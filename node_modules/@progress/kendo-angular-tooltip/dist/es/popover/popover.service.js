/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Injectable, NgZone } from '@angular/core';
import { BehaviorSubject, combineLatest, Subject, Subscription } from 'rxjs';
import { auditTime } from 'rxjs/operators';
/**
 * @hidden
 */
var PopoverService = /** @class */ (function () {
    function PopoverService(ngZone) {
        this.ngZone = ngZone;
        this._pointerOverPopup = new BehaviorSubject(null);
        this._pointerOverAnchor = new BehaviorSubject(null);
        this._focusInsidePopover = new BehaviorSubject(null);
        this._hidePopover = new Subject();
        this.subs = new Subscription();
        this.monitor();
    }
    PopoverService.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    Object.defineProperty(PopoverService.prototype, "isPopoverHovered", {
        get: function () {
            return this._pointerOverPopup.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    PopoverService.prototype.emitPopoverState = function (isHovered) {
        var _this = this;
        this.ngZone.run(function (_) { return _this._pointerOverPopup.next(isHovered); });
    };
    Object.defineProperty(PopoverService.prototype, "isAnchorHovered", {
        get: function () {
            return this._pointerOverAnchor.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    PopoverService.prototype.emitAnchorState = function (isHovered, anchor) {
        var _this = this;
        this._isOrigin = this.originAnchor === anchor;
        this.currentAnchor = anchor;
        if (isHovered) {
            this.originAnchor = anchor;
        }
        this.ngZone.run(function (_) { return _this._pointerOverAnchor.next(isHovered); });
    };
    Object.defineProperty(PopoverService.prototype, "isFocusInsidePopover", {
        get: function () {
            return this._focusInsidePopover.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    PopoverService.prototype.emitFocusInsidePopover = function (isFocused) {
        var _this = this;
        this.ngZone.run(function (_) { return _this._focusInsidePopover.next(isFocused); });
        this._focusInsidePopover.next(null);
    };
    Object.defineProperty(PopoverService.prototype, "hidePopover", {
        get: function () {
            return this._hidePopover.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    PopoverService.prototype.monitor = function () {
        var _this = this;
        this.subs.add(combineLatest(this.isPopoverHovered, this.isAnchorHovered).pipe(
        // `auditTime` is used because the `mouseleave` event is emitted before `mouseenter`
        // i.e. there is a millisecond in which the pointer leaves the first target (e.g. anchor) and hasn't reached the second one (e.g. popup)
        // resulting in both observables emitting `false`
        auditTime(20)).subscribe(function (val) {
            var isPopoverHovered = val[0], isAnchorHovered = val[1];
            _this._hidePopover.next([isPopoverHovered, isAnchorHovered, _this._isOrigin, _this.currentAnchor]);
        }));
    };
    PopoverService = tslib_1.__decorate([
        Injectable(),
        tslib_1.__metadata("design:paramtypes", [NgZone])
    ], PopoverService);
    return PopoverService;
}());
export { PopoverService };
