/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Directive, ElementRef, Input, NgZone, Renderer2 } from "@angular/core";
import { closest } from "@progress/kendo-angular-common";
import { PopupService } from "@progress/kendo-angular-popup";
import { filter, take } from "rxjs/operators";
import { closestBySelector } from "../utils";
import { PopoverDirectivesBase } from './directives-base';
import { PopoverService } from "./popover.service";
/**
 * Represents the [`kendoPopoverContainer`]({% slug configuration_popover %}#toc-containerdirective) directive.
 * It is used to filter and target multiple elements, which should display a popover on interaction.
 *
 * @example
 * ```ts-no-run
 * <div kendoPopoverContainer [popover]="myPopover" filter=".has-popover">
 *     <button class="has-popover">Show Popover</button>
 *     <button>Button Without Popover</button>
 *     <button class="has-popover">Show Popover</button>
 * </div>
 * ```
 */
var PopoverContainerDirective = /** @class */ (function (_super) {
    tslib_1.__extends(PopoverContainerDirective, _super);
    function PopoverContainerDirective(wrapperEl, ngZone, popupService, renderer, popoverService) {
        var _this = _super.call(this, ngZone, popupService, renderer) || this;
        _this.wrapperEl = wrapperEl;
        _this.ngZone = ngZone;
        _this.popupService = popupService;
        _this.renderer = renderer;
        _this.popoverService = popoverService;
        _this.mouseenterHandler = function (anchor) {
            _this.controlVisibility(anchor, true);
        };
        _this.mouseleaveHandler = function (args) {
            var anchor = args.anchor;
            if (_this.isPrevented(anchor, false)) {
                return;
            }
            if (!_this._hideSub) {
                _this._hideSub = _this.popoverService.hidePopover.subscribe(function (val) {
                    var isPopoverHovered = val[0], isOriginAnchor = val[2], currentAnchor = val[3];
                    if (!isPopoverHovered && !isOriginAnchor) {
                        _this.hide();
                        if (!isOriginAnchor && currentAnchor) {
                            _this.show(currentAnchor);
                        }
                    }
                });
            }
        };
        _this.focusHandler = function (anchor) {
            _this.controlVisibility(anchor, true);
        };
        _this.blurHandler = function (args) {
            var anchor = args.anchor;
            var event = args.domEvent;
            if (_this.isPrevented(anchor, false)) {
                return;
            }
            // from anchor to popup focus check
            var isFocusInside = !!closest(event.relatedTarget, function (node) { return node.classList && node.classList.contains('k-popover'); });
            if (!isFocusInside) {
                _this.hide();
            }
            if (!_this._focusInsideSub) {
                // inside popup focus check
                _this._focusInsideSub = _this.popoverService.isFocusInsidePopover.pipe(filter(function (v) { return v !== null; })).subscribe(function (val) {
                    if (!val && !isFocusInside) {
                        _this.hide();
                    }
                });
            }
        };
        _this._popoverService = _this.popoverService;
        return _this;
    }
    /**
     * Shows the Popover.
     *
     * @param anchor&mdash;Specifies the element that will be used as an anchor. The Popover opens relative to that element. [See example]({% slug programmaticcontrol_popover %})
     */
    PopoverContainerDirective.prototype.show = function (anchor) {
        var _this = this;
        if (this.popupRef) {
            return;
        }
        this.ngZone.run(function () {
            _this.openPopup(anchor);
        });
        this.popupRef.popupAnchorViewportLeave
            .pipe(take(1))
            .subscribe(function () { return _this.hide(); });
    };
    /**
     * Toggles the visibility of the Popover. [See example]({% slug programmaticcontrol_popover %})
     *
     * @param anchor&mdash;Specifies the element that will be used as an anchor. The Popover opens relative to that element.
     */
    PopoverContainerDirective.prototype.toggle = function (anchor) {
        var previousAnchor = this.popupRef && this.popupRef.content.instance.anchor;
        if (this.popupRef) {
            this.hide();
            if (previousAnchor !== anchor) {
                this.show(anchor);
            }
        }
        else {
            this.show(anchor);
        }
    };
    PopoverContainerDirective.prototype.subscribeClick = function () {
        var _this = this;
        if (this.disposeClickListener) {
            this.disposeClickListener();
        }
        this.disposeClickListener = this.renderer.listen(document, 'click', function (e) {
            var filterElement = closestBySelector(e.target, _this.filter);
            _this.clickHandler(filterElement, e);
        });
    };
    PopoverContainerDirective.prototype.subscribeToEvents = function (arr) {
        var _this = this;
        var filteredElements = Array.from(document.querySelectorAll(this.filter));
        filteredElements.forEach(function (el) {
            _this.subs.add(_this.renderer.listen(el, arr[0].name, function () {
                _this.popoverService.emitAnchorState(true, el);
                arr[0].handler(el);
            }));
            _this.subs.add(_this.renderer.listen(el, arr[1].name, function (e) {
                _this.popoverService.emitAnchorState(false, null);
                arr[1].handler({ anchor: el, domEvent: e });
            }));
        });
    };
    PopoverContainerDirective.prototype.clickHandler = function (anchor, event) {
        var isInsidePopup = !!closest(event.target, function (node) { return node.classList && node.classList.contains('k-popup'); });
        var popupRefAnchor = this.popupRef && this.popupRef.content.instance.anchor;
        var isOriginAnchor = !!closest(event.target, function (node) { return node === (popupRefAnchor ? popupRefAnchor : anchor); });
        if (this.showOn !== 'click' || isInsidePopup || (this.popupRef && isOriginAnchor)) {
            return;
        }
        if (!anchor && this.popupRef) {
            this.controlVisibility(anchor, false);
            return;
        }
        if (isOriginAnchor) {
            this.controlVisibility(anchor, true);
        }
        else if (this.popupRef) {
            this.controlVisibility(anchor, false);
            this.controlVisibility(anchor, true);
        }
    };
    PopoverContainerDirective.prototype.controlVisibility = function (anchor, show) {
        if (this.isPrevented(anchor, show)) {
            return;
        }
        show ? this.show(anchor) : this.hide();
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], PopoverContainerDirective.prototype, "filter", void 0);
    PopoverContainerDirective = tslib_1.__decorate([
        Directive({
            selector: '[kendoPopoverContainer]',
            exportAs: 'kendoPopoverContainer',
            providers: [PopoverService]
        }),
        tslib_1.__metadata("design:paramtypes", [ElementRef,
            NgZone,
            PopupService,
            Renderer2,
            PopoverService])
    ], PopoverContainerDirective);
    return PopoverContainerDirective;
}(PopoverDirectivesBase));
export { PopoverContainerDirective };
