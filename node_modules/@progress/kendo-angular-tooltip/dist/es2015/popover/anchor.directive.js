/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Directive, ElementRef, NgZone, Renderer2 } from "@angular/core";
import { closest } from "@progress/kendo-angular-common";
import { PopupService } from "@progress/kendo-angular-popup";
import { filter, take } from "rxjs/operators";
import { PopoverDirectivesBase } from "./directives-base";
import { PopoverService } from "./popover.service";
/**
 * Represents the [`kendoPopoverAnchor`]({% slug configuration_popover %}#toc-anchordirective) directive.
 * It is used to target an element, which should display a popover on interaction.
 *
 * @example
 * ```ts-no-run
 * <button kendoPopoverAnchor [popover]="myPopover">Show Popover</button>
 * ```
 */
let PopoverAnchorDirective = class PopoverAnchorDirective extends PopoverDirectivesBase {
    constructor(hostEl, ngZone, popupService, renderer, popoverService) {
        super(ngZone, popupService, renderer);
        this.hostEl = hostEl;
        this.ngZone = ngZone;
        this.popupService = popupService;
        this.renderer = renderer;
        this.popoverService = popoverService;
        this.mouseenterHandler = () => {
            this.controlVisibility(this.hostEl.nativeElement, true);
        };
        this.mouseleaveHandler = () => {
            if (this.isPrevented(this.hostEl.nativeElement, false)) {
                return;
            }
            if (!this._hideSub) {
                this._hideSub = this.popoverService.hidePopover.subscribe((val) => {
                    const [isPopoverHovered, isAnchorHovered] = val;
                    if (!isPopoverHovered && !isAnchorHovered) {
                        this.hide();
                    }
                });
            }
        };
        this.focusHandler = () => {
            this.controlVisibility(this.hostEl.nativeElement, true);
        };
        this.blurHandler = (args) => {
            const event = args.domEvent;
            if (this.isPrevented(this.hostEl.nativeElement, false)) {
                return;
            }
            // from anchor to popup focus check
            const isFocusInside = !!closest(event.relatedTarget, (node) => node.classList && node.classList.contains('k-popover'));
            if (!isFocusInside) {
                this.hide();
            }
            if (!this._focusInsideSub) {
                // inside popup focus check
                this._focusInsideSub = this.popoverService.isFocusInsidePopover.pipe(filter(v => v !== null)).subscribe((val) => {
                    if (!val) {
                        this.hide();
                    }
                });
            }
        };
        this._popoverService = this.popoverService;
    }
    /**
     * Shows the Popover. [See example]({% slug programmaticcontrol_popover %})
     */
    show() {
        if (this.popupRef) {
            return;
        }
        this.ngZone.run(() => {
            this.openPopup(this.hostEl);
        });
        this.popupRef.popupAnchorViewportLeave
            .pipe(take(1))
            .subscribe(() => this.hide());
    }
    /**
     * Toggles the visibility of the Popover. [See example]({% slug programmaticcontrol_popover %})
     */
    toggle() {
        if (this.popupRef) {
            this.hide();
        }
        else {
            this.show();
        }
    }
    subscribeToEvents(arr) {
        this.subs.add(this.renderer.listen(this.hostEl.nativeElement, arr[0].name, () => {
            this.popoverService.emitAnchorState(true, this.hostEl.nativeElement);
            arr[0].handler();
        }));
        this.subs.add(this.renderer.listen(this.hostEl.nativeElement, arr[1].name, (e) => {
            this.popoverService.emitAnchorState(false, null);
            arr[1].handler({ domEvent: e });
        }));
    }
    subscribeClick() {
        if (this.disposeClickListener) {
            this.disposeClickListener();
        }
        this.disposeClickListener = this.renderer.listen(document, 'click', (e) => {
            this.onClick(e);
        });
    }
    /**
     * @hidden
     */
    onClick(event) {
        const isInsidePopup = !!closest(event.target, (node) => node.classList && node.classList.contains('k-popup'));
        let isAnchor = !!closest(event.target, (node) => node === this.hostEl.nativeElement);
        if (isInsidePopup || (this.popupRef && isAnchor)) {
            return;
        }
        if (isAnchor) {
            // on opening
            this.controlVisibility(this.hostEl.nativeElement, true);
        }
        else {
            // on closing
            this.controlVisibility(this.hostEl.nativeElement, false);
        }
    }
    controlVisibility(anchor, show) {
        if (this.isPrevented(anchor, show)) {
            return;
        }
        show ? this.show() : this.hide();
    }
};
PopoverAnchorDirective = tslib_1.__decorate([
    Directive({
        selector: '[kendoPopoverAnchor]',
        exportAs: 'kendoPopoverAnchor',
        providers: [PopoverService]
    }),
    tslib_1.__metadata("design:paramtypes", [ElementRef,
        NgZone,
        PopupService,
        Renderer2,
        PopoverService])
], PopoverAnchorDirective);
export { PopoverAnchorDirective };
