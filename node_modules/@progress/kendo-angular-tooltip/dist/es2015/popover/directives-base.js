/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { ElementRef, Input, isDevMode } from "@angular/core";
import { closest, hasObservers, isDocumentAvailable } from "@progress/kendo-angular-common";
import { ERRORS } from '../constants';
import { PopoverHideEvent, PopoverShowEvent, PopoverShownEvent, PopoverHiddenEvent } from "../models/events";
import { align, containsItem } from "../utils";
import { PopoverComponent } from "./popover.component";
import { Subscription } from "rxjs";
const validShowOptions = ['hover', 'click', 'none', 'focus'];
/**
 * @hidden
 */
export class PopoverDirectivesBase {
    constructor(ngZone, popupService, renderer) {
        this.ngZone = ngZone;
        this.popupService = popupService;
        this.renderer = renderer;
        this.subs = new Subscription();
        this._showOn = 'click';
    }
    /**
     * Specifies the popover instance that will be rendered.
     * Accepts a [`PopoverComponent`]({% slug api_tooltip_popovercomponent %}) instance or
     * a [`PopoverFn`]({% slug api_tooltip_popoverfn %}) callback which returns a [`PopoverComponent`]({% slug api_tooltip_popovercomponent %}) instance
     * depending on the current anchor element.
     *
     * [See example]({% slug templates_popover %}#toc-popovercallback)
     */
    set popover(value) {
        if (value instanceof PopoverComponent || typeof value === `function`) {
            this._popover = value;
        }
        else {
            if (isDevMode) {
                throw new Error(ERRORS.popover);
            }
        }
    }
    get popover() {
        return this._popover;
    }
    /**
     * The event on which the Popover will be shown
     *
     * The supported values are:
     * - `click` (default) &mdash;The Popover will be shown when its `anchor` element is clicked.
     * - `hover`&mdash;The Popover will be shown when its `anchor` element is hovered.
     * - `focus`&mdash;The Popover will be shown when its `anchor` element is focused.
     * - `none`&mdash;The Popover will not be shown on user interaction. It could be rendered via the Popover API methods.
     */
    set showOn(value) {
        if (isDevMode && !containsItem(validShowOptions, value)) {
            throw new Error(ERRORS.showOn);
        }
        this._showOn = value;
    }
    get showOn() {
        return this._showOn;
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            switch (this.showOn) {
                case 'hover':
                    this.subscribeToEvents([{
                            name: 'mouseenter', handler: this.mouseenterHandler
                        }, {
                            name: 'mouseleave', handler: this.mouseleaveHandler
                        }]);
                    break;
                case 'focus':
                    this.subscribeToEvents([{
                            name: 'focus', handler: this.focusHandler
                        }, {
                            name: 'blur', handler: this.blurHandler
                        }]);
                    break;
                case 'click':
                    this.subscribeClick();
                    break;
                default:
                    break;
            }
        });
    }
    ngOnDestroy() {
        this.closePopup();
        if (this.disposeHoverOverListener) {
            this.disposeHoverOverListener();
        }
        if (this.disposeHoverOutListener) {
            this.disposeHoverOutListener();
        }
        if (this.disposeClickListener) {
            this.disposeClickListener();
        }
        if (this._focusInsideSub) {
            this._focusInsideSub.unsubscribe();
        }
        if (this._hideSub) {
            this._hideSub.unsubscribe();
        }
        if (this.subs) {
            this.subs.unsubscribe();
        }
        if (this._popupOpenSub) {
            this._popupOpenSub.unsubscribe();
        }
        if (this._popupCloseSub) {
            this._popupCloseSub.unsubscribe();
        }
    }
    /**
     * Hides the Popover ([See example]({% slug programmaticcontrol_popover %})).
     */
    hide() {
        this.closePopup();
    }
    /**
     * @hidden
     */
    closePopup() {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
            if (this.disposePopupHoverOutListener) {
                this.disposePopupHoverOutListener();
            }
            if (this.disposePopupHoverInListener) {
                this.disposePopupHoverInListener();
            }
            if (this.disposePopupFocusOutListener) {
                this.disposePopupFocusOutListener();
            }
        }
    }
    /**
     * @hidden
     */
    openPopup(anchor) {
        const _anchor = anchor instanceof ElementRef ? anchor.nativeElement : anchor;
        const popoverComp = this.popover instanceof PopoverComponent ? this.popover : this.popover(_anchor);
        const alignSettings = align(popoverComp.position, popoverComp.offset);
        const anchorAlign = alignSettings.anchorAlign;
        const popupAlign = alignSettings.popupAlign;
        const popupMargin = alignSettings.popupMargin;
        const _animation = popoverComp.animation;
        this.popupRef = this.popupService.open({
            anchor: { nativeElement: _anchor },
            animate: _animation,
            content: PopoverComponent,
            popupAlign,
            anchorAlign,
            margin: popupMargin,
            popupClass: 'k-popup-transparent',
            collision: { horizontal: 'fit', vertical: 'fit' }
        });
        this.applySettings(this.popupRef.content, popoverComp, anchor);
        this.monitorPopup();
        this.initializeCompletionEvents(popoverComp, _anchor);
    }
    /**
     * @hidden
     */
    isPrevented(anchorElement, show) {
        const popoverComp = this.popover instanceof PopoverComponent ? this.popover : this.popover(anchorElement);
        let eventArgs;
        eventArgs = this.initializeEvents(popoverComp, eventArgs, show, anchorElement);
        return eventArgs.isDefaultPrevented();
    }
    /**
     * @hidden
     */
    monitorPopup() {
        if (this.showOn === 'hover') {
            this.ngZone.runOutsideAngular(() => {
                const popup = this.popupRef.popupElement;
                this.disposePopupHoverInListener = this.renderer.listen(popup, 'mouseenter', _ => {
                    this.ngZone.run(_ => this._popoverService.emitPopoverState(true));
                });
                this.disposePopupHoverOutListener = this.renderer.listen(popup, 'mouseleave', _ => {
                    this.ngZone.run(_ => this._popoverService.emitPopoverState(false));
                });
            });
        }
        if (this.showOn === 'focus') {
            this.ngZone.runOutsideAngular(() => {
                const popup = this.popupRef.popupElement;
                this.disposePopupFocusOutListener = this.renderer.listen(popup, 'focusout', (e) => {
                    const isInsidePopover = closest(e.relatedTarget, (node) => node.classList && node.classList.contains('k-popover'));
                    if (!isInsidePopover) {
                        this.ngZone.run(_ => this._popoverService.emitFocusInsidePopover(false));
                    }
                });
            });
        }
    }
    applySettings(contentComponent, popover, anchor) {
        const content = contentComponent.instance;
        const _anchor = anchor instanceof ElementRef ? anchor.nativeElement : anchor;
        content.visible = true;
        content.anchor = _anchor;
        content.position = popover.position;
        content.offset = popover.offset;
        content.width = popover.width;
        content.height = popover.height;
        content.title = popover.title;
        content.body = popover.body;
        content.callout = popover.callout;
        content.animation = popover.animation;
        content.contextData = popover.templateData(_anchor);
        content.titleTemplate = popover.titleTemplate;
        content.bodyTemplate = popover.bodyTemplate;
        content.actionsTemplate = popover.actionsTemplate;
        this.popupRef.content.changeDetectorRef.detectChanges();
    }
    /**
     * @hidden
     */
    initializeEvents(popoverComp, eventArgs, show, anchorElement) {
        if (show) {
            eventArgs = new PopoverShowEvent(anchorElement);
            if (this.shouldEmitEvent(!!this.popupRef, 'show', popoverComp)) {
                this.ngZone.run(() => popoverComp.show.emit(eventArgs));
            }
        }
        else {
            eventArgs = new PopoverHideEvent(anchorElement, this.popupRef);
            if (this.shouldEmitEvent(!!this.popupRef, 'hide', popoverComp)) {
                this.ngZone.run(() => popoverComp.hide.emit(eventArgs));
            }
        }
        return eventArgs;
    }
    initializeCompletionEvents(popoverComp, _anchor) {
        if (this.shouldEmitCompletionEvents('shown', popoverComp)) {
            this.popupRef.popupOpen.subscribe(() => {
                const eventArgs = new PopoverShownEvent(_anchor, this.popupRef);
                popoverComp.shown.emit(eventArgs);
            });
        }
        if (this.shouldEmitCompletionEvents('hidden', popoverComp)) {
            this.popupRef.popupClose.subscribe(() => {
                this.ngZone.run(_ => {
                    const eventArgs = new PopoverHiddenEvent(_anchor);
                    popoverComp.hidden.emit(eventArgs);
                });
            });
        }
    }
    shouldEmitEvent(hasPopup, event, popoverComp) {
        if ((event === 'show' && !hasPopup && hasObservers(popoverComp[event]))
            || (event === 'hide' && hasPopup && hasObservers(popoverComp[event]))) {
            return true;
        }
        return false;
    }
    shouldEmitCompletionEvents(event, popoverComp) {
        if ((hasObservers(popoverComp[event]) && !this._popupOpenSub)
            || (hasObservers(popoverComp[event]) && !this._popupCloseSub)) {
            return true;
        }
        return false;
    }
}
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], PopoverDirectivesBase.prototype, "popover", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], PopoverDirectivesBase.prototype, "showOn", null);
