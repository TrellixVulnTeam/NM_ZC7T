/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param, __extends } from 'tslib';
import { InjectionToken, Injectable, HostBinding, Output, EventEmitter, Input, TemplateRef, ElementRef, Component, isDevMode, Directive, Optional, Inject, NgZone, Renderer2, ContentChild, forwardRef, NgModule } from '@angular/core';
import { take, filter, debounceTime, auditTime } from 'rxjs/operators';
import { fromEvent, Subscription, combineLatest, BehaviorSubject, Subject } from 'rxjs';
import { PopupService, PopupModule } from '@progress/kendo-angular-popup';
import { validatePackage } from '@progress/kendo-licensing';
import { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';
import { PreventableEvent, isDocumentAvailable, closest, hasObservers } from '@progress/kendo-angular-common';
import { CommonModule } from '@angular/common';

/**
 * @hidden
 */
var packageMetadata = {
    name: '@progress/kendo-angular-tooltip',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1646219971,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * Obsolete. Provide the TooltipSettings class instead.
 *
 * @hidden
 */
var TOOLTIP_SETTINGS = new InjectionToken('kendo-ui-tooltip-settings');
/**
 * Provides a global configuration for the Kendo UI Tooltip. Once injected through
 * the `AppComponent` constructor, the configuration properties can be overridden.
 *
 * @example
 * ```ts-no-run
 * import { TooltipSettings } from '@progress/kendo-angular-tooltip';
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *      <div kendoTooltip>
 *          <button title="Saves the current document">Save</button>
 *      </div>`,
 *    providers: [{
 *        provide: TooltipSettings,
 *        useFactory: (): TooltipSettings => ({
 *          // Override default values of tooltips if wanted
 *          position: 'right'
 *        })
 *    }]
 * })
 * export class AppComponent { }
 * ```
 */
var TooltipSettings = /** @class */ (function () {
    function TooltipSettings() {
    }
    TooltipSettings = __decorate([
        Injectable()
    ], TooltipSettings);
    return TooltipSettings;
}());

/**
 * @hidden
 */
function align(position, offset) {
    var anchorAlign = {};
    var popupAlign = {};
    var popupMargin = {};
    switch (position) {
        case 'top':
            anchorAlign = { horizontal: 'center', vertical: 'top' };
            popupAlign = { horizontal: 'center', vertical: 'bottom' };
            popupMargin = { horizontal: 0, vertical: offset };
            break;
        case 'bottom':
            anchorAlign = { horizontal: 'center', vertical: 'bottom' };
            popupAlign = { horizontal: 'center', vertical: 'top' };
            popupMargin = { horizontal: 0, vertical: offset };
            break;
        case 'right':
            anchorAlign = { horizontal: 'right', vertical: 'center' };
            popupAlign = { horizontal: 'left', vertical: 'center' };
            popupMargin = { horizontal: offset, vertical: 0 };
            break;
        case 'left':
            anchorAlign = { horizontal: 'left', vertical: 'center' };
            popupAlign = { horizontal: 'right', vertical: 'center' };
            popupMargin = { horizontal: offset, vertical: 0 };
            break;
        default: break;
    }
    return {
        anchorAlign: anchorAlign,
        popupAlign: popupAlign,
        popupMargin: popupMargin
    };
}
/**
 * @hidden
 */
function collision(inputcollision, position) {
    if (inputcollision) {
        return inputcollision;
    }
    if (position === 'top' || position === 'bottom') {
        return { horizontal: 'fit', vertical: 'flip' };
    }
    return { horizontal: 'flip', vertical: 'fit' };
}
function isDocumentNode(container) {
    return container.nodeType === 9;
}
/**
 * @hidden
 */
function closestBySelector(element, selector) {
    if (element.closest) {
        return element.closest(selector);
    }
    var matches = Element.prototype.matches ?
        function (el, sel) { return el.matches(sel); }
        : function (el, sel) { return el.msMatchesSelector(sel); };
    var node = element;
    while (node && !isDocumentNode(node)) {
        if (matches(node, selector)) {
            return node;
        }
        node = node.parentNode;
    }
}
/**
 * @hidden
 */
function contains(container, child) {
    if (!container) {
        return false;
    }
    if (isDocumentNode(container)) {
        return false;
    }
    if (container.contains) {
        return container.contains(child);
    }
    if (container.compareDocumentPosition) {
        // tslint:disable-next-line
        return !!(container.compareDocumentPosition(child) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    }
}
/**
 * @hidden
 */
var hasParent = function (node, parent) {
    while (node && node !== parent) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
function getCenterOffset(item, dir, size) {
    var rect = item.getBoundingClientRect();
    return rect[dir] + (rect[size] / 2);
}
/**
 * @hidden
 */
function containsItem(collection, item) {
    return collection.indexOf(item) !== -1;
}

/**
 * @hidden
 */
var TooltipContentComponent = /** @class */ (function () {
    function TooltipContentComponent(content, localizationService) {
        this.content = content;
        this.localizationService = localizationService;
        this.close = new EventEmitter();
        this.tooltipWidth = null;
        this.tooltipHeight = null;
        this.callout = true;
        this.calloutStyles = function (position, calloutSize, isFlip) {
            var styles = {};
            var isVertical = position === 'top' || position === 'bottom';
            var flipDeg = '180deg';
            var zeroDeg = '0deg';
            if (!isFlip) {
                styles.transform = isVertical ? "rotateX(" + zeroDeg + ")" : "rotateY(" + zeroDeg + ")";
                return styles;
            }
            if (position === 'top') {
                styles.bottom = 'unset';
            }
            else if (position === 'bottom') {
                styles.top = 'unset';
            }
            else if (position === 'left') {
                styles.right = 'unset';
            }
            else if (position === 'right') {
                styles.left = 'unset';
            }
            styles[position] = -calloutSize + "px";
            styles.transform = isVertical ? "rotateX(" + flipDeg + ")" : "rotateY(" + flipDeg + ")";
            return styles;
        };
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    Object.defineProperty(TooltipContentComponent.prototype, "cssClasses", {
        get: function () {
            return 'k-widget k-tooltip';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipContentComponent.prototype, "className", {
        get: function () {
            return this.closable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipContentComponent.prototype, "cssPosition", {
        get: function () {
            return 'relative';
        },
        enumerable: true,
        configurable: true
    });
    TooltipContentComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.dynamicRTLSubscription = this.localizationService.changes
            .subscribe(function (_a) {
            var rtl = _a.rtl;
            return _this.direction = rtl ? 'rtl' : 'ltr';
        });
    };
    TooltipContentComponent.prototype.ngOnDestroy = function () {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    };
    Object.defineProperty(TooltipContentComponent.prototype, "closeButtonTitle", {
        get: function () {
            return this.closeTitle || this.localizationService.get('closeTitle');
        },
        enumerable: true,
        configurable: true
    });
    TooltipContentComponent.prototype.calloutPositionClass = function () {
        return {
            'top': 'k-callout-s',
            'left': 'k-callout-e',
            'bottom': 'k-callout-n',
            'right': 'k-callout-w'
        }[this.position];
    };
    TooltipContentComponent.prototype.onCloseClick = function (event) {
        event.preventDefault();
        this.close.emit();
    };
    TooltipContentComponent.prototype.updateCalloutPosition = function (position, isFlip) {
        if (!this.callout) {
            return;
        }
        var callout = this.content.nativeElement.querySelector('.k-callout');
        var isVertical = position === 'top' || position === 'bottom';
        var size = isVertical ? 'width' : 'height';
        var dir = isVertical ? 'left' : 'top';
        var offsetProperty = isVertical ? 'marginLeft' : 'marginTop';
        var calloutSize = callout.getBoundingClientRect()[size];
        var anchorCenter = getCenterOffset(this.anchor.nativeElement, dir, size);
        var contentCenter = getCenterOffset(this.content.nativeElement, dir, size);
        var diff = Math.abs(contentCenter - anchorCenter);
        if (diff > 1 || diff === 0 || Math.round(diff) === 0) {
            var newMargin = contentCenter - anchorCenter + (calloutSize / 2);
            callout.style[offsetProperty] = -newMargin + "px";
        }
        var calloutStyles = this.calloutStyles(position, calloutSize, isFlip);
        Object.keys(calloutStyles).forEach(function (style) {
            callout.style[style] = calloutStyles[style];
        });
    };
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], TooltipContentComponent.prototype, "direction", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TooltipContentComponent.prototype, "close", void 0);
    __decorate([
        HostBinding('class'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TooltipContentComponent.prototype, "cssClasses", null);
    __decorate([
        HostBinding('class.k-tooltip-closable'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TooltipContentComponent.prototype, "className", null);
    __decorate([
        HostBinding('style.position'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TooltipContentComponent.prototype, "cssPosition", null);
    __decorate([
        HostBinding('style.width.px'),
        Input(),
        __metadata("design:type", Number)
    ], TooltipContentComponent.prototype, "tooltipWidth", void 0);
    __decorate([
        HostBinding('style.height.px'),
        Input(),
        __metadata("design:type", Number)
    ], TooltipContentComponent.prototype, "tooltipHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], TooltipContentComponent.prototype, "titleTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", ElementRef)
    ], TooltipContentComponent.prototype, "anchor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipContentComponent.prototype, "closable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], TooltipContentComponent.prototype, "templateRef", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipContentComponent.prototype, "templateString", void 0);
    TooltipContentComponent = __decorate([
        Component({
            selector: 'kendo-tooltip',
            template: "\n        <ng-container kendoTooltipLocalizedMessages\n            i18n-closeTitle=\"kendo.tooltip.closeTitle|The title of the close button\"\n            closeTitle=\"Close\"\n        >\n        </ng-container>\n\n        <div class=\"k-tooltip-content\">\n            <div class=\"k-tooltip-title\" *ngIf=\"titleTemplate\">\n                <ng-template\n                    [ngIf]=\"titleTemplate\"\n                    [ngTemplateOutlet]=\"titleTemplate\"\n                    [ngTemplateOutletContext]=\"{ $implicit: anchor, anchor: anchor }\">\n                </ng-template>\n            </div>\n\n            <ng-template\n                [ngIf]=\"templateRef\"\n                [ngTemplateOutlet]=\"templateRef\"\n                [ngTemplateOutletContext]=\"{ $implicit: anchor, anchor: anchor }\">\n            </ng-template>\n            <ng-template\n                [ngIf]=\"templateString\">\n                {{ templateString }}\n            </ng-template>\n        </div>\n\n        <div *ngIf=\"closable\" class=\"k-tooltip-button\" (click)=\"onCloseClick($event)\">\n            <a href=\"#\" class=\"k-icon k-i-close\" [attr.title]=\"closeButtonTitle\"></a>\n        </div>\n\n        <div class=\"k-callout\" *ngIf=\"callout\" [ngClass]=\"calloutPositionClass()\"></div>\n    ",
            providers: [
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.tooltip'
                }
            ]
        }),
        __metadata("design:paramtypes", [ElementRef,
            LocalizationService])
    ], TooltipContentComponent);
    return TooltipContentComponent;
}());

/**
 * Represents the [Kendo UI Tooltip directive for Angular]({% slug overview_tooltip %}).
 * Used to display additional information that is related to an element.
 *
 * @example
 * ```ts-no-run
 * <div kendoTooltip>
 *    <a title="Tooltip title" href="foo">foo</a>
 * </div>
 * ```
 */
var TooltipDirective = /** @class */ (function () {
    function TooltipDirective(tooltipWrapper, ngZone, renderer, popupService, settings, legacySettings) {
        var _this = this;
        this.tooltipWrapper = tooltipWrapper;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.popupService = popupService;
        /**
         * Specifies a selector for elements within a container which will display a tooltip
         * ([see example]({% slug anchorelements_tooltip %})). The possible values include any
         * DOM `selector`. The default value is `[title]`.
         */
        this.filter = '[title]';
        /**
         * Specifies the position of the Tooltip that is relative to the
         * anchor element ([see example]({% slug positioning_tooltip %})).
         *
         * The possible values are:
         * * `top` (default)
         * * `bottom`
         * * `left`
         * * `right`
         */
        this.position = 'top';
        /**
         * Specifies the delay in milliseconds before the Tooltip is shown.
         * * `100` (default) milliseconds.
         */
        this.showAfter = 100;
        /**
         * Specifies if the Ð¢ooltip will display a callout arrow.
         *
         * The possible values are:
         * * `true` (default)
         * * `false`
         */
        this.callout = true;
        /**
         * Specifies if the Ð¢ooltip will display a **Close** button
         * ([see example]({% slug closable_tooltip %})).
         *
         * The possible values are:
         * * `true`
         * * `false`
         */
        this.closable = false;
        /**
         * Specifies the offset in pixels between the Tooltip and the anchor. Defaults to `6` pixels.
         * If the `callout` property is set to `true`, the offset is rendered from the callout arrow.
         * If the `callout` property is set to `false`, the offset is rendered from the content of the Tooltip.
         */
        this.offset = 6;
        this.anchor = null;
        this.validPositions = ['top', 'bottom', 'right', 'left'];
        this.validShowOptions = ['hover', 'click', 'none'];
        validatePackage(packageMetadata);
        Object.assign(this, settings, legacySettings);
        this.ngZone.runOutsideAngular(function () {
            var wrapper = _this.tooltipWrapper.nativeElement;
            _this.anchorTitleSubscription = fromEvent(wrapper, 'mouseover')
                .pipe(filter(function () { return _this.filter !== ''; }))
                .subscribe(function (e) {
                var filterElement = closestBySelector(e.target, _this.filter);
                if (filterElement) {
                    _this.hideElementTitle({ nativeElement: filterElement });
                }
            });
            _this.mouseOverSubscription = fromEvent(wrapper, 'mouseover')
                .pipe(debounceTime(100), filter(function () { return _this.filter !== ''; }))
                .subscribe(function (e) { return _this.onMouseOver(e); });
            _this.mouseOutSubscription = fromEvent(wrapper, 'mouseout')
                .pipe(debounceTime(100))
                .subscribe(function (e) { return _this.onMouseOut(e); });
        });
    }
    Object.defineProperty(TooltipDirective.prototype, "tooltipTemplate", {
        get: function () { return this.template; },
        /**
         * Sets the content of the Tooltip as a template reference
         * ([see example]({% slug templates_tooltip %})).
         */
        set: function (value) {
            this.template = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows the Tooltip.
     * @param anchor&mdash; ElementRef|Element.
     * Specifies the element that will be used as an anchor. The Tooltip opens relative to that element.
     */
    TooltipDirective.prototype.show = function (anchor) {
        var _this = this;
        if (this.popupRef) {
            return;
        }
        if (anchor instanceof Element) {
            anchor = { nativeElement: anchor };
        }
        this.anchor = anchor;
        if (this.showOn === 'hover') {
            if (this.popupRef) {
                return;
            }
            clearTimeout(this.showTimeout);
            this.showTimeout = window.setTimeout(function () { return _this.showContent(_this.anchor); }, this.showAfter);
        }
        else {
            this.hideElementTitle(this.anchor);
            this.showContent(this.anchor);
        }
    };
    /**
     * Hides the Tooltip.
     */
    TooltipDirective.prototype.hide = function () {
        clearTimeout(this.showTimeout);
        var anchor = this.anchor && this.anchor.nativeElement;
        if (anchor && anchor.getAttribute('data-title')) {
            if (!anchor.getAttribute('title') && anchor.hasAttribute('title')) {
                anchor.setAttribute('title', anchor.getAttribute('data-title'));
            }
            anchor.setAttribute('data-title', '');
        }
        if (this.popupMouseOutSubscription) {
            this.popupMouseOutSubscription.unsubscribe();
        }
        if (this.closeClickSubscription) {
            this.closeClickSubscription.unsubscribe();
        }
        this.closePopup();
    };
    /**
     * Toggle visibility of the Tooltip.
     *
     * @param anchor&mdash; ElementRef|Element. Specifies the element that will be used as an anchor.
     * @param show&mdash; Optional. Boolean. Specifies if the Tooltip will be rendered.
     */
    TooltipDirective.prototype.toggle = function (anchor, show) {
        var previousAnchor = this.anchor && this.anchor.nativeElement;
        if (anchor instanceof Element) {
            anchor = { nativeElement: anchor };
        }
        if (previousAnchor !== anchor.nativeElement) {
            this.hide();
        }
        if (previousAnchor === anchor.nativeElement && this.showOn === 'click') {
            this.hide();
        }
        if (typeof show === 'undefined') {
            show = !this.popupRef;
        }
        if (show) {
            this.show(anchor);
        }
        else {
            this.hide();
        }
    };
    TooltipDirective.prototype.ngOnInit = function () {
        if (this.showOn === undefined) {
            this.showOn = 'hover';
        }
        this.verifyProperties();
    };
    TooltipDirective.prototype.ngOnChanges = function (changes) {
        if (changes.showOn) {
            this.subscribeClick();
        }
    };
    TooltipDirective.prototype.ngAfterViewChecked = function () {
        if (!this.popupRef) {
            return;
        }
        if (this.anchor &&
            !hasParent(this.anchor.nativeElement || this.anchor, this.tooltipWrapper.nativeElement)) {
            this.anchor = null;
            this.hide();
        }
    };
    TooltipDirective.prototype.ngOnDestroy = function () {
        this.hide();
        this.template = null;
        this.anchorTitleSubscription.unsubscribe();
        this.mouseOverSubscription.unsubscribe();
        this.mouseOutSubscription.unsubscribe();
        if (this.mouseClickSubscription) {
            this.mouseClickSubscription.unsubscribe();
        }
        if (this.popupPositionChangeSubscription) {
            this.popupPositionChangeSubscription.unsubscribe();
        }
        if (this.popupMouseOutSubscription) {
            this.popupMouseOutSubscription.unsubscribe();
        }
    };
    TooltipDirective.prototype.showContent = function (anchorRef) {
        var _this = this;
        if (!anchorRef.nativeElement.getAttribute('data-title') && !this.template) {
            return;
        }
        this.ngZone.run(function () {
            _this.openPopup(anchorRef);
            _this.bindContent(_this.popupRef.content, anchorRef);
        });
        this.popupRef.popupAnchorViewportLeave
            .pipe(take(1))
            .subscribe(function () { return _this.hide(); });
    };
    TooltipDirective.prototype.bindContent = function (contentComponent, anchorRef) {
        var _this = this;
        var content = contentComponent.instance;
        this.closeClickSubscription = content.close
            .subscribe(function () { _this.hide(); });
        if (!this.template) {
            content.templateString = this.anchor.nativeElement.getAttribute('data-title');
        }
        else {
            content.templateRef = this.template;
        }
        if (this.titleTemplate) {
            content.titleTemplate = this.titleTemplate;
        }
        content.closeTitle = this.closeTitle;
        content.anchor = anchorRef;
        content.callout = this.callout;
        content.closable = this.closable;
        content.position = this.position;
        content.tooltipWidth = this.tooltipWidth;
        content.tooltipHeight = this.tooltipHeight;
        this.popupRef.content.changeDetectorRef.detectChanges();
    };
    TooltipDirective.prototype.hideElementTitle = function (elementRef) {
        var element = elementRef.nativeElement;
        if (element.getAttribute('title')) {
            element.setAttribute('data-title', element.getAttribute('title'));
            element.setAttribute('title', '');
        }
    };
    TooltipDirective.prototype.openPopup = function (anchorRef) {
        var _this = this;
        var alignSettings = align(this.position, this.offset);
        var anchorAlign = alignSettings.anchorAlign;
        var popupAlign = alignSettings.popupAlign;
        var popupMargin = alignSettings.popupMargin;
        this.popupRef = this.popupService.open({
            anchor: anchorRef,
            anchorAlign: anchorAlign,
            animate: false,
            content: TooltipContentComponent,
            collision: collision(this.collision, this.position),
            margin: popupMargin,
            popupAlign: popupAlign,
            popupClass: 'k-popup-transparent'
        });
        this.renderer.addClass(this.popupRef.popupElement, 'k-tooltip-wrapper');
        if (this.tooltipClass) {
            this.renderer.addClass(this.popupRef.popupElement, this.tooltipClass);
        }
        var popupInstance = this.popupRef.content.instance;
        if (popupInstance.callout) {
            this.popupPositionChangeSubscription = this.popupRef.popupPositionChange
                .subscribe(function (_a) {
                var flip = _a.flip;
                var isFlip = flip.horizontal === true || flip.vertical === true;
                popupInstance.updateCalloutPosition(_this.position, isFlip);
            });
        }
        if (this.showOn === 'hover') {
            this.ngZone.runOutsideAngular(function () {
                var popup = _this.popupRef.popupElement;
                _this.popupMouseOutSubscription = fromEvent(popup, 'mouseout')
                    .subscribe(function (e) { return _this.onMouseOut(e); });
            });
        }
    };
    TooltipDirective.prototype.closePopup = function () {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.popupPositionChangeSubscription) {
            this.popupPositionChangeSubscription.unsubscribe();
        }
    };
    TooltipDirective.prototype.subscribeClick = function () {
        var _this = this;
        if (this.mouseClickSubscription) {
            this.mouseClickSubscription.unsubscribe();
        }
        if (this.showOn === 'click') {
            this.mouseClickSubscription = fromEvent(document, 'click')
                .pipe(filter(function () { return _this.filter !== ''; }))
                .subscribe(function (e) { return _this.onMouseClick(e, _this.tooltipWrapper.nativeElement); });
        }
    };
    TooltipDirective.prototype.onMouseClick = function (e, wrapper) {
        var target = e.target;
        var filterElement = closestBySelector(target, this.filter);
        var popup = this.popupRef && this.popupRef.popupElement;
        if (popup) {
            if (popup.contains(target)) {
                return;
            }
            if (this.closable) {
                return;
            }
        }
        if (wrapper.contains(target) && filterElement) {
            this.toggle(filterElement, true);
        }
        else if (popup) {
            this.hide();
        }
    };
    TooltipDirective.prototype.onMouseOver = function (e) {
        var filterElement = closestBySelector(e.target, this.filter);
        if (this.showOn !== 'hover') {
            return;
        }
        if (filterElement) {
            this.toggle(filterElement, true);
        }
    };
    TooltipDirective.prototype.onMouseOut = function (e) {
        if (this.showOn !== 'hover') {
            return;
        }
        if (this.closable) {
            return;
        }
        var popup = this.popupRef && this.popupRef.popupElement;
        var relatedTarget = e.relatedTarget;
        if (relatedTarget && this.anchor && contains(this.anchor.nativeElement, relatedTarget)) {
            return;
        }
        if (relatedTarget && contains(popup, relatedTarget)) {
            return;
        }
        this.hide();
    };
    TooltipDirective.prototype.verifyProperties = function () {
        if (!isDevMode()) {
            return;
        }
        if (!containsItem(this.validPositions, this.position)) {
            throw new Error("Invalid value provided for position property.The available options are 'top', 'bottom', 'left', or 'right'.");
        }
        if (!containsItem(this.validShowOptions, this.showOn)) {
            throw new Error("Invalid value provided for showOn property.The available options are 'hover' or 'none'.");
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipDirective.prototype, "filter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipDirective.prototype, "position", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], TooltipDirective.prototype, "titleTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipDirective.prototype, "showOn", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "showAfter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "callout", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "closable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "offset", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "tooltipWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "tooltipHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipDirective.prototype, "tooltipClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "collision", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipDirective.prototype, "closeTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef),
        __metadata("design:paramtypes", [TemplateRef])
    ], TooltipDirective.prototype, "tooltipTemplate", null);
    TooltipDirective = __decorate([
        Directive({
            selector: '[kendoTooltip]',
            exportAs: 'kendoTooltip'
        }),
        __param(4, Optional()),
        __param(5, Optional()), __param(5, Inject(TOOLTIP_SETTINGS)),
        __metadata("design:paramtypes", [ElementRef,
            NgZone,
            Renderer2,
            PopupService,
            TooltipSettings,
            TooltipSettings])
    ], TooltipDirective);
    return TooltipDirective;
}());

/**
 * @hidden
 */
var ERRORS = {
    popover: "Invalid value provided for the 'popover' property. The accepted data types are 'PopoverComponent' or 'PopoverFn'.",
    templateData: "templateData must be a function, but received",
    showOn: "Invalid value provided for the 'showOn' property. The available options are 'click', 'hover', 'focus' or 'none'."
};

/**
 * Represents a template that defines the content of the Popover title.
 *
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoPopoverTitleTemplate` directive inside the `<kendo-popover>` tag.
 */
var PopoverTitleTemplateDirective = /** @class */ (function () {
    function PopoverTitleTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    PopoverTitleTemplateDirective = __decorate([
        Directive({
            selector: '[kendoPopoverTitleTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], PopoverTitleTemplateDirective);
    return PopoverTitleTemplateDirective;
}());

/**
 * Represents a template that defines the content of the Popover body.
 *
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoPopoverBodyTemplate` directive inside the `<kendo-popover>` tag.
 */
var PopoverBodyTemplateDirective = /** @class */ (function () {
    function PopoverBodyTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    PopoverBodyTemplateDirective = __decorate([
        Directive({
            selector: '[kendoPopoverBodyTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], PopoverBodyTemplateDirective);
    return PopoverBodyTemplateDirective;
}());

/**
 * Represents a template that defines the content of the Popover actions.
 *
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoPopoverActionsTemplate` directive inside the `<kendo-popover>` tag.
 */
var PopoverActionsTemplateDirective = /** @class */ (function () {
    function PopoverActionsTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    PopoverActionsTemplateDirective = __decorate([
        Directive({
            selector: '[kendoPopoverActionsTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], PopoverActionsTemplateDirective);
    return PopoverActionsTemplateDirective;
}());

/**
 * Represents the [Kendo UI Popover component for Angular]({% slug overview_popover %}).
 * Used to display additional information that is related to a target element.
 *
 * @example
 * ```ts-no-run
 * <kendo-popover>
 *    <ng-template kendoPopoverTitleTemplate>Foo Title</ng-template>
 *    <ng-template kendoPopoverBodyTemplate>Foo Body</ng-template>
 *    <ng-template kendoPopoverActionsTemplate>Foo Actions</ng-template>
 * </kendo-popover>
 * ```
 */
var PopoverComponent = /** @class */ (function () {
    function PopoverComponent(localization) {
        this.localization = localization;
        /**
         * Specifies the position of the Popover in relation to its anchor element. [See example]({% slug positioning_popover %})
         *
         * The possible options are:
         * `top`
         * `bottom`
         * `right` (Default)
         * `left`
         */
        this.position = 'right';
        /**
         * Determines whether a callout will be rendered along the Popover. [See example]({% slug callout_popover %})
         *
         * @default true
         */
        this.callout = true;
        /**
         * Enables and configures the Popover animation. [See example]({% slug animations_popover %})
         *
         * The possible options are:
         *
         * * `boolean`&mdash;Enables the default animation
         * * `PopoverAnimation`&mdash;A configuration object which allows setting the `direction`, `duration` and `type` of the animation.
         *
         * @default false
         */
        this.animation = false;
        /**
         * @hidden
         * Determines the visibility of the Popover.
         */
        this.visible = false;
        /**
         * Fires before the Popover is about to be shown ([see example]({% slug events_popover %})).
         * The event is preventable. If canceled, the Popover will not be displayed. [See example]({% slug events_popover %})
         */
        this.show = new EventEmitter();
        /**
         * Fires after the Popover has been shown and the animation has ended. [See example]({% slug events_popover %})
         */
        this.shown = new EventEmitter();
        /**
         * Fires when the Popover is about to be hidden ([see example]({% slug events_popover %})).
         * The event is preventable. If canceled, the Popover will remain visible.
         */
        this.hide = new EventEmitter();
        /**
         * Fires after the Popover has been hidden and the animation has ended. [See example]({% slug events_popover %})
         */
        this.hidden = new EventEmitter();
        this._offset = 6;
        this._width = 'auto';
        this._height = 'auto';
        this.subs = new Subscription();
        /**
         * @hidden
         */
        this._templateData = function () { return null; };
        validatePackage(packageMetadata);
    }
    Object.defineProperty(PopoverComponent.prototype, "offset", {
        get: function () {
            var calloutBuffer = 14;
            return this.callout
                ? calloutBuffer + this._offset
                : this._offset;
        },
        /**
         * Specifies the distance from the Popover to its anchor element in pixels.
         *
         * @default `6`
         */
        set: function (value) {
            this._offset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PopoverComponent.prototype, "width", {
        get: function () {
            return this._width;
        },
        /**
         * Determines the width of the popover. Numeric values are treated as pixels.
         * @default 'auto'
         */
        set: function (value) {
            this._width = typeof value === 'number' ? value + "px" : value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PopoverComponent.prototype, "height", {
        get: function () {
            return this._height;
        },
        /**
         * Determines the height of the popover. Numeric values are treated as pixels.
         * @default 'auto'
         */
        set: function (value) {
            this._height = typeof value === 'number' ? value + "px" : value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PopoverComponent.prototype, "templateData", {
        get: function () {
            return this._templateData;
        },
        /**
         * Defines a callback function which returns custom data passed to the Popover templates.
         * It exposes the current anchor element as an argument. [See example]({% slug templates_popover %}#toc-popoverdatacallback)
         */
        set: function (fn) {
            if (isDevMode && typeof fn !== 'function') {
                throw new Error(ERRORS.templateData + " " + JSON.stringify(fn) + ".");
            }
            this._templateData = fn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PopoverComponent.prototype, "isHidden", {
        /**
         * @hidden
         */
        get: function () {
            return !this.visible;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PopoverComponent.prototype, "hasAttributeHidden", {
        /**
         * @hidden
         */
        get: function () {
            return !this.visible;
        },
        enumerable: true,
        configurable: true
    });
    PopoverComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subs.add(this.localization.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
        }));
    };
    PopoverComponent.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    /**
     * @hidden
     */
    PopoverComponent.prototype.getCalloutPosition = function () {
        switch (this.position) {
            case 'top': return { 'k-callout-s': true };
            case 'bottom': return { 'k-callout-n': true };
            case 'left': return { 'k-callout-e': true };
            case 'right': return { 'k-callout-w': true };
            default: return { 'k-callout-s': true };
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PopoverComponent.prototype, "position", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], PopoverComponent.prototype, "offset", null);
    __decorate([
        HostBinding('style.width'),
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], PopoverComponent.prototype, "width", null);
    __decorate([
        HostBinding('style.height'),
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], PopoverComponent.prototype, "height", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], PopoverComponent.prototype, "direction", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PopoverComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PopoverComponent.prototype, "subtitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PopoverComponent.prototype, "body", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopoverComponent.prototype, "callout", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PopoverComponent.prototype, "animation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], PopoverComponent.prototype, "templateData", null);
    __decorate([
        HostBinding('class.k-hidden'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], PopoverComponent.prototype, "isHidden", null);
    __decorate([
        HostBinding('attr.aria-hidden'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], PopoverComponent.prototype, "hasAttributeHidden", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], PopoverComponent.prototype, "show", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], PopoverComponent.prototype, "shown", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], PopoverComponent.prototype, "hide", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], PopoverComponent.prototype, "hidden", void 0);
    __decorate([
        ContentChild(PopoverTitleTemplateDirective, { static: false }),
        __metadata("design:type", PopoverTitleTemplateDirective)
    ], PopoverComponent.prototype, "titleTemplate", void 0);
    __decorate([
        ContentChild(PopoverBodyTemplateDirective, { static: false }),
        __metadata("design:type", PopoverBodyTemplateDirective)
    ], PopoverComponent.prototype, "bodyTemplate", void 0);
    __decorate([
        ContentChild(PopoverActionsTemplateDirective, { static: false }),
        __metadata("design:type", PopoverActionsTemplateDirective)
    ], PopoverComponent.prototype, "actionsTemplate", void 0);
    PopoverComponent = __decorate([
        Component({
            selector: 'kendo-popover',
            providers: [
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.popover'
                }
            ],
            template: "\n    <div *ngIf=\"visible\" role=\"tooltip\" class=\"k-popover\" [ngStyle]=\"{'width.px': width, 'height.px': height}\">\n        <div class=\"k-popover-callout\" [ngClass]=\"getCalloutPosition()\" *ngIf=\"callout\"></div>\n\n        <div *ngIf=\"titleTemplate || title\" class=\"k-popover-header\">\n            <ng-template *ngIf=\"titleTemplate\"\n                [ngTemplateOutlet]=\"titleTemplate?.templateRef\"\n                [ngTemplateOutletContext]=\"{ $implicit: anchor, data: contextData }\">\n            </ng-template>\n            <ng-container *ngIf=\"title && !titleTemplate\">\n                {{ title }}\n            </ng-container>\n        </div>\n\n        <div *ngIf=\"bodyTemplate || body\" class=\"k-popover-body\">\n            <ng-template *ngIf=\"bodyTemplate\"\n                [ngTemplateOutlet]=\"bodyTemplate?.templateRef\"\n                [ngTemplateOutletContext]=\"{ $implicit: anchor, data: contextData }\">\n            </ng-template>\n            <ng-container *ngIf=\"body && !bodyTemplate\">\n                {{ body }}\n            </ng-container>\n        </div>\n\n        <div *ngIf=\"actionsTemplate\" class=\"k-popover-actions k-actions k-hstack k-justify-content-between\">\n            <ng-template *ngIf=\"actionsTemplate\"\n                [ngTemplateOutlet]=\"actionsTemplate?.templateRef\"\n                [ngTemplateOutletContext]=\"{ $implicit: anchor, data: contextData }\">\n            </ng-template>\n        </div>\n    </div>\n    "
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], PopoverComponent);
    return PopoverComponent;
}());

/**
 * Arguments for the `show` event. The `show` event fires when a popover is about
 * to be opened. If you cancel the event, the opening is prevented.
 */
var PopoverShowEvent = /** @class */ (function (_super) {
    __extends(PopoverShowEvent, _super);
    /**
     * @hidden
     * Constructs the event arguments for the `show` event.
     * @param anchor - The host element related to the popover.
     */
    function PopoverShowEvent(anchor) {
        var _this = _super.call(this) || this;
        _this.anchor = anchor;
        return _this;
    }
    return PopoverShowEvent;
}(PreventableEvent));
/**
 * Arguments for the `hide` event. The `hide` event fires when a popover is about
 * to be closed. If you cancel the event, the popover stays open.
 */
var PopoverHideEvent = /** @class */ (function (_super) {
    __extends(PopoverHideEvent, _super);
    /**
     * @hidden
     * Constructs the event arguments for the `hide` event.
     * @param anchor - The host element related to the popover.
     * @param popover - The popover element.
     */
    function PopoverHideEvent(anchor, popover) {
        var _this = _super.call(this) || this;
        _this.anchor = anchor;
        _this.popover = popover;
        return _this;
    }
    return PopoverHideEvent;
}(PreventableEvent));
/**
 * Arguments for the `shown` event. The `shown` event fires after the popover has opened and its opening animation has finished.
 */
var PopoverShownEvent = /** @class */ (function () {
    /**
     * @hidden
     * Constructs the event arguments for the `shown` event.
     * @param anchor - The host element related to the popover.
     * @param popover - The popover element.
     */
    function PopoverShownEvent(anchor, popover) {
        this.anchor = anchor;
        this.popover = popover;
    }
    return PopoverShownEvent;
}());
/**
 * Arguments for the `hidden` event. The `hidden` event fires after the popover has closed and its closing animation has finished.
 */
var PopoverHiddenEvent = /** @class */ (function () {
    /**
     * @hidden
     * Constructs the event arguments for the `hidden` event.
     * @param anchor - The host element related to the popover.
     */
    function PopoverHiddenEvent(anchor) {
        this.anchor = anchor;
    }
    return PopoverHiddenEvent;
}());

var validShowOptions = ['hover', 'click', 'none', 'focus'];
/**
 * @hidden
 */
var PopoverDirectivesBase = /** @class */ (function () {
    function PopoverDirectivesBase(ngZone, popupService, renderer) {
        this.ngZone = ngZone;
        this.popupService = popupService;
        this.renderer = renderer;
        this.subs = new Subscription();
        this._showOn = 'click';
    }
    Object.defineProperty(PopoverDirectivesBase.prototype, "popover", {
        get: function () {
            return this._popover;
        },
        /**
         * Specifies the popover instance that will be rendered.
         * Accepts a [`PopoverComponent`]({% slug api_tooltip_popovercomponent %}) instance or
         * a [`PopoverFn`]({% slug api_tooltip_popoverfn %}) callback which returns a [`PopoverComponent`]({% slug api_tooltip_popovercomponent %}) instance
         * depending on the current anchor element.
         *
         * [See example]({% slug templates_popover %}#toc-popovercallback)
         */
        set: function (value) {
            if (value instanceof PopoverComponent || typeof value === "function") {
                this._popover = value;
            }
            else {
                if (isDevMode) {
                    throw new Error(ERRORS.popover);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PopoverDirectivesBase.prototype, "showOn", {
        get: function () {
            return this._showOn;
        },
        /**
         * The event on which the Popover will be shown
         *
         * The supported values are:
         * - `click` (default) &mdash;The Popover will be shown when its `anchor` element is clicked.
         * - `hover`&mdash;The Popover will be shown when its `anchor` element is hovered.
         * - `focus`&mdash;The Popover will be shown when its `anchor` element is focused.
         * - `none`&mdash;The Popover will not be shown on user interaction. It could be rendered via the Popover API methods.
         */
        set: function (value) {
            if (isDevMode && !containsItem(validShowOptions, value)) {
                throw new Error(ERRORS.showOn);
            }
            this._showOn = value;
        },
        enumerable: true,
        configurable: true
    });
    PopoverDirectivesBase.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (!isDocumentAvailable()) {
            return;
        }
        this.ngZone.runOutsideAngular(function () {
            switch (_this.showOn) {
                case 'hover':
                    _this.subscribeToEvents([{
                            name: 'mouseenter', handler: _this.mouseenterHandler
                        }, {
                            name: 'mouseleave', handler: _this.mouseleaveHandler
                        }]);
                    break;
                case 'focus':
                    _this.subscribeToEvents([{
                            name: 'focus', handler: _this.focusHandler
                        }, {
                            name: 'blur', handler: _this.blurHandler
                        }]);
                    break;
                case 'click':
                    _this.subscribeClick();
                    break;
                default:
                    break;
            }
        });
    };
    PopoverDirectivesBase.prototype.ngOnDestroy = function () {
        this.closePopup();
        if (this.disposeHoverOverListener) {
            this.disposeHoverOverListener();
        }
        if (this.disposeHoverOutListener) {
            this.disposeHoverOutListener();
        }
        if (this.disposeClickListener) {
            this.disposeClickListener();
        }
        if (this._focusInsideSub) {
            this._focusInsideSub.unsubscribe();
        }
        if (this._hideSub) {
            this._hideSub.unsubscribe();
        }
        if (this.subs) {
            this.subs.unsubscribe();
        }
        if (this._popupOpenSub) {
            this._popupOpenSub.unsubscribe();
        }
        if (this._popupCloseSub) {
            this._popupCloseSub.unsubscribe();
        }
    };
    /**
     * Hides the Popover ([See example]({% slug programmaticcontrol_popover %})).
     */
    PopoverDirectivesBase.prototype.hide = function () {
        this.closePopup();
    };
    /**
     * @hidden
     */
    PopoverDirectivesBase.prototype.closePopup = function () {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
            if (this.disposePopupHoverOutListener) {
                this.disposePopupHoverOutListener();
            }
            if (this.disposePopupHoverInListener) {
                this.disposePopupHoverInListener();
            }
            if (this.disposePopupFocusOutListener) {
                this.disposePopupFocusOutListener();
            }
        }
    };
    /**
     * @hidden
     */
    PopoverDirectivesBase.prototype.openPopup = function (anchor) {
        var _anchor = anchor instanceof ElementRef ? anchor.nativeElement : anchor;
        var popoverComp = this.popover instanceof PopoverComponent ? this.popover : this.popover(_anchor);
        var alignSettings = align(popoverComp.position, popoverComp.offset);
        var anchorAlign = alignSettings.anchorAlign;
        var popupAlign = alignSettings.popupAlign;
        var popupMargin = alignSettings.popupMargin;
        var _animation = popoverComp.animation;
        this.popupRef = this.popupService.open({
            anchor: { nativeElement: _anchor },
            animate: _animation,
            content: PopoverComponent,
            popupAlign: popupAlign,
            anchorAlign: anchorAlign,
            margin: popupMargin,
            popupClass: 'k-popup-transparent',
            collision: { horizontal: 'fit', vertical: 'fit' }
        });
        this.applySettings(this.popupRef.content, popoverComp, anchor);
        this.monitorPopup();
        this.initializeCompletionEvents(popoverComp, _anchor);
    };
    /**
     * @hidden
     */
    PopoverDirectivesBase.prototype.isPrevented = function (anchorElement, show) {
        var popoverComp = this.popover instanceof PopoverComponent ? this.popover : this.popover(anchorElement);
        var eventArgs;
        eventArgs = this.initializeEvents(popoverComp, eventArgs, show, anchorElement);
        return eventArgs.isDefaultPrevented();
    };
    /**
     * @hidden
     */
    PopoverDirectivesBase.prototype.monitorPopup = function () {
        var _this = this;
        if (this.showOn === 'hover') {
            this.ngZone.runOutsideAngular(function () {
                var popup = _this.popupRef.popupElement;
                _this.disposePopupHoverInListener = _this.renderer.listen(popup, 'mouseenter', function (_) {
                    _this.ngZone.run(function (_) { return _this._popoverService.emitPopoverState(true); });
                });
                _this.disposePopupHoverOutListener = _this.renderer.listen(popup, 'mouseleave', function (_) {
                    _this.ngZone.run(function (_) { return _this._popoverService.emitPopoverState(false); });
                });
            });
        }
        if (this.showOn === 'focus') {
            this.ngZone.runOutsideAngular(function () {
                var popup = _this.popupRef.popupElement;
                _this.disposePopupFocusOutListener = _this.renderer.listen(popup, 'focusout', function (e) {
                    var isInsidePopover = closest(e.relatedTarget, function (node) { return node.classList && node.classList.contains('k-popover'); });
                    if (!isInsidePopover) {
                        _this.ngZone.run(function (_) { return _this._popoverService.emitFocusInsidePopover(false); });
                    }
                });
            });
        }
    };
    PopoverDirectivesBase.prototype.applySettings = function (contentComponent, popover, anchor) {
        var content = contentComponent.instance;
        var _anchor = anchor instanceof ElementRef ? anchor.nativeElement : anchor;
        content.visible = true;
        content.anchor = _anchor;
        content.position = popover.position;
        content.offset = popover.offset;
        content.width = popover.width;
        content.height = popover.height;
        content.title = popover.title;
        content.body = popover.body;
        content.callout = popover.callout;
        content.animation = popover.animation;
        content.contextData = popover.templateData(_anchor);
        content.titleTemplate = popover.titleTemplate;
        content.bodyTemplate = popover.bodyTemplate;
        content.actionsTemplate = popover.actionsTemplate;
        this.popupRef.content.changeDetectorRef.detectChanges();
    };
    /**
     * @hidden
     */
    PopoverDirectivesBase.prototype.initializeEvents = function (popoverComp, eventArgs, show, anchorElement) {
        if (show) {
            eventArgs = new PopoverShowEvent(anchorElement);
            if (this.shouldEmitEvent(!!this.popupRef, 'show', popoverComp)) {
                this.ngZone.run(function () { return popoverComp.show.emit(eventArgs); });
            }
        }
        else {
            eventArgs = new PopoverHideEvent(anchorElement, this.popupRef);
            if (this.shouldEmitEvent(!!this.popupRef, 'hide', popoverComp)) {
                this.ngZone.run(function () { return popoverComp.hide.emit(eventArgs); });
            }
        }
        return eventArgs;
    };
    PopoverDirectivesBase.prototype.initializeCompletionEvents = function (popoverComp, _anchor) {
        var _this = this;
        if (this.shouldEmitCompletionEvents('shown', popoverComp)) {
            this.popupRef.popupOpen.subscribe(function () {
                var eventArgs = new PopoverShownEvent(_anchor, _this.popupRef);
                popoverComp.shown.emit(eventArgs);
            });
        }
        if (this.shouldEmitCompletionEvents('hidden', popoverComp)) {
            this.popupRef.popupClose.subscribe(function () {
                _this.ngZone.run(function (_) {
                    var eventArgs = new PopoverHiddenEvent(_anchor);
                    popoverComp.hidden.emit(eventArgs);
                });
            });
        }
    };
    PopoverDirectivesBase.prototype.shouldEmitEvent = function (hasPopup, event, popoverComp) {
        if ((event === 'show' && !hasPopup && hasObservers(popoverComp[event]))
            || (event === 'hide' && hasPopup && hasObservers(popoverComp[event]))) {
            return true;
        }
        return false;
    };
    PopoverDirectivesBase.prototype.shouldEmitCompletionEvents = function (event, popoverComp) {
        if ((hasObservers(popoverComp[event]) && !this._popupOpenSub)
            || (hasObservers(popoverComp[event]) && !this._popupCloseSub)) {
            return true;
        }
        return false;
    };
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], PopoverDirectivesBase.prototype, "popover", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], PopoverDirectivesBase.prototype, "showOn", null);
    return PopoverDirectivesBase;
}());

/**
 * @hidden
 */
var PopoverService = /** @class */ (function () {
    function PopoverService(ngZone) {
        this.ngZone = ngZone;
        this._pointerOverPopup = new BehaviorSubject(null);
        this._pointerOverAnchor = new BehaviorSubject(null);
        this._focusInsidePopover = new BehaviorSubject(null);
        this._hidePopover = new Subject();
        this.subs = new Subscription();
        this.monitor();
    }
    PopoverService.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    Object.defineProperty(PopoverService.prototype, "isPopoverHovered", {
        get: function () {
            return this._pointerOverPopup.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    PopoverService.prototype.emitPopoverState = function (isHovered) {
        var _this = this;
        this.ngZone.run(function (_) { return _this._pointerOverPopup.next(isHovered); });
    };
    Object.defineProperty(PopoverService.prototype, "isAnchorHovered", {
        get: function () {
            return this._pointerOverAnchor.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    PopoverService.prototype.emitAnchorState = function (isHovered, anchor) {
        var _this = this;
        this._isOrigin = this.originAnchor === anchor;
        this.currentAnchor = anchor;
        if (isHovered) {
            this.originAnchor = anchor;
        }
        this.ngZone.run(function (_) { return _this._pointerOverAnchor.next(isHovered); });
    };
    Object.defineProperty(PopoverService.prototype, "isFocusInsidePopover", {
        get: function () {
            return this._focusInsidePopover.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    PopoverService.prototype.emitFocusInsidePopover = function (isFocused) {
        var _this = this;
        this.ngZone.run(function (_) { return _this._focusInsidePopover.next(isFocused); });
        this._focusInsidePopover.next(null);
    };
    Object.defineProperty(PopoverService.prototype, "hidePopover", {
        get: function () {
            return this._hidePopover.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    PopoverService.prototype.monitor = function () {
        var _this = this;
        this.subs.add(combineLatest(this.isPopoverHovered, this.isAnchorHovered).pipe(
        // `auditTime` is used because the `mouseleave` event is emitted before `mouseenter`
        // i.e. there is a millisecond in which the pointer leaves the first target (e.g. anchor) and hasn't reached the second one (e.g. popup)
        // resulting in both observables emitting `false`
        auditTime(20)).subscribe(function (val) {
            var isPopoverHovered = val[0], isAnchorHovered = val[1];
            _this._hidePopover.next([isPopoverHovered, isAnchorHovered, _this._isOrigin, _this.currentAnchor]);
        }));
    };
    PopoverService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [NgZone])
    ], PopoverService);
    return PopoverService;
}());

/**
 * Represents the [`kendoPopoverContainer`]({% slug configuration_popover %}#toc-containerdirective) directive.
 * It is used to filter and target multiple elements, which should display a popover on interaction.
 *
 * @example
 * ```ts-no-run
 * <div kendoPopoverContainer [popover]="myPopover" filter=".has-popover">
 *     <button class="has-popover">Show Popover</button>
 *     <button>Button Without Popover</button>
 *     <button class="has-popover">Show Popover</button>
 * </div>
 * ```
 */
var PopoverContainerDirective = /** @class */ (function (_super) {
    __extends(PopoverContainerDirective, _super);
    function PopoverContainerDirective(wrapperEl, ngZone, popupService, renderer, popoverService) {
        var _this = _super.call(this, ngZone, popupService, renderer) || this;
        _this.wrapperEl = wrapperEl;
        _this.ngZone = ngZone;
        _this.popupService = popupService;
        _this.renderer = renderer;
        _this.popoverService = popoverService;
        _this.mouseenterHandler = function (anchor) {
            _this.controlVisibility(anchor, true);
        };
        _this.mouseleaveHandler = function (args) {
            var anchor = args.anchor;
            if (_this.isPrevented(anchor, false)) {
                return;
            }
            if (!_this._hideSub) {
                _this._hideSub = _this.popoverService.hidePopover.subscribe(function (val) {
                    var isPopoverHovered = val[0], isOriginAnchor = val[2], currentAnchor = val[3];
                    if (!isPopoverHovered && !isOriginAnchor) {
                        _this.hide();
                        if (!isOriginAnchor && currentAnchor) {
                            _this.show(currentAnchor);
                        }
                    }
                });
            }
        };
        _this.focusHandler = function (anchor) {
            _this.controlVisibility(anchor, true);
        };
        _this.blurHandler = function (args) {
            var anchor = args.anchor;
            var event = args.domEvent;
            if (_this.isPrevented(anchor, false)) {
                return;
            }
            // from anchor to popup focus check
            var isFocusInside = !!closest(event.relatedTarget, function (node) { return node.classList && node.classList.contains('k-popover'); });
            if (!isFocusInside) {
                _this.hide();
            }
            if (!_this._focusInsideSub) {
                // inside popup focus check
                _this._focusInsideSub = _this.popoverService.isFocusInsidePopover.pipe(filter(function (v) { return v !== null; })).subscribe(function (val) {
                    if (!val && !isFocusInside) {
                        _this.hide();
                    }
                });
            }
        };
        _this._popoverService = _this.popoverService;
        return _this;
    }
    /**
     * Shows the Popover.
     *
     * @param anchor&mdash;Specifies the element that will be used as an anchor. The Popover opens relative to that element. [See example]({% slug programmaticcontrol_popover %})
     */
    PopoverContainerDirective.prototype.show = function (anchor) {
        var _this = this;
        if (this.popupRef) {
            return;
        }
        this.ngZone.run(function () {
            _this.openPopup(anchor);
        });
        this.popupRef.popupAnchorViewportLeave
            .pipe(take(1))
            .subscribe(function () { return _this.hide(); });
    };
    /**
     * Toggles the visibility of the Popover. [See example]({% slug programmaticcontrol_popover %})
     *
     * @param anchor&mdash;Specifies the element that will be used as an anchor. The Popover opens relative to that element.
     */
    PopoverContainerDirective.prototype.toggle = function (anchor) {
        var previousAnchor = this.popupRef && this.popupRef.content.instance.anchor;
        if (this.popupRef) {
            this.hide();
            if (previousAnchor !== anchor) {
                this.show(anchor);
            }
        }
        else {
            this.show(anchor);
        }
    };
    PopoverContainerDirective.prototype.subscribeClick = function () {
        var _this = this;
        if (this.disposeClickListener) {
            this.disposeClickListener();
        }
        this.disposeClickListener = this.renderer.listen(document, 'click', function (e) {
            var filterElement = closestBySelector(e.target, _this.filter);
            _this.clickHandler(filterElement, e);
        });
    };
    PopoverContainerDirective.prototype.subscribeToEvents = function (arr) {
        var _this = this;
        var filteredElements = Array.from(document.querySelectorAll(this.filter));
        filteredElements.forEach(function (el) {
            _this.subs.add(_this.renderer.listen(el, arr[0].name, function () {
                _this.popoverService.emitAnchorState(true, el);
                arr[0].handler(el);
            }));
            _this.subs.add(_this.renderer.listen(el, arr[1].name, function (e) {
                _this.popoverService.emitAnchorState(false, null);
                arr[1].handler({ anchor: el, domEvent: e });
            }));
        });
    };
    PopoverContainerDirective.prototype.clickHandler = function (anchor, event) {
        var isInsidePopup = !!closest(event.target, function (node) { return node.classList && node.classList.contains('k-popup'); });
        var popupRefAnchor = this.popupRef && this.popupRef.content.instance.anchor;
        var isOriginAnchor = !!closest(event.target, function (node) { return node === (popupRefAnchor ? popupRefAnchor : anchor); });
        if (this.showOn !== 'click' || isInsidePopup || (this.popupRef && isOriginAnchor)) {
            return;
        }
        if (!anchor && this.popupRef) {
            this.controlVisibility(anchor, false);
            return;
        }
        if (isOriginAnchor) {
            this.controlVisibility(anchor, true);
        }
        else if (this.popupRef) {
            this.controlVisibility(anchor, false);
            this.controlVisibility(anchor, true);
        }
    };
    PopoverContainerDirective.prototype.controlVisibility = function (anchor, show) {
        if (this.isPrevented(anchor, show)) {
            return;
        }
        show ? this.show(anchor) : this.hide();
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PopoverContainerDirective.prototype, "filter", void 0);
    PopoverContainerDirective = __decorate([
        Directive({
            selector: '[kendoPopoverContainer]',
            exportAs: 'kendoPopoverContainer',
            providers: [PopoverService]
        }),
        __metadata("design:paramtypes", [ElementRef,
            NgZone,
            PopupService,
            Renderer2,
            PopoverService])
    ], PopoverContainerDirective);
    return PopoverContainerDirective;
}(PopoverDirectivesBase));

/**
 * Represents the [`kendoPopoverAnchor`]({% slug configuration_popover %}#toc-anchordirective) directive.
 * It is used to target an element, which should display a popover on interaction.
 *
 * @example
 * ```ts-no-run
 * <button kendoPopoverAnchor [popover]="myPopover">Show Popover</button>
 * ```
 */
var PopoverAnchorDirective = /** @class */ (function (_super) {
    __extends(PopoverAnchorDirective, _super);
    function PopoverAnchorDirective(hostEl, ngZone, popupService, renderer, popoverService) {
        var _this = _super.call(this, ngZone, popupService, renderer) || this;
        _this.hostEl = hostEl;
        _this.ngZone = ngZone;
        _this.popupService = popupService;
        _this.renderer = renderer;
        _this.popoverService = popoverService;
        _this.mouseenterHandler = function () {
            _this.controlVisibility(_this.hostEl.nativeElement, true);
        };
        _this.mouseleaveHandler = function () {
            if (_this.isPrevented(_this.hostEl.nativeElement, false)) {
                return;
            }
            if (!_this._hideSub) {
                _this._hideSub = _this.popoverService.hidePopover.subscribe(function (val) {
                    var isPopoverHovered = val[0], isAnchorHovered = val[1];
                    if (!isPopoverHovered && !isAnchorHovered) {
                        _this.hide();
                    }
                });
            }
        };
        _this.focusHandler = function () {
            _this.controlVisibility(_this.hostEl.nativeElement, true);
        };
        _this.blurHandler = function (args) {
            var event = args.domEvent;
            if (_this.isPrevented(_this.hostEl.nativeElement, false)) {
                return;
            }
            // from anchor to popup focus check
            var isFocusInside = !!closest(event.relatedTarget, function (node) { return node.classList && node.classList.contains('k-popover'); });
            if (!isFocusInside) {
                _this.hide();
            }
            if (!_this._focusInsideSub) {
                // inside popup focus check
                _this._focusInsideSub = _this.popoverService.isFocusInsidePopover.pipe(filter(function (v) { return v !== null; })).subscribe(function (val) {
                    if (!val) {
                        _this.hide();
                    }
                });
            }
        };
        _this._popoverService = _this.popoverService;
        return _this;
    }
    /**
     * Shows the Popover. [See example]({% slug programmaticcontrol_popover %})
     */
    PopoverAnchorDirective.prototype.show = function () {
        var _this = this;
        if (this.popupRef) {
            return;
        }
        this.ngZone.run(function () {
            _this.openPopup(_this.hostEl);
        });
        this.popupRef.popupAnchorViewportLeave
            .pipe(take(1))
            .subscribe(function () { return _this.hide(); });
    };
    /**
     * Toggles the visibility of the Popover. [See example]({% slug programmaticcontrol_popover %})
     */
    PopoverAnchorDirective.prototype.toggle = function () {
        if (this.popupRef) {
            this.hide();
        }
        else {
            this.show();
        }
    };
    PopoverAnchorDirective.prototype.subscribeToEvents = function (arr) {
        var _this = this;
        this.subs.add(this.renderer.listen(this.hostEl.nativeElement, arr[0].name, function () {
            _this.popoverService.emitAnchorState(true, _this.hostEl.nativeElement);
            arr[0].handler();
        }));
        this.subs.add(this.renderer.listen(this.hostEl.nativeElement, arr[1].name, function (e) {
            _this.popoverService.emitAnchorState(false, null);
            arr[1].handler({ domEvent: e });
        }));
    };
    PopoverAnchorDirective.prototype.subscribeClick = function () {
        var _this = this;
        if (this.disposeClickListener) {
            this.disposeClickListener();
        }
        this.disposeClickListener = this.renderer.listen(document, 'click', function (e) {
            _this.onClick(e);
        });
    };
    /**
     * @hidden
     */
    PopoverAnchorDirective.prototype.onClick = function (event) {
        var _this = this;
        var isInsidePopup = !!closest(event.target, function (node) { return node.classList && node.classList.contains('k-popup'); });
        var isAnchor = !!closest(event.target, function (node) { return node === _this.hostEl.nativeElement; });
        if (isInsidePopup || (this.popupRef && isAnchor)) {
            return;
        }
        if (isAnchor) {
            // on opening
            this.controlVisibility(this.hostEl.nativeElement, true);
        }
        else {
            // on closing
            this.controlVisibility(this.hostEl.nativeElement, false);
        }
    };
    PopoverAnchorDirective.prototype.controlVisibility = function (anchor, show) {
        if (this.isPrevented(anchor, show)) {
            return;
        }
        show ? this.show() : this.hide();
    };
    PopoverAnchorDirective = __decorate([
        Directive({
            selector: '[kendoPopoverAnchor]',
            exportAs: 'kendoPopoverAnchor',
            providers: [PopoverService]
        }),
        __metadata("design:paramtypes", [ElementRef,
            NgZone,
            PopupService,
            Renderer2,
            PopoverService])
    ], PopoverAnchorDirective);
    return PopoverAnchorDirective;
}(PopoverDirectivesBase));

/**
 * @hidden
 */
var LocalizedMessagesDirective = /** @class */ (function (_super) {
    __extends(LocalizedMessagesDirective, _super);
    function LocalizedMessagesDirective(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    LocalizedMessagesDirective_1 = LocalizedMessagesDirective;
    var LocalizedMessagesDirective_1;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LocalizedMessagesDirective.prototype, "closeTitle", void 0);
    LocalizedMessagesDirective = LocalizedMessagesDirective_1 = __decorate([
        Directive({
            providers: [
                {
                    provide: ComponentMessages,
                    useExisting: forwardRef(function () { return LocalizedMessagesDirective_1; })
                }
            ],
            selector: "[kendoTooltipLocalizedMessages]"
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], LocalizedMessagesDirective);
    return LocalizedMessagesDirective;
}(ComponentMessages));

var COMPONENT_DIRECTIVES = [TooltipDirective, TooltipContentComponent, LocalizedMessagesDirective];
var COMPONENT_MODULES = [PopupModule];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Tooltip component.
 *
 * The package exports:
 * - `KendoTooltipDirective`&mdash;The Tooltip directive class.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Tooltip module
 * import { TooltipModule } from '@progress/kendo-angular-tooltip';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * _@NgModule{{
 *    declarations: [AppComponent], // declare app component
 *    imports:      [BrowserModule, TooltipModule], // import TooltipModule module
 *    bootstrap:    [AppComponent]
 * }}
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 * ```
 */
var TooltipModule = /** @class */ (function () {
    function TooltipModule() {
    }
    TooltipModule = __decorate([
        NgModule({
            declarations: [COMPONENT_DIRECTIVES],
            entryComponents: [TooltipContentComponent],
            imports: [CommonModule].concat(COMPONENT_MODULES),
            exports: [COMPONENT_DIRECTIVES]
        })
    ], TooltipModule);
    return TooltipModule;
}());

var DIRECTIVES = [
    PopoverActionsTemplateDirective,
    PopoverBodyTemplateDirective,
    PopoverTitleTemplateDirective,
    PopoverAnchorDirective,
    PopoverContainerDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Popover component.
 *
 * @example
 *
 * ```ts-no-run
 * import { PopoverModule } from '@progress/kendo-angular-tooltip';
 *
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { NgModule } from '@angular/core';
 *
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, PopoverModule],
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var PopoverModule = /** @class */ (function () {
    function PopoverModule() {
    }
    PopoverModule = __decorate([
        NgModule({
            declarations: DIRECTIVES.concat([
                PopoverComponent
            ]),
            entryComponents: [PopoverComponent],
            exports: DIRECTIVES.concat([PopoverComponent]),
            imports: [
                CommonModule,
                PopupModule
            ]
        })
    ], PopoverModule);
    return PopoverModule;
}());

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Tooltips components.
 *
 * @example
 *
 * ```ts-no-run
 * import { TooltipsModule } from '@progress/kendo-angular-tooltip';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * _@NgModule{{
 *    declarations: [AppComponent], // declare app component
 *    imports:      [BrowserModule, TooltipsModule], // import TooltipsModule module
 *    bootstrap:    [AppComponent]
 * }}
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 * ```
 */
var TooltipsModule = /** @class */ (function () {
    function TooltipsModule() {
    }
    TooltipsModule = __decorate([
        NgModule({
            exports: [TooltipModule, PopoverModule]
        })
    ], TooltipsModule);
    return TooltipsModule;
}());

// Tooltip

/**
 * Generated bundle index. Do not edit.
 */

export { LocalizedMessagesDirective, PopoverDirectivesBase, PopoverService, TooltipContentComponent, TooltipDirective, TooltipSettings, TOOLTIP_SETTINGS, PopoverComponent, PopoverContainerDirective, PopoverAnchorDirective, PopoverTitleTemplateDirective, PopoverBodyTemplateDirective, PopoverActionsTemplateDirective, PopoverShowEvent, PopoverShownEvent, PopoverHideEvent, PopoverHiddenEvent, TooltipModule, PopoverModule, TooltipsModule };
