/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param } from 'tslib';
import { Injectable, Directive, TemplateRef, Optional, isDevMode, Input, ViewChild, ElementRef, HostBinding, ViewChildren, QueryList, ContentChildren, Component, SkipSelf, Host, Renderer2, EventEmitter, Output, ContentChild, HostListener, ChangeDetectorRef, NgZone, Inject, forwardRef, ViewEncapsulation, NgModule } from '@angular/core';
import { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';
import { Keys, DraggableDirective, PreventableEvent, isDocumentAvailable, hasObservers, EventsModule, DraggableModule, ResizeSensorModule, isChanged } from '@progress/kendo-angular-common';
import { validatePackage } from '@progress/kendo-licensing';
import { trigger, state, style, transition, animate, AUTO_STYLE, AnimationBuilder } from '@angular/animations';
import { Subject, BehaviorSubject, Subscription, of } from 'rxjs';
import { tap, filter, switchMap, delay, takeUntil, map, take } from 'rxjs/operators';
import Draggable from '@telerik/kendo-draggable';
import { CommonModule } from '@angular/common';
import { ProgressBarModule } from '@progress/kendo-angular-progressbar';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@progress/kendo-angular-l10n';
import * as ɵngcc3 from '@progress/kendo-angular-common';
import * as ɵngcc4 from '@angular/animations';
import * as ɵngcc5 from '@progress/kendo-angular-progressbar';

const _c0 = ["header"];
const _c1 = ["contentWrapper"];
function PanelBarItemComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 6);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.iconClasses);
} }
function PanelBarItemComponent_img_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "img", 7);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("src", ctx_r2.imageUrl, ɵngcc0.ɵɵsanitizeUrl);
} }
function PanelBarItemComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 8);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.title);
} }
function PanelBarItemComponent_5_ng_template_0_Template(rf, ctx) { }
const _c2 = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return { title: a0, id: a1, icon: a2, iconClass: a3, imageUrl: a4, selected: a5, expanded: a6, disabled: a7, focused: a8, content: a9 }; };
const _c3 = function (a0) { return { item: a0 }; };
function PanelBarItemComponent_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, PanelBarItemComponent_5_ng_template_0_Template, 0, 0, "ng-template", 9);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.titleTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(13, _c3, ɵngcc0.ɵɵpureFunctionV(2, _c2, [ctx_r4.title, ctx_r4.id, ctx_r4.icon, ctx_r4.iconClass, ctx_r4.imageUrl, ctx_r4.selected, ctx_r4.expanded, ctx_r4.disabled, ctx_r4.focused, ctx_r4.content])));
} }
const _c4 = function (a0, a1) { return { "k-i-arrow-chevron-up k-panelbar-collapse": a0, "k-i-arrow-chevron-down k-panelbar-expand": a1 }; };
function PanelBarItemComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(1, _c4, ctx_r5.expanded, !ctx_r5.expanded));
} }
function PanelBarItemComponent_div_7_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r9.contentOverflow)("height", ctx_r9.contentHeight);
} }
function PanelBarItemComponent_div_7_div_3_ng_template_1_Template(rf, ctx) { }
const _c5 = function (a0, a1, a2, a3, a4, a5) { return { title: a0, id: a1, icon: a2, imageUrl: a3, disabled: a4, content: a5 }; };
const _c6 = function (a0) { return { $implicit: a0 }; };
function PanelBarItemComponent_div_7_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_3_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r10.contentOverflow)("height", ctx_r10.contentHeight);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r10.contentTemplate.first.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(13, _c6, ɵngcc0.ɵɵpureFunction6(6, _c5, ctx_r10.title, ctx_r10.id, ctx_r10.icon, ctx_r10.imageUrl, ctx_r10.disabled, ctx_r10.content)));
} }
function PanelBarItemComponent_div_7_div_4_ng_container_1_kendo_panelbar_item_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-panelbar-item", 18);
} if (rf & 2) {
    const item_r15 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r16 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("title", item_r15.title)("id", item_r15.id)("icon", item_r15.icon)("iconClass", item_r15.iconClass)("imageUrl", item_r15.imageUrl)("selected", !!item_r15.selected)("expanded", !!item_r15.expanded)("disabled", !!item_r15.disabled)("template", ctx_r16.template)("items", item_r15.children)("content", item_r15.content);
} }
function PanelBarItemComponent_div_7_div_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_4_ng_container_1_kendo_panelbar_item_1_Template, 1, 11, "kendo-panelbar-item", 17);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r15 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r15.hidden);
} }
function PanelBarItemComponent_div_7_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_4_ng_container_1_Template, 2, 1, "ng-container", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r11.contentOverflow)("height", ctx_r11.contentHeight);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r11.items);
} }
function PanelBarItemComponent_div_7_div_5_ng_template_1_Template(rf, ctx) { }
function PanelBarItemComponent_div_7_div_5_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r19 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r19.content);
} }
function PanelBarItemComponent_div_7_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_5_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵngcc0.ɵɵtemplate(2, PanelBarItemComponent_div_7_div_5_ng_template_2_Template, 1, 1, "ng-template", 19);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r12.contentOverflow)("height", ctx_r12.contentHeight);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r12.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(14, _c6, ɵngcc0.ɵɵpureFunction6(7, _c5, ctx_r12.title, ctx_r12.id, ctx_r12.icon, ctx_r12.imageUrl, ctx_r12.disabled, ctx_r12.content)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r12.template);
} }
function PanelBarItemComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", null, 11);
    ɵngcc0.ɵɵtemplate(2, PanelBarItemComponent_div_7_div_2_Template, 2, 4, "div", 12);
    ɵngcc0.ɵɵtemplate(3, PanelBarItemComponent_div_7_div_3_Template, 2, 15, "div", 13);
    ɵngcc0.ɵɵtemplate(4, PanelBarItemComponent_div_7_div_4_Template, 2, 5, "div", 12);
    ɵngcc0.ɵɵtemplate(5, PanelBarItemComponent_div_7_div_5_Template, 3, 16, "div", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@toggle", ctx_r6.state);
    ɵngcc0.ɵɵattribute("role", "group")("aria-hidden", !ctx_r6.disabled && !ctx_r6.expanded);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.hasChildItems && !(ctx_r6.items == null ? null : ctx_r6.items.length));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.hasContent && !ctx_r6.content);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.hasItems);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.content);
} }
const _c7 = [[["kendo-panelbar-item"]]];
const _c8 = ["kendo-panelbar-item"];
function PanelBarComponent_ng_content_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "contentChildItems && !items"]);
} }
function PanelBarComponent_ng_template_1_ng_container_0_kendo_panelbar_item_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-panelbar-item", 4);
} if (rf & 2) {
    const item_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("title", item_r3.title)("id", item_r3.id)("icon", item_r3.icon)("iconClass", item_r3.iconClass)("imageUrl", item_r3.imageUrl)("selected", !!item_r3.selected)("expanded", !!item_r3.expanded)("disabled", !!item_r3.disabled)("template", ctx_r4.templateRef)("items", item_r3.children)("content", item_r3.content);
} }
function PanelBarComponent_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, PanelBarComponent_ng_template_1_ng_container_0_kendo_panelbar_item_1_Template, 1, 11, "kendo-panelbar-item", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r3.hidden);
} }
function PanelBarComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, PanelBarComponent_ng_template_1_ng_container_0_Template, 2, 1, "ng-container", 2);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.items);
} }
function SplitterPaneComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SplitterPaneComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 2);
} }
const _c9 = ["*"];
function SplitterComponent_ng_container_1_kendo_splitter_bar_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-splitter-bar", 2);
} if (rf & 2) {
    const index_r2 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("index", index_r2)("orientation", ctx_r4.orientation);
} }
function SplitterComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, SplitterComponent_ng_container_1_kendo_splitter_bar_1_Template, 1, 2, "kendo-splitter-bar", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const last_r3 = ctx.last;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r3);
} }
const _c10 = [[["kendo-splitter-pane"]]];
const _c11 = ["kendo-splitter-pane"];
const _c12 = ["kendoTabStripScrollableButton", ""];
const _c13 = ["tablist"];
const _c14 = ["prevScrollButton"];
const _c15 = ["nextScrollButton"];
const _c16 = ["tabHeaderContainer"];
function TabStripComponent_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵtemplate(2, TabStripComponent_ng_container_1_ng_container_2_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(4);
    const _r4 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
} }
function TabStripComponent_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵtemplate(2, TabStripComponent_ng_container_2_ng_container_2_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r4 = ɵngcc0.ɵɵreference(6);
    const _r2 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
} }
function TabStripComponent_ng_template_3_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 11, 12);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("prev", true);
} }
function TabStripComponent_ng_template_3_ng_container_4_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 14, 15);
    ɵngcc0.ɵɵlistener("click", function TabStripComponent_ng_template_3_ng_container_4_li_1_Template_li_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const i_r17 = ɵngcc0.ɵɵnextContext().index; const ctx_r20 = ɵngcc0.ɵɵnextContext(2); return ctx_r20.onTabClick($event, i_r17); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r23 = ɵngcc0.ɵɵnextContext();
    const tab_r16 = ctx_r23.$implicit;
    const i_r17 = ctx_r23.index;
    const ctx_r18 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", tab_r16.cssClass)("ngStyle", tab_r16.cssStyle)("tab", tab_r16)("index", i_r17)("tabStripClosable", ctx_r18.closable)("tabStripCloseIcon", ctx_r18.closeIcon)("id", "k-tabstrip-tab-" + i_r17);
    ɵngcc0.ɵɵattribute("aria-controls", "k-tabstrip-tabpanel-" + i_r17);
} }
function TabStripComponent_ng_template_3_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_template_3_ng_container_4_li_1_Template, 2, 8, "li", 13);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const tab_r16 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !tab_r16.closed);
} }
function TabStripComponent_ng_template_3_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 11, 16);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("prev", false);
} }
function TabStripComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_template_3_span_1_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementStart(2, "ul", 8, 9);
    ɵngcc0.ɵɵtemplate(4, TabStripComponent_ng_template_3_ng_container_4_Template, 2, 1, "ng-container", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, TabStripComponent_ng_template_3_span_5_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r3.itemsWrapperClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.hasScrollButtons);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("justify-content", ctx_r3.tabsAlignmentStyles)("width", ctx_r3.tabListWidth)("height", ctx_r3.tabListHeight);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.tabs);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.hasScrollButtons);
} }
function TabStripComponent_ng_template_5_ng_template_0_div_0_ng_template_1_Template(rf, ctx) { }
function TabStripComponent_ng_template_5_ng_template_0_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 19);
    ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_template_5_ng_template_0_div_0_ng_template_1_Template, 0, 0, "ng-template", 20);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r30 = ɵngcc0.ɵɵnextContext();
    const tab_r26 = ctx_r30.$implicit;
    const i_r27 = ctx_r30.index;
    const ctx_r28 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("@state", tab_r26.selected && ctx_r28.animate ? "active" : "inactive")("ngClass", !ctx_r28.keepTabContent || tab_r26.selected ? "k-content k-state-active" : "k-content")("tabIndex", 0)("id", "k-tabstrip-tabpanel-" + i_r27);
    ɵngcc0.ɵɵattribute("aria-hidden", !tab_r26.selected)("aria-expanded", tab_r26.selected)("aria-labelledby", "k-tabstrip-tab-" + i_r27)("aria-disabled", tab_r26.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", tab_r26.tabContent == null ? null : tab_r26.tabContent.templateRef);
} }
function TabStripComponent_ng_template_5_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TabStripComponent_ng_template_5_ng_template_0_div_0_Template, 2, 9, "div", 18);
} if (rf & 2) {
    const tab_r26 = ctx.$implicit;
    const ctx_r25 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngIf", !tab_r26.closed && (tab_r26.selected || ctx_r25.keepTabContent));
} }
function TabStripComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TabStripComponent_ng_template_5_ng_template_0_Template, 1, 1, "ng-template", 17);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r5.tabs);
} }
function TabStripComponent_kendo_resize_sensor_7_Template(rf, ctx) { if (rf & 1) {
    const _r32 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-resize-sensor", 21);
    ɵngcc0.ɵɵlistener("resize", function TabStripComponent_kendo_resize_sensor_7_Template_kendo_resize_sensor_resize_0_listener() { ɵngcc0.ɵɵrestoreView(_r32); const ctx_r31 = ɵngcc0.ɵɵnextContext(); return ctx_r31.onResize(); });
    ɵngcc0.ɵɵelementEnd();
} }
function DrawerComponent_div_0_ng_container_1_1_ng_template_0_Template(rf, ctx) { }
function DrawerComponent_div_0_ng_container_1_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_ng_container_1_1_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.headerTemplate == null ? null : ctx_r3.headerTemplate.templateRef);
} }
function DrawerComponent_div_0_ng_container_1_3_ng_template_0_Template(rf, ctx) { }
function DrawerComponent_div_0_ng_container_1_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_ng_container_1_3_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.footerTemplate == null ? null : ctx_r4.footerTemplate.templateRef);
} }
function DrawerComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, DrawerComponent_div_0_ng_container_1_1_Template, 1, 1, null, 2);
    ɵngcc0.ɵɵelement(2, "ul", 3);
    ɵngcc0.ɵɵtemplate(3, DrawerComponent_div_0_ng_container_1_3_Template, 1, 1, null, 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("items", ctx_r1.items)("mini", ctx_r1.mini)("expanded", ctx_r1.expanded)("itemTemplate", ctx_r1.itemTemplate == null ? null : ctx_r1.itemTemplate.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.footerTemplate);
} }
function DrawerComponent_div_0_2_ng_template_0_Template(rf, ctx) { }
function DrawerComponent_div_0_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_2_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.drawerTemplate == null ? null : ctx_r2.drawerTemplate.templateRef);
} }
function DrawerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵtemplate(1, DrawerComponent_div_0_ng_container_1_Template, 4, 6, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(2, DrawerComponent_div_0_2_Template, 1, 1, null, 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r0.drawerWidth, "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.drawerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.drawerTemplate);
} }
function DrawerContainerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵlistener("click", function DrawerContainerComponent_div_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.closeDrawer(); });
    ɵngcc0.ɵɵelementEnd();
} }
function StepperComponent_kendo_progressbar_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-progressbar", 3);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("animation", ctx_r0.progressAnimation)("max", ctx_r0.steps.length - 1)("label", false)("orientation", ctx_r0.orientation)("reverse", !ctx_r0.isHorizontal)("value", ctx_r0.currentStep)("ngStyle", ctx_r0.progressBarStyling);
    ɵngcc0.ɵɵattribute("aria-hidden", true);
} }
function AvatarComponent_ng_content_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "customAvatar"]);
} }
function AvatarComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 1);
    ɵngcc0.ɵɵelement(2, "img", 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵpropertyInterpolate("src", ctx_r1.imageSrc, ɵngcc0.ɵɵsanitizeUrl);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r1.cssStyle);
} }
function AvatarComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 3);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r2.cssStyle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.initials.substring(0, 2));
} }
function AvatarComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r3.cssStyle)("ngClass", ctx_r3.iconClasses());
} }
function CardActionsComponent_ng_content_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "!actions"]);
} }
function CardActionsComponent_ng_container_1_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function CardActionsComponent_ng_container_1_button_1_Template_button_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r6); const action_r4 = restoredCtx.$implicit; const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.onClick(action_r4); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r4 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("k-primary", action_r4.primary)("k-flat", action_r4.flat);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", action_r4.text, " ");
} }
function CardActionsComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, CardActionsComponent_ng_container_1_button_1_Template, 2, 5, "button", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.actions);
} }
function CardActionsComponent_2_ng_template_0_Template(rf, ctx) { }
function CardActionsComponent_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, CardActionsComponent_2_ng_template_0_Template, 0, 0, "ng-template", 3);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.actions);
} }
const _c21 = ["content"];
function ExpansionPanelComponent_ng_container_1_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.title);
} }
function ExpansionPanelComponent_ng_container_1_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r4.subtitle, " ");
} }
function ExpansionPanelComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ExpansionPanelComponent_ng_container_1_div_1_Template, 2, 1, "div", 7);
    ɵngcc0.ɵɵelement(2, "span", 8);
    ɵngcc0.ɵɵtemplate(3, ExpansionPanelComponent_ng_container_1_div_3_Template, 2, 1, "div", 9);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.title);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.subtitle);
} }
function ExpansionPanelComponent_2_ng_template_0_Template(rf, ctx) { }
function ExpansionPanelComponent_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ExpansionPanelComponent_2_ng_template_0_Template, 0, 0, "ng-template", 12);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.titleTemplate == null ? null : ctx_r1.titleTemplate.templateRef);
} }
function TileLayoutItemComponent_kendo_tilelayout_item_header_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "kendo-tilelayout-item-header")(1, "h5", 1);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);
} }
function TileLayoutItemComponent_ng_container_2_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 3);
} if (rf & 2) {
    const dir_r3 = ctx.$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassMapInterpolate1("k-resize-handle k-cursor-", dir_r3, "-resize k-touch-action-none");
    ɵngcc0.ɵɵproperty("rtl", ctx_r2.rtl)("resizeDirection", dir_r3);
} }
function TileLayoutItemComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TileLayoutItemComponent_ng_container_2_div_1_Template, 1, 5, "div", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.resizeDirections);
} }
const _c22 = ["hint"];
const _c23 = ["kendoDrawerItem", ""];
function DrawerItemComponent_0_ng_template_0_Template(rf, ctx) { }
function DrawerItemComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerItemComponent_0_ng_template_0_Template, 0, 0, "ng-template", 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.itemTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c6, ctx_r0.item));
} }
function DrawerItemComponent_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span", 4);
    ɵngcc0.ɵɵelementStart(2, "span", 5);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r4.iconClasses);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.item.text);
} }
function DrawerItemComponent_ng_template_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r5.iconClasses);
} }
function DrawerItemComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerItemComponent_ng_template_1_ng_container_0_Template, 4, 2, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(1, DrawerItemComponent_ng_template_1_ng_container_1_Template, 2, 1, "ng-container", 3);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.expanded);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.mini && !ctx_r2.expanded);
} }
const _c24 = ["kendoDrawerList", ""];
function DrawerListComponent_ng_container_0_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "li", 3);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    const item_r1 = ctx_r5.$implicit;
    const idx_r2 = ctx_r5.index;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("item", item_r1)("index", idx_r2)("mini", ctx_r3.mini)("expanded", ctx_r3.expanded)("itemTemplate", ctx_r3.itemTemplate)("ngClass", item_r1.cssClass)("ngStyle", item_r1.cssStyle);
    ɵngcc0.ɵɵattribute("data-kendo-drawer-index", idx_r2);
} }
function DrawerListComponent_ng_container_0_li_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 4);
    ɵngcc0.ɵɵtext(1, " \u00A0 ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("ngClass", item_r1.cssClass)("ngStyle", item_r1.cssStyle);
} }
function DrawerListComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, DrawerListComponent_ng_container_0_li_1_Template, 1, 8, "li", 1);
    ɵngcc0.ɵɵtemplate(2, DrawerListComponent_ng_container_0_li_2_Template, 2, 2, "li", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r1.separator);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r1.separator);
} }
const _c25 = ["stepLink"];
const _c26 = ["kendoStepperStep", ""];
function StepperStepComponent_2_ng_template_0_Template(rf, ctx) { }
const _c27 = function (a0, a1) { return { $implicit: a0, index: a1 }; };
function StepperStepComponent_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, StepperStepComponent_2_ng_template_0_Template, 0, 0, "ng-template", 3);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.stepTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c27, ctx_r1.step, ctx_r1.index));
} }
function StepperStepComponent_ng_container_3_span_1_1_ng_template_0_Template(rf, ctx) { }
function StepperStepComponent_ng_container_3_span_1_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, StepperStepComponent_ng_container_3_span_1_1_ng_template_0_Template, 0, 0, "ng-template", 3);
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r6.indicatorTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c27, ctx_r6.step, ctx_r6.index));
} }
function StepperStepComponent_ng_container_3_span_1_ng_container_2_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 9);
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r9.indicatorIconClasses);
} }
function StepperStepComponent_ng_container_3_span_1_ng_container_2_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r10.indicatorText);
} }
function StepperStepComponent_ng_container_3_span_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_1_ng_container_2_span_1_Template, 1, 1, "span", 7);
    ɵngcc0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_1_ng_container_2_span_2_Template, 2, 1, "span", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.showIndicatorIcon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r7.showIndicatorIcon);
} }
function StepperStepComponent_ng_container_3_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_1_1_Template, 1, 5, null, 2);
    ɵngcc0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_1_ng_container_2_Template, 3, 2, "ng-container", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("transition-duration", ctx_r4.transitionDuration, "ms");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.indicatorTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r4.indicatorTemplate);
} }
function StepperStepComponent_ng_container_3_span_2_1_ng_template_0_Template(rf, ctx) { }
function StepperStepComponent_ng_container_3_span_2_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, StepperStepComponent_ng_container_3_span_2_1_ng_template_0_Template, 0, 0, "ng-template", 3);
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r11.labelTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c27, ctx_r11.step, ctx_r11.index));
} }
function StepperStepComponent_ng_container_3_span_2_ng_container_2_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 15);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r14.step.label);
} }
function StepperStepComponent_ng_container_3_span_2_ng_container_2_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 16);
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r15.validationIconClasses);
} }
function StepperStepComponent_ng_container_3_span_2_ng_container_2_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 17);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("(", ctx_r16.optionalText, ")");
} }
function StepperStepComponent_ng_container_3_span_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_2_ng_container_2_span_1_Template, 2, 1, "span", 12);
    ɵngcc0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_2_ng_container_2_span_2_Template, 1, 1, "span", 13);
    ɵngcc0.ɵɵtemplate(3, StepperStepComponent_ng_container_3_span_2_ng_container_2_span_3_Template, 2, 1, "span", 14);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r12.showLabelText);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r12.showLabelIcon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r12.step.optional);
} }
function StepperStepComponent_ng_container_3_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 11);
    ɵngcc0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_2_1_Template, 1, 5, null, 2);
    ɵngcc0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_2_ng_container_2_Template, 4, 3, "ng-container", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.labelTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r5.labelTemplate);
} }
function StepperStepComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_1_Template, 3, 4, "span", 4);
    ɵngcc0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_2_Template, 3, 2, "span", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.showIndicator);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.showLabel);
} }
const _c28 = ["kendoStepperList", ""];
function StepperListComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "li", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const step_r1 = ctx.$implicit;
    const idx_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("max-width", ctx_r0.maxStepWidth, "%")("max-height", ctx_r0.maxStepHeight, "%");
    ɵngcc0.ɵɵclassProp("k-step-first", idx_r2 === 0)("k-step-last", idx_r2 === ctx_r0.steps.length - 1)("k-step-done", idx_r2 < ctx_r0.currentStep)("k-step-current", idx_r2 === ctx_r0.currentStep)("k-step-optional", step_r1.optional)("k-step-disabled", step_r1.disabled);
    ɵngcc0.ɵɵproperty("type", ctx_r0.stepType)("step", step_r1)("index", idx_r2)("current", ctx_r0.currentStep)("successIcon", ctx_r0.successIcon)("errorIcon", ctx_r0.errorIcon)("indicatorTemplate", ctx_r0.indicatorTemplate)("labelTemplate", ctx_r0.labelTemplate)("stepTemplate", ctx_r0.stepTemplate)("ngClass", step_r1.cssClass)("ngStyle", step_r1.cssStyle);
    ɵngcc0.ɵɵattribute("data-kendo-stepper-index", idx_r2);
} }
const _c29 = ["kendoTabStripTab", ""];
function TabComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.tab.title);
} }
function TabComponent_span_1_ng_template_1_Template(rf, ctx) { }
function TabComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 2);
    ɵngcc0.ɵɵtemplate(1, TabComponent_span_1_ng_template_1_Template, 0, 0, "ng-template", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.tab.tabTitle == null ? null : ctx_r1.tab.tabTitle.templateRef);
} }
function TabComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵlistener("click", function TabComponent_span_2_Template_span_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.closeTab(ctx_r4.index); });
    ɵngcc0.ɵɵelement(1, "span", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r2.closeButtonTitle);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.closeButtonTitle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r2.closeButtonClasses);
} }
const packageMetadata = {
    name: '@progress/kendo-angular-layout',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1649340417,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * Represents the expand modes of the PanelBar.
 * By default, the expand mode is set to `multiple`.
 */
var PanelBarExpandMode;
(function (PanelBarExpandMode) {
    /**
     * Allows you to expand only one item at a time.
     * When you expand an item, the item that was previously expanded is coll.
     */
    PanelBarExpandMode[PanelBarExpandMode["Single"] = 0] = "Single";
    /**
     * Allows you to expand only one item at a time and requires you to set the `height` property.
     * The expanded area occupies the entire height of the PanelBar.
     */
    PanelBarExpandMode[PanelBarExpandMode["Full"] = 1] = "Full";
    /**
     * The default mode of the PanelBar.
     * Allows you to expand more than one item at a time. Items can also be toggled.
     */
    PanelBarExpandMode[PanelBarExpandMode["Multiple"] = 2] = "Multiple";
    /**
     * By default, the expand mode is set to `multiple`.
     */
    PanelBarExpandMode[PanelBarExpandMode["Default"] = 2] = "Default";
})(PanelBarExpandMode || (PanelBarExpandMode = {}));

/**
 * @hidden
 */
let nextPanelbarId = 0;
/**
 * @hidden
 */
let PanelBarService = class PanelBarService {
    constructor() {
        this.parentSource = new Subject();
        this.keepContentSource = new BehaviorSubject(false);
        this.childSource = new Subject();
        this.parent$ = this.parentSource.asObservable();
        this.children$ = this.childSource.asObservable();
        this.keepContent$ = this.keepContentSource.asObservable();
        this.pbId = nextPanelbarId++;
    }
    onKeepContent(keepContent) {
        this.keepContentSource.next(keepContent);
    }
    onSelect(event) {
        this.childSource.next(event);
    }
    onFocus() {
        this.parentSource.next(true);
    }
    onBlur() {
        this.parentSource.next(false);
    }
};
PanelBarService.ɵfac = function PanelBarService_Factory(t) { return new (t || PanelBarService)(); };
PanelBarService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: PanelBarService, factory: function (t) { return PanelBarService.ɵfac(t); } });
PanelBarService = __decorate([ __metadata("design:paramtypes", [])
], PanelBarService);

/**
 * Represents the content template of the declaratively initialized PanelBar items.
 * The content can be expanded or collapsed through the item.
 */
let PanelBarContentDirective = class PanelBarContentDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
PanelBarContentDirective.ɵfac = function PanelBarContentDirective_Factory(t) { return new (t || PanelBarContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
PanelBarContentDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: PanelBarContentDirective, selectors: [["", "kendoPanelBarContent", ""]] });
PanelBarContentDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], PanelBarContentDirective);

/**
 * Represents the template directive of the PanelBar which helps to customize the item title
 * ([more information and example]({% slug templates_panelbar %}#toc-customizing-the-appearance-of-the-title)).
 *
 * > The `kendoPanelBarItemTitle` directive overrides the PanelBarItem [title]({% slug api_layout_panelbaritemcomponent %}#toc-title) option.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *        <kendo-panelbar>
 *            <kendo-panelbar-item [expanded]="true">
 *                <ng-template kendoPanelBarItemTitle>
 *                    Item Title
 *                </ng-template>
 *            </kendo-panelbar-item>
 *        </kendo-panelbar>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
let PanelBarItemTitleDirective = class PanelBarItemTitleDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
PanelBarItemTitleDirective.ɵfac = function PanelBarItemTitleDirective_Factory(t) { return new (t || PanelBarItemTitleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
PanelBarItemTitleDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: PanelBarItemTitleDirective, selectors: [["", "kendoPanelBarItemTitle", ""]] });
PanelBarItemTitleDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], PanelBarItemTitleDirective);

let nextId = 0;
const SIZES = {
    small: 'sm',
    medium: 'md',
    large: 'lg'
};
const ROUNDNESS = {
    small: 'sm',
    medium: 'md',
    large: 'lg',
    full: 'full'
};
const SHAPE_TO_ROUNDED = {
    rounded: 'large',
    circle: 'full'
};
const parsePanelBarItems = (data) => {
    return data.map((item) => {
        if (!item.id) {
            item.id = `default-${nextId++}`;
        }
        if (item.children) {
            item.children = parsePanelBarItems(item.children);
        }
        return item;
    });
};
var util = {
    parsePanelBarItems
};
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const isHorizontalArrowKey = keyCode => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight;
/**
 * @hidden
 */
const isVerticalArrowKey = keyCode => keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;
/**
 * @hidden
 */
const isArrowKey = keyCode => isHorizontalArrowKey(keyCode) || isVerticalArrowKey(keyCode);
/**
 * @hidden
 */
const isNavigationKey = keyCode => keyCode === Keys.PageUp || keyCode === Keys.PageDown ||
    keyCode === Keys.Home || keyCode === Keys.End;
/**
 * @hidden
 *
 * Returns the styling classes to be added and removed
 */
const getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {
    switch (stylingOption) {
        case 'size':
            return {
                toRemove: `k-${componentType}-${SIZES[previousValue]}`,
                toAdd: newValue ? `k-${componentType}-${SIZES[newValue]}` : null
            };
        case 'rounded':
            return {
                toRemove: `k-rounded-${ROUNDNESS[previousValue]}`,
                toAdd: newValue ? `k-rounded-${ROUNDNESS[newValue]}` : null
            };
        default:
            break;
    }
};
/**
 * @hidden
 */
const mapShapeToRounded = (shape) => SHAPE_TO_ROUNDED[shape] || null;
/**
 * @hidden
 */
const isNumber = (value) => typeof value === 'number' && isFinite(value);

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabIndex');
        const skipTab = tabIndex === '-1';
        let focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
/**
 * @hidden
 */
const hasClass = (element, className) => Boolean(toClassList(element.className).find((name) => name === className));
/**
 * @hidden
 */
const closestInScope = (target, predicate, scope, targetAttr) => {
    while (target && target !== scope && !predicate(target, targetAttr)) {
        target = target.parentNode;
    }
    if (target !== scope) {
        return target;
    }
};
/**
 * @hidden
 */
const itemIndex = (item, indexAttr) => +item.getAttribute(indexAttr);
const hasItemIndex = (item, indexAttr) => isPresent(item.getAttribute(indexAttr));
/**
 * @hidden
 */
const closestItem = (target, targetAttr, scope) => closestInScope(target, hasItemIndex, scope, targetAttr);

var PanelBarItemComponent_1;
/**
 * @hidden
 */
let nextId$1 = 0;
/**
 * Represents the items of the PanelBar.
 */
let PanelBarItemComponent = PanelBarItemComponent_1 = class PanelBarItemComponent {
    constructor(parent, eventService, element, renderer) {
        this.parent = parent;
        this.eventService = eventService;
        this.element = element;
        this.renderer = renderer;
        /**
         * Allows the component to set the `"id"` property to each item.
         * Used to set the `id` attributes of the nested elements and to enable the WAI-ARIA support.
         */
        this.id = `default-${nextId$1++}`;
        /**
         * Defines the icon that will be rendered next to the title ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.icon = '';
        /**
         * Defines  the icon that will be rendered next to the title by using a custom CSS class
         * ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.iconClass = '';
        /**
         * Defines the location of the image that will be displayed next to the title
         * ([see example]({% slug items_panelbar %}#toc-title-images)).
         */
        this.imageUrl = '';
        /**
         * When set to `true`, disables a PanelBar item ([see example]({% slug items_panelbar %}#toc-disabled-state)).
         */
        this.disabled = false;
        /**
         * Sets the selected state of a PanelBar item ([see example]({% slug items_panelbar %}#toc-selected-state)).
         */
        this.selected = false;
        this.keepContent = false;
        this.hasChildItems = false;
        this.hasItems = false;
        this.hasContent = false;
        this.state = "inactive";
        this.role = "treeitem";
        this.titleAttribute = null; // tslint:disable-line
        this.kItemClass = true;
        this.focused = false;
        this.wrapperFocused = false;
        this.subscriptions = new Subscription(() => { });
        this._expanded = false;
        this.subscriptions.add(eventService.parent$.subscribe(focused => this.onWrapperFocusChange(focused)));
        this.subscriptions.add(eventService.keepContent$.subscribe(keepContent => this.keepContent = keepContent));
        this.wrapperFocused = parent ? parent.focused : false;
        this.level = this.parent ? this.parent.level + 1 : 0;
    }
    /**
     * When set to `true`, expands the PanelBar item ([see example]({% slug items_panelbar %}#toc-expanded-state)).
     */
    set expanded(value) {
        const activeState = this.animate ? "active" : "activeWithoutAnimation";
        this.state = value ? activeState : "inactive";
        if (!this.keepContent) {
            this.toggleExpandedChildAnimations(value);
        }
        this._expanded = value;
    }
    get expanded() {
        return this._expanded;
    }
    get animate() {
        return this.eventService.animate;
    }
    get kStateDefaultClass() {
        return !this.disabled;
    }
    get kStateDisabledClass() {
        return this.disabled;
    }
    get kStateExpandedClass() {
        return !this.disabled && this.expanded && (this.hasChildItems || this.hasContent);
    }
    get itemId() {
        return 'k-panelbar-' + this.eventService.pbId + '-item-' + this.id;
    }
    get ariaExpanded() {
        return (this.hasChildItems || this.hasContent) ? !this.disabled && this.expanded : null;
    }
    get ariaSelected() {
        return !this.disabled && this.selected;
    }
    get ariaDisabled() {
        return this.disabled ? true : null;
    }
    get headerClass() {
        return this.parent ? null : true;
    }
    get childClass() {
        return this.parent ? true : null;
    }
    /**
     * @hidden
     */
    get titleTemplate() {
        return this.titleTemplates.length > 0 ? this.titleTemplates.toArray()[0].templateRef : undefined;
    }
    /**
     * @hidden
     */
    headerHeight() {
        return this.element.nativeElement.offsetHeight - (this.contentWrapper ? this.contentWrapper.nativeElement.offsetHeight : 0);
    }
    ngOnInit() {
        this.addLevelClass();
    }
    ngAfterContentChecked() {
        this.hasItems = this.items && this.items.filter(item => !item.hidden).length > 0;
        this.hasChildItems = this.contentItems.filter(item => item !== this).length > 0 || this.hasItems;
        this.hasContent = (this.contentTemplate !== undefined && this.contentTemplate.length > 0) ||
            this.content !== undefined;
        this.validateConfiguration();
    }
    ngAfterViewChecked() {
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
        }
        else {
            this.childrenItems = this.contentItems.filter(item => item !== this);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    onItemAction() {
        if (!this.disabled) {
            this.eventService.onSelect(this);
        }
    }
    /**
     * @hidden
     */
    onItemClick(e) {
        if (!isFocusable(e.target)) {
            this.onItemAction();
        }
    }
    /**
     * @hidden
     */
    get iconClasses() {
        let icon = this.icon ? 'k-i-' + this.icon : null;
        return {
            [icon || this.iconClass]: true
        };
    }
    /**
     * @hidden
     */
    serialize() {
        return {
            content: this.content,
            disabled: this.disabled,
            expanded: this.expanded,
            focused: this.focused,
            icon: this.icon,
            iconClass: this.iconClass,
            id: this.id,
            imageUrl: this.imageUrl,
            selected: this.selected,
            title: this.title
        };
    }
    /**
     * @hidden
     */
    subTreeViewItems() {
        let subTree = [];
        this.viewChildItems.forEach(item => {
            subTree = subTree.concat(item.subTreeViewItems());
            subTree.push(item);
        });
        return subTree;
    }
    /**
     * @hidden
     */
    validateConfiguration() {
        if (isDevMode()) {
            if (this.content && (this.contentTemplate !== undefined && this.contentTemplate.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and component property.");
            }
        }
    }
    /**
     * @hidden
     */
    toggleAnimationState(value) {
        if (!this.animate) {
            return;
        }
        this.state = value && this.eventService.expandMode !== PanelBarExpandMode.Single ? 'active' : 'activeWithoutAnimation';
    }
    /**
     * @hidden
     */
    toggleExpandedChildAnimations(value) {
        if (this.childrenItems) {
            this.childrenItems.forEach(child => {
                if (child.expanded) {
                    child.toggleAnimationState(value);
                    child.toggleExpandedChildAnimations(value);
                }
            });
        }
    }
    /**
     * @hidden
     */
    addLevelClass() {
        if (this.level >= 0) {
            this.renderer.addClass(this.element.nativeElement, `k-level-${this.level}`);
        }
    }
    onWrapperFocusChange(focused) {
        this.wrapperFocused = focused;
    }
};
PanelBarItemComponent.ɵfac = function PanelBarItemComponent_Factory(t) { return new (t || PanelBarItemComponent)(ɵngcc0.ɵɵdirectiveInject(PanelBarItemComponent, 13), ɵngcc0.ɵɵdirectiveInject(PanelBarService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
PanelBarItemComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PanelBarItemComponent, selectors: [["kendo-panelbar-item"]], contentQueries: function PanelBarItemComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent_1, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarContentDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemTitleDirective, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentItems = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.titleTemplates = _t);
    } }, viewQuery: function PanelBarItemComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 5);
        ɵngcc0.ɵɵviewQuery(_c1, 5);
        ɵngcc0.ɵɵviewQuery(PanelBarItemComponent_1, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentWrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewChildItems = _t);
    } }, hostVars: 18, hostBindings: function PanelBarItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.itemId);
        ɵngcc0.ɵɵattribute("role", ctx.role)("title", ctx.titleAttribute)("aria-expanded", ctx.ariaExpanded)("aria-selected", ctx.ariaSelected)("aria-disabled", ctx.ariaDisabled);
        ɵngcc0.ɵɵclassProp("k-item", ctx.kItemClass)("k-state-default", ctx.kStateDefaultClass)("k-state-disabled", ctx.kStateDisabledClass)("k-state-expanded", ctx.kStateExpandedClass)("k-panelbar-header", ctx.headerClass)("k-panelbar-item", ctx.childClass);
    } }, inputs: { id: "id", icon: "icon", iconClass: "iconClass", imageUrl: "imageUrl", disabled: "disabled", selected: "selected", expanded: "expanded", title: "title", content: "content", items: "items", template: "template" }, exportAs: ["kendoPanelbarItem"], ngContentSelectors: _c8, decls: 8, vars: 12, consts: [[3, "click"], ["header", ""], ["class", "k-icon k-panelbar-item-icon", 3, "ngClass", 4, "ngIf"], ["class", "k-image k-panelbar-item-icon", "alt", "", 3, "src", 4, "ngIf"], [4, "ngIf"], ["class", "k-icon k-panelbar-toggle", 3, "ngClass", 4, "ngIf"], [1, "k-icon", "k-panelbar-item-icon", 3, "ngClass"], ["alt", "", 1, "k-image", "k-panelbar-item-icon", 3, "src"], [1, "k-panelbar-item-text"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-icon", "k-panelbar-toggle", 3, "ngClass"], ["contentWrapper", ""], ["class", "k-panel k-group k-panelbar-group", 3, "overflow", "height", 4, "ngIf"], ["class", "k-content k-panelbar-content", 3, "overflow", "height", 4, "ngIf"], [1, "k-panel", "k-group", "k-panelbar-group"], [1, "k-content", "k-panelbar-content"], [4, "ngFor", "ngForOf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content", 4, "ngIf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content"], [3, "ngIf"]], template: function PanelBarItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵelementStart(0, "span", 0, 1);
        ɵngcc0.ɵɵlistener("click", function PanelBarItemComponent_Template_span_click_0_listener($event) { return ctx.onItemClick($event); });
        ɵngcc0.ɵɵtemplate(2, PanelBarItemComponent_span_2_Template, 1, 1, "span", 2);
        ɵngcc0.ɵɵtemplate(3, PanelBarItemComponent_img_3_Template, 1, 1, "img", 3);
        ɵngcc0.ɵɵtemplate(4, PanelBarItemComponent_ng_container_4_Template, 3, 1, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(5, PanelBarItemComponent_5_Template, 1, 15, null, 4);
        ɵngcc0.ɵɵtemplate(6, PanelBarItemComponent_span_6_Template, 1, 4, "span", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, PanelBarItemComponent_div_7_Template, 6, 7, "div", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-link", true)("k-state-selected", !ctx.disabled && ctx.selected)("k-state-focused", ctx.focused && ctx.wrapperFocused);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon || ctx.iconClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.imageUrl);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.titleTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.titleTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasChildItems || ctx.hasContent);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.keepContent || !ctx.disabled && ctx.expanded && (ctx.hasChildItems || ctx.hasContent));
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgForOf, PanelBarItemComponent], encapsulation: 2, data: { animation: [
            trigger('toggle', [
                state('inactive', style({ display: 'none' })),
                transition('* => active', [
                    style({ overflow: 'hidden', display: 'block', height: 0 }),
                    animate(200, style({ height: AUTO_STYLE }))
                ]),
                transition('active => *', [
                    style({ overflow: 'hidden', height: AUTO_STYLE }),
                    animate(200, style({ height: 0, display: 'none' }))
                ])
            ])
        ] } });
__decorate([
    Input(),
    __metadata("design:type", String)
], PanelBarItemComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PanelBarItemComponent.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PanelBarItemComponent.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PanelBarItemComponent.prototype, "iconClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PanelBarItemComponent.prototype, "imageUrl", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PanelBarItemComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], PanelBarItemComponent.prototype, "expanded", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PanelBarItemComponent.prototype, "selected", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PanelBarItemComponent.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], PanelBarItemComponent.prototype, "items", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], PanelBarItemComponent.prototype, "template", void 0);
__decorate([
    ViewChild('header', { static: false }),
    __metadata("design:type", ElementRef)
], PanelBarItemComponent.prototype, "header", void 0);
__decorate([
    ViewChild('contentWrapper', { static: false }),
    __metadata("design:type", ElementRef)
], PanelBarItemComponent.prototype, "contentWrapper", void 0);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String)
], PanelBarItemComponent.prototype, "role", void 0);
__decorate([
    HostBinding('attr.title'),
    __metadata("design:type", String)
], PanelBarItemComponent.prototype, "titleAttribute", void 0);
__decorate([
    HostBinding('class.k-item'),
    __metadata("design:type", Boolean)
], PanelBarItemComponent.prototype, "kItemClass", void 0);
__decorate([
    HostBinding('class.k-state-default'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PanelBarItemComponent.prototype, "kStateDefaultClass", null);
__decorate([
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PanelBarItemComponent.prototype, "kStateDisabledClass", null);
__decorate([
    HostBinding('class.k-state-expanded'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PanelBarItemComponent.prototype, "kStateExpandedClass", null);
__decorate([
    HostBinding('id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], PanelBarItemComponent.prototype, "itemId", null);
__decorate([
    HostBinding('attr.aria-expanded'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PanelBarItemComponent.prototype, "ariaExpanded", null);
__decorate([
    HostBinding('attr.aria-selected'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PanelBarItemComponent.prototype, "ariaSelected", null);
__decorate([
    HostBinding('attr.aria-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PanelBarItemComponent.prototype, "ariaDisabled", null);
__decorate([
    HostBinding('class.k-panelbar-header'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PanelBarItemComponent.prototype, "headerClass", null);
__decorate([
    HostBinding('class.k-panelbar-item'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], PanelBarItemComponent.prototype, "childClass", null);
__decorate([
    ViewChildren(PanelBarItemComponent_1),
    __metadata("design:type", QueryList)
], PanelBarItemComponent.prototype, "viewChildItems", void 0);
__decorate([
    ContentChildren(PanelBarItemComponent_1),
    __metadata("design:type", QueryList)
], PanelBarItemComponent.prototype, "contentItems", void 0);
__decorate([
    ContentChildren(PanelBarContentDirective, { descendants: false }),
    __metadata("design:type", QueryList)
], PanelBarItemComponent.prototype, "contentTemplate", void 0);
__decorate([
    ContentChildren(PanelBarItemTitleDirective, { descendants: false }),
    __metadata("design:type", QueryList)
], PanelBarItemComponent.prototype, "titleTemplates", void 0);
PanelBarItemComponent = PanelBarItemComponent_1 = __decorate([ __param(0, SkipSelf()), __param(0, Host()), __param(0, Optional()),
    __metadata("design:paramtypes", [PanelBarItemComponent,
        PanelBarService,
        ElementRef,
        Renderer2])
], PanelBarItemComponent);

/**
 * Represents the template directive of the PanelBar which helps to customize the item content.
 */
let PanelBarItemTemplateDirective = class PanelBarItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
PanelBarItemTemplateDirective.ɵfac = function PanelBarItemTemplateDirective_Factory(t) { return new (t || PanelBarItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
PanelBarItemTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: PanelBarItemTemplateDirective, selectors: [["", "kendoPanelBarItemTemplate", ""]] });
PanelBarItemTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], PanelBarItemTemplateDirective);

/**
 * @hidden
 */
class PreventableEvent$1 {
    /**
     * @hidden
     */
    constructor(args) {
        this.prevented = false;
        Object.assign(this, args);
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `collapse` event of the PanelBar.
 */
class PanelBarCollapseEvent extends PreventableEvent$1 {
}

/**
 * Arguments for the `expand` event of the PanelBar.
 */
class PanelBarExpandEvent extends PreventableEvent$1 {
}

/**
 * Arguments for the `select` event of the PanelBar.
 */
class PanelBarSelectEvent extends PreventableEvent$1 {
}

/**
 * Represents the [Kendo UI PanelBar component for Angular]({% slug overview_panelbar %}).
 */
let PanelBarComponent = 
// TODO: add styles as input prop
class PanelBarComponent {
    constructor(elementRef, eventService, localization) {
        this.localization = localization;
        /**
         * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum ([see example]({% slug expandmodes_panelbar %})).
         *
         * The available modes are:
         * - `"single"`&mdash;Expands only one item at a time. Expanding an item collapses the item that was previously expanded.
         * - `"multiple"`&mdash;The default mode of the PanelBar.
         * Expands more than one item at a time. Items can also be toggled.
         * - `"full"`&mdash;Expands only one item at a time.
         * The expanded area occupies the entire height of the PanelBar. Requires you to set the `height` property.
         */
        this.expandMode = PanelBarExpandMode.Default;
        /**
         * Allows the PanelBar to modify the selected state of the items.
         */
        this.selectable = true;
        /**
         * Sets the animate state of the PanelBar ([see example]({% slug animations_panelbar %})).
         */
        this.animate = true;
        /**
         * Sets the height of the component when the `"full"` expand mode is used.
         * This option is ignored in the `"multiple"` and `"single"` expand modes.
         */
        this.height = '400px';
        /**
         * Fires each time the user interacts with a PanelBar item
         * ([see example]({% slug routing_panelbar %}#toc-getting-the-selected-item)).
         * The event data contains all items that are modified.
         */
        this.stateChange = new EventEmitter();
        /**
         * Fires when an item is about to be selected.
         * ([see example]({% slug events_panelbar %}))
         * This event is preventable. If you cancel it, the item will not be selected.
         */
        this.select = new EventEmitter();
        /**
         * Fires when an item is about to be expanded.
         * ([see example]({% slug events_panelbar %}))
         * This event is preventable. If you cancel it, the item will remain collapsed.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when an item is about to be collapsed.
         * ([see example]({% slug events_panelbar %}))
         * This event is preventable. If you cancel it, the item will remain expanded.
         */
        this.collapse = new EventEmitter();
        this.tabIndex = 0;
        this.role = 'tree';
        this.hostClass = true;
        this.activeDescendant = '';
        this.isViewInit = true;
        this.focused = false;
        this._keepItemContent = false;
        this.updateChildrenHeight = () => {
            let childrenHeight = 0;
            const panelbarHeight = this.elementRef.nativeElement.offsetHeight;
            const contentOverflow = this.expandMode === PanelBarExpandMode.Full ? 'auto' : 'visible';
            this.childrenItems.forEach(item => {
                childrenHeight += item.headerHeight();
            });
            this.childrenItems.forEach(item => {
                item.contentHeight = PanelBarExpandMode.Full === this.expandMode ? (panelbarHeight - childrenHeight) + 'px' : 'auto';
                item.contentOverflow = contentOverflow;
            });
        };
        validatePackage(packageMetadata);
        /* tslint:disable-line */
        this.keyBindings = this.computedKeys;
        this.elementRef = elementRef;
        this.eventService = eventService;
        this.eventService.children$.subscribe(event => this.onItemAction(event));
    }
    /**
     * When set to `true`, the PanelBar renders the content of all items and they are persisted in the DOM
     * ([see example]({% slug templates_panelbar %}#toc-collections)).
     * By default, this option is set to `false`.
     */
    get keepItemContent() {
        return this._keepItemContent;
    }
    set keepItemContent(keepItemContent) {
        this._keepItemContent = keepItemContent;
        this.eventService.onKeepContent(keepItemContent);
    }
    /**
     * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances
     * ([see example]({% slug items_panelbar %})).
     */
    set items(data) {
        if (data) {
            this._items = util.parsePanelBarItems(data);
        }
    }
    get items() {
        return this._items;
    }
    get hostHeight() {
        return this.expandMode === PanelBarExpandMode.Full ? this.height : 'auto';
    }
    get overflow() {
        return this.expandMode === PanelBarExpandMode.Full ? 'hidden' : 'visible';
    }
    get dir() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    /**
     * @hidden
     */
    invertKeys(original, inverted) {
        return this.localization.rtl ? inverted : original;
    }
    get computedKeys() {
        return {
            [Keys.Space]: () => this.selectFocusedItem(),
            [Keys.Enter]: () => this.selectFocusedItem(),
            [Keys.ArrowUp]: () => this.focusPreviousItem(),
            [this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)]: () => this.collapseItem(),
            [Keys.ArrowDown]: () => this.focusNextItem(),
            [this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)]: () => this.expandItem(),
            [Keys.End]: () => this.focusLastItem(),
            [Keys.Home]: () => this.focusFirstItem()
        };
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    ngOnInit() {
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(() => this.keyBindings = this.computedKeys);
        this.eventService.animate = this.animate;
        this.eventService.expandMode = this.expandMode;
    }
    ngAfterViewChecked() {
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
            this.allItems = this.viewItems;
        }
        else {
            this.childrenItems = this.contentChildItems.toArray();
            this.allItems = this.contentItems.toArray();
        }
        if (this.isViewInit && this.childrenItems.length) {
            this.isViewInit = false;
            setTimeout(() => this.updateChildrenHeight());
        }
        this.validateConfiguration();
    }
    ngOnChanges(changes) {
        if (changes['height'] || changes['expandMode'] || changes['items']) { // tslint:disable-line
            if (this.childrenItems) {
                setTimeout(this.updateChildrenHeight);
            }
        }
        if (changes.animate) {
            this.eventService.animate = this.animate;
        }
        if (changes.expandMode) {
            this.eventService.expandMode = this.expandMode;
        }
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    onComponentClick(event) {
        const itemClicked = this.visibleItems().some((item) => {
            return item.header.nativeElement.contains(event.target);
        });
        if (!isFocusable(event.target) && !this.focused && itemClicked) {
            this.elementRef.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onComponentFocus() {
        this.eventService.onFocus();
        this.focused = true;
        if (this.allItems.length > 0) {
            const visibleItems = this.visibleItems();
            const focusedItems = visibleItems.filter(item => item.focused);
            if (!focusedItems.length && visibleItems.length > 0) {
                visibleItems[0].focused = true;
                this.activeDescendant = visibleItems[0].itemId;
            }
        }
    }
    /**
     * @hidden
     */
    onComponentBlur() {
        this.eventService.onBlur();
        this.focused = false;
        this.activeDescendant = '';
    }
    /**
     * @hidden
     */
    onComponentKeyDown(event) {
        if (event.target === this.elementRef.nativeElement) {
            if (event.keyCode === Keys.Space || event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowDown ||
                event.keyCode === Keys.ArrowLeft || event.keyCode === Keys.ArrowRight || event.keyCode === Keys.Home ||
                event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {
                event.preventDefault();
            }
            const handler = this.keyBindings[event.keyCode];
            //TODO: check if next item is disabled and skip operation?
            if (handler) {
                handler();
            }
        }
    }
    /**
     * @hidden
     */
    emitEvent(event, item) {
        let eventArgs;
        switch (event) {
            case 'select':
                eventArgs = new PanelBarSelectEvent();
                break;
            case 'collapse':
                eventArgs = new PanelBarCollapseEvent();
                break;
            default:
                eventArgs = new PanelBarExpandEvent();
                break;
        }
        eventArgs.item = item.serialize();
        this[event].emit(eventArgs);
        return eventArgs;
    }
    get viewItems() {
        let treeItems = [];
        this.viewChildItems.toArray().forEach(item => {
            treeItems.push(item);
            treeItems = treeItems.concat(item.subTreeViewItems());
        });
        return treeItems;
    }
    validateConfiguration() {
        if (isDevMode()) {
            if (this.items && (this.contentItems && this.contentItems.length > 0)) {
                throw new Error('Invalid configuration: mixed template components and items property.');
            }
        }
    }
    onItemAction(item) {
        if (!item) {
            return;
        }
        let modifiedItems = new Array();
        this.allItems
            .forEach((currentItem) => {
            let selectedState = currentItem === item;
            let focusedState = selectedState;
            selectedState = this.selectable ? selectedState : currentItem.selected;
            if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {
                const isSelectPrevented = selectedState ? this.emitEvent('select', currentItem).isDefaultPrevented() : false;
                if (!isSelectPrevented) {
                    currentItem.selected = selectedState;
                    currentItem.focused = focusedState;
                    this.activeDescendant = focusedState ? currentItem.itemId : '';
                    modifiedItems.push(currentItem);
                }
            }
        });
        if (this.expandMode === PanelBarExpandMode.Multiple) {
            if ((item.hasChildItems || item.hasContent) && item.selected) {
                const isEventPrevented = item.expanded ?
                    this.emitEvent('collapse', item).isDefaultPrevented() :
                    this.emitEvent('expand', item).isDefaultPrevented();
                if (!isEventPrevented) {
                    item.expanded = !item.expanded;
                    if (modifiedItems.indexOf(item) < 0) {
                        modifiedItems.push(item);
                    }
                }
            }
        }
        else {
            let siblings = item.parent ? item.parent.childrenItems : this.childrenItems;
            let preventedCollapseItem;
            let expandedItems = [];
            if ((item.hasChildItems || item.hasContent) && item.selected) {
                siblings
                    .forEach((currentItem) => {
                    let expandedState = currentItem === item;
                    if (currentItem.expanded !== expandedState) {
                        const isEventPrevented = currentItem.expanded ?
                            this.emitEvent('collapse', currentItem).isDefaultPrevented() :
                            this.emitEvent('expand', currentItem).isDefaultPrevented();
                        if (!isEventPrevented) {
                            currentItem.expanded = expandedState;
                            if (currentItem.expanded) {
                                expandedItems.push(currentItem);
                            }
                            if (modifiedItems.indexOf(currentItem) < 0) {
                                modifiedItems.push(currentItem);
                            }
                        }
                        else if (isEventPrevented && currentItem.expanded) {
                            preventedCollapseItem = currentItem;
                        }
                    }
                    else if (currentItem.expanded === expandedState && expandedState) {
                        const isCollapsePrevented = this.emitEvent('collapse', currentItem).isDefaultPrevented();
                        if (!isCollapsePrevented) {
                            currentItem.expanded = !currentItem.expanded;
                            if (modifiedItems.indexOf(currentItem) < 0) {
                                modifiedItems.push(currentItem);
                            }
                        }
                    }
                });
                expandedItems.forEach(item => {
                    if (preventedCollapseItem && item.id !== preventedCollapseItem.id) {
                        item.expanded = false;
                        if (isDevMode()) {
                            const expandMode = PanelBarExpandMode[this.expandMode].toLowerCase();
                            console.warn(`
                            The ${expandMode} expandMode allows the expansion of only one item at a time.
                            See https://www.telerik.com/kendo-angular-ui-develop/components/layout/panelbar/expand-modes/`);
                        }
                    }
                });
            }
        }
        if (modifiedItems.length > 0) {
            this.stateChange.emit(modifiedItems.map(currentItem => currentItem.serialize()));
        }
    }
    isVisible(item) {
        const visibleItems = this.visibleItems();
        return visibleItems.some(i => i === item);
    }
    getVisibleParent(item) {
        const visibleItems = this.visibleItems();
        if (!item.parent) {
            return item;
        }
        return visibleItems.some(i => i === item.parent) ? item.parent : this.getVisibleParent(item.parent);
    }
    focusItem(action) {
        const visibleItems = this.visibleItems();
        let currentIndex = visibleItems.findIndex(item => item.focused);
        let currentItem = visibleItems[currentIndex];
        let nextItem;
        if (currentIndex === -1) {
            let focusedItem = this.allItems.find(item => item.focused);
            focusedItem.focused = false;
            currentItem = this.getVisibleParent(focusedItem);
            currentIndex = visibleItems.findIndex(item => item === currentItem);
        }
        switch (action) {
            case 'lastItem':
                nextItem = visibleItems[visibleItems.length - 1];
                break;
            case 'firstItem':
                nextItem = visibleItems[0];
                break;
            case 'nextItem':
                nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];
                break;
            case 'previousItem':
                nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];
                break;
            default:
        }
        if (currentItem && nextItem && currentItem !== nextItem) {
            this.moveFocus(currentItem, nextItem);
        }
    }
    moveFocus(from, to) {
        from.focused = false;
        to.focused = true;
        this.activeDescendant = to.itemId;
        const modifiedItems = new Array(from.serialize(), to.serialize());
        this.stateChange.emit(modifiedItems);
    }
    focusLastItem() {
        this.focusItem('lastItem');
    }
    focusFirstItem() {
        this.focusItem('firstItem');
    }
    focusNextItem() {
        this.focusItem('nextItem');
    }
    focusPreviousItem() {
        this.focusItem('previousItem');
    }
    expandItem() {
        let currentItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(currentItem)) {
            currentItem.focused = false;
            currentItem = this.getVisibleParent(currentItem);
        }
        if (currentItem.hasChildItems || currentItem.hasContent) {
            if (!currentItem.expanded) {
                this.onItemAction(currentItem);
            }
            else if (currentItem.hasChildItems) {
                const firstChildIndex = currentItem.childrenItems.findIndex(item => !item.disabled);
                if (firstChildIndex > -1) {
                    this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);
                }
            }
        }
    }
    collapseItem() {
        const currentItem = this.allItems.filter(item => item.focused)[0];
        if (currentItem.expanded) {
            this.onItemAction(currentItem);
        }
        else if (currentItem.parent) {
            this.moveFocus(currentItem, currentItem.parent);
        }
    }
    selectFocusedItem() {
        let focusedItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(focusedItem)) {
            focusedItem.focused = false;
            focusedItem = this.getVisibleParent(focusedItem);
        }
        if (focusedItem) {
            focusedItem.onItemAction();
        }
    }
    visibleItems() {
        return this.flatVisibleItems(this.childrenItems);
    }
    flatVisibleItems(listOfItems = new Array(), flattedItems = new Array()) {
        listOfItems.forEach(item => {
            flattedItems.push(item);
            if (item.expanded && item.hasChildItems) {
                this.flatVisibleItems(item.childrenItems, flattedItems);
            }
        });
        return flattedItems;
    }
};
PanelBarComponent.ɵfac = function PanelBarComponent_Factory(t) { return new (t || PanelBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(PanelBarService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
PanelBarComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PanelBarComponent, selectors: [["kendo-panelbar"]], contentQueries: function PanelBarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentItems = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentChildItems = _t);
    } }, viewQuery: function PanelBarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(PanelBarItemComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewChildItems = _t);
    } }, hostVars: 10, hostBindings: function PanelBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function PanelBarComponent_click_HostBindingHandler($event) { return ctx.onComponentClick($event); })("focus", function PanelBarComponent_focus_HostBindingHandler() { return ctx.onComponentFocus(); })("blur", function PanelBarComponent_blur_HostBindingHandler() { return ctx.onComponentBlur(); })("keydown", function PanelBarComponent_keydown_HostBindingHandler($event) { return ctx.onComponentKeyDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabIndex", ctx.tabIndex)("role", ctx.role)("aria-activedescendant", ctx.activeDescendant)("dir", ctx.dir);
        ɵngcc0.ɵɵstyleProp("height", ctx.hostHeight)("overflow", ctx.overflow);
        ɵngcc0.ɵɵclassProp("k-panelbar", ctx.hostClass);
    } }, inputs: { expandMode: "expandMode", selectable: "selectable", animate: "animate", height: "height", keepItemContent: "keepItemContent", items: "items" }, outputs: { stateChange: "stateChange", select: "select", expand: "expand", collapse: "collapse" }, exportAs: ["kendoPanelbar"], features: [ɵngcc0.ɵɵProvidersFeature([
            PanelBarService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.panelbar'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c8, decls: 2, vars: 2, consts: [[4, "ngIf"], [3, "ngIf"], [4, "ngFor", "ngForOf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content", 4, "ngIf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content"]], template: function PanelBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵtemplate(0, PanelBarComponent_ng_content_0_Template, 1, 0, "ng-content", 0);
        ɵngcc0.ɵɵtemplate(1, PanelBarComponent_ng_template_1_Template, 1, 1, "ng-template", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.contentChildItems && !ctx.items);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.items == null ? null : ctx.items.length);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, PanelBarItemComponent], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], PanelBarComponent.prototype, "expandMode", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PanelBarComponent.prototype, "selectable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PanelBarComponent.prototype, "animate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PanelBarComponent.prototype, "height", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], PanelBarComponent.prototype, "keepItemContent", null);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], PanelBarComponent.prototype, "items", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], PanelBarComponent.prototype, "stateChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], PanelBarComponent.prototype, "select", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], PanelBarComponent.prototype, "expand", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], PanelBarComponent.prototype, "collapse", void 0);
__decorate([
    HostBinding('attr.tabIndex'),
    __metadata("design:type", Number)
], PanelBarComponent.prototype, "tabIndex", void 0);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String)
], PanelBarComponent.prototype, "role", void 0);
__decorate([
    HostBinding('class.k-panelbar'),
    __metadata("design:type", Boolean)
], PanelBarComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('attr.aria-activedescendant'),
    __metadata("design:type", String)
], PanelBarComponent.prototype, "activeDescendant", void 0);
__decorate([
    HostBinding('style.height'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], PanelBarComponent.prototype, "hostHeight", null);
__decorate([
    HostBinding('style.overflow'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], PanelBarComponent.prototype, "overflow", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], PanelBarComponent.prototype, "dir", null);
__decorate([
    ContentChild(PanelBarItemTemplateDirective, { static: false }),
    __metadata("design:type", PanelBarItemTemplateDirective)
], PanelBarComponent.prototype, "template", void 0);
__decorate([
    ContentChildren(PanelBarItemComponent, { descendants: true }),
    __metadata("design:type", QueryList)
], PanelBarComponent.prototype, "contentItems", void 0);
__decorate([
    ContentChildren(PanelBarItemComponent),
    __metadata("design:type", QueryList)
], PanelBarComponent.prototype, "contentChildItems", void 0);
__decorate([
    ViewChildren(PanelBarItemComponent),
    __metadata("design:type", QueryList)
], PanelBarComponent.prototype, "viewChildItems", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], PanelBarComponent.prototype, "onComponentClick", null);
__decorate([
    HostListener('focus'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PanelBarComponent.prototype, "onComponentFocus", null);
__decorate([
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PanelBarComponent.prototype, "onComponentBlur", null);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], PanelBarComponent.prototype, "onComponentKeyDown", null);
PanelBarComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        PanelBarService,
        LocalizationService])
], PanelBarComponent);

/**
 * Represents the pane component of the Splitter.
 */
let SplitterPaneComponent = class SplitterPaneComponent {
    constructor(element, renderer, cdr) {
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        /**
         * Specifies if the user is allowed to resize the pane and provide space for other panes.
         */
        this.resizable = true;
        /**
         * Specifies if the user is allowed to hide the pane and provide space for other panes.
         */
        this.collapsible = false;
        /**
         * Specifies if overflowing content is scrollable or hidden.
         */
        this.scrollable = true;
        /**
         * Specifies if the pane is initially collapsed.
         */
        this.collapsed = false;
        /**
         * @hidden
         */
        this.orientation = 'horizontal';
        /**
         * @hidden
         */
        this.overlayContent = false;
        /**
         * Fires each time the user resizes the Splitter pane.
         * The event data contains the new pane size.
         * Allows a two-way binding of the pane `size` property.
         */
        this.sizeChange = new EventEmitter();
        /**
         * Fires each time the `collapsed` property changes.
         * The event data contains the new property state.
         * Allows a two-way binding of the `collapsed` pane property.
         */
        this.collapsedChange = new EventEmitter();
        this.hostClass = true;
        /**
         * @hidden
         */
        this.forceExpand = false;
        /**
         * @hidden
         */
        this.isResized = false;
    }
    /**
     * @hidden
     */
    set order(paneOrder) {
        this._order = paneOrder;
        this.setOrderStyles();
    }
    get order() {
        return this._order;
    }
    /**
     * Sets the initial size of the pane.
     * Has to be between the `min` and `max` properties.
     */
    set size(newSize) {
        this._size = newSize;
        const element = this.element.nativeElement;
        this.renderer.setStyle(element, '-ms-flex-preferred-size', newSize);
        this.renderer.setStyle(element, 'flex-basis', newSize);
        if (this.staticPaneClass) {
            this.renderer.addClass(element, 'k-pane-static');
        }
        else {
            this.renderer.removeClass(element, 'k-pane-static');
        }
    }
    get size() {
        return this._size;
    }
    /**
     * @hidden
     */
    set containsSplitter(value) {
        const element = this.element.nativeElement;
        if (value) {
            this.renderer.addClass(element, 'k-pane-flex');
        }
        else {
            this.renderer.removeClass(element, 'k-pane-flex');
        }
    }
    get isHidden() {
        return this.collapsed;
    }
    get staticPaneClass() {
        if (this.forceExpand) {
            return false;
        }
        return !this.resizable && !this.collapsible || this.fixedSize;
    }
    get scrollablePaneClass() {
        return this.scrollable;
    }
    get fixedSize() {
        return this.size && this.size.length > 0;
    }
    ngAfterViewChecked() {
        const element = this.element.nativeElement;
        if (this.isHidden) {
            this.renderer.addClass(element, 'k-state-hidden');
            this.renderer.addClass(element, 'hidden');
        }
        else {
            this.renderer.removeClass(element, 'k-state-hidden');
            this.renderer.removeClass(element, 'hidden');
        }
    }
    /**
     * @hidden
     */
    get computedSize() {
        if (this.orientation === 'vertical') {
            return this.element.nativeElement.offsetHeight;
        }
        else {
            return this.element.nativeElement.offsetWidth;
        }
    }
    /**
     * @hidden
     */
    toggleOverlay(show) {
        this.overlayContent = show;
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    detectChanges() {
        this.cdr.detectChanges();
    }
    setOrderStyles() {
        const element = this.element.nativeElement;
        this.renderer.setStyle(element, '-ms-flex-order', this.order);
        this.renderer.setStyle(element, 'order', this.order);
    }
};
SplitterPaneComponent.ɵfac = function SplitterPaneComponent_Factory(t) { return new (t || SplitterPaneComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
SplitterPaneComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SplitterPaneComponent, selectors: [["kendo-splitter-pane"]], hostVars: 6, hostBindings: function SplitterPaneComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-pane", ctx.hostClass)("k-pane-static", ctx.staticPaneClass)("k-scrollable", ctx.scrollablePaneClass);
    } }, inputs: { resizable: "resizable", collapsible: "collapsible", scrollable: "scrollable", collapsed: "collapsed", orientation: "orientation", overlayContent: "overlayContent", order: "order", size: "size", containsSplitter: "containsSplitter", min: "min", max: "max" }, outputs: { sizeChange: "sizeChange", collapsedChange: "collapsedChange" }, exportAs: ["kendoSplitterPane"], ngContentSelectors: _c9, decls: 2, vars: 2, consts: [[4, "ngIf"], ["class", "k-splitter-overlay k-overlay", 4, "ngIf"], [1, "k-splitter-overlay", "k-overlay"]], template: function SplitterPaneComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, SplitterPaneComponent_ng_container_0_Template, 2, 0, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, SplitterPaneComponent_div_1_Template, 1, 0, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.collapsed);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.overlayContent);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], SplitterPaneComponent.prototype, "order", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], SplitterPaneComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], SplitterPaneComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SplitterPaneComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SplitterPaneComponent.prototype, "resizable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SplitterPaneComponent.prototype, "collapsible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SplitterPaneComponent.prototype, "scrollable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SplitterPaneComponent.prototype, "collapsed", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SplitterPaneComponent.prototype, "orientation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], SplitterPaneComponent.prototype, "containsSplitter", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SplitterPaneComponent.prototype, "overlayContent", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], SplitterPaneComponent.prototype, "sizeChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], SplitterPaneComponent.prototype, "collapsedChange", void 0);
__decorate([
    HostBinding('class.k-pane'),
    __metadata("design:type", Boolean)
], SplitterPaneComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('class.k-pane-static'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SplitterPaneComponent.prototype, "staticPaneClass", null);
__decorate([
    HostBinding('class.k-scrollable'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SplitterPaneComponent.prototype, "scrollablePaneClass", null);
SplitterPaneComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        ChangeDetectorRef])
], SplitterPaneComponent);

const SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#toc-size';
/**
 * @hidden
 */
let SplitterService = class SplitterService {
    constructor(zone) {
        this.zone = zone;
        this.layoutChange = new EventEmitter();
        this.containerSize = () => { };
    }
    tryToggle(paneIndex) {
        const pane = this.pane(paneIndex);
        if (pane.collapsible) {
            pane.collapsed = !pane.collapsed;
            pane.collapsedChange.emit(pane.collapsed);
            this.emit(this.layoutChange, {});
            if (pane.collapsed) {
                pane.detectChanges();
            }
        }
        const notCollapsed = this.panes.filter(p => !p.collapsed);
        const allHaveFixedSize = notCollapsed.every(p => p.fixedSize);
        notCollapsed[notCollapsed.length - 1].forceExpand = allHaveFixedSize ? true : false;
        return pane.collapsible;
    }
    toggleContentOverlay(index, show) {
        this.pane(index).toggleOverlay(show);
        this.pane(index + 1).toggleOverlay(show);
    }
    dragState(splitbarIndex) {
        let prev = this.pane(splitbarIndex);
        let next = this.pane(splitbarIndex + 1);
        const total = prev.computedSize + next.computedSize;
        const px = s => this.toPixels(s);
        return {
            prev: {
                index: splitbarIndex,
                initialSize: prev.computedSize,
                min: px(prev.min) || total - px(next.max) || 0,
                max: px(prev.max) || total - px(next.min) || total
            },
            next: {
                index: splitbarIndex + 1,
                initialSize: next.computedSize,
                min: px(next.min) || total - px(prev.max) || 0,
                max: px(next.max) || total - px(prev.min) || total
            }
        };
    }
    setSize(state$$1, delta) {
        const clamp = (min, max, v) => Math.min(max, Math.max(min, v));
        const resize = (paneState, change) => {
            const pane = this.pane(paneState.index);
            const splitterSize = this.containerSize();
            const newSize = clamp(paneState.min, paneState.max, paneState.initialSize + change);
            let size = "";
            if (this.isPercent(pane.size)) {
                size = (100 * newSize / splitterSize) + "%";
            }
            else {
                size = newSize + "px";
            }
            pane.size = size;
            pane.isResized = true;
            this.emit(pane.sizeChange, size);
        };
        const prev = this.pane(state$$1.prev.index);
        const next = this.pane(state$$1.next.index);
        // determine which pane to resize
        if (prev.fixedSize && next.fixedSize) {
            // resizing both panes
            resize(state$$1.prev, delta);
            resize(state$$1.next, -delta);
        }
        else if (next.collapsible || next.fixedSize) {
            // resizing next
            resize(state$$1.next, -delta);
        }
        else {
            // resizing prev
            resize(state$$1.prev, delta);
        }
        this.emit(this.layoutChange, {});
    }
    isDraggable(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev.resizable && next.resizable;
        const nearCollapsedPane = prev.collapsed || next.collapsed;
        return betweenResizablePanes && !nearCollapsedPane;
    }
    isStatic(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev.resizable && next.resizable;
        const nearCollapsiblePane = prev.collapsible || next.collapsible;
        return !betweenResizablePanes && !nearCollapsiblePane;
    }
    pane(index) {
        if (!this.panes) {
            throw new Error("Panes not initialized");
        }
        if (index < 0 || index >= this.panes.length) {
            throw new Error("Index out of range");
        }
        return this.panes[index];
    }
    configure({ panes, orientation, containerSize }) {
        this.panes = panes;
        this.panes.forEach((pane, index) => {
            pane.order = index * 2;
            pane.orientation = orientation;
        });
        if (isDevMode()) {
            const allPanesWithSize = panes.length && !panes.some(pane => !pane.fixedSize);
            const hasResizedPane = panes.length && panes.some(pane => pane.isResized);
            if (allPanesWithSize && !hasResizedPane) {
                throw new Error(`
                    The Splitter should have at least one pane without a set size.
                    See ${SIZING_DOC_LINK} for more information.
                `);
            }
        }
        this.containerSize = containerSize;
    }
    isPercent(size) {
        return /%$/.test(size);
    }
    toPixels(size) {
        let result = parseFloat(size);
        if (this.isPercent(size)) {
            result = (this.containerSize() * result / 100);
        }
        return result;
    }
    emit(emitter, args) {
        if (emitter.observers.length) {
            this.zone.run(() => emitter.emit(args));
        }
    }
};
SplitterService.ɵfac = function SplitterService_Factory(t) { return new (t || SplitterService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
SplitterService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SplitterService, factory: function (t) { return SplitterService.ɵfac(t); } });
SplitterService = __decorate([ __metadata("design:paramtypes", [NgZone])
], SplitterService);

const stopPropagation = ({ originalEvent: event }) => {
    event.stopPropagation();
    event.preventDefault();
};
const preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
const classFromObject = classes => Object.keys(classes).filter(c => classes[c]).join(' ');
const createMoveStream = (draggable) => mouseDown => draggable.kendoDrag
    .pipe(takeUntil(draggable.kendoRelease), map(({ pageX, pageY }) => ({
    originalX: mouseDown.pageX,
    originalY: mouseDown.pageY,
    pageX,
    pageY
})));
/**
 * @hidden
 */
let SplitterBarComponent = class SplitterBarComponent {
    constructor(draggable, element, splitter, localization) {
        this.draggable = draggable;
        this.element = element;
        this.splitter = splitter;
        this.localization = localization;
        this.orientation = 'horizontal';
        this.index = 0;
        this.ariaRole = 'separator';
        this.focused = false;
        this.subscriptions = new Subscription();
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    get tabIndex() {
        return this.splitter.isStatic(this.index) ? -1 : 0;
    }
    get hostClasses() {
        const isHorizontal = this.orientation === 'horizontal';
        const isDraggable = this.splitter.isDraggable(this.index);
        const isStatic = this.splitter.isStatic(this.index);
        return classFromObject({
            'k-state-focused': this.focused,
            'k-splitbar': true,
            'k-splitbar-horizontal': isHorizontal,
            'k-splitbar-vertical': !isHorizontal,
            'k-splitbar-draggable-horizontal': isHorizontal && isDraggable,
            'k-splitbar-draggable-vertical': !isHorizontal && isDraggable,
            'k-splitbar-static-horizontal': isHorizontal && isStatic,
            'k-splitbar-static-vertical': !isHorizontal && isStatic,
            'k-touch-action-none': isDraggable
        });
    }
    get order() {
        return 2 * this.index + 1;
    }
    collapseAny() {
        if (this.expandLast) {
            this.toggleNext();
        }
        else {
            this.tryToggleNearest();
        }
    }
    onFocusIn() {
        this.focused = true;
    }
    onFocusOut() {
        this.focused = false;
    }
    onKeyDown(event) {
        const keyCode = event && event.keyCode;
        const isHorizontal = this.orientation === 'horizontal';
        const resize = delta => {
            event.preventDefault();
            const state$$1 = this.splitter.dragState(this.index);
            this.splitter.setSize(state$$1, delta);
        };
        if (keyCode === Keys.Enter) {
            event.preventDefault();
            this.collapseAny();
        }
        else if (isHorizontal && keyCode === Keys.ArrowLeft) {
            resize(-10);
        }
        else if (isHorizontal && keyCode === Keys.ArrowRight) {
            resize(10);
        }
        else if (!isHorizontal && keyCode === Keys.ArrowUp) {
            resize(-10);
        }
        else if (!isHorizontal && keyCode === Keys.ArrowDown) {
            resize(10);
        }
    }
    get expandLast() {
        const panes = this.splitter.panes;
        return panes.length === 2 && panes[1].collapsed;
    }
    ngOnInit() {
        let state$$1;
        const listener = this.draggable.kendoPress.pipe(tap(stopPropagation), filter(() => this.splitter.isDraggable(this.index)), tap(() => state$$1 = this.splitter.dragState(this.index)), tap(() => this.splitter.toggleContentOverlay(this.index, true)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.draggable))).subscribe(({ pageX, pageY, originalX, originalY }) => {
            let delta;
            if (this.orientation === 'vertical') {
                delta = pageY - originalY;
            }
            else if (this.direction === 'rtl') {
                delta = originalX - pageX;
            }
            else {
                delta = pageX - originalX;
            }
            this.splitter.setSize(state$$1, delta);
        });
        this.subscriptions.add(listener);
        this.subscriptions.add(this.draggable.kendoRelease.subscribe(() => this.splitter.toggleContentOverlay(this.index, false)));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    togglePrevious() {
        this.splitter.tryToggle(this.index);
    }
    toggleNext() {
        this.splitter.tryToggle(this.index + 1);
    }
    previousArrowClass() {
        const pane = this.splitter.pane(this.index);
        const nextPane = this.splitter.pane(this.index + 1);
        const isCollapsible = pane.collapsible;
        const isCollapsed = pane.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible || nextPane.isHidden,
            'k-collapse-prev': isCollapsible,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && isCollapsed
        });
    }
    nextArrowClass() {
        const pane = this.splitter.pane(this.index + 1);
        const prevPane = this.splitter.pane(this.index);
        const isCollapsible = pane.collapsible;
        const isCollapsed = pane.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible || prevPane.isHidden,
            'k-collapse-next': isCollapsible,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && isCollapsed
        });
    }
    tryToggleNearest() {
        const prev = this.index;
        const next = this.index + 1;
        if (!this.splitter.tryToggle(prev)) {
            this.splitter.tryToggle(next);
        }
    }
};
SplitterBarComponent.ɵfac = function SplitterBarComponent_Factory(t) { return new (t || SplitterBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.DraggableDirective, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SplitterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
SplitterBarComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SplitterBarComponent, selectors: [["kendo-splitter-bar"]], hostVars: 11, hostBindings: function SplitterBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("dblclick", function SplitterBarComponent_dblclick_HostBindingHandler() { return ctx.collapseAny(); })("focusin", function SplitterBarComponent_focusin_HostBindingHandler() { return ctx.onFocusIn(); })("focusout", function SplitterBarComponent_focusout_HostBindingHandler() { return ctx.onFocusOut(); })("keydown", function SplitterBarComponent_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-orientation", ctx.orientation)("role", ctx.ariaRole)("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵclassMap(ctx.hostClasses);
        ɵngcc0.ɵɵstyleProp("-ms-flex-order", ctx.order)("order", ctx.order);
        ɵngcc0.ɵɵclassProp("k-state-focused", ctx.focused);
    } }, inputs: { orientation: "orientation", index: "index" }, decls: 3, vars: 4, consts: [[3, "click"], [1, "k-resize-handle"]], template: function SplitterBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function SplitterBarComponent_Template_div_click_0_listener() { return ctx.togglePrevious(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 0);
        ɵngcc0.ɵɵlistener("click", function SplitterBarComponent_Template_div_click_2_listener() { return ctx.toggleNext(); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.previousArrowClass());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassMap(ctx.nextArrowClass());
    } }, encapsulation: 2 });
__decorate([
    Input(),
    HostBinding('attr.aria-orientation'),
    __metadata("design:type", String)
], SplitterBarComponent.prototype, "orientation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SplitterBarComponent.prototype, "index", void 0);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String)
], SplitterBarComponent.prototype, "ariaRole", void 0);
__decorate([
    HostBinding('class.k-state-focused'),
    __metadata("design:type", Boolean)
], SplitterBarComponent.prototype, "focused", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], SplitterBarComponent.prototype, "tabIndex", null);
__decorate([
    HostBinding('class'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], SplitterBarComponent.prototype, "hostClasses", null);
__decorate([
    HostBinding('style.-ms-flex-order'),
    HostBinding('style.order'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], SplitterBarComponent.prototype, "order", null);
__decorate([
    HostListener('dblclick'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SplitterBarComponent.prototype, "collapseAny", null);
__decorate([
    HostListener('focusin'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SplitterBarComponent.prototype, "onFocusIn", null);
__decorate([
    HostListener('focusout'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SplitterBarComponent.prototype, "onFocusOut", null);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SplitterBarComponent.prototype, "onKeyDown", null);
SplitterBarComponent = __decorate([ __param(0, Host()),
    __metadata("design:paramtypes", [DraggableDirective,
        ElementRef,
        SplitterService,
        LocalizationService])
], SplitterBarComponent);

/**
 * Represents the [Kendo UI Splitter component for Angular]({% slug overview_splitter %}).
 *
 * ```ts-preview
 *
 *  @Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-splitter style="height: 280px;">
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / left pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane>
 *            <h3>Inner splitter / center pane</h3>
 *            <p>Resizable only.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / right pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *        </kendo-splitter>
 *      `,
 *    styles: [ `
 *        h3 { font-size: 1.2em; }
 *        h3, p { margin: 10px; padding: 0; }
 *    ` ]
 *  })
 *  class AppComponent {}
 * ```
 */
let SplitterComponent = class SplitterComponent {
    constructor(element, splitterService, localization, renderer, enclosingPane) {
        this.element = element;
        this.splitterService = splitterService;
        this.localization = localization;
        this.renderer = renderer;
        this.enclosingPane = enclosingPane;
        /**
         * Specifies the orientation of the panes within the Splitter.
         * Panes in a horizontal Splitter are placed horizontally.
         * Panes in a vertical Splitter are placed vertically.
         */
        this.orientation = 'horizontal';
        this.ariaRole = 'splitter';
        validatePackage(packageMetadata);
        if (enclosingPane) {
            enclosingPane.containsSplitter = true;
        }
        // the handler only runs in NgZone if there are bound handlers
        // this line merges both streams
        this.layoutChange = this.splitterService.layoutChange;
        this.configure = this.configure.bind(this);
    }
    get hostClasses() {
        return true;
    }
    get horizontalHostClasses() {
        return this.orientation === 'horizontal';
    }
    get verticalHostClasses() {
        return this.orientation === 'vertical';
    }
    get dir() {
        return this.direction;
    }
    set splitbars(splitbars) {
        if (!isPresent(splitbars) || !isPresent(this.panes)) {
            return;
        }
        const components = [...this.panes.toArray(), ...splitbars.toArray()]
            .sort((a, b) => a.order - b.order);
        const elements = components.map(component => component.element.nativeElement);
        elements.forEach(element => this.renderer.appendChild(this.element.nativeElement, element));
    }
    ngAfterContentInit() {
        this.reconfigure();
    }
    ngOnChanges(changes) {
        if (changes.orientation && !changes.orientation.isFirstChange()) {
            this.reconfigure();
        }
    }
    ngOnDestroy() {
        if (this.enclosingPane) {
            this.enclosingPane.containsSplitter = false;
        }
        this.unsubscribeChanges();
    }
    reconfigure() {
        this.unsubscribeChanges();
        this.configure();
        this.paneChangesSubscription = this.panes.changes.subscribe(this.configure);
    }
    unsubscribeChanges() {
        if (this.paneChangesSubscription) {
            this.paneChangesSubscription.unsubscribe();
            this.paneChangesSubscription = null;
        }
    }
    configure() {
        this.splitterService.configure({
            panes: this.panes.toArray(),
            orientation: this.orientation,
            containerSize: () => {
                if (this.orientation === 'vertical') {
                    return this.element.nativeElement.clientHeight;
                }
                else {
                    return this.element.nativeElement.clientWidth;
                }
            }
        });
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
};
SplitterComponent.ɵfac = function SplitterComponent_Factory(t) { return new (t || SplitterComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SplitterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(SplitterPaneComponent, 9)); };
SplitterComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SplitterComponent, selectors: [["kendo-splitter"]], contentQueries: function SplitterComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, SplitterPaneComponent, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panes = _t);
    } }, viewQuery: function SplitterComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(SplitterBarComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.splitbars = _t);
    } }, hostVars: 12, hostBindings: function SplitterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.ariaRole)("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-splitter", ctx.hostClasses)("k-splitter-flex", ctx.hostClasses)("k-splitter-horizontal", ctx.horizontalHostClasses)("k-splitter-vertical", ctx.verticalHostClasses);
    } }, inputs: { orientation: "orientation" }, outputs: { layoutChange: "layoutChange" }, exportAs: ["kendoSplitter"], features: [ɵngcc0.ɵɵProvidersFeature([
            SplitterService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.spliter'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c11, decls: 2, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["kendoDraggable", "", 3, "index", "orientation", 4, "ngIf"], ["kendoDraggable", "", 3, "index", "orientation"]], template: function SplitterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c10);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, SplitterComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.panes);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, SplitterBarComponent, ɵngcc3.DraggableDirective], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], SplitterComponent.prototype, "orientation", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], SplitterComponent.prototype, "layoutChange", void 0);
__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-splitter'),
    HostBinding('class.k-splitter-flex'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SplitterComponent.prototype, "hostClasses", null);
__decorate([
    HostBinding('class.k-splitter-horizontal'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SplitterComponent.prototype, "horizontalHostClasses", null);
__decorate([
    HostBinding('class.k-splitter-vertical'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SplitterComponent.prototype, "verticalHostClasses", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], SplitterComponent.prototype, "dir", null);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String)
], SplitterComponent.prototype, "ariaRole", void 0);
__decorate([
    ViewChildren(SplitterBarComponent),
    __metadata("design:type", QueryList),
    __metadata("design:paramtypes", [QueryList])
], SplitterComponent.prototype, "splitbars", null);
__decorate([
    ContentChildren(SplitterPaneComponent),
    __metadata("design:type", QueryList)
], SplitterComponent.prototype, "panes", void 0);
SplitterComponent = __decorate([ __param(4, Optional()), __param(4, Host()), __param(4, Inject(SplitterPaneComponent)),
    __metadata("design:paramtypes", [ElementRef,
        SplitterService,
        LocalizationService,
        Renderer2,
        SplitterPaneComponent])
], SplitterComponent);

/**
 * Represents the content template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabContent` inside the component tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip [ngStyle]="{'width': '400px'}" [animate]="true">
 *           <kendo-tabstrip-tab title="Paris" [selected]="true">
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab title="Sofia">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
let TabContentDirective = class TabContentDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
TabContentDirective.ɵfac = function TabContentDirective_Factory(t) { return new (t || TabContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
TabContentDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TabContentDirective, selectors: [["", "kendoTabContent", ""]] });
TabContentDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], TabContentDirective);

/**
 * Represents the title template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabTitle` directive inside the component tag.
 *
 * > The `kendoTabTitle` directive overrides the TabStripTab [title]({% slug api_layout_tabstriptabcomponent %}#toc-title) option.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip>
 *           <kendo-tabstrip-tab [selected]="true">
 *             <ng-template kendoTabTitle>
 *               <h4>Custom Title</h4>
 *             </ng-template>
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab title="Sofia">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
let TabTitleDirective = class TabTitleDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
TabTitleDirective.ɵfac = function TabTitleDirective_Factory(t) { return new (t || TabTitleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
TabTitleDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TabTitleDirective, selectors: [["", "kendoTabTitle", ""]] });
TabTitleDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], TabTitleDirective);

/**
 * Represents the tab component of the TabStrip.
 */
let TabStripTabComponent = class TabStripTabComponent {
    /**
     * Represents the tab component of the TabStrip.
     */
    constructor() {
        /**
         * Used to disable a tab ([see example]({% slug tabs_tabstrip %}#toc-disabled-tabs)).
         *
         * Defaults to `false`.
         */
        this.disabled = false;
        this._tabContent = new QueryList();
        /**
         * @hidden
         *
         * Currently only disabled tabs can be focused. Otherwise they will be
         * immediately selected
         */
        this.focused = false;
    }
    get tabContent() {
        return this._tabContent.first;
    }
    get tabTitle() {
        return this._tabTitleDirective.first;
    }
};
TabStripTabComponent.ɵfac = function TabStripTabComponent_Factory(t) { return new (t || TabStripTabComponent)(); };
TabStripTabComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TabStripTabComponent, selectors: [["kendo-tabstrip-tab"]], contentQueries: function TabStripTabComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabContentDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabTitleDirective, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabContent = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabTitleDirective = _t);
    } }, inputs: { disabled: "disabled", title: "title", cssClass: "cssClass", cssStyle: "cssStyle", selected: "selected", closable: "closable", closeIcon: "closeIcon" }, exportAs: ["kendoTabStripTab"], decls: 0, vars: 0, template: function TabStripTabComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], TabStripTabComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TabStripTabComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TabStripTabComponent.prototype, "cssClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TabStripTabComponent.prototype, "cssStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TabStripTabComponent.prototype, "selected", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TabStripTabComponent.prototype, "closable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TabStripTabComponent.prototype, "closeIcon", void 0);
__decorate([
    ContentChildren(TabContentDirective),
    __metadata("design:type", QueryList)
], TabStripTabComponent.prototype, "_tabContent", void 0);
__decorate([
    ContentChildren(TabTitleDirective),
    __metadata("design:type", QueryList)
], TabStripTabComponent.prototype, "_tabTitleDirective", void 0);

/**
 * Arguments for the `tabClose` event of the TabStrip.
 * The `tabClose` event fires when the close button of the tab is clicked.
 *
 */
class TabCloseEvent {
    /**
     * Constructs the event arguments for the `tabClose` event.
     * @param index - The index of the closed tab.
     * @param tab - The closed tab instance
     */
    constructor(index, tab) {
        this.index = index;
        this.tab = tab;
    }
}

/**
 * Arguments for the `select` event of the TabStrip.
 * The `select` event fires when a tab is selected (clicked).
 */
class SelectEvent extends PreventableEvent {
    /**
     * Constructs the event arguments for the `select` event.
     * @param index - The index of the selected tab.
     * @param title - The title of the selected tab.
     */
    constructor(index, title) {
        super();
        this.index = index;
        this.title = title;
    }
}

/**
 * @hidden
 *
 * Checks if the current target is a TabStrip tab element
 */
const isTabElement = (target) => {
    const targetId = target.getAttribute('id');
    if (isPresent(targetId) || targetId.indexOf('k-tabstrip-tab-') >= 0) {
        return true;
    }
    return false;
};
/**
 * @hidden
 *
 * Checks if the current tab is closable. Depends on the value of the TabStrip closable property.
 */
const isTabClosable = (tab, tabStripClosable) => {
    if (tab.closable !== undefined) {
        return tab.closable;
    }
    return tabStripClosable;
};
/**
 * @hidden
 *
 * Checks if the TabStrip scroll buttons will be rendered. Depends on the value of the TabStrip scrollable settings.
 */
const tabStripHasScrollButtons = (scrollableSettings) => {
    return scrollableSettings.enabled && scrollableSettings.scrollButtons !== 'hidden';
};
/**
 * @hidden
 *
 * Checks if the TabStrip mouse scroll will be enabled. Depends on the value of the TabStrip scrollable settings.
 */
const mouseScrollEnabled = (scrollableSettings) => {
    return scrollableSettings.enabled && scrollableSettings.mouseScroll;
};
/**
 * @hidden
 *
 * Retrieves the current active tab element and its index.
 * This could either be the currently selected tab or the currently focused tab.
 */
const getActiveTab = (tabs) => {
    let focusedTab;
    let selectedTab;
    let focusedIndex = -1;
    let selectedIndex = -1;
    tabs.forEach((tab, index) => {
        if (tab.selected) {
            selectedTab = tab;
            selectedIndex = index;
        }
        else if (tab.focused) {
            focusedTab = tab;
            focusedIndex = index;
        }
    });
    return focusedIndex >= 0 ?
        { tab: focusedTab, index: focusedIndex } :
        { tab: selectedTab, index: selectedIndex };
};
/**
 * @hidden
 */
const getTabByIndex = (tabs, index) => {
    const filtered = tabs.filter((_tab, i) => i === index);
    if (filtered.length > 0) {
        return filtered[0];
    }
    return null;
};
/**
 * @hidden
 */
const getTabHeaderByIndex = (tabHeaderContainers, index) => {
    const filtered = tabHeaderContainers.filter((_tabHeader, i) => i === index);
    if (filtered.length > 0) {
        return filtered[0];
    }
    return null;
};
/**
 * @hidden
 */
const resetTabFocus = (tabs) => {
    tabs.forEach((tab) => {
        tab.focused = false;
    });
};
/**
 * @hidden
 */
const resetTabSelection = (tabs) => {
    tabs.forEach((tab) => {
        tab.selected = false;
    });
};
/**
 * @hidden
 */
const isTablistHorizontal = (tabPosition) => tabPosition === 'top' || tabPosition === 'bottom';

/**
 * @hidden
 */
let TabStripService = class TabStripService {
    constructor(localization, ngZone) {
        this.localization = localization;
        this.ngZone = ngZone;
    }
    onKeyDown(event) {
        if (!isTabElement(event.target)) {
            return;
        }
        const key = event.keyCode;
        if (this.shouldHandleKey(key)) {
            event.preventDefault();
        }
        else {
            return;
        }
        if (isNavigationKey(key) || isArrowKey(key)) {
            this.onNavigate(key);
        }
        else if (key === Keys.Delete) {
            this.onDelete();
        }
    }
    onTabSelect(tab, index) {
        const selectArgs = new SelectEvent(index, tab.title);
        this.owner.tabSelect.emit(selectArgs);
        if (!selectArgs.isDefaultPrevented()) {
            if (tab.selected) {
                this.focusTabHeader(index);
                return;
            }
            this.selectTab(tab, index);
        }
    }
    selectTab(tab, index) {
        resetTabSelection(this.owner.tabs);
        this.focusTabHeader(index);
        tab.selected = true;
        if (this.owner.isScrollable) {
            this.owner.scrollToSelectedTab();
        }
    }
    onTabClose(tab, index) {
        const closeArgs = new TabCloseEvent(index, tab);
        this.owner.tabClose.emit(closeArgs);
    }
    onNavigate(keyCode) {
        let { tab: activeTab, index: activeIndex } = getActiveTab(this.owner.tabs);
        if (!NgZone.isInAngularZone()) {
            this.ngZone.run(() => {
                if (activeIndex < 0) {
                    this.owner.selectTab(this.firstNavigatableIndex());
                    return;
                }
                activeTab.focused = false;
                const nextIndex = this.computeNextIndex(activeIndex, keyCode);
                this.activateTab(nextIndex);
            });
        }
    }
    onDelete() {
        let { tab: activeTab, index: activeTabIndex } = getActiveTab(this.owner.tabs);
        if (isTabClosable(activeTab, this.owner.closable) && !activeTab.disabled) {
            this.ngZone.run(() => {
                this.onTabClose(activeTab, activeTabIndex);
            });
        }
    }
    activateTab(index) {
        const tab = getTabByIndex(this.owner.tabs, index);
        if (tab.disabled) {
            this.focusTabHeader(index);
            tab.focused = true;
        }
        else {
            this.onTabSelect(tab, index);
        }
    }
    focusTabHeader(index) {
        const tabHeader = getTabHeaderByIndex(this.owner.tabHeaderContainers, index);
        tabHeader.nativeElement.focus();
    }
    shouldHandleKey(keyCode) {
        if (isNavigationKey(keyCode)) {
            return true;
        }
        if (isTablistHorizontal(this.owner.tabPosition) && isHorizontalArrowKey(keyCode)) {
            return true;
        }
        if (!isTablistHorizontal(this.owner.tabPosition) && isVerticalArrowKey(keyCode)) {
            return true;
        }
        if (keyCode === Keys.Delete) {
            return true;
        }
        return false;
    }
    computeNextIndex(activeIndex, keyCode) {
        switch (keyCode) {
            case this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight):
            case this.invertKeys(Keys.ArrowUp, Keys.ArrowDown):
                return this.prevNavigatableIndex(activeIndex);
            case this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft):
            case this.invertKeys(Keys.ArrowDown, Keys.ArrowUp):
                return this.nextNavigatableIndex(activeIndex);
            case Keys.Home:
                return this.firstNavigatableIndex();
            case Keys.End:
                return this.lastNavigatableIndex();
            default:
                return;
        }
    }
    invertKeys(original, inverted) {
        return this.localization.rtl ? inverted : original;
    }
    firstNavigatableIndex() {
        return 0;
    }
    lastNavigatableIndex() {
        return this.owner.tabs.length - 1;
    }
    prevNavigatableIndex(selectedIndex) {
        if (selectedIndex - 1 < 0) {
            return this.lastNavigatableIndex();
        }
        return selectedIndex - 1;
    }
    nextNavigatableIndex(selectedIndex) {
        if (selectedIndex + 1 >= this.owner.tabs.length) {
            return this.firstNavigatableIndex();
        }
        return selectedIndex + 1;
    }
};
TabStripService.ɵfac = function TabStripService_Factory(t) { return new (t || TabStripService)(ɵngcc0.ɵɵinject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
TabStripService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: TabStripService, factory: function (t) { return TabStripService.ɵfac(t); } });
TabStripService = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        NgZone])
], TabStripService);

/**
 * @hidden
 */
const MOUSE_SCROLL_SPEED = 10;
/**
 * @hidden
 */
const BUTTON_SCROLL_SPEED = 100;
/**
 * @hidden
 */
const HIDDEN_CLASS = 'k-hidden';
/**
 * @hidden
 */
const DIRECTION_CLASSES = {
    left: 'k-i-arrow-60-left',
    right: 'k-i-arrow-60-right',
    up: 'k-i-arrow-60-up',
    down: 'k-i-arrow-60-down'
};
/**
 * @hidden
 */
const DEFAULT_SCROLL_BEHAVIOR = 'smooth';

/**
 * Arguments for the `tabScroll` event of the TabStrip.
 * The `tabScroll` event fires when the tabs are being scrolled.
 *
 */
class TabScrollEvent extends PreventableEvent$1 {
}

/**
 * @hidden
 */
let ScrollService = class ScrollService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.position = 0;
        this.scrollButtonActiveStateChange = new Subject();
    }
    get tablistElement() {
        return this.owner.tablist.nativeElement;
    }
    get scrollButtonIconClass() {
        const tabStrip = this.owner;
        const defaultPrevIcon = isTablistHorizontal(tabStrip.tabPosition) ? DIRECTION_CLASSES.left : DIRECTION_CLASSES.up;
        const defaultNextIcon = isTablistHorizontal(tabStrip.tabPosition) ? DIRECTION_CLASSES.right : DIRECTION_CLASSES.down;
        if (typeof tabStrip.scrollable === 'object') {
            const prevIcon = typeof tabStrip.scrollable.prevButtonIcon === 'undefined' ? defaultPrevIcon : tabStrip.scrollable.prevButtonIcon;
            const nextIcon = typeof tabStrip.scrollable.nextButtonIcon === 'undefined' ? defaultNextIcon : tabStrip.scrollable.nextButtonIcon;
            return { prevScrollButton: prevIcon, nextScrollButton: nextIcon };
        }
        return { prevScrollButton: defaultPrevIcon, nextScrollButton: defaultNextIcon };
    }
    get tabstripSize() {
        const hostElement = this.owner.wrapper.nativeElement;
        const wrapperWidth = parseFloat(getComputedStyle(hostElement).width);
        const wrapperHeight = parseFloat(getComputedStyle(hostElement).height);
        return isTablistHorizontal(this.owner.tabPosition) ? wrapperWidth : wrapperHeight;
    }
    get tablistOverflowSize() {
        if (!isDocumentAvailable()) {
            return 0;
        }
        const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
        const overflowSize = Math.floor(this.tablistElement[isHorizontal ? 'scrollWidth' : 'scrollHeight']
            - this.tablistElement.getBoundingClientRect()[isHorizontal ? 'width' : 'height']);
        return overflowSize < 0 ? 0 : overflowSize;
    }
    get tabsOverflow() {
        return this.tablistOverflowSize > 0;
    }
    get scrollButtonsSize() {
        if (!this.owner.hasScrollButtons) {
            return 0;
        }
        const prevRect = this.owner.prevScrollButton.hostBoundingClientRect;
        const prevSize = isTablistHorizontal(this.owner.tabPosition) ? prevRect.width : prevRect.height;
        const nextRect = this.owner.nextScrollButton.hostBoundingClientRect;
        const nextSize = isTablistHorizontal(this.owner.tabPosition) ? nextRect.width : nextRect.height;
        return prevSize + nextSize;
    }
    toggleScrollButtonsState() {
        const tabStrip = this.owner;
        if (!tabStrip.hasScrollButtons) {
            return;
        }
        const currentPrevButtonActive = !tabStrip.prevScrollButton.disabled;
        const currentNextButtonActive = !tabStrip.nextScrollButton.disabled;
        const calculatedPrevButtonActive = this.position > 0 && this.tablistOverflowSize > 0;
        const calculatedNextButtonActive = this.position < this.tablistOverflowSize + this.scrollButtonsSize && this.tablistOverflowSize > 0;
        if (calculatedPrevButtonActive !== currentPrevButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('prev', calculatedPrevButtonActive));
        }
        if (calculatedNextButtonActive !== currentNextButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('next', calculatedNextButtonActive));
        }
    }
    scrollToSelectedTab() {
        if (!this.tabsOverflow) {
            return;
        }
        let { index: activeIndex } = getActiveTab(this.owner.tabs);
        if (activeIndex === -1) {
            return;
        }
        this.position += this.getScrollOffset(activeIndex);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollLeft = this.position;
        }
        else {
            this.tablistElement.scrollTop = this.position;
        }
        this.toggleScrollButtonsState();
        const tabStrip = this.owner;
        if (!tabStrip.hasScrollButtons) {
            return;
        }
        const isFirstTabActive = activeIndex === 0;
        const isLastTabActive = activeIndex === this.owner.tabs.length - 1;
        if (isFirstTabActive && !tabStrip.prevScrollButton.disabled) {
            this.ngZone.run(() => this.toggleButtonActiveState('prev', false));
        }
        if (isLastTabActive && !tabStrip.nextScrollButton.disabled) {
            this.ngZone.run(() => this.toggleButtonActiveState('next', false));
        }
    }
    getScrollOffset(activeIndex) {
        if (!isDocumentAvailable()) {
            return 0;
        }
        const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
        this.tablistElement[`scroll${isHorizontal ? 'Left' : 'Top'}`] = this.position;
        const activeTabRect = this.tablistElement.children[activeIndex].getBoundingClientRect();
        const tablistRect = this.tablistElement.getBoundingClientRect();
        const end = isHorizontal ? 'right' : 'bottom';
        const start = isHorizontal ? 'left' : 'top';
        const activeTabStart = activeTabRect[start];
        const activeTabEnd = activeTabRect[end];
        const tablistStart = tablistRect[start];
        const tablistEnd = tablistRect[end];
        const tabEndIsInVisibleRange = activeTabEnd <= tablistEnd;
        const tabStartIsInVisibleRange = activeTabStart >= tablistStart;
        const isWholeTabVisible = tabEndIsInVisibleRange && tabStartIsInVisibleRange;
        if (isWholeTabVisible) {
            return 0;
        }
        if (!tabEndIsInVisibleRange) {
            return activeTabEnd - tablistEnd;
        }
        if (!tabStartIsInVisibleRange) {
            return activeTabStart - tablistStart;
        }
    }
    onMouseScroll(event) {
        event.preventDefault();
        if (!mouseScrollEnabled(this.owner.scrollable)) {
            return;
        }
        const direction = event.deltaY < 0 ? 'prev' : 'next';
        this.calculateListPosition(direction, this.owner.scrollable.mouseScrollSpeed);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollLeft = this.position;
        }
        else {
            this.tablistElement.scrollTop = this.position;
        }
        this.toggleScrollButtonsState();
    }
    scrollTabs(direction) {
        this.calculateListPosition(direction, this.owner.scrollable.buttonScrollSpeed);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollTo({ left: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        else {
            this.tablistElement.scrollTo({ top: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        this.toggleScrollButtonsState();
    }
    calculateListPosition(direction, scrollSpeed) {
        const adjustedMaxScroll = this.tablistOverflowSize + this.scrollButtonsSize;
        if (direction === 'prev' && this.position > 0) {
            this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;
        }
        else if (direction === 'next' && this.position < adjustedMaxScroll) {
            if (this.position + scrollSpeed > adjustedMaxScroll) {
                this.position = adjustedMaxScroll;
                return;
            }
            this.position += scrollSpeed;
        }
    }
    emitScrollEvent(ev) {
        const scrollEvent = new TabScrollEvent({
            originalEvent: ev
        });
        if (hasObservers(this.owner.tabScroll)) {
            this.owner.tabScroll.emit(scrollEvent);
        }
        return scrollEvent;
    }
    restoreScrollPosition() {
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollTo({ left: this.position });
        }
        else {
            this.tablistElement.scrollTo({ top: this.position });
        }
        this.toggleScrollButtonsState();
    }
    toggleButtonActiveState(buttonType, active) {
        this.scrollButtonActiveStateChange.next({ buttonType, active });
    }
};
ScrollService.ɵfac = function ScrollService_Factory(t) { return new (t || ScrollService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ScrollService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ScrollService, factory: function (t) { return ScrollService.ɵfac(t); } });
ScrollService = __decorate([ __metadata("design:paramtypes", [NgZone])
], ScrollService);

/**
 * @hidden
 */
const normalizeSettings = ({ enabled = true, scrollButtons = 'auto', mouseScroll = true, buttonScrollSpeed = BUTTON_SCROLL_SPEED, mouseScrollSpeed = MOUSE_SCROLL_SPEED, prevButtonIcon, nextButtonIcon }) => ({
    enabled,
    scrollButtons,
    mouseScroll,
    buttonScrollSpeed,
    mouseScrollSpeed,
    prevButtonIcon,
    nextButtonIcon
});
/**
 * @hidden
 */
const normalizeScrollableSettings = (settings) => normalizeSettings(settings === false ? { enabled: false } : settings);

/**
 * @hidden
 */
let TabStripScrollableButtonComponent = class TabStripScrollableButtonComponent {
    constructor(host, scrollService, renderer, ngZone) {
        this.host = host;
        this.scrollService = scrollService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.btnClasses = true;
        this.prev = false;
        this._disabled = false;
        this.subs = new Subscription();
        this.clickHandler = (scrollEvent) => {
            const tabStripScrollEvent = this.scrollService.emitScrollEvent(scrollEvent);
            const isTabStripScrollEventPrevented = tabStripScrollEvent.isDefaultPrevented();
            if (isTabStripScrollEventPrevented) {
                return;
            }
            const buttonType = this.prev ? 'prev' : 'next';
            this.scrollService.scrollTabs(buttonType);
        };
        this.subs.add(this.scrollService.scrollButtonActiveStateChange.subscribe((activeButtonSettings) => {
            const applyActiveState = (this.prev && activeButtonSettings.buttonType === 'prev') ||
                (!this.prev && activeButtonSettings.buttonType === 'next');
            if (applyActiveState) {
                this.disabled = !activeButtonSettings.active;
            }
        }));
    }
    get prevClass() {
        return this.prev;
    }
    get nextClass() {
        return !this.prev;
    }
    get disabled() {
        return this._disabled;
    }
    get hostBoundingClientRect() {
        return this.host.nativeElement.getBoundingClientRect();
    }
    get iconClass() {
        return this.scrollService.scrollButtonIconClass[this.prev ? 'prevScrollButton' : 'nextScrollButton'];
    }
    set disabled(value) {
        this._disabled = value;
    }
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            this.subs.add(this.renderer.listen(this.host.nativeElement, 'click', this.clickHandler));
        });
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    toggle(show) {
        this.renderer[show ? 'removeClass' : 'addClass'](this.host.nativeElement, HIDDEN_CLASS);
    }
};
TabStripScrollableButtonComponent.ɵfac = function TabStripScrollableButtonComponent_Factory(t) { return new (t || TabStripScrollableButtonComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ScrollService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
TabStripScrollableButtonComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TabStripScrollableButtonComponent, selectors: [["", "kendoTabStripScrollableButton", ""]], hostVars: 18, hostBindings: function TabStripScrollableButtonComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-button", ctx.btnClasses)("k-button-md", ctx.btnClasses)("k-icon-button", ctx.btnClasses)("k-rounded-md", ctx.btnClasses)("k-button-flat", ctx.btnClasses)("k-button-flat-base", ctx.btnClasses)("k-disabled", ctx.disabled)("k-tabstrip-prev", ctx.prevClass)("k-tabstrip-next", ctx.nextClass);
    } }, inputs: { prev: "prev" }, attrs: _c12, decls: 1, vars: 1, consts: [[1, "k-icon", "k-button-icon", 3, "ngClass"]], template: function TabStripScrollableButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.iconClass);
    } }, directives: [ɵngcc1.NgClass], encapsulation: 2 });
__decorate([
    HostBinding('class.k-button'),
    HostBinding('class.k-button-md'),
    HostBinding('class.k-icon-button'),
    HostBinding('class.k-rounded-md'),
    HostBinding('class.k-button-flat'),
    HostBinding('class.k-button-flat-base'),
    __metadata("design:type", Boolean)
], TabStripScrollableButtonComponent.prototype, "btnClasses", void 0);
__decorate([
    HostBinding('class.k-tabstrip-prev'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TabStripScrollableButtonComponent.prototype, "prevClass", null);
__decorate([
    HostBinding('class.k-tabstrip-next'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TabStripScrollableButtonComponent.prototype, "nextClass", null);
__decorate([
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], TabStripScrollableButtonComponent.prototype, "disabled", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TabStripScrollableButtonComponent.prototype, "prev", void 0);
TabStripScrollableButtonComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        ScrollService,
        Renderer2,
        NgZone])
], TabStripScrollableButtonComponent);

/**
 * Represents the [Kendo UI TabStrip component for Angular]({% slug overview_tabstrip %}).
 */
let TabStripComponent = class TabStripComponent {
    constructor(localization, renderer, wrapper, tabstripService, scrollService, ngZone) {
        this.localization = localization;
        this.renderer = renderer;
        this.wrapper = wrapper;
        this.tabstripService = tabstripService;
        this.scrollService = scrollService;
        this.ngZone = ngZone;
        /**
         * Enables the tab animation.
         *
         * @default true
         */
        this.animate = true;
        /**
         * Sets the position of the tabs. Defaults to `top`.
         *
         * @default 'top'
         */
        this.tabPosition = 'top';
        /**
         * When set to `true`, the component renders all tabs and they are persisted in the DOM.
         * By default, `keepTabContent` is `false`.
         *
         * @default false
         */
        this.keepTabContent = false;
        /**
         * When set to `true`, a close button will be rendered inside each tab.
         * By default, `closable` is `false`.
         *
         * @default false
         */
        this.closable = false;
        /**
         * Allows defining a custom CSS class, or multiple classes separated by spaces, which will be applied to the close button span element.
         * Allows the usage of custom icons.
         */
        this.closeIcon = 'k-icon k-i-x';
        /**
         * Fires each time the user selects a tab ([see example]({% slug overview_tabstrip %}#toc-basic-usage)).
         * The event data contains the index of the selected tab and its title.
         */
        this.tabSelect = new EventEmitter();
        /**
         * Fires each time the user closes a tab.
         * The event data contains the index of the closed tab and its instance.
         */
        this.tabClose = new EventEmitter();
        /**
         * Fires each time the user scrolls the TabStrip list.
         * The event is preventable.
         */
        this.tabScroll = new EventEmitter();
        this.hostClasses = true;
        /**
         * A query list of all declared tabs.
         */
        this.tabs = new QueryList();
        this._scrollableSettings = normalizeScrollableSettings(false);
        this.subscriptions = new Subscription();
        this.subscriptionsArePresent = false;
        validatePackage(packageMetadata);
        this.tabstripService.owner = this;
        this.scrollService.owner = this;
    }
    /**
     * Sets the height of the TabStrip.
     */
    set height(value) {
        this._height = value;
        this.renderer.setStyle(this.wrapper.nativeElement, 'height', value);
    }
    get height() {
        return this._height;
    }
    /**
     * Enables the scrolling of the tab list. When set to `true` and the total size of all tabs
     * is greater than the size of the TabStrip container, scroll buttons will be rendered on each end of the tab list.
     *
     * By default, `scrollable` is `false`.
     *
     * @default false
     */
    set scrollable(value) {
        this._scrollableSettings = normalizeScrollableSettings(value);
        if (this.tablist) {
            this.toggleScrollButtons(this.scrollService.tabsOverflow);
            this.attachWheelHandler(this.tablist.nativeElement);
        }
    }
    get scrollable() {
        return this._scrollableSettings;
    }
    get tabsAtTop() {
        return this.tabPosition === 'top';
    }
    get tabsAtRight() {
        return this.tabPosition === 'right';
    }
    get tabsAtBottom() {
        return this.tabPosition === 'bottom';
    }
    get tabsAtLeft() {
        return this.tabPosition === 'left';
    }
    get dir() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    get tabStripScrollable() {
        return this._scrollableSettings.enabled;
    }
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            if (this.scrollService.tabsOverflow) {
                this.toggleScrollButtons(true);
            }
            else {
                this.toggleScrollButtons(false);
            }
            setTimeout(() => {
                this.scrollToSelectedTab();
            });
        });
        this.initDomEvents();
    }
    ngOnChanges(changes) {
        const positionChange = changes.tabPosition;
        if (positionChange) {
            const tabsAtBottomChanged = positionChange.previousValue === 'bottom' || positionChange.currentValue === 'bottom';
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                if (tabsAtBottomChanged) {
                    if (this.subscriptionsArePresent) {
                        this.subscriptions.unsubscribe();
                        this.subscriptions = new Subscription();
                        this.subscriptionsArePresent = false;
                    }
                    this.initDomEvents();
                }
                this.scrollService.restoreScrollPosition();
            });
        }
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get tabsAlignmentStyles() {
        return {
            start: 'flex-start',
            end: 'flex-end',
            center: 'center',
            justify: 'space-between'
        }[this.tabAlignment];
    }
    /**
     * @hidden
     */
    get tabListWidth() {
        if (this.tabPosition === 'top' || this.tabPosition === 'bottom') {
            return '100%';
        }
        return null;
    }
    /**
     * @hidden
     */
    get tabListHeight() {
        if (this.tabPosition === 'left' || this.tabPosition === 'right') {
            return '100%';
        }
        return null;
    }
    /**
     * @hidden
     */
    get isScrollable() {
        return this._scrollableSettings.enabled;
    }
    /**
     * @hidden
     */
    get hasScrollButtons() {
        return tabStripHasScrollButtons(this._scrollableSettings);
    }
    /**
     * @hidden
     */
    get mouseScrollEnabled() {
        return mouseScrollEnabled(this._scrollableSettings);
    }
    /**
     * @hidden
     */
    get itemsWrapperClass() {
        return isTablistHorizontal(this.tabPosition) ? 'k-hstack' : 'k-vstack';
    }
    /**
     * Allows the user to select a tab programmatically.
     * @param {number} index - The index of the tab that will be selected.
     */
    selectTab(index) {
        const tab = getTabByIndex(this.tabs, index);
        if (!tab || tab.disabled) {
            return;
        }
        this.tabstripService.selectTab(tab, index);
        this.scrollToSelectedTab();
    }
    /**
     * @hidden
     */
    onTabClick(originalEvent, tabIndex) {
        if (isFocusable(originalEvent.target)) {
            return;
        }
        const targetElement = originalEvent.target;
        const isTargetCloseButton = hasClass(targetElement, 'k-remove-tab') || hasClass(targetElement.parentElement, 'k-remove-tab');
        if (isTargetCloseButton) {
            return;
        }
        const tab = getTabByIndex(this.tabs, tabIndex);
        this.tabstripService.onTabSelect(tab, tabIndex);
        this.scrollToSelectedTab();
    }
    /**
     * @hidden
     */
    onResize() {
        if (this.scrollService.tabsOverflow) {
            this.toggleScrollButtons(true);
        }
        else {
            this.toggleScrollButtons(false);
        }
        this.ngZone.runOutsideAngular(() => {
            this.scrollService.toggleScrollButtonsState();
        });
    }
    /**
     * @hidden
     */
    scrollToSelectedTab() {
        if (this._scrollableSettings.enabled) {
            this.scrollService.scrollToSelectedTab();
        }
    }
    initDomEvents() {
        if (!this.wrapper || this.subscriptionsArePresent) {
            return;
        }
        const tablist = this.tablist.nativeElement;
        this.ngZone.runOutsideAngular(() => {
            this.subscriptions.add(this.renderer.listen(tablist, 'keydown', (ev) => {
                this.tabstripService.onKeyDown(ev);
            }));
        });
        this.subscriptions.add(this.renderer.listen(tablist, 'focusout', () => {
            resetTabFocus(this.tabs);
        }));
        if (this.isScrollable && this.mouseScrollEnabled) {
            this.attachWheelHandler(tablist);
        }
        this.subscriptionsArePresent = true;
    }
    toggleScrollButtons(tabsOverflow) {
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            const scrollButtonsSetting = this._scrollableSettings.scrollButtons;
            const scrollButtonsArePresent = this.prevScrollButton && this.nextScrollButton;
            const shouldShowButtons = scrollButtonsArePresent && tabsOverflow;
            const shouldHideButtons = scrollButtonsArePresent &&
                !tabsOverflow &&
                scrollButtonsSetting !== 'visible';
            const alwaysVisible = scrollButtonsSetting === 'visible';
            if (shouldHideButtons) {
                this.prevScrollButton.toggle(false);
                this.nextScrollButton.toggle(false);
            }
            else if (shouldShowButtons || alwaysVisible) {
                this.prevScrollButton.toggle(true);
                this.nextScrollButton.toggle(true);
            }
            if (scrollButtonsArePresent && alwaysVisible) {
                this.ngZone.runOutsideAngular(() => {
                    this.scrollService.toggleScrollButtonsState();
                });
            }
        });
    }
    attachWheelHandler(tablist) {
        this.ngZone.runOutsideAngular(() => {
            this.subscriptions.add(this.renderer.listen(tablist, 'wheel', (wheelEvent) => {
                const tabStripScrollEvent = this.scrollService.emitScrollEvent(wheelEvent);
                const isTabStripScrollEventPrevented = tabStripScrollEvent.isDefaultPrevented();
                if (isTabStripScrollEventPrevented || !this.scrollService.tabsOverflow) {
                    return;
                }
                this.scrollService.onMouseScroll(wheelEvent);
            }));
        });
    }
};
TabStripComponent.ɵfac = function TabStripComponent_Factory(t) { return new (t || TabStripComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(TabStripService), ɵngcc0.ɵɵdirectiveInject(ScrollService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
TabStripComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TabStripComponent, selectors: [["kendo-tabstrip"]], contentQueries: function TabStripComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabStripTabComponent, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, viewQuery: function TabStripComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c13, 5);
        ɵngcc0.ɵɵviewQuery(_c14, 5);
        ɵngcc0.ɵɵviewQuery(_c15, 5);
        ɵngcc0.ɵɵviewQuery(_c16, 5, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tablist = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.prevScrollButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nextScrollButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabHeaderContainers = _t);
    } }, hostVars: 15, hostBindings: function TabStripComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-tabstrip", ctx.hostClasses)("k-floatwrap", ctx.hostClasses)("k-tabstrip-top", ctx.tabsAtTop)("k-tabstrip-right", ctx.tabsAtRight)("k-tabstrip-bottom", ctx.tabsAtBottom)("k-tabstrip-left", ctx.tabsAtLeft)("k-tabstrip-scrollable", ctx.tabStripScrollable);
    } }, inputs: { animate: "animate", tabPosition: "tabPosition", keepTabContent: "keepTabContent", closable: "closable", closeIcon: "closeIcon", height: "height", scrollable: "scrollable", tabAlignment: "tabAlignment" }, outputs: { tabSelect: "tabSelect", tabClose: "tabClose", tabScroll: "tabScroll" }, exportAs: ["kendoTabStrip"], features: [ɵngcc0.ɵɵProvidersFeature([
            TabStripService,
            ScrollService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.tabstrip'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 3, consts: function () { let i18n_17; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the **Close** button in the TabStrip tab.
         * @meaning kendo.tabstrip.closeTitle
         */
        const MSG_EXTERNAL_6238253944136586274$$DIST_FESM2015_INDEX_JS_18 = goog.getMsg("Close");
        i18n_17 = MSG_EXTERNAL_6238253944136586274$$DIST_FESM2015_INDEX_JS_18;
    }
    else {
        i18n_17 = $localize `:kendo.tabstrip.closeTitle|The title for the **Close** button in the TabStrip tab.␟28d3600711ed2cde12f915765a15978db3ec0fd1␟6238253944136586274:Close`;
    } return [["kendoTabStripLocalizedMessages", "", "closeTitle", i18n_17], [4, "ngIf"], ["heading", ""], ["content", ""], [3, "resize", 4, "ngIf"], [4, "ngTemplateOutlet"], [1, "k-tabstrip-items-wrapper", 3, "ngClass"], ["kendoTabStripScrollableButton", "", 3, "prev", 4, "ngIf"], ["role", "tablist", 1, "k-reset", "k-tabstrip-items"], ["tablist", ""], [4, "ngFor", "ngForOf"], ["kendoTabStripScrollableButton", "", 3, "prev"], ["prevScrollButton", ""], ["kendoTabStripTab", "", "role", "tab", 3, "ngClass", "ngStyle", "tab", "index", "tabStripClosable", "tabStripCloseIcon", "id", "click", 4, "ngIf"], ["kendoTabStripTab", "", "role", "tab", 3, "ngClass", "ngStyle", "tab", "index", "tabStripClosable", "tabStripCloseIcon", "id", "click"], ["tabHeaderContainer", ""], ["nextScrollButton", ""], ["ngFor", "", 3, "ngForOf"], ["role", "tabpanel", 3, "ngClass", "tabIndex", "id", 4, "ngIf"], ["role", "tabpanel", 3, "ngClass", "tabIndex", "id"], [3, "ngTemplateOutlet"], [3, "resize"]]; }, template: function TabStripComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_container_1_Template, 3, 2, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, TabStripComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(3, TabStripComponent_ng_template_3_Template, 6, 10, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, TabStripComponent_ng_template_5_Template, 1, 1, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(7, TabStripComponent_kendo_resize_sensor_7_Template, 1, 0, "kendo-resize-sensor", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tabsAtBottom);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tabsAtBottom);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isScrollable);
    } }, directives: function () { return [LocalizedTabStripMessagesDirective, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass, TabStripScrollableButtonComponent, ɵngcc1.NgForOf, TabComponent, ɵngcc1.NgStyle, ɵngcc3.ResizeSensorComponent]; }, encapsulation: 2, data: { animation: [
            trigger('state', [
                state('active', style({ opacity: 1 })),
                transition('* => active', [
                    style({ opacity: 0 }),
                    animate('400ms ease-in')
                ])
            ])
        ] } });
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TabStripComponent.prototype, "height", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TabStripComponent.prototype, "animate", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TabStripComponent.prototype, "tabAlignment", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TabStripComponent.prototype, "tabPosition", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TabStripComponent.prototype, "keepTabContent", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TabStripComponent.prototype, "closable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], TabStripComponent.prototype, "scrollable", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], TabStripComponent.prototype, "closeIcon", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TabStripComponent.prototype, "tabSelect", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TabStripComponent.prototype, "tabClose", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TabStripComponent.prototype, "tabScroll", void 0);
__decorate([
    HostBinding('class.k-tabstrip'),
    HostBinding('class.k-floatwrap'),
    __metadata("design:type", Boolean)
], TabStripComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.k-tabstrip-top'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TabStripComponent.prototype, "tabsAtTop", null);
__decorate([
    HostBinding('class.k-tabstrip-right'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TabStripComponent.prototype, "tabsAtRight", null);
__decorate([
    HostBinding('class.k-tabstrip-bottom'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TabStripComponent.prototype, "tabsAtBottom", null);
__decorate([
    HostBinding('class.k-tabstrip-left'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TabStripComponent.prototype, "tabsAtLeft", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], TabStripComponent.prototype, "dir", null);
__decorate([
    HostBinding('class.k-tabstrip-scrollable'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TabStripComponent.prototype, "tabStripScrollable", null);
__decorate([
    ContentChildren(TabStripTabComponent),
    __metadata("design:type", QueryList)
], TabStripComponent.prototype, "tabs", void 0);
__decorate([
    ViewChild('tablist', { static: false }),
    __metadata("design:type", ElementRef)
], TabStripComponent.prototype, "tablist", void 0);
__decorate([
    ViewChildren('tabHeaderContainer', { read: ElementRef }),
    __metadata("design:type", QueryList)
], TabStripComponent.prototype, "tabHeaderContainers", void 0);
__decorate([
    ViewChild('prevScrollButton', { static: false }),
    __metadata("design:type", TabStripScrollableButtonComponent)
], TabStripComponent.prototype, "prevScrollButton", void 0);
__decorate([
    ViewChild('nextScrollButton', { static: false }),
    __metadata("design:type", TabStripScrollableButtonComponent)
], TabStripComponent.prototype, "nextScrollButton", void 0);
TabStripComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        Renderer2,
        ElementRef,
        TabStripService,
        ScrollService,
        NgZone])
], TabStripComponent);

/**
 * @hidden
 */
class TabStripMessages extends ComponentMessages {
}
TabStripMessages.ɵfac = /*@__PURE__*/ function () { let ɵTabStripMessages_BaseFactory; return function TabStripMessages_Factory(t) { return (ɵTabStripMessages_BaseFactory || (ɵTabStripMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TabStripMessages)))(t || TabStripMessages); }; }();
TabStripMessages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TabStripMessages, inputs: { closeTitle: "closeTitle" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], TabStripMessages.prototype, "closeTitle", void 0);

var LocalizedTabStripMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedTabStripMessagesDirective = LocalizedTabStripMessagesDirective_1 = class LocalizedTabStripMessagesDirective extends TabStripMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
LocalizedTabStripMessagesDirective.ɵfac = function LocalizedTabStripMessagesDirective_Factory(t) { return new (t || LocalizedTabStripMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
LocalizedTabStripMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LocalizedTabStripMessagesDirective, selectors: [["", "kendoTabStripLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TabStripMessages,
                useExisting: forwardRef(() => LocalizedTabStripMessagesDirective_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
LocalizedTabStripMessagesDirective = LocalizedTabStripMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LocalizedTabStripMessagesDirective);

var TabStripCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages
 * ([see example]({% slug rtl_layout %})).
 */
let TabStripCustomMessagesComponent = TabStripCustomMessagesComponent_1 = class TabStripCustomMessagesComponent extends TabStripMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
TabStripCustomMessagesComponent.ɵfac = function TabStripCustomMessagesComponent_Factory(t) { return new (t || TabStripCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
TabStripCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TabStripCustomMessagesComponent, selectors: [["kendo-tabstrip-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TabStripMessages,
                useExisting: forwardRef(() => TabStripCustomMessagesComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function TabStripCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
TabStripCustomMessagesComponent = TabStripCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], TabStripCustomMessagesComponent);

/**
 * Represents a template that defines the content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerTemplate` directive inside the `<kendo-drawer>` tag.
 * Using this template directive will override all other templates,
 * for example, `kendoDrawerHeaderTemplate` and `kendoDrawerItemTemplate`.
 */
let DrawerTemplateDirective = class DrawerTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
DrawerTemplateDirective.ɵfac = function DrawerTemplateDirective_Factory(t) { return new (t || DrawerTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DrawerTemplateDirective, selectors: [["", "kendoDrawerTemplate", ""]] });
DrawerTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], DrawerTemplateDirective);

/**
 * Represents a template that defines the item content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerItemTemplate` directive inside the `<kendo-drawer>` tag.
 */
let DrawerItemTemplateDirective = class DrawerItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
DrawerItemTemplateDirective.ɵfac = function DrawerItemTemplateDirective_Factory(t) { return new (t || DrawerItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerItemTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DrawerItemTemplateDirective, selectors: [["", "kendoDrawerItemTemplate", ""]] });
DrawerItemTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], DrawerItemTemplateDirective);

/**
 * Represents a template that defines the header content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerHeaderTemplate` directive inside the `<kendo-drawer>` tag.
 */
let DrawerHeaderTemplateDirective = class DrawerHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
DrawerHeaderTemplateDirective.ɵfac = function DrawerHeaderTemplateDirective_Factory(t) { return new (t || DrawerHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerHeaderTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DrawerHeaderTemplateDirective, selectors: [["", "kendoDrawerHeaderTemplate", ""]] });
DrawerHeaderTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], DrawerHeaderTemplateDirective);

/**
 * Represents a template that defines the footer content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerFooterTemplate` directive inside the `<kendo-drawer>` tag.
 */
let DrawerFooterTemplateDirective = class DrawerFooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
DrawerFooterTemplateDirective.ɵfac = function DrawerFooterTemplateDirective_Factory(t) { return new (t || DrawerFooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerFooterTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DrawerFooterTemplateDirective, selectors: [["", "kendoDrawerFooterTemplate", ""]] });
DrawerFooterTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], DrawerFooterTemplateDirective);

/**
 * @hidden
 */
function miniExpandPush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: `${miniWidth}px` }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function miniCollapsePush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${miniWidth}px` }))
    ];
}
/**
 * @hidden
 *
 */
function miniExpandOverlay(duration, width, miniWidth) {
    return [
        style({ width: `${miniWidth}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', width: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function expandPush(duration, width) {
    return [
        style({ overflow: 'hidden', flexBasis: '0px' }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function collapsePush(duration, width) {
    return [
        style({ flexBasis: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', flexBasis: `0px` }))
    ];
}
/**
 * @hidden
 */
function expandRTLOverlay(duration) {
    return [
        style({ transform: `translateX(100%)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(0)` }))
    ];
}
/**
 * @hidden
 */
function expandOverlay(duration, position) {
    const translateDir = position !== 'end' ? `-100%` : `100%`;
    return [
        style({ transform: `translateX(${translateDir})` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(0)` }))
    ];
}
/**
 * @hidden
 */
function miniCollapseOverlay(duration, width, miniWidth) {
    return [
        style({ width: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', width: `${miniWidth}px` }))
    ];
}
/**
 * @hidden
 */
function collapseOverlay(duration, position) {
    const translateDir = position !== 'end' ? '-100%' : '100%';
    return [
        style({ transform: `translateX(0)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(${translateDir})` }))
    ];
}
/**
 * @hidden
 */
function collapseRTLOverlay(duration) {
    return [
        style({ transform: `translateX(0)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(100%)` }))
    ];
}
/**
 * @hidden
 */
function expandAnimation(settings) {
    const duration = settings.animation.duration;
    const width = settings.width;
    const miniWidth = settings.miniWidth;
    const mode = settings.mode;
    const mini = settings.mini;
    const rtl = settings.rtl;
    const position = settings.position;
    if (mini && mode === 'push') {
        return miniExpandPush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return expandPush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? expandRTLOverlay(duration) : expandOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniExpandOverlay(duration, width, miniWidth);
    }
}
/**
 * @hidden
 */
function collapseAnimation(settings) {
    const duration = settings.animation.duration;
    const width = settings.width;
    const miniWidth = settings.miniWidth;
    const mode = settings.mode;
    const mini = settings.mini;
    const rtl = settings.rtl;
    const position = settings.position;
    if (mini && mode === 'push') {
        return miniCollapsePush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return collapsePush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? collapseRTLOverlay(duration) : collapseOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniCollapseOverlay(duration, width, miniWidth);
    }
}

/**
 * Arguments for the `select` event of the Drawer.
 */
class DrawerSelectEvent extends PreventableEvent$1 {
}

/**
 * @hidden
 */
let DrawerService = class DrawerService {
    /**
     * @hidden
     */
    constructor() {
        this.selectedIndices = [];
    }
    emit(event, args) {
        const drawer = this.owner;
        const eventArgs = new DrawerSelectEvent(Object.assign({}, args, { sender: drawer }));
        if (hasObservers(drawer[event])) {
            drawer[event].emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    onSelect(selectedIdx) {
        this.selectedIndices = [selectedIdx];
        const drawer = this.owner;
        if (drawer.autoCollapse && !drawer.minimized) {
            drawer.toggle(false);
        }
    }
    initSelection() {
        const items = this.owner.items;
        this.selectedIndices = [];
        for (let i = 0; i < items.length; i++) {
            if (items[i].selected) {
                this.selectedIndices.push(i);
            }
        }
    }
};
DrawerService.ɵfac = function DrawerService_Factory(t) { return new (t || DrawerService)(); };
DrawerService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DrawerService, factory: function (t) { return DrawerService.ɵfac(t); } });

const DEFAULT_ANIMATION = { type: 'slide', duration: 200 };
/**
 * Represents the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-drawer-container>
 *             <kendo-drawer #drawer
 *                  [items]="items"
 *                  mode="overlay"
 *                  [(expanded)]="expanded">
 *              </kendo-drawer>
 *              <kendo-drawer-content>
 *                  <button class="k-button" (click)="drawer.toggle()">Open the Drawer</button>
 *              </kendo-drawer-content>
 *        </kendo-drawer-container>
 *    `
 * })
 * class AppComponent {
 *    public expanded = false;
 *
 *    public items: any[] = [
 *      { text: 'Inbox', icon: 'k-i-inbox' },
 *      { text: 'Notifications', icon: 'k-i-bell' },
 *      { text: 'Date', icon: 'k-i-calendar' }
 *    ];
 * }
 * ```
 */
let DrawerComponent = class DrawerComponent {
    constructor(element, builder, localizationService, drawerService) {
        this.element = element;
        this.builder = builder;
        this.localizationService = localizationService;
        this.drawerService = drawerService;
        this.hostClasses = true;
        /**
         * Specifies the mode in which the Drawer will be displayed.
         *
         * The possible values are:
         * * (Default) `overlay`
         * * `push`
         */
        this.mode = 'overlay';
        /**
         * Specifies the position of the Drawer
         * ([see example]({% slug positioning_drawer %})).
         *
         * The possible values are:
         * * (Default) `start`
         * * `end`
         */
        this.position = 'start';
        /**
         * Enables the mini (compact) view of the Drawer which is displayed when the component is collapsed
         * ([see example]({% slug expandmodespositions_drawer %}#toc-mini-view)).
         */
        this.mini = false;
        /**
         * Specifies the state of the Drawer.
         */
        this.expanded = false;
        /**
         * Defines the width of the Drawer when it is expanded.
         * Defaults to `240`.
         */
        this.width = 240;
        /**
         * Defines the width of the Drawer when the mini view is enabled
         * and the component is collapsed. Defaults to `60`.
         */
        this.miniWidth = 50;
        /**
         * Specifies if the Drawer will be automatically collapsed when an item
         * or the overlay is clicked. Defaults to `true`.
         */
        this.autoCollapse = true;
        /**
         * Specifies the animation settings of the Drawer.
         * ([see example]({% slug interaction_drawer %}#toc-toggling-between-states)).
         *
         * The possible values are:
         * * Boolean
         *    * (Default) `true`
         *    * `false`
         * * `DrawerAnimation`
         *    * (Default) `type?: 'slide'`
         *    * `duration`&mdash;Accepts a number in milliseconds. Defaults to `300ms`.
         */
        this.animation = DEFAULT_ANIMATION;
        /**
         * Fires when the Drawer is expanded and its animation is complete.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the Drawer is collapsed and its animation is complete.
         */
        this.collapse = new EventEmitter();
        /**
         * Fires when a Drawer item is selected. This event is preventable.
         */
        this.select = new EventEmitter();
        /**
         * Fires when the `expanded` property of the component was updated.
         * Used to provide a two-way binding for the `expanded` property.
         */
        this.expandedChange = new EventEmitter();
        this.animationEnd = new EventEmitter();
        this.rtl = false;
        this._items = [];
        validatePackage(packageMetadata);
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
        this.drawerService.owner = this;
    }
    get startPositionClass() {
        return this.position === 'start';
    }
    get endPositionClass() {
        return this.position === 'end';
    }
    get overlayTransofrmStyles() {
        if (this.mode === 'push') {
            return;
        }
        if (this.expanded || this.minimized) {
            return `translateX(0px)`;
        }
        return `translateX(-100%)`;
    }
    get flexStyles() {
        if (this.mode === 'overlay') {
            return;
        }
        if (!this.expanded && !this.minimized) {
            return 0;
        }
        return this.drawerWidth;
    }
    /**
     * The collection of items that will be rendered in the Drawer.
     */
    set items(items) {
        if (isPresent(items)) {
            this._items = items;
            this.drawerService.initSelection();
        }
    }
    get items() {
        return this._items;
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get minimized() {
        return this.mini && !this.expanded;
    }
    /**
     * @hidden
     */
    get drawerWidth() {
        return this.minimized ? this.miniWidth : this.width;
    }
    /**
     * Toggles the visibility of the Drawer.
     *
     * @param expanded? - Boolean. Specifies if the Drawer will be expanded or collapsed.
     */
    toggle(expanded) {
        const previous = this.expanded;
        const current = isPresent(expanded) ? expanded : !previous;
        if (current === previous) {
            return;
        }
        if (current === true) {
            this.setExpanded(true);
        }
        else if (current === false && !this.animation) {
            this.setExpanded(false);
        }
        if (this.animation) {
            this.animationEnd.pipe(take(1))
                .subscribe(() => { this.onAnimationEnd(current); });
            this.animate(current);
        }
        else {
            this[current ? 'expand' : 'collapse'].emit();
        }
    }
    onAnimationEnd(currentExpanded) {
        if (currentExpanded) {
            this.expand.emit();
        }
        else {
            this.setExpanded(false);
            this.collapse.emit();
        }
    }
    setExpanded(value) {
        this.expanded = value;
        this.expandedChange.emit(value);
    }
    animate(expanded) {
        const settings = {
            mode: this.mode,
            mini: this.mini,
            miniWidth: this.miniWidth,
            width: this.width,
            rtl: this.rtl,
            position: this.position,
            animation: (typeof this.animation !== 'boolean') ? this.animation : DEFAULT_ANIMATION
        };
        const animation = expanded ? expandAnimation(settings) : collapseAnimation(settings);
        const player = this.createPlayer(animation, this.element.nativeElement);
        player.play();
    }
    createPlayer(animation, animatedElement) {
        const factory = this.builder.build(animation);
        let player = factory.create(animatedElement);
        player.onDone(() => {
            if (player) {
                this.animationEnd.emit();
                player.destroy();
                player = null;
            }
        });
        return player;
    }
};
DrawerComponent.ɵfac = function DrawerComponent_Factory(t) { return new (t || DrawerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(DrawerService)); };
DrawerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DrawerComponent, selectors: [["kendo-drawer"]], contentQueries: function DrawerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerFooterTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerHeaderTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerItemTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.drawerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
    } }, hostVars: 13, hostBindings: function DrawerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵstyleProp("transform", ctx.overlayTransofrmStyles)("flex-basis", ctx.flexStyles, "px");
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-drawer", ctx.hostClasses)("k-drawer-start", ctx.startPositionClass)("k-drawer-end", ctx.endPositionClass);
    } }, inputs: { mode: "mode", position: "position", mini: "mini", expanded: "expanded", width: "width", miniWidth: "miniWidth", autoCollapse: "autoCollapse", animation: "animation", items: "items" }, outputs: { expand: "expand", collapse: "collapse", select: "select", expandedChange: "expandedChange" }, exportAs: ["kendoDrawer"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            DrawerService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.drawer'
            }
        ])], decls: 1, vars: 1, consts: [["class", "k-drawer-wrapper", 3, "width", 4, "ngIf"], [1, "k-drawer-wrapper"], [4, "ngIf"], ["kendoDrawerList", "", 1, "k-drawer-items", 3, "items", "mini", "expanded", "itemTemplate"], [3, "ngTemplateOutlet"]], template: function DrawerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_Template, 3, 4, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.expanded || ctx.mini);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, DrawerListComponent]; }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-drawer'),
    __metadata("design:type", Boolean)
], DrawerComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.k-drawer-start'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DrawerComponent.prototype, "startPositionClass", null);
__decorate([
    HostBinding('class.k-drawer-end'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DrawerComponent.prototype, "endPositionClass", null);
__decorate([
    HostBinding('style.transform'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], DrawerComponent.prototype, "overlayTransofrmStyles", null);
__decorate([
    HostBinding('style.flexBasis.px'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], DrawerComponent.prototype, "flexStyles", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], DrawerComponent.prototype, "mode", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DrawerComponent.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DrawerComponent.prototype, "mini", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DrawerComponent.prototype, "expanded", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DrawerComponent.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DrawerComponent.prototype, "miniWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DrawerComponent.prototype, "autoCollapse", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], DrawerComponent.prototype, "items", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], DrawerComponent.prototype, "direction", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DrawerComponent.prototype, "animation", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DrawerComponent.prototype, "expand", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DrawerComponent.prototype, "collapse", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DrawerComponent.prototype, "select", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DrawerComponent.prototype, "expandedChange", void 0);
__decorate([
    ContentChild(DrawerTemplateDirective, { static: false }),
    __metadata("design:type", DrawerTemplateDirective)
], DrawerComponent.prototype, "drawerTemplate", void 0);
__decorate([
    ContentChild(DrawerFooterTemplateDirective, { static: false }),
    __metadata("design:type", DrawerFooterTemplateDirective)
], DrawerComponent.prototype, "footerTemplate", void 0);
__decorate([
    ContentChild(DrawerHeaderTemplateDirective, { static: false }),
    __metadata("design:type", DrawerHeaderTemplateDirective)
], DrawerComponent.prototype, "headerTemplate", void 0);
__decorate([
    ContentChild(DrawerItemTemplateDirective, { static: false }),
    __metadata("design:type", DrawerItemTemplateDirective)
], DrawerComponent.prototype, "itemTemplate", void 0);
DrawerComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        AnimationBuilder,
        LocalizationService,
        DrawerService])
], DrawerComponent);

/**
 * Serves as a container for the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}) and its content.
 */
let DrawerContainerComponent = class DrawerContainerComponent {
    constructor(localizationService) {
        this.localizationService = localizationService;
        this.rtl = false;
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
    }
    get hostClass() {
        return true;
    }
    get overlayClass() {
        return this.drawer.mode === 'overlay';
    }
    get miniClass() {
        return this.drawer.mini;
    }
    get pushClass() {
        return this.drawer.mode === 'push';
    }
    get isExpandedClass() {
        return this.drawer.expanded;
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get overlay() {
        return isPresent(this.drawer) &&
            this.drawer.expanded &&
            this.drawer.mode === 'overlay';
    }
    /**
     * @hidden
     */
    closeDrawer() {
        if (this.overlay && this.drawer.autoCollapse) {
            this.drawer.toggle(false);
        }
    }
};
DrawerContainerComponent.ɵfac = function DrawerContainerComponent_Factory(t) { return new (t || DrawerContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
DrawerContainerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DrawerContainerComponent, selectors: [["kendo-drawer-container"]], contentQueries: function DrawerContainerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.drawer = _t.first);
    } }, hostVars: 11, hostBindings: function DrawerContainerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-drawer-container", ctx.hostClass)("k-drawer-overlay", ctx.overlayClass)("k-drawer-mini", ctx.miniClass)("k-drawer-push", ctx.pushClass)("k-drawer-expanded", ctx.isExpandedClass);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.drawer.container'
            }
        ])], ngContentSelectors: _c9, decls: 2, vars: 1, consts: [["class", "k-overlay", 3, "click", 4, "ngIf"], [1, "k-overlay", 3, "click"]], template: function DrawerContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, DrawerContainerComponent_div_0_Template, 1, 0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.overlay);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
__decorate([
    HostBinding('class.k-drawer-container'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DrawerContainerComponent.prototype, "hostClass", null);
__decorate([
    HostBinding('class.k-drawer-overlay'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DrawerContainerComponent.prototype, "overlayClass", null);
__decorate([
    HostBinding('class.k-drawer-mini'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DrawerContainerComponent.prototype, "miniClass", null);
__decorate([
    HostBinding('class.k-drawer-push'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DrawerContainerComponent.prototype, "pushClass", null);
__decorate([
    HostBinding('class.k-drawer-expanded'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DrawerContainerComponent.prototype, "isExpandedClass", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], DrawerContainerComponent.prototype, "direction", void 0);
__decorate([
    ContentChild(DrawerComponent, { static: false }),
    __metadata("design:type", DrawerComponent)
], DrawerContainerComponent.prototype, "drawer", void 0);
DrawerContainerComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], DrawerContainerComponent);

/**
 * Represents the content of the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).
 */
let DrawerContentComponent = class DrawerContentComponent {
    constructor() {
        this.hostClasses = true;
    }
};
DrawerContentComponent.ɵfac = function DrawerContentComponent_Factory(t) { return new (t || DrawerContentComponent)(); };
DrawerContentComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DrawerContentComponent, selectors: [["kendo-drawer-content"]], hostVars: 2, hostBindings: function DrawerContentComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-drawer-content", ctx.hostClasses);
    } }, ngContentSelectors: _c9, decls: 1, vars: 0, template: function DrawerContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-drawer-content'),
    __metadata("design:type", Boolean)
], DrawerContentComponent.prototype, "hostClasses", void 0);
DrawerContentComponent = __decorate([ __metadata("design:paramtypes", [])
], DrawerContentComponent);

/**
 * Represents a template that defines the content of the whole Step.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperStepTemplate` directive inside the `<kendo-stepper>` tag.
 */
let StepperStepTemplateDirective = class StepperStepTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
StepperStepTemplateDirective.ɵfac = function StepperStepTemplateDirective_Factory(t) { return new (t || StepperStepTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
StepperStepTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: StepperStepTemplateDirective, selectors: [["", "kendoStepperStepTemplate", ""]] });
StepperStepTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], StepperStepTemplateDirective);

/**
 * Represents a template that defines the content of the Step label.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperLabelTemplate` directive inside the `<kendo-stepper>` tag.
 */
let StepperLabelTemplateDirective = class StepperLabelTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
StepperLabelTemplateDirective.ɵfac = function StepperLabelTemplateDirective_Factory(t) { return new (t || StepperLabelTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
StepperLabelTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: StepperLabelTemplateDirective, selectors: [["", "kendoStepperLabelTemplate", ""]] });
StepperLabelTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], StepperLabelTemplateDirective);

/**
 * Represents a template that defines the content of the Step indicator.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperIndicatorTemplate` directive inside the `<kendo-stepper>` tag.
 */
let StepperIndicatorTemplateDirective = class StepperIndicatorTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
StepperIndicatorTemplateDirective.ɵfac = function StepperIndicatorTemplateDirective_Factory(t) { return new (t || StepperIndicatorTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
StepperIndicatorTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: StepperIndicatorTemplateDirective, selectors: [["", "kendoStepperIndicatorTemplate", ""]] });
StepperIndicatorTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], StepperIndicatorTemplateDirective);

/**
 * Arguments for the `activate` event of the Stepper.
 */
class StepperActivateEvent extends PreventableEvent$1 {
}

const DEFAULT_CURRENT_STEP = 0;
const handlers = {};
handlers[Keys.ArrowLeft] = 'left';
handlers[Keys.ArrowRight] = 'right';
handlers[Keys.ArrowUp] = 'up';
handlers[Keys.ArrowDown] = 'down';
handlers[Keys.Home] = 'home';
handlers[Keys.End] = 'end';
handlers[Keys.Enter] = 'enter';
handlers[Keys.Space] = 'enter';
const handlersRTL = Object.assign({}, handlers);
handlersRTL[Keys.ArrowLeft] = 'right';
handlersRTL[Keys.ArrowRight] = 'left';
/**
 * @hidden
 */
let StepperService = class StepperService {
    constructor(localization, ngZone, changeDetector) {
        this.localization = localization;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.currentStep = DEFAULT_CURRENT_STEP;
        this.triggerValidation = new EventEmitter();
        this.focusedStepChange = new EventEmitter();
    }
    get handlers() {
        return this.localization.rtl ? handlersRTL : handlers;
    }
    emit(event, eventArgs) {
        const stepper = this.owner;
        if (hasObservers(stepper[event])) {
            stepper[event].emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    onActivate(currentIdx, originalEvent) {
        const eventArgs = new StepperActivateEvent({
            index: currentIdx,
            step: this.owner.steps[currentIdx],
            originalEvent: originalEvent,
            sender: this.owner
        });
        this.ngZone.run(() => {
            if (!this.emit('activate', eventArgs)) {
                this.currentStep = currentIdx;
                this.owner['currentStepChange'].emit(currentIdx);
                this.changeDetector.detectChanges();
            }
        });
    }
    validateSteps() {
        this.triggerValidation.emit();
    }
    keydown(e) {
        const current = this.focusedStep || this.currentStep;
        const handler = this.handlers[e.keyCode];
        if (!isPresent(current)) {
            return;
        }
        if (handler) {
            e.preventDefault();
            this[handler](e);
        }
    }
    left() {
        if (!this.isHorizontal) {
            return;
        }
        this.focusPrevStep();
    }
    right() {
        if (!this.isHorizontal) {
            return;
        }
        this.focusNextStep();
    }
    up() {
        if (this.isHorizontal) {
            return;
        }
        this.focusPrevStep();
    }
    down() {
        if (this.isHorizontal) {
            return;
        }
        this.focusNextStep();
    }
    home() {
        this.focusedStep = 0;
        this.focusedStepChange.emit();
    }
    end() {
        this.focusedStep = this.owner.steps.length - 1;
        this.focusedStepChange.emit();
    }
    enter(event) {
        if (this.focusedStep === this.currentStep) {
            return;
        }
        if (this.isStepDisabled(this.focusedStep)) {
            return;
        }
        if (this.owner.linear && this.isPrevOrNextStep(this.focusedStep) === false) {
            return;
        }
        this.onActivate(this.focusedStep, event);
    }
    focus(focusedIdx) {
        this.focusedStep = focusedIdx;
    }
    focusNextStep() {
        if (this.focusedStep < this.owner.steps.length) {
            this.focusedStep += 1;
            this.focusedStepChange.emit();
        }
    }
    focusPrevStep() {
        if (this.focusedStep > 0) {
            this.focusedStep -= 1;
            this.focusedStepChange.emit();
        }
    }
    isStepDisabled(index) {
        return this.owner.steps[index].disabled;
    }
    isPrevOrNextStep(index) {
        return index === this.currentStep + 1 || index === this.currentStep - 1;
    }
    get isHorizontal() {
        return this.owner.orientation === 'horizontal';
    }
};
StepperService.ɵfac = function StepperService_Factory(t) { return new (t || StepperService)(ɵngcc0.ɵɵinject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.ChangeDetectorRef)); };
StepperService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: StepperService, factory: function (t) { return StepperService.ɵfac(t); } });
StepperService = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        NgZone,
        ChangeDetectorRef])
], StepperService);

const DEFAULT_ANIMATION_DURATION = 400;
/**
 * Represents the [Kendo UI Stepper component for Angular]({% slug overview_stepper %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-stepper [steps]="steps">
 *        </kendo-stepper>
 *    `
 * })
 * class AppComponent {
 *    public steps: Array<StepperStep> = [
 *      { label: 'Step One' }, { label: 'Step Two' }, { label: 'Step Three' }
 *    ];
 * }
 * ```
 */
let StepperComponent = class StepperComponent {
    constructor(renderer, elem, localization, stepperService) {
        this.renderer = renderer;
        this.elem = elem;
        this.localization = localization;
        this.stepperService = stepperService;
        this.hostClasses = true;
        this.ariaRole = 'navigation';
        this.displayStyle = 'grid';
        /**
         * Specifies the type of the steps in the Stepper.
         *
         * The possible values are:
         * * (Default) `indicator`
         * * `label`
         * * `full`
         */
        this.stepType = 'indicator';
        /**
         * Specifies the linear flow of the Stepper.
         *
         * @default true
         */
        this.linear = true;
        /**
         * Specifies the orientation of the Stepper
         * ([see example]({% slug orientation_stepper %})).
         *
         * The possible values are:
         * * (Default) `horizontal`
         * * `vertical`
         */
        this.orientation = 'horizontal';
        /**
         * Specifies the duration of the progress indicator animation in milliseconds. Defaults to `400ms`.
         *
         * The possible values are:
         *  * Boolean
         *    * (Default) `true`
         *    * false
         *  * Number
         */
        this.animation = true;
        /**
         * Fires when a step is about to be activated. This event is preventable.
         */
        this.activate = new EventEmitter();
        /**
         * Fires when the `currentStep` property of the component was updated.
         * Used to provide a two-way binding for the `currentStep` property.
         */
        this.currentStepChange = new EventEmitter();
        this._steps = [];
        this.dynamicRTLSubscription = this.localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.stepperService.owner = this;
    }
    get linearClass() {
        return this.linear;
    }
    /**
     * The index of the current step.
     */
    set currentStep(value) {
        this.stepperService.currentStep = value;
    }
    get currentStep() {
        return this.stepperService.currentStep;
    }
    /**
     * The collection of steps that will be rendered in the Stepper.
     * ([see example]({% slug step_appearance_stepper %}))
     */
    set steps(steps) {
        if (isPresent(steps) && steps.length > 0) {
            this._steps = steps;
        }
    }
    get steps() {
        return this._steps;
    }
    ngOnInit() {
        this.applyHostStyling();
    }
    ngOnChanges(changes) {
        if (changes.steps && !changes.steps.firstChange) {
            this.applyHostStyling();
        }
        if (changes.orientation) {
            this.resetHostStyling();
            this.applyHostStyling();
        }
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * Manually triggers the validity check configured by the [isValid]({% slug api_layout_stepperstep %}#toc-isvalid) property of the steps ([see example]({% slug step_validation_stepper %}#toc-triggering-the-validation)).
     *
     * Steps that have their [validate]({% slug api_layout_stepperstep %}#toc-validate) property set to `false`, will not be validated.
     */
    validateSteps() {
        this.stepperService.validateSteps();
    }
    applyHostStyling() {
        const stepFramesStyle = this.orientation === 'horizontal' ? 'grid-template-columns' : 'grid-template-rows';
        const stepFramesValue = `repeat(${this.steps.length * 2}, 1fr)`;
        this.renderer.setStyle(this.elem.nativeElement, stepFramesStyle, stepFramesValue);
    }
    resetHostStyling() {
        this.renderer.removeStyle(this.elem.nativeElement, 'grid-template-columns');
        this.renderer.removeStyle(this.elem.nativeElement, 'grid-template-rows');
    }
    /**
     * @hidden
     */
    get progressAnimation() {
        return { duration: this.animationDuration };
    }
    /**
     * @hidden
     */
    get animationDuration() {
        if (typeof this.animation === 'number') {
            return this.animation;
        }
        if (typeof this.animation === 'boolean' && this.animation) {
            return DEFAULT_ANIMATION_DURATION;
        }
        return 0;
    }
    /**
     * @hidden
     */
    get stepsListStyling() {
        if (this.orientation === 'horizontal') {
            return { 'grid-column-start': 1, 'grid-column-end': -1 };
        }
        return { 'grid-row-start': 1, 'grid-row-end': -1 };
    }
    /**
     * @hidden
     */
    get progressBarStyling() {
        if (this.orientation === 'horizontal') {
            return {
                'grid-column-start': 2,
                'grid-column-end': this.steps.length * 2
            };
        }
        return {
            'grid-row-start': 2,
            'grid-row-end': this.steps.length * 2
        };
    }
    /***
     * @hidden
     */
    get isHorizontal() {
        return this.stepperService.isHorizontal;
    }
};
StepperComponent.ɵfac = function StepperComponent_Factory(t) { return new (t || StepperComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(StepperService)); };
StepperComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: StepperComponent, selectors: [["kendo-stepper"]], contentQueries: function StepperComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, StepperStepTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, StepperLabelTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, StepperIndicatorTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indicatorTemplate = _t.first);
    } }, hostVars: 10, hostBindings: function StepperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.ariaRole)("dir", ctx.direction);
        ɵngcc0.ɵɵstyleProp("display", ctx.displayStyle);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-stepper", ctx.hostClasses)("k-stepper-linear", ctx.linearClass);
    } }, inputs: { stepType: "stepType", linear: "linear", orientation: "orientation", animation: "animation", currentStep: "currentStep", steps: "steps", successIcon: "successIcon", errorIcon: "errorIcon" }, outputs: { activate: "activate", currentStepChange: "currentStepChange" }, exportAs: ["kendoStepper"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            StepperService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.stepper'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 16, consts: function () { let i18n_19; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The text for the optional segment of the step label
         * @meaning kendo.stepper.optional
         */
        const MSG_EXTERNAL_9222129954657106830$$DIST_FESM2015_INDEX_JS_20 = goog.getMsg("Optional");
        i18n_19 = MSG_EXTERNAL_9222129954657106830$$DIST_FESM2015_INDEX_JS_20;
    }
    else {
        i18n_19 = $localize `:kendo.stepper.optional|The text for the optional segment of the step label␟5662ca90a1b7d36b2f55d6e21c0f4f7e166291af␟9222129954657106830:Optional`;
    } return [["kendoStepperLocalizedMessages", "", "optional", i18n_19], ["kendoStepperList", "", 1, "k-step-list", 3, "stepType", "linear", "orientation", "steps", "currentStep", "successIcon", "errorIcon", "indicatorTemplate", "labelTemplate", "stepTemplate", "ngStyle"], [3, "animation", "max", "label", "orientation", "reverse", "value", "ngStyle", 4, "ngIf"], [3, "animation", "max", "label", "orientation", "reverse", "value", "ngStyle"]]; }, template: function StepperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelement(1, "ol", 1);
        ɵngcc0.ɵɵtemplate(2, StepperComponent_kendo_progressbar_2_Template, 1, 8, "kendo-progressbar", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("k-step-list-horizontal", ctx.isHorizontal)("k-step-list-vertical", !ctx.isHorizontal);
        ɵngcc0.ɵɵproperty("stepType", ctx.stepType)("linear", ctx.linear)("orientation", ctx.orientation)("steps", ctx.steps)("currentStep", ctx.currentStep)("successIcon", ctx.successIcon)("errorIcon", ctx.errorIcon)("indicatorTemplate", ctx.indicatorTemplate == null ? null : ctx.indicatorTemplate.templateRef)("labelTemplate", ctx.labelTemplate == null ? null : ctx.labelTemplate.templateRef)("stepTemplate", ctx.stepTemplate == null ? null : ctx.stepTemplate.templateRef)("ngStyle", ctx.stepsListStyling);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.steps.length > 0);
    } }, directives: function () { return [LocalizedStepperMessagesDirective, StepperListComponent, ɵngcc1.NgStyle, ɵngcc1.NgIf, ɵngcc5.ProgressBarComponent]; }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-stepper'),
    __metadata("design:type", Boolean)
], StepperComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.k-stepper-linear'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], StepperComponent.prototype, "linearClass", null);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String)
], StepperComponent.prototype, "ariaRole", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], StepperComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('style.display'),
    __metadata("design:type", String)
], StepperComponent.prototype, "displayStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperComponent.prototype, "stepType", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], StepperComponent.prototype, "linear", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperComponent.prototype, "orientation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], StepperComponent.prototype, "currentStep", null);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], StepperComponent.prototype, "steps", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperComponent.prototype, "successIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperComponent.prototype, "errorIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], StepperComponent.prototype, "animation", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], StepperComponent.prototype, "activate", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], StepperComponent.prototype, "currentStepChange", void 0);
__decorate([
    ContentChild(StepperStepTemplateDirective, { static: false }),
    __metadata("design:type", StepperStepTemplateDirective)
], StepperComponent.prototype, "stepTemplate", void 0);
__decorate([
    ContentChild(StepperLabelTemplateDirective, { static: false }),
    __metadata("design:type", StepperLabelTemplateDirective)
], StepperComponent.prototype, "labelTemplate", void 0);
__decorate([
    ContentChild(StepperIndicatorTemplateDirective, { static: false }),
    __metadata("design:type", StepperIndicatorTemplateDirective)
], StepperComponent.prototype, "indicatorTemplate", void 0);
StepperComponent = __decorate([ __metadata("design:paramtypes", [Renderer2,
        ElementRef,
        LocalizationService,
        StepperService])
], StepperComponent);

/**
 * @hidden
 */
class StepperMessages extends ComponentMessages {
}
StepperMessages.ɵfac = /*@__PURE__*/ function () { let ɵStepperMessages_BaseFactory; return function StepperMessages_Factory(t) { return (ɵStepperMessages_BaseFactory || (ɵStepperMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(StepperMessages)))(t || StepperMessages); }; }();
StepperMessages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: StepperMessages, inputs: { optional: "optional" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperMessages.prototype, "optional", void 0);

var StepperCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages
 * ([see example]({% slug rtl_layout %})).
 */
let StepperCustomMessagesComponent = StepperCustomMessagesComponent_1 = class StepperCustomMessagesComponent extends StepperMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
StepperCustomMessagesComponent.ɵfac = function StepperCustomMessagesComponent_Factory(t) { return new (t || StepperCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
StepperCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: StepperCustomMessagesComponent, selectors: [["kendo-stepper-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: StepperMessages,
                useExisting: forwardRef(() => StepperCustomMessagesComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function StepperCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
StepperCustomMessagesComponent = StepperCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], StepperCustomMessagesComponent);

var LocalizedStepperMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedStepperMessagesDirective = LocalizedStepperMessagesDirective_1 = class LocalizedStepperMessagesDirective extends StepperMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
LocalizedStepperMessagesDirective.ɵfac = function LocalizedStepperMessagesDirective_Factory(t) { return new (t || LocalizedStepperMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
LocalizedStepperMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LocalizedStepperMessagesDirective, selectors: [["", "kendoStepperLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: StepperMessages,
                useExisting: forwardRef(() => LocalizedStepperMessagesDirective_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
LocalizedStepperMessagesDirective = LocalizedStepperMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LocalizedStepperMessagesDirective);

/**
 * Displays images, icons or initials representing people or other entities.
 */
let AvatarComponent = class AvatarComponent {
    constructor(renderer, element) {
        this.renderer = renderer;
        this.element = element;
        this.hostClass = true;
        /**
         * Sets a border to the avatar.
         */
        this.border = false;
        this._themeColor = 'primary';
        this._size = 'medium';
        this._fillMode = 'solid';
        this._rounded = 'full';
        validatePackage(packageMetadata);
    }
    /**
     * @hidden
     */
    get borderClass() {
        return this.border;
    }
    /**
     * @hidden
     */
    get flexBasis() {
        return this.width;
    }
    /**
     * Sets the shape for the avatar.
     * @hidden
     */
    set shape(shape) {
        this.rounded = mapShapeToRounded(shape);
    }
    /**
     * Specifies the size of the avatar
     * ([see example]({% slug appearance_avatar %}#toc-size)).
     *
     * The possible values are:
     * * `small`
     * * `medium` (Default)
     * * `large`
     *
     */
    set size(size) {
        if (size !== this._size) {
            this.handleClasses('size', size);
            this._size = size === null ? null : size || 'medium';
        }
    }
    get size() {
        return this._size;
    }
    /**
     * Specifies the rounded styling of the avatar
     * ([see example]({% slug appearance_avatar %}#toc-rounded-corners)).
     *
     * The possible values are:
     * * `small`
     * * `medium`
     * * `large`
     * * `full` (Default)
     * * null
     *
     */
    set rounded(rounded) {
        if (rounded !== this._rounded) {
            this.handleClasses('rounded', rounded);
            this._rounded = rounded === null ? null : rounded || 'full';
        }
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * Specifies the theme color of the avatar.
     * The theme color will be applied as background and border color, while also amending the text color accordingly.
     *
     * The possible values are:
     * * `base`&mdash; Applies the base coloring value.
     * * `primary` (Default)&mdash;Applies coloring based on primary theme color.
     * * `secondary`&mdash;Applies coloring based on secondary theme color.
     * * `tertiary`&mdash; Applies coloring based on tertiary theme color.
     * * `info`&mdash;Applies coloring based on info theme color.
     * * `success`&mdash; Applies coloring based on success theme color.
     * * `warning`&mdash; Applies coloring based on warning theme color.
     * * `error`&mdash; Applies coloring based on error theme color.
     * * `dark`&mdash; Applies coloring based on dark theme color.
     * * `light`&mdash; Applies coloring based on light theme color.
     * * `inverse`&mdash; Applies coloring based on inverted theme color.
     */
    set themeColor(themeColor) {
        if (themeColor !== this._themeColor) {
            this._themeColor = themeColor === null ? null : (themeColor || 'primary');
            this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
        }
    }
    get themeColor() {
        return this._themeColor;
    }
    /**
     * Specifies the appearance fill style of the avatar.
     *
     * The possible values are:
     * * `solid` (Default)
     * * `outline`
     * * null
     *
     */
    set fillMode(fillMode) {
        if (fillMode !== this.fillMode) {
            this._fillMode = fillMode === null ? null : (fillMode || 'solid');
            this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
        }
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * Specifies the appearance fill style of the avatar.
     * Deprecated, left for backward compatibility.
     *
     * @hidden
     */
    set fill(fillMode) {
        this.fillMode = fillMode;
    }
    /**
     * @hidden
     */
    get avatarWidth() {
        return this.width;
    }
    /**
     * @hidden
     */
    get avatarHeight() {
        return this.height;
    }
    ngOnInit() {
        this.verifyProperties();
    }
    ngAfterViewInit() {
        const stylingInputs = ['size', 'rounded'];
        stylingInputs.forEach(input => {
            this.handleClasses(input, this[input]);
        });
        this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
    }
    /**
     * @hidden
     */
    iconClasses() {
        if (this.icon) {
            return `k-icon k-i-${this.icon}`;
        }
        if (this.iconClass) {
            return `${this.iconClass}`;
        }
    }
    /**
     * @hidden
     */
    get customAvatar() {
        return !(this.imageSrc || this.initials || this.icon || this.iconClass);
    }
    verifyProperties() {
        if (!isDevMode()) {
            return;
        }
        const inputs = [this.icon || this.iconClass, this.imageSrc, this.initials];
        const inputsLength = inputs.filter((value) => value).length;
        if (inputsLength > 1) {
            throw new Error(`
                Invalid property configuration given.
                The kendo-avatar component can accept only one of:
                icon, imageSrc or initials properties.
            `);
        }
    }
    handleClasses(styleType, value) {
        const elem = this.element.nativeElement;
        const classes = getStylingClasses('avatar', styleType, this[styleType], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
    handleFillModeAndThemeColorClasses(fill, themeColor) {
        const wrapperElement = this.element.nativeElement;
        // remove existing fill and theme color classes
        const currentClasses = Array.from(wrapperElement.classList);
        const classesToRemove = currentClasses.filter(cl => {
            return cl.startsWith('k-avatar-solid') || cl.startsWith('k-avatar-outline');
        });
        classesToRemove.forEach((cl => this.renderer.removeClass(wrapperElement, cl)));
        // add fill if needed
        if (fill !== null) {
            this.renderer.addClass(wrapperElement, `k-avatar-${fill}`);
        }
        // add theme color class if fill and theme color
        if (fill !== null && themeColor !== null) {
            this.renderer.addClass(wrapperElement, `k-avatar-${fill}-${themeColor}`);
        }
    }
};
AvatarComponent.ɵfac = function AvatarComponent_Factory(t) { return new (t || AvatarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvatarComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AvatarComponent, selectors: [["kendo-avatar"]], hostVars: 10, hostBindings: function AvatarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("flex-basis", ctx.flexBasis)("width", ctx.avatarWidth)("height", ctx.avatarHeight);
        ɵngcc0.ɵɵclassProp("k-avatar", ctx.hostClass)("k-avatar-bordered", ctx.borderClass);
    } }, inputs: { border: "border", shape: "shape", rounded: "rounded", size: "size", themeColor: "themeColor", fillMode: "fillMode", fill: "fill", iconClass: "iconClass", width: "width", height: "height", cssStyle: "cssStyle", initials: "initials", icon: "icon", imageSrc: "imageSrc" }, ngContentSelectors: _c9, decls: 4, vars: 4, consts: [[4, "ngIf"], [1, "k-avatar-image"], [3, "src", "ngStyle"], [1, "k-avatar-text", 3, "ngStyle"], [1, "k-avatar-icon", 3, "ngStyle", "ngClass"]], template: function AvatarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, AvatarComponent_ng_content_0_Template, 1, 0, "ng-content", 0);
        ɵngcc0.ɵɵtemplate(1, AvatarComponent_ng_container_1_Template, 3, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, AvatarComponent_ng_container_2_Template, 3, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(3, AvatarComponent_ng_container_3_Template, 2, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.customAvatar);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.imageSrc);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.initials);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon || ctx.iconClass);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgStyle, ɵngcc1.NgClass], encapsulation: 2 });
__decorate([
    HostBinding('class.k-avatar'),
    __metadata("design:type", Boolean)
], AvatarComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('class.k-avatar-bordered'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], AvatarComponent.prototype, "borderClass", null);
__decorate([
    HostBinding('style.flexBasis'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], AvatarComponent.prototype, "flexBasis", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], AvatarComponent.prototype, "shape", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], AvatarComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], AvatarComponent.prototype, "rounded", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], AvatarComponent.prototype, "themeColor", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], AvatarComponent.prototype, "fillMode", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], AvatarComponent.prototype, "fill", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AvatarComponent.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AvatarComponent.prototype, "iconClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AvatarComponent.prototype, "width", void 0);
__decorate([
    HostBinding('style.width'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], AvatarComponent.prototype, "avatarWidth", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], AvatarComponent.prototype, "height", void 0);
__decorate([
    HostBinding('style.height'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], AvatarComponent.prototype, "avatarHeight", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AvatarComponent.prototype, "cssStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AvatarComponent.prototype, "initials", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AvatarComponent.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AvatarComponent.prototype, "imageSrc", void 0);
AvatarComponent = __decorate([ __metadata("design:paramtypes", [Renderer2, ElementRef])
], AvatarComponent);

/**
 * Represents the [Kendo UI Card component for Angular]({% slug overview_card %})
 */
let CardComponent = class CardComponent {
    constructor(localizationService) {
        this.localizationService = localizationService;
        this.hostClass = true;
        /**
         * Specifies the layout of the Card content.
         *
         * The possible values are:
         * * (Default) `vertical`
         * * `horizontal`
         *
         */
        this.orientation = 'vertical';
        /**
         * Defines the width of the Card.
         * Defaults to `285px`.
         */
        this.width = '285px';
        this.rtl = false;
        validatePackage(packageMetadata);
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
    }
    get widthStyle() {
        return this.width;
    }
    get vertical() {
        return this.orientation === 'vertical';
    }
    get horizontal() {
        return this.orientation === 'horizontal';
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
};
CardComponent.ɵfac = function CardComponent_Factory(t) { return new (t || CardComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
CardComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CardComponent, selectors: [["kendo-card"]], hostVars: 11, hostBindings: function CardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵstyleProp("width", ctx.widthStyle);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClass)("k-card", ctx.hostClass)("k-card-vertical", ctx.vertical)("k-card-horizontal", ctx.horizontal);
    } }, inputs: { orientation: "orientation", width: "width" }, features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.card.component'
            }
        ])], ngContentSelectors: _c9, decls: 1, vars: 0, template: function CardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-card'),
    __metadata("design:type", Boolean)
], CardComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('style.width'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], CardComponent.prototype, "widthStyle", null);
__decorate([
    HostBinding('class.k-card-vertical'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CardComponent.prototype, "vertical", null);
__decorate([
    HostBinding('class.k-card-horizontal'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CardComponent.prototype, "horizontal", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], CardComponent.prototype, "direction", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CardComponent.prototype, "orientation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CardComponent.prototype, "width", void 0);
CardComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], CardComponent);

/**
 * Specifies the content in the Card header.
 */
let CardHeaderComponent = class CardHeaderComponent {
    /**
     * Specifies the content in the Card header.
     */
    constructor() {
        this.hostClass = true;
    }
};
CardHeaderComponent.ɵfac = function CardHeaderComponent_Factory(t) { return new (t || CardHeaderComponent)(); };
CardHeaderComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CardHeaderComponent, selectors: [["kendo-card-header"]], hostVars: 2, hostBindings: function CardHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-header", ctx.hostClass);
    } }, ngContentSelectors: _c9, decls: 1, vars: 0, template: function CardHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-card-header'),
    __metadata("design:type", Boolean)
], CardHeaderComponent.prototype, "hostClass", void 0);

/**
 * Specifies the content in the Card body.
 */
let CardBodyComponent = class CardBodyComponent {
    /**
     * Specifies the content in the Card body.
     */
    constructor() {
        this.hostClass = true;
    }
};
CardBodyComponent.ɵfac = function CardBodyComponent_Factory(t) { return new (t || CardBodyComponent)(); };
CardBodyComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CardBodyComponent, selectors: [["kendo-card-body"]], hostVars: 2, hostBindings: function CardBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-body", ctx.hostClass);
    } }, ngContentSelectors: _c9, decls: 1, vars: 0, template: function CardBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-card-body'),
    __metadata("design:type", Boolean)
], CardBodyComponent.prototype, "hostClass", void 0);

/**
 * Specifies the content in the Card footer.
 */
let CardFooterComponent = class CardFooterComponent {
    /**
     * Specifies the content in the Card footer.
     */
    constructor() {
        this.hostClass = true;
    }
};
CardFooterComponent.ɵfac = function CardFooterComponent_Factory(t) { return new (t || CardFooterComponent)(); };
CardFooterComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CardFooterComponent, selectors: [["kendo-card-footer"]], hostVars: 2, hostBindings: function CardFooterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-footer", ctx.hostClass);
    } }, ngContentSelectors: _c9, decls: 1, vars: 0, template: function CardFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-card-footer'),
    __metadata("design:type", Boolean)
], CardFooterComponent.prototype, "hostClass", void 0);

/**
 * Specifies the action buttons of the Card.
 * * ([see example]({% slug actions_card %})).
 */
let CardActionsComponent = class CardActionsComponent {
    /**
     * Specifies the action buttons of the Card.
     * * ([see example]({% slug actions_card %})).
     */
    constructor() {
        this.hostClass = true;
        /**
         * Specifies the layout of the Card action buttons.
         *
         * * The possible values are:
         * * (Default) `horizontal`
         * * `vertical`
         *
         */
        this.orientation = 'horizontal';
        /**
         * Specifies the layout of the Card action buttons.
         *
         * The possible values are:
         * * (Default) `start`
         * * `center`
         * * `end`
         * * `stretched`
         *
         */
        this.layout = 'start';
        /**
         * Fires when the user clicks an action button.
         */
        this.action = new EventEmitter();
    }
    get stretchedClass() {
        return this.layout === 'stretched';
    }
    get startClass() {
        return this.layout === 'start';
    }
    get endClass() {
        return this.layout === 'end';
    }
    get centerClass() {
        return this.layout === 'center';
    }
    get verticalClass() {
        return this.orientation === 'vertical';
    }
    get horizontalClass() {
        return this.orientation === 'horizontal';
    }
    /**
     * @hidden
     */
    onClick(action) {
        this.action.emit(action);
    }
    /**
     * @hidden
     */
    actionTemplate() {
        return this.actions instanceof TemplateRef;
    }
};
CardActionsComponent.ɵfac = function CardActionsComponent_Factory(t) { return new (t || CardActionsComponent)(); };
CardActionsComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CardActionsComponent, selectors: [["kendo-card-actions"]], hostVars: 14, hostBindings: function CardActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-actions", ctx.hostClass)("k-card-actions-stretched", ctx.stretchedClass)("k-card-actions-start", ctx.startClass)("k-card-actions-end", ctx.endClass)("k-card-actions-center", ctx.centerClass)("k-card-actions-vertical", ctx.verticalClass)("k-card-actions-horizontal", ctx.horizontalClass);
    } }, inputs: { orientation: "orientation", layout: "layout", actions: "actions" }, outputs: { action: "action" }, ngContentSelectors: _c9, decls: 3, vars: 3, consts: [[4, "ngIf"], ["type", "button", "class", "k-button", 3, "k-primary", "k-flat", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "k-button", 3, "click"], [3, "ngTemplateOutlet"]], template: function CardActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, CardActionsComponent_ng_content_0_Template, 1, 0, "ng-content", 0);
        ɵngcc0.ɵɵtemplate(1, CardActionsComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, CardActionsComponent_2_Template, 1, 1, null, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.actions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.actionTemplate());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.actionTemplate());
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
__decorate([
    HostBinding('class.k-card-actions'),
    __metadata("design:type", Boolean)
], CardActionsComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('class.k-card-actions-stretched'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CardActionsComponent.prototype, "stretchedClass", null);
__decorate([
    HostBinding('class.k-card-actions-start'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CardActionsComponent.prototype, "startClass", null);
__decorate([
    HostBinding('class.k-card-actions-end'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CardActionsComponent.prototype, "endClass", null);
__decorate([
    HostBinding('class.k-card-actions-center'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CardActionsComponent.prototype, "centerClass", null);
__decorate([
    HostBinding('class.k-card-actions-vertical'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CardActionsComponent.prototype, "verticalClass", null);
__decorate([
    HostBinding('class.k-card-actions-horizontal'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CardActionsComponent.prototype, "horizontalClass", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], CardActionsComponent.prototype, "orientation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CardActionsComponent.prototype, "layout", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CardActionsComponent.prototype, "actions", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], CardActionsComponent.prototype, "action", void 0);

/**
 * Specifies a separator in the content of the Card.
 */
let CardSeparatorDirective = class CardSeparatorDirective {
    /**
     * Specifies a separator in the content of the Card.
     */
    constructor() {
        this.hostClass = true;
        /**
         * Specifies the orientation of the Card separator.
         *
         * The possible values are:
         * (Default) `horizontal`
         * `vertical`
         */
        this.orientation = 'horizontal';
    }
    get verticalClass() {
        return this.orientation === 'vertical';
    }
    get horizontalClass() {
        return this.orientation === 'horizontal';
    }
};
CardSeparatorDirective.ɵfac = function CardSeparatorDirective_Factory(t) { return new (t || CardSeparatorDirective)(); };
CardSeparatorDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CardSeparatorDirective, selectors: [["", "kendoCardSeparator", ""]], hostVars: 8, hostBindings: function CardSeparatorDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("color", ctx.color);
        ɵngcc0.ɵɵclassProp("k-card-separator", ctx.hostClass)("k-separator-vertical", ctx.verticalClass)("k-separator-horizontal", ctx.horizontalClass);
    } }, inputs: { orientation: "orientation", color: "color" } });
__decorate([
    HostBinding('class.k-card-separator'),
    __metadata("design:type", Boolean)
], CardSeparatorDirective.prototype, "hostClass", void 0);
__decorate([
    HostBinding('class.k-separator-vertical'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CardSeparatorDirective.prototype, "verticalClass", null);
__decorate([
    HostBinding('class.k-separator-horizontal'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CardSeparatorDirective.prototype, "horizontalClass", null);
__decorate([
    HostBinding('style.color'),
    Input(),
    __metadata("design:type", String)
], CardSeparatorDirective.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CardSeparatorDirective.prototype, "orientation", void 0);

/**
 * Specifies the text and styles for the title of the Card.
 */
let CardTitleDirective = class CardTitleDirective {
    /**
     * Specifies the text and styles for the title of the Card.
     */
    constructor() {
        this.hostClass = true;
    }
};
CardTitleDirective.ɵfac = function CardTitleDirective_Factory(t) { return new (t || CardTitleDirective)(); };
CardTitleDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CardTitleDirective, selectors: [["", "kendoCardTitle", ""]], hostVars: 2, hostBindings: function CardTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-title", ctx.hostClass);
    } } });
__decorate([
    HostBinding('class.k-card-title'),
    __metadata("design:type", Boolean)
], CardTitleDirective.prototype, "hostClass", void 0);

/**
 * Specifies the text and styles for the subtitle of the Card.
 */
let CardSubtitleDirective = class CardSubtitleDirective {
    /**
     * Specifies the text and styles for the subtitle of the Card.
     */
    constructor() {
        this.hostClass = true;
    }
};
CardSubtitleDirective.ɵfac = function CardSubtitleDirective_Factory(t) { return new (t || CardSubtitleDirective)(); };
CardSubtitleDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CardSubtitleDirective, selectors: [["", "kendoCardSubtitle", ""]], hostVars: 2, hostBindings: function CardSubtitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-subtitle", ctx.hostClass);
    } } });
__decorate([
    HostBinding('class.k-card-subtitle'),
    __metadata("design:type", Boolean)
], CardSubtitleDirective.prototype, "hostClass", void 0);

/**
 * Specifies any media that will be displayed and aligned in the Card.
 */
let CardMediaDirective = class CardMediaDirective {
    /**
     * Specifies any media that will be displayed and aligned in the Card.
     */
    constructor() {
        this.hostClass = true;
    }
};
CardMediaDirective.ɵfac = function CardMediaDirective_Factory(t) { return new (t || CardMediaDirective)(); };
CardMediaDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CardMediaDirective, selectors: [["", "kendoCardMedia", ""]], hostVars: 2, hostBindings: function CardMediaDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-media", ctx.hostClass);
    } } });
__decorate([
    HostBinding('class.k-card-media'),
    __metadata("design:type", Boolean)
], CardMediaDirective.prototype, "hostClass", void 0);

/**
 * The settings of the Card action buttons.
 */
class CardAction {
}

/**
 * Represents a template that defines the content of the ExpansionPanel title.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoExpansionPanelTitleDirective` directive inside the `<kendo-expansionpanel>` tag.
 * ([see example]({% slug title_expansionpanel %}#toc-title-template)).
 */
let ExpansionPanelTitleDirective = class ExpansionPanelTitleDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
ExpansionPanelTitleDirective.ɵfac = function ExpansionPanelTitleDirective_Factory(t) { return new (t || ExpansionPanelTitleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ExpansionPanelTitleDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ExpansionPanelTitleDirective, selectors: [["", "kendoExpansionPanelTitleDirective", ""]] });
ExpansionPanelTitleDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], ExpansionPanelTitleDirective);

/**
 * @hidden
 */
function expand(duration, height) {
    return [
        style({ overflow: 'hidden', display: 'block', height: 0 }),
        animate(`${duration}ms ease-in`, style({ height: `${height}` }))
    ];
}
/**
 * @hidden
 */
function collapse(duration, height) {
    return [
        style({ overflow: 'hidden', height: `${height}` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', height: 0 }))
    ];
}

/**
 * Arguments for the `action` event of the ExpansionPanel.
 */
class ExpansionPanelActionEvent extends PreventableEvent$1 {
}

const DEFAULT_DURATION = 200;
const CONTENT_HIDDEN_CLASS = 'k-hidden';
/**
 * Represents the [Kendo UI ExpansionPanel component for Angular]({% slug overview_expansionpanel %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-expansionpanel title="Chile" subtitle="South America">
 *              There are various theories about the origin of the word Chile.
 *        </kendo-expansionpanel>
 *    `
 * })
 * class AppComponent {}
 * ```
 */
let ExpansionPanelComponent = class ExpansionPanelComponent {
    constructor(renderer, hostElement, ngZone, localizationService, builder) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.ngZone = ngZone;
        this.localizationService = localizationService;
        this.builder = builder;
        /**
         * Specifies the primary text in the header of the ExpansionPanel
         * ([see example]({% slug title_expansionpanel %}#toc-title-and-subtitle)).
         */
        this.title = '';
        /**
         * Specifies the secondary text in the header of the ExpansionPanel, which is rendered next to the collapse/expand icon
         * ([see example]({% slug title_expansionpanel %}#toc-title-and-subtitle)).
         */
        this.subtitle = '';
        /**
         * Specifies whether the ExpansionPanel is disabled. If disabled, the ExpansionPanel can be neither expanded nor collapsed
         * ([see example]({% slug disabled_expansionpanel %})).
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Specifies the animation settings of the ExpansionPanel
         * ([see example]({% slug animations_expansionpanel %})).
         *
         * The possible values are:
         * * Boolean
         *    * (Default) `true` Numeric values represent duration. Default duration is 200ms.
         *    * false
         * * Number
         */
        this.animation = true;
        /**
         * Fires when the `expanded` property of the component is updated.
         * Used to provide a two-way binding for the `expanded` property
         * ([see example]({% slug overview_expansionpanel %}#toc-events)).
         */
        this.expandedChange = new EventEmitter();
        /**
         * Fires when the expanded state of the ExpansionPanel is about to change. This event is preventable
         * ([see example]({% slug overview_expansionpanel %}#toc-events)).
         */
        this.action = new EventEmitter();
        /**
         * Fires when the ExpansionPanel is expanded. If there is animation it will fire when the animation is complete
         * ([see example]({% slug overview_expansionpanel %}#toc-events)).
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the ExpansionPanel is collapsed. If there is animation it will fire when the animation is complete
         * ([see example]({% slug overview_expansionpanel %}#toc-events)).
         */
        this.collapse = new EventEmitter();
        this.hostClass = true;
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.focused = false;
        this.animationEnd = new EventEmitter();
        this.subscriptions = new Subscription();
        this._expanded = false;
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    /**
     * Specifies whether the ExpansionPanel is expanded. The property supports two-way binding.
     * ([see example]({% slug interaction_expansionpanel %}#toc-setting-the-initial-state)).
     *
     * @default false
     */
    set expanded(value) {
        if (value === this.expanded) {
            return;
        }
        this._expanded = value;
        if (this.expanded) {
            this.removeContentHiddenClass();
        }
        else {
            this.addContentHiddenClass();
        }
    }
    get expanded() {
        return this._expanded;
    }
    get expandedClass() {
        return this.expanded && !this.disabled;
    }
    get focusClass() {
        return this.focused;
    }
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    onComponentBlur() {
        if (this.focused) {
            this.focused = false;
        }
    }
    /**
     * @hidden
     */
    onComponentFocus() {
        if (!this.focused) {
            this.focused = true;
        }
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.hostElement.nativeElement, 'title');
        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => { this.direction = rtl ? 'rtl' : 'ltr'; });
    }
    ngAfterViewInit() {
        this.initDomEvents();
        if (!this.expanded) {
            this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    initDomEvents() {
        if (!this.hostElement) {
            return;
        }
        if (!this.disabled) {
            this.ngZone.runOutsideAngular(() => {
                const nativeElement = this.hostElement.nativeElement;
                this.subscriptions.add(this.renderer.listen(nativeElement, 'keydown', this.keyDownHandler.bind(this)));
            });
        }
    }
    /**
     * @hidden
     */
    keyDownHandler(ev) {
        const isEnterOrSpace = ev.keyCode === Keys.Enter || ev.keyCode === Keys.Space;
        if (!isEnterOrSpace) {
            return;
        }
        if (hasClass(ev.target, 'k-expander')) {
            ev.preventDefault();
            this.ngZone.run(() => {
                this.onHeaderAction();
            });
        }
    }
    /**
     * @hidden
     */
    onHeaderClick(ev) {
        if (!isFocusable(ev.target) && !this.disabled) {
            this.onHeaderAction();
        }
    }
    /**
     * @hidden
     */
    onHeaderAction() {
        this.focused = true;
        const eventArgs = new ExpansionPanelActionEvent();
        eventArgs.action = this.expanded ? 'collapse' : 'expand';
        this.action.emit(eventArgs);
        if (!eventArgs.isDefaultPrevented()) {
            this.setExpanded(!this.expanded);
            if (this.expanded) {
                this.removeContentHiddenClass();
            }
            if (this.animation) {
                this.animateContent();
                return;
            }
            if (!this.expanded) {
                this.addContentHiddenClass();
            }
            this.emitExpandCollapseEvent();
        }
    }
    /**
     * @hidden
     */
    get indicatorClasses() {
        if (this.expanded) {
            return this.collapseIcon ? this.collapseIcon : `k-icon k-i-arrow-chevron-up`;
        }
        else {
            return this.expandIcon ? this.expandIcon : `k-icon k-i-arrow-chevron-down`;
        }
    }
    /**
     * Toggles the visibility of the ExpansionPanel
     * ([see example]({% slug interaction_expansionpanel %}#toc-toggling-the-content)).
     *
     * @param expanded? - Boolean. Specifies, whether the ExpansionPanel will be expanded or collapsed.
     */
    toggle(expanded) {
        const previous = this.expanded;
        const current = isPresent(expanded) ? expanded : !previous;
        if (current === previous) {
            return;
        }
        this.setExpanded(current);
        if (this.expanded) {
            this.removeContentHiddenClass();
        }
        if (this.animation) {
            this.animateContent();
            return;
        }
        if (!this.expanded) {
            this.addContentHiddenClass();
        }
        this.emitExpandCollapseEvent();
    }
    setExpanded(value) {
        this._expanded = value;
        this.expandedChange.emit(value);
    }
    animateContent() {
        const duration = typeof this.animation === 'boolean' ? DEFAULT_DURATION : this.animation;
        const contentHeight = getComputedStyle(this.content.nativeElement).height;
        const animation = this.expanded ? expand(duration, contentHeight) : collapse(duration, contentHeight);
        const player = this.createPlayer(animation, this.content.nativeElement);
        this.animationEnd.pipe(take(1)).subscribe(() => {
            if (!this.expanded) {
                this.addContentHiddenClass();
            }
            this.emitExpandCollapseEvent();
        });
        player.play();
    }
    createPlayer(animation, animatedElement) {
        const factory = this.builder.build(animation);
        let player = factory.create(animatedElement);
        player.onDone(() => {
            if (player) {
                this.animationEnd.emit();
                player.destroy();
                player = null;
            }
        });
        return player;
    }
    emitExpandCollapseEvent() {
        this[this.expanded ? 'expand' : 'collapse'].emit();
    }
    addContentHiddenClass() {
        this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
    }
    removeContentHiddenClass() {
        this.renderer.removeClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
    }
};
ExpansionPanelComponent.ɵfac = function ExpansionPanelComponent_Factory(t) { return new (t || ExpansionPanelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.AnimationBuilder)); };
ExpansionPanelComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ExpansionPanelComponent, selectors: [["kendo-expansionpanel"]], contentQueries: function ExpansionPanelComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ExpansionPanelTitleDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.titleTemplate = _t.first);
    } }, viewQuery: function ExpansionPanelComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c21, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t.first);
    } }, hostVars: 12, hostBindings: function ExpansionPanelComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("blur", function ExpansionPanelComponent_blur_HostBindingHandler() { return ctx.onComponentBlur(); })("focus", function ExpansionPanelComponent_focus_HostBindingHandler() { return ctx.onComponentFocus(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("dir", ctx.direction)("aria-expanded", ctx.expandedClass)("aria-disabled", ctx.disabledClass);
        ɵngcc0.ɵɵclassProp("k-expander", ctx.hostClass)("k-expanded", ctx.expandedClass)("k-state-focus", ctx.focusClass)("k-state-disabled", ctx.disabledClass);
    } }, inputs: { title: "title", subtitle: "subtitle", disabled: "disabled", animation: "animation", expanded: "expanded", expandIcon: "expandIcon", collapseIcon: "collapseIcon" }, outputs: { expandedChange: "expandedChange", action: "action", expand: "expand", collapse: "collapse" }, exportAs: ["kendoExpansionPanel"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.expansionpanel'
            }
        ])], ngContentSelectors: _c9, decls: 9, vars: 6, consts: [[3, "click"], [4, "ngIf"], [1, "k-expander-indicator"], [3, "ngClass"], [1, "k-expander-content-wrapper"], ["content", ""], [1, "k-expander-content"], ["class", "k-expander-title", 4, "ngIf"], [1, "k-spacer"], ["class", "k-expander-sub-title", 4, "ngIf"], [1, "k-expander-title"], [1, "k-expander-sub-title"], [3, "ngTemplateOutlet"]], template: function ExpansionPanelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function ExpansionPanelComponent_Template_div_click_0_listener($event) { return ctx.onHeaderClick($event); });
        ɵngcc0.ɵɵtemplate(1, ExpansionPanelComponent_ng_container_1_Template, 4, 2, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, ExpansionPanelComponent_2_Template, 1, 1, null, 1);
        ɵngcc0.ɵɵelementStart(3, "span", 2);
        ɵngcc0.ɵɵelement(4, "span", 3);
        ɵngcc0.ɵɵelementEnd()();
        ɵngcc0.ɵɵelementStart(5, "div", 4, 5)(7, "div", 6);
        ɵngcc0.ɵɵprojection(8);
        ɵngcc0.ɵɵelementEnd()();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-expander-header", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.titleTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.titleTemplate);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ctx.indicatorClasses);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵattribute("aria-hidden", !ctx.expanded);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], ExpansionPanelComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ExpansionPanelComponent.prototype, "subtitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ExpansionPanelComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], ExpansionPanelComponent.prototype, "expanded", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], ExpansionPanelComponent.prototype, "expandIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ExpansionPanelComponent.prototype, "collapseIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ExpansionPanelComponent.prototype, "animation", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ExpansionPanelComponent.prototype, "expandedChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ExpansionPanelComponent.prototype, "action", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ExpansionPanelComponent.prototype, "expand", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ExpansionPanelComponent.prototype, "collapse", void 0);
__decorate([
    ContentChild(ExpansionPanelTitleDirective, { static: false }),
    __metadata("design:type", ExpansionPanelTitleDirective)
], ExpansionPanelComponent.prototype, "titleTemplate", void 0);
__decorate([
    ViewChild('content', { static: true }),
    __metadata("design:type", ElementRef)
], ExpansionPanelComponent.prototype, "content", void 0);
__decorate([
    HostBinding('class.k-expander'),
    __metadata("design:type", Boolean)
], ExpansionPanelComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('attr.aria-expanded'),
    HostBinding('class.k-expanded'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ExpansionPanelComponent.prototype, "expandedClass", null);
__decorate([
    HostBinding('class.k-state-focus'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ExpansionPanelComponent.prototype, "focusClass", null);
__decorate([
    HostBinding('attr.aria-disabled'),
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ExpansionPanelComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], ExpansionPanelComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Number)
], ExpansionPanelComponent.prototype, "tabindex", void 0);
__decorate([
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ExpansionPanelComponent.prototype, "onComponentBlur", null);
__decorate([
    HostListener('focus'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ExpansionPanelComponent.prototype, "onComponentFocus", null);
ExpansionPanelComponent = __decorate([ __metadata("design:paramtypes", [Renderer2,
        ElementRef,
        NgZone,
        LocalizationService,
        AnimationBuilder])
], ExpansionPanelComponent);

/**
 * @hidden
 */
const normalizeValue = (value) => {
    return value ? +value : undefined;
};
/**
 * @hidden
 */
const isRowItemPresent = (items) => {
    return items.some(item => isPresent(item.row));
};
/**
 * @hidden
 */
const propsChanged = (initialProps, newProps) => {
    for (let i = 0; i < initialProps.length; i++) {
        if (initialProps[i] !== newProps[i]) {
            return true;
        }
    }
    return false;
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
const getDropTarget = (event) => {
    if (!(isDocumentAvailable() && isPresent(document.elementsFromPoint))) {
        return [event.target];
    }
    return document.elementsFromPoint(event.clientX, event.clientY)
        .filter(item => item.classList && (item.classList.contains('k-tilelayout-item') || item.classList.contains('k-layout-item-hint')));
};
/**
 * @hidden
 */
const setElementStyles = (renderer, elem, styles) => {
    const props = Object.keys(styles);
    props.forEach(p => {
        renderer.setStyle(elem, p, styles[p]);
    });
};
/**
 * @hidden
 */
const calculateCellFromPosition = (coordinates, tileLayoutElement, gap, cellSize, columns, rtl = false) => {
    const tileLayoutRect = tileLayoutElement.getBoundingClientRect();
    const totalRows = (tileLayoutRect.height - gap.rows) / (cellSize.height + gap.rows);
    const distanceFromTop = coordinates.y - tileLayoutRect.y;
    const distanceFromLeft = coordinates.x - tileLayoutRect.x;
    const distanceFromRight = tileLayoutRect.right - coordinates.x;
    const distanceToCellWidthRatio = Math.floor((rtl ? distanceFromRight : distanceFromLeft) / (gap.columns + cellSize.width));
    const cappedColumnPosition = Math.min(distanceToCellWidthRatio + 1, columns);
    const distanceToCellHeightRatio = Math.floor(distanceFromTop / (gap.rows + cellSize.height));
    const cappedRowPosition = Math.min(distanceToCellHeightRatio + 1, totalRows);
    const col = Math.max(cappedColumnPosition, 0);
    const row = Math.max(cappedRowPosition, 0);
    return {
        row, col
    };
};

/**
 * @hidden
 */
const RESIZE_HANDLE_UNIDIRECTIONAL_SIZE = 9;
/**
 * @hidden
 */
const RESIZE_HANDLE_BIDIRECTIONAL_SIZE = 25;
/**
 * @hidden
 */
const RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP = 5;
/**
 * @hidden
 */
const RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP = 18;
/**
 * @hidden
 */
const DRAGGED_ZINDEX = 10;
/**
 * @hidden
 */
const RESIZE_DIRECTIONS = ['ew', 'ns', 'nwse'];
/**
 * @hidden
 */
const RTL_RESIZE_DIRECTIONS = ['ew', 'ns', 'nesw'];
/**
 * @hidden
 */
const RESIZE_HANDLE_DIMENSIONS = {
    // numeric values represent pixels
    ew: {
        width: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,
        overlapX: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP
    },
    ns: {
        height: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,
        overlapY: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP
    },
    nwse: {
        width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,
        overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP
    },
    nesw: {
        width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,
        overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP
    }
};
/**
 * @hidden
 */
const OVERLAP_THRESHOLD = 0.3;
/**
 * @hidden
 */
const REVERSE_OVERLAP_THRESHOLD = -0.7;
/**
 * @hidden
 */
const HINT_BORDERS_HEIGHT = 2;

/**
 * @hidden
 */
class PreventableEvent$2 {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `reorder` event. The event fires when the order or starting
 * positions of the items is changed via the UI. If you prevent the event, the change is canceled ([see example]({% slug reordering_tilelayout %}#toc-handling-the-reorder-event)).
 */
class TileLayoutReorderEvent extends PreventableEvent$2 {
    /**
     * Constructs the event arguments for the `reorder` event.
     * @param item - The TileLayoutItem being reordered.
     * @param items - The TileLayoutItem collection that holds the currently rendered items and their internal state.
     * @param newIndex - The new order index of the reordered item used to determine its positioning relative to the other items.
     * @param oldIndex - The initial order index of the reordered item used to determine its positioning relative to the other items.
     * @param newCol - The new start column of the reordered item.
     * @param oldCol - The initial start column of the reordered item.
     * @param newRow - The new start row of the reordered item.
     * @param oldRow - The initial start row of the reordered item.
     * @hidden
     */
    constructor(item, items, newIndex, oldIndex, newCol, oldCol, newRow, oldRow) {
        super();
        this.item = item;
        this.items = items;
        this.newIndex = newIndex;
        this.oldIndex = oldIndex;
        this.newCol = newCol;
        this.oldCol = oldCol;
        this.newRow = newRow;
        this.oldRow = oldRow;
    }
}

/**
 * Arguments for the `resize` event. The `resize` event fires when any item size
 * is changed from the UI. If you cancel the event, the change is prevented ([see example]({% slug resizing_tilelayout %}#toc-handling-the-resize-event)).
 */
class TileLayoutResizeEvent extends PreventableEvent$2 {
    /**
     * Constructs the event arguments for the `resize` event.
     * @param item - The TileLayoutItem being resized
     * @param items - The TileLayoutItem collection
     * @param newRowSpan - The new rowSpan of the resized item
     * @param oldRowSpan - The initial rowSpan of the resized item
     * @param newColSpan - The new colSpan of the resized item
     * @param oldColSpan - The initial colSpan of the resized item
     * @hidden
     */
    constructor(item, items, newRowSpan, oldRowSpan, newColSpan, oldColSpan) {
        super();
        this.item = item;
        this.items = items;
        this.newRowSpan = newRowSpan;
        this.oldRowSpan = oldRowSpan;
        this.newColSpan = newColSpan;
        this.oldColSpan = oldColSpan;
    }
}

/**
 * @hidden
 */
let TileLayoutDraggingService = class TileLayoutDraggingService {
    constructor(zone, renderer, localization) {
        this.zone = zone;
        this.renderer = renderer;
        this.localization = localization;
        this.reorderable = new BehaviorSubject(null);
        this.resizable = new BehaviorSubject(null);
        this.reorder = new Subject();
        this.resize = new Subject();
        this.lastDragCursorOffset = {
            x: 0,
            y: 0
        };
        this.localizationSubscription = this.localization.changes.subscribe(({ rtl }) => this.rtl = rtl);
    }
    get colStart() {
        return this.currentColStart;
    }
    get rowStart() {
        return this.currentRowStart;
    }
    get itemWrapper() {
        return this.draggedItemWrapper;
    }
    get order() {
        return this.targetOrder;
    }
    ngOnDestroy() {
        this.localizationSubscription.unsubscribe();
    }
    handlePress(originalEvent) {
        const resizing = !!originalEvent.target.classList.contains('k-resize-handle');
        const closestTile = closestInScope(originalEvent.target, el => el.classList.contains('k-tilelayout-item'), this.tileLayoutSettings.tileLayoutElement);
        const closestHeader = closestInScope(originalEvent.target, el => el.classList.contains('k-tilelayout-item-header'), this.tileLayoutSettings.tileLayoutElement);
        if (!closestTile) {
            return;
        }
        this.zone.run(() => {
            this.draggedItemWrapper = closestTile;
            this.draggedItem = this.tileLayoutSettings.items
                .find(item => item.order === +closestTile.style.order);
        });
        const reordering = !resizing && this.reorderable.getValue() && this.draggedItem.reorderable && closestHeader;
        if (!(reordering || resizing)) {
            return;
        }
        else {
            originalEvent.preventDefault();
        }
        this.zone.run(() => {
            this.reordering = reordering;
            this.resizing = resizing;
        });
        const tileRect = this.draggedItemWrapper.getBoundingClientRect();
        this.zone.run(() => {
            this.offset = {
                top: originalEvent.clientY - tileRect.top,
                left: originalEvent.clientX - tileRect.left,
                x: tileRect.x,
                y: tileRect.y,
                width: tileRect.width,
                height: tileRect.height
            };
            this.targetSize = {
                rowSpan: this.draggedItem.rowSpan,
                colSpan: this.draggedItem.colSpan
            };
            this.cellSize = {
                width: (tileRect.width - ((this.targetSize.colSpan - 1) * this.tileLayoutSettings.gap.columns)) / this.targetSize.colSpan,
                height: (tileRect.height - ((this.targetSize.rowSpan - 1) * this.tileLayoutSettings.gap.rows)) / this.targetSize.rowSpan
            };
            this.lastDragCursorOffset = {
                x: originalEvent.clientX,
                y: originalEvent.clientY
            };
        });
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            left: tileRect.left + window.pageXOffset + 'px',
            top: tileRect.top + window.pageYOffset + 'px',
            width: tileRect.width + 'px',
            height: tileRect.height + 'px',
            zIndex: DRAGGED_ZINDEX
        });
        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
            display: 'flex',
            height: (tileRect.height - HINT_BORDERS_HEIGHT) + 'px'
        });
        this.zone.run(() => this.targetOrder = this.draggedItem.order);
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            position: 'absolute'
        });
        if (this.reorderable.getValue() && !resizing) {
            this.zone.run(() => {
                this.currentColStart = this.draggedItem.colStart;
                this.currentRowStart = this.draggedItem.rowStart;
            });
            const headerEl = this.draggedItem.elem.nativeElement.querySelector('.k-tilelayout-item-header');
            this.renderer.addClass(headerEl, 'k-cursor-grabbing');
        }
        else if (this.resizable && resizing) {
            this.zone.run(() => {
                this.startingPoint = {
                    top: originalEvent.clientY,
                    left: originalEvent.clientX
                };
                this.currentResizingColSpan = this.draggedItem.colSpan;
                this.currentResizingRowSpan = this.draggedItem.rowSpan;
                if (this.draggedItem.col) {
                    this.currentColStart = this.draggedItem.col.toString();
                }
                if (this.draggedItem.row) {
                    this.currentRowStart = this.draggedItem.row.toString();
                }
                this.direction = originalEvent.target.classList[1];
            });
        }
    }
    handleDrag(originalEvent) {
        if (this.draggedItemWrapper) {
            if (this.reordering) {
                this.reorderItems(originalEvent);
            }
            else if (this.resizing) {
                this.resizeItem(originalEvent);
            }
            this.lastDragCursorOffset = {
                x: originalEvent.clientX,
                y: originalEvent.clientY
            };
        }
    }
    handleRelease(originalEvent) {
        originalEvent.preventDefault();
        if (this.reordering) {
            const initialOrder = this.draggedItem.order;
            const initialCol = this.draggedItem.col;
            const initialRow = this.draggedItem.row;
            const targetCol = normalizeValue(this.currentColStart);
            const targetRow = normalizeValue(this.currentRowStart);
            if (propsChanged([this.targetOrder, targetCol, targetRow], [initialOrder, initialCol, initialRow])) {
                const reorderEvent = new TileLayoutReorderEvent(this.draggedItem, this.tileLayoutSettings.items, this.targetOrder, initialOrder, normalizeValue(this.currentColStart), initialCol, targetRow, initialRow);
                this.reorder.next(reorderEvent);
                if (!reorderEvent.isDefaultPrevented()) {
                    if (this.targetOrder > initialOrder) {
                        this.zone.run(() => {
                            for (let i = initialOrder + 1; i <= this.targetOrder; i++) {
                                this.tileLayoutSettings.items.find(item => item.order === i).order = i - 1;
                            }
                        });
                    }
                    else {
                        this.zone.run(() => {
                            for (let i = this.targetOrder; i < initialOrder; i++) {
                                this.tileLayoutSettings.items.find(item => item.order === i).order = i + 1;
                            }
                        });
                    }
                    this.draggedItem.order = this.targetOrder;
                    if (this.draggedItem.col) {
                        this.draggedItem.col = +this.currentColStart;
                    }
                    if (this.draggedItem.row) {
                        this.draggedItem.row = +this.currentRowStart;
                    }
                }
            }
            this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);
            this.zone.run(() => this.cleanUp());
        }
        else if (!this.reordering && this.resizing) {
            const initialRowSpan = this.draggedItem.rowSpan;
            const initialColSpan = this.draggedItem.colSpan;
            const { targetColSpan, targetRowSpan } = isRowItemPresent(this.tileLayoutSettings.items) ?
                this.targetSpan() :
                { targetColSpan: this.currentResizingColSpan, targetRowSpan: this.currentResizingRowSpan };
            if (propsChanged([initialRowSpan, initialColSpan], [targetRowSpan, targetColSpan])) {
                const resizeEvent = new TileLayoutResizeEvent(this.draggedItem, this.tileLayoutSettings.items, targetRowSpan, initialRowSpan, targetColSpan, initialColSpan);
                this.resize.next(resizeEvent);
                if (!resizeEvent.isDefaultPrevented()) {
                    this.draggedItem.colSpan = this.currentResizingColSpan;
                    this.draggedItem.rowSpan = this.currentResizingRowSpan;
                }
            }
            this.zone.run(() => this.cleanUp());
        }
    }
    reorderItems(event) {
        const targets = getDropTarget(event);
        const closestTile = targets.find(t => t !== this.draggedItemWrapper);
        let tileOrder = closestTile ? +closestTile.style.order : +this.draggedItemWrapper.style.order;
        if (this.tileLayoutSettings.autoFlow !== 'none') {
            const deltaX = event.clientX - this.lastDragCursorOffset.x;
            const deltaY = event.clientY - this.lastDragCursorOffset.y;
            const directionX = deltaX > 0 ? 'right' : deltaX < 0 ? 'left' : undefined;
            const directionY = deltaY > 0 ? 'down' : deltaX < 0 ? 'up' : undefined;
            const rect = this.draggedItemWrapper.getBoundingClientRect();
            const horizontalGap = this.tileLayoutSettings.gap.columns;
            const verticalGap = this.tileLayoutSettings.gap.rows;
            if (directionX && this.draggedItem.col) {
                const { col } = calculateCellFromPosition({
                    x: directionX === 'right' ? rect.right - horizontalGap : rect.left + horizontalGap,
                    y: event.clientY
                }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
                const targetStartCol = this.getTargetCol(col, directionX);
                this.currentColStart = targetStartCol.toString();
            }
            if (directionY && this.draggedItem.row) {
                const { row } = calculateCellFromPosition({
                    x: event.clientX,
                    y: directionY === 'down' ? rect.bottom - verticalGap : rect.top + verticalGap
                }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
                const targetStartRow = this.getTargetRow(row, directionY);
                this.currentRowStart = targetStartRow.toString();
            }
        }
        const hintBefore = tileOrder < this.targetOrder;
        const hintAfter = tileOrder > this.targetOrder;
        this.zone.run(() => this.targetOrder = tileOrder);
        if (hintBefore) {
            this.tileLayoutSettings.tileLayoutElement
                .insertBefore(this.tileLayoutSettings.hintElement, this.tileLayoutSettings.tileLayoutElement.firstChild);
        }
        else if (hintAfter) {
            this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);
        }
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            top: (event.pageY - this.offset.top) + 'px',
            left: (event.pageX - this.offset.left) + 'px'
        });
    }
    resizeItem(event) {
        setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {
            cursor: this.direction.split('k-cursor-')[1]
        });
        const currentWidth = this.rtl ?
            this.offset.width + (this.offset.x - event.clientX) :
            this.offset.width + (event.clientX - this.startingPoint.left);
        const currentHeight = this.offset.height + (event.clientY - this.startingPoint.top);
        const hintRect = this.tileLayoutSettings.hintElement.getBoundingClientRect();
        const hintWidth = hintRect.width;
        const hintHeight = hintRect.height;
        const horizontalDragDirection = event.clientX - this.lastDragCursorOffset.x;
        const verticalDragDirection = event.clientY - this.lastDragCursorOffset.y;
        const startCol = this.draggedItem.col ? this.draggedItem.col : calculateCellFromPosition({
            x: this.rtl ? hintRect.right : hintRect.x,
            y: hintRect.y
        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl).col;
        const maxWidth = (this.tileLayoutSettings.columns - startCol) * (this.cellSize.width + this.tileLayoutSettings.gap.columns) + this.cellSize.width;
        const resizeHorizontally = () => {
            setElementStyles(this.renderer, this.draggedItemWrapper, {
                width: Math.min(Math.max(currentWidth, this.cellSize.width), maxWidth) + 'px'
            });
            if (this.rtl && currentWidth > this.cellSize.width) {
                const totalWidth = this.tileLayoutSettings.columns * (this.cellSize.width + this.tileLayoutSettings.gap.columns);
                const leftBoundary = this.tileLayoutSettings.tileLayoutElement.getBoundingClientRect().right - totalWidth;
                setElementStyles(this.renderer, this.draggedItemWrapper, {
                    left: Math.max(event.clientX, leftBoundary) + 'px'
                });
            }
            const deltaX = currentWidth - hintWidth;
            const { x, y, right } = this.draggedItem.elem.nativeElement.getBoundingClientRect();
            const { col } = calculateCellFromPosition({ x: (this.rtl ? right : x), y: y }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
            const resizedColSpan = col + this.currentResizingColSpan;
            const expandingCondition = this.rtl ? horizontalDragDirection < 0 : horizontalDragDirection > 0;
            const shrinkingCondition = this.rtl ? horizontalDragDirection > 0 : horizontalDragDirection < 0;
            if (deltaX > OVERLAP_THRESHOLD * this.cellSize.width &&
                expandingCondition &&
                resizedColSpan <= this.tileLayoutSettings.columns) {
                this.currentResizingColSpan++;
            }
            else if (this.currentResizingColSpan > 1 &&
                shrinkingCondition &&
                deltaX < REVERSE_OVERLAP_THRESHOLD * this.cellSize.width) {
                this.currentResizingColSpan--;
            }
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                gridColumnEnd: `span ${this.currentResizingColSpan}`
            });
        };
        const resizeVertically = () => {
            setElementStyles(this.renderer, this.draggedItemWrapper, {
                height: Math.max(currentHeight, this.cellSize.height) + 'px'
            });
            const deltaY = currentHeight - hintHeight;
            if (deltaY > OVERLAP_THRESHOLD * this.cellSize.height && verticalDragDirection > 0) {
                this.currentResizingRowSpan++;
            }
            else if (this.currentResizingRowSpan > 1 &&
                verticalDragDirection < 0 && deltaY < REVERSE_OVERLAP_THRESHOLD * this.cellSize.height) {
                this.currentResizingRowSpan--;
            }
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                gridRowEnd: `span ${this.currentResizingRowSpan}`
            });
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                height: `${this.calculateHintHeight()}px`
            });
        };
        if (this.direction.indexOf('ew') > -1) {
            resizeHorizontally();
        }
        else if (this.direction.indexOf('ns') > -1) {
            resizeVertically();
        }
        else {
            resizeHorizontally();
            resizeVertically();
        }
    }
    cleanUp() {
        this.targetOrder = this.currentResizingColSpan = this.currentColStart = this.currentResizingRowSpan = this.currentRowStart = undefined;
        this.resizing = this.reordering = false;
        this.direction = null;
        if (this.draggedItemWrapper) {
            const grabHandle = this.draggedItemWrapper.querySelector('.k-cursor-grab');
            if (grabHandle) {
                this.renderer.removeClass(grabHandle, 'k-cursor-grabbing');
            }
            setElementStyles(this.renderer, this.draggedItemWrapper, {
                top: '',
                left: '',
                display: '',
                width: '',
                height: '',
                zIndex: '',
                position: ''
            });
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                display: 'none',
                height: 'auto'
            });
            setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {
                cursor: 'default'
            });
            this.draggedItemWrapper =
                this.offset =
                    this.draggedItem =
                        this.resizing =
                            this.reordering =
                                this.currentResizingColSpan =
                                    this.currentResizingRowSpan =
                                        this.startingPoint = undefined;
            this.lastDragCursorOffset = {
                x: 0,
                y: 0
            };
        }
    }
    targetSpan() {
        const itemRect = this.draggedItem.elem.nativeElement.getBoundingClientRect();
        const startingCell = calculateCellFromPosition({ x: this.rtl ? itemRect.right : itemRect.x, y: itemRect.y }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
        const targetEndCell = calculateCellFromPosition({
            x: this.rtl ? itemRect.x + OVERLAP_THRESHOLD * this.cellSize.width : itemRect.right - OVERLAP_THRESHOLD * this.cellSize.width,
            y: itemRect.bottom - OVERLAP_THRESHOLD * this.cellSize.height
        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
        return {
            targetColSpan: targetEndCell.col - startingCell.col + 1,
            targetRowSpan: targetEndCell.row - startingCell.row + 1
        };
    }
    getTargetCol(col, direction) {
        if (this.rtl) {
            return direction === 'left' ? col - this.draggedItem.colSpan + 1 : col;
        }
        return direction === 'right' ? col - this.draggedItem.colSpan + 1 : col;
    }
    getTargetRow(row, direction) {
        return direction === 'down' ? row - this.draggedItem.rowSpan + 1 : row;
    }
    calculateHintHeight() {
        const totalHintCellsHeight = this.currentResizingRowSpan * this.cellSize.height;
        const totalHintGapsHeight = (this.currentResizingRowSpan - 1) * this.tileLayoutSettings.gap.rows;
        const hintHeight = totalHintCellsHeight + totalHintGapsHeight - HINT_BORDERS_HEIGHT;
        return hintHeight;
    }
};
TileLayoutDraggingService.ɵfac = function TileLayoutDraggingService_Factory(t) { return new (t || TileLayoutDraggingService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinject(ɵngcc2.LocalizationService)); };
TileLayoutDraggingService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: TileLayoutDraggingService, factory: function (t) { return TileLayoutDraggingService.ɵfac(t); } });
TileLayoutDraggingService = __decorate([ __metadata("design:paramtypes", [NgZone,
        Renderer2,
        LocalizationService])
], TileLayoutDraggingService);

/**
 * Represents a tile item within the TileLayoutComponent.
 */
let TileLayoutItemComponent = class TileLayoutItemComponent {
    constructor(elem, renderer, localization, draggingService) {
        this.elem = elem;
        this.renderer = renderer;
        this.localization = localization;
        this.draggingService = draggingService;
        /**
         * Determines how many rows will the tile item span ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default 1
         */
        this.rowSpan = 1;
        /**
         * Determines how many columns will the tile item span ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default 1
         */
        this.colSpan = 1;
        /**
         * Determines whether the item can be reordered. By default all items are reorderable when the [reorderable]({% slug api_layout_tilelayoutcomponent %}#toc-reorderable) property of the TileLayoutComponent is set to `true` ([see example]({% slug reordering_tilelayout %}#toc-disable-reordering)).
         *
         * @default true
         */
        this.reorderable = true;
        /**
         * Determines whether the item can be resized. By default all items are resizable when the [resizable]({% slug api_layout_tilelayoutcomponent %}#resizable) property of the TileLayoutComponent is set to `true` ([see example]({% slug resizing_tilelayout %}#toc-disable-resizing)).
         * @default true
         */
        this.resizable = true;
        this.itemClass = true;
        this.subs = new Subscription();
        this.subs.add(this.localization.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
        }));
        this.subs.add(this.draggingService.resizable.subscribe(resizable => {
            this.resizeDirections = resizable && this.resizable ?
                this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;
        }));
    }
    /**
     * Determines the order of the tile items within the TileLayout.
     * If not set, the items will receive increasing sequential order in accordance with
     * their position in the DOM when initially rendered.
     */
    set order(value) {
        this._order = value;
        this.renderer.setStyle(this.elem.nativeElement, 'order', `${this._order}`);
    }
    get order() {
        return this._order;
    }
    get colEnd() {
        return `span ${this.colSpan}`;
    }
    get rowEnd() {
        return `span ${this.rowSpan}`;
    }
    get colStart() {
        return isPresent(this.col) ? this.col.toString() : undefined;
    }
    get rowStart() {
        return isPresent(this.row) ? this.row.toString() : undefined;
    }
    ngAfterViewInit() {
        this.subs.add(this.draggingService.reorderable.subscribe(reorderable => {
            this.toggleCursorClass(reorderable && this.reorderable);
        }));
    }
    ngOnChanges(changes) {
        if (changes.reorderable && !changes.reorderable.firstChange) {
            this.toggleCursorClass(changes.reorderable.currentValue && this.draggingService.reorderable.getValue());
        }
        if (changes.resizable) {
            this.resizeDirections = this.resizable && this.draggingService.resizable.getValue() ?
                this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;
        }
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    toggleCursorClass(isReorderable) {
        const headerEl = this.elem.nativeElement.querySelector('.k-tilelayout-item-header');
        if (!headerEl) {
            return;
        }
        if (isReorderable) {
            this.renderer.addClass(headerEl, 'k-cursor-grab');
        }
        else {
            this.renderer.removeClass(headerEl, 'k-cursor-grab');
        }
    }
};
TileLayoutItemComponent.ɵfac = function TileLayoutItemComponent_Factory(t) { return new (t || TileLayoutItemComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(TileLayoutDraggingService)); };
TileLayoutItemComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TileLayoutItemComponent, selectors: [["kendo-tilelayout-item"]], hostVars: 12, hostBindings: function TileLayoutItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("grid-column-end", ctx.colEnd)("grid-row-end", ctx.rowEnd)("grid-column-start", ctx.colStart)("grid-row-start", ctx.rowStart);
        ɵngcc0.ɵɵclassProp("k-tilelayout-item", ctx.itemClass)("k-card", ctx.itemClass);
    } }, inputs: { rowSpan: "rowSpan", colSpan: "colSpan", reorderable: "reorderable", resizable: "resizable", order: "order", title: "title", col: "col", row: "row" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c9, decls: 3, vars: 2, consts: [[4, "ngIf"], [1, "k-card-title"], ["kendoTileLayoutResizeHandle", "", 3, "class", "rtl", "resizeDirection", 4, "ngFor", "ngForOf"], ["kendoTileLayoutResizeHandle", "", 3, "rtl", "resizeDirection"]], template: function TileLayoutItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, TileLayoutItemComponent_kendo_tilelayout_item_header_0_Template, 3, 1, "kendo-tilelayout-item-header", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, TileLayoutItemComponent_ng_container_2_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.resizable);
    } }, directives: function () { return [ɵngcc1.NgIf, TileLayoutItemHeaderComponent, ɵngcc1.NgForOf, TileLayoutResizeHandleDirective]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], TileLayoutItemComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TileLayoutItemComponent.prototype, "rowSpan", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TileLayoutItemComponent.prototype, "colSpan", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], TileLayoutItemComponent.prototype, "order", null);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TileLayoutItemComponent.prototype, "col", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TileLayoutItemComponent.prototype, "row", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TileLayoutItemComponent.prototype, "reorderable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TileLayoutItemComponent.prototype, "resizable", void 0);
__decorate([
    HostBinding('class.k-tilelayout-item'),
    HostBinding('class.k-card'),
    __metadata("design:type", Boolean)
], TileLayoutItemComponent.prototype, "itemClass", void 0);
__decorate([
    HostBinding('style.grid-column-end'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], TileLayoutItemComponent.prototype, "colEnd", null);
__decorate([
    HostBinding('style.grid-row-end'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], TileLayoutItemComponent.prototype, "rowEnd", null);
__decorate([
    HostBinding('style.grid-column-start'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], TileLayoutItemComponent.prototype, "colStart", null);
__decorate([
    HostBinding('style.grid-row-start'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], TileLayoutItemComponent.prototype, "rowStart", null);
TileLayoutItemComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        LocalizationService,
        TileLayoutDraggingService])
], TileLayoutItemComponent);

const autoFlowClasses = {
    column: 'k-grid-flow-col',
    row: 'k-grid-flow-row',
    'column-dense': 'k-grid-flow-col-dense',
    'row-dense': 'k-grid-flow-row-dense'
};
/**
 * Represents the [Kendo UI TileLayout component for Angular]({% slug overview_tilelayout %})
 */
let TileLayoutComponent = class TileLayoutComponent {
    constructor(elem, renderer, localization, draggingService, zone) {
        this.elem = elem;
        this.renderer = renderer;
        this.localization = localization;
        this.draggingService = draggingService;
        this.zone = zone;
        /**
         * Defines the number of columns ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default 1
         */
        this.columns = 1;
        /**
         * Determines the width of the columns. Numeric values are treated as pixels ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default '1fr'
         */
        this.columnWidth = '1fr';
        /**
         * Determines whether the reordering functionality will be enabled ([see example]({% slug reordering_tilelayout %})).
         * @default false
         */
        this.reorderable = false;
        /**
         * Determines whether the resizing functionality will be enabled ([see example]({% slug resizing_tilelayout %})).
         * @default false
         */
        this.resizable = false;
        /**
         * Determines the height of the rows. Numeric values are treated as pixels ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default '1fr'
         */
        this.rowHeight = '1fr';
        /**
         * Controls how the auto-placement algorithm works, specifying exactly how auto-placed items are flowed in the TileLayout ([see example]({% slug tiles_autoflow_tilelayout %})).
         * For further reference, check the [grid-auto-flow CSS article](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow).
         *
         * The possible values are:
         * * (Default) `column`
         * * `row`
         * * `row dense`
         * * `column dense`
         * * `none`
         *
         */
        this.autoFlow = 'column';
        /**
         * Fires when the user completes the reordering of the item ([see example]({% slug overview_tilelayout %}#toc-events)).
         * This event is preventable. If you cancel it, the item will not be reordered.
         */
        this.reorder = new EventEmitter();
        /**
         * Fires when the user completes the resizing of the item ([see example]({% slug overview_tilelayout %}#toc-events)).
         * This event is preventable. If you cancel it, the item will not be resized.
         */
        this.resize = new EventEmitter();
        this.hostClass = true;
        this.subs = new Subscription();
        this._gap = {
            rows: 16,
            columns: 16
        };
        validatePackage(packageMetadata);
    }
    /**
     * The numeric values which determine the spacing in pixels between the layout items horizontally and vertically.
     * Properties:
     * * rows - the vertical spacing. Numeric values are treated as pixels. Defaults to `16`.
     * * columns - the horizontal spacing. Numeric values are treated as pixels. Defaults to `16`.
     *
     * When bound to a single numeric value, it will be set to both `rows` and `columns` properties.
     */
    set gap(value) {
        this._gap = (typeof value === 'number') ? { rows: value, columns: value } : Object.assign(this._gap, value);
    }
    get gap() {
        return this._gap;
    }
    get gapStyle() {
        return `${this.gap.rows}px ${this.gap.columns}px`;
    }
    get currentColStart() {
        return this.draggingService.colStart;
    }
    get currentRowStart() {
        return this.draggingService.rowStart;
    }
    get draggedItemWrapper() {
        return this.draggingService.itemWrapper;
    }
    get targetOrder() {
        return this.draggingService.order;
    }
    ngOnInit() {
        this.applyColStyling();
        this.applyRowStyling();
        this.draggingService.reorderable.next(this.reorderable);
        this.draggingService.resizable.next(this.resizable);
        if (hasObservers(this.reorder)) {
            this.subs.add(this.draggingService.reorder.subscribe(e => this.reorder.emit(e)));
        }
        if (hasObservers(this.resize)) {
            this.subs.add(this.draggingService.resize.subscribe(e => this.resize.emit(e)));
        }
        this.subs.add(this.draggingService.reorderable.subscribe(reorderable => {
            if (reorderable && !this.draggable) {
                this.initializeDraggable();
            }
        }));
        this.subs.add(this.draggingService.resizable.subscribe(resizable => {
            if (resizable && !this.draggable) {
                this.initializeDraggable();
            }
        }));
        this.subs.add(this.localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        }));
    }
    ngAfterViewInit() {
        this.draggingService.tileLayoutSettings = this.draggingServiceConfig();
        this.applyAutoFlow(null, autoFlowClasses[this.autoFlow]);
        this.items.changes.subscribe(() => {
            this.setItemsOrder();
            this.draggingService.tileLayoutSettings.items = this.items.toArray();
        });
    }
    ngAfterContentInit() {
        this.setItemsOrder();
    }
    ngOnChanges(changes) {
        if (changes.columns || changes.columnWidth) {
            this.applyColStyling();
        }
        if (changes.rowHeight) {
            this.applyRowStyling();
        }
        if (changes.reorderable) {
            this.draggingService.reorderable.next(changes.reorderable.currentValue);
        }
        if (changes.resizable) {
            this.draggingService.resizable.next(changes.resizable.currentValue);
        }
        if (changes.gap || changes.autoFlow || changes.columns) {
            this.draggingService.tileLayoutSettings = this.draggingServiceConfig();
            if (changes.autoFlow) {
                this.applyAutoFlow(autoFlowClasses[changes.autoFlow.previousValue] || '', autoFlowClasses[changes.autoFlow.currentValue]);
            }
        }
    }
    ngOnDestroy() {
        if (this.draggable) {
            this.draggable.destroy();
        }
        this.subs.unsubscribe();
    }
    handlePress({ originalEvent }) {
        this.draggingService.handlePress(originalEvent);
    }
    handleDrag({ originalEvent }) {
        this.draggingService.handleDrag(originalEvent);
    }
    handleRelease({ originalEvent }) {
        this.draggingService.handleRelease(originalEvent);
    }
    applyColStyling() {
        const colWidth = typeof this.columnWidth === 'number' ? `${this.columnWidth}px` : this.columnWidth;
        const gridTemplateColumnsStyle = `repeat(${this.columns}, ${colWidth})`;
        this.renderer.setStyle(this.elem.nativeElement, 'grid-template-columns', gridTemplateColumnsStyle);
    }
    applyRowStyling() {
        const rowHeight = typeof this.rowHeight === 'number' ? `${this.rowHeight}px` : this.rowHeight;
        const gridAutoRowsStyle = `${rowHeight}`;
        this.renderer.setStyle(this.elem.nativeElement, 'grid-auto-rows', gridAutoRowsStyle);
    }
    draggingServiceConfig() {
        return {
            tileLayoutElement: this.elem ? this.elem.nativeElement : undefined,
            hintElement: this.hint ? this.hint.nativeElement : undefined,
            gap: this.gap,
            columns: this.columns,
            autoFlow: this.autoFlow,
            items: this.items ? this.items.toArray() : []
        };
    }
    initializeDraggable() {
        this.draggable = new Draggable({
            press: this.handlePress.bind(this),
            drag: this.handleDrag.bind(this),
            release: this.handleRelease.bind(this)
        });
        this.zone.runOutsideAngular(() => this.draggable.bindTo(this.elem.nativeElement));
    }
    applyAutoFlow(classToRemove, classToAdd) {
        const element = this.elem.nativeElement;
        if (classToRemove) {
            this.renderer.removeClass(element, classToRemove);
        }
        if (this.autoFlow !== 'none' && isPresent(classToAdd)) {
            this.renderer.addClass(element, classToAdd);
        }
    }
    setItemsOrder() {
        this.items.forEach((item, index) => {
            if (!isPresent(item.order)) {
                item.order = index;
            }
        });
    }
};
TileLayoutComponent.ɵfac = function TileLayoutComponent_Factory(t) { return new (t || TileLayoutComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(TileLayoutDraggingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
TileLayoutComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TileLayoutComponent, selectors: [["kendo-tilelayout"]], contentQueries: function TileLayoutComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TileLayoutItemComponent, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, viewQuery: function TileLayoutComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c22, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hint = _t.first);
    } }, hostVars: 9, hostBindings: function TileLayoutComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵstyleProp("gap", ctx.gapStyle)("padding", ctx.gapStyle);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClass)("k-tilelayout", ctx.hostClass);
    } }, inputs: { columns: "columns", columnWidth: "columnWidth", reorderable: "reorderable", resizable: "resizable", rowHeight: "rowHeight", autoFlow: "autoFlow", gap: "gap" }, outputs: { reorder: "reorder", resize: "resize" }, features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            TileLayoutDraggingService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.tilelayout.component'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c9, decls: 3, vars: 14, consts: [[1, "k-layout-item-hint", "k-layout-item-hint-reorder"], ["hint", ""]], template: function TileLayoutComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelement(1, "div", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("display", "none")("order", ctx.targetOrder)("grid-column-end", ctx.draggedItemWrapper == null ? null : ctx.draggedItemWrapper.style.gridColumnEnd)("grid-row-end", ctx.draggedItemWrapper == null ? null : ctx.draggedItemWrapper.style.gridRowEnd)("grid-column-start", ctx.currentColStart)("grid-row-start", ctx.currentRowStart)("z-index", "1");
    } }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], TileLayoutComponent.prototype, "columns", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TileLayoutComponent.prototype, "columnWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], TileLayoutComponent.prototype, "gap", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TileLayoutComponent.prototype, "reorderable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TileLayoutComponent.prototype, "resizable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TileLayoutComponent.prototype, "rowHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TileLayoutComponent.prototype, "autoFlow", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TileLayoutComponent.prototype, "reorder", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TileLayoutComponent.prototype, "resize", void 0);
__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-tilelayout'),
    __metadata("design:type", Boolean)
], TileLayoutComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('style.gap'),
    HostBinding('style.padding'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], TileLayoutComponent.prototype, "gapStyle", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], TileLayoutComponent.prototype, "direction", void 0);
__decorate([
    ContentChildren(TileLayoutItemComponent),
    __metadata("design:type", QueryList)
], TileLayoutComponent.prototype, "items", void 0);
__decorate([
    ViewChild('hint', { static: false }),
    __metadata("design:type", ElementRef)
], TileLayoutComponent.prototype, "hint", void 0);
TileLayoutComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        LocalizationService,
        TileLayoutDraggingService,
        NgZone])
], TileLayoutComponent);

/**
 * Holds the main content of the TileLayoutItem component.
 */
let TileLayoutItemBodyComponent = class TileLayoutItemBodyComponent {
    /**
     * Holds the main content of the TileLayoutItem component.
     */
    constructor() {
        this.hostClass = true;
        this.minHeight = 0;
    }
};
TileLayoutItemBodyComponent.ɵfac = function TileLayoutItemBodyComponent_Factory(t) { return new (t || TileLayoutItemBodyComponent)(); };
TileLayoutItemBodyComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TileLayoutItemBodyComponent, selectors: [["kendo-tilelayout-item-body"]], hostVars: 6, hostBindings: function TileLayoutItemBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("min-height", ctx.minHeight);
        ɵngcc0.ɵɵclassProp("k-tilelayout-item-body", ctx.hostClass)("k-card-body", ctx.hostClass);
    } }, ngContentSelectors: _c9, decls: 1, vars: 0, template: function TileLayoutItemBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-tilelayout-item-body'),
    HostBinding('class.k-card-body'),
    __metadata("design:type", Boolean)
], TileLayoutItemBodyComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('style.min-height'),
    __metadata("design:type", Number)
], TileLayoutItemBodyComponent.prototype, "minHeight", void 0);

/**
 * Holds the content of the header section of the TileLayoutItem component.
 * This is the area which can be dragged to reorder the items if reordering is enabled for this item.
 */
let TileLayoutItemHeaderComponent = class TileLayoutItemHeaderComponent {
    constructor(draggingService) {
        this.draggingService = draggingService;
        this.hostClass = true;
    }
    get touchActionNone() {
        return this.draggingService.reorderable.getValue();
    }
    get touchActionAuto() {
        return !this.draggingService.reorderable.getValue();
    }
};
TileLayoutItemHeaderComponent.ɵfac = function TileLayoutItemHeaderComponent_Factory(t) { return new (t || TileLayoutItemHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(TileLayoutDraggingService)); };
TileLayoutItemHeaderComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TileLayoutItemHeaderComponent, selectors: [["kendo-tilelayout-item-header"]], hostVars: 8, hostBindings: function TileLayoutItemHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-tilelayout-item-header", ctx.hostClass)("k-card-header", ctx.hostClass)("k-touch-action-none", ctx.touchActionNone)("k-touch-action-auto", ctx.touchActionAuto);
    } }, ngContentSelectors: _c9, decls: 1, vars: 0, template: function TileLayoutItemHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-tilelayout-item-header'),
    HostBinding('class.k-card-header'),
    __metadata("design:type", Boolean)
], TileLayoutItemHeaderComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('class.k-touch-action-none'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TileLayoutItemHeaderComponent.prototype, "touchActionNone", null);
__decorate([
    HostBinding('class.k-touch-action-auto'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TileLayoutItemHeaderComponent.prototype, "touchActionAuto", null);
TileLayoutItemHeaderComponent = __decorate([ __metadata("design:paramtypes", [TileLayoutDraggingService])
], TileLayoutItemHeaderComponent);

const exportedModules = [
    AvatarComponent
];
const declarations = [
    ...exportedModules
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Avatar component.
 */
let AvatarModule = class AvatarModule {
};
AvatarModule.ɵfac = function AvatarModule_Factory(t) { return new (t || AvatarModule)(); };
AvatarModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: AvatarModule });
AvatarModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

const cardDirectives = [
    CardTitleDirective,
    CardSubtitleDirective,
    CardSeparatorDirective,
    CardMediaDirective
];
const exportedModules$1 = [
    CardComponent,
    CardHeaderComponent,
    CardBodyComponent,
    CardFooterComponent,
    CardActionsComponent,
    ...cardDirectives
];
const declarations$1 = [...exportedModules$1];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Card component.
 */
let CardModule = class CardModule {
};
CardModule.ɵfac = function CardModule_Factory(t) { return new (t || CardModule)(); };
CardModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CardModule });
CardModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

/**
 * @hidden
 */
const DRAWER_LINK_SELECTOR = '.k-drawer-link';
/**
 * @hidden
 */
const ACTIVE_NESTED_LINK_SELECTOR = ':focus:not(.k-state-disabled) .k-drawer-link';
/**
 * @hidden
 */
const nestedLink = (element, selector) => element.querySelector(selector);

/**
 * @hidden
 */
let DrawerItemComponent = class DrawerItemComponent {
    constructor(drawer, element, renderer) {
        this.drawer = drawer;
        this.element = element;
        this.renderer = renderer;
    }
    get disabledClass() {
        return this.item.disabled;
    }
    get selectedClass() {
        return this.drawer.selectedIndices.indexOf(this.index) >= 0;
    }
    get label() {
        return this.item.text ? this.item.text : null;
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        const link = nestedLink(this.element.nativeElement, DRAWER_LINK_SELECTOR);
        if (link) {
            this.renderer.removeAttribute(link, 'tabindex');
        }
    }
    /**
     * @hidden
     */
    get iconClasses() {
        const classes = [];
        if (this.item.icon) {
            classes.push(`k-icon ${this.item.icon}`);
        }
        if (this.item.iconClass) {
            classes.push(`${this.item.iconClass}`);
        }
        return classes;
    }
};
DrawerItemComponent.ɵfac = function DrawerItemComponent_Factory(t) { return new (t || DrawerItemComponent)(ɵngcc0.ɵɵdirectiveInject(DrawerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
DrawerItemComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DrawerItemComponent, selectors: [["", "kendoDrawerItem", ""]], hostVars: 7, hostBindings: function DrawerItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabledClass)("aria-selected", ctx.selectedClass)("aria-label", ctx.label);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass)("k-state-selected", ctx.selectedClass);
    } }, inputs: { item: "item", index: "index", itemTemplate: "itemTemplate", mini: "mini", expanded: "expanded", disabled: "disabled", cssClass: "cssClass", cssStyle: "cssStyle" }, attrs: _c23, decls: 3, vars: 2, consts: [[4, "ngIf", "ngIfElse"], ["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngIf"], [3, "ngClass"], [1, "k-item-text"]], template: function DrawerItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DrawerItemComponent_0_Template, 1, 4, null, 0);
        ɵngcc0.ɵɵtemplate(1, DrawerItemComponent_ng_template_1_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.itemTemplate)("ngIfElse", _r1);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], DrawerItemComponent.prototype, "item", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DrawerItemComponent.prototype, "index", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], DrawerItemComponent.prototype, "itemTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DrawerItemComponent.prototype, "mini", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DrawerItemComponent.prototype, "expanded", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DrawerItemComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DrawerItemComponent.prototype, "cssClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DrawerItemComponent.prototype, "cssStyle", void 0);
__decorate([
    HostBinding('attr.aria-disabled'),
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DrawerItemComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('attr.aria-selected'),
    HostBinding('class.k-state-selected'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DrawerItemComponent.prototype, "selectedClass", null);
__decorate([
    HostBinding('attr.aria-label'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DrawerItemComponent.prototype, "label", null);
DrawerItemComponent = __decorate([ __metadata("design:paramtypes", [DrawerService, ElementRef, Renderer2])
], DrawerItemComponent);

/**
 * @hidden
 */
const DRAWER_ITEM_INDEX = 'data-kendo-drawer-index';

/**
 * @hidden
 */
let DrawerListComponent = class DrawerListComponent {
    constructor(drawerService, renderer, ngZone, changeDetector, element) {
        this.drawerService = drawerService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.element = element;
        this.subscriptions = new Subscription();
    }
    ngOnInit() {
        this.initialSelection();
        this.initDomEvents();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    initialSelection() {
        /* Differentiates a user selected item */
        if (this.drawerService.selectedIndices.length === 0) {
            this.drawerService.initSelection();
        }
    }
    initDomEvents() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            const nativeElement = this.element.nativeElement;
            this.subscriptions.add(this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this)));
            this.subscriptions.add(this.renderer.listen(nativeElement, 'keydown', this.keyDownHandler.bind(this)));
        });
    }
    clickHandler(e) {
        const itemIdx = this.getDrawerItemIndex(e.target);
        const item = this.items[itemIdx];
        if (!item) {
            return;
        }
        if (item.disabled) {
            e.preventDefault();
            return;
        }
        const args = {
            index: itemIdx,
            item: item,
            originalEvent: e
        };
        this.ngZone.run(() => {
            if (!this.drawerService.emit('select', args)) {
                this.drawerService.onSelect(itemIdx);
                this.changeDetector.detectChanges();
            }
        });
    }
    keyDownHandler(e) {
        const isEnterOrSpace = e.keyCode === Keys.Enter || e.keyCode === Keys.Space;
        if (!isEnterOrSpace) {
            return;
        }
        this.clickHandler(e);
        const link = nestedLink(this.element.nativeElement, ACTIVE_NESTED_LINK_SELECTOR);
        if (link) {
            link.click();
        }
        return false;
    }
    getDrawerItemIndex(target) {
        const item = closestItem(target, DRAWER_ITEM_INDEX, this.element.nativeElement);
        if (item) {
            return itemIndex(item, DRAWER_ITEM_INDEX);
        }
    }
};
DrawerListComponent.ɵfac = function DrawerListComponent_Factory(t) { return new (t || DrawerListComponent)(ɵngcc0.ɵɵdirectiveInject(DrawerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
DrawerListComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DrawerListComponent, selectors: [["", "kendoDrawerList", ""]], inputs: { items: "items", itemTemplate: "itemTemplate", mini: "mini", expanded: "expanded" }, attrs: _c24, decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["kendoDrawerItem", "", "class", "k-drawer-item", "tabindex", "0", 3, "item", "index", "mini", "expanded", "itemTemplate", "ngClass", "ngStyle", 4, "ngIf"], ["class", "k-drawer-item k-drawer-separator", 3, "ngClass", "ngStyle", 4, "ngIf"], ["kendoDrawerItem", "", "tabindex", "0", 1, "k-drawer-item", 3, "item", "index", "mini", "expanded", "itemTemplate", "ngClass", "ngStyle"], [1, "k-drawer-item", "k-drawer-separator", 3, "ngClass", "ngStyle"]], template: function DrawerListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DrawerListComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, DrawerItemComponent, ɵngcc1.NgClass, ɵngcc1.NgStyle], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], DrawerListComponent.prototype, "items", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], DrawerListComponent.prototype, "itemTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DrawerListComponent.prototype, "mini", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DrawerListComponent.prototype, "expanded", void 0);
DrawerListComponent = __decorate([ __metadata("design:paramtypes", [DrawerService,
        Renderer2,
        NgZone,
        ChangeDetectorRef,
        ElementRef])
], DrawerListComponent);

const templateDirectives = [
    DrawerTemplateDirective,
    DrawerHeaderTemplateDirective,
    DrawerFooterTemplateDirective,
    DrawerItemTemplateDirective
];
const exportedModules$2 = [
    DrawerComponent,
    DrawerContainerComponent,
    DrawerContentComponent,
    ...templateDirectives
];
const declarations$2 = [
    DrawerItemComponent,
    DrawerListComponent,
    ...exportedModules$2
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Drawer component.
 */
let DrawerModule = class DrawerModule {
};
DrawerModule.ɵfac = function DrawerModule_Factory(t) { return new (t || DrawerModule)(); };
DrawerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DrawerModule });
DrawerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

const exportedModules$3 = [
    ExpansionPanelComponent,
    ExpansionPanelTitleDirective
];
const declarations$3 = [
    ...exportedModules$3
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the ExpansionPanel component.
 */
let ExpansionPanelModule = class ExpansionPanelModule {
};
ExpansionPanelModule.ɵfac = function ExpansionPanelModule_Factory(t) { return new (t || ExpansionPanelModule)(); };
ExpansionPanelModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ExpansionPanelModule });
ExpansionPanelModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, EventsModule]] });

const exportedModules$4 = [
    PanelBarComponent,
    PanelBarItemComponent,
    PanelBarContentDirective,
    PanelBarItemTemplateDirective,
    PanelBarItemTitleDirective
];
const declarations$4 = [
    ...exportedModules$4
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the PanelBar component.
 *
 * The module registers:
 * - `PanelBarComponent`&mdash;The `PanelBar` component class.
 * - `PanelBarItemComponent`&mdash;The `PanelBarItem` component class.
 * - `PanelBarContentComponent`&mdash;The `PanelBarContent` component class.
 * - `PanelBarItemTemplateDirective&mdash;The `PanelBarItemTemplate` directive.
 * - `PanelBarItemTitleDirective&mdash;The `PanelBarItemTitle` directive.
 */
let PanelBarModule = class PanelBarModule {
};
PanelBarModule.ɵfac = function PanelBarModule_Factory(t) { return new (t || PanelBarModule)(); };
PanelBarModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: PanelBarModule });
PanelBarModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

const exportedModules$5 = [
    SplitterComponent,
    SplitterPaneComponent
];
const declarations$5 = [
    SplitterBarComponent,
    ...exportedModules$5
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Splitter component.
 *
 * The module registers:
 * - `SplitterComponent`&mdash;The `Splitter` component class.
 * - `SplitterPaneComponent`&mdash;The `SplitterPane` component class.
 */
let SplitterModule = class SplitterModule {
};
SplitterModule.ɵfac = function SplitterModule_Factory(t) { return new (t || SplitterModule)(); };
SplitterModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: SplitterModule });
SplitterModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            DraggableModule
        ]] });

/**
 * @hidden
 */
let StepperStepComponent = class StepperStepComponent {
    constructor(service, localization, ngZone) {
        this.service = service;
        this.localization = localization;
        this.ngZone = ngZone;
        this.isStepValid = undefined;
        this.shouldCheckValidity = undefined;
        validatePackage(packageMetadata);
        this.subs = this.service.focusedStepChange.subscribe(() => {
            this.onFocusedStepChange();
        });
        this.subs.add(this.service.triggerValidation.subscribe(() => {
            this.handleValidityChecks();
        }));
    }
    get errorStepClass() {
        if (isPresent(this.isStepValid)) {
            return !this.isStepValid;
        }
        return false;
    }
    get successStepClass() {
        if (isPresent(this.isStepValid)) {
            return this.isStepValid;
        }
        return false;
    }
    ngOnInit() {
        this.handleValidityChecks();
    }
    ngOnChanges(changes) {
        if (changes.current && !changes.current.firstChange) {
            this.handleValidityChecks();
        }
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    onFocusedStepChange() {
        this.ngZone.runOutsideAngular(() => {
            if (this.index === this.service.focusedStep) {
                this.stepLink.nativeElement.focus();
            }
        });
    }
    onFocus() {
        this.service.focus(this.index);
    }
    get tabIndexAttr() {
        const active = this.service.focusedStep || this.service.currentStep;
        return this.index === active ? 0 : -1;
    }
    get indicatorIconClasses() {
        if (this.step.icon) {
            return `k-icon k-i-${this.step.icon}`;
        }
        if (this.step.iconClass) {
            return `${this.step.iconClass}`;
        }
        if (this.shouldCheckValidity) {
            return this.validationIconClasses;
        }
    }
    get showIndicatorIcon() {
        if (this.shouldCheckValidity) {
            return true;
        }
        if (this.step.icon || this.step.iconClass) {
            return true;
        }
        return false;
    }
    get showLabelIcon() {
        if (this.shouldCheckValidity) {
            if (this.type === 'label') {
                return true;
            }
            if (this.step.icon || this.step.iconClass) {
                return true;
            }
        }
        return false;
    }
    get showLabelText() {
        return this.type === 'label' || this.type === 'full';
    }
    get validationIconClasses() {
        if (this.isStepValid) {
            return this.successIcon ? `${this.successIcon}` : 'k-icon k-i-check';
        }
        else {
            return this.errorIcon ? `${this.errorIcon}` : 'k-icon k-i-warning';
        }
    }
    get indicatorText() {
        const text = this.step.text;
        return text ? text : this.index + 1;
    }
    updateStepValidity() {
        if (typeof this.step.isValid === 'boolean') {
            return this.step.isValid;
        }
        if (typeof this.step.isValid === 'function') {
            return this.step.isValid(this.index);
        }
        return undefined;
    }
    get showIndicator() {
        return this.type === 'indicator' || this.type === 'full';
    }
    get showLabel() {
        if (this.type === 'label' || this.type === 'full') {
            return true;
        }
        return this.step.optional;
    }
    get optionalText() {
        return this.localization.get('optional');
    }
    get transitionDuration() {
        return this.service.owner.animationDuration;
    }
    _shouldCheckValidity() {
        if (isPresent(this.step.validate)) {
            if (typeof this.step.validate === 'boolean') {
                return this.step.validate;
            }
            if (typeof this.step.validate === 'function') {
                return this.step.validate(this.index);
            }
        }
        return isPresent(this.step.isValid) && this.index < this.current;
    }
    handleValidityChecks() {
        this.isStepValid = undefined;
        this.shouldCheckValidity = this._shouldCheckValidity();
        if (this.shouldCheckValidity) {
            this.isStepValid = this.updateStepValidity();
        }
    }
};
StepperStepComponent.ɵfac = function StepperStepComponent_Factory(t) { return new (t || StepperStepComponent)(ɵngcc0.ɵɵdirectiveInject(StepperService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
StepperStepComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: StepperStepComponent, selectors: [["", "kendoStepperStep", ""]], viewQuery: function StepperStepComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c25, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepLink = _t.first);
    } }, hostVars: 4, hostBindings: function StepperStepComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-step-error", ctx.errorStepClass)("k-step-success", ctx.successStepClass);
    } }, inputs: { step: "step", index: "index", current: "current", type: "type", successIcon: "successIcon", errorIcon: "errorIcon", indicatorTemplate: "indicatorTemplate", labelTemplate: "labelTemplate", stepTemplate: "stepTemplate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c26, decls: 4, vars: 6, consts: [["href", "#", 1, "k-step-link", 3, "focus"], ["stepLink", ""], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "k-step-indicator", "aria-hidden", "true", 3, "transition-duration", 4, "ngIf"], ["class", "k-step-label", 4, "ngIf"], ["aria-hidden", "true", 1, "k-step-indicator"], ["class", "k-step-indicator-icon", 3, "ngClass", 4, "ngIf"], ["class", "k-step-indicator-text", 4, "ngIf"], [1, "k-step-indicator-icon", 3, "ngClass"], [1, "k-step-indicator-text"], [1, "k-step-label"], ["class", "k-step-text", 4, "ngIf"], ["aria-hidden", "true", 3, "ngClass", 4, "ngIf"], ["class", "k-step-label-optional", 4, "ngIf"], [1, "k-step-text"], ["aria-hidden", "true", 3, "ngClass"], [1, "k-step-label-optional"]], template: function StepperStepComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0, 1);
        ɵngcc0.ɵɵlistener("focus", function StepperStepComponent_Template_a_focus_0_listener() { return ctx.onFocus(); });
        ɵngcc0.ɵɵtemplate(2, StepperStepComponent_2_Template, 1, 5, null, 2);
        ɵngcc0.ɵɵtemplate(3, StepperStepComponent_ng_container_3_Template, 3, 2, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabIndexAttr)("title", ctx.step.label)("aria-disabled", ctx.step.disabled)("aria-current", ctx.index === ctx.current ? "step" : null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.stepTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.stepTemplate);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], StepperStepComponent.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], StepperStepComponent.prototype, "index", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], StepperStepComponent.prototype, "current", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperStepComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperStepComponent.prototype, "successIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperStepComponent.prototype, "errorIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], StepperStepComponent.prototype, "indicatorTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], StepperStepComponent.prototype, "labelTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], StepperStepComponent.prototype, "stepTemplate", void 0);
__decorate([
    ViewChild('stepLink', { static: true }),
    __metadata("design:type", ElementRef)
], StepperStepComponent.prototype, "stepLink", void 0);
__decorate([
    HostBinding('class.k-step-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], StepperStepComponent.prototype, "errorStepClass", null);
__decorate([
    HostBinding('class.k-step-success'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], StepperStepComponent.prototype, "successStepClass", null);
StepperStepComponent = __decorate([ __metadata("design:paramtypes", [StepperService,
        LocalizationService,
        NgZone])
], StepperStepComponent);

/**
 * @hidden
 */
const STEPPER_STEP_INDEX = 'data-kendo-stepper-index';

/**
 * @hidden
 */
let StepperListComponent = class StepperListComponent {
    constructor(renderer, ngZone, service, element) {
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.service = service;
        this.element = element;
    }
    ngOnInit() {
        this.initDomEvents();
    }
    ngOnDestroy() {
        if (this.domSubs) {
            this.domSubs();
        }
    }
    get maxStepWidth() {
        return this.maxStepDimension('width');
    }
    get maxStepHeight() {
        return this.maxStepDimension('height');
    }
    maxStepDimension(dimension) {
        if (dimension === 'width' && this.orientation === 'vertical') {
            return null;
        }
        if (dimension === 'height' && this.orientation === 'horizontal') {
            return null;
        }
        return 100 / this.steps.length;
    }
    initDomEvents() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            const nativeElement = this.element.nativeElement;
            const clickSubscription = this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this));
            const keydownSubscription = this.renderer.listen(nativeElement, 'keydown', (e) => {
                if (hasClass(e.target, 'k-step-link')) {
                    this.service.keydown(e);
                }
            });
            this.domSubs = () => {
                clickSubscription();
                keydownSubscription();
            };
        });
    }
    clickHandler(e) {
        e.preventDefault();
        const stepIdx = this.getStepIndex(e.target);
        const step = this.steps[stepIdx];
        if (!step || step.disabled) {
            return;
        }
        if (stepIdx === this.currentStep) {
            this.service.focus(stepIdx);
            return;
        }
        if (this.linear && this.service.isPrevOrNextStep(stepIdx) === false) {
            return;
        }
        this.service.onActivate(stepIdx, e);
    }
    getStepIndex(target) {
        const step = closestItem(target, STEPPER_STEP_INDEX, this.element.nativeElement);
        if (step) {
            return itemIndex(step, STEPPER_STEP_INDEX);
        }
    }
};
StepperListComponent.ɵfac = function StepperListComponent_Factory(t) { return new (t || StepperListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(StepperService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
StepperListComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: StepperListComponent, selectors: [["", "kendoStepperList", ""]], inputs: { linear: "linear", stepType: "stepType", orientation: "orientation", currentStep: "currentStep", steps: "steps", successIcon: "successIcon", errorIcon: "errorIcon", indicatorTemplate: "indicatorTemplate", labelTemplate: "labelTemplate", stepTemplate: "stepTemplate" }, attrs: _c28, decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["kendoStepperStep", "", 1, "k-step", 3, "type", "step", "index", "current", "successIcon", "errorIcon", "indicatorTemplate", "labelTemplate", "stepTemplate", "ngClass", "ngStyle"]], template: function StepperListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, StepperListComponent_ng_container_0_Template, 2, 28, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.steps);
    } }, directives: [ɵngcc1.NgForOf, StepperStepComponent, ɵngcc1.NgClass, ɵngcc1.NgStyle], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], StepperListComponent.prototype, "linear", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperListComponent.prototype, "stepType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperListComponent.prototype, "orientation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], StepperListComponent.prototype, "currentStep", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], StepperListComponent.prototype, "steps", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperListComponent.prototype, "successIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StepperListComponent.prototype, "errorIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], StepperListComponent.prototype, "indicatorTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], StepperListComponent.prototype, "labelTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], StepperListComponent.prototype, "stepTemplate", void 0);
StepperListComponent = __decorate([ __metadata("design:paramtypes", [Renderer2,
        NgZone,
        StepperService,
        ElementRef])
], StepperListComponent);

const templateDirectives$1 = [
    StepperStepTemplateDirective,
    StepperLabelTemplateDirective,
    StepperIndicatorTemplateDirective
];
const exportedModules$6 = [
    StepperComponent,
    StepperCustomMessagesComponent,
    ...templateDirectives$1
];
const declarations$6 = [
    StepperStepComponent,
    StepperListComponent,
    LocalizedStepperMessagesDirective,
    ...exportedModules$6
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Stepper component.
 */
let StepperModule = class StepperModule {
};
StepperModule.ɵfac = function StepperModule_Factory(t) { return new (t || StepperModule)(); };
StepperModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: StepperModule });
StepperModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, ProgressBarModule]] });

/**
 * @hidden
 */
let TabComponent = class TabComponent {
    constructor(localization, tabstripService) {
        this.localization = localization;
        this.tabstripService = tabstripService;
        this.hostClasses = true;
    }
    get activeClass() {
        return this.tab.selected;
    }
    get disabledClass() {
        return this.tab.disabled;
    }
    get focusedClass() {
        return this.tab.focused;
    }
    get tabIndex() {
        return this.tab.selected || this.tab.focused ? 0 : -1;
    }
    get tabClosable() {
        if (this.tab.closable !== undefined) {
            return this.tab.closable;
        }
        return this.tabStripClosable;
    }
    get closeButtonClasses() {
        if (isPresent(this.tab.closeIcon)) {
            return this.tab.closeIcon;
        }
        return this.tabStripCloseIcon;
    }
    get closeButtonTitle() {
        return this.localization.get('closeTitle');
    }
    closeTab(index) {
        this.tabstripService.onTabClose(this.tab, index);
    }
};
TabComponent.ɵfac = function TabComponent_Factory(t) { return new (t || TabComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(TabStripService)); };
TabComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TabComponent, selectors: [["", "kendoTabStripTab", ""]], hostVars: 13, hostBindings: function TabComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-selected", ctx.activeClass)("aria-disabled", ctx.disabledClass)("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵclassProp("k-item", ctx.hostClasses)("k-state-default", ctx.hostClasses)("k-state-active", ctx.activeClass)("k-state-disabled", ctx.disabledClass)("k-state-focused", ctx.focusedClass);
    } }, inputs: { tab: "tab", index: "index", tabStripClosable: "tabStripClosable", tabStripCloseIcon: "tabStripCloseIcon" }, attrs: _c29, decls: 3, vars: 3, consts: [["class", "k-link", 4, "ngIf"], ["class", "k-remove-tab k-button k-icon-button k-flat", "role", "button", 3, "title", "click", 4, "ngIf"], [1, "k-link"], [3, "ngTemplateOutlet"], ["role", "button", 1, "k-remove-tab", "k-button", "k-icon-button", "k-flat", 3, "title", "click"], [3, "ngClass"]], template: function TabComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TabComponent_span_0_Template, 2, 1, "span", 0);
        ɵngcc0.ɵɵtemplate(1, TabComponent_span_1_Template, 2, 1, "span", 0);
        ɵngcc0.ɵɵtemplate(2, TabComponent_span_2_Template, 2, 3, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tab.tabTitle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tab.tabTitle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tabClosable);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", TabStripTabComponent)
], TabComponent.prototype, "tab", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TabComponent.prototype, "index", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TabComponent.prototype, "tabStripClosable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TabComponent.prototype, "tabStripCloseIcon", void 0);
__decorate([
    HostBinding('class.k-item'),
    HostBinding('class.k-state-default'),
    __metadata("design:type", Boolean)
], TabComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('attr.aria-selected]'),
    HostBinding('class.k-state-active'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TabComponent.prototype, "activeClass", null);
__decorate([
    HostBinding('attr.aria-disabled]'),
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TabComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('class.k-state-focused'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TabComponent.prototype, "focusedClass", null);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], TabComponent.prototype, "tabIndex", null);
TabComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        TabStripService])
], TabComponent);

const exportedModules$7 = [
    TabStripComponent,
    TabStripTabComponent,
    TabContentDirective,
    TabTitleDirective,
    TabComponent,
    TabStripCustomMessagesComponent,
    LocalizedTabStripMessagesDirective
];
const declarations$7 = [
    ...exportedModules$7,
    TabStripScrollableButtonComponent
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TabStrip component.
 *
 * The module registers:
 * - `TabStripComponent`&mdash;The `TabStrip` component class.
 * - `TabStripTabComponent`&mdash;The `TabStripTab` component class.
 * - `TabContentDirective`&mdash;The tab content directive used on the `<ng-template>` tag.
 * - `TabTitleDirective`&mdash;The tab title directive used on the `<ng-template>` tag.
 */
let TabStripModule = class TabStripModule {
};
TabStripModule.ɵfac = function TabStripModule_Factory(t) { return new (t || TabStripModule)(); };
TabStripModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: TabStripModule });
TabStripModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, ResizeSensorModule]] });

/**
 * @hidden
 */
let TileLayoutResizeHandleDirective = class TileLayoutResizeHandleDirective {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
    }
    ngOnInit() {
        this.sizeHandle();
    }
    setHorizontalPosition(element) {
        this.renderer.setStyle(element, this.rtl ? 'left' : 'right', -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapX + 'px');
    }
    setBottom(element) {
        this.renderer.setStyle(element, 'bottom', -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapY + 'px');
    }
    sizeHandle() {
        const element = this.el.nativeElement;
        const handleWidth = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width ?
            `${RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width}px` : '100%';
        const handleHeight = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height ?
            `${RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height}px` : '100%';
        this.renderer.setStyle(element, 'width', handleWidth);
        this.renderer.setStyle(element, 'height', handleHeight);
        if (this.resizeDirection === 'ew') {
            this.setHorizontalPosition(element);
        }
        else if (this.resizeDirection === 'ns') {
            this.setBottom(element);
        }
        else {
            this.setHorizontalPosition(element);
            this.setBottom(element);
        }
    }
};
TileLayoutResizeHandleDirective.ɵfac = function TileLayoutResizeHandleDirective_Factory(t) { return new (t || TileLayoutResizeHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
TileLayoutResizeHandleDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TileLayoutResizeHandleDirective, selectors: [["", "kendoTileLayoutResizeHandle", ""]], inputs: { resizeDirection: "resizeDirection", rtl: "rtl" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], TileLayoutResizeHandleDirective.prototype, "resizeDirection", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TileLayoutResizeHandleDirective.prototype, "rtl", void 0);
TileLayoutResizeHandleDirective = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2])
], TileLayoutResizeHandleDirective);

const exportedModules$8 = [
    TileLayoutComponent,
    TileLayoutItemComponent,
    TileLayoutItemHeaderComponent,
    TileLayoutItemBodyComponent,
    TileLayoutResizeHandleDirective
];
const declarations$8 = [
    ...exportedModules$8
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TileLayout component.
 *
 * The module registers:
 * - `TileLayoutComponent`&mdash;The `TileLayoutComponent` component class.
 * - `TileLayoutItemComponent`&mdash;The `TileLayoutItemComponent` component class.
 * - `TileLayoutItemHeaderComponent`&mdash;The `TileLayoutItemHeaderComponent` component class.
 * - `TileLayoutItemBodyComponent`&mdash;The `TileLayoutItemBodyComponent` component class.
 */
let TileLayoutModule = class TileLayoutModule {
};
TileLayoutModule.ɵfac = function TileLayoutModule_Factory(t) { return new (t || TileLayoutModule)(); };
TileLayoutModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: TileLayoutModule });
TileLayoutModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

/**
 * @hidden
 */
const VERTICAL_SUFFIX = {
    top: 'start',
    middle: 'center',
    bottom: 'end',
    stretch: 'stretch'
};
/**
 * @hidden
 */
const JUSTIFY_PREFIX = `k-justify-content`;
/**
 * @hidden
 */
const GRID_JUSTIFY_PREFIX = `k-justify-items`;
/**
 * @hidden
 */
const ALIGN_PREFIX = `k-align-items`;
/**
 * @hidden
 */
const normalizeGap = (gap) => {
    if (typeof gap === 'number' || typeof gap === 'string') {
        return { cols: gap, rows: gap };
    }
    else {
        let parsedGap = {};
        parsedGap.rows = gap.rows ? gap.rows : 0;
        parsedGap.cols = gap.cols ? gap.cols : 0;
        return parsedGap;
    }
};
/**
 * @hidden
 */
const generateGapStyle = (gap) => {
    if (gap.rows === gap.cols) {
        return typeof gap.rows === 'number' ? `${gap.rows}px` : gap.rows;
    }
    else {
        let rowStyle = `${typeof gap.rows === 'number' ? gap.rows + 'px' : gap.rows}`;
        let colStyle = `${typeof gap.cols === 'number' ? gap.cols + 'px' : gap.cols}`;
        return `${rowStyle} ${colStyle}`;
    }
};
/**
 * @hidden
 */
const generateGridStyle = (items, itemType) => {
    let styling = [];
    items.forEach((item) => {
        if (typeof item === 'number') {
            styling.push(`${item}px`);
        }
        else if (typeof item === 'string') {
            styling.push(item);
        }
        else {
            if (itemType === 'rows') {
                const rowHeight = item.height;
                if (rowHeight) {
                    styling.push(typeof rowHeight === 'number' ? `${rowHeight}px` : rowHeight);
                }
                else {
                    styling.push('0px');
                }
            }
            else {
                const colWidth = item.width;
                if (colWidth) {
                    styling.push(typeof colWidth === 'number' ? `${colWidth}px` : colWidth);
                }
                else {
                    styling.push('0px');
                }
            }
        }
    });
    return styling;
};
/**
 * @hidden
 */
const validateGridLayoutRowsCols = (arr) => {
    for (const el of arr) {
        const isNum = typeof el === 'number';
        const isStr = typeof el === 'string';
        const isObject = typeof el === 'object' && el !== null;
        if (!isNum && !isStr && !isObject) {
            return false;
        }
    }
    return true;
};

/**
 * Represents the [Kendo UI StackLayout component for Angular]({% slug overview_stacklayout %}).
 */
let StackLayoutComponent = class StackLayoutComponent {
    constructor(renderer, element, localization) {
        this.renderer = renderer;
        this.element = element;
        this.localization = localization;
        this.hostClass = true;
        /**
         * Specifies the gap between the inner StackLayout elements. The default value is `0`
         * ([see example]({% slug layout_stacklayout %}#toc-gaps)).
         */
        this.gap = 0;
        /**
         * Specifies the orientation of the StackLayout
         * ([see example]({% slug layout_stacklayout %}#toc-orientation)).
         *
         * The possible values are:
         * (Default) `horizontal`
         * `vertical`
         */
        this.orientation = 'horizontal';
        this._align = {
            horizontal: 'stretch',
            vertical: 'stretch'
        };
        validatePackage(packageMetadata);
    }
    get horizontalClass() {
        return this.orientation === 'horizontal';
    }
    get verticalClass() {
        return this.orientation === 'vertical';
    }
    get dir() {
        return this.direction;
    }
    /**
     * Specifies the horizontal and vertical alignment of the inner StackLayout elements
     * ([see example]({% slug layout_stacklayout %}#toc-alignment)).
     */
    set align(align) {
        this._align = Object.assign({}, this._align, align);
        this.handleAlignClasses();
    }
    get align() {
        return this._align;
    }
    ngAfterViewInit() {
        this.handleAlignClasses();
        this.setGap();
    }
    ngOnChanges(changes) {
        if (isChanged('gap', changes)) {
            this.setGap();
        }
        if (isChanged('orientation', changes)) {
            this.handleAlignClasses();
        }
    }
    handleAlignClasses() {
        const elem = this.element.nativeElement;
        if (isPresent(this.justifyClass)) {
            this.renderer.removeClass(elem, this.justifyClass);
        }
        if (isPresent(this.alignClass)) {
            this.renderer.removeClass(elem, this.alignClass);
        }
        if (this.orientation === 'horizontal') {
            this.justifyClass = `${JUSTIFY_PREFIX}-${this.align.horizontal}`;
            this.alignClass = `${ALIGN_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;
        }
        else {
            this.justifyClass = `${JUSTIFY_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;
            this.alignClass = `${ALIGN_PREFIX}-${this.align.horizontal}`;
        }
        this.renderer.addClass(elem, this.justifyClass);
        this.renderer.addClass(elem, this.alignClass);
    }
    setGap() {
        const parsedGap = isNumber(this.gap) ? `${this.gap}px` : this.gap;
        this.renderer.setStyle(this.element.nativeElement, 'gap', parsedGap);
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
};
StackLayoutComponent.ɵfac = function StackLayoutComponent_Factory(t) { return new (t || StackLayoutComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
StackLayoutComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: StackLayoutComponent, selectors: [["kendo-stacklayout"]], hostVars: 7, hostBindings: function StackLayoutComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-stack-layout", ctx.hostClass)("k-hstack", ctx.horizontalClass)("k-vstack", ctx.verticalClass);
    } }, inputs: { gap: "gap", orientation: "orientation", align: "align" }, exportAs: ["kendoStackLayout"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.stacklayout'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c9, decls: 1, vars: 0, template: function StackLayoutComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-stack-layout'),
    __metadata("design:type", Boolean)
], StackLayoutComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('class.k-hstack'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], StackLayoutComponent.prototype, "horizontalClass", null);
__decorate([
    HostBinding('class.k-vstack'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], StackLayoutComponent.prototype, "verticalClass", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], StackLayoutComponent.prototype, "dir", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], StackLayoutComponent.prototype, "align", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], StackLayoutComponent.prototype, "gap", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StackLayoutComponent.prototype, "orientation", void 0);
StackLayoutComponent = __decorate([ __metadata("design:paramtypes", [Renderer2,
        ElementRef,
        LocalizationService])
], StackLayoutComponent);

const exportedModules$9 = [
    StackLayoutComponent
];
const declarations$9 = [
    ...exportedModules$9
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the StackLayout component.
 */
let StackLayoutModule = class StackLayoutModule {
};
StackLayoutModule.ɵfac = function StackLayoutModule_Factory(t) { return new (t || StackLayoutModule)(); };
StackLayoutModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: StackLayoutModule });
StackLayoutModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

/**
 * Represents the [Kendo UI GridLayout component for Angular]({% slug overview_gridlayout %}).
 */
let GridLayoutComponent = class GridLayoutComponent {
    constructor(renderer, element, localization) {
        this.renderer = renderer;
        this.element = element;
        this.localization = localization;
        this.hostClass = true;
        /**
         * Specifies the gaps between the elements. The default value is `0`
         * ([see example]({% slug layout_gridlayout %}#toc-gaps)).
         */
        this.gap = 0;
        this._align = {
            horizontal: 'stretch',
            vertical: 'stretch'
        };
        validatePackage(packageMetadata);
    }
    get dir() {
        return this.direction;
    }
    /**
     * Specifies the horizontal and vertical alignment of the inner GridLayout elements
     * ([see example]({% slug layout_gridlayout %}#toc-alignment)).
     */
    set align(align) {
        this._align = Object.assign({}, this._align, align);
        this.handleAlignClasses();
    }
    get align() {
        return this._align;
    }
    ngAfterViewInit() {
        this.handleAlignClasses();
        this.handleGridTemplateStyling('rows');
        this.handleGridTemplateStyling('cols');
        this.setGap();
    }
    ngOnChanges(changes) {
        if (isChanged('gap', changes)) {
            this.setGap();
        }
        if (isChanged('rows', changes)) {
            this.handleGridTemplateStyling('rows');
        }
        if (isChanged('cols', changes)) {
            this.handleGridTemplateStyling('cols');
        }
    }
    handleAlignClasses() {
        const elem = this.element.nativeElement;
        if (isPresent(this.justifyClass)) {
            this.renderer.removeClass(elem, this.justifyClass);
        }
        if (isPresent(this.alignClass)) {
            this.renderer.removeClass(elem, this.alignClass);
        }
        this.justifyClass = `${GRID_JUSTIFY_PREFIX}-${this.align.horizontal}`;
        this.alignClass = `${ALIGN_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;
        this.renderer.addClass(elem, this.justifyClass);
        this.renderer.addClass(elem, this.alignClass);
    }
    setGap() {
        let parsedGap = normalizeGap(this.gap);
        let gapStyle = generateGapStyle(parsedGap);
        this.renderer.setStyle(this.element.nativeElement, 'gap', gapStyle);
    }
    handleGridTemplateStyling(type) {
        if (!isPresent(this[type])) {
            return;
        }
        const isValid = validateGridLayoutRowsCols(this[type]);
        if (!isValid && isDevMode()) {
            const valueType = type === 'rows' ? 'GridLayoutRowSize' : 'GridLayoutColSize';
            throw new Error(`The provided ${type} value contains invalid elements. The array supports values of type number, string or ${valueType}.`);
        }
        const gridTemplateStyle = type === 'rows' ? 'grid-template-rows' : 'grid-template-columns';
        const gridStyle = generateGridStyle(this[type], type);
        this.renderer.setStyle(this.element.nativeElement, gridTemplateStyle, gridStyle.join(' '));
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
};
GridLayoutComponent.ɵfac = function GridLayoutComponent_Factory(t) { return new (t || GridLayoutComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
GridLayoutComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GridLayoutComponent, selectors: [["kendo-gridlayout"]], hostVars: 3, hostBindings: function GridLayoutComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-grid-layout", ctx.hostClass);
    } }, inputs: { gap: "gap", align: "align", rows: "rows", cols: "cols" }, exportAs: ["kendoGridLayout"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.gridlayout'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c9, decls: 1, vars: 0, template: function GridLayoutComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-grid-layout'),
    __metadata("design:type", Boolean)
], GridLayoutComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], GridLayoutComponent.prototype, "dir", null);
__decorate([
    Input(),
    __metadata("design:type", Array)
], GridLayoutComponent.prototype, "rows", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], GridLayoutComponent.prototype, "cols", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GridLayoutComponent.prototype, "gap", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], GridLayoutComponent.prototype, "align", null);
GridLayoutComponent = __decorate([ __metadata("design:paramtypes", [Renderer2,
        ElementRef,
        LocalizationService])
], GridLayoutComponent);

let GridLayoutItemComponent = class GridLayoutItemComponent {
    constructor(renderer, element) {
        this.renderer = renderer;
        this.element = element;
    }
    ngOnInit() {
        this.setItemStyle();
    }
    ngOnChanges() {
        this.setItemStyle();
    }
    setItemStyle() {
        const row = this.row || 'auto';
        const col = this.col || 'auto';
        const rowSpan = this.rowSpan ? `span ${this.rowSpan}` : 'auto';
        const colSpan = this.colSpan ? `span ${this.colSpan}` : 'auto';
        const gridAreaStyle = `${row} / ${col} / ${rowSpan} / ${colSpan}`;
        this.renderer.setStyle(this.element.nativeElement, 'grid-area', gridAreaStyle);
    }
};
GridLayoutItemComponent.ɵfac = function GridLayoutItemComponent_Factory(t) { return new (t || GridLayoutItemComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
GridLayoutItemComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GridLayoutItemComponent, selectors: [["kendo-gridlayout-item"]], inputs: { row: "row", col: "col", rowSpan: "rowSpan", colSpan: "colSpan" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c9, decls: 1, vars: 0, template: function GridLayoutItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], GridLayoutItemComponent.prototype, "row", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GridLayoutItemComponent.prototype, "col", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GridLayoutItemComponent.prototype, "rowSpan", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GridLayoutItemComponent.prototype, "colSpan", void 0);
GridLayoutItemComponent = __decorate([ __metadata("design:paramtypes", [Renderer2,
        ElementRef])
], GridLayoutItemComponent);

const exportedModules$a = [
    GridLayoutComponent,
    GridLayoutItemComponent
];
const declarations$a = [
    ...exportedModules$a
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the GridLayout component.
 */
let GridLayoutModule = class GridLayoutModule {
};
GridLayoutModule.ɵfac = function GridLayoutModule_Factory(t) { return new (t || GridLayoutModule)(); };
GridLayoutModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: GridLayoutModule });
GridLayoutModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Layout components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Layout module
 * import { LayoutModule } from '@progress/kendo-angular-layout';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, LayoutModule], // import Layout module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let LayoutModule = class LayoutModule {
};
LayoutModule.ɵfac = function LayoutModule_Factory(t) { return new (t || LayoutModule)(); };
LayoutModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: LayoutModule });
LayoutModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [AvatarModule, CardModule, DrawerModule, PanelBarModule, ExpansionPanelModule, SplitterModule, StepperModule, TabStripModule, TileLayoutModule, StackLayoutModule, GridLayoutModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PanelBarService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PanelBarContentDirective, [{
        type: Directive,
        args: [{
                selector: "[kendoPanelBarContent]"
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PanelBarItemTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoPanelBarItemTitle]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PanelBarItemComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('toggle', [
                        state('inactive', style({ display: 'none' })),
                        transition('* => active', [
                            style({ overflow: 'hidden', display: 'block', height: 0 }),
                            animate(200, style({ height: AUTO_STYLE }))
                        ]),
                        transition('active => *', [
                            style({ overflow: 'hidden', height: AUTO_STYLE }),
                            animate(200, style({ height: 0, display: 'none' }))
                        ])
                    ])
                ],
                exportAs: 'kendoPanelbarItem',
                selector: "kendo-panelbar-item",
                template: `
            <span
                #header
                [class.k-link]="true"
                [class.k-state-selected]="!disabled && selected"
                [class.k-state-focused]="focused && wrapperFocused"
                (click)="onItemClick($event)">
                <span
                    *ngIf="icon || iconClass"
                    class="k-icon k-panelbar-item-icon"
                    [ngClass]="iconClasses">
                </span>
                <img
                    *ngIf="imageUrl"
                    class="k-image k-panelbar-item-icon"
                    [src]="imageUrl"
                    alt="">
                <ng-container *ngIf="!titleTemplate"><span class="k-panelbar-item-text">{{title}}</span></ng-container>
                <ng-template *ngIf="titleTemplate"
                [ngTemplateOutlet]="titleTemplate"
                [ngTemplateOutletContext]="{
                    item: {
                        title: title,
                        id: id,
                        icon: icon,
                        iconClass: iconClass,
                        imageUrl: imageUrl,
                        selected: selected,
                        expanded: expanded,
                        disabled: disabled,
                        focused: focused,
                        content: content
                    }
                }"></ng-template>
                <span *ngIf="hasChildItems || hasContent"
                    class="k-icon k-panelbar-toggle"
                    [ngClass]="{'k-i-arrow-chevron-up k-panelbar-collapse': expanded, 'k-i-arrow-chevron-down k-panelbar-expand': !expanded}">
                </span>
            </span>
            <div #contentWrapper
                *ngIf="keepContent || (!disabled && expanded && (hasChildItems || hasContent))"
                [@toggle]="state"
                [attr.role]="'group'"
                [attr.aria-hidden]="!disabled && !expanded">
                <div
                    *ngIf="hasChildItems && !items?.length"
                    [style.overflow]="contentOverflow"
                    [style.height]="contentHeight"
                    class="k-panel k-group k-panelbar-group">
                        <ng-content select="kendo-panelbar-item"></ng-content>
                </div>
                <div
                    *ngIf="hasContent && !content"
                    [style.overflow]="contentOverflow"
                    [style.height]="contentHeight"
                    class="k-content k-panelbar-content">
                    <ng-template
                        [ngTemplateOutlet]="contentTemplate.first.templateRef"
                        [ngTemplateOutletContext]="{
                            $implicit: {
                                title: title,
                                id: id,
                                icon: icon,
                                imageUrl: imageUrl,
                                disabled: disabled,
                                content: content
                            }
                        }">
                    </ng-template>
                </div>
                <div *ngIf="hasItems"
                    [style.overflow]="contentOverflow"
                    [style.height]="contentHeight"
                    class="k-panel k-group k-panelbar-group">
                    <ng-container *ngFor="let item of items">
                        <kendo-panelbar-item *ngIf="!item.hidden"
                            [title]="item.title"
                            [id]="item.id"
                            [icon]="item.icon"
                            [iconClass]="item.iconClass"
                            [imageUrl]="item.imageUrl"
                            [selected]="!!item.selected"
                            [expanded]="!!item.expanded"
                            [disabled]="!!item.disabled"
                            [template]="template"
                            [items]="item.children"
                            [content]="item.content">
                        </kendo-panelbar-item>
                    </ng-container>
                </div>
                <div
                    *ngIf="content"
                    [style.overflow]="contentOverflow"
                    [style.height]="contentHeight"
                    class="k-content k-panelbar-content">
                    <ng-template
                        [ngTemplateOutlet]="template"
                        [ngTemplateOutletContext]="{
                            $implicit: {
                                title: title,
                                id: id,
                                icon: icon,
                                imageUrl: imageUrl,
                                disabled: disabled,
                                content: content
                            }
                        }">
                    </ng-template>
                    <ng-template [ngIf]="!template">{{content}}</ng-template>
                </div>
            </div>`
            }]
    }], function () { return [{ type: PanelBarItemComponent, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: PanelBarService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { id: [{
            type: Input
        }], icon: [{
            type: Input
        }], iconClass: [{
            type: Input
        }], imageUrl: [{
            type: Input
        }], disabled: [{
            type: Input
        }], selected: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], titleAttribute: [{
            type: HostBinding,
            args: ['attr.title']
        }], kItemClass: [{
            type: HostBinding,
            args: ['class.k-item']
        }], expanded: [{
            type: Input
        }], kStateDefaultClass: [{
            type: HostBinding,
            args: ['class.k-state-default']
        }], kStateDisabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], kStateExpandedClass: [{
            type: HostBinding,
            args: ['class.k-state-expanded']
        }], itemId: [{
            type: HostBinding,
            args: ['id']
        }], ariaExpanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], headerClass: [{
            type: HostBinding,
            args: ['class.k-panelbar-header']
        }], childClass: [{
            type: HostBinding,
            args: ['class.k-panelbar-item']
        }], title: [{
            type: Input
        }], content: [{
            type: Input
        }], items: [{
            type: Input
        }], template: [{
            type: Input
        }], header: [{
            type: ViewChild,
            args: ['header', { static: false }]
        }], contentWrapper: [{
            type: ViewChild,
            args: ['contentWrapper', { static: false }]
        }], viewChildItems: [{
            type: ViewChildren,
            args: [PanelBarItemComponent_1]
        }], contentItems: [{
            type: ContentChildren,
            args: [PanelBarItemComponent_1]
        }], contentTemplate: [{
            type: ContentChildren,
            args: [PanelBarContentDirective, { descendants: false }]
        }], titleTemplates: [{
            type: ContentChildren,
            args: [PanelBarItemTitleDirective, { descendants: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PanelBarItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoPanelBarItemTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PanelBarComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoPanelbar',
                providers: [
                    PanelBarService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.panelbar'
                    }
                ],
                selector: 'kendo-panelbar',
                template: `
        <ng-content *ngIf="contentChildItems && !items" select="kendo-panelbar-item"></ng-content>
        <ng-template [ngIf]="items?.length">
            <ng-container *ngFor="let item of items">
                <kendo-panelbar-item *ngIf="!item.hidden"
                    [title]="item.title"
                    [id]="item.id"
                    [icon]="item.icon"
                    [iconClass]="item.iconClass"
                    [imageUrl]="item.imageUrl"
                    [selected]="!!item.selected"
                    [expanded]="!!item.expanded"
                    [disabled]="!!item.disabled"
                    [template]="templateRef"
                    [items]="item.children"
                    [content]="item.content"
                >
                </kendo-panelbar-item>
            </ng-container>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: PanelBarService }, { type: ɵngcc2.LocalizationService }]; }, { expandMode: [{
            type: Input
        }], selectable: [{
            type: Input
        }], animate: [{
            type: Input
        }], height: [{
            type: Input
        }], stateChange: [{
            type: Output
        }], select: [{
            type: Output
        }], expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabIndex']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-panelbar']
        }], activeDescendant: [{
            type: HostBinding,
            args: ['attr.aria-activedescendant']
        }], keepItemContent: [{
            type: Input
        }], items: [{
            type: Input
        }], hostHeight: [{
            type: HostBinding,
            args: ['style.height']
        }], overflow: [{
            type: HostBinding,
            args: ['style.overflow']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], 
    /**
     * @hidden
     */
    onComponentClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], 
    /**
     * @hidden
     */
    onComponentFocus: [{
            type: HostListener,
            args: ['focus']
        }], 
    /**
     * @hidden
     */
    onComponentBlur: [{
            type: HostListener,
            args: ['blur']
        }], 
    /**
     * @hidden
     */
    onComponentKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], template: [{
            type: ContentChild,
            args: [PanelBarItemTemplateDirective, { static: false }]
        }], contentItems: [{
            type: ContentChildren,
            args: [PanelBarItemComponent, { descendants: true }]
        }], contentChildItems: [{
            type: ContentChildren,
            args: [PanelBarItemComponent]
        }], viewChildItems: [{
            type: ViewChildren,
            args: [PanelBarItemComponent]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitterPaneComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSplitterPane',
                selector: 'kendo-splitter-pane',
                template: `
        <ng-container *ngIf="!collapsed"><ng-content></ng-content></ng-container>
        <div *ngIf="overlayContent" class="k-splitter-overlay k-overlay"></div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { resizable: [{
            type: Input
        }], collapsible: [{
            type: Input
        }], scrollable: [{
            type: Input
        }], collapsed: [{
            type: Input
        }], orientation: [{
            type: Input
        }], overlayContent: [{
            type: Input
        }], sizeChange: [{
            type: Output
        }], collapsedChange: [{
            type: Output
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-pane']
        }], order: [{
            type: Input
        }], size: [{
            type: Input
        }], containsSplitter: [{
            type: Input
        }], staticPaneClass: [{
            type: HostBinding,
            args: ['class.k-pane-static']
        }], scrollablePaneClass: [{
            type: HostBinding,
            args: ['class.k-scrollable']
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitterService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitterBarComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-splitter-bar',
                template: `
      <div [class]="previousArrowClass()" (click)="togglePrevious()"></div>
      <div class="k-resize-handle"></div>
      <div [class]="nextArrowClass()" (click)="toggleNext()"></div>
    `
            }]
    }], function () { return [{ type: ɵngcc3.DraggableDirective, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ElementRef }, { type: SplitterService }, { type: ɵngcc2.LocalizationService }]; }, { orientation: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-orientation']
        }], index: [{
            type: Input
        }], ariaRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], focused: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }], order: [{
            type: HostBinding,
            args: ['style.-ms-flex-order']
        }, {
            type: HostBinding,
            args: ['style.order']
        }], collapseAny: [{
            type: HostListener,
            args: ['dblclick']
        }], onFocusIn: [{
            type: HostListener,
            args: ['focusin']
        }], onFocusOut: [{
            type: HostListener,
            args: ['focusout']
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitterComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSplitter',
                selector: 'kendo-splitter',
                providers: [
                    SplitterService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.spliter'
                    }
                ],
                template: `
      <ng-content select="kendo-splitter-pane"></ng-content>
      <ng-container *ngFor="
        let pane of panes;
        let index = index;
        let last = last;
      ">
        <kendo-splitter-bar
          kendoDraggable
          *ngIf="!last"
          [index]="index"
          [orientation]="orientation">
        </kendo-splitter-bar>
      </ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: SplitterService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.Renderer2 }, { type: SplitterPaneComponent, decorators: [{
                type: Optional
            }, {
                type: Host
            }, {
                type: Inject,
                args: [SplitterPaneComponent]
            }] }]; }, { orientation: [{
            type: Input
        }], ariaRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], layoutChange: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-splitter']
        }, {
            type: HostBinding,
            args: ['class.k-splitter-flex']
        }], horizontalHostClasses: [{
            type: HostBinding,
            args: ['class.k-splitter-horizontal']
        }], verticalHostClasses: [{
            type: HostBinding,
            args: ['class.k-splitter-vertical']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], splitbars: [{
            type: ViewChildren,
            args: [SplitterBarComponent]
        }], panes: [{
            type: ContentChildren,
            args: [SplitterPaneComponent]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabContentDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTabContent]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTabTitle]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabStripTabComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoTabStripTab',
                selector: 'kendo-tabstrip-tab',
                template: ``
            }]
    }], function () { return []; }, { disabled: [{
            type: Input
        }], _tabContent: [{
            type: ContentChildren,
            args: [TabContentDirective]
        }], title: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], cssStyle: [{
            type: Input
        }], selected: [{
            type: Input
        }], closable: [{
            type: Input
        }], closeIcon: [{
            type: Input
        }], _tabTitleDirective: [{
            type: ContentChildren,
            args: [TabTitleDirective]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabStripService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabStripScrollableButtonComponent, [{
        type: Component,
        args: [{
                template: `
        <span class="k-icon k-button-icon" [ngClass]="iconClass"></span>
    `,
                selector: '[kendoTabStripScrollableButton]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ScrollService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { btnClasses: [{
            type: HostBinding,
            args: ['class.k-button']
        }, {
            type: HostBinding,
            args: ['class.k-button-md']
        }, {
            type: HostBinding,
            args: ['class.k-icon-button']
        }, {
            type: HostBinding,
            args: ['class.k-rounded-md']
        }, {
            type: HostBinding,
            args: ['class.k-button-flat']
        }, {
            type: HostBinding,
            args: ['class.k-button-flat-base']
        }], prev: [{
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ['class.k-disabled']
        }], prevClass: [{
            type: HostBinding,
            args: ['class.k-tabstrip-prev']
        }], nextClass: [{
            type: HostBinding,
            args: ['class.k-tabstrip-next']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabStripComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('state', [
                        state('active', style({ opacity: 1 })),
                        transition('* => active', [
                            style({ opacity: 0 }),
                            animate('400ms ease-in')
                        ])
                    ])
                ],
                providers: [
                    TabStripService,
                    ScrollService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.tabstrip'
                    }
                ],
                exportAs: 'kendoTabStrip',
                selector: 'kendo-tabstrip',
                template: `
        <ng-container kendoTabStripLocalizedMessages
            i18n-closeTitle="kendo.tabstrip.closeTitle|The title for the **Close** button in the TabStrip tab."
            closeTitle="Close">
        </ng-container>
        <ng-container *ngIf="!tabsAtBottom">
            <ng-container *ngTemplateOutlet="heading">
            </ng-container>
            <ng-container *ngTemplateOutlet="content">
            </ng-container>
        </ng-container>

        <ng-container *ngIf="tabsAtBottom">
            <ng-container *ngTemplateOutlet="content">
            </ng-container>
            <ng-container *ngTemplateOutlet="heading">
            </ng-container>
        </ng-container>
        <ng-template #heading>
            <div class="k-tabstrip-items-wrapper" [ngClass]="itemsWrapperClass">
                <span *ngIf="hasScrollButtons"
                     #prevScrollButton
                    kendoTabStripScrollableButton
                    [prev]="true"></span>
                <ul role="tablist" #tablist
                    class="k-reset k-tabstrip-items"
                    [style.justifyContent]="tabsAlignmentStyles"
                    [style.width]="tabListWidth"
                    [style.height]="tabListHeight"
                >
                    <ng-container *ngFor="let tab of tabs; let i = index;">
                        <li *ngIf="!tab.closed"
                            #tabHeaderContainer
                            kendoTabStripTab
                            [ngClass]="tab.cssClass"
                            [ngStyle]="tab.cssStyle"
                            [tab]="tab"
                            [index]="i"
                            role="tab"
                            [tabStripClosable]="closable"
                            [tabStripCloseIcon]="closeIcon"
                            (click)="onTabClick($event, i)"
                            [id]="'k-tabstrip-tab-' + i"
                            [attr.aria-controls]="'k-tabstrip-tabpanel-' + i">
                        </li>
                    </ng-container>
                </ul>
                <span *ngIf="hasScrollButtons" #nextScrollButton
                    kendoTabStripScrollableButton
                    [prev]="false">
                </span>
            </div>
        </ng-template>
        <ng-template #content>
            <ng-template ngFor let-tab [ngForOf]="tabs" let-i="index">
                <div
                    [@state]="tab.selected && animate ? 'active' : 'inactive'"
                    *ngIf="!tab.closed && (tab.selected || keepTabContent)"
                    [ngClass]="!this.keepTabContent || tab.selected ? 'k-content k-state-active' : 'k-content'"
                    [tabIndex]="0"
                    role="tabpanel"
                    [id]="'k-tabstrip-tabpanel-' + i"
                    [attr.aria-hidden]="!tab.selected"
                    [attr.aria-expanded]="tab.selected"
                    [attr.aria-labelledby]="'k-tabstrip-tab-' + i"
                    [attr.aria-disabled]="tab.disabled"
                >
                    <ng-template [ngTemplateOutlet]="tab.tabContent?.templateRef">
                    </ng-template>
                </div>
            </ng-template>
        </ng-template>
        <kendo-resize-sensor *ngIf="isScrollable" (resize)="onResize()"></kendo-resize-sensor>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: TabStripService }, { type: ScrollService }, { type: ɵngcc0.NgZone }]; }, { animate: [{
            type: Input
        }], tabPosition: [{
            type: Input
        }], keepTabContent: [{
            type: Input
        }], closable: [{
            type: Input
        }], closeIcon: [{
            type: Input
        }], tabSelect: [{
            type: Output
        }], tabClose: [{
            type: Output
        }], tabScroll: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-tabstrip']
        }, {
            type: HostBinding,
            args: ['class.k-floatwrap']
        }], tabs: [{
            type: ContentChildren,
            args: [TabStripTabComponent]
        }], height: [{
            type: Input
        }], scrollable: [{
            type: Input
        }], tabsAtTop: [{
            type: HostBinding,
            args: ['class.k-tabstrip-top']
        }], tabsAtRight: [{
            type: HostBinding,
            args: ['class.k-tabstrip-right']
        }], tabsAtBottom: [{
            type: HostBinding,
            args: ['class.k-tabstrip-bottom']
        }], tabsAtLeft: [{
            type: HostBinding,
            args: ['class.k-tabstrip-left']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], tabStripScrollable: [{
            type: HostBinding,
            args: ['class.k-tabstrip-scrollable']
        }], tabAlignment: [{
            type: Input
        }], tablist: [{
            type: ViewChild,
            args: ['tablist', { static: false }]
        }], tabHeaderContainers: [{
            type: ViewChildren,
            args: ['tabHeaderContainer', { read: ElementRef }]
        }], prevScrollButton: [{
            type: ViewChild,
            args: ['prevScrollButton', { static: false }]
        }], nextScrollButton: [{
            type: ViewChild,
            args: ['nextScrollButton', { static: false }]
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizedTabStripMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: TabStripMessages,
                        useExisting: forwardRef(() => LocalizedTabStripMessagesDirective_1)
                    }
                ],
                selector: `[kendoTabStripLocalizedMessages]`
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabStripCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: TabStripMessages,
                        useExisting: forwardRef(() => TabStripCustomMessagesComponent_1)
                    }
                ],
                selector: 'kendo-tabstrip-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DrawerTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DrawerItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerItemTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DrawerHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerHeaderTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DrawerFooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DrawerService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DrawerComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoDrawer',
                providers: [
                    LocalizationService,
                    DrawerService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.drawer'
                    }
                ],
                selector: 'kendo-drawer',
                template: `
        <div class="k-drawer-wrapper" *ngIf="expanded || mini" [style.width.px]="drawerWidth">
            <ng-container *ngIf="!drawerTemplate">
                <ng-template *ngIf="headerTemplate"
                    [ngTemplateOutlet]="headerTemplate?.templateRef">
                </ng-template>

                <ul kendoDrawerList
                    [items]="items" [mini]="mini" [expanded]="expanded"
                    [itemTemplate]="itemTemplate?.templateRef"
                    class="k-drawer-items">
                </ul>

                <ng-template *ngIf="footerTemplate"
                    [ngTemplateOutlet]="footerTemplate?.templateRef">
                </ng-template>
            </ng-container>

            <ng-template *ngIf="drawerTemplate"
                [ngTemplateOutlet]="drawerTemplate?.templateRef">
            </ng-template>
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc4.AnimationBuilder }, { type: ɵngcc2.LocalizationService }, { type: DrawerService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-drawer']
        }], mode: [{
            type: Input
        }], position: [{
            type: Input
        }], mini: [{
            type: Input
        }], expanded: [{
            type: Input
        }], width: [{
            type: Input
        }], miniWidth: [{
            type: Input
        }], autoCollapse: [{
            type: Input
        }], animation: [{
            type: Input
        }], expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], select: [{
            type: Output
        }], expandedChange: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], startPositionClass: [{
            type: HostBinding,
            args: ['class.k-drawer-start']
        }], endPositionClass: [{
            type: HostBinding,
            args: ['class.k-drawer-end']
        }], overlayTransofrmStyles: [{
            type: HostBinding,
            args: ['style.transform']
        }], flexStyles: [{
            type: HostBinding,
            args: ['style.flexBasis.px']
        }], items: [{
            type: Input
        }], drawerTemplate: [{
            type: ContentChild,
            args: [DrawerTemplateDirective, { static: false }]
        }], footerTemplate: [{
            type: ContentChild,
            args: [DrawerFooterTemplateDirective, { static: false }]
        }], headerTemplate: [{
            type: ContentChild,
            args: [DrawerHeaderTemplateDirective, { static: false }]
        }], itemTemplate: [{
            type: ContentChild,
            args: [DrawerItemTemplateDirective, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DrawerContainerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-drawer-container',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.drawer.container'
                    }
                ],
                template: `
        <div class="k-overlay" *ngIf="overlay" (click)="closeDrawer()"></div>
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-drawer-container']
        }], overlayClass: [{
            type: HostBinding,
            args: ['class.k-drawer-overlay']
        }], miniClass: [{
            type: HostBinding,
            args: ['class.k-drawer-mini']
        }], pushClass: [{
            type: HostBinding,
            args: ['class.k-drawer-push']
        }], isExpandedClass: [{
            type: HostBinding,
            args: ['class.k-drawer-expanded']
        }], drawer: [{
            type: ContentChild,
            args: [DrawerComponent, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DrawerContentComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-drawer-content',
                template: `
        <ng-content></ng-content>
    `,
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return []; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-drawer-content']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepperStepTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoStepperStepTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepperLabelTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoStepperLabelTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepperIndicatorTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoStepperIndicatorTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepperService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepperComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoStepper',
                providers: [
                    LocalizationService,
                    StepperService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.stepper'
                    }
                ],
                selector: 'kendo-stepper',
                template: `
        <ng-container kendoStepperLocalizedMessages
            i18n-optional="kendo.stepper.optional|The text for the optional segment of the step label"
            optional="Optional"
         >
        </ng-container>
        <ol kendoStepperList
            [stepType]='stepType'
            [linear]='linear'
            [orientation]='orientation'
            [steps]='steps'
            [currentStep]='currentStep'
            [successIcon]='successIcon'
            [errorIcon]='errorIcon'
            [indicatorTemplate]='indicatorTemplate?.templateRef'
            [labelTemplate]='labelTemplate?.templateRef'
            [stepTemplate]='stepTemplate?.templateRef'
            class='k-step-list'
            [class.k-step-list-horizontal]='isHorizontal'
            [class.k-step-list-vertical]='!isHorizontal'
            [ngStyle]='stepsListStyling'>
        </ol>

        <kendo-progressbar *ngIf='steps.length > 0'
            [attr.aria-hidden]='true'
            [animation]='progressAnimation'
            [max]='steps.length - 1'
            [label]='false'
            [orientation]='orientation'
            [reverse]='!isHorizontal'
            [value]='currentStep'
            [ngStyle]='progressBarStyling'>
        </kendo-progressbar>
    `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc2.LocalizationService }, { type: StepperService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-stepper']
        }], ariaRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], displayStyle: [{
            type: HostBinding,
            args: ['style.display']
        }], stepType: [{
            type: Input
        }], linear: [{
            type: Input
        }], orientation: [{
            type: Input
        }], animation: [{
            type: Input
        }], activate: [{
            type: Output
        }], currentStepChange: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], linearClass: [{
            type: HostBinding,
            args: ['class.k-stepper-linear']
        }], currentStep: [{
            type: Input
        }], steps: [{
            type: Input
        }], successIcon: [{
            type: Input
        }], errorIcon: [{
            type: Input
        }], stepTemplate: [{
            type: ContentChild,
            args: [StepperStepTemplateDirective, { static: false }]
        }], labelTemplate: [{
            type: ContentChild,
            args: [StepperLabelTemplateDirective, { static: false }]
        }], indicatorTemplate: [{
            type: ContentChild,
            args: [StepperIndicatorTemplateDirective, { static: false }]
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepperCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: StepperMessages,
                        useExisting: forwardRef(() => StepperCustomMessagesComponent_1)
                    }
                ],
                selector: 'kendo-stepper-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizedStepperMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: StepperMessages,
                        useExisting: forwardRef(() => LocalizedStepperMessagesDirective_1)
                    }
                ],
                selector: `
      [kendoStepperLocalizedMessages]
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AvatarComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-avatar',
                template: `
        <ng-content *ngIf="customAvatar"></ng-content>

        <ng-container *ngIf="imageSrc">
            <span class="k-avatar-image">
                <img src="{{imageSrc}}" [ngStyle]="cssStyle" />
            </span>
        </ng-container>

        <ng-container *ngIf="initials">
            <span class="k-avatar-text" [ngStyle]="cssStyle">{{ initials.substring(0, 2) }}</span>
        </ng-container>

        <ng-container *ngIf="icon || iconClass">
            <span class="k-avatar-icon" [ngStyle]="cssStyle" [ngClass]="iconClasses()"></span>
        </ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-avatar']
        }], border: [{
            type: Input
        }], borderClass: [{
            type: HostBinding,
            args: ['class.k-avatar-bordered']
        }], flexBasis: [{
            type: HostBinding,
            args: ['style.flexBasis']
        }], shape: [{
            type: Input
        }], rounded: [{
            type: Input
        }], size: [{
            type: Input
        }], themeColor: [{
            type: Input
        }], fillMode: [{
            type: Input
        }], fill: [{
            type: Input
        }], avatarWidth: [{
            type: HostBinding,
            args: ['style.width']
        }], avatarHeight: [{
            type: HostBinding,
            args: ['style.height']
        }], iconClass: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], cssStyle: [{
            type: Input
        }], initials: [{
            type: Input
        }], icon: [{
            type: Input
        }], imageSrc: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.card.component'
                    }
                ],
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-card']
        }], orientation: [{
            type: Input
        }], width: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], widthStyle: [{
            type: HostBinding,
            args: ['style.width']
        }], vertical: [{
            type: HostBinding,
            args: ['class.k-card-vertical']
        }], horizontal: [{
            type: HostBinding,
            args: ['class.k-card-horizontal']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-header',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-header']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardBodyComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-body',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-body']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardFooterComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-footer',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-footer']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardActionsComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-actions',
                template: `
        <ng-content *ngIf="!actions"></ng-content>

        <ng-container *ngIf="!actionTemplate()">
            <button type="button"
                class="k-button"
                [class.k-primary]="action.primary"
                [class.k-flat]="action.flat"
                (click)="onClick(action)"
                *ngFor="let action of actions"
            >
                {{ action.text }}
            </button>
        </ng-container>

        <ng-template [ngTemplateOutlet]="actions" *ngIf="actionTemplate()"></ng-template>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-actions']
        }], orientation: [{
            type: Input
        }], layout: [{
            type: Input
        }], action: [{
            type: Output
        }], stretchedClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-stretched']
        }], startClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-start']
        }], endClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-end']
        }], centerClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-center']
        }], verticalClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-vertical']
        }], horizontalClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-horizontal']
        }], actions: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardSeparatorDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardSeparator]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-separator']
        }], orientation: [{
            type: Input
        }], verticalClass: [{
            type: HostBinding,
            args: ['class.k-separator-vertical']
        }], horizontalClass: [{
            type: HostBinding,
            args: ['class.k-separator-horizontal']
        }], color: [{
            type: HostBinding,
            args: ['style.color']
        }, {
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardTitle]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-title']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardSubtitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardSubtitle]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-subtitle']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardMediaDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardMedia]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-media']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExpansionPanelTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExpansionPanelTitleDirective]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExpansionPanelComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoExpansionPanel',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.expansionpanel'
                    }
                ],
                selector: 'kendo-expansionpanel',
                template: `
        <div
            [class.k-expander-header]="true"
            (click)="onHeaderClick($event)">
            <ng-container *ngIf="!titleTemplate">
                <div *ngIf="title" class="k-expander-title">{{ title }}</div>
                <span class="k-spacer"></span>
                <div *ngIf="subtitle" class="k-expander-sub-title">
                    {{ subtitle }}
                </div>
            </ng-container>
            <ng-template
                *ngIf="titleTemplate"
                [ngTemplateOutlet]="titleTemplate?.templateRef">
            </ng-template>
            <span class="k-expander-indicator">
                <span [ngClass]="indicatorClasses"></span>
            </span>
        </div>
        <div #content class="k-expander-content-wrapper">
            <div  class="k-expander-content" [attr.aria-hidden]="!expanded">
                <ng-content></ng-content>
            </div>
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc4.AnimationBuilder }]; }, { title: [{
            type: Input
        }], subtitle: [{
            type: Input
        }], disabled: [{
            type: Input
        }], animation: [{
            type: Input
        }], expandedChange: [{
            type: Output
        }], action: [{
            type: Output
        }], expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-expander']
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], expanded: [{
            type: Input
        }], expandedClass: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }, {
            type: HostBinding,
            args: ['class.k-expanded']
        }], focusClass: [{
            type: HostBinding,
            args: ['class.k-state-focus']
        }], disabledClass: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], 
    /**
     * @hidden
     */
    onComponentBlur: [{
            type: HostListener,
            args: ['blur']
        }], 
    /**
     * @hidden
     */
    onComponentFocus: [{
            type: HostListener,
            args: ['focus']
        }], expandIcon: [{
            type: Input
        }], collapseIcon: [{
            type: Input
        }], titleTemplate: [{
            type: ContentChild,
            args: [ExpansionPanelTitleDirective, { static: false }]
        }], content: [{
            type: ViewChild,
            args: ['content', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TileLayoutDraggingService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TileLayoutItemComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-tilelayout-item',
                template: `
        <kendo-tilelayout-item-header *ngIf="title">
            <h5 class="k-card-title">{{ title }}</h5>
        </kendo-tilelayout-item-header>
        <ng-content></ng-content>
        <ng-container *ngIf="resizable">
            <div
                *ngFor="let dir of resizeDirections"
                class="k-resize-handle k-cursor-{{dir}}-resize k-touch-action-none"
                kendoTileLayoutResizeHandle
                [rtl]="rtl"
                [resizeDirection]="dir">
            </div>
        </ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.LocalizationService }, { type: TileLayoutDraggingService }]; }, { rowSpan: [{
            type: Input
        }], colSpan: [{
            type: Input
        }], reorderable: [{
            type: Input
        }], resizable: [{
            type: Input
        }], itemClass: [{
            type: HostBinding,
            args: ['class.k-tilelayout-item']
        }, {
            type: HostBinding,
            args: ['class.k-card']
        }], order: [{
            type: Input
        }], colEnd: [{
            type: HostBinding,
            args: ['style.grid-column-end']
        }], rowEnd: [{
            type: HostBinding,
            args: ['style.grid-row-end']
        }], colStart: [{
            type: HostBinding,
            args: ['style.grid-column-start']
        }], rowStart: [{
            type: HostBinding,
            args: ['style.grid-row-start']
        }], title: [{
            type: Input
        }], col: [{
            type: Input
        }], row: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TileLayoutComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-tilelayout',
                providers: [
                    LocalizationService,
                    TileLayoutDraggingService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.tilelayout.component'
                    }
                ],
                template: `
        <ng-content></ng-content>
        <div #hint class="k-layout-item-hint k-layout-item-hint-reorder"
            [style.display]="'none'"
            [style.order]="targetOrder"
            [style.gridColumnEnd]="draggedItemWrapper?.style.gridColumnEnd"
            [style.gridRowEnd]="draggedItemWrapper?.style.gridRowEnd"
            [style.gridColumnStart]="currentColStart"
            [style.gridRowStart]="currentRowStart"
            [style.zIndex]="'1'"></div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.LocalizationService }, { type: TileLayoutDraggingService }, { type: ɵngcc0.NgZone }]; }, { columns: [{
            type: Input
        }], columnWidth: [{
            type: Input
        }], reorderable: [{
            type: Input
        }], resizable: [{
            type: Input
        }], rowHeight: [{
            type: Input
        }], autoFlow: [{
            type: Input
        }], reorder: [{
            type: Output
        }], resize: [{
            type: Output
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-tilelayout']
        }], gap: [{
            type: Input
        }], gapStyle: [{
            type: HostBinding,
            args: ['style.gap']
        }, {
            type: HostBinding,
            args: ['style.padding']
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], items: [{
            type: ContentChildren,
            args: [TileLayoutItemComponent]
        }], hint: [{
            type: ViewChild,
            args: ['hint', { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TileLayoutItemBodyComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-tilelayout-item-body',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-tilelayout-item-body']
        }, {
            type: HostBinding,
            args: ['class.k-card-body']
        }], minHeight: [{
            type: HostBinding,
            args: ['style.min-height']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TileLayoutItemHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-tilelayout-item-header',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: TileLayoutDraggingService }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-tilelayout-item-header']
        }, {
            type: HostBinding,
            args: ['class.k-card-header']
        }], touchActionNone: [{
            type: HostBinding,
            args: ['class.k-touch-action-none']
        }], touchActionAuto: [{
            type: HostBinding,
            args: ['class.k-touch-action-auto']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AvatarModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations],
                exports: [exportedModules],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AvatarModule, { declarations: function () { return [AvatarComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [AvatarComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$1],
                exports: [exportedModules$1],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CardModule, { declarations: function () { return [CardComponent, CardHeaderComponent, CardBodyComponent, CardFooterComponent, CardActionsComponent, CardTitleDirective, CardSubtitleDirective, CardSeparatorDirective, CardMediaDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CardComponent, CardHeaderComponent, CardBodyComponent, CardFooterComponent, CardActionsComponent, CardTitleDirective, CardSubtitleDirective, CardSeparatorDirective, CardMediaDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DrawerItemComponent, [{
        type: Component,
        args: [{
                selector: '[kendoDrawerItem]',
                template: `
        <ng-template *ngIf="itemTemplate; else defaultTemplate"
            [ngTemplateOutlet]="itemTemplate"
            [ngTemplateOutletContext]="{ $implicit: item }">
        </ng-template>

        <ng-template #defaultTemplate>
            <ng-container *ngIf="expanded">
                <span [ngClass]="iconClasses"></span>
                <span class="k-item-text">{{ item.text }}</span>
            </ng-container>
            <ng-container *ngIf="mini && !expanded">
                <span [ngClass]="iconClasses"></span>
            </ng-container>
        </ng-template>
    `
            }]
    }], function () { return [{ type: DrawerService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { disabledClass: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], selectedClass: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }, {
            type: HostBinding,
            args: ['class.k-state-selected']
        }], label: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], item: [{
            type: Input
        }], index: [{
            type: Input
        }], itemTemplate: [{
            type: Input
        }], mini: [{
            type: Input
        }], expanded: [{
            type: Input
        }], disabled: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], cssStyle: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DrawerListComponent, [{
        type: Component,
        args: [{
                selector: '[kendoDrawerList]',
                template: `
        <ng-container *ngFor="let item of items; let idx = index">
            <li *ngIf="!item.separator" kendoDrawerItem
                class="k-drawer-item"
                [item]="item"
                [index]="idx"
                [mini]="mini"
                [expanded]="expanded"
                [itemTemplate]="itemTemplate"
                [attr.${DRAWER_ITEM_INDEX}]="idx"
                [ngClass]="item.cssClass"
                [ngStyle]="item.cssStyle"
                tabindex="0">
            </li>

            <li *ngIf="item.separator"
                class="k-drawer-item k-drawer-separator"
                [ngClass]="item.cssClass"
                [ngStyle]="item.cssStyle">
                &nbsp;
            </li>
        </ng-container>
    `
            }]
    }], function () { return [{ type: DrawerService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { items: [{
            type: Input
        }], itemTemplate: [{
            type: Input
        }], mini: [{
            type: Input
        }], expanded: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DrawerModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$2],
                exports: [exportedModules$2],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DrawerModule, { declarations: function () { return [DrawerItemComponent, DrawerListComponent, DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerHeaderTemplateDirective, DrawerFooterTemplateDirective, DrawerItemTemplateDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerHeaderTemplateDirective, DrawerFooterTemplateDirective, DrawerItemTemplateDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExpansionPanelModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$3],
                exports: [exportedModules$3],
                imports: [CommonModule, EventsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ExpansionPanelModule, { declarations: function () { return [ExpansionPanelComponent, ExpansionPanelTitleDirective]; }, imports: function () { return [CommonModule, EventsModule]; }, exports: function () { return [ExpansionPanelComponent, ExpansionPanelTitleDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PanelBarModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$4],
                exports: [exportedModules$4],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PanelBarModule, { declarations: function () { return [PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitterModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$5],
                exports: [exportedModules$5],
                imports: [
                    CommonModule,
                    DraggableModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SplitterModule, { declarations: function () { return [SplitterBarComponent, SplitterComponent, SplitterPaneComponent]; }, imports: function () { return [CommonModule,
        DraggableModule]; }, exports: function () { return [SplitterComponent, SplitterPaneComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepperStepComponent, [{
        type: Component,
        args: [{
                selector: '[kendoStepperStep]',
                template: `
        <a href='#' class='k-step-link' #stepLink
            [attr.tabindex]='tabIndexAttr'
            [attr.title]='step.label'
            [attr.aria-disabled]='step.disabled'
            [attr.aria-current]='index === current ? "step" : null'
            (focus)='onFocus()'
        >
            <ng-template *ngIf='stepTemplate'
                [ngTemplateOutlet]='stepTemplate'
                [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
            </ng-template>

            <ng-container *ngIf='!stepTemplate'>
                <span *ngIf='showIndicator'
                    class='k-step-indicator'
                    aria-hidden='true'
                    [style.transition-duration.ms]='transitionDuration'
                >
                    <ng-template *ngIf='indicatorTemplate'
                        [ngTemplateOutlet]='indicatorTemplate'
                        [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
                    </ng-template>

                    <ng-container *ngIf='!indicatorTemplate'>
                        <span *ngIf='showIndicatorIcon' class='k-step-indicator-icon' [ngClass]='indicatorIconClasses'></span>
                        <span class='k-step-indicator-text' *ngIf='!showIndicatorIcon'>{{ indicatorText }}</span>
                    </ng-container>
                </span>

                <span class='k-step-label' *ngIf='showLabel'>
                    <ng-template *ngIf='labelTemplate'
                        [ngTemplateOutlet]='labelTemplate'
                        [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
                    </ng-template>

                    <ng-container *ngIf='!labelTemplate'>
                        <span class='k-step-text' *ngIf='showLabelText'>{{ step.label }}</span>
                        <span [ngClass]='validationIconClasses' *ngIf='showLabelIcon' aria-hidden='true'></span>
                        <span class='k-step-label-optional' *ngIf='step.optional'>({{optionalText}})</span>
                    </ng-container>
                </span>
            </ng-container>
        </a>
    `
            }]
    }], function () { return [{ type: StepperService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { errorStepClass: [{
            type: HostBinding,
            args: ['class.k-step-error']
        }], successStepClass: [{
            type: HostBinding,
            args: ['class.k-step-success']
        }], step: [{
            type: Input
        }], index: [{
            type: Input
        }], current: [{
            type: Input
        }], type: [{
            type: Input
        }], successIcon: [{
            type: Input
        }], errorIcon: [{
            type: Input
        }], indicatorTemplate: [{
            type: Input
        }], labelTemplate: [{
            type: Input
        }], stepTemplate: [{
            type: Input
        }], stepLink: [{
            type: ViewChild,
            args: ['stepLink', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepperListComponent, [{
        type: Component,
        args: [{
                selector: '[kendoStepperList]',
                template: `
        <ng-container *ngFor='let step of steps; let idx = index'>
            <li kendoStepperStep
                [attr.${STEPPER_STEP_INDEX}]='idx'
                [type]='stepType'
                [step]='step'
                [index]='idx'
                [current]='currentStep'
                [successIcon]='successIcon'
                [errorIcon]='errorIcon'
                [indicatorTemplate]='indicatorTemplate'
                [labelTemplate]='labelTemplate'
                [stepTemplate]='stepTemplate'
                class='k-step'
                [class.k-step-first]='idx === 0'
                [class.k-step-last]='idx === steps.length - 1'
                [class.k-step-done]='idx < currentStep'
                [class.k-step-current]='idx === currentStep'
                [class.k-step-optional]='step.optional'
                [class.k-step-disabled]='step.disabled'
                [ngClass]='step.cssClass'
                [ngStyle]='step.cssStyle'
                [style.max-width.%] = 'maxStepWidth'
                [style.max-height.%] = 'maxStepHeight'
            >
            </li>
        </ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: StepperService }, { type: ɵngcc0.ElementRef }]; }, { linear: [{
            type: Input
        }], stepType: [{
            type: Input
        }], orientation: [{
            type: Input
        }], currentStep: [{
            type: Input
        }], steps: [{
            type: Input
        }], successIcon: [{
            type: Input
        }], errorIcon: [{
            type: Input
        }], indicatorTemplate: [{
            type: Input
        }], labelTemplate: [{
            type: Input
        }], stepTemplate: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepperModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$6],
                exports: [exportedModules$6],
                imports: [CommonModule, ProgressBarModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(StepperModule, { declarations: function () { return [StepperStepComponent, StepperListComponent, LocalizedStepperMessagesDirective, StepperComponent, StepperCustomMessagesComponent, StepperStepTemplateDirective, StepperLabelTemplateDirective, StepperIndicatorTemplateDirective]; }, imports: function () { return [CommonModule, ProgressBarModule]; }, exports: function () { return [StepperComponent, StepperCustomMessagesComponent, StepperStepTemplateDirective, StepperLabelTemplateDirective, StepperIndicatorTemplateDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabComponent, [{
        type: Component,
        args: [{
                selector: '[kendoTabStripTab]',
                template: `
        <span class="k-link" *ngIf="!tab.tabTitle">{{ tab.title }}</span>
        <span class="k-link" *ngIf="tab.tabTitle">
            <ng-template [ngTemplateOutlet]="tab.tabTitle?.templateRef">
            </ng-template>
        </span>
        <span class="k-remove-tab k-button k-icon-button k-flat" *ngIf="tabClosable"
            role="button"
            [title]="closeButtonTitle"
            [attr.aria-label]="closeButtonTitle"
            (click)="closeTab(index)"
        >
            <span [ngClass]="closeButtonClasses"></span>
        </span>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: TabStripService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-item']
        }, {
            type: HostBinding,
            args: ['class.k-state-default']
        }], activeClass: [{
            type: HostBinding,
            args: ['attr.aria-selected]']
        }, {
            type: HostBinding,
            args: ['class.k-state-active']
        }], disabledClass: [{
            type: HostBinding,
            args: ['attr.aria-disabled]']
        }, {
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], focusedClass: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], tab: [{
            type: Input
        }], index: [{
            type: Input
        }], tabStripClosable: [{
            type: Input
        }], tabStripCloseIcon: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabStripModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$7],
                exports: [exportedModules$7],
                imports: [CommonModule, ResizeSensorModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabStripModule, { declarations: function () { return [TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabComponent, TabStripCustomMessagesComponent, LocalizedTabStripMessagesDirective, TabStripScrollableButtonComponent]; }, imports: function () { return [CommonModule, ResizeSensorModule]; }, exports: function () { return [TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabComponent, TabStripCustomMessagesComponent, LocalizedTabStripMessagesDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TileLayoutResizeHandleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTileLayoutResizeHandle]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { resizeDirection: [{
            type: Input
        }], rtl: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TileLayoutModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$8],
                exports: [exportedModules$8],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TileLayoutModule, { declarations: function () { return [TileLayoutComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent, TileLayoutItemBodyComponent, TileLayoutResizeHandleDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TileLayoutComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent, TileLayoutItemBodyComponent, TileLayoutResizeHandleDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StackLayoutComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoStackLayout',
                selector: 'kendo-stacklayout',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.stacklayout'
                    }
                ],
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc2.LocalizationService }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-stack-layout']
        }], gap: [{
            type: Input
        }], orientation: [{
            type: Input
        }], horizontalClass: [{
            type: HostBinding,
            args: ['class.k-hstack']
        }], verticalClass: [{
            type: HostBinding,
            args: ['class.k-vstack']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], align: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StackLayoutModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$9],
                exports: [exportedModules$9],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(StackLayoutModule, { declarations: function () { return [StackLayoutComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [StackLayoutComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridLayoutComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoGridLayout',
                selector: 'kendo-gridlayout',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.gridlayout'
                    }
                ],
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc2.LocalizationService }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-grid-layout']
        }], gap: [{
            type: Input
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], align: [{
            type: Input
        }], rows: [{
            type: Input
        }], cols: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridLayoutItemComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-gridlayout-item',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { row: [{
            type: Input
        }], col: [{
            type: Input
        }], rowSpan: [{
            type: Input
        }], colSpan: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridLayoutModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$a],
                exports: [exportedModules$a],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GridLayoutModule, { declarations: function () { return [GridLayoutComponent, GridLayoutItemComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [GridLayoutComponent, GridLayoutItemComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LayoutModule, [{
        type: NgModule,
        args: [{
                exports: [
                    AvatarModule,
                    CardModule,
                    DrawerModule,
                    PanelBarModule,
                    ExpansionPanelModule,
                    SplitterModule,
                    StepperModule,
                    TabStripModule,
                    TileLayoutModule,
                    StackLayoutModule,
                    GridLayoutModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LayoutModule, { exports: [AvatarModule, CardModule, DrawerModule, PanelBarModule, ExpansionPanelModule, SplitterModule, StepperModule, TabStripModule, TileLayoutModule, StackLayoutModule, GridLayoutModule] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { PreventableEvent$1 as PreventableEvent, DrawerService, DrawerItemComponent, DrawerListComponent, DRAWER_ITEM_INDEX, PanelBarService, SplitterBarComponent, SplitterService, StepperListComponent, StepperMessages, STEPPER_STEP_INDEX, StepperStepComponent, StepperService, TabStripMessages, TabComponent, TabStripScrollableButtonComponent, ScrollService, TabStripService, TileLayoutDraggingService, PreventableEvent$2 as PreventableEvent$1, TileLayoutResizeHandleDirective, PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, PanelBarExpandMode, SplitterComponent, SplitterPaneComponent, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, LocalizedTabStripMessagesDirective, TabStripCustomMessagesComponent, DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerSelectEvent, StepperComponent, StepperActivateEvent, StepperCustomMessagesComponent, LocalizedStepperMessagesDirective, AvatarComponent, CardComponent, CardHeaderComponent, CardBodyComponent, CardFooterComponent, CardActionsComponent, CardSeparatorDirective, CardTitleDirective, CardSubtitleDirective, CardMediaDirective, CardAction, ExpansionPanelComponent, ExpansionPanelTitleDirective, ExpansionPanelActionEvent, TileLayoutComponent, TileLayoutItemComponent, TileLayoutItemBodyComponent, TileLayoutItemHeaderComponent, TileLayoutReorderEvent, TileLayoutResizeEvent, AvatarModule, CardModule, DrawerModule, LayoutModule, PanelBarModule, SplitterModule, StepperModule, TabStripModule, ExpansionPanelModule, TileLayoutModule, StackLayoutModule, GridLayoutModule, StackLayoutComponent, GridLayoutComponent, GridLayoutItemComponent, PanelBarCollapseEvent, PanelBarExpandEvent, PanelBarSelectEvent, TabCloseEvent, SelectEvent, DrawerTemplateDirective, DrawerItemTemplateDirective, DrawerHeaderTemplateDirective, DrawerFooterTemplateDirective, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1SkFBRTtBQUNGLDhCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MEpBQUU7QUFDRix1Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0tBQUU7QUFDRix5Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQWlJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lLQUFFO0FBQ0YsNENBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FvQ0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7d0RBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FTRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1SkFBRTtBQUNGLDhCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBU0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5SEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBNEJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsySUFBRTtBQUNGLGtDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxSUFBRTtBQUNGLGdDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O2lUQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQU95QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1SkFBRTtBQUNGLDhCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2lKQUFFO0FBQ0YsNEJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7MkRBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQWlHRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0xBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBQUU7QUFDRix3RkFVRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2lLQUFFO0FBQ0Ysa0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1SkFBRTtBQUNGLHNDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21LQUFFO0FBQ0YsMENBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eUtBQUU7QUFDRiw0Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5S0FBRTtBQUNGLDRDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpSkFHa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhIQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQW9DRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3REFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQWVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7NkJBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQVFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzS0FBRTtBQUNGLDJDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lLQUFFO0FBQ0YsNENBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUxBQUU7QUFDRixnREFJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvSkFBRTtBQUNGLDZCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0xBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQStDRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswS0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2dLQUFFO0FBQ0YsZ0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBQUU7QUFDRixzRkFZRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3RkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFxQkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs2QkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFjRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzZCQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsdURBUXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs2QkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHFEQVFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7NkJBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSx1REFRd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O2lHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFzQnlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O21FQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFLMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O1dBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxzREFLdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O1dBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSx5REFLMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O1dBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxzREFLdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsrS0FBRTtBQUNGLDJDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FxQ0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FMQUFFO0FBQ0Ysd0NBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztnS0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBbUJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0F1Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OzZCQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQVFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzZCQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBT0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7eUZBT2lCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7dUZBT2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7aUdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQW9CRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs2SEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBMkJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O3lGQU9pQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7K0dBT3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzJGQU9tQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O2NBVW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQWlERztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztpSEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBZ0NHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7NkdBT2tCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztpR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBbUJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzsrR0FPbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Mk9BQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzZGQU9xQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7NkJBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBZUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzhGQU9zQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OzZCQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQWVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs2QkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBT0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzZGQU9xQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttVEFpQmlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIxIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmLCBPcHRpb25hbCwgaXNEZXZNb2RlLCBJbnB1dCwgVmlld0NoaWxkLCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgVmlld0NoaWxkcmVuLCBRdWVyeUxpc3QsIENvbnRlbnRDaGlsZHJlbiwgQ29tcG9uZW50LCBTa2lwU2VsZiwgSG9zdCwgUmVuZGVyZXIyLCBFdmVudEVtaXR0ZXIsIE91dHB1dCwgQ29udGVudENoaWxkLCBIb3N0TGlzdGVuZXIsIENoYW5nZURldGVjdG9yUmVmLCBOZ1pvbmUsIEluamVjdCwgZm9yd2FyZFJlZiwgVmlld0VuY2Fwc3VsYXRpb24sIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCwgQ29tcG9uZW50TWVzc2FnZXMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IEtleXMsIERyYWdnYWJsZURpcmVjdGl2ZSwgUHJldmVudGFibGVFdmVudCwgaXNEb2N1bWVudEF2YWlsYWJsZSwgaGFzT2JzZXJ2ZXJzLCBFdmVudHNNb2R1bGUsIERyYWdnYWJsZU1vZHVsZSwgUmVzaXplU2Vuc29yTW9kdWxlLCBpc0NoYW5nZWQgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jb21tb24nO1xuaW1wb3J0IHsgdmFsaWRhdGVQYWNrYWdlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWxpY2Vuc2luZyc7XG5pbXBvcnQgeyB0cmlnZ2VyLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIGFuaW1hdGUsIEFVVE9fU1RZTEUsIEFuaW1hdGlvbkJ1aWxkZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IFN1YmplY3QsIEJlaGF2aW9yU3ViamVjdCwgU3Vic2NyaXB0aW9uLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFwLCBmaWx0ZXIsIHN3aXRjaE1hcCwgZGVsYXksIHRha2VVbnRpbCwgbWFwLCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IERyYWdnYWJsZSBmcm9tICdAdGVsZXJpay9rZW5kby1kcmFnZ2FibGUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFByb2dyZXNzQmFyTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcHJvZ3Jlc3NiYXInO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcGFja2FnZU1ldGFkYXRhID0ge1xuICAgIG5hbWU6ICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sYXlvdXQnLFxuICAgIHByb2R1Y3ROYW1lOiAnS2VuZG8gVUkgZm9yIEFuZ3VsYXInLFxuICAgIHByb2R1Y3RDb2RlczogWydLRU5ET1VJQU5HVUxBUicsICdLRU5ET1VJQ09NUExFVEUnXSxcbiAgICBwdWJsaXNoRGF0ZTogMTY0OTM0MDQxNyxcbiAgICB2ZXJzaW9uOiAnJyxcbiAgICBsaWNlbnNpbmdEb2NzVXJsOiAnaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9teS1saWNlbnNlLz91dG1fbWVkaXVtPXByb2R1Y3QmdXRtX3NvdXJjZT1rZW5kb2FuZ3VsYXImdXRtX2NhbXBhaWduPWtlbmRvLXVpLWFuZ3VsYXItcHVyY2hhc2UtbGljZW5zZS1rZXlzLXdhcm5pbmcnXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGV4cGFuZCBtb2RlcyBvZiB0aGUgUGFuZWxCYXIuXG4gKiBCeSBkZWZhdWx0LCB0aGUgZXhwYW5kIG1vZGUgaXMgc2V0IHRvIGBtdWx0aXBsZWAuXG4gKi9cbnZhciBQYW5lbEJhckV4cGFuZE1vZGU7XG4oZnVuY3Rpb24gKFBhbmVsQmFyRXhwYW5kTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEFsbG93cyB5b3UgdG8gZXhwYW5kIG9ubHkgb25lIGl0ZW0gYXQgYSB0aW1lLlxuICAgICAqIFdoZW4geW91IGV4cGFuZCBhbiBpdGVtLCB0aGUgaXRlbSB0aGF0IHdhcyBwcmV2aW91c2x5IGV4cGFuZGVkIGlzIGNvbGwuXG4gICAgICovXG4gICAgUGFuZWxCYXJFeHBhbmRNb2RlW1BhbmVsQmFyRXhwYW5kTW9kZVtcIlNpbmdsZVwiXSA9IDBdID0gXCJTaW5nbGVcIjtcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgeW91IHRvIGV4cGFuZCBvbmx5IG9uZSBpdGVtIGF0IGEgdGltZSBhbmQgcmVxdWlyZXMgeW91IHRvIHNldCB0aGUgYGhlaWdodGAgcHJvcGVydHkuXG4gICAgICogVGhlIGV4cGFuZGVkIGFyZWEgb2NjdXBpZXMgdGhlIGVudGlyZSBoZWlnaHQgb2YgdGhlIFBhbmVsQmFyLlxuICAgICAqL1xuICAgIFBhbmVsQmFyRXhwYW5kTW9kZVtQYW5lbEJhckV4cGFuZE1vZGVbXCJGdWxsXCJdID0gMV0gPSBcIkZ1bGxcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBtb2RlIG9mIHRoZSBQYW5lbEJhci5cbiAgICAgKiBBbGxvd3MgeW91IHRvIGV4cGFuZCBtb3JlIHRoYW4gb25lIGl0ZW0gYXQgYSB0aW1lLiBJdGVtcyBjYW4gYWxzbyBiZSB0b2dnbGVkLlxuICAgICAqL1xuICAgIFBhbmVsQmFyRXhwYW5kTW9kZVtQYW5lbEJhckV4cGFuZE1vZGVbXCJNdWx0aXBsZVwiXSA9IDJdID0gXCJNdWx0aXBsZVwiO1xuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBleHBhbmQgbW9kZSBpcyBzZXQgdG8gYG11bHRpcGxlYC5cbiAgICAgKi9cbiAgICBQYW5lbEJhckV4cGFuZE1vZGVbUGFuZWxCYXJFeHBhbmRNb2RlW1wiRGVmYXVsdFwiXSA9IDJdID0gXCJEZWZhdWx0XCI7XG59KShQYW5lbEJhckV4cGFuZE1vZGUgfHwgKFBhbmVsQmFyRXhwYW5kTW9kZSA9IHt9KSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgbmV4dFBhbmVsYmFySWQgPSAwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBQYW5lbEJhclNlcnZpY2UgPSBjbGFzcyBQYW5lbEJhclNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhcmVudFNvdXJjZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMua2VlcENvbnRlbnRTb3VyY2UgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGlsZFNvdXJjZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMucGFyZW50JCA9IHRoaXMucGFyZW50U291cmNlLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuJCA9IHRoaXMuY2hpbGRTb3VyY2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMua2VlcENvbnRlbnQkID0gdGhpcy5rZWVwQ29udGVudFNvdXJjZS5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5wYklkID0gbmV4dFBhbmVsYmFySWQrKztcbiAgICB9XG4gICAgb25LZWVwQ29udGVudChrZWVwQ29udGVudCkge1xuICAgICAgICB0aGlzLmtlZXBDb250ZW50U291cmNlLm5leHQoa2VlcENvbnRlbnQpO1xuICAgIH1cbiAgICBvblNlbGVjdChldmVudCkge1xuICAgICAgICB0aGlzLmNoaWxkU291cmNlLm5leHQoZXZlbnQpO1xuICAgIH1cbiAgICBvbkZvY3VzKCkge1xuICAgICAgICB0aGlzLnBhcmVudFNvdXJjZS5uZXh0KHRydWUpO1xuICAgIH1cbiAgICBvbkJsdXIoKSB7XG4gICAgICAgIHRoaXMucGFyZW50U291cmNlLm5leHQoZmFsc2UpO1xuICAgIH1cbn07XG5QYW5lbEJhclNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgUGFuZWxCYXJTZXJ2aWNlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb250ZW50IHRlbXBsYXRlIG9mIHRoZSBkZWNsYXJhdGl2ZWx5IGluaXRpYWxpemVkIFBhbmVsQmFyIGl0ZW1zLlxuICogVGhlIGNvbnRlbnQgY2FuIGJlIGV4cGFuZGVkIG9yIGNvbGxhcHNlZCB0aHJvdWdoIHRoZSBpdGVtLlxuICovXG5sZXQgUGFuZWxCYXJDb250ZW50RGlyZWN0aXZlID0gY2xhc3MgUGFuZWxCYXJDb250ZW50RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcblBhbmVsQmFyQ29udGVudERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiBcIltrZW5kb1BhbmVsQmFyQ29udGVudF1cIlxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgUGFuZWxCYXJDb250ZW50RGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB0ZW1wbGF0ZSBkaXJlY3RpdmUgb2YgdGhlIFBhbmVsQmFyIHdoaWNoIGhlbHBzIHRvIGN1c3RvbWl6ZSB0aGUgaXRlbSB0aXRsZVxuICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIHRlbXBsYXRlc19wYW5lbGJhciAlfSN0b2MtY3VzdG9taXppbmctdGhlLWFwcGVhcmFuY2Utb2YtdGhlLXRpdGxlKSkuXG4gKlxuICogPiBUaGUgYGtlbmRvUGFuZWxCYXJJdGVtVGl0bGVgIGRpcmVjdGl2ZSBvdmVycmlkZXMgdGhlIFBhbmVsQmFySXRlbSBbdGl0bGVdKHslIHNsdWcgYXBpX2xheW91dF9wYW5lbGJhcml0ZW1jb21wb25lbnQgJX0jdG9jLXRpdGxlKSBvcHRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgPGtlbmRvLXBhbmVsYmFyPlxuICogICAgICAgICAgICA8a2VuZG8tcGFuZWxiYXItaXRlbSBbZXhwYW5kZWRdPVwidHJ1ZVwiPlxuICogICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvUGFuZWxCYXJJdGVtVGl0bGU+XG4gKiAgICAgICAgICAgICAgICAgICAgSXRlbSBUaXRsZVxuICogICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICAgPC9rZW5kby1wYW5lbGJhci1pdGVtPlxuICogICAgICAgIDwva2VuZG8tcGFuZWxiYXI+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge31cbiAqXG4gKiBgYGBcbiAqL1xubGV0IFBhbmVsQmFySXRlbVRpdGxlRGlyZWN0aXZlID0gY2xhc3MgUGFuZWxCYXJJdGVtVGl0bGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuUGFuZWxCYXJJdGVtVGl0bGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1BhbmVsQmFySXRlbVRpdGxlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgUGFuZWxCYXJJdGVtVGl0bGVEaXJlY3RpdmUpO1xuXG5sZXQgbmV4dElkID0gMDtcbmNvbnN0IFNJWkVTID0ge1xuICAgIHNtYWxsOiAnc20nLFxuICAgIG1lZGl1bTogJ21kJyxcbiAgICBsYXJnZTogJ2xnJ1xufTtcbmNvbnN0IFJPVU5ETkVTUyA9IHtcbiAgICBzbWFsbDogJ3NtJyxcbiAgICBtZWRpdW06ICdtZCcsXG4gICAgbGFyZ2U6ICdsZycsXG4gICAgZnVsbDogJ2Z1bGwnXG59O1xuY29uc3QgU0hBUEVfVE9fUk9VTkRFRCA9IHtcbiAgICByb3VuZGVkOiAnbGFyZ2UnLFxuICAgIGNpcmNsZTogJ2Z1bGwnXG59O1xuY29uc3QgcGFyc2VQYW5lbEJhckl0ZW1zID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gZGF0YS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKCFpdGVtLmlkKSB7XG4gICAgICAgICAgICBpdGVtLmlkID0gYGRlZmF1bHQtJHtuZXh0SWQrK31gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpdGVtLmNoaWxkcmVuID0gcGFyc2VQYW5lbEJhckl0ZW1zKGl0ZW0uY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xufTtcbnZhciB1dGlsID0ge1xuICAgIHBhcnNlUGFuZWxCYXJJdGVtc1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1ByZXNlbnQgPSAodmFsdWUpID0+IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNIb3Jpem9udGFsQXJyb3dLZXkgPSBrZXlDb2RlID0+IGtleUNvZGUgPT09IEtleXMuQXJyb3dMZWZ0IHx8IGtleUNvZGUgPT09IEtleXMuQXJyb3dSaWdodDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1ZlcnRpY2FsQXJyb3dLZXkgPSBrZXlDb2RlID0+IGtleUNvZGUgPT09IEtleXMuQXJyb3dVcCB8fCBrZXlDb2RlID09PSBLZXlzLkFycm93RG93bjtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0Fycm93S2V5ID0ga2V5Q29kZSA9PiBpc0hvcml6b250YWxBcnJvd0tleShrZXlDb2RlKSB8fCBpc1ZlcnRpY2FsQXJyb3dLZXkoa2V5Q29kZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNOYXZpZ2F0aW9uS2V5ID0ga2V5Q29kZSA9PiBrZXlDb2RlID09PSBLZXlzLlBhZ2VVcCB8fCBrZXlDb2RlID09PSBLZXlzLlBhZ2VEb3duIHx8XG4gICAga2V5Q29kZSA9PT0gS2V5cy5Ib21lIHx8IGtleUNvZGUgPT09IEtleXMuRW5kO1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmV0dXJucyB0aGUgc3R5bGluZyBjbGFzc2VzIHRvIGJlIGFkZGVkIGFuZCByZW1vdmVkXG4gKi9cbmNvbnN0IGdldFN0eWxpbmdDbGFzc2VzID0gKGNvbXBvbmVudFR5cGUsIHN0eWxpbmdPcHRpb24sIHByZXZpb3VzVmFsdWUsIG5ld1ZhbHVlKSA9PiB7XG4gICAgc3dpdGNoIChzdHlsaW5nT3B0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3NpemUnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b1JlbW92ZTogYGstJHtjb21wb25lbnRUeXBlfS0ke1NJWkVTW3ByZXZpb3VzVmFsdWVdfWAsXG4gICAgICAgICAgICAgICAgdG9BZGQ6IG5ld1ZhbHVlID8gYGstJHtjb21wb25lbnRUeXBlfS0ke1NJWkVTW25ld1ZhbHVlXX1gIDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAncm91bmRlZCc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvUmVtb3ZlOiBgay1yb3VuZGVkLSR7Uk9VTkRORVNTW3ByZXZpb3VzVmFsdWVdfWAsXG4gICAgICAgICAgICAgICAgdG9BZGQ6IG5ld1ZhbHVlID8gYGstcm91bmRlZC0ke1JPVU5ETkVTU1tuZXdWYWx1ZV19YCA6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG1hcFNoYXBlVG9Sb3VuZGVkID0gKHNoYXBlKSA9PiBTSEFQRV9UT19ST1VOREVEW3NoYXBlXSB8fCBudWxsO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzTnVtYmVyID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcblxuY29uc3QgZm9jdXNhYmxlUmVnZXggPSAvXig/OmF8aW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaTtcbmNvbnN0IHRvQ2xhc3NMaXN0ID0gKGNsYXNzTmFtZXMpID0+IFN0cmluZyhjbGFzc05hbWVzKS50cmltKCkuc3BsaXQoJyAnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0ZvY3VzYWJsZSA9IChlbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHRhYkluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XG4gICAgICAgIGNvbnN0IHNraXBUYWIgPSB0YWJJbmRleCA9PT0gJy0xJztcbiAgICAgICAgbGV0IGZvY3VzYWJsZSA9IHRhYkluZGV4ICE9PSBudWxsICYmICFza2lwVGFiO1xuICAgICAgICBpZiAoZm9jdXNhYmxlUmVnZXgudGVzdCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgZm9jdXNhYmxlID0gIWVsZW1lbnQuZGlzYWJsZWQgJiYgIXNraXBUYWI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvY3VzYWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNDbGFzcyA9IChlbGVtZW50LCBjbGFzc05hbWUpID0+IEJvb2xlYW4odG9DbGFzc0xpc3QoZWxlbWVudC5jbGFzc05hbWUpLmZpbmQoKG5hbWUpID0+IG5hbWUgPT09IGNsYXNzTmFtZSkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3RJblNjb3BlID0gKHRhcmdldCwgcHJlZGljYXRlLCBzY29wZSwgdGFyZ2V0QXR0cikgPT4ge1xuICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBzY29wZSAmJiAhcHJlZGljYXRlKHRhcmdldCwgdGFyZ2V0QXR0cikpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgIT09IHNjb3BlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpdGVtSW5kZXggPSAoaXRlbSwgaW5kZXhBdHRyKSA9PiAraXRlbS5nZXRBdHRyaWJ1dGUoaW5kZXhBdHRyKTtcbmNvbnN0IGhhc0l0ZW1JbmRleCA9IChpdGVtLCBpbmRleEF0dHIpID0+IGlzUHJlc2VudChpdGVtLmdldEF0dHJpYnV0ZShpbmRleEF0dHIpKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0SXRlbSA9ICh0YXJnZXQsIHRhcmdldEF0dHIsIHNjb3BlKSA9PiBjbG9zZXN0SW5TY29wZSh0YXJnZXQsIGhhc0l0ZW1JbmRleCwgc2NvcGUsIHRhcmdldEF0dHIpO1xuXG52YXIgUGFuZWxCYXJJdGVtQ29tcG9uZW50XzE7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IG5leHRJZCQxID0gMDtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgaXRlbXMgb2YgdGhlIFBhbmVsQmFyLlxuICovXG5sZXQgUGFuZWxCYXJJdGVtQ29tcG9uZW50ID0gUGFuZWxCYXJJdGVtQ29tcG9uZW50XzEgPSBjbGFzcyBQYW5lbEJhckl0ZW1Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgZXZlbnRTZXJ2aWNlLCBlbGVtZW50LCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UgPSBldmVudFNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyB0aGUgY29tcG9uZW50IHRvIHNldCB0aGUgYFwiaWRcImAgcHJvcGVydHkgdG8gZWFjaCBpdGVtLlxuICAgICAgICAgKiBVc2VkIHRvIHNldCB0aGUgYGlkYCBhdHRyaWJ1dGVzIG9mIHRoZSBuZXN0ZWQgZWxlbWVudHMgYW5kIHRvIGVuYWJsZSB0aGUgV0FJLUFSSUEgc3VwcG9ydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBgZGVmYXVsdC0ke25leHRJZCQxKyt9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGljb24gdGhhdCB3aWxsIGJlIHJlbmRlcmVkIG5leHQgdG8gdGhlIHRpdGxlIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaXRlbXNfcGFuZWxiYXIgJX0jdG9jLXRpdGxlLWljb25zKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmljb24gPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgIHRoZSBpY29uIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBuZXh0IHRvIHRoZSB0aXRsZSBieSB1c2luZyBhIGN1c3RvbSBDU1MgY2xhc3NcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBpdGVtc19wYW5lbGJhciAlfSN0b2MtdGl0bGUtaWNvbnMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWNvbkNsYXNzID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgaW1hZ2UgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBuZXh0IHRvIHRoZSB0aXRsZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGl0ZW1zX3BhbmVsYmFyICV9I3RvYy10aXRsZS1pbWFnZXMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW1hZ2VVcmwgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgZGlzYWJsZXMgYSBQYW5lbEJhciBpdGVtIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaXRlbXNfcGFuZWxiYXIgJX0jdG9jLWRpc2FibGVkLXN0YXRlKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiBhIFBhbmVsQmFyIGl0ZW0gKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBpdGVtc19wYW5lbGJhciAlfSN0b2Mtc2VsZWN0ZWQtc3RhdGUpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5rZWVwQ29udGVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0NoaWxkSXRlbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNJdGVtcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaW5hY3RpdmVcIjtcbiAgICAgICAgdGhpcy5yb2xlID0gXCJ0cmVlaXRlbVwiO1xuICAgICAgICB0aGlzLnRpdGxlQXR0cmlidXRlID0gbnVsbDsgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgICAgICB0aGlzLmtJdGVtQ2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53cmFwcGVyRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCgpID0+IHsgfSk7XG4gICAgICAgIHRoaXMuX2V4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoZXZlbnRTZXJ2aWNlLnBhcmVudCQuc3Vic2NyaWJlKGZvY3VzZWQgPT4gdGhpcy5vbldyYXBwZXJGb2N1c0NoYW5nZShmb2N1c2VkKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGV2ZW50U2VydmljZS5rZWVwQ29udGVudCQuc3Vic2NyaWJlKGtlZXBDb250ZW50ID0+IHRoaXMua2VlcENvbnRlbnQgPSBrZWVwQ29udGVudCkpO1xuICAgICAgICB0aGlzLndyYXBwZXJGb2N1c2VkID0gcGFyZW50ID8gcGFyZW50LmZvY3VzZWQgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5sZXZlbCA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQubGV2ZWwgKyAxIDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBleHBhbmRzIHRoZSBQYW5lbEJhciBpdGVtIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaXRlbXNfcGFuZWxiYXIgJX0jdG9jLWV4cGFuZGVkLXN0YXRlKSkuXG4gICAgICovXG4gICAgc2V0IGV4cGFuZGVkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVN0YXRlID0gdGhpcy5hbmltYXRlID8gXCJhY3RpdmVcIiA6IFwiYWN0aXZlV2l0aG91dEFuaW1hdGlvblwiO1xuICAgICAgICB0aGlzLnN0YXRlID0gdmFsdWUgPyBhY3RpdmVTdGF0ZSA6IFwiaW5hY3RpdmVcIjtcbiAgICAgICAgaWYgKCF0aGlzLmtlZXBDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUV4cGFuZGVkQ2hpbGRBbmltYXRpb25zKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9leHBhbmRlZCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZXhwYW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbmRlZDtcbiAgICB9XG4gICAgZ2V0IGFuaW1hdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50U2VydmljZS5hbmltYXRlO1xuICAgIH1cbiAgICBnZXQga1N0YXRlRGVmYXVsdENsYXNzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIGdldCBrU3RhdGVEaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgZ2V0IGtTdGF0ZUV4cGFuZGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZCAmJiB0aGlzLmV4cGFuZGVkICYmICh0aGlzLmhhc0NoaWxkSXRlbXMgfHwgdGhpcy5oYXNDb250ZW50KTtcbiAgICB9XG4gICAgZ2V0IGl0ZW1JZCgpIHtcbiAgICAgICAgcmV0dXJuICdrLXBhbmVsYmFyLScgKyB0aGlzLmV2ZW50U2VydmljZS5wYklkICsgJy1pdGVtLScgKyB0aGlzLmlkO1xuICAgIH1cbiAgICBnZXQgYXJpYUV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaGFzQ2hpbGRJdGVtcyB8fCB0aGlzLmhhc0NvbnRlbnQpID8gIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5leHBhbmRlZCA6IG51bGw7XG4gICAgfVxuICAgIGdldCBhcmlhU2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZCAmJiB0aGlzLnNlbGVjdGVkO1xuICAgIH1cbiAgICBnZXQgYXJpYURpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/IHRydWUgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgaGVhZGVyQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IG51bGwgOiB0cnVlO1xuICAgIH1cbiAgICBnZXQgY2hpbGRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdHJ1ZSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdGl0bGVUZW1wbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGVUZW1wbGF0ZXMubGVuZ3RoID4gMCA/IHRoaXMudGl0bGVUZW1wbGF0ZXMudG9BcnJheSgpWzBdLnRlbXBsYXRlUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGVhZGVySGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gKHRoaXMuY29udGVudFdyYXBwZXIgPyB0aGlzLmNvbnRlbnRXcmFwcGVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogMCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmFkZExldmVsQ2xhc3MoKTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICB0aGlzLmhhc0l0ZW1zID0gdGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zLmZpbHRlcihpdGVtID0+ICFpdGVtLmhpZGRlbikubGVuZ3RoID4gMDtcbiAgICAgICAgdGhpcy5oYXNDaGlsZEl0ZW1zID0gdGhpcy5jb250ZW50SXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gdGhpcykubGVuZ3RoID4gMCB8fCB0aGlzLmhhc0l0ZW1zO1xuICAgICAgICB0aGlzLmhhc0NvbnRlbnQgPSAodGhpcy5jb250ZW50VGVtcGxhdGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNvbnRlbnRUZW1wbGF0ZS5sZW5ndGggPiAwKSB8fFxuICAgICAgICAgICAgdGhpcy5jb250ZW50ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmFsaWRhdGVDb25maWd1cmF0aW9uKCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5JdGVtcyA9IHRoaXMudmlld0NoaWxkSXRlbXMudG9BcnJheSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbkl0ZW1zID0gdGhpcy5jb250ZW50SXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25JdGVtQWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLm9uU2VsZWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkl0ZW1DbGljayhlKSB7XG4gICAgICAgIGlmICghaXNGb2N1c2FibGUoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLm9uSXRlbUFjdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaWNvbkNsYXNzZXMoKSB7XG4gICAgICAgIGxldCBpY29uID0gdGhpcy5pY29uID8gJ2staS0nICsgdGhpcy5pY29uIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtpY29uIHx8IHRoaXMuaWNvbkNsYXNzXTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICAgICBleHBhbmRlZDogdGhpcy5leHBhbmRlZCxcbiAgICAgICAgICAgIGZvY3VzZWQ6IHRoaXMuZm9jdXNlZCxcbiAgICAgICAgICAgIGljb246IHRoaXMuaWNvbixcbiAgICAgICAgICAgIGljb25DbGFzczogdGhpcy5pY29uQ2xhc3MsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGltYWdlVXJsOiB0aGlzLmltYWdlVXJsLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHRoaXMuc2VsZWN0ZWQsXG4gICAgICAgICAgICB0aXRsZTogdGhpcy50aXRsZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc3ViVHJlZVZpZXdJdGVtcygpIHtcbiAgICAgICAgbGV0IHN1YlRyZWUgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3Q2hpbGRJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgc3ViVHJlZSA9IHN1YlRyZWUuY29uY2F0KGl0ZW0uc3ViVHJlZVZpZXdJdGVtcygpKTtcbiAgICAgICAgICAgIHN1YlRyZWUucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdWJUcmVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdmFsaWRhdGVDb25maWd1cmF0aW9uKCkge1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQgJiYgKHRoaXMuY29udGVudFRlbXBsYXRlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jb250ZW50VGVtcGxhdGUubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb246IG1peGVkIHRlbXBsYXRlIGNvbXBvbmVudHMgYW5kIGNvbXBvbmVudCBwcm9wZXJ0eS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvZ2dsZUFuaW1hdGlvblN0YXRlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5hbmltYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHZhbHVlICYmIHRoaXMuZXZlbnRTZXJ2aWNlLmV4cGFuZE1vZGUgIT09IFBhbmVsQmFyRXhwYW5kTW9kZS5TaW5nbGUgPyAnYWN0aXZlJyA6ICdhY3RpdmVXaXRob3V0QW5pbWF0aW9uJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvZ2dsZUV4cGFuZGVkQ2hpbGRBbmltYXRpb25zKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuSXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5JdGVtcy5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudG9nZ2xlQW5pbWF0aW9uU3RhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50b2dnbGVFeHBhbmRlZENoaWxkQW5pbWF0aW9ucyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGFkZExldmVsQ2xhc3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmxldmVsID49IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGBrLWxldmVsLSR7dGhpcy5sZXZlbH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbldyYXBwZXJGb2N1c0NoYW5nZShmb2N1c2VkKSB7XG4gICAgICAgIHRoaXMud3JhcHBlckZvY3VzZWQgPSBmb2N1c2VkO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhbmVsQmFySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImltYWdlVXJsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUGFuZWxCYXJJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIFBhbmVsQmFySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUGFuZWxCYXJJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZWxCYXJJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFBhbmVsQmFySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgUGFuZWxCYXJJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdoZWFkZXInLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImhlYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdjb250ZW50V3JhcHBlcicsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIFBhbmVsQmFySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGVudFdyYXBwZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFuZWxCYXJJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci50aXRsZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlQXR0cmlidXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1pdGVtJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImtJdGVtQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXN0YXRlLWRlZmF1bHQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgUGFuZWxCYXJJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJrU3RhdGVEZWZhdWx0Q2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImtTdGF0ZURpc2FibGVkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1leHBhbmRlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImtTdGF0ZUV4cGFuZGVkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnaWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1JZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZXhwYW5kZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgUGFuZWxCYXJJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhRXhwYW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLXNlbGVjdGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFBhbmVsQmFySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYXJpYVNlbGVjdGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImFyaWFEaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXBhbmVsYmFyLWhlYWRlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImhlYWRlckNsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstcGFuZWxiYXItaXRlbScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImNoaWxkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGRyZW4oUGFuZWxCYXJJdGVtQ29tcG9uZW50XzEpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInZpZXdDaGlsZEl0ZW1zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oUGFuZWxCYXJJdGVtQ29tcG9uZW50XzEpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImNvbnRlbnRJdGVtc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKFBhbmVsQmFyQ29udGVudERpcmVjdGl2ZSwgeyBkZXNjZW5kYW50czogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFBhbmVsQmFySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGVudFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oUGFuZWxCYXJJdGVtVGl0bGVEaXJlY3RpdmUsIHsgZGVzY2VuZGFudHM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBQYW5lbEJhckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlVGVtcGxhdGVzXCIsIHZvaWQgMCk7XG5QYW5lbEJhckl0ZW1Db21wb25lbnQgPSBQYW5lbEJhckl0ZW1Db21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgIHRyaWdnZXIoJ3RvZ2dsZScsIFtcbiAgICAgICAgICAgICAgICBzdGF0ZSgnaW5hY3RpdmUnLCBzdHlsZSh7IGRpc3BsYXk6ICdub25lJyB9KSksXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiBhY3RpdmUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlKHsgb3ZlcmZsb3c6ICdoaWRkZW4nLCBkaXNwbGF5OiAnYmxvY2snLCBoZWlnaHQ6IDAgfSksXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoMjAwLCBzdHlsZSh7IGhlaWdodDogQVVUT19TVFlMRSB9KSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCdhY3RpdmUgPT4gKicsIFtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIGhlaWdodDogQVVUT19TVFlMRSB9KSxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgyMDAsIHN0eWxlKHsgaGVpZ2h0OiAwLCBkaXNwbGF5OiAnbm9uZScgfSkpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9QYW5lbGJhckl0ZW0nLFxuICAgICAgICBzZWxlY3RvcjogXCJrZW5kby1wYW5lbGJhci1pdGVtXCIsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICNoZWFkZXJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1saW5rXT1cInRydWVcIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLXNlbGVjdGVkXT1cIiFkaXNhYmxlZCAmJiBzZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstc3RhdGUtZm9jdXNlZF09XCJmb2N1c2VkICYmIHdyYXBwZXJGb2N1c2VkXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwib25JdGVtQ2xpY2soJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaWNvbiB8fCBpY29uQ2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstaWNvbiBrLXBhbmVsYmFyLWl0ZW0taWNvblwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cImljb25DbGFzc2VzXCI+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJpbWFnZVVybFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1pbWFnZSBrLXBhbmVsYmFyLWl0ZW0taWNvblwiXG4gICAgICAgICAgICAgICAgICAgIFtzcmNdPVwiaW1hZ2VVcmxcIlxuICAgICAgICAgICAgICAgICAgICBhbHQ9XCJcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXRpdGxlVGVtcGxhdGVcIj48c3BhbiBjbGFzcz1cImstcGFuZWxiYXItaXRlbS10ZXh0XCI+e3t0aXRsZX19PC9zcGFuPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cInRpdGxlVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRpdGxlVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IGljb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3M6IGljb25DbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsOiBpbWFnZVVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkOiBleHBhbmRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzZWQ6IGZvY3VzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cImhhc0NoaWxkSXRlbXMgfHwgaGFzQ29udGVudFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1pY29uIGstcGFuZWxiYXItdG9nZ2xlXCJcbiAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwieydrLWktYXJyb3ctY2hldnJvbi11cCBrLXBhbmVsYmFyLWNvbGxhcHNlJzogZXhwYW5kZWQsICdrLWktYXJyb3ctY2hldnJvbi1kb3duIGstcGFuZWxiYXItZXhwYW5kJzogIWV4cGFuZGVkfVwiPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxkaXYgI2NvbnRlbnRXcmFwcGVyXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJrZWVwQ29udGVudCB8fCAoIWRpc2FibGVkICYmIGV4cGFuZGVkICYmIChoYXNDaGlsZEl0ZW1zIHx8IGhhc0NvbnRlbnQpKVwiXG4gICAgICAgICAgICAgICAgW0B0b2dnbGVdPVwic3RhdGVcIlxuICAgICAgICAgICAgICAgIFthdHRyLnJvbGVdPVwiJ2dyb3VwJ1wiXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1oaWRkZW5dPVwiIWRpc2FibGVkICYmICFleHBhbmRlZFwiPlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNDaGlsZEl0ZW1zICYmICFpdGVtcz8ubGVuZ3RoXCJcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm92ZXJmbG93XT1cImNvbnRlbnRPdmVyZmxvd1wiXG4gICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHRdPVwiY29udGVudEhlaWdodFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1wYW5lbCBrLWdyb3VwIGstcGFuZWxiYXItZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImtlbmRvLXBhbmVsYmFyLWl0ZW1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc0NvbnRlbnQgJiYgIWNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUub3ZlcmZsb3ddPVwiY29udGVudE92ZXJmbG93XCJcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodF09XCJjb250ZW50SGVpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWNvbnRlbnQgay1wYW5lbGJhci1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29udGVudFRlbXBsYXRlLmZpcnN0LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiBpY29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybDogaW1hZ2VVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVwiaGFzSXRlbXNcIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUub3ZlcmZsb3ddPVwiY29udGVudE92ZXJmbG93XCJcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodF09XCJjb250ZW50SGVpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLXBhbmVsIGstZ3JvdXAgay1wYW5lbGJhci1ncm91cFwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8a2VuZG8tcGFuZWxiYXItaXRlbSAqbmdJZj1cIiFpdGVtLmhpZGRlblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlXT1cIml0ZW0udGl0bGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpZF09XCJpdGVtLmlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWNvbl09XCJpdGVtLmljb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpY29uQ2xhc3NdPVwiaXRlbS5pY29uQ2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbWFnZVVybF09XCJpdGVtLmltYWdlVXJsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0ZWRdPVwiISFpdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXhwYW5kZWRdPVwiISFpdGVtLmV4cGFuZGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiISFpdGVtLmRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGVtcGxhdGVdPVwidGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpdGVtc109XCJpdGVtLmNoaWxkcmVuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29udGVudF09XCJpdGVtLmNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwva2VuZG8tcGFuZWxiYXItaXRlbT5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUub3ZlcmZsb3ddPVwiY29udGVudE92ZXJmbG93XCJcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodF09XCJjb250ZW50SGVpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWNvbnRlbnQgay1wYW5lbGJhci1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwidGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246IGljb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsOiBpbWFnZVVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIXRlbXBsYXRlXCI+e3tjb250ZW50fX08L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+YFxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgU2tpcFNlbGYoKSksIF9fcGFyYW0oMCwgSG9zdCgpKSwgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1BhbmVsQmFySXRlbUNvbXBvbmVudCxcbiAgICAgICAgUGFuZWxCYXJTZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjJdKVxuXSwgUGFuZWxCYXJJdGVtQ29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB0ZW1wbGF0ZSBkaXJlY3RpdmUgb2YgdGhlIFBhbmVsQmFyIHdoaWNoIGhlbHBzIHRvIGN1c3RvbWl6ZSB0aGUgaXRlbSBjb250ZW50LlxuICovXG5sZXQgUGFuZWxCYXJJdGVtVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBQYW5lbEJhckl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5QYW5lbEJhckl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvUGFuZWxCYXJJdGVtVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBQYW5lbEJhckl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQcmV2ZW50YWJsZUV2ZW50JDEge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHRoaXMucHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgYSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogSW4gdGhpcyB3YXksIHRoZSBzb3VyY2UgY29tcG9uZW50IHN1cHByZXNzZXNcbiAgICAgKiB0aGUgYnVpbHQtaW4gYmVoYXZpb3IgdGhhdCBmb2xsb3dzIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZXZlbnQgd2FzIHByZXZlbnRlZFxuICAgICAqIGJ5IGFueSBvZiBpdHMgc3Vic2NyaWJlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGRlZmF1bHQgYWN0aW9uIHdhcyBwcmV2ZW50ZWQuXG4gICAgICogT3RoZXJ3aXNlLCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICovXG4gICAgaXNEZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50ZWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBjb2xsYXBzZWAgZXZlbnQgb2YgdGhlIFBhbmVsQmFyLlxuICovXG5jbGFzcyBQYW5lbEJhckNvbGxhcHNlRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50JDEge1xufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBleHBhbmRgIGV2ZW50IG9mIHRoZSBQYW5lbEJhci5cbiAqL1xuY2xhc3MgUGFuZWxCYXJFeHBhbmRFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQkMSB7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHNlbGVjdGAgZXZlbnQgb2YgdGhlIFBhbmVsQmFyLlxuICovXG5jbGFzcyBQYW5lbEJhclNlbGVjdEV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCQxIHtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgUGFuZWxCYXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3BhbmVsYmFyICV9KS5cbiAqL1xubGV0IFBhbmVsQmFyQ29tcG9uZW50ID0gXG4vLyBUT0RPOiBhZGQgc3R5bGVzIGFzIGlucHV0IHByb3BcbmNsYXNzIFBhbmVsQmFyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCBldmVudFNlcnZpY2UsIGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGV4cGFuZCBtb2RlIG9mIHRoZSBQYW5lbEJhciB0aHJvdWdoIHRoZSBgUGFuZWxCYXJFeHBhbmRNb2RlYCBlbnVtIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZXhwYW5kbW9kZXNfcGFuZWxiYXIgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGF2YWlsYWJsZSBtb2RlcyBhcmU6XG4gICAgICAgICAqIC0gYFwic2luZ2xlXCJgJm1kYXNoO0V4cGFuZHMgb25seSBvbmUgaXRlbSBhdCBhIHRpbWUuIEV4cGFuZGluZyBhbiBpdGVtIGNvbGxhcHNlcyB0aGUgaXRlbSB0aGF0IHdhcyBwcmV2aW91c2x5IGV4cGFuZGVkLlxuICAgICAgICAgKiAtIGBcIm11bHRpcGxlXCJgJm1kYXNoO1RoZSBkZWZhdWx0IG1vZGUgb2YgdGhlIFBhbmVsQmFyLlxuICAgICAgICAgKiBFeHBhbmRzIG1vcmUgdGhhbiBvbmUgaXRlbSBhdCBhIHRpbWUuIEl0ZW1zIGNhbiBhbHNvIGJlIHRvZ2dsZWQuXG4gICAgICAgICAqIC0gYFwiZnVsbFwiYCZtZGFzaDtFeHBhbmRzIG9ubHkgb25lIGl0ZW0gYXQgYSB0aW1lLlxuICAgICAgICAgKiBUaGUgZXhwYW5kZWQgYXJlYSBvY2N1cGllcyB0aGUgZW50aXJlIGhlaWdodCBvZiB0aGUgUGFuZWxCYXIuIFJlcXVpcmVzIHlvdSB0byBzZXQgdGhlIGBoZWlnaHRgIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmRNb2RlID0gUGFuZWxCYXJFeHBhbmRNb2RlLkRlZmF1bHQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgdGhlIFBhbmVsQmFyIHRvIG1vZGlmeSB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlIGl0ZW1zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGFuaW1hdGUgc3RhdGUgb2YgdGhlIFBhbmVsQmFyIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYW5pbWF0aW9uc19wYW5lbGJhciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50IHdoZW4gdGhlIGBcImZ1bGxcImAgZXhwYW5kIG1vZGUgaXMgdXNlZC5cbiAgICAgICAgICogVGhpcyBvcHRpb24gaXMgaWdub3JlZCBpbiB0aGUgYFwibXVsdGlwbGVcImAgYW5kIGBcInNpbmdsZVwiYCBleHBhbmQgbW9kZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9ICc0MDBweCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgaW50ZXJhY3RzIHdpdGggYSBQYW5lbEJhciBpdGVtXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcm91dGluZ19wYW5lbGJhciAlfSN0b2MtZ2V0dGluZy10aGUtc2VsZWN0ZWQtaXRlbSkpLlxuICAgICAgICAgKiBUaGUgZXZlbnQgZGF0YSBjb250YWlucyBhbGwgaXRlbXMgdGhhdCBhcmUgbW9kaWZpZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhbiBpdGVtIGlzIGFib3V0IHRvIGJlIHNlbGVjdGVkLlxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGV2ZW50c19wYW5lbGJhciAlfSkpXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgaXQsIHRoZSBpdGVtIHdpbGwgbm90IGJlIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIGFuIGl0ZW0gaXMgYWJvdXQgdG8gYmUgZXhwYW5kZWQuXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZXZlbnRzX3BhbmVsYmFyICV9KSlcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCBpdCwgdGhlIGl0ZW0gd2lsbCByZW1haW4gY29sbGFwc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIGFuIGl0ZW0gaXMgYWJvdXQgdG8gYmUgY29sbGFwc2VkLlxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGV2ZW50c19wYW5lbGJhciAlfSkpXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgaXQsIHRoZSBpdGVtIHdpbGwgcmVtYWluIGV4cGFuZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xsYXBzZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy50YWJJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucm9sZSA9ICd0cmVlJztcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLmFjdGl2ZURlc2NlbmRhbnQgPSAnJztcbiAgICAgICAgdGhpcy5pc1ZpZXdJbml0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2tlZXBJdGVtQ29udGVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuSGVpZ2h0ID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVsYmFySGVpZ2h0ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgY29udGVudE92ZXJmbG93ID0gdGhpcy5leHBhbmRNb2RlID09PSBQYW5lbEJhckV4cGFuZE1vZGUuRnVsbCA/ICdhdXRvJyA6ICd2aXNpYmxlJztcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5JdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuSGVpZ2h0ICs9IGl0ZW0uaGVhZGVySGVpZ2h0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5JdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0uY29udGVudEhlaWdodCA9IFBhbmVsQmFyRXhwYW5kTW9kZS5GdWxsID09PSB0aGlzLmV4cGFuZE1vZGUgPyAocGFuZWxiYXJIZWlnaHQgLSBjaGlsZHJlbkhlaWdodCkgKyAncHgnIDogJ2F1dG8nO1xuICAgICAgICAgICAgICAgIGl0ZW0uY29udGVudE92ZXJmbG93ID0gY29udGVudE92ZXJmbG93O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1saW5lICovXG4gICAgICAgIHRoaXMua2V5QmluZGluZ3MgPSB0aGlzLmNvbXB1dGVkS2V5cztcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UgPSBldmVudFNlcnZpY2U7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmNoaWxkcmVuJC5zdWJzY3JpYmUoZXZlbnQgPT4gdGhpcy5vbkl0ZW1BY3Rpb24oZXZlbnQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgUGFuZWxCYXIgcmVuZGVycyB0aGUgY29udGVudCBvZiBhbGwgaXRlbXMgYW5kIHRoZXkgYXJlIHBlcnNpc3RlZCBpbiB0aGUgRE9NXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0ZW1wbGF0ZXNfcGFuZWxiYXIgJX0jdG9jLWNvbGxlY3Rpb25zKSkuXG4gICAgICogQnkgZGVmYXVsdCwgdGhpcyBvcHRpb24gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgICovXG4gICAgZ2V0IGtlZXBJdGVtQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tlZXBJdGVtQ29udGVudDtcbiAgICB9XG4gICAgc2V0IGtlZXBJdGVtQ29udGVudChrZWVwSXRlbUNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fa2VlcEl0ZW1Db250ZW50ID0ga2VlcEl0ZW1Db250ZW50O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5vbktlZXBDb250ZW50KGtlZXBJdGVtQ29udGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGl0ZW1zIG9mIHRoZSBQYW5lbEJhciBhcyBhbiBhcnJheSBvZiBgUGFuZWxCYXJJdGVtTW9kZWxgIGluc3RhbmNlc1xuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaXRlbXNfcGFuZWxiYXIgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgaXRlbXMoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSB1dGlsLnBhcnNlUGFuZWxCYXJJdGVtcyhkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcztcbiAgICB9XG4gICAgZ2V0IGhvc3RIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuZE1vZGUgPT09IFBhbmVsQmFyRXhwYW5kTW9kZS5GdWxsID8gdGhpcy5oZWlnaHQgOiAnYXV0byc7XG4gICAgfVxuICAgIGdldCBvdmVyZmxvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kTW9kZSA9PT0gUGFuZWxCYXJFeHBhbmRNb2RlLkZ1bGwgPyAnaGlkZGVuJyA6ICd2aXNpYmxlJztcbiAgICB9XG4gICAgZ2V0IGRpcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpbnZlcnRLZXlzKG9yaWdpbmFsLCBpbnZlcnRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gaW52ZXJ0ZWQgOiBvcmlnaW5hbDtcbiAgICB9XG4gICAgZ2V0IGNvbXB1dGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtLZXlzLlNwYWNlXTogKCkgPT4gdGhpcy5zZWxlY3RGb2N1c2VkSXRlbSgpLFxuICAgICAgICAgICAgW0tleXMuRW50ZXJdOiAoKSA9PiB0aGlzLnNlbGVjdEZvY3VzZWRJdGVtKCksXG4gICAgICAgICAgICBbS2V5cy5BcnJvd1VwXTogKCkgPT4gdGhpcy5mb2N1c1ByZXZpb3VzSXRlbSgpLFxuICAgICAgICAgICAgW3RoaXMuaW52ZXJ0S2V5cyhLZXlzLkFycm93TGVmdCwgS2V5cy5BcnJvd1JpZ2h0KV06ICgpID0+IHRoaXMuY29sbGFwc2VJdGVtKCksXG4gICAgICAgICAgICBbS2V5cy5BcnJvd0Rvd25dOiAoKSA9PiB0aGlzLmZvY3VzTmV4dEl0ZW0oKSxcbiAgICAgICAgICAgIFt0aGlzLmludmVydEtleXMoS2V5cy5BcnJvd1JpZ2h0LCBLZXlzLkFycm93TGVmdCldOiAoKSA9PiB0aGlzLmV4cGFuZEl0ZW0oKSxcbiAgICAgICAgICAgIFtLZXlzLkVuZF06ICgpID0+IHRoaXMuZm9jdXNMYXN0SXRlbSgpLFxuICAgICAgICAgICAgW0tleXMuSG9tZV06ICgpID0+IHRoaXMuZm9jdXNGaXJzdEl0ZW0oKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uXG4gICAgICAgICAgICAuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5rZXlCaW5kaW5ncyA9IHRoaXMuY29tcHV0ZWRLZXlzKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYW5pbWF0ZSA9IHRoaXMuYW5pbWF0ZTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZXhwYW5kTW9kZSA9IHRoaXMuZXhwYW5kTW9kZTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbkl0ZW1zID0gdGhpcy52aWV3Q2hpbGRJdGVtcy50b0FycmF5KCk7XG4gICAgICAgICAgICB0aGlzLmFsbEl0ZW1zID0gdGhpcy52aWV3SXRlbXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuSXRlbXMgPSB0aGlzLmNvbnRlbnRDaGlsZEl0ZW1zLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIHRoaXMuYWxsSXRlbXMgPSB0aGlzLmNvbnRlbnRJdGVtcy50b0FycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3SW5pdCAmJiB0aGlzLmNoaWxkcmVuSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmlzVmlld0luaXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVDaGlsZHJlbkhlaWdodCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbGlkYXRlQ29uZmlndXJhdGlvbigpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzWydoZWlnaHQnXSB8fCBjaGFuZ2VzWydleHBhbmRNb2RlJ10gfHwgY2hhbmdlc1snaXRlbXMnXSkgeyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbkl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLnVwZGF0ZUNoaWxkcmVuSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5hbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hbmltYXRlID0gdGhpcy5hbmltYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLmV4cGFuZE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmV4cGFuZE1vZGUgPSB0aGlzLmV4cGFuZE1vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRlbXBsYXRlUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZSA/IHRoaXMudGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNvbXBvbmVudENsaWNrKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGl0ZW1DbGlja2VkID0gdGhpcy52aXNpYmxlSXRlbXMoKS5zb21lKChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5oZWFkZXIubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpc0ZvY3VzYWJsZShldmVudC50YXJnZXQpICYmICF0aGlzLmZvY3VzZWQgJiYgaXRlbUNsaWNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ29tcG9uZW50Rm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLm9uRm9jdXMoKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYWxsSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZUl0ZW1zID0gdGhpcy52aXNpYmxlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRJdGVtcyA9IHZpc2libGVJdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmZvY3VzZWQpO1xuICAgICAgICAgICAgaWYgKCFmb2N1c2VkSXRlbXMubGVuZ3RoICYmIHZpc2libGVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZUl0ZW1zWzBdLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IHZpc2libGVJdGVtc1swXS5pdGVtSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ29tcG9uZW50Qmx1cigpIHtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2Uub25CbHVyKCk7XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFjdGl2ZURlc2NlbmRhbnQgPSAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ29tcG9uZW50S2V5RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtleXMuU3BhY2UgfHwgZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5BcnJvd1VwIHx8IGV2ZW50LmtleUNvZGUgPT09IEtleXMuQXJyb3dEb3duIHx8XG4gICAgICAgICAgICAgICAgZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5BcnJvd0xlZnQgfHwgZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5BcnJvd1JpZ2h0IHx8IGV2ZW50LmtleUNvZGUgPT09IEtleXMuSG9tZSB8fFxuICAgICAgICAgICAgICAgIGV2ZW50LmtleUNvZGUgPT09IEtleXMuRW5kIHx8IGV2ZW50LmtleUNvZGUgPT09IEtleXMuUGFnZVVwIHx8IGV2ZW50LmtleUNvZGUgPT09IEtleXMuUGFnZURvd24pIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMua2V5QmluZGluZ3NbZXZlbnQua2V5Q29kZV07XG4gICAgICAgICAgICAvL1RPRE86IGNoZWNrIGlmIG5leHQgaXRlbSBpcyBkaXNhYmxlZCBhbmQgc2tpcCBvcGVyYXRpb24/XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZW1pdEV2ZW50KGV2ZW50LCBpdGVtKSB7XG4gICAgICAgIGxldCBldmVudEFyZ3M7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICAgICAgZXZlbnRBcmdzID0gbmV3IFBhbmVsQmFyU2VsZWN0RXZlbnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbGxhcHNlJzpcbiAgICAgICAgICAgICAgICBldmVudEFyZ3MgPSBuZXcgUGFuZWxCYXJDb2xsYXBzZUV2ZW50KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGV2ZW50QXJncyA9IG5ldyBQYW5lbEJhckV4cGFuZEV2ZW50KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRBcmdzLml0ZW0gPSBpdGVtLnNlcmlhbGl6ZSgpO1xuICAgICAgICB0aGlzW2V2ZW50XS5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIHJldHVybiBldmVudEFyZ3M7XG4gICAgfVxuICAgIGdldCB2aWV3SXRlbXMoKSB7XG4gICAgICAgIGxldCB0cmVlSXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3Q2hpbGRJdGVtcy50b0FycmF5KCkuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIHRyZWVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgdHJlZUl0ZW1zID0gdHJlZUl0ZW1zLmNvbmNhdChpdGVtLnN1YlRyZWVWaWV3SXRlbXMoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJlZUl0ZW1zO1xuICAgIH1cbiAgICB2YWxpZGF0ZUNvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXMgJiYgKHRoaXMuY29udGVudEl0ZW1zICYmIHRoaXMuY29udGVudEl0ZW1zLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbmZpZ3VyYXRpb246IG1peGVkIHRlbXBsYXRlIGNvbXBvbmVudHMgYW5kIGl0ZW1zIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9uSXRlbUFjdGlvbihpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtb2RpZmllZEl0ZW1zID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuYWxsSXRlbXNcbiAgICAgICAgICAgIC5mb3JFYWNoKChjdXJyZW50SXRlbSkgPT4ge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkU3RhdGUgPSBjdXJyZW50SXRlbSA9PT0gaXRlbTtcbiAgICAgICAgICAgIGxldCBmb2N1c2VkU3RhdGUgPSBzZWxlY3RlZFN0YXRlO1xuICAgICAgICAgICAgc2VsZWN0ZWRTdGF0ZSA9IHRoaXMuc2VsZWN0YWJsZSA/IHNlbGVjdGVkU3RhdGUgOiBjdXJyZW50SXRlbS5zZWxlY3RlZDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SXRlbS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWRTdGF0ZSB8fCBjdXJyZW50SXRlbS5mb2N1c2VkICE9PSBmb2N1c2VkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1NlbGVjdFByZXZlbnRlZCA9IHNlbGVjdGVkU3RhdGUgPyB0aGlzLmVtaXRFdmVudCgnc2VsZWN0JywgY3VycmVudEl0ZW0pLmlzRGVmYXVsdFByZXZlbnRlZCgpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1NlbGVjdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SXRlbS5zZWxlY3RlZCA9IHNlbGVjdGVkU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVtLmZvY3VzZWQgPSBmb2N1c2VkU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IGZvY3VzZWRTdGF0ZSA/IGN1cnJlbnRJdGVtLml0ZW1JZCA6ICcnO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEl0ZW1zLnB1c2goY3VycmVudEl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZE1vZGUgPT09IFBhbmVsQmFyRXhwYW5kTW9kZS5NdWx0aXBsZSkge1xuICAgICAgICAgICAgaWYgKChpdGVtLmhhc0NoaWxkSXRlbXMgfHwgaXRlbS5oYXNDb250ZW50KSAmJiBpdGVtLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFdmVudFByZXZlbnRlZCA9IGl0ZW0uZXhwYW5kZWQgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudCgnY29sbGFwc2UnLCBpdGVtKS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KCdleHBhbmQnLCBpdGVtKS5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRXZlbnRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5leHBhbmRlZCA9ICFpdGVtLmV4cGFuZGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWRJdGVtcy5pbmRleE9mKGl0ZW0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNpYmxpbmdzID0gaXRlbS5wYXJlbnQgPyBpdGVtLnBhcmVudC5jaGlsZHJlbkl0ZW1zIDogdGhpcy5jaGlsZHJlbkl0ZW1zO1xuICAgICAgICAgICAgbGV0IHByZXZlbnRlZENvbGxhcHNlSXRlbTtcbiAgICAgICAgICAgIGxldCBleHBhbmRlZEl0ZW1zID0gW107XG4gICAgICAgICAgICBpZiAoKGl0ZW0uaGFzQ2hpbGRJdGVtcyB8fCBpdGVtLmhhc0NvbnRlbnQpICYmIGl0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nc1xuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoY3VycmVudEl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV4cGFuZGVkU3RhdGUgPSBjdXJyZW50SXRlbSA9PT0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmV4cGFuZGVkICE9PSBleHBhbmRlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0V2ZW50UHJldmVudGVkID0gY3VycmVudEl0ZW0uZXhwYW5kZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KCdjb2xsYXBzZScsIGN1cnJlbnRJdGVtKS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoJ2V4cGFuZCcsIGN1cnJlbnRJdGVtKS5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNFdmVudFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVtLmV4cGFuZGVkID0gZXhwYW5kZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEl0ZW0uZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWRJdGVtcy5wdXNoKGN1cnJlbnRJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVkSXRlbXMuaW5kZXhPZihjdXJyZW50SXRlbSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSXRlbXMucHVzaChjdXJyZW50SXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNFdmVudFByZXZlbnRlZCAmJiBjdXJyZW50SXRlbS5leHBhbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRlZENvbGxhcHNlSXRlbSA9IGN1cnJlbnRJdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJdGVtLmV4cGFuZGVkID09PSBleHBhbmRlZFN0YXRlICYmIGV4cGFuZGVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQ29sbGFwc2VQcmV2ZW50ZWQgPSB0aGlzLmVtaXRFdmVudCgnY29sbGFwc2UnLCBjdXJyZW50SXRlbSkuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ29sbGFwc2VQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SXRlbS5leHBhbmRlZCA9ICFjdXJyZW50SXRlbS5leHBhbmRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWRJdGVtcy5pbmRleE9mKGN1cnJlbnRJdGVtKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJdGVtcy5wdXNoKGN1cnJlbnRJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBleHBhbmRlZEl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50ZWRDb2xsYXBzZUl0ZW0gJiYgaXRlbS5pZCAhPT0gcHJldmVudGVkQ29sbGFwc2VJdGVtLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBhbmRNb2RlID0gUGFuZWxCYXJFeHBhbmRNb2RlW3RoaXMuZXhwYW5kTW9kZV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSAke2V4cGFuZE1vZGV9IGV4cGFuZE1vZGUgYWxsb3dzIHRoZSBleHBhbnNpb24gb2Ygb25seSBvbmUgaXRlbSBhdCBhIHRpbWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWktZGV2ZWxvcC9jb21wb25lbnRzL2xheW91dC9wYW5lbGJhci9leHBhbmQtbW9kZXMvYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kaWZpZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlLmVtaXQobW9kaWZpZWRJdGVtcy5tYXAoY3VycmVudEl0ZW0gPT4gY3VycmVudEl0ZW0uc2VyaWFsaXplKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1Zpc2libGUoaXRlbSkge1xuICAgICAgICBjb25zdCB2aXNpYmxlSXRlbXMgPSB0aGlzLnZpc2libGVJdGVtcygpO1xuICAgICAgICByZXR1cm4gdmlzaWJsZUl0ZW1zLnNvbWUoaSA9PiBpID09PSBpdGVtKTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZVBhcmVudChpdGVtKSB7XG4gICAgICAgIGNvbnN0IHZpc2libGVJdGVtcyA9IHRoaXMudmlzaWJsZUl0ZW1zKCk7XG4gICAgICAgIGlmICghaXRlbS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlSXRlbXMuc29tZShpID0+IGkgPT09IGl0ZW0ucGFyZW50KSA/IGl0ZW0ucGFyZW50IDogdGhpcy5nZXRWaXNpYmxlUGFyZW50KGl0ZW0ucGFyZW50KTtcbiAgICB9XG4gICAgZm9jdXNJdGVtKGFjdGlvbikge1xuICAgICAgICBjb25zdCB2aXNpYmxlSXRlbXMgPSB0aGlzLnZpc2libGVJdGVtcygpO1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdmlzaWJsZUl0ZW1zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0uZm9jdXNlZCk7XG4gICAgICAgIGxldCBjdXJyZW50SXRlbSA9IHZpc2libGVJdGVtc1tjdXJyZW50SW5kZXhdO1xuICAgICAgICBsZXQgbmV4dEl0ZW07XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgZm9jdXNlZEl0ZW0gPSB0aGlzLmFsbEl0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLmZvY3VzZWQpO1xuICAgICAgICAgICAgZm9jdXNlZEl0ZW0uZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY3VycmVudEl0ZW0gPSB0aGlzLmdldFZpc2libGVQYXJlbnQoZm9jdXNlZEl0ZW0pO1xuICAgICAgICAgICAgY3VycmVudEluZGV4ID0gdmlzaWJsZUl0ZW1zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0gPT09IGN1cnJlbnRJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbGFzdEl0ZW0nOlxuICAgICAgICAgICAgICAgIG5leHRJdGVtID0gdmlzaWJsZUl0ZW1zW3Zpc2libGVJdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZpcnN0SXRlbSc6XG4gICAgICAgICAgICAgICAgbmV4dEl0ZW0gPSB2aXNpYmxlSXRlbXNbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduZXh0SXRlbSc6XG4gICAgICAgICAgICAgICAgbmV4dEl0ZW0gPSB2aXNpYmxlSXRlbXNbY3VycmVudEluZGV4IDwgdmlzaWJsZUl0ZW1zLmxlbmd0aCAtIDEgPyBjdXJyZW50SW5kZXggKyAxIDogMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwcmV2aW91c0l0ZW0nOlxuICAgICAgICAgICAgICAgIG5leHRJdGVtID0gdmlzaWJsZUl0ZW1zW2N1cnJlbnRJbmRleCA+IDAgPyBjdXJyZW50SW5kZXggLSAxIDogdmlzaWJsZUl0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEl0ZW0gJiYgbmV4dEl0ZW0gJiYgY3VycmVudEl0ZW0gIT09IG5leHRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVGb2N1cyhjdXJyZW50SXRlbSwgbmV4dEl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmVGb2N1cyhmcm9tLCB0bykge1xuICAgICAgICBmcm9tLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdG8uZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IHRvLml0ZW1JZDtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRJdGVtcyA9IG5ldyBBcnJheShmcm9tLnNlcmlhbGl6ZSgpLCB0by5zZXJpYWxpemUoKSk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2UuZW1pdChtb2RpZmllZEl0ZW1zKTtcbiAgICB9XG4gICAgZm9jdXNMYXN0SXRlbSgpIHtcbiAgICAgICAgdGhpcy5mb2N1c0l0ZW0oJ2xhc3RJdGVtJyk7XG4gICAgfVxuICAgIGZvY3VzRmlyc3RJdGVtKCkge1xuICAgICAgICB0aGlzLmZvY3VzSXRlbSgnZmlyc3RJdGVtJyk7XG4gICAgfVxuICAgIGZvY3VzTmV4dEl0ZW0oKSB7XG4gICAgICAgIHRoaXMuZm9jdXNJdGVtKCduZXh0SXRlbScpO1xuICAgIH1cbiAgICBmb2N1c1ByZXZpb3VzSXRlbSgpIHtcbiAgICAgICAgdGhpcy5mb2N1c0l0ZW0oJ3ByZXZpb3VzSXRlbScpO1xuICAgIH1cbiAgICBleHBhbmRJdGVtKCkge1xuICAgICAgICBsZXQgY3VycmVudEl0ZW0gPSB0aGlzLmFsbEl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uZm9jdXNlZClbMF07XG4gICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUoY3VycmVudEl0ZW0pKSB7XG4gICAgICAgICAgICBjdXJyZW50SXRlbS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBjdXJyZW50SXRlbSA9IHRoaXMuZ2V0VmlzaWJsZVBhcmVudChjdXJyZW50SXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmhhc0NoaWxkSXRlbXMgfHwgY3VycmVudEl0ZW0uaGFzQ29udGVudCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50SXRlbS5leHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25JdGVtQWN0aW9uKGN1cnJlbnRJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJdGVtLmhhc0NoaWxkSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdENoaWxkSW5kZXggPSBjdXJyZW50SXRlbS5jaGlsZHJlbkl0ZW1zLmZpbmRJbmRleChpdGVtID0+ICFpdGVtLmRpc2FibGVkKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RDaGlsZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlRm9jdXMoY3VycmVudEl0ZW0sIGN1cnJlbnRJdGVtLmNoaWxkcmVuSXRlbXNbZmlyc3RDaGlsZEluZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxhcHNlSXRlbSgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEl0ZW0gPSB0aGlzLmFsbEl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uZm9jdXNlZClbMF07XG4gICAgICAgIGlmIChjdXJyZW50SXRlbS5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5vbkl0ZW1BY3Rpb24oY3VycmVudEl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJdGVtLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlRm9jdXMoY3VycmVudEl0ZW0sIGN1cnJlbnRJdGVtLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0Rm9jdXNlZEl0ZW0oKSB7XG4gICAgICAgIGxldCBmb2N1c2VkSXRlbSA9IHRoaXMuYWxsSXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5mb2N1c2VkKVswXTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZShmb2N1c2VkSXRlbSkpIHtcbiAgICAgICAgICAgIGZvY3VzZWRJdGVtLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvY3VzZWRJdGVtID0gdGhpcy5nZXRWaXNpYmxlUGFyZW50KGZvY3VzZWRJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXNlZEl0ZW0pIHtcbiAgICAgICAgICAgIGZvY3VzZWRJdGVtLm9uSXRlbUFjdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2libGVJdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdFZpc2libGVJdGVtcyh0aGlzLmNoaWxkcmVuSXRlbXMpO1xuICAgIH1cbiAgICBmbGF0VmlzaWJsZUl0ZW1zKGxpc3RPZkl0ZW1zID0gbmV3IEFycmF5KCksIGZsYXR0ZWRJdGVtcyA9IG5ldyBBcnJheSgpKSB7XG4gICAgICAgIGxpc3RPZkl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBmbGF0dGVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmV4cGFuZGVkICYmIGl0ZW0uaGFzQ2hpbGRJdGVtcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmxhdFZpc2libGVJdGVtcyhpdGVtLmNoaWxkcmVuSXRlbXMsIGZsYXR0ZWRJdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmxhdHRlZEl0ZW1zO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBQYW5lbEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kTW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFBhbmVsQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUGFuZWxCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBhbmVsQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBQYW5lbEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwia2VlcEl0ZW1Db250ZW50XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgUGFuZWxCYXJDb21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1zXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFBhbmVsQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGF0ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFBhbmVsQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBQYW5lbEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgUGFuZWxCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbGxhcHNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci50YWJJbmRleCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBQYW5lbEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFuZWxCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInJvbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXBhbmVsYmFyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBQYW5lbEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFuZWxCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZURlc2NlbmRhbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5oZWlnaHQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQYW5lbEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdEhlaWdodFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5vdmVyZmxvdycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFBhbmVsQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvdmVyZmxvd1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmRpcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFBhbmVsQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoUGFuZWxCYXJJdGVtVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUGFuZWxCYXJJdGVtVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBQYW5lbEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihQYW5lbEJhckl0ZW1Db21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFBhbmVsQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250ZW50SXRlbXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihQYW5lbEJhckl0ZW1Db21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBQYW5lbEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGVudENoaWxkSXRlbXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZHJlbihQYW5lbEJhckl0ZW1Db21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBQYW5lbEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmlld0NoaWxkSXRlbXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIFBhbmVsQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkNvbXBvbmVudENsaWNrXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdmb2N1cycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgUGFuZWxCYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9uQ29tcG9uZW50Rm9jdXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0TGlzdGVuZXIoJ2JsdXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIFBhbmVsQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkNvbXBvbmVudEJsdXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIFBhbmVsQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkNvbXBvbmVudEtleURvd25cIiwgbnVsbCk7XG5QYW5lbEJhckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9QYW5lbGJhcicsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgUGFuZWxCYXJTZXJ2aWNlLFxuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLnBhbmVsYmFyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXBhbmVsYmFyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgKm5nSWY9XCJjb250ZW50Q2hpbGRJdGVtcyAmJiAhaXRlbXNcIiBzZWxlY3Q9XCJrZW5kby1wYW5lbGJhci1pdGVtXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaXRlbXM/Lmxlbmd0aFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPlxuICAgICAgICAgICAgICAgIDxrZW5kby1wYW5lbGJhci1pdGVtICpuZ0lmPVwiIWl0ZW0uaGlkZGVuXCJcbiAgICAgICAgICAgICAgICAgICAgW3RpdGxlXT1cIml0ZW0udGl0bGVcIlxuICAgICAgICAgICAgICAgICAgICBbaWRdPVwiaXRlbS5pZFwiXG4gICAgICAgICAgICAgICAgICAgIFtpY29uXT1cIml0ZW0uaWNvblwiXG4gICAgICAgICAgICAgICAgICAgIFtpY29uQ2xhc3NdPVwiaXRlbS5pY29uQ2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICBbaW1hZ2VVcmxdPVwiaXRlbS5pbWFnZVVybFwiXG4gICAgICAgICAgICAgICAgICAgIFtzZWxlY3RlZF09XCIhIWl0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICBbZXhwYW5kZWRdPVwiISFpdGVtLmV4cGFuZGVkXCJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cIiEhaXRlbS5kaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZV09XCJ0ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgIFtpdGVtc109XCJpdGVtLmNoaWxkcmVuXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRlbnRdPVwiaXRlbS5jb250ZW50XCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC9rZW5kby1wYW5lbGJhci1pdGVtPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pXG4gICAgLy8gVE9ETzogYWRkIHN0eWxlcyBhcyBpbnB1dCBwcm9wXG4gICAgLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgUGFuZWxCYXJTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFBhbmVsQmFyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBwYW5lIGNvbXBvbmVudCBvZiB0aGUgU3BsaXR0ZXIuXG4gKi9cbmxldCBTcGxpdHRlclBhbmVDb21wb25lbnQgPSBjbGFzcyBTcGxpdHRlclBhbmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHJlbmRlcmVyLCBjZHIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgdXNlciBpcyBhbGxvd2VkIHRvIHJlc2l6ZSB0aGUgcGFuZSBhbmQgcHJvdmlkZSBzcGFjZSBmb3Igb3RoZXIgcGFuZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2l6YWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIHVzZXIgaXMgYWxsb3dlZCB0byBoaWRlIHRoZSBwYW5lIGFuZCBwcm92aWRlIHNwYWNlIGZvciBvdGhlciBwYW5lcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2libGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiBvdmVyZmxvd2luZyBjb250ZW50IGlzIHNjcm9sbGFibGUgb3IgaGlkZGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgcGFuZSBpcyBpbml0aWFsbHkgY29sbGFwc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm92ZXJsYXlDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgcmVzaXplcyB0aGUgU3BsaXR0ZXIgcGFuZS5cbiAgICAgICAgICogVGhlIGV2ZW50IGRhdGEgY29udGFpbnMgdGhlIG5ldyBwYW5lIHNpemUuXG4gICAgICAgICAqIEFsbG93cyBhIHR3by13YXkgYmluZGluZyBvZiB0aGUgcGFuZSBgc2l6ZWAgcHJvcGVydHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpemVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGBjb2xsYXBzZWRgIHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICAgICAqIFRoZSBldmVudCBkYXRhIGNvbnRhaW5zIHRoZSBuZXcgcHJvcGVydHkgc3RhdGUuXG4gICAgICAgICAqIEFsbG93cyBhIHR3by13YXkgYmluZGluZyBvZiB0aGUgYGNvbGxhcHNlZGAgcGFuZSBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvcmNlRXhwYW5kID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzUmVzaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IG9yZGVyKHBhbmVPcmRlcikge1xuICAgICAgICB0aGlzLl9vcmRlciA9IHBhbmVPcmRlcjtcbiAgICAgICAgdGhpcy5zZXRPcmRlclN0eWxlcygpO1xuICAgIH1cbiAgICBnZXQgb3JkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5pdGlhbCBzaXplIG9mIHRoZSBwYW5lLlxuICAgICAqIEhhcyB0byBiZSBiZXR3ZWVuIHRoZSBgbWluYCBhbmQgYG1heGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBzZXQgc2l6ZShuZXdTaXplKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSBuZXdTaXplO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWxlbWVudCwgJy1tcy1mbGV4LXByZWZlcnJlZC1zaXplJywgbmV3U2l6ZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWxlbWVudCwgJ2ZsZXgtYmFzaXMnLCBuZXdTaXplKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGljUGFuZUNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLXBhbmUtc3RhdGljJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW1lbnQsICdrLXBhbmUtc3RhdGljJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGNvbnRhaW5zU3BsaXR0ZXIodmFsdWUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgJ2stcGFuZS1mbGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW1lbnQsICdrLXBhbmUtZmxleCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0hpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGFwc2VkO1xuICAgIH1cbiAgICBnZXQgc3RhdGljUGFuZUNsYXNzKCkge1xuICAgICAgICBpZiAodGhpcy5mb3JjZUV4cGFuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy5yZXNpemFibGUgJiYgIXRoaXMuY29sbGFwc2libGUgfHwgdGhpcy5maXhlZFNpemU7XG4gICAgfVxuICAgIGdldCBzY3JvbGxhYmxlUGFuZUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxhYmxlO1xuICAgIH1cbiAgICBnZXQgZml4ZWRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplICYmIHRoaXMuc2l6ZS5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgJ2stc3RhdGUtaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdoaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ2stc3RhdGUtaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW1lbnQsICdoaWRkZW4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbXB1dGVkU2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvZ2dsZU92ZXJsYXkoc2hvdykge1xuICAgICAgICB0aGlzLm92ZXJsYXlDb250ZW50ID0gc2hvdztcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZGV0ZWN0Q2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICBzZXRPcmRlclN0eWxlcygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsICctbXMtZmxleC1vcmRlcicsIHRoaXMub3JkZXIpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsICdvcmRlcicsIHRoaXMub3JkZXIpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcbl0sIFNwbGl0dGVyUGFuZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3JkZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIFNwbGl0dGVyUGFuZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNwbGl0dGVyUGFuZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTcGxpdHRlclBhbmVDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNwbGl0dGVyUGFuZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicmVzaXphYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU3BsaXR0ZXJQYW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xsYXBzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNwbGl0dGVyUGFuZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2Nyb2xsYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNwbGl0dGVyUGFuZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sbGFwc2VkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTcGxpdHRlclBhbmVDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgU3BsaXR0ZXJQYW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250YWluc1NwbGl0dGVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNwbGl0dGVyUGFuZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3ZlcmxheUNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBTcGxpdHRlclBhbmVDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBTcGxpdHRlclBhbmVDb21wb25lbnQucHJvdG90eXBlLCBcImNvbGxhcHNlZENoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstcGFuZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU3BsaXR0ZXJQYW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0Q2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXBhbmUtc3RhdGljJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFNwbGl0dGVyUGFuZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhdGljUGFuZUNsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc2Nyb2xsYWJsZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBTcGxpdHRlclBhbmVDb21wb25lbnQucHJvdG90eXBlLCBcInNjcm9sbGFibGVQYW5lQ2xhc3NcIiwgbnVsbCk7XG5TcGxpdHRlclBhbmVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvU3BsaXR0ZXJQYW5lJyxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1zcGxpdHRlci1wYW5lJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFjb2xsYXBzZWRcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDxkaXYgKm5nSWY9XCJvdmVybGF5Q29udGVudFwiIGNsYXNzPVwiay1zcGxpdHRlci1vdmVybGF5IGstb3ZlcmxheVwiPjwvZGl2PlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgU3BsaXR0ZXJQYW5lQ29tcG9uZW50KTtcblxuY29uc3QgU0laSU5HX0RPQ19MSU5LID0gJ2h0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9sYXlvdXQvc3BsaXR0ZXIvcGFuZXMvI3RvYy1zaXplJztcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU3BsaXR0ZXJTZXJ2aWNlID0gY2xhc3MgU3BsaXR0ZXJTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcih6b25lKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMubGF5b3V0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lclNpemUgPSAoKSA9PiB7IH07XG4gICAgfVxuICAgIHRyeVRvZ2dsZShwYW5lSW5kZXgpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMucGFuZShwYW5lSW5kZXgpO1xuICAgICAgICBpZiAocGFuZS5jb2xsYXBzaWJsZSkge1xuICAgICAgICAgICAgcGFuZS5jb2xsYXBzZWQgPSAhcGFuZS5jb2xsYXBzZWQ7XG4gICAgICAgICAgICBwYW5lLmNvbGxhcHNlZENoYW5nZS5lbWl0KHBhbmUuY29sbGFwc2VkKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmxheW91dENoYW5nZSwge30pO1xuICAgICAgICAgICAgaWYgKHBhbmUuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgcGFuZS5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm90Q29sbGFwc2VkID0gdGhpcy5wYW5lcy5maWx0ZXIocCA9PiAhcC5jb2xsYXBzZWQpO1xuICAgICAgICBjb25zdCBhbGxIYXZlRml4ZWRTaXplID0gbm90Q29sbGFwc2VkLmV2ZXJ5KHAgPT4gcC5maXhlZFNpemUpO1xuICAgICAgICBub3RDb2xsYXBzZWRbbm90Q29sbGFwc2VkLmxlbmd0aCAtIDFdLmZvcmNlRXhwYW5kID0gYWxsSGF2ZUZpeGVkU2l6ZSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHBhbmUuY29sbGFwc2libGU7XG4gICAgfVxuICAgIHRvZ2dsZUNvbnRlbnRPdmVybGF5KGluZGV4LCBzaG93KSB7XG4gICAgICAgIHRoaXMucGFuZShpbmRleCkudG9nZ2xlT3ZlcmxheShzaG93KTtcbiAgICAgICAgdGhpcy5wYW5lKGluZGV4ICsgMSkudG9nZ2xlT3ZlcmxheShzaG93KTtcbiAgICB9XG4gICAgZHJhZ1N0YXRlKHNwbGl0YmFySW5kZXgpIHtcbiAgICAgICAgbGV0IHByZXYgPSB0aGlzLnBhbmUoc3BsaXRiYXJJbmRleCk7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5wYW5lKHNwbGl0YmFySW5kZXggKyAxKTtcbiAgICAgICAgY29uc3QgdG90YWwgPSBwcmV2LmNvbXB1dGVkU2l6ZSArIG5leHQuY29tcHV0ZWRTaXplO1xuICAgICAgICBjb25zdCBweCA9IHMgPT4gdGhpcy50b1BpeGVscyhzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZXY6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogc3BsaXRiYXJJbmRleCxcbiAgICAgICAgICAgICAgICBpbml0aWFsU2l6ZTogcHJldi5jb21wdXRlZFNpemUsXG4gICAgICAgICAgICAgICAgbWluOiBweChwcmV2Lm1pbikgfHwgdG90YWwgLSBweChuZXh0Lm1heCkgfHwgMCxcbiAgICAgICAgICAgICAgICBtYXg6IHB4KHByZXYubWF4KSB8fCB0b3RhbCAtIHB4KG5leHQubWluKSB8fCB0b3RhbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogc3BsaXRiYXJJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFNpemU6IG5leHQuY29tcHV0ZWRTaXplLFxuICAgICAgICAgICAgICAgIG1pbjogcHgobmV4dC5taW4pIHx8IHRvdGFsIC0gcHgocHJldi5tYXgpIHx8IDAsXG4gICAgICAgICAgICAgICAgbWF4OiBweChuZXh0Lm1heCkgfHwgdG90YWwgLSBweChwcmV2Lm1pbikgfHwgdG90YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0U2l6ZShzdGF0ZSQkMSwgZGVsdGEpIHtcbiAgICAgICAgY29uc3QgY2xhbXAgPSAobWluLCBtYXgsIHYpID0+IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2KSk7XG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9IChwYW5lU3RhdGUsIGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMucGFuZShwYW5lU3RhdGUuaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgc3BsaXR0ZXJTaXplID0gdGhpcy5jb250YWluZXJTaXplKCk7XG4gICAgICAgICAgICBjb25zdCBuZXdTaXplID0gY2xhbXAocGFuZVN0YXRlLm1pbiwgcGFuZVN0YXRlLm1heCwgcGFuZVN0YXRlLmluaXRpYWxTaXplICsgY2hhbmdlKTtcbiAgICAgICAgICAgIGxldCBzaXplID0gXCJcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUGVyY2VudChwYW5lLnNpemUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9ICgxMDAgKiBuZXdTaXplIC8gc3BsaXR0ZXJTaXplKSArIFwiJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IG5ld1NpemUgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYW5lLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcGFuZS5pc1Jlc2l6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KHBhbmUuc2l6ZUNoYW5nZSwgc2l6ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLnBhbmUoc3RhdGUkJDEucHJldi5pbmRleCk7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLnBhbmUoc3RhdGUkJDEubmV4dC5pbmRleCk7XG4gICAgICAgIC8vIGRldGVybWluZSB3aGljaCBwYW5lIHRvIHJlc2l6ZVxuICAgICAgICBpZiAocHJldi5maXhlZFNpemUgJiYgbmV4dC5maXhlZFNpemUpIHtcbiAgICAgICAgICAgIC8vIHJlc2l6aW5nIGJvdGggcGFuZXNcbiAgICAgICAgICAgIHJlc2l6ZShzdGF0ZSQkMS5wcmV2LCBkZWx0YSk7XG4gICAgICAgICAgICByZXNpemUoc3RhdGUkJDEubmV4dCwgLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXh0LmNvbGxhcHNpYmxlIHx8IG5leHQuZml4ZWRTaXplKSB7XG4gICAgICAgICAgICAvLyByZXNpemluZyBuZXh0XG4gICAgICAgICAgICByZXNpemUoc3RhdGUkJDEubmV4dCwgLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlc2l6aW5nIHByZXZcbiAgICAgICAgICAgIHJlc2l6ZShzdGF0ZSQkMS5wcmV2LCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KHRoaXMubGF5b3V0Q2hhbmdlLCB7fSk7XG4gICAgfVxuICAgIGlzRHJhZ2dhYmxlKHNwbGl0QmFySW5kZXgpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMucGFuZShzcGxpdEJhckluZGV4KTtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMucGFuZShzcGxpdEJhckluZGV4ICsgMSk7XG4gICAgICAgIGNvbnN0IGJldHdlZW5SZXNpemFibGVQYW5lcyA9IHByZXYucmVzaXphYmxlICYmIG5leHQucmVzaXphYmxlO1xuICAgICAgICBjb25zdCBuZWFyQ29sbGFwc2VkUGFuZSA9IHByZXYuY29sbGFwc2VkIHx8IG5leHQuY29sbGFwc2VkO1xuICAgICAgICByZXR1cm4gYmV0d2VlblJlc2l6YWJsZVBhbmVzICYmICFuZWFyQ29sbGFwc2VkUGFuZTtcbiAgICB9XG4gICAgaXNTdGF0aWMoc3BsaXRCYXJJbmRleCkge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5wYW5lKHNwbGl0QmFySW5kZXgpO1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5wYW5lKHNwbGl0QmFySW5kZXggKyAxKTtcbiAgICAgICAgY29uc3QgYmV0d2VlblJlc2l6YWJsZVBhbmVzID0gcHJldi5yZXNpemFibGUgJiYgbmV4dC5yZXNpemFibGU7XG4gICAgICAgIGNvbnN0IG5lYXJDb2xsYXBzaWJsZVBhbmUgPSBwcmV2LmNvbGxhcHNpYmxlIHx8IG5leHQuY29sbGFwc2libGU7XG4gICAgICAgIHJldHVybiAhYmV0d2VlblJlc2l6YWJsZVBhbmVzICYmICFuZWFyQ29sbGFwc2libGVQYW5lO1xuICAgIH1cbiAgICBwYW5lKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5wYW5lcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFuZXMgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5wYW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYW5lc1tpbmRleF07XG4gICAgfVxuICAgIGNvbmZpZ3VyZSh7IHBhbmVzLCBvcmllbnRhdGlvbiwgY29udGFpbmVyU2l6ZSB9KSB7XG4gICAgICAgIHRoaXMucGFuZXMgPSBwYW5lcztcbiAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKChwYW5lLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcGFuZS5vcmRlciA9IGluZGV4ICogMjtcbiAgICAgICAgICAgIHBhbmUub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgY29uc3QgYWxsUGFuZXNXaXRoU2l6ZSA9IHBhbmVzLmxlbmd0aCAmJiAhcGFuZXMuc29tZShwYW5lID0+ICFwYW5lLmZpeGVkU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBoYXNSZXNpemVkUGFuZSA9IHBhbmVzLmxlbmd0aCAmJiBwYW5lcy5zb21lKHBhbmUgPT4gcGFuZS5pc1Jlc2l6ZWQpO1xuICAgICAgICAgICAgaWYgKGFsbFBhbmVzV2l0aFNpemUgJiYgIWhhc1Jlc2l6ZWRQYW5lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgICAgICAgICAgICAgICAgVGhlIFNwbGl0dGVyIHNob3VsZCBoYXZlIGF0IGxlYXN0IG9uZSBwYW5lIHdpdGhvdXQgYSBzZXQgc2l6ZS5cbiAgICAgICAgICAgICAgICAgICAgU2VlICR7U0laSU5HX0RPQ19MSU5LfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRhaW5lclNpemUgPSBjb250YWluZXJTaXplO1xuICAgIH1cbiAgICBpc1BlcmNlbnQoc2l6ZSkge1xuICAgICAgICByZXR1cm4gLyUkLy50ZXN0KHNpemUpO1xuICAgIH1cbiAgICB0b1BpeGVscyhzaXplKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZsb2F0KHNpemUpO1xuICAgICAgICBpZiAodGhpcy5pc1BlcmNlbnQoc2l6ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICh0aGlzLmNvbnRhaW5lclNpemUoKSAqIHJlc3VsdCAvIDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZW1pdChlbWl0dGVyLCBhcmdzKSB7XG4gICAgICAgIGlmIChlbWl0dGVyLm9ic2VydmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gZW1pdHRlci5lbWl0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5TcGxpdHRlclNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOZ1pvbmVdKVxuXSwgU3BsaXR0ZXJTZXJ2aWNlKTtcblxuY29uc3Qgc3RvcFByb3BhZ2F0aW9uID0gKHsgb3JpZ2luYWxFdmVudDogZXZlbnQgfSkgPT4ge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59O1xuY29uc3QgcHJldmVudE9uRGJsQ2xpY2sgPSByZWxlYXNlID0+IG1vdXNlRG93biA9PiBvZihtb3VzZURvd24pLnBpcGUoZGVsYXkoMTUwKSwgdGFrZVVudGlsKHJlbGVhc2UpKTtcbmNvbnN0IGNsYXNzRnJvbU9iamVjdCA9IGNsYXNzZXMgPT4gT2JqZWN0LmtleXMoY2xhc3NlcykuZmlsdGVyKGMgPT4gY2xhc3Nlc1tjXSkuam9pbignICcpO1xuY29uc3QgY3JlYXRlTW92ZVN0cmVhbSA9IChkcmFnZ2FibGUpID0+IG1vdXNlRG93biA9PiBkcmFnZ2FibGUua2VuZG9EcmFnXG4gICAgLnBpcGUodGFrZVVudGlsKGRyYWdnYWJsZS5rZW5kb1JlbGVhc2UpLCBtYXAoKHsgcGFnZVgsIHBhZ2VZIH0pID0+ICh7XG4gICAgb3JpZ2luYWxYOiBtb3VzZURvd24ucGFnZVgsXG4gICAgb3JpZ2luYWxZOiBtb3VzZURvd24ucGFnZVksXG4gICAgcGFnZVgsXG4gICAgcGFnZVlcbn0pKSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFNwbGl0dGVyQmFyQ29tcG9uZW50ID0gY2xhc3MgU3BsaXR0ZXJCYXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSwgZWxlbWVudCwgc3BsaXR0ZXIsIGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zcGxpdHRlciA9IHNwbGl0dGVyO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYXJpYVJvbGUgPSAnc2VwYXJhdG9yJztcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuICAgIGdldCB0YWJJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXR0ZXIuaXNTdGF0aWModGhpcy5pbmRleCkgPyAtMSA6IDA7XG4gICAgfVxuICAgIGdldCBob3N0Q2xhc3NlcygpIHtcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgICBjb25zdCBpc0RyYWdnYWJsZSA9IHRoaXMuc3BsaXR0ZXIuaXNEcmFnZ2FibGUodGhpcy5pbmRleCk7XG4gICAgICAgIGNvbnN0IGlzU3RhdGljID0gdGhpcy5zcGxpdHRlci5pc1N0YXRpYyh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIGNsYXNzRnJvbU9iamVjdCh7XG4gICAgICAgICAgICAnay1zdGF0ZS1mb2N1c2VkJzogdGhpcy5mb2N1c2VkLFxuICAgICAgICAgICAgJ2stc3BsaXRiYXInOiB0cnVlLFxuICAgICAgICAgICAgJ2stc3BsaXRiYXItaG9yaXpvbnRhbCc6IGlzSG9yaXpvbnRhbCxcbiAgICAgICAgICAgICdrLXNwbGl0YmFyLXZlcnRpY2FsJzogIWlzSG9yaXpvbnRhbCxcbiAgICAgICAgICAgICdrLXNwbGl0YmFyLWRyYWdnYWJsZS1ob3Jpem9udGFsJzogaXNIb3Jpem9udGFsICYmIGlzRHJhZ2dhYmxlLFxuICAgICAgICAgICAgJ2stc3BsaXRiYXItZHJhZ2dhYmxlLXZlcnRpY2FsJzogIWlzSG9yaXpvbnRhbCAmJiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgICdrLXNwbGl0YmFyLXN0YXRpYy1ob3Jpem9udGFsJzogaXNIb3Jpem9udGFsICYmIGlzU3RhdGljLFxuICAgICAgICAgICAgJ2stc3BsaXRiYXItc3RhdGljLXZlcnRpY2FsJzogIWlzSG9yaXpvbnRhbCAmJiBpc1N0YXRpYyxcbiAgICAgICAgICAgICdrLXRvdWNoLWFjdGlvbi1ub25lJzogaXNEcmFnZ2FibGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBvcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIDIgKiB0aGlzLmluZGV4ICsgMTtcbiAgICB9XG4gICAgY29sbGFwc2VBbnkoKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZExhc3QpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cnlUb2dnbGVOZWFyZXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Gb2N1c0luKCkge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgIH1cbiAgICBvbkZvY3VzT3V0KCkge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldmVudCAmJiBldmVudC5rZXlDb2RlO1xuICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9IGRlbHRhID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSQkMSA9IHRoaXMuc3BsaXR0ZXIuZHJhZ1N0YXRlKHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zcGxpdHRlci5zZXRTaXplKHN0YXRlJCQxLCBkZWx0YSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLkVudGVyKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZUFueSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSG9yaXpvbnRhbCAmJiBrZXlDb2RlID09PSBLZXlzLkFycm93TGVmdCkge1xuICAgICAgICAgICAgcmVzaXplKC0xMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNIb3Jpem9udGFsICYmIGtleUNvZGUgPT09IEtleXMuQXJyb3dSaWdodCkge1xuICAgICAgICAgICAgcmVzaXplKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNIb3Jpem9udGFsICYmIGtleUNvZGUgPT09IEtleXMuQXJyb3dVcCkge1xuICAgICAgICAgICAgcmVzaXplKC0xMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzSG9yaXpvbnRhbCAmJiBrZXlDb2RlID09PSBLZXlzLkFycm93RG93bikge1xuICAgICAgICAgICAgcmVzaXplKDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZXhwYW5kTGFzdCgpIHtcbiAgICAgICAgY29uc3QgcGFuZXMgPSB0aGlzLnNwbGl0dGVyLnBhbmVzO1xuICAgICAgICByZXR1cm4gcGFuZXMubGVuZ3RoID09PSAyICYmIHBhbmVzWzFdLmNvbGxhcHNlZDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGxldCBzdGF0ZSQkMTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSB0aGlzLmRyYWdnYWJsZS5rZW5kb1ByZXNzLnBpcGUodGFwKHN0b3BQcm9wYWdhdGlvbiksIGZpbHRlcigoKSA9PiB0aGlzLnNwbGl0dGVyLmlzRHJhZ2dhYmxlKHRoaXMuaW5kZXgpKSwgdGFwKCgpID0+IHN0YXRlJCQxID0gdGhpcy5zcGxpdHRlci5kcmFnU3RhdGUodGhpcy5pbmRleCkpLCB0YXAoKCkgPT4gdGhpcy5zcGxpdHRlci50b2dnbGVDb250ZW50T3ZlcmxheSh0aGlzLmluZGV4LCB0cnVlKSksIHN3aXRjaE1hcChwcmV2ZW50T25EYmxDbGljayh0aGlzLmRyYWdnYWJsZS5rZW5kb1JlbGVhc2UpKSwgc3dpdGNoTWFwKGNyZWF0ZU1vdmVTdHJlYW0odGhpcy5kcmFnZ2FibGUpKSkuc3Vic2NyaWJlKCh7IHBhZ2VYLCBwYWdlWSwgb3JpZ2luYWxYLCBvcmlnaW5hbFkgfSkgPT4ge1xuICAgICAgICAgICAgbGV0IGRlbHRhO1xuICAgICAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSA9IHBhZ2VZIC0gb3JpZ2luYWxZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgPSBvcmlnaW5hbFggLSBwYWdlWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gcGFnZVggLSBvcmlnaW5hbFg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNwbGl0dGVyLnNldFNpemUoc3RhdGUkJDEsIGRlbHRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQobGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuZHJhZ2dhYmxlLmtlbmRvUmVsZWFzZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zcGxpdHRlci50b2dnbGVDb250ZW50T3ZlcmxheSh0aGlzLmluZGV4LCBmYWxzZSkpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvZ2dsZVByZXZpb3VzKCkge1xuICAgICAgICB0aGlzLnNwbGl0dGVyLnRyeVRvZ2dsZSh0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgdG9nZ2xlTmV4dCgpIHtcbiAgICAgICAgdGhpcy5zcGxpdHRlci50cnlUb2dnbGUodGhpcy5pbmRleCArIDEpO1xuICAgIH1cbiAgICBwcmV2aW91c0Fycm93Q2xhc3MoKSB7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLnNwbGl0dGVyLnBhbmUodGhpcy5pbmRleCk7XG4gICAgICAgIGNvbnN0IG5leHRQYW5lID0gdGhpcy5zcGxpdHRlci5wYW5lKHRoaXMuaW5kZXggKyAxKTtcbiAgICAgICAgY29uc3QgaXNDb2xsYXBzaWJsZSA9IHBhbmUuY29sbGFwc2libGU7XG4gICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gcGFuZS5jb2xsYXBzZWQ7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgcmV0dXJuIGNsYXNzRnJvbU9iamVjdCh7XG4gICAgICAgICAgICAnay1pY29uJzogdHJ1ZSxcbiAgICAgICAgICAgICdrLWhpZGRlbic6ICFpc0NvbGxhcHNpYmxlIHx8IG5leHRQYW5lLmlzSGlkZGVuLFxuICAgICAgICAgICAgJ2stY29sbGFwc2UtcHJldic6IGlzQ29sbGFwc2libGUsXG4gICAgICAgICAgICAnay1pLWFycm93LTYwLWxlZnQnOiBpc0NvbGxhcHNpYmxlICYmIGlzSG9yaXpvbnRhbCAmJiAhaXNDb2xsYXBzZWQsXG4gICAgICAgICAgICAnay1pLWFycm93LTYwLXJpZ2h0JzogaXNDb2xsYXBzaWJsZSAmJiBpc0hvcml6b250YWwgJiYgaXNDb2xsYXBzZWQsXG4gICAgICAgICAgICAnay1pLWFycm93LTYwLXVwJzogaXNDb2xsYXBzaWJsZSAmJiAhaXNIb3Jpem9udGFsICYmICFpc0NvbGxhcHNlZCxcbiAgICAgICAgICAgICdrLWktYXJyb3ctNjAtZG93bic6IGlzQ29sbGFwc2libGUgJiYgIWlzSG9yaXpvbnRhbCAmJiBpc0NvbGxhcHNlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmV4dEFycm93Q2xhc3MoKSB7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLnNwbGl0dGVyLnBhbmUodGhpcy5pbmRleCArIDEpO1xuICAgICAgICBjb25zdCBwcmV2UGFuZSA9IHRoaXMuc3BsaXR0ZXIucGFuZSh0aGlzLmluZGV4KTtcbiAgICAgICAgY29uc3QgaXNDb2xsYXBzaWJsZSA9IHBhbmUuY29sbGFwc2libGU7XG4gICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gcGFuZS5jb2xsYXBzZWQ7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgcmV0dXJuIGNsYXNzRnJvbU9iamVjdCh7XG4gICAgICAgICAgICAnay1pY29uJzogdHJ1ZSxcbiAgICAgICAgICAgICdrLWhpZGRlbic6ICFpc0NvbGxhcHNpYmxlIHx8IHByZXZQYW5lLmlzSGlkZGVuLFxuICAgICAgICAgICAgJ2stY29sbGFwc2UtbmV4dCc6IGlzQ29sbGFwc2libGUsXG4gICAgICAgICAgICAnay1pLWFycm93LTYwLXJpZ2h0JzogaXNDb2xsYXBzaWJsZSAmJiBpc0hvcml6b250YWwgJiYgIWlzQ29sbGFwc2VkLFxuICAgICAgICAgICAgJ2staS1hcnJvdy02MC1sZWZ0JzogaXNDb2xsYXBzaWJsZSAmJiBpc0hvcml6b250YWwgJiYgaXNDb2xsYXBzZWQsXG4gICAgICAgICAgICAnay1pLWFycm93LTYwLWRvd24nOiBpc0NvbGxhcHNpYmxlICYmICFpc0hvcml6b250YWwgJiYgIWlzQ29sbGFwc2VkLFxuICAgICAgICAgICAgJ2staS1hcnJvdy02MC11cCc6IGlzQ29sbGFwc2libGUgJiYgIWlzSG9yaXpvbnRhbCAmJiBpc0NvbGxhcHNlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJ5VG9nZ2xlTmVhcmVzdCgpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgaWYgKCF0aGlzLnNwbGl0dGVyLnRyeVRvZ2dsZShwcmV2KSkge1xuICAgICAgICAgICAgdGhpcy5zcGxpdHRlci50cnlUb2dnbGUobmV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLW9yaWVudGF0aW9uJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNwbGl0dGVyQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcmllbnRhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU3BsaXR0ZXJCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5yb2xlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNwbGl0dGVyQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhUm9sZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc3RhdGUtZm9jdXNlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU3BsaXR0ZXJCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvY3VzZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgU3BsaXR0ZXJCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgU3BsaXR0ZXJCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLi1tcy1mbGV4LW9yZGVyJyksXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLm9yZGVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgU3BsaXR0ZXJCYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9yZGVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdkYmxjbGljaycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgU3BsaXR0ZXJCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbGxhcHNlQW55XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdmb2N1c2luJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBTcGxpdHRlckJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Gb2N1c0luXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdmb2N1c291dCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgU3BsaXR0ZXJCYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRm9jdXNPdXRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIFNwbGl0dGVyQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbktleURvd25cIiwgbnVsbCk7XG5TcGxpdHRlckJhckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tc3BsaXR0ZXItYmFyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgIDxkaXYgW2NsYXNzXT1cInByZXZpb3VzQXJyb3dDbGFzcygpXCIgKGNsaWNrKT1cInRvZ2dsZVByZXZpb3VzKClcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJrLXJlc2l6ZS1oYW5kbGVcIj48L2Rpdj5cbiAgICAgIDxkaXYgW2NsYXNzXT1cIm5leHRBcnJvd0NsYXNzKClcIiAoY2xpY2spPVwidG9nZ2xlTmV4dCgpXCI+PC9kaXY+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgSG9zdCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RyYWdnYWJsZURpcmVjdGl2ZSxcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgU3BsaXR0ZXJTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFNwbGl0dGVyQmFyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgU3BsaXR0ZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3NwbGl0dGVyICV9KS5cbiAqXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tc3BsaXR0ZXIgc3R5bGU9XCJoZWlnaHQ6IDI4MHB4O1wiPlxuICpcbiAqICAgICAgICAgIDxrZW5kby1zcGxpdHRlci1wYW5lIFtjb2xsYXBzaWJsZV09XCJ0cnVlXCIgc2l6ZT1cIjMwJVwiPlxuICogICAgICAgICAgICA8aDM+SW5uZXIgc3BsaXR0ZXIgLyBsZWZ0IHBhbmU8L2gzPlxuICogICAgICAgICAgICA8cD5SZXNpemFibGUgYW5kIGNvbGxhcHNpYmxlLjwvcD5cbiAqICAgICAgICAgIDwva2VuZG8tc3BsaXR0ZXItcGFuZT5cbiAqXG4gKiAgICAgICAgICA8a2VuZG8tc3BsaXR0ZXItcGFuZT5cbiAqICAgICAgICAgICAgPGgzPklubmVyIHNwbGl0dGVyIC8gY2VudGVyIHBhbmU8L2gzPlxuICogICAgICAgICAgICA8cD5SZXNpemFibGUgb25seS48L3A+XG4gKiAgICAgICAgICA8L2tlbmRvLXNwbGl0dGVyLXBhbmU+XG4gKlxuICogICAgICAgICAgPGtlbmRvLXNwbGl0dGVyLXBhbmUgW2NvbGxhcHNpYmxlXT1cInRydWVcIiBzaXplPVwiMzAlXCI+XG4gKiAgICAgICAgICAgIDxoMz5Jbm5lciBzcGxpdHRlciAvIHJpZ2h0IHBhbmU8L2gzPlxuICogICAgICAgICAgICA8cD5SZXNpemFibGUgYW5kIGNvbGxhcHNpYmxlLjwvcD5cbiAqICAgICAgICAgIDwva2VuZG8tc3BsaXR0ZXItcGFuZT5cbiAqXG4gKiAgICAgICAgPC9rZW5kby1zcGxpdHRlcj5cbiAqICAgICAgYCxcbiAqICAgIHN0eWxlczogWyBgXG4gKiAgICAgICAgaDMgeyBmb250LXNpemU6IDEuMmVtOyB9XG4gKiAgICAgICAgaDMsIHAgeyBtYXJnaW46IDEwcHg7IHBhZGRpbmc6IDA7IH1cbiAqICAgIGAgXVxuICogIH0pXG4gKiAgY2xhc3MgQXBwQ29tcG9uZW50IHt9XG4gKiBgYGBcbiAqL1xubGV0IFNwbGl0dGVyQ29tcG9uZW50ID0gY2xhc3MgU3BsaXR0ZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHNwbGl0dGVyU2VydmljZSwgbG9jYWxpemF0aW9uLCByZW5kZXJlciwgZW5jbG9zaW5nUGFuZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnNwbGl0dGVyU2VydmljZSA9IHNwbGl0dGVyU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5lbmNsb3NpbmdQYW5lID0gZW5jbG9zaW5nUGFuZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBhbmVzIHdpdGhpbiB0aGUgU3BsaXR0ZXIuXG4gICAgICAgICAqIFBhbmVzIGluIGEgaG9yaXpvbnRhbCBTcGxpdHRlciBhcmUgcGxhY2VkIGhvcml6b250YWxseS5cbiAgICAgICAgICogUGFuZXMgaW4gYSB2ZXJ0aWNhbCBTcGxpdHRlciBhcmUgcGxhY2VkIHZlcnRpY2FsbHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnO1xuICAgICAgICB0aGlzLmFyaWFSb2xlID0gJ3NwbGl0dGVyJztcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgICAgIGlmIChlbmNsb3NpbmdQYW5lKSB7XG4gICAgICAgICAgICBlbmNsb3NpbmdQYW5lLmNvbnRhaW5zU3BsaXR0ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBoYW5kbGVyIG9ubHkgcnVucyBpbiBOZ1pvbmUgaWYgdGhlcmUgYXJlIGJvdW5kIGhhbmRsZXJzXG4gICAgICAgIC8vIHRoaXMgbGluZSBtZXJnZXMgYm90aCBzdHJlYW1zXG4gICAgICAgIHRoaXMubGF5b3V0Q2hhbmdlID0gdGhpcy5zcGxpdHRlclNlcnZpY2UubGF5b3V0Q2hhbmdlO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZSA9IHRoaXMuY29uZmlndXJlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGdldCBob3N0Q2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBob3Jpem9udGFsSG9zdENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIGdldCB2ZXJ0aWNhbEhvc3RDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJztcbiAgICB9XG4gICAgZ2V0IGRpcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uO1xuICAgIH1cbiAgICBzZXQgc3BsaXRiYXJzKHNwbGl0YmFycykge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChzcGxpdGJhcnMpIHx8ICFpc1ByZXNlbnQodGhpcy5wYW5lcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gWy4uLnRoaXMucGFuZXMudG9BcnJheSgpLCAuLi5zcGxpdGJhcnMudG9BcnJheSgpXVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEub3JkZXIgLSBiLm9yZGVyKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBjb21wb25lbnRzLm1hcChjb21wb25lbnQgPT4gY29tcG9uZW50LmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBlbGVtZW50KSk7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZWNvbmZpZ3VyZSgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLm9yaWVudGF0aW9uICYmICFjaGFuZ2VzLm9yaWVudGF0aW9uLmlzRmlyc3RDaGFuZ2UoKSkge1xuICAgICAgICAgICAgdGhpcy5yZWNvbmZpZ3VyZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5lbmNsb3NpbmdQYW5lKSB7XG4gICAgICAgICAgICB0aGlzLmVuY2xvc2luZ1BhbmUuY29udGFpbnNTcGxpdHRlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDaGFuZ2VzKCk7XG4gICAgfVxuICAgIHJlY29uZmlndXJlKCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2hhbmdlcygpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgICAgICB0aGlzLnBhbmVDaGFuZ2VzU3Vic2NyaXB0aW9uID0gdGhpcy5wYW5lcy5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmNvbmZpZ3VyZSk7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZUNoYW5nZXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucGFuZUNoYW5nZXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMucGFuZUNoYW5nZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbmZpZ3VyZSgpIHtcbiAgICAgICAgdGhpcy5zcGxpdHRlclNlcnZpY2UuY29uZmlndXJlKHtcbiAgICAgICAgICAgIHBhbmVzOiB0aGlzLnBhbmVzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiB0aGlzLm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgY29udGFpbmVyU2l6ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNwbGl0dGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcmllbnRhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFNwbGl0dGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYXlvdXRDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXdpZGdldCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXNwbGl0dGVyJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc3BsaXR0ZXItZmxleCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBTcGxpdHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zcGxpdHRlci1ob3Jpem9udGFsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFNwbGl0dGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3Jpem9udGFsSG9zdENsYXNzZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zcGxpdHRlci12ZXJ0aWNhbCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBTcGxpdHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmVydGljYWxIb3N0Q2xhc3Nlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmRpcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFNwbGl0dGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5yb2xlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNwbGl0dGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhUm9sZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkcmVuKFNwbGl0dGVyQmFyQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1F1ZXJ5TGlzdF0pXG5dLCBTcGxpdHRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic3BsaXRiYXJzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKFNwbGl0dGVyUGFuZUNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFNwbGl0dGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYW5lc1wiLCB2b2lkIDApO1xuU3BsaXR0ZXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvU3BsaXR0ZXInLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXNwbGl0dGVyJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBTcGxpdHRlclNlcnZpY2UsXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uc3BsaXRlcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImtlbmRvLXNwbGl0dGVyLXBhbmVcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cIlxuICAgICAgICBsZXQgcGFuZSBvZiBwYW5lcztcbiAgICAgICAgbGV0IGluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCBsYXN0ID0gbGFzdDtcbiAgICAgIFwiPlxuICAgICAgICA8a2VuZG8tc3BsaXR0ZXItYmFyXG4gICAgICAgICAga2VuZG9EcmFnZ2FibGVcbiAgICAgICAgICAqbmdJZj1cIiFsYXN0XCJcbiAgICAgICAgICBbaW5kZXhdPVwiaW5kZXhcIlxuICAgICAgICAgIFtvcmllbnRhdGlvbl09XCJvcmllbnRhdGlvblwiPlxuICAgICAgICA8L2tlbmRvLXNwbGl0dGVyLWJhcj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIEhvc3QoKSksIF9fcGFyYW0oNCwgSW5qZWN0KFNwbGl0dGVyUGFuZUNvbXBvbmVudCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgU3BsaXR0ZXJTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIFNwbGl0dGVyUGFuZUNvbXBvbmVudF0pXG5dLCBTcGxpdHRlckNvbXBvbmVudCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29udGVudCB0ZW1wbGF0ZSBvZiB0aGUgS2VuZG8gVUkgVGFiU3RyaXAuXG4gKiBUbyBkZWZpbmUgdGhlIHRlbXBsYXRlLCBuZXN0IGEgYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9UYWJDb250ZW50YCBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgIDxrZW5kby10YWJzdHJpcCBbbmdTdHlsZV09XCJ7J3dpZHRoJzogJzQwMHB4J31cIiBbYW5pbWF0ZV09XCJ0cnVlXCI+XG4gKiAgICAgICAgICAgPGtlbmRvLXRhYnN0cmlwLXRhYiB0aXRsZT1cIlBhcmlzXCIgW3NlbGVjdGVkXT1cInRydWVcIj5cbiAqICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RhYkNvbnRlbnQ+XG4gKiAgICAgICAgICAgICAgIDxoMz5Db250ZW50IDE8L2gzPlxuICogICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICA8L2tlbmRvLXRhYnN0cmlwLXRhYj5cbiAqXG4gKiAgICAgICAgICAgPGtlbmRvLXRhYnN0cmlwLXRhYiB0aXRsZT1cIlNvZmlhXCI+XG4gKiAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UYWJDb250ZW50PlxuICogICAgICAgICAgICAgICA8aDM+Q29udGVudCAyPC9oMz5cbiAqICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgPC9rZW5kby10YWJzdHJpcC10YWI+XG4gKiAgICAgICAgIDwva2VuZG8tdGFic3RyaXA+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge31cbiAqXG4gKiBgYGBcbiAqL1xubGV0IFRhYkNvbnRlbnREaXJlY3RpdmUgPSBjbGFzcyBUYWJDb250ZW50RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcblRhYkNvbnRlbnREaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RhYkNvbnRlbnRdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgVGFiQ29udGVudERpcmVjdGl2ZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGl0bGUgdGVtcGxhdGUgb2YgdGhlIEtlbmRvIFVJIFRhYlN0cmlwLlxuICogVG8gZGVmaW5lIHRoZSB0ZW1wbGF0ZSwgbmVzdCBhIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvVGFiVGl0bGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuXG4gKlxuICogPiBUaGUgYGtlbmRvVGFiVGl0bGVgIGRpcmVjdGl2ZSBvdmVycmlkZXMgdGhlIFRhYlN0cmlwVGFiIFt0aXRsZV0oeyUgc2x1ZyBhcGlfbGF5b3V0X3RhYnN0cmlwdGFiY29tcG9uZW50ICV9I3RvYy10aXRsZSkgb3B0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICA8a2VuZG8tdGFic3RyaXA+XG4gKiAgICAgICAgICAgPGtlbmRvLXRhYnN0cmlwLXRhYiBbc2VsZWN0ZWRdPVwidHJ1ZVwiPlxuICogICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVGFiVGl0bGU+XG4gKiAgICAgICAgICAgICAgIDxoND5DdXN0b20gVGl0bGU8L2g0PlxuICogICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RhYkNvbnRlbnQ+XG4gKiAgICAgICAgICAgICAgIDxoMz5Db250ZW50IDE8L2gzPlxuICogICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICA8L2tlbmRvLXRhYnN0cmlwLXRhYj5cbiAqXG4gKiAgICAgICAgICAgPGtlbmRvLXRhYnN0cmlwLXRhYiB0aXRsZT1cIlNvZmlhXCI+XG4gKiAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UYWJDb250ZW50PlxuICogICAgICAgICAgICAgICA8aDM+Q29udGVudCAyPC9oMz5cbiAqICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgPC9rZW5kby10YWJzdHJpcC10YWI+XG4gKiAgICAgICAgIDwva2VuZG8tdGFic3RyaXA+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge31cbiAqXG4gKiBgYGBcbiAqL1xubGV0IFRhYlRpdGxlRGlyZWN0aXZlID0gY2xhc3MgVGFiVGl0bGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuVGFiVGl0bGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RhYlRpdGxlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIFRhYlRpdGxlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB0YWIgY29tcG9uZW50IG9mIHRoZSBUYWJTdHJpcC5cbiAqL1xubGV0IFRhYlN0cmlwVGFiQ29tcG9uZW50ID0gY2xhc3MgVGFiU3RyaXBUYWJDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHRhYiBjb21wb25lbnQgb2YgdGhlIFRhYlN0cmlwLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBkaXNhYmxlIGEgdGFiIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdGFic190YWJzdHJpcCAlfSN0b2MtZGlzYWJsZWQtdGFicykpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90YWJDb250ZW50ID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKlxuICAgICAgICAgKiBDdXJyZW50bHkgb25seSBkaXNhYmxlZCB0YWJzIGNhbiBiZSBmb2N1c2VkLiBPdGhlcndpc2UgdGhleSB3aWxsIGJlXG4gICAgICAgICAqIGltbWVkaWF0ZWx5IHNlbGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHRhYkNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWJDb250ZW50LmZpcnN0O1xuICAgIH1cbiAgICBnZXQgdGFiVGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWJUaXRsZURpcmVjdGl2ZS5maXJzdDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGFiU3RyaXBUYWJDb21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGFiU3RyaXBUYWJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUYWJTdHJpcFRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiY3NzQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRhYlN0cmlwVGFiQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjc3NTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRhYlN0cmlwVGFiQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRhYlN0cmlwVGFiQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbG9zYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGFiU3RyaXBUYWJDb21wb25lbnQucHJvdG90eXBlLCBcImNsb3NlSWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKFRhYkNvbnRlbnREaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBUYWJTdHJpcFRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiX3RhYkNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihUYWJUaXRsZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFRhYlN0cmlwVGFiQ29tcG9uZW50LnByb3RvdHlwZSwgXCJfdGFiVGl0bGVEaXJlY3RpdmVcIiwgdm9pZCAwKTtcblRhYlN0cmlwVGFiQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1RhYlN0cmlwVGFiJyxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10YWJzdHJpcC10YWInLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KVxuXSwgVGFiU3RyaXBUYWJDb21wb25lbnQpO1xuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGB0YWJDbG9zZWAgZXZlbnQgb2YgdGhlIFRhYlN0cmlwLlxuICogVGhlIGB0YWJDbG9zZWAgZXZlbnQgZmlyZXMgd2hlbiB0aGUgY2xvc2UgYnV0dG9uIG9mIHRoZSB0YWIgaXMgY2xpY2tlZC5cbiAqXG4gKi9cbmNsYXNzIFRhYkNsb3NlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgdGhlIGV2ZW50IGFyZ3VtZW50cyBmb3IgdGhlIGB0YWJDbG9zZWAgZXZlbnQuXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBjbG9zZWQgdGFiLlxuICAgICAqIEBwYXJhbSB0YWIgLSBUaGUgY2xvc2VkIHRhYiBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCB0YWIpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnRhYiA9IHRhYjtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHNlbGVjdGAgZXZlbnQgb2YgdGhlIFRhYlN0cmlwLlxuICogVGhlIGBzZWxlY3RgIGV2ZW50IGZpcmVzIHdoZW4gYSB0YWIgaXMgc2VsZWN0ZWQgKGNsaWNrZWQpLlxuICovXG5jbGFzcyBTZWxlY3RFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgdGhlIGV2ZW50IGFyZ3VtZW50cyBmb3IgdGhlIGBzZWxlY3RgIGV2ZW50LlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgdGFiLlxuICAgICAqIEBwYXJhbSB0aXRsZSAtIFRoZSB0aXRsZSBvZiB0aGUgc2VsZWN0ZWQgdGFiLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCB0aXRsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqIENoZWNrcyBpZiB0aGUgY3VycmVudCB0YXJnZXQgaXMgYSBUYWJTdHJpcCB0YWIgZWxlbWVudFxuICovXG5jb25zdCBpc1RhYkVsZW1lbnQgPSAodGFyZ2V0KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0SWQgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgIGlmIChpc1ByZXNlbnQodGFyZ2V0SWQpIHx8IHRhcmdldElkLmluZGV4T2YoJ2stdGFic3RyaXAtdGFiLScpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgdGFiIGlzIGNsb3NhYmxlLiBEZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiB0aGUgVGFiU3RyaXAgY2xvc2FibGUgcHJvcGVydHkuXG4gKi9cbmNvbnN0IGlzVGFiQ2xvc2FibGUgPSAodGFiLCB0YWJTdHJpcENsb3NhYmxlKSA9PiB7XG4gICAgaWYgKHRhYi5jbG9zYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0YWIuY2xvc2FibGU7XG4gICAgfVxuICAgIHJldHVybiB0YWJTdHJpcENsb3NhYmxlO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIENoZWNrcyBpZiB0aGUgVGFiU3RyaXAgc2Nyb2xsIGJ1dHRvbnMgd2lsbCBiZSByZW5kZXJlZC4gRGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgdGhlIFRhYlN0cmlwIHNjcm9sbGFibGUgc2V0dGluZ3MuXG4gKi9cbmNvbnN0IHRhYlN0cmlwSGFzU2Nyb2xsQnV0dG9ucyA9IChzY3JvbGxhYmxlU2V0dGluZ3MpID0+IHtcbiAgICByZXR1cm4gc2Nyb2xsYWJsZVNldHRpbmdzLmVuYWJsZWQgJiYgc2Nyb2xsYWJsZVNldHRpbmdzLnNjcm9sbEJ1dHRvbnMgIT09ICdoaWRkZW4nO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIENoZWNrcyBpZiB0aGUgVGFiU3RyaXAgbW91c2Ugc2Nyb2xsIHdpbGwgYmUgZW5hYmxlZC4gRGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgdGhlIFRhYlN0cmlwIHNjcm9sbGFibGUgc2V0dGluZ3MuXG4gKi9cbmNvbnN0IG1vdXNlU2Nyb2xsRW5hYmxlZCA9IChzY3JvbGxhYmxlU2V0dGluZ3MpID0+IHtcbiAgICByZXR1cm4gc2Nyb2xsYWJsZVNldHRpbmdzLmVuYWJsZWQgJiYgc2Nyb2xsYWJsZVNldHRpbmdzLm1vdXNlU2Nyb2xsO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBhY3RpdmUgdGFiIGVsZW1lbnQgYW5kIGl0cyBpbmRleC5cbiAqIFRoaXMgY291bGQgZWl0aGVyIGJlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFiIG9yIHRoZSBjdXJyZW50bHkgZm9jdXNlZCB0YWIuXG4gKi9cbmNvbnN0IGdldEFjdGl2ZVRhYiA9ICh0YWJzKSA9PiB7XG4gICAgbGV0IGZvY3VzZWRUYWI7XG4gICAgbGV0IHNlbGVjdGVkVGFiO1xuICAgIGxldCBmb2N1c2VkSW5kZXggPSAtMTtcbiAgICBsZXQgc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgIHRhYnMuZm9yRWFjaCgodGFiLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAodGFiLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZFRhYiA9IHRhYjtcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YWIuZm9jdXNlZCkge1xuICAgICAgICAgICAgZm9jdXNlZFRhYiA9IHRhYjtcbiAgICAgICAgICAgIGZvY3VzZWRJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvY3VzZWRJbmRleCA+PSAwID9cbiAgICAgICAgeyB0YWI6IGZvY3VzZWRUYWIsIGluZGV4OiBmb2N1c2VkSW5kZXggfSA6XG4gICAgICAgIHsgdGFiOiBzZWxlY3RlZFRhYiwgaW5kZXg6IHNlbGVjdGVkSW5kZXggfTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2V0VGFiQnlJbmRleCA9ICh0YWJzLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gdGFicy5maWx0ZXIoKF90YWIsIGkpID0+IGkgPT09IGluZGV4KTtcbiAgICBpZiAoZmlsdGVyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gZmlsdGVyZWRbMF07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBnZXRUYWJIZWFkZXJCeUluZGV4ID0gKHRhYkhlYWRlckNvbnRhaW5lcnMsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSB0YWJIZWFkZXJDb250YWluZXJzLmZpbHRlcigoX3RhYkhlYWRlciwgaSkgPT4gaSA9PT0gaW5kZXgpO1xuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZFswXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHJlc2V0VGFiRm9jdXMgPSAodGFicykgPT4ge1xuICAgIHRhYnMuZm9yRWFjaCgodGFiKSA9PiB7XG4gICAgICAgIHRhYi5mb2N1c2VkID0gZmFsc2U7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHJlc2V0VGFiU2VsZWN0aW9uID0gKHRhYnMpID0+IHtcbiAgICB0YWJzLmZvckVhY2goKHRhYikgPT4ge1xuICAgICAgICB0YWIuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9KTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNUYWJsaXN0SG9yaXpvbnRhbCA9ICh0YWJQb3NpdGlvbikgPT4gdGFiUG9zaXRpb24gPT09ICd0b3AnIHx8IHRhYlBvc2l0aW9uID09PSAnYm90dG9tJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBUYWJTdHJpcFNlcnZpY2UgPSBjbGFzcyBUYWJTdHJpcFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgbmdab25lKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICghaXNUYWJFbGVtZW50KGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRIYW5kbGVLZXkoa2V5KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYXZpZ2F0aW9uS2V5KGtleSkgfHwgaXNBcnJvd0tleShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLm9uTmF2aWdhdGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IEtleXMuRGVsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLm9uRGVsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25UYWJTZWxlY3QodGFiLCBpbmRleCkge1xuICAgICAgICBjb25zdCBzZWxlY3RBcmdzID0gbmV3IFNlbGVjdEV2ZW50KGluZGV4LCB0YWIudGl0bGUpO1xuICAgICAgICB0aGlzLm93bmVyLnRhYlNlbGVjdC5lbWl0KHNlbGVjdEFyZ3MpO1xuICAgICAgICBpZiAoIXNlbGVjdEFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIGlmICh0YWIuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzVGFiSGVhZGVyKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdFRhYih0YWIsIGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RUYWIodGFiLCBpbmRleCkge1xuICAgICAgICByZXNldFRhYlNlbGVjdGlvbih0aGlzLm93bmVyLnRhYnMpO1xuICAgICAgICB0aGlzLmZvY3VzVGFiSGVhZGVyKGluZGV4KTtcbiAgICAgICAgdGFiLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMub3duZXIuaXNTY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm93bmVyLnNjcm9sbFRvU2VsZWN0ZWRUYWIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblRhYkNsb3NlKHRhYiwgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgY2xvc2VBcmdzID0gbmV3IFRhYkNsb3NlRXZlbnQoaW5kZXgsIHRhYik7XG4gICAgICAgIHRoaXMub3duZXIudGFiQ2xvc2UuZW1pdChjbG9zZUFyZ3MpO1xuICAgIH1cbiAgICBvbk5hdmlnYXRlKGtleUNvZGUpIHtcbiAgICAgICAgbGV0IHsgdGFiOiBhY3RpdmVUYWIsIGluZGV4OiBhY3RpdmVJbmRleCB9ID0gZ2V0QWN0aXZlVGFiKHRoaXMub3duZXIudGFicyk7XG4gICAgICAgIGlmICghTmdab25lLmlzSW5Bbmd1bGFyWm9uZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vd25lci5zZWxlY3RUYWIodGhpcy5maXJzdE5hdmlnYXRhYmxlSW5kZXgoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFiLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmNvbXB1dGVOZXh0SW5kZXgoYWN0aXZlSW5kZXgsIGtleUNvZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVUYWIobmV4dEluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uRGVsZXRlKCkge1xuICAgICAgICBsZXQgeyB0YWI6IGFjdGl2ZVRhYiwgaW5kZXg6IGFjdGl2ZVRhYkluZGV4IH0gPSBnZXRBY3RpdmVUYWIodGhpcy5vd25lci50YWJzKTtcbiAgICAgICAgaWYgKGlzVGFiQ2xvc2FibGUoYWN0aXZlVGFiLCB0aGlzLm93bmVyLmNsb3NhYmxlKSAmJiAhYWN0aXZlVGFiLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25UYWJDbG9zZShhY3RpdmVUYWIsIGFjdGl2ZVRhYkluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGl2YXRlVGFiKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHRhYiA9IGdldFRhYkJ5SW5kZXgodGhpcy5vd25lci50YWJzLCBpbmRleCk7XG4gICAgICAgIGlmICh0YWIuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUYWJIZWFkZXIoaW5kZXgpO1xuICAgICAgICAgICAgdGFiLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vblRhYlNlbGVjdCh0YWIsIGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb2N1c1RhYkhlYWRlcihpbmRleCkge1xuICAgICAgICBjb25zdCB0YWJIZWFkZXIgPSBnZXRUYWJIZWFkZXJCeUluZGV4KHRoaXMub3duZXIudGFiSGVhZGVyQ29udGFpbmVycywgaW5kZXgpO1xuICAgICAgICB0YWJIZWFkZXIubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICBzaG91bGRIYW5kbGVLZXkoa2V5Q29kZSkge1xuICAgICAgICBpZiAoaXNOYXZpZ2F0aW9uS2V5KGtleUNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUYWJsaXN0SG9yaXpvbnRhbCh0aGlzLm93bmVyLnRhYlBvc2l0aW9uKSAmJiBpc0hvcml6b250YWxBcnJvd0tleShrZXlDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1RhYmxpc3RIb3Jpem9udGFsKHRoaXMub3duZXIudGFiUG9zaXRpb24pICYmIGlzVmVydGljYWxBcnJvd0tleShrZXlDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbXB1dGVOZXh0SW5kZXgoYWN0aXZlSW5kZXgsIGtleUNvZGUpIHtcbiAgICAgICAgc3dpdGNoIChrZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaW52ZXJ0S2V5cyhLZXlzLkFycm93TGVmdCwgS2V5cy5BcnJvd1JpZ2h0KTpcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pbnZlcnRLZXlzKEtleXMuQXJyb3dVcCwgS2V5cy5BcnJvd0Rvd24pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZOYXZpZ2F0YWJsZUluZGV4KGFjdGl2ZUluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pbnZlcnRLZXlzKEtleXMuQXJyb3dSaWdodCwgS2V5cy5BcnJvd0xlZnQpOlxuICAgICAgICAgICAgY2FzZSB0aGlzLmludmVydEtleXMoS2V5cy5BcnJvd0Rvd24sIEtleXMuQXJyb3dVcCk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dE5hdmlnYXRhYmxlSW5kZXgoYWN0aXZlSW5kZXgpO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkhvbWU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3ROYXZpZ2F0YWJsZUluZGV4KCk7XG4gICAgICAgICAgICBjYXNlIEtleXMuRW5kOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3ROYXZpZ2F0YWJsZUluZGV4KCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZlcnRLZXlzKG9yaWdpbmFsLCBpbnZlcnRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gaW52ZXJ0ZWQgOiBvcmlnaW5hbDtcbiAgICB9XG4gICAgZmlyc3ROYXZpZ2F0YWJsZUluZGV4KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgbGFzdE5hdmlnYXRhYmxlSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm93bmVyLnRhYnMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgcHJldk5hdmlnYXRhYmxlSW5kZXgoc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAtIDEgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0TmF2aWdhdGFibGVJbmRleCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RlZEluZGV4IC0gMTtcbiAgICB9XG4gICAgbmV4dE5hdmlnYXRhYmxlSW5kZXgoc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCArIDEgPj0gdGhpcy5vd25lci50YWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3ROYXZpZ2F0YWJsZUluZGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkSW5kZXggKyAxO1xuICAgIH1cbn07XG5UYWJTdHJpcFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmVdKVxuXSwgVGFiU3RyaXBTZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE1PVVNFX1NDUk9MTF9TUEVFRCA9IDEwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEJVVFRPTl9TQ1JPTExfU1BFRUQgPSAxMDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgSElEREVOX0NMQVNTID0gJ2staGlkZGVuJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBESVJFQ1RJT05fQ0xBU1NFUyA9IHtcbiAgICBsZWZ0OiAnay1pLWFycm93LTYwLWxlZnQnLFxuICAgIHJpZ2h0OiAnay1pLWFycm93LTYwLXJpZ2h0JyxcbiAgICB1cDogJ2staS1hcnJvdy02MC11cCcsXG4gICAgZG93bjogJ2staS1hcnJvdy02MC1kb3duJ1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBERUZBVUxUX1NDUk9MTF9CRUhBVklPUiA9ICdzbW9vdGgnO1xuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGB0YWJTY3JvbGxgIGV2ZW50IG9mIHRoZSBUYWJTdHJpcC5cbiAqIFRoZSBgdGFiU2Nyb2xsYCBldmVudCBmaXJlcyB3aGVuIHRoZSB0YWJzIGFyZSBiZWluZyBzY3JvbGxlZC5cbiAqXG4gKi9cbmNsYXNzIFRhYlNjcm9sbEV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCQxIHtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTY3JvbGxTZXJ2aWNlID0gY2xhc3MgU2Nyb2xsU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Iobmdab25lKSB7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxCdXR0b25BY3RpdmVTdGF0ZUNoYW5nZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIGdldCB0YWJsaXN0RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3duZXIudGFibGlzdC5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsQnV0dG9uSWNvbkNsYXNzKCkge1xuICAgICAgICBjb25zdCB0YWJTdHJpcCA9IHRoaXMub3duZXI7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcmV2SWNvbiA9IGlzVGFibGlzdEhvcml6b250YWwodGFiU3RyaXAudGFiUG9zaXRpb24pID8gRElSRUNUSU9OX0NMQVNTRVMubGVmdCA6IERJUkVDVElPTl9DTEFTU0VTLnVwO1xuICAgICAgICBjb25zdCBkZWZhdWx0TmV4dEljb24gPSBpc1RhYmxpc3RIb3Jpem9udGFsKHRhYlN0cmlwLnRhYlBvc2l0aW9uKSA/IERJUkVDVElPTl9DTEFTU0VTLnJpZ2h0IDogRElSRUNUSU9OX0NMQVNTRVMuZG93bjtcbiAgICAgICAgaWYgKHR5cGVvZiB0YWJTdHJpcC5zY3JvbGxhYmxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgcHJldkljb24gPSB0eXBlb2YgdGFiU3RyaXAuc2Nyb2xsYWJsZS5wcmV2QnV0dG9uSWNvbiA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0UHJldkljb24gOiB0YWJTdHJpcC5zY3JvbGxhYmxlLnByZXZCdXR0b25JY29uO1xuICAgICAgICAgICAgY29uc3QgbmV4dEljb24gPSB0eXBlb2YgdGFiU3RyaXAuc2Nyb2xsYWJsZS5uZXh0QnV0dG9uSWNvbiA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0TmV4dEljb24gOiB0YWJTdHJpcC5zY3JvbGxhYmxlLm5leHRCdXR0b25JY29uO1xuICAgICAgICAgICAgcmV0dXJuIHsgcHJldlNjcm9sbEJ1dHRvbjogcHJldkljb24sIG5leHRTY3JvbGxCdXR0b246IG5leHRJY29uIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcHJldlNjcm9sbEJ1dHRvbjogZGVmYXVsdFByZXZJY29uLCBuZXh0U2Nyb2xsQnV0dG9uOiBkZWZhdWx0TmV4dEljb24gfTtcbiAgICB9XG4gICAgZ2V0IHRhYnN0cmlwU2l6ZSgpIHtcbiAgICAgICAgY29uc3QgaG9zdEVsZW1lbnQgPSB0aGlzLm93bmVyLndyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3Qgd3JhcHBlcldpZHRoID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKGhvc3RFbGVtZW50KS53aWR0aCk7XG4gICAgICAgIGNvbnN0IHdyYXBwZXJIZWlnaHQgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoaG9zdEVsZW1lbnQpLmhlaWdodCk7XG4gICAgICAgIHJldHVybiBpc1RhYmxpc3RIb3Jpem9udGFsKHRoaXMub3duZXIudGFiUG9zaXRpb24pID8gd3JhcHBlcldpZHRoIDogd3JhcHBlckhlaWdodDtcbiAgICB9XG4gICAgZ2V0IHRhYmxpc3RPdmVyZmxvd1NpemUoKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBpc1RhYmxpc3RIb3Jpem9udGFsKHRoaXMub3duZXIudGFiUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBvdmVyZmxvd1NpemUgPSBNYXRoLmZsb29yKHRoaXMudGFibGlzdEVsZW1lbnRbaXNIb3Jpem9udGFsID8gJ3Njcm9sbFdpZHRoJyA6ICdzY3JvbGxIZWlnaHQnXVxuICAgICAgICAgICAgLSB0aGlzLnRhYmxpc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2lzSG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J10pO1xuICAgICAgICByZXR1cm4gb3ZlcmZsb3dTaXplIDwgMCA/IDAgOiBvdmVyZmxvd1NpemU7XG4gICAgfVxuICAgIGdldCB0YWJzT3ZlcmZsb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYmxpc3RPdmVyZmxvd1NpemUgPiAwO1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsQnV0dG9uc1NpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5vd25lci5oYXNTY3JvbGxCdXR0b25zKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2UmVjdCA9IHRoaXMub3duZXIucHJldlNjcm9sbEJ1dHRvbi5ob3N0Qm91bmRpbmdDbGllbnRSZWN0O1xuICAgICAgICBjb25zdCBwcmV2U2l6ZSA9IGlzVGFibGlzdEhvcml6b250YWwodGhpcy5vd25lci50YWJQb3NpdGlvbikgPyBwcmV2UmVjdC53aWR0aCA6IHByZXZSZWN0LmhlaWdodDtcbiAgICAgICAgY29uc3QgbmV4dFJlY3QgPSB0aGlzLm93bmVyLm5leHRTY3JvbGxCdXR0b24uaG9zdEJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgICAgICAgY29uc3QgbmV4dFNpemUgPSBpc1RhYmxpc3RIb3Jpem9udGFsKHRoaXMub3duZXIudGFiUG9zaXRpb24pID8gbmV4dFJlY3Qud2lkdGggOiBuZXh0UmVjdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBwcmV2U2l6ZSArIG5leHRTaXplO1xuICAgIH1cbiAgICB0b2dnbGVTY3JvbGxCdXR0b25zU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHRhYlN0cmlwID0gdGhpcy5vd25lcjtcbiAgICAgICAgaWYgKCF0YWJTdHJpcC5oYXNTY3JvbGxCdXR0b25zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFByZXZCdXR0b25BY3RpdmUgPSAhdGFiU3RyaXAucHJldlNjcm9sbEJ1dHRvbi5kaXNhYmxlZDtcbiAgICAgICAgY29uc3QgY3VycmVudE5leHRCdXR0b25BY3RpdmUgPSAhdGFiU3RyaXAubmV4dFNjcm9sbEJ1dHRvbi5kaXNhYmxlZDtcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZFByZXZCdXR0b25BY3RpdmUgPSB0aGlzLnBvc2l0aW9uID4gMCAmJiB0aGlzLnRhYmxpc3RPdmVyZmxvd1NpemUgPiAwO1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkTmV4dEJ1dHRvbkFjdGl2ZSA9IHRoaXMucG9zaXRpb24gPCB0aGlzLnRhYmxpc3RPdmVyZmxvd1NpemUgKyB0aGlzLnNjcm9sbEJ1dHRvbnNTaXplICYmIHRoaXMudGFibGlzdE92ZXJmbG93U2l6ZSA+IDA7XG4gICAgICAgIGlmIChjYWxjdWxhdGVkUHJldkJ1dHRvbkFjdGl2ZSAhPT0gY3VycmVudFByZXZCdXR0b25BY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB0aGlzLnRvZ2dsZUJ1dHRvbkFjdGl2ZVN0YXRlKCdwcmV2JywgY2FsY3VsYXRlZFByZXZCdXR0b25BY3RpdmUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsY3VsYXRlZE5leHRCdXR0b25BY3RpdmUgIT09IGN1cnJlbnROZXh0QnV0dG9uQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy50b2dnbGVCdXR0b25BY3RpdmVTdGF0ZSgnbmV4dCcsIGNhbGN1bGF0ZWROZXh0QnV0dG9uQWN0aXZlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nyb2xsVG9TZWxlY3RlZFRhYigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhYnNPdmVyZmxvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGluZGV4OiBhY3RpdmVJbmRleCB9ID0gZ2V0QWN0aXZlVGFiKHRoaXMub3duZXIudGFicyk7XG4gICAgICAgIGlmIChhY3RpdmVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KGFjdGl2ZUluZGV4KTtcbiAgICAgICAgaWYgKGlzVGFibGlzdEhvcml6b250YWwodGhpcy5vd25lci50YWJQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMudGFibGlzdEVsZW1lbnQuc2Nyb2xsTGVmdCA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhYmxpc3RFbGVtZW50LnNjcm9sbFRvcCA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2dnbGVTY3JvbGxCdXR0b25zU3RhdGUoKTtcbiAgICAgICAgY29uc3QgdGFiU3RyaXAgPSB0aGlzLm93bmVyO1xuICAgICAgICBpZiAoIXRhYlN0cmlwLmhhc1Njcm9sbEJ1dHRvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0ZpcnN0VGFiQWN0aXZlID0gYWN0aXZlSW5kZXggPT09IDA7XG4gICAgICAgIGNvbnN0IGlzTGFzdFRhYkFjdGl2ZSA9IGFjdGl2ZUluZGV4ID09PSB0aGlzLm93bmVyLnRhYnMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGlzRmlyc3RUYWJBY3RpdmUgJiYgIXRhYlN0cmlwLnByZXZTY3JvbGxCdXR0b24uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB0aGlzLnRvZ2dsZUJ1dHRvbkFjdGl2ZVN0YXRlKCdwcmV2JywgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYXN0VGFiQWN0aXZlICYmICF0YWJTdHJpcC5uZXh0U2Nyb2xsQnV0dG9uLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy50b2dnbGVCdXR0b25BY3RpdmVTdGF0ZSgnbmV4dCcsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2Nyb2xsT2Zmc2V0KGFjdGl2ZUluZGV4KSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBpc1RhYmxpc3RIb3Jpem9udGFsKHRoaXMub3duZXIudGFiUG9zaXRpb24pO1xuICAgICAgICB0aGlzLnRhYmxpc3RFbGVtZW50W2BzY3JvbGwke2lzSG9yaXpvbnRhbCA/ICdMZWZ0JyA6ICdUb3AnfWBdID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgYWN0aXZlVGFiUmVjdCA9IHRoaXMudGFibGlzdEVsZW1lbnQuY2hpbGRyZW5bYWN0aXZlSW5kZXhdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB0YWJsaXN0UmVjdCA9IHRoaXMudGFibGlzdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGlzSG9yaXpvbnRhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBpc0hvcml6b250YWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgICAgY29uc3QgYWN0aXZlVGFiU3RhcnQgPSBhY3RpdmVUYWJSZWN0W3N0YXJ0XTtcbiAgICAgICAgY29uc3QgYWN0aXZlVGFiRW5kID0gYWN0aXZlVGFiUmVjdFtlbmRdO1xuICAgICAgICBjb25zdCB0YWJsaXN0U3RhcnQgPSB0YWJsaXN0UmVjdFtzdGFydF07XG4gICAgICAgIGNvbnN0IHRhYmxpc3RFbmQgPSB0YWJsaXN0UmVjdFtlbmRdO1xuICAgICAgICBjb25zdCB0YWJFbmRJc0luVmlzaWJsZVJhbmdlID0gYWN0aXZlVGFiRW5kIDw9IHRhYmxpc3RFbmQ7XG4gICAgICAgIGNvbnN0IHRhYlN0YXJ0SXNJblZpc2libGVSYW5nZSA9IGFjdGl2ZVRhYlN0YXJ0ID49IHRhYmxpc3RTdGFydDtcbiAgICAgICAgY29uc3QgaXNXaG9sZVRhYlZpc2libGUgPSB0YWJFbmRJc0luVmlzaWJsZVJhbmdlICYmIHRhYlN0YXJ0SXNJblZpc2libGVSYW5nZTtcbiAgICAgICAgaWYgKGlzV2hvbGVUYWJWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhYkVuZElzSW5WaXNpYmxlUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVUYWJFbmQgLSB0YWJsaXN0RW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFiU3RhcnRJc0luVmlzaWJsZVJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlVGFiU3RhcnQgLSB0YWJsaXN0U3RhcnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Nb3VzZVNjcm9sbChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoIW1vdXNlU2Nyb2xsRW5hYmxlZCh0aGlzLm93bmVyLnNjcm9sbGFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gZXZlbnQuZGVsdGFZIDwgMCA/ICdwcmV2JyA6ICduZXh0JztcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVMaXN0UG9zaXRpb24oZGlyZWN0aW9uLCB0aGlzLm93bmVyLnNjcm9sbGFibGUubW91c2VTY3JvbGxTcGVlZCk7XG4gICAgICAgIGlmIChpc1RhYmxpc3RIb3Jpem9udGFsKHRoaXMub3duZXIudGFiUG9zaXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnRhYmxpc3RFbGVtZW50LnNjcm9sbExlZnQgPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YWJsaXN0RWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9nZ2xlU2Nyb2xsQnV0dG9uc1N0YXRlKCk7XG4gICAgfVxuICAgIHNjcm9sbFRhYnMoZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlTGlzdFBvc2l0aW9uKGRpcmVjdGlvbiwgdGhpcy5vd25lci5zY3JvbGxhYmxlLmJ1dHRvblNjcm9sbFNwZWVkKTtcbiAgICAgICAgaWYgKGlzVGFibGlzdEhvcml6b250YWwodGhpcy5vd25lci50YWJQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMudGFibGlzdEVsZW1lbnQuc2Nyb2xsVG8oeyBsZWZ0OiB0aGlzLnBvc2l0aW9uLCBiZWhhdmlvcjogREVGQVVMVF9TQ1JPTExfQkVIQVZJT1IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhYmxpc3RFbGVtZW50LnNjcm9sbFRvKHsgdG9wOiB0aGlzLnBvc2l0aW9uLCBiZWhhdmlvcjogREVGQVVMVF9TQ1JPTExfQkVIQVZJT1IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2dnbGVTY3JvbGxCdXR0b25zU3RhdGUoKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlTGlzdFBvc2l0aW9uKGRpcmVjdGlvbiwgc2Nyb2xsU3BlZWQpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRNYXhTY3JvbGwgPSB0aGlzLnRhYmxpc3RPdmVyZmxvd1NpemUgKyB0aGlzLnNjcm9sbEJ1dHRvbnNTaXplO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAncHJldicgJiYgdGhpcy5wb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uIC0gc2Nyb2xsU3BlZWQgPD0gMCA/IDAgOiB0aGlzLnBvc2l0aW9uIC0gc2Nyb2xsU3BlZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbmV4dCcgJiYgdGhpcy5wb3NpdGlvbiA8IGFkanVzdGVkTWF4U2Nyb2xsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiArIHNjcm9sbFNwZWVkID4gYWRqdXN0ZWRNYXhTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gYWRqdXN0ZWRNYXhTY3JvbGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBzY3JvbGxTcGVlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0U2Nyb2xsRXZlbnQoZXYpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsRXZlbnQgPSBuZXcgVGFiU2Nyb2xsRXZlbnQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vd25lci50YWJTY3JvbGwpKSB7XG4gICAgICAgICAgICB0aGlzLm93bmVyLnRhYlNjcm9sbC5lbWl0KHNjcm9sbEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Nyb2xsRXZlbnQ7XG4gICAgfVxuICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKGlzVGFibGlzdEhvcml6b250YWwodGhpcy5vd25lci50YWJQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMudGFibGlzdEVsZW1lbnQuc2Nyb2xsVG8oeyBsZWZ0OiB0aGlzLnBvc2l0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YWJsaXN0RWxlbWVudC5zY3JvbGxUbyh7IHRvcDogdGhpcy5wb3NpdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvZ2dsZVNjcm9sbEJ1dHRvbnNTdGF0ZSgpO1xuICAgIH1cbiAgICB0b2dnbGVCdXR0b25BY3RpdmVTdGF0ZShidXR0b25UeXBlLCBhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxCdXR0b25BY3RpdmVTdGF0ZUNoYW5nZS5uZXh0KHsgYnV0dG9uVHlwZSwgYWN0aXZlIH0pO1xuICAgIH1cbn07XG5TY3JvbGxTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmdab25lXSlcbl0sIFNjcm9sbFNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgbm9ybWFsaXplU2V0dGluZ3MgPSAoeyBlbmFibGVkID0gdHJ1ZSwgc2Nyb2xsQnV0dG9ucyA9ICdhdXRvJywgbW91c2VTY3JvbGwgPSB0cnVlLCBidXR0b25TY3JvbGxTcGVlZCA9IEJVVFRPTl9TQ1JPTExfU1BFRUQsIG1vdXNlU2Nyb2xsU3BlZWQgPSBNT1VTRV9TQ1JPTExfU1BFRUQsIHByZXZCdXR0b25JY29uLCBuZXh0QnV0dG9uSWNvbiB9KSA9PiAoe1xuICAgIGVuYWJsZWQsXG4gICAgc2Nyb2xsQnV0dG9ucyxcbiAgICBtb3VzZVNjcm9sbCxcbiAgICBidXR0b25TY3JvbGxTcGVlZCxcbiAgICBtb3VzZVNjcm9sbFNwZWVkLFxuICAgIHByZXZCdXR0b25JY29uLFxuICAgIG5leHRCdXR0b25JY29uXG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub3JtYWxpemVTY3JvbGxhYmxlU2V0dGluZ3MgPSAoc2V0dGluZ3MpID0+IG5vcm1hbGl6ZVNldHRpbmdzKHNldHRpbmdzID09PSBmYWxzZSA/IHsgZW5hYmxlZDogZmFsc2UgfSA6IHNldHRpbmdzKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBUYWJTdHJpcFNjcm9sbGFibGVCdXR0b25Db21wb25lbnQgPSBjbGFzcyBUYWJTdHJpcFNjcm9sbGFibGVCdXR0b25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QsIHNjcm9sbFNlcnZpY2UsIHJlbmRlcmVyLCBuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5zY3JvbGxTZXJ2aWNlID0gc2Nyb2xsU2VydmljZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5idG5DbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcmV2ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3VicyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5jbGlja0hhbmRsZXIgPSAoc2Nyb2xsRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhYlN0cmlwU2Nyb2xsRXZlbnQgPSB0aGlzLnNjcm9sbFNlcnZpY2UuZW1pdFNjcm9sbEV2ZW50KHNjcm9sbEV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGlzVGFiU3RyaXBTY3JvbGxFdmVudFByZXZlbnRlZCA9IHRhYlN0cmlwU2Nyb2xsRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICAgICAgICBpZiAoaXNUYWJTdHJpcFNjcm9sbEV2ZW50UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnV0dG9uVHlwZSA9IHRoaXMucHJldiA/ICdwcmV2JyA6ICduZXh0JztcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZS5zY3JvbGxUYWJzKGJ1dHRvblR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1YnMuYWRkKHRoaXMuc2Nyb2xsU2VydmljZS5zY3JvbGxCdXR0b25BY3RpdmVTdGF0ZUNoYW5nZS5zdWJzY3JpYmUoKGFjdGl2ZUJ1dHRvblNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhcHBseUFjdGl2ZVN0YXRlID0gKHRoaXMucHJldiAmJiBhY3RpdmVCdXR0b25TZXR0aW5ncy5idXR0b25UeXBlID09PSAncHJldicpIHx8XG4gICAgICAgICAgICAgICAgKCF0aGlzLnByZXYgJiYgYWN0aXZlQnV0dG9uU2V0dGluZ3MuYnV0dG9uVHlwZSA9PT0gJ25leHQnKTtcbiAgICAgICAgICAgIGlmIChhcHBseUFjdGl2ZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCA9ICFhY3RpdmVCdXR0b25TZXR0aW5ncy5hY3RpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0IHByZXZDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldjtcbiAgICB9XG4gICAgZ2V0IG5leHRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnByZXY7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cbiAgICBnZXQgaG9zdEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgICBnZXQgaWNvbkNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxTZXJ2aWNlLnNjcm9sbEJ1dHRvbkljb25DbGFzc1t0aGlzLnByZXYgPyAncHJldlNjcm9sbEJ1dHRvbicgOiAnbmV4dFNjcm9sbEJ1dHRvbiddO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnMuYWRkKHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50LCAnY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vicy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICB0b2dnbGUoc2hvdykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyW3Nob3cgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10odGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQsIEhJRERFTl9DTEFTUyk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWJ1dHRvbicpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWJ1dHRvbi1tZCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWljb24tYnV0dG9uJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstcm91bmRlZC1tZCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWJ1dHRvbi1mbGF0JyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstYnV0dG9uLWZsYXQtYmFzZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGFiU3RyaXBTY3JvbGxhYmxlQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJidG5DbGFzc2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay10YWJzdHJpcC1wcmV2JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRhYlN0cmlwU2Nyb2xsYWJsZUJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwicHJldkNsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdGFic3RyaXAtbmV4dCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBUYWJTdHJpcFNjcm9sbGFibGVCdXR0b25Db21wb25lbnQucHJvdG90eXBlLCBcIm5leHRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBUYWJTdHJpcFNjcm9sbGFibGVCdXR0b25Db21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRhYlN0cmlwU2Nyb2xsYWJsZUJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwicHJldlwiLCB2b2lkIDApO1xuVGFiU3RyaXBTY3JvbGxhYmxlQnV0dG9uQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1idXR0b24taWNvblwiIFtuZ0NsYXNzXT1cImljb25DbGFzc1wiPjwvc3Bhbj5cbiAgICBgLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RhYlN0cmlwU2Nyb2xsYWJsZUJ1dHRvbl0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBTY3JvbGxTZXJ2aWNlLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBUYWJTdHJpcFNjcm9sbGFibGVCdXR0b25Db21wb25lbnQpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBUYWJTdHJpcCBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfdGFic3RyaXAgJX0pLlxuICovXG5sZXQgVGFiU3RyaXBDb21wb25lbnQgPSBjbGFzcyBUYWJTdHJpcENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uLCByZW5kZXJlciwgd3JhcHBlciwgdGFic3RyaXBTZXJ2aWNlLCBzY3JvbGxTZXJ2aWNlLCBuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgdGhpcy50YWJzdHJpcFNlcnZpY2UgPSB0YWJzdHJpcFNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZSA9IHNjcm9sbFNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcyB0aGUgdGFiIGFuaW1hdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0YWJzLiBEZWZhdWx0cyB0byBgdG9wYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgJ3RvcCdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFiUG9zaXRpb24gPSAndG9wJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGNvbXBvbmVudCByZW5kZXJzIGFsbCB0YWJzIGFuZCB0aGV5IGFyZSBwZXJzaXN0ZWQgaW4gdGhlIERPTS5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgYGtlZXBUYWJDb250ZW50YCBpcyBgZmFsc2VgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwVGFiQ29udGVudCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBhIGNsb3NlIGJ1dHRvbiB3aWxsIGJlIHJlbmRlcmVkIGluc2lkZSBlYWNoIHRhYi5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgYGNsb3NhYmxlYCBpcyBgZmFsc2VgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zYWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIGRlZmluaW5nIGEgY3VzdG9tIENTUyBjbGFzcywgb3IgbXVsdGlwbGUgY2xhc3NlcyBzZXBhcmF0ZWQgYnkgc3BhY2VzLCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGNsb3NlIGJ1dHRvbiBzcGFuIGVsZW1lbnQuXG4gICAgICAgICAqIEFsbG93cyB0aGUgdXNhZ2Ugb2YgY3VzdG9tIGljb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZUljb24gPSAnay1pY29uIGstaS14JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBzZWxlY3RzIGEgdGFiIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfdGFic3RyaXAgJX0jdG9jLWJhc2ljLXVzYWdlKSkuXG4gICAgICAgICAqIFRoZSBldmVudCBkYXRhIGNvbnRhaW5zIHRoZSBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgdGFiIGFuZCBpdHMgdGl0bGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYlNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBjbG9zZXMgYSB0YWIuXG4gICAgICAgICAqIFRoZSBldmVudCBkYXRhIGNvbnRhaW5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VkIHRhYiBhbmQgaXRzIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJDbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBzY3JvbGxzIHRoZSBUYWJTdHJpcCBsaXN0LlxuICAgICAgICAgKiBUaGUgZXZlbnQgaXMgcHJldmVudGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYlNjcm9sbCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHF1ZXJ5IGxpc3Qgb2YgYWxsIGRlY2xhcmVkIHRhYnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYnMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbGFibGVTZXR0aW5ncyA9IG5vcm1hbGl6ZVNjcm9sbGFibGVTZXR0aW5ncyhmYWxzZSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zQXJlUHJlc2VudCA9IGZhbHNlO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy50YWJzdHJpcFNlcnZpY2Uub3duZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLnNjcm9sbFNlcnZpY2Uub3duZXIgPSB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgdGhlIFRhYlN0cmlwLlxuICAgICAqL1xuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsICdoZWlnaHQnLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHNjcm9sbGluZyBvZiB0aGUgdGFiIGxpc3QuIFdoZW4gc2V0IHRvIGB0cnVlYCBhbmQgdGhlIHRvdGFsIHNpemUgb2YgYWxsIHRhYnNcbiAgICAgKiBpcyBncmVhdGVyIHRoYW4gdGhlIHNpemUgb2YgdGhlIFRhYlN0cmlwIGNvbnRhaW5lciwgc2Nyb2xsIGJ1dHRvbnMgd2lsbCBiZSByZW5kZXJlZCBvbiBlYWNoIGVuZCBvZiB0aGUgdGFiIGxpc3QuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBgc2Nyb2xsYWJsZWAgaXMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgc2V0IHNjcm9sbGFibGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZVNldHRpbmdzID0gbm9ybWFsaXplU2Nyb2xsYWJsZVNldHRpbmdzKHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMudGFibGlzdCkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVTY3JvbGxCdXR0b25zKHRoaXMuc2Nyb2xsU2VydmljZS50YWJzT3ZlcmZsb3cpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hXaGVlbEhhbmRsZXIodGhpcy50YWJsaXN0Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzY3JvbGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsYWJsZVNldHRpbmdzO1xuICAgIH1cbiAgICBnZXQgdGFic0F0VG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJQb3NpdGlvbiA9PT0gJ3RvcCc7XG4gICAgfVxuICAgIGdldCB0YWJzQXRSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiUG9zaXRpb24gPT09ICdyaWdodCc7XG4gICAgfVxuICAgIGdldCB0YWJzQXRCb3R0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYlBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgICB9XG4gICAgZ2V0IHRhYnNBdExlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYlBvc2l0aW9uID09PSAnbGVmdCc7XG4gICAgfVxuICAgIGdldCBkaXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgIH1cbiAgICBnZXQgdGFiU3RyaXBTY3JvbGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsYWJsZVNldHRpbmdzLmVuYWJsZWQ7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsU2VydmljZS50YWJzT3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZVNjcm9sbEJ1dHRvbnModHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZVNjcm9sbEJ1dHRvbnMoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGVkVGFiKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5pdERvbUV2ZW50cygpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlID0gY2hhbmdlcy50YWJQb3NpdGlvbjtcbiAgICAgICAgaWYgKHBvc2l0aW9uQ2hhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJzQXRCb3R0b21DaGFuZ2VkID0gcG9zaXRpb25DaGFuZ2UucHJldmlvdXNWYWx1ZSA9PT0gJ2JvdHRvbScgfHwgcG9zaXRpb25DaGFuZ2UuY3VycmVudFZhbHVlID09PSAnYm90dG9tJztcbiAgICAgICAgICAgIHRoaXMubmdab25lLm9uU3RhYmxlLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGFic0F0Qm90dG9tQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zQXJlUHJlc2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNBcmVQcmVzZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0RG9tRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZS5yZXN0b3JlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRhYnNBbGlnbm1lbnRTdHlsZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogJ2ZsZXgtc3RhcnQnLFxuICAgICAgICAgICAgZW5kOiAnZmxleC1lbmQnLFxuICAgICAgICAgICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGp1c3RpZnk6ICdzcGFjZS1iZXR3ZWVuJ1xuICAgICAgICB9W3RoaXMudGFiQWxpZ25tZW50XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB0YWJMaXN0V2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhYlBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLnRhYlBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgcmV0dXJuICcxMDAlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB0YWJMaXN0SGVpZ2h0KCkge1xuICAgICAgICBpZiAodGhpcy50YWJQb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHRoaXMudGFiUG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiAnMTAwJSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaXNTY3JvbGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsYWJsZVNldHRpbmdzLmVuYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaGFzU2Nyb2xsQnV0dG9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRhYlN0cmlwSGFzU2Nyb2xsQnV0dG9ucyh0aGlzLl9zY3JvbGxhYmxlU2V0dGluZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IG1vdXNlU2Nyb2xsRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIG1vdXNlU2Nyb2xsRW5hYmxlZCh0aGlzLl9zY3JvbGxhYmxlU2V0dGluZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGl0ZW1zV3JhcHBlckNsYXNzKCkge1xuICAgICAgICByZXR1cm4gaXNUYWJsaXN0SG9yaXpvbnRhbCh0aGlzLnRhYlBvc2l0aW9uKSA/ICdrLWhzdGFjaycgOiAnay12c3RhY2snO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gc2VsZWN0IGEgdGFiIHByb2dyYW1tYXRpY2FsbHkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB0YWIgdGhhdCB3aWxsIGJlIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIHNlbGVjdFRhYihpbmRleCkge1xuICAgICAgICBjb25zdCB0YWIgPSBnZXRUYWJCeUluZGV4KHRoaXMudGFicywgaW5kZXgpO1xuICAgICAgICBpZiAoIXRhYiB8fCB0YWIuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhYnN0cmlwU2VydmljZS5zZWxlY3RUYWIodGFiLCBpbmRleCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9TZWxlY3RlZFRhYigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25UYWJDbGljayhvcmlnaW5hbEV2ZW50LCB0YWJJbmRleCkge1xuICAgICAgICBpZiAoaXNGb2N1c2FibGUob3JpZ2luYWxFdmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IG9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCBpc1RhcmdldENsb3NlQnV0dG9uID0gaGFzQ2xhc3ModGFyZ2V0RWxlbWVudCwgJ2stcmVtb3ZlLXRhYicpIHx8IGhhc0NsYXNzKHRhcmdldEVsZW1lbnQucGFyZW50RWxlbWVudCwgJ2stcmVtb3ZlLXRhYicpO1xuICAgICAgICBpZiAoaXNUYXJnZXRDbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhYiA9IGdldFRhYkJ5SW5kZXgodGhpcy50YWJzLCB0YWJJbmRleCk7XG4gICAgICAgIHRoaXMudGFic3RyaXBTZXJ2aWNlLm9uVGFiU2VsZWN0KHRhYiwgdGFiSW5kZXgpO1xuICAgICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0ZWRUYWIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxTZXJ2aWNlLnRhYnNPdmVyZmxvdykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVTY3JvbGxCdXR0b25zKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVTY3JvbGxCdXR0b25zKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFNlcnZpY2UudG9nZ2xlU2Nyb2xsQnV0dG9uc1N0YXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2Nyb2xsVG9TZWxlY3RlZFRhYigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbGFibGVTZXR0aW5ncy5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFNlcnZpY2Uuc2Nyb2xsVG9TZWxlY3RlZFRhYigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXREb21FdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy53cmFwcGVyIHx8IHRoaXMuc3Vic2NyaXB0aW9uc0FyZVByZXNlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJsaXN0ID0gdGhpcy50YWJsaXN0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4odGFibGlzdCwgJ2tleWRvd24nLCAoZXYpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYnN0cmlwU2VydmljZS5vbktleURvd24oZXYpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbih0YWJsaXN0LCAnZm9jdXNvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICByZXNldFRhYkZvY3VzKHRoaXMudGFicyk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTY3JvbGxhYmxlICYmIHRoaXMubW91c2VTY3JvbGxFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFdoZWVsSGFuZGxlcih0YWJsaXN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNBcmVQcmVzZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgdG9nZ2xlU2Nyb2xsQnV0dG9ucyh0YWJzT3ZlcmZsb3cpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUub25TdGFibGUucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQnV0dG9uc1NldHRpbmcgPSB0aGlzLl9zY3JvbGxhYmxlU2V0dGluZ3Muc2Nyb2xsQnV0dG9ucztcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEJ1dHRvbnNBcmVQcmVzZW50ID0gdGhpcy5wcmV2U2Nyb2xsQnV0dG9uICYmIHRoaXMubmV4dFNjcm9sbEJ1dHRvbjtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNob3dCdXR0b25zID0gc2Nyb2xsQnV0dG9uc0FyZVByZXNlbnQgJiYgdGFic092ZXJmbG93O1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkSGlkZUJ1dHRvbnMgPSBzY3JvbGxCdXR0b25zQXJlUHJlc2VudCAmJlxuICAgICAgICAgICAgICAgICF0YWJzT3ZlcmZsb3cgJiZcbiAgICAgICAgICAgICAgICBzY3JvbGxCdXR0b25zU2V0dGluZyAhPT0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgY29uc3QgYWx3YXlzVmlzaWJsZSA9IHNjcm9sbEJ1dHRvbnNTZXR0aW5nID09PSAndmlzaWJsZSc7XG4gICAgICAgICAgICBpZiAoc2hvdWxkSGlkZUJ1dHRvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxCdXR0b24udG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTY3JvbGxCdXR0b24udG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNob3VsZFNob3dCdXR0b25zIHx8IGFsd2F5c1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxCdXR0b24udG9nZ2xlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFNjcm9sbEJ1dHRvbi50b2dnbGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2Nyb2xsQnV0dG9uc0FyZVByZXNlbnQgJiYgYWx3YXlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxTZXJ2aWNlLnRvZ2dsZVNjcm9sbEJ1dHRvbnNTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXR0YWNoV2hlZWxIYW5kbGVyKHRhYmxpc3QpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbih0YWJsaXN0LCAnd2hlZWwnLCAod2hlZWxFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYlN0cmlwU2Nyb2xsRXZlbnQgPSB0aGlzLnNjcm9sbFNlcnZpY2UuZW1pdFNjcm9sbEV2ZW50KHdoZWVsRXZlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVGFiU3RyaXBTY3JvbGxFdmVudFByZXZlbnRlZCA9IHRhYlN0cmlwU2Nyb2xsRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGFiU3RyaXBTY3JvbGxFdmVudFByZXZlbnRlZCB8fCAhdGhpcy5zY3JvbGxTZXJ2aWNlLnRhYnNPdmVyZmxvdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZS5vbk1vdXNlU2Nyb2xsKHdoZWVsRXZlbnQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBUYWJTdHJpcENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRhYlN0cmlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUYWJTdHJpcENvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiQWxpZ25tZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUYWJTdHJpcENvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiUG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUYWJTdHJpcENvbXBvbmVudC5wcm90b3R5cGUsIFwia2VlcFRhYkNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUYWJTdHJpcENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xvc2FibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgVGFiU3RyaXBDb21wb25lbnQucHJvdG90eXBlLCBcInNjcm9sbGFibGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUYWJTdHJpcENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xvc2VJY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVGFiU3RyaXBDb21wb25lbnQucHJvdG90eXBlLCBcInRhYlNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRhYlN0cmlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJDbG9zZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRhYlN0cmlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJTY3JvbGxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXRhYnN0cmlwJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZmxvYXR3cmFwJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUYWJTdHJpcENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXRhYnN0cmlwLXRvcCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBUYWJTdHJpcENvbXBvbmVudC5wcm90b3R5cGUsIFwidGFic0F0VG9wXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdGFic3RyaXAtcmlnaHQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVGFiU3RyaXBDb21wb25lbnQucHJvdG90eXBlLCBcInRhYnNBdFJpZ2h0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdGFic3RyaXAtYm90dG9tJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRhYlN0cmlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJzQXRCb3R0b21cIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay10YWJzdHJpcC1sZWZ0JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRhYlN0cmlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJzQXRMZWZ0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVGFiU3RyaXBDb21wb25lbnQucHJvdG90eXBlLCBcImRpclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXRhYnN0cmlwLXNjcm9sbGFibGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVGFiU3RyaXBDb21wb25lbnQucHJvdG90eXBlLCBcInRhYlN0cmlwU2Nyb2xsYWJsZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihUYWJTdHJpcFRhYkNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFRhYlN0cmlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3RhYmxpc3QnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBUYWJTdHJpcENvbXBvbmVudC5wcm90b3R5cGUsIFwidGFibGlzdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkcmVuKCd0YWJIZWFkZXJDb250YWluZXInLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFRhYlN0cmlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJIZWFkZXJDb250YWluZXJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3ByZXZTY3JvbGxCdXR0b24nLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRhYlN0cmlwU2Nyb2xsYWJsZUJ1dHRvbkNvbXBvbmVudClcbl0sIFRhYlN0cmlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmV2U2Nyb2xsQnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ25leHRTY3JvbGxCdXR0b24nLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRhYlN0cmlwU2Nyb2xsYWJsZUJ1dHRvbkNvbXBvbmVudClcbl0sIFRhYlN0cmlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuZXh0U2Nyb2xsQnV0dG9uXCIsIHZvaWQgMCk7XG5UYWJTdHJpcENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgIHRyaWdnZXIoJ3N0YXRlJywgW1xuICAgICAgICAgICAgICAgIHN0YXRlKCdhY3RpdmUnLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJyogPT4gYWN0aXZlJywgW1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoJzQwMG1zIGVhc2UtaW4nKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKVxuICAgICAgICBdLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIFRhYlN0cmlwU2VydmljZSxcbiAgICAgICAgICAgIFNjcm9sbFNlcnZpY2UsXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8udGFic3RyaXAnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9UYWJTdHJpcCcsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdGFic3RyaXAnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvVGFiU3RyaXBMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICAgICAgaTE4bi1jbG9zZVRpdGxlPVwia2VuZG8udGFic3RyaXAuY2xvc2VUaXRsZXxUaGUgdGl0bGUgZm9yIHRoZSAqKkNsb3NlKiogYnV0dG9uIGluIHRoZSBUYWJTdHJpcCB0YWIuXCJcbiAgICAgICAgICAgIGNsb3NlVGl0bGU9XCJDbG9zZVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiF0YWJzQXRCb3R0b21cIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoZWFkaW5nXCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb250ZW50XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInRhYnNBdEJvdHRvbVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNvbnRlbnRcIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImhlYWRpbmdcIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNoZWFkaW5nPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstdGFic3RyaXAtaXRlbXMtd3JhcHBlclwiIFtuZ0NsYXNzXT1cIml0ZW1zV3JhcHBlckNsYXNzXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJoYXNTY3JvbGxCdXR0b25zXCJcbiAgICAgICAgICAgICAgICAgICAgICNwcmV2U2Nyb2xsQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvVGFiU3RyaXBTY3JvbGxhYmxlQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIFtwcmV2XT1cInRydWVcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPHVsIHJvbGU9XCJ0YWJsaXN0XCIgI3RhYmxpc3RcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLXJlc2V0IGstdGFic3RyaXAtaXRlbXNcIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUuanVzdGlmeUNvbnRlbnRdPVwidGFic0FsaWdubWVudFN0eWxlc1wiXG4gICAgICAgICAgICAgICAgICAgIFtzdHlsZS53aWR0aF09XCJ0YWJMaXN0V2lkdGhcIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0XT1cInRhYkxpc3RIZWlnaHRcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgdGFiIG9mIHRhYnM7IGxldCBpID0gaW5kZXg7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgKm5nSWY9XCIhdGFiLmNsb3NlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgI3RhYkhlYWRlckNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlbmRvVGFiU3RyaXBUYWJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ0YWIuY3NzQ2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cInRhYi5jc3NTdHlsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RhYl09XCJ0YWJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbmRleF09XCJpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGFiU3RyaXBDbG9zYWJsZV09XCJjbG9zYWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RhYlN0cmlwQ2xvc2VJY29uXT1cImNsb3NlSWNvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIm9uVGFiQ2xpY2soJGV2ZW50LCBpKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2lkXT1cIidrLXRhYnN0cmlwLXRhYi0nICsgaVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1jb250cm9sc109XCInay10YWJzdHJpcC10YWJwYW5lbC0nICsgaVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cImhhc1Njcm9sbEJ1dHRvbnNcIiAjbmV4dFNjcm9sbEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBrZW5kb1RhYlN0cmlwU2Nyb2xsYWJsZUJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBbcHJldl09XCJmYWxzZVwiPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgI2NvbnRlbnQ+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LXRhYiBbbmdGb3JPZl09XCJ0YWJzXCIgbGV0LWk9XCJpbmRleFwiPlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgW0BzdGF0ZV09XCJ0YWIuc2VsZWN0ZWQgJiYgYW5pbWF0ZSA/ICdhY3RpdmUnIDogJ2luYWN0aXZlJ1wiXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiIXRhYi5jbG9zZWQgJiYgKHRhYi5zZWxlY3RlZCB8fCBrZWVwVGFiQ29udGVudClcIlxuICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCIhdGhpcy5rZWVwVGFiQ29udGVudCB8fCB0YWIuc2VsZWN0ZWQgPyAnay1jb250ZW50IGstc3RhdGUtYWN0aXZlJyA6ICdrLWNvbnRlbnQnXCJcbiAgICAgICAgICAgICAgICAgICAgW3RhYkluZGV4XT1cIjBcIlxuICAgICAgICAgICAgICAgICAgICByb2xlPVwidGFicGFuZWxcIlxuICAgICAgICAgICAgICAgICAgICBbaWRdPVwiJ2stdGFic3RyaXAtdGFicGFuZWwtJyArIGlcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWhpZGRlbl09XCIhdGFiLnNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJ0YWIuc2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwiJ2stdGFic3RyaXAtdGFiLScgKyBpXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJ0YWIuZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhYi50YWJDb250ZW50Py50ZW1wbGF0ZVJlZlwiPlxuICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgKm5nSWY9XCJpc1Njcm9sbGFibGVcIiAocmVzaXplKT1cIm9uUmVzaXplKClcIj48L2tlbmRvLXJlc2l6ZS1zZW5zb3I+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBUYWJTdHJpcFNlcnZpY2UsXG4gICAgICAgIFNjcm9sbFNlcnZpY2UsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBUYWJTdHJpcENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBUYWJTdHJpcE1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGFiU3RyaXBNZXNzYWdlcy5wcm90b3R5cGUsIFwiY2xvc2VUaXRsZVwiLCB2b2lkIDApO1xuXG52YXIgTG9jYWxpemVkVGFiU3RyaXBNZXNzYWdlc0RpcmVjdGl2ZV8xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBMb2NhbGl6ZWRUYWJTdHJpcE1lc3NhZ2VzRGlyZWN0aXZlID0gTG9jYWxpemVkVGFiU3RyaXBNZXNzYWdlc0RpcmVjdGl2ZV8xID0gY2xhc3MgTG9jYWxpemVkVGFiU3RyaXBNZXNzYWdlc0RpcmVjdGl2ZSBleHRlbmRzIFRhYlN0cmlwTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG59O1xuTG9jYWxpemVkVGFiU3RyaXBNZXNzYWdlc0RpcmVjdGl2ZSA9IExvY2FsaXplZFRhYlN0cmlwTWVzc2FnZXNEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRhYlN0cmlwTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTG9jYWxpemVkVGFiU3RyaXBNZXNzYWdlc0RpcmVjdGl2ZV8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogYFtrZW5kb1RhYlN0cmlwTG9jYWxpemVkTWVzc2FnZXNdYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBMb2NhbGl6ZWRUYWJTdHJpcE1lc3NhZ2VzRGlyZWN0aXZlKTtcblxudmFyIFRhYlN0cmlwQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMTtcbi8qKlxuICogQ3VzdG9tIGNvbXBvbmVudCBtZXNzYWdlcyBvdmVycmlkZSBkZWZhdWx0IGNvbXBvbmVudCBtZXNzYWdlc1xuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBydGxfbGF5b3V0ICV9KSkuXG4gKi9cbmxldCBUYWJTdHJpcEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gVGFiU3RyaXBDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gY2xhc3MgVGFiU3RyaXBDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIFRhYlN0cmlwTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuVGFiU3RyaXBDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IFRhYlN0cmlwQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRhYlN0cmlwTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGFiU3RyaXBDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRhYnN0cmlwLW1lc3NhZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFRhYlN0cmlwQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0ZW1wbGF0ZSB0aGF0IGRlZmluZXMgdGhlIGNvbnRlbnQgb2YgdGhlIERyYXdlci5cbiAqIFRvIGRlZmluZSB0aGUgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZ1xuICogd2l0aCB0aGUgYGtlbmRvRHJhd2VyVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGA8a2VuZG8tZHJhd2VyPmAgdGFnLlxuICogVXNpbmcgdGhpcyB0ZW1wbGF0ZSBkaXJlY3RpdmUgd2lsbCBvdmVycmlkZSBhbGwgb3RoZXIgdGVtcGxhdGVzLFxuICogZm9yIGV4YW1wbGUsIGBrZW5kb0RyYXdlckhlYWRlclRlbXBsYXRlYCBhbmQgYGtlbmRvRHJhd2VySXRlbVRlbXBsYXRlYC5cbiAqL1xubGV0IERyYXdlclRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgRHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuRHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RyYXdlclRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgRHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0ZW1wbGF0ZSB0aGF0IGRlZmluZXMgdGhlIGl0ZW0gY29udGVudCBvZiB0aGUgRHJhd2VyLlxuICogVG8gZGVmaW5lIHRoZSB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG9EcmF3ZXJJdGVtVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGA8a2VuZG8tZHJhd2VyPmAgdGFnLlxuICovXG5sZXQgRHJhd2VySXRlbVRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgRHJhd2VySXRlbVRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkRyYXdlckl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJhd2VySXRlbVRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgRHJhd2VySXRlbVRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdGVtcGxhdGUgdGhhdCBkZWZpbmVzIHRoZSBoZWFkZXIgY29udGVudCBvZiB0aGUgRHJhd2VyLlxuICogVG8gZGVmaW5lIHRoZSB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG9EcmF3ZXJIZWFkZXJUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgYDxrZW5kby1kcmF3ZXI+YCB0YWcuXG4gKi9cbmxldCBEcmF3ZXJIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIERyYXdlckhlYWRlclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkRyYXdlckhlYWRlclRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9EcmF3ZXJIZWFkZXJUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIERyYXdlckhlYWRlclRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdGVtcGxhdGUgdGhhdCBkZWZpbmVzIHRoZSBmb290ZXIgY29udGVudCBvZiB0aGUgRHJhd2VyLlxuICogVG8gZGVmaW5lIHRoZSB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG9EcmF3ZXJGb290ZXJUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgYDxrZW5kby1kcmF3ZXI+YCB0YWcuXG4gKi9cbmxldCBEcmF3ZXJGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIERyYXdlckZvb3RlclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkRyYXdlckZvb3RlclRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9EcmF3ZXJGb290ZXJUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIERyYXdlckZvb3RlclRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG1pbmlFeHBhbmRQdXNoKGR1cmF0aW9uLCB3aWR0aCwgbWluaVdpZHRoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIGZsZXhCYXNpczogYCR7bWluaVdpZHRofXB4YCB9KSxcbiAgICAgICAgYW5pbWF0ZShgJHtkdXJhdGlvbn1tcyBlYXNlLWluYCwgc3R5bGUoeyBmbGV4QmFzaXM6IGAke3dpZHRofXB4YCB9KSlcbiAgICBdO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG1pbmlDb2xsYXBzZVB1c2goZHVyYXRpb24sIHdpZHRoLCBtaW5pV2lkdGgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdHlsZSh7IG92ZXJmbG93OiAnaGlkZGVuJywgZmxleEJhc2lzOiBgJHt3aWR0aH1weGAgfSksXG4gICAgICAgIGFuaW1hdGUoYCR7ZHVyYXRpb259bXMgZWFzZS1pbmAsIHN0eWxlKHsgZmxleEJhc2lzOiBgJHttaW5pV2lkdGh9cHhgIH0pKVxuICAgIF07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKi9cbmZ1bmN0aW9uIG1pbmlFeHBhbmRPdmVybGF5KGR1cmF0aW9uLCB3aWR0aCwgbWluaVdpZHRoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3R5bGUoeyB3aWR0aDogYCR7bWluaVdpZHRofXB4YCB9KSxcbiAgICAgICAgYW5pbWF0ZShgJHtkdXJhdGlvbn1tcyBlYXNlLWluYCwgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIHdpZHRoOiBgJHt3aWR0aH1weGAgfSkpXG4gICAgXTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBleHBhbmRQdXNoKGR1cmF0aW9uLCB3aWR0aCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0eWxlKHsgb3ZlcmZsb3c6ICdoaWRkZW4nLCBmbGV4QmFzaXM6ICcwcHgnIH0pLFxuICAgICAgICBhbmltYXRlKGAke2R1cmF0aW9ufW1zIGVhc2UtaW5gLCBzdHlsZSh7IGZsZXhCYXNpczogYCR7d2lkdGh9cHhgIH0pKVxuICAgIF07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY29sbGFwc2VQdXNoKGR1cmF0aW9uLCB3aWR0aCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0eWxlKHsgZmxleEJhc2lzOiBgJHt3aWR0aH1weGAgfSksXG4gICAgICAgIGFuaW1hdGUoYCR7ZHVyYXRpb259bXMgZWFzZS1pbmAsIHN0eWxlKHsgb3ZlcmZsb3c6ICdoaWRkZW4nLCBmbGV4QmFzaXM6IGAwcHhgIH0pKVxuICAgIF07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZXhwYW5kUlRMT3ZlcmxheShkdXJhdGlvbikge1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgxMDAlKWAgfSksXG4gICAgICAgIGFuaW1hdGUoYCR7ZHVyYXRpb259bXMgZWFzZS1pbmAsIHN0eWxlKHsgb3ZlcmZsb3c6ICdoaWRkZW4nLCB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKDApYCB9KSlcbiAgICBdO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZE92ZXJsYXkoZHVyYXRpb24sIHBvc2l0aW9uKSB7XG4gICAgY29uc3QgdHJhbnNsYXRlRGlyID0gcG9zaXRpb24gIT09ICdlbmQnID8gYC0xMDAlYCA6IGAxMDAlYDtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGVEaXJ9KWAgfSksXG4gICAgICAgIGFuaW1hdGUoYCR7ZHVyYXRpb259bXMgZWFzZS1pbmAsIHN0eWxlKHsgb3ZlcmZsb3c6ICdoaWRkZW4nLCB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKDApYCB9KSlcbiAgICBdO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG1pbmlDb2xsYXBzZU92ZXJsYXkoZHVyYXRpb24sIHdpZHRoLCBtaW5pV2lkdGgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdHlsZSh7IHdpZHRoOiBgJHt3aWR0aH1weGAgfSksXG4gICAgICAgIGFuaW1hdGUoYCR7ZHVyYXRpb259bXMgZWFzZS1pbmAsIHN0eWxlKHsgb3ZlcmZsb3c6ICdoaWRkZW4nLCB3aWR0aDogYCR7bWluaVdpZHRofXB4YCB9KSlcbiAgICBdO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGNvbGxhcHNlT3ZlcmxheShkdXJhdGlvbiwgcG9zaXRpb24pIHtcbiAgICBjb25zdCB0cmFuc2xhdGVEaXIgPSBwb3NpdGlvbiAhPT0gJ2VuZCcgPyAnLTEwMCUnIDogJzEwMCUnO1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgwKWAgfSksXG4gICAgICAgIGFuaW1hdGUoYCR7ZHVyYXRpb259bXMgZWFzZS1pbmAsIHN0eWxlKHsgb3ZlcmZsb3c6ICdoaWRkZW4nLCB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7dHJhbnNsYXRlRGlyfSlgIH0pKVxuICAgIF07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY29sbGFwc2VSVExPdmVybGF5KGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKDApYCB9KSxcbiAgICAgICAgYW5pbWF0ZShgJHtkdXJhdGlvbn1tcyBlYXNlLWluYCwgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoMTAwJSlgIH0pKVxuICAgIF07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZXhwYW5kQW5pbWF0aW9uKHNldHRpbmdzKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSBzZXR0aW5ncy5hbmltYXRpb24uZHVyYXRpb247XG4gICAgY29uc3Qgd2lkdGggPSBzZXR0aW5ncy53aWR0aDtcbiAgICBjb25zdCBtaW5pV2lkdGggPSBzZXR0aW5ncy5taW5pV2lkdGg7XG4gICAgY29uc3QgbW9kZSA9IHNldHRpbmdzLm1vZGU7XG4gICAgY29uc3QgbWluaSA9IHNldHRpbmdzLm1pbmk7XG4gICAgY29uc3QgcnRsID0gc2V0dGluZ3MucnRsO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gc2V0dGluZ3MucG9zaXRpb247XG4gICAgaWYgKG1pbmkgJiYgbW9kZSA9PT0gJ3B1c2gnKSB7XG4gICAgICAgIHJldHVybiBtaW5pRXhwYW5kUHVzaChkdXJhdGlvbiwgd2lkdGgsIG1pbmlXaWR0aCk7XG4gICAgfVxuICAgIGlmICghbWluaSAmJiBtb2RlID09PSAncHVzaCcpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZFB1c2goZHVyYXRpb24sIHdpZHRoKTtcbiAgICB9XG4gICAgaWYgKCFtaW5pICYmIG1vZGUgPT09ICdvdmVybGF5Jykge1xuICAgICAgICByZXR1cm4gcnRsID8gZXhwYW5kUlRMT3ZlcmxheShkdXJhdGlvbikgOiBleHBhbmRPdmVybGF5KGR1cmF0aW9uLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIGlmIChtaW5pICYmIG1vZGUgPT09ICdvdmVybGF5Jykge1xuICAgICAgICByZXR1cm4gbWluaUV4cGFuZE92ZXJsYXkoZHVyYXRpb24sIHdpZHRoLCBtaW5pV2lkdGgpO1xuICAgIH1cbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBjb2xsYXBzZUFuaW1hdGlvbihzZXR0aW5ncykge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gc2V0dGluZ3MuYW5pbWF0aW9uLmR1cmF0aW9uO1xuICAgIGNvbnN0IHdpZHRoID0gc2V0dGluZ3Mud2lkdGg7XG4gICAgY29uc3QgbWluaVdpZHRoID0gc2V0dGluZ3MubWluaVdpZHRoO1xuICAgIGNvbnN0IG1vZGUgPSBzZXR0aW5ncy5tb2RlO1xuICAgIGNvbnN0IG1pbmkgPSBzZXR0aW5ncy5taW5pO1xuICAgIGNvbnN0IHJ0bCA9IHNldHRpbmdzLnJ0bDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHNldHRpbmdzLnBvc2l0aW9uO1xuICAgIGlmIChtaW5pICYmIG1vZGUgPT09ICdwdXNoJykge1xuICAgICAgICByZXR1cm4gbWluaUNvbGxhcHNlUHVzaChkdXJhdGlvbiwgd2lkdGgsIG1pbmlXaWR0aCk7XG4gICAgfVxuICAgIGlmICghbWluaSAmJiBtb2RlID09PSAncHVzaCcpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxhcHNlUHVzaChkdXJhdGlvbiwgd2lkdGgpO1xuICAgIH1cbiAgICBpZiAoIW1pbmkgJiYgbW9kZSA9PT0gJ292ZXJsYXknKSB7XG4gICAgICAgIHJldHVybiBydGwgPyBjb2xsYXBzZVJUTE92ZXJsYXkoZHVyYXRpb24pIDogY29sbGFwc2VPdmVybGF5KGR1cmF0aW9uLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIGlmIChtaW5pICYmIG1vZGUgPT09ICdvdmVybGF5Jykge1xuICAgICAgICByZXR1cm4gbWluaUNvbGxhcHNlT3ZlcmxheShkdXJhdGlvbiwgd2lkdGgsIG1pbmlXaWR0aCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBzZWxlY3RgIGV2ZW50IG9mIHRoZSBEcmF3ZXIuXG4gKi9cbmNsYXNzIERyYXdlclNlbGVjdEV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCQxIHtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBEcmF3ZXJTZXJ2aWNlID0gY2xhc3MgRHJhd2VyU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNlcyA9IFtdO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50LCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGRyYXdlciA9IHRoaXMub3duZXI7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IG5ldyBEcmF3ZXJTZWxlY3RFdmVudChPYmplY3QuYXNzaWduKHt9LCBhcmdzLCB7IHNlbmRlcjogZHJhd2VyIH0pKTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyhkcmF3ZXJbZXZlbnRdKSkge1xuICAgICAgICAgICAgZHJhd2VyW2V2ZW50XS5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9XG4gICAgb25TZWxlY3Qoc2VsZWN0ZWRJZHgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljZXMgPSBbc2VsZWN0ZWRJZHhdO1xuICAgICAgICBjb25zdCBkcmF3ZXIgPSB0aGlzLm93bmVyO1xuICAgICAgICBpZiAoZHJhd2VyLmF1dG9Db2xsYXBzZSAmJiAhZHJhd2VyLm1pbmltaXplZCkge1xuICAgICAgICAgICAgZHJhd2VyLnRvZ2dsZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFNlbGVjdGlvbigpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLm93bmVyLml0ZW1zO1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbkRyYXdlclNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIERyYXdlclNlcnZpY2UpO1xuXG5jb25zdCBERUZBVUxUX0FOSU1BVElPTiA9IHsgdHlwZTogJ3NsaWRlJywgZHVyYXRpb246IDIwMCB9O1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgRHJhd2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19kcmF3ZXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1kcmF3ZXItY29udGFpbmVyPlxuICogICAgICAgICAgICAgPGtlbmRvLWRyYXdlciAjZHJhd2VyXG4gKiAgICAgICAgICAgICAgICAgIFtpdGVtc109XCJpdGVtc1wiXG4gKiAgICAgICAgICAgICAgICAgIG1vZGU9XCJvdmVybGF5XCJcbiAqICAgICAgICAgICAgICAgICAgWyhleHBhbmRlZCldPVwiZXhwYW5kZWRcIj5cbiAqICAgICAgICAgICAgICA8L2tlbmRvLWRyYXdlcj5cbiAqICAgICAgICAgICAgICA8a2VuZG8tZHJhd2VyLWNvbnRlbnQ+XG4gKiAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJrLWJ1dHRvblwiIChjbGljayk9XCJkcmF3ZXIudG9nZ2xlKClcIj5PcGVuIHRoZSBEcmF3ZXI8L2J1dHRvbj5cbiAqICAgICAgICAgICAgICA8L2tlbmRvLWRyYXdlci1jb250ZW50PlxuICogICAgICAgIDwva2VuZG8tZHJhd2VyLWNvbnRhaW5lcj5cbiAqICAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgcHVibGljIGV4cGFuZGVkID0gZmFsc2U7XG4gKlxuICogICAgcHVibGljIGl0ZW1zOiBhbnlbXSA9IFtcbiAqICAgICAgeyB0ZXh0OiAnSW5ib3gnLCBpY29uOiAnay1pLWluYm94JyB9LFxuICogICAgICB7IHRleHQ6ICdOb3RpZmljYXRpb25zJywgaWNvbjogJ2staS1iZWxsJyB9LFxuICogICAgICB7IHRleHQ6ICdEYXRlJywgaWNvbjogJ2staS1jYWxlbmRhcicgfVxuICogICAgXTtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgRHJhd2VyQ29tcG9uZW50ID0gY2xhc3MgRHJhd2VyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBidWlsZGVyLCBsb2NhbGl6YXRpb25TZXJ2aWNlLCBkcmF3ZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuZHJhd2VyU2VydmljZSA9IGRyYXdlclNlcnZpY2U7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBtb2RlIGluIHdoaWNoIHRoZSBEcmF3ZXIgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgb3ZlcmxheWBcbiAgICAgICAgICogKiBgcHVzaGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW9kZSA9ICdvdmVybGF5JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgcG9zaXRpb24gb2YgdGhlIERyYXdlclxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHBvc2l0aW9uaW5nX2RyYXdlciAlfSkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiAoRGVmYXVsdCkgYHN0YXJ0YFxuICAgICAgICAgKiAqIGBlbmRgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gJ3N0YXJ0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIG1pbmkgKGNvbXBhY3QpIHZpZXcgb2YgdGhlIERyYXdlciB3aGljaCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGNvbGxhcHNlZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGV4cGFuZG1vZGVzcG9zaXRpb25zX2RyYXdlciAlfSN0b2MtbWluaS12aWV3KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbmkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgc3RhdGUgb2YgdGhlIERyYXdlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIHdpZHRoIG9mIHRoZSBEcmF3ZXIgd2hlbiBpdCBpcyBleHBhbmRlZC5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gYDI0MGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpZHRoID0gMjQwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgd2lkdGggb2YgdGhlIERyYXdlciB3aGVuIHRoZSBtaW5pIHZpZXcgaXMgZW5hYmxlZFxuICAgICAgICAgKiBhbmQgdGhlIGNvbXBvbmVudCBpcyBjb2xsYXBzZWQuIERlZmF1bHRzIHRvIGA2MGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbmlXaWR0aCA9IDUwO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSBEcmF3ZXIgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNvbGxhcHNlZCB3aGVuIGFuIGl0ZW1cbiAgICAgICAgICogb3IgdGhlIG92ZXJsYXkgaXMgY2xpY2tlZC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvQ29sbGFwc2UgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBhbmltYXRpb24gc2V0dGluZ3Mgb2YgdGhlIERyYXdlci5cbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBpbnRlcmFjdGlvbl9kcmF3ZXIgJX0jdG9jLXRvZ2dsaW5nLWJldHdlZW4tc3RhdGVzKSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIEJvb2xlYW5cbiAgICAgICAgICogICAgKiAoRGVmYXVsdCkgYHRydWVgXG4gICAgICAgICAqICAgICogYGZhbHNlYFxuICAgICAgICAgKiAqIGBEcmF3ZXJBbmltYXRpb25gXG4gICAgICAgICAqICAgICogKERlZmF1bHQpIGB0eXBlPzogJ3NsaWRlJ2BcbiAgICAgICAgICogICAgKiBgZHVyYXRpb25gJm1kYXNoO0FjY2VwdHMgYSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzLiBEZWZhdWx0cyB0byBgMzAwbXNgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBERUZBVUxUX0FOSU1BVElPTjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIERyYXdlciBpcyBleHBhbmRlZCBhbmQgaXRzIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgRHJhd2VyIGlzIGNvbGxhcHNlZCBhbmQgaXRzIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIGEgRHJhd2VyIGl0ZW0gaXMgc2VsZWN0ZWQuIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGBleHBhbmRlZGAgcHJvcGVydHkgb2YgdGhlIGNvbXBvbmVudCB3YXMgdXBkYXRlZC5cbiAgICAgICAgICogVXNlZCB0byBwcm92aWRlIGEgdHdvLXdheSBiaW5kaW5nIGZvciB0aGUgYGV4cGFuZGVkYCBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRW5kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnJ0bCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJ0bCA9IHJ0bDtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kcmF3ZXJTZXJ2aWNlLm93bmVyID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IHN0YXJ0UG9zaXRpb25DbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09ICdzdGFydCc7XG4gICAgfVxuICAgIGdldCBlbmRQb3NpdGlvbkNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA9PT0gJ2VuZCc7XG4gICAgfVxuICAgIGdldCBvdmVybGF5VHJhbnNvZnJtU3R5bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAncHVzaCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCB8fCB0aGlzLm1pbmltaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGVYKDBweClgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgdHJhbnNsYXRlWCgtMTAwJSlgO1xuICAgIH1cbiAgICBnZXQgZmxleFN0eWxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ292ZXJsYXknKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmV4cGFuZGVkICYmICF0aGlzLm1pbmltaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyV2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIGl0ZW1zIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBpbiB0aGUgRHJhd2VyLlxuICAgICAqL1xuICAgIHNldCBpdGVtcyhpdGVtcykge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGl0ZW1zKSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICAgICAgICAgIHRoaXMuZHJhd2VyU2VydmljZS5pbml0U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IG1pbmltaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluaSAmJiAhdGhpcy5leHBhbmRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkcmF3ZXJXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluaW1pemVkID8gdGhpcy5taW5pV2lkdGggOiB0aGlzLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBEcmF3ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXhwYW5kZWQ/IC0gQm9vbGVhbi4gU3BlY2lmaWVzIGlmIHRoZSBEcmF3ZXIgd2lsbCBiZSBleHBhbmRlZCBvciBjb2xsYXBzZWQuXG4gICAgICovXG4gICAgdG9nZ2xlKGV4cGFuZGVkKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5leHBhbmRlZDtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGlzUHJlc2VudChleHBhbmRlZCkgPyBleHBhbmRlZCA6ICFwcmV2aW91cztcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXhwYW5kZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gZmFsc2UgJiYgIXRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNldEV4cGFuZGVkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRW5kLnBpcGUodGFrZSgxKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHsgdGhpcy5vbkFuaW1hdGlvbkVuZChjdXJyZW50KTsgfSk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGUoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2N1cnJlbnQgPyAnZXhwYW5kJyA6ICdjb2xsYXBzZSddLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkFuaW1hdGlvbkVuZChjdXJyZW50RXhwYW5kZWQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRFeHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRFeHBhbmRlZChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFeHBhbmRlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgfVxuICAgIGFuaW1hdGUoZXhwYW5kZWQpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgICBtaW5pOiB0aGlzLm1pbmksXG4gICAgICAgICAgICBtaW5pV2lkdGg6IHRoaXMubWluaVdpZHRoLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBydGw6IHRoaXMucnRsLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMucG9zaXRpb24sXG4gICAgICAgICAgICBhbmltYXRpb246ICh0eXBlb2YgdGhpcy5hbmltYXRpb24gIT09ICdib29sZWFuJykgPyB0aGlzLmFuaW1hdGlvbiA6IERFRkFVTFRfQU5JTUFUSU9OXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IGV4cGFuZGVkID8gZXhwYW5kQW5pbWF0aW9uKHNldHRpbmdzKSA6IGNvbGxhcHNlQW5pbWF0aW9uKHNldHRpbmdzKTtcbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5jcmVhdGVQbGF5ZXIoYW5pbWF0aW9uLCB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHBsYXllci5wbGF5KCk7XG4gICAgfVxuICAgIGNyZWF0ZVBsYXllcihhbmltYXRpb24sIGFuaW1hdGVkRWxlbWVudCkge1xuICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5idWlsZGVyLmJ1aWxkKGFuaW1hdGlvbik7XG4gICAgICAgIGxldCBwbGF5ZXIgPSBmYWN0b3J5LmNyZWF0ZShhbmltYXRlZEVsZW1lbnQpO1xuICAgICAgICBwbGF5ZXIub25Eb25lKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkVuZC5lbWl0KCk7XG4gICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYXllcjtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstd2lkZ2V0JyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZHJhd2VyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEcmF3ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kcmF3ZXItc3RhcnQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRHJhd2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydFBvc2l0aW9uQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kcmF3ZXItZW5kJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIERyYXdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZW5kUG9zaXRpb25DbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS50cmFuc2Zvcm0nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBEcmF3ZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm92ZXJsYXlUcmFuc29mcm1TdHlsZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnc3R5bGUuZmxleEJhc2lzLnB4JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRHJhd2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmbGV4U3R5bGVzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRHJhd2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtb2RlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEcmF3ZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRHJhd2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5pXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRHJhd2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBhbmRlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRHJhd2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRHJhd2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5pV2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEcmF3ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImF1dG9Db2xsYXBzZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgRHJhd2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmRpcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEcmF3ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRHJhd2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEcmF3ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImV4cGFuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERyYXdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sbGFwc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEcmF3ZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERyYXdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kZWRDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERyYXdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZHJhd2VyVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChEcmF3ZXJGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEcmF3ZXJGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERyYXdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9vdGVyVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChEcmF3ZXJIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEcmF3ZXJIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERyYXdlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVhZGVyVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChEcmF3ZXJJdGVtVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRHJhd2VySXRlbVRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRHJhd2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtVGVtcGxhdGVcIiwgdm9pZCAwKTtcbkRyYXdlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9EcmF3ZXInLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBEcmF3ZXJTZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uZHJhd2VyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWRyYXdlcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLWRyYXdlci13cmFwcGVyXCIgKm5nSWY9XCJleHBhbmRlZCB8fCBtaW5pXCIgW3N0eWxlLndpZHRoLnB4XT1cImRyYXdlcldpZHRoXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWRyYXdlclRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaGVhZGVyVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJoZWFkZXJUZW1wbGF0ZT8udGVtcGxhdGVSZWZcIj5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICAgICAgPHVsIGtlbmRvRHJhd2VyTGlzdFxuICAgICAgICAgICAgICAgICAgICBbaXRlbXNdPVwiaXRlbXNcIiBbbWluaV09XCJtaW5pXCIgW2V4cGFuZGVkXT1cImV4cGFuZGVkXCJcbiAgICAgICAgICAgICAgICAgICAgW2l0ZW1UZW1wbGF0ZV09XCJpdGVtVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWRyYXdlci1pdGVtc1wiPlxuICAgICAgICAgICAgICAgIDwvdWw+XG5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJmb290ZXJUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImZvb3RlclRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiPlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiZHJhd2VyVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImRyYXdlclRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9kaXY+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgQW5pbWF0aW9uQnVpbGRlcixcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgRHJhd2VyU2VydmljZV0pXG5dLCBEcmF3ZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIFNlcnZlcyBhcyBhIGNvbnRhaW5lciBmb3IgdGhlIFtLZW5kbyBVSSBEcmF3ZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2RyYXdlciAlfSkgYW5kIGl0cyBjb250ZW50LlxuICovXG5sZXQgRHJhd2VyQ29udGFpbmVyQ29tcG9uZW50ID0gY2xhc3MgRHJhd2VyQ29udGFpbmVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMucnRsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ydGwgPSBydGw7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMucnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBob3N0Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgb3ZlcmxheUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3ZXIubW9kZSA9PT0gJ292ZXJsYXknO1xuICAgIH1cbiAgICBnZXQgbWluaUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3ZXIubWluaTtcbiAgICB9XG4gICAgZ2V0IHB1c2hDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyLm1vZGUgPT09ICdwdXNoJztcbiAgICB9XG4gICAgZ2V0IGlzRXhwYW5kZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyLmV4cGFuZGVkO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBvdmVybGF5KCkge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZHJhd2VyKSAmJlxuICAgICAgICAgICAgdGhpcy5kcmF3ZXIuZXhwYW5kZWQgJiZcbiAgICAgICAgICAgIHRoaXMuZHJhd2VyLm1vZGUgPT09ICdvdmVybGF5JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNsb3NlRHJhd2VyKCkge1xuICAgICAgICBpZiAodGhpcy5vdmVybGF5ICYmIHRoaXMuZHJhd2VyLmF1dG9Db2xsYXBzZSkge1xuICAgICAgICAgICAgdGhpcy5kcmF3ZXIudG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kcmF3ZXItY29udGFpbmVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIERyYXdlckNvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZHJhd2VyLW92ZXJsYXknKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRHJhd2VyQ29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvdmVybGF5Q2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kcmF3ZXItbWluaScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBEcmF3ZXJDb250YWluZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1pbmlDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWRyYXdlci1wdXNoJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIERyYXdlckNvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwicHVzaENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZHJhd2VyLWV4cGFuZGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIERyYXdlckNvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNFeHBhbmRlZENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERyYXdlckNvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlyZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoRHJhd2VyQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERyYXdlckNvbXBvbmVudClcbl0sIERyYXdlckNvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZHJhd2VyXCIsIHZvaWQgMCk7XG5EcmF3ZXJDb250YWluZXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWRyYXdlci1jb250YWluZXInLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5kcmF3ZXIuY29udGFpbmVyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1vdmVybGF5XCIgKm5nSWY9XCJvdmVybGF5XCIgKGNsaWNrKT1cImNsb3NlRHJhd2VyKClcIj48L2Rpdj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgRHJhd2VyQ29udGFpbmVyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb250ZW50IG9mIHRoZSBbS2VuZG8gVUkgRHJhd2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19kcmF3ZXIgJX0pLlxuICovXG5sZXQgRHJhd2VyQ29udGVudENvbXBvbmVudCA9IGNsYXNzIERyYXdlckNvbnRlbnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZHJhd2VyLWNvbnRlbnQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyYXdlckNvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIHZvaWQgMCk7XG5EcmF3ZXJDb250ZW50Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1kcmF3ZXItY29udGVudCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRHJhd2VyQ29udGVudENvbXBvbmVudCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRlbXBsYXRlIHRoYXQgZGVmaW5lcyB0aGUgY29udGVudCBvZiB0aGUgd2hvbGUgU3RlcC5cbiAqIFRvIGRlZmluZSB0aGUgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZ1xuICogd2l0aCB0aGUgYGtlbmRvU3RlcHBlclN0ZXBUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgYDxrZW5kby1zdGVwcGVyPmAgdGFnLlxuICovXG5sZXQgU3RlcHBlclN0ZXBUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIFN0ZXBwZXJTdGVwVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuU3RlcHBlclN0ZXBUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvU3RlcHBlclN0ZXBUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIFN0ZXBwZXJTdGVwVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0ZW1wbGF0ZSB0aGF0IGRlZmluZXMgdGhlIGNvbnRlbnQgb2YgdGhlIFN0ZXAgbGFiZWwuXG4gKiBUbyBkZWZpbmUgdGhlIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWdcbiAqIHdpdGggdGhlIGBrZW5kb1N0ZXBwZXJMYWJlbFRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBgPGtlbmRvLXN0ZXBwZXI+YCB0YWcuXG4gKi9cbmxldCBTdGVwcGVyTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIFN0ZXBwZXJMYWJlbFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcblN0ZXBwZXJMYWJlbFRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9TdGVwcGVyTGFiZWxUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIFN0ZXBwZXJMYWJlbFRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdGVtcGxhdGUgdGhhdCBkZWZpbmVzIHRoZSBjb250ZW50IG9mIHRoZSBTdGVwIGluZGljYXRvci5cbiAqIFRvIGRlZmluZSB0aGUgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZ1xuICogd2l0aCB0aGUgYGtlbmRvU3RlcHBlckluZGljYXRvclRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBgPGtlbmRvLXN0ZXBwZXI+YCB0YWcuXG4gKi9cbmxldCBTdGVwcGVySW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBTdGVwcGVySW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuU3RlcHBlckluZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9TdGVwcGVySW5kaWNhdG9yVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBTdGVwcGVySW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBhY3RpdmF0ZWAgZXZlbnQgb2YgdGhlIFN0ZXBwZXIuXG4gKi9cbmNsYXNzIFN0ZXBwZXJBY3RpdmF0ZUV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCQxIHtcbn1cblxuY29uc3QgREVGQVVMVF9DVVJSRU5UX1NURVAgPSAwO1xuY29uc3QgaGFuZGxlcnMgPSB7fTtcbmhhbmRsZXJzW0tleXMuQXJyb3dMZWZ0XSA9ICdsZWZ0JztcbmhhbmRsZXJzW0tleXMuQXJyb3dSaWdodF0gPSAncmlnaHQnO1xuaGFuZGxlcnNbS2V5cy5BcnJvd1VwXSA9ICd1cCc7XG5oYW5kbGVyc1tLZXlzLkFycm93RG93bl0gPSAnZG93bic7XG5oYW5kbGVyc1tLZXlzLkhvbWVdID0gJ2hvbWUnO1xuaGFuZGxlcnNbS2V5cy5FbmRdID0gJ2VuZCc7XG5oYW5kbGVyc1tLZXlzLkVudGVyXSA9ICdlbnRlcic7XG5oYW5kbGVyc1tLZXlzLlNwYWNlXSA9ICdlbnRlcic7XG5jb25zdCBoYW5kbGVyc1JUTCA9IE9iamVjdC5hc3NpZ24oe30sIGhhbmRsZXJzKTtcbmhhbmRsZXJzUlRMW0tleXMuQXJyb3dMZWZ0XSA9ICdyaWdodCc7XG5oYW5kbGVyc1JUTFtLZXlzLkFycm93UmlnaHRdID0gJ2xlZnQnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTdGVwcGVyU2VydmljZSA9IGNsYXNzIFN0ZXBwZXJTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIG5nWm9uZSwgY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSBERUZBVUxUX0NVUlJFTlRfU1RFUDtcbiAgICAgICAgdGhpcy50cmlnZ2VyVmFsaWRhdGlvbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkU3RlcENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IGhhbmRsZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gaGFuZGxlcnNSVEwgOiBoYW5kbGVycztcbiAgICB9XG4gICAgZW1pdChldmVudCwgZXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IHN0ZXBwZXIgPSB0aGlzLm93bmVyO1xuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHN0ZXBwZXJbZXZlbnRdKSkge1xuICAgICAgICAgICAgc3RlcHBlcltldmVudF0uZW1pdChldmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudEFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgfVxuICAgIG9uQWN0aXZhdGUoY3VycmVudElkeCwgb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBjb25zdCBldmVudEFyZ3MgPSBuZXcgU3RlcHBlckFjdGl2YXRlRXZlbnQoe1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJZHgsXG4gICAgICAgICAgICBzdGVwOiB0aGlzLm93bmVyLnN0ZXBzW2N1cnJlbnRJZHhdLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcbiAgICAgICAgICAgIHNlbmRlcjogdGhpcy5vd25lclxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lbWl0KCdhY3RpdmF0ZScsIGV2ZW50QXJncykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gY3VycmVudElkeDtcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyWydjdXJyZW50U3RlcENoYW5nZSddLmVtaXQoY3VycmVudElkeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YWxpZGF0ZVN0ZXBzKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJWYWxpZGF0aW9uLmVtaXQoKTtcbiAgICB9XG4gICAga2V5ZG93bihlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmZvY3VzZWRTdGVwIHx8IHRoaXMuY3VycmVudFN0ZXA7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzW2Uua2V5Q29kZV07XG4gICAgICAgIGlmICghaXNQcmVzZW50KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXNbaGFuZGxlcl0oZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGVmdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXNQcmV2U3RlcCgpO1xuICAgIH1cbiAgICByaWdodCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXNOZXh0U3RlcCgpO1xuICAgIH1cbiAgICB1cCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2N1c1ByZXZTdGVwKCk7XG4gICAgfVxuICAgIGRvd24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXNOZXh0U3RlcCgpO1xuICAgIH1cbiAgICBob21lKCkge1xuICAgICAgICB0aGlzLmZvY3VzZWRTdGVwID0gMDtcbiAgICAgICAgdGhpcy5mb2N1c2VkU3RlcENoYW5nZS5lbWl0KCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkU3RlcCA9IHRoaXMub3duZXIuc3RlcHMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5mb2N1c2VkU3RlcENoYW5nZS5lbWl0KCk7XG4gICAgfVxuICAgIGVudGVyKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzZWRTdGVwID09PSB0aGlzLmN1cnJlbnRTdGVwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTdGVwRGlzYWJsZWQodGhpcy5mb2N1c2VkU3RlcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vd25lci5saW5lYXIgJiYgdGhpcy5pc1ByZXZPck5leHRTdGVwKHRoaXMuZm9jdXNlZFN0ZXApID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25BY3RpdmF0ZSh0aGlzLmZvY3VzZWRTdGVwLCBldmVudCk7XG4gICAgfVxuICAgIGZvY3VzKGZvY3VzZWRJZHgpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkU3RlcCA9IGZvY3VzZWRJZHg7XG4gICAgfVxuICAgIGZvY3VzTmV4dFN0ZXAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzZWRTdGVwIDwgdGhpcy5vd25lci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZFN0ZXAgKz0gMTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZFN0ZXBDaGFuZ2UuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvY3VzUHJldlN0ZXAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzZWRTdGVwID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkU3RlcCAtPSAxO1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkU3RlcENoYW5nZS5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNTdGVwRGlzYWJsZWQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3duZXIuc3RlcHNbaW5kZXhdLmRpc2FibGVkO1xuICAgIH1cbiAgICBpc1ByZXZPck5leHRTdGVwKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gdGhpcy5jdXJyZW50U3RlcCArIDEgfHwgaW5kZXggPT09IHRoaXMuY3VycmVudFN0ZXAgLSAxO1xuICAgIH1cbiAgICBnZXQgaXNIb3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vd25lci5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgIH1cbn07XG5TdGVwcGVyU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgU3RlcHBlclNlcnZpY2UpO1xuXG5jb25zdCBERUZBVUxUX0FOSU1BVElPTl9EVVJBVElPTiA9IDQwMDtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIFN0ZXBwZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3N0ZXBwZXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1zdGVwcGVyIFtzdGVwc109XCJzdGVwc1wiPlxuICogICAgICAgIDwva2VuZG8tc3RlcHBlcj5cbiAqICAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgcHVibGljIHN0ZXBzOiBBcnJheTxTdGVwcGVyU3RlcD4gPSBbXG4gKiAgICAgIHsgbGFiZWw6ICdTdGVwIE9uZScgfSwgeyBsYWJlbDogJ1N0ZXAgVHdvJyB9LCB7IGxhYmVsOiAnU3RlcCBUaHJlZScgfVxuICogICAgXTtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgU3RlcHBlckNvbXBvbmVudCA9IGNsYXNzIFN0ZXBwZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBlbGVtLCBsb2NhbGl6YXRpb24sIHN0ZXBwZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UgPSBzdGVwcGVyU2VydmljZTtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuYXJpYVJvbGUgPSAnbmF2aWdhdGlvbic7XG4gICAgICAgIHRoaXMuZGlzcGxheVN0eWxlID0gJ2dyaWQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSB0eXBlIG9mIHRoZSBzdGVwcyBpbiB0aGUgU3RlcHBlci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICogKERlZmF1bHQpIGBpbmRpY2F0b3JgXG4gICAgICAgICAqICogYGxhYmVsYFxuICAgICAgICAgKiAqIGBmdWxsYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGVwVHlwZSA9ICdpbmRpY2F0b3InO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBsaW5lYXIgZmxvdyBvZiB0aGUgU3RlcHBlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lYXIgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgU3RlcHBlclxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG9yaWVudGF0aW9uX3N0ZXBwZXIgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICogKERlZmF1bHQpIGBob3Jpem9udGFsYFxuICAgICAgICAgKiAqIGB2ZXJ0aWNhbGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgdG8gYDQwMG1zYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICAqIEJvb2xlYW5cbiAgICAgICAgICogICAgKiAoRGVmYXVsdCkgYHRydWVgXG4gICAgICAgICAqICAgICogZmFsc2VcbiAgICAgICAgICogICogTnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIGEgc3RlcCBpcyBhYm91dCB0byBiZSBhY3RpdmF0ZWQuIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYGN1cnJlbnRTdGVwYCBwcm9wZXJ0eSBvZiB0aGUgY29tcG9uZW50IHdhcyB1cGRhdGVkLlxuICAgICAgICAgKiBVc2VkIHRvIHByb3ZpZGUgYSB0d28td2F5IGJpbmRpbmcgZm9yIHRoZSBgY3VycmVudFN0ZXBgIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fc3RlcHMgPSBbXTtcbiAgICAgICAgdGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2Uub3duZXIgPSB0aGlzO1xuICAgIH1cbiAgICBnZXQgbGluZWFyQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVhcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHN0ZXAuXG4gICAgICovXG4gICAgc2V0IGN1cnJlbnRTdGVwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuY3VycmVudFN0ZXAgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRTdGVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcGVyU2VydmljZS5jdXJyZW50U3RlcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbGxlY3Rpb24gb2Ygc3RlcHMgdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGluIHRoZSBTdGVwcGVyLlxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc3RlcF9hcHBlYXJhbmNlX3N0ZXBwZXIgJX0pKVxuICAgICAqL1xuICAgIHNldCBzdGVwcyhzdGVwcykge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHN0ZXBzKSAmJiBzdGVwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGVwcyA9IHN0ZXBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzdGVwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXBzO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5hcHBseUhvc3RTdHlsaW5nKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuc3RlcHMgJiYgIWNoYW5nZXMuc3RlcHMuZmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlIb3N0U3R5bGluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0SG9zdFN0eWxpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlIb3N0U3R5bGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSB0cmlnZ2VycyB0aGUgdmFsaWRpdHkgY2hlY2sgY29uZmlndXJlZCBieSB0aGUgW2lzVmFsaWRdKHslIHNsdWcgYXBpX2xheW91dF9zdGVwcGVyc3RlcCAlfSN0b2MtaXN2YWxpZCkgcHJvcGVydHkgb2YgdGhlIHN0ZXBzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc3RlcF92YWxpZGF0aW9uX3N0ZXBwZXIgJX0jdG9jLXRyaWdnZXJpbmctdGhlLXZhbGlkYXRpb24pKS5cbiAgICAgKlxuICAgICAqIFN0ZXBzIHRoYXQgaGF2ZSB0aGVpciBbdmFsaWRhdGVdKHslIHNsdWcgYXBpX2xheW91dF9zdGVwcGVyc3RlcCAlfSN0b2MtdmFsaWRhdGUpIHByb3BlcnR5IHNldCB0byBgZmFsc2VgLCB3aWxsIG5vdCBiZSB2YWxpZGF0ZWQuXG4gICAgICovXG4gICAgdmFsaWRhdGVTdGVwcygpIHtcbiAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS52YWxpZGF0ZVN0ZXBzKCk7XG4gICAgfVxuICAgIGFwcGx5SG9zdFN0eWxpbmcoKSB7XG4gICAgICAgIGNvbnN0IHN0ZXBGcmFtZXNTdHlsZSA9IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/ICdncmlkLXRlbXBsYXRlLWNvbHVtbnMnIDogJ2dyaWQtdGVtcGxhdGUtcm93cyc7XG4gICAgICAgIGNvbnN0IHN0ZXBGcmFtZXNWYWx1ZSA9IGByZXBlYXQoJHt0aGlzLnN0ZXBzLmxlbmd0aCAqIDJ9LCAxZnIpYDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsZW0ubmF0aXZlRWxlbWVudCwgc3RlcEZyYW1lc1N0eWxlLCBzdGVwRnJhbWVzVmFsdWUpO1xuICAgIH1cbiAgICByZXNldEhvc3RTdHlsaW5nKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZVN0eWxlKHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LCAnZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zJyk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlU3R5bGUodGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQsICdncmlkLXRlbXBsYXRlLXJvd3MnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBwcm9ncmVzc0FuaW1hdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgZHVyYXRpb246IHRoaXMuYW5pbWF0aW9uRHVyYXRpb24gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBhbmltYXRpb25EdXJhdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmFuaW1hdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYW5pbWF0aW9uID09PSAnYm9vbGVhbicgJiYgdGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0FOSU1BVElPTl9EVVJBVElPTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBzdGVwc0xpc3RTdHlsaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICByZXR1cm4geyAnZ3JpZC1jb2x1bW4tc3RhcnQnOiAxLCAnZ3JpZC1jb2x1bW4tZW5kJzogLTEgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAnZ3JpZC1yb3ctc3RhcnQnOiAxLCAnZ3JpZC1yb3ctZW5kJzogLTEgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBwcm9ncmVzc0JhclN0eWxpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2dyaWQtY29sdW1uLXN0YXJ0JzogMixcbiAgICAgICAgICAgICAgICAnZ3JpZC1jb2x1bW4tZW5kJzogdGhpcy5zdGVwcy5sZW5ndGggKiAyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZ3JpZC1yb3ctc3RhcnQnOiAyLFxuICAgICAgICAgICAgJ2dyaWQtcm93LWVuZCc6IHRoaXMuc3RlcHMubGVuZ3RoICogMlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKioqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpc0hvcml6b250YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmlzSG9yaXpvbnRhbDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstd2lkZ2V0JyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc3RlcHBlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU3RlcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXN0ZXBwZXItbGluZWFyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFN0ZXBwZXJDb21wb25lbnQucHJvdG90eXBlLCBcImxpbmVhckNsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTdGVwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhUm9sZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFN0ZXBwZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLmRpc3BsYXknKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3RlcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzcGxheVN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTdGVwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwVHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFN0ZXBwZXJDb21wb25lbnQucHJvdG90eXBlLCBcImxpbmVhclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3RlcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwib3JpZW50YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgU3RlcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VycmVudFN0ZXBcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBTdGVwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFN0ZXBwZXJDb21wb25lbnQucHJvdG90eXBlLCBcInN1Y2Nlc3NJY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTdGVwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvckljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFN0ZXBwZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFN0ZXBwZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgU3RlcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VycmVudFN0ZXBDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChTdGVwcGVyU3RlcFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0ZXBwZXJTdGVwVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBTdGVwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChTdGVwcGVyTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdGVwcGVyTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIFN0ZXBwZXJDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChTdGVwcGVySW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RlcHBlckluZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgU3RlcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5kaWNhdG9yVGVtcGxhdGVcIiwgdm9pZCAwKTtcblN0ZXBwZXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvU3RlcHBlcicsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIFN0ZXBwZXJTZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uc3RlcHBlcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1zdGVwcGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBrZW5kb1N0ZXBwZXJMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICAgICAgaTE4bi1vcHRpb25hbD1cImtlbmRvLnN0ZXBwZXIub3B0aW9uYWx8VGhlIHRleHQgZm9yIHRoZSBvcHRpb25hbCBzZWdtZW50IG9mIHRoZSBzdGVwIGxhYmVsXCJcbiAgICAgICAgICAgIG9wdGlvbmFsPVwiT3B0aW9uYWxcIlxuICAgICAgICAgPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG9sIGtlbmRvU3RlcHBlckxpc3RcbiAgICAgICAgICAgIFtzdGVwVHlwZV09J3N0ZXBUeXBlJ1xuICAgICAgICAgICAgW2xpbmVhcl09J2xpbmVhcidcbiAgICAgICAgICAgIFtvcmllbnRhdGlvbl09J29yaWVudGF0aW9uJ1xuICAgICAgICAgICAgW3N0ZXBzXT0nc3RlcHMnXG4gICAgICAgICAgICBbY3VycmVudFN0ZXBdPSdjdXJyZW50U3RlcCdcbiAgICAgICAgICAgIFtzdWNjZXNzSWNvbl09J3N1Y2Nlc3NJY29uJ1xuICAgICAgICAgICAgW2Vycm9ySWNvbl09J2Vycm9ySWNvbidcbiAgICAgICAgICAgIFtpbmRpY2F0b3JUZW1wbGF0ZV09J2luZGljYXRvclRlbXBsYXRlPy50ZW1wbGF0ZVJlZidcbiAgICAgICAgICAgIFtsYWJlbFRlbXBsYXRlXT0nbGFiZWxUZW1wbGF0ZT8udGVtcGxhdGVSZWYnXG4gICAgICAgICAgICBbc3RlcFRlbXBsYXRlXT0nc3RlcFRlbXBsYXRlPy50ZW1wbGF0ZVJlZidcbiAgICAgICAgICAgIGNsYXNzPSdrLXN0ZXAtbGlzdCdcbiAgICAgICAgICAgIFtjbGFzcy5rLXN0ZXAtbGlzdC1ob3Jpem9udGFsXT0naXNIb3Jpem9udGFsJ1xuICAgICAgICAgICAgW2NsYXNzLmstc3RlcC1saXN0LXZlcnRpY2FsXT0nIWlzSG9yaXpvbnRhbCdcbiAgICAgICAgICAgIFtuZ1N0eWxlXT0nc3RlcHNMaXN0U3R5bGluZyc+XG4gICAgICAgIDwvb2w+XG5cbiAgICAgICAgPGtlbmRvLXByb2dyZXNzYmFyICpuZ0lmPSdzdGVwcy5sZW5ndGggPiAwJ1xuICAgICAgICAgICAgW2F0dHIuYXJpYS1oaWRkZW5dPSd0cnVlJ1xuICAgICAgICAgICAgW2FuaW1hdGlvbl09J3Byb2dyZXNzQW5pbWF0aW9uJ1xuICAgICAgICAgICAgW21heF09J3N0ZXBzLmxlbmd0aCAtIDEnXG4gICAgICAgICAgICBbbGFiZWxdPSdmYWxzZSdcbiAgICAgICAgICAgIFtvcmllbnRhdGlvbl09J29yaWVudGF0aW9uJ1xuICAgICAgICAgICAgW3JldmVyc2VdPSchaXNIb3Jpem9udGFsJ1xuICAgICAgICAgICAgW3ZhbHVlXT0nY3VycmVudFN0ZXAnXG4gICAgICAgICAgICBbbmdTdHlsZV09J3Byb2dyZXNzQmFyU3R5bGluZyc+XG4gICAgICAgIDwva2VuZG8tcHJvZ3Jlc3NiYXI+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUmVuZGVyZXIyLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBTdGVwcGVyU2VydmljZV0pXG5dLCBTdGVwcGVyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFN0ZXBwZXJNZXNzYWdlcyBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFN0ZXBwZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwib3B0aW9uYWxcIiwgdm9pZCAwKTtcblxudmFyIFN0ZXBwZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xO1xuLyoqXG4gKiBDdXN0b20gY29tcG9uZW50IG1lc3NhZ2VzIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50IG1lc3NhZ2VzXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJ0bF9sYXlvdXQgJX0pKS5cbiAqL1xubGV0IFN0ZXBwZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IFN0ZXBwZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gY2xhc3MgU3RlcHBlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50IGV4dGVuZHMgU3RlcHBlck1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblN0ZXBwZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IFN0ZXBwZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogU3RlcHBlck1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFN0ZXBwZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXN0ZXBwZXItbWVzc2FnZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgU3RlcHBlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KTtcblxudmFyIExvY2FsaXplZFN0ZXBwZXJNZXNzYWdlc0RpcmVjdGl2ZV8xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBMb2NhbGl6ZWRTdGVwcGVyTWVzc2FnZXNEaXJlY3RpdmUgPSBMb2NhbGl6ZWRTdGVwcGVyTWVzc2FnZXNEaXJlY3RpdmVfMSA9IGNsYXNzIExvY2FsaXplZFN0ZXBwZXJNZXNzYWdlc0RpcmVjdGl2ZSBleHRlbmRzIFN0ZXBwZXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5Mb2NhbGl6ZWRTdGVwcGVyTWVzc2FnZXNEaXJlY3RpdmUgPSBMb2NhbGl6ZWRTdGVwcGVyTWVzc2FnZXNEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFN0ZXBwZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMb2NhbGl6ZWRTdGVwcGVyTWVzc2FnZXNEaXJlY3RpdmVfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6IGBcbiAgICAgIFtrZW5kb1N0ZXBwZXJMb2NhbGl6ZWRNZXNzYWdlc11cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIExvY2FsaXplZFN0ZXBwZXJNZXNzYWdlc0RpcmVjdGl2ZSk7XG5cbi8qKlxuICogRGlzcGxheXMgaW1hZ2VzLCBpY29ucyBvciBpbml0aWFscyByZXByZXNlbnRpbmcgcGVvcGxlIG9yIG90aGVyIGVudGl0aWVzLlxuICovXG5sZXQgQXZhdGFyQ29tcG9uZW50ID0gY2xhc3MgQXZhdGFyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgZWxlbWVudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYSBib3JkZXIgdG8gdGhlIGF2YXRhci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm9yZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RoZW1lQ29sb3IgPSAncHJpbWFyeSc7XG4gICAgICAgIHRoaXMuX3NpemUgPSAnbWVkaXVtJztcbiAgICAgICAgdGhpcy5fZmlsbE1vZGUgPSAnc29saWQnO1xuICAgICAgICB0aGlzLl9yb3VuZGVkID0gJ2Z1bGwnO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBib3JkZXJDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGZsZXhCYXNpcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNoYXBlIGZvciB0aGUgYXZhdGFyLlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgc2hhcGUoc2hhcGUpIHtcbiAgICAgICAgdGhpcy5yb3VuZGVkID0gbWFwU2hhcGVUb1JvdW5kZWQoc2hhcGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHNpemUgb2YgdGhlIGF2YXRhclxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBwZWFyYW5jZV9hdmF0YXIgJX0jdG9jLXNpemUpKS5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYHNtYWxsYFxuICAgICAqICogYG1lZGl1bWAgKERlZmF1bHQpXG4gICAgICogKiBgbGFyZ2VgXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgc2l6ZShzaXplKSB7XG4gICAgICAgIGlmIChzaXplICE9PSB0aGlzLl9zaXplKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsYXNzZXMoJ3NpemUnLCBzaXplKTtcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSBzaXplID09PSBudWxsID8gbnVsbCA6IHNpemUgfHwgJ21lZGl1bSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHJvdW5kZWQgc3R5bGluZyBvZiB0aGUgYXZhdGFyXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcHBlYXJhbmNlX2F2YXRhciAlfSN0b2Mtcm91bmRlZC1jb3JuZXJzKSkuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGBzbWFsbGBcbiAgICAgKiAqIGBtZWRpdW1gXG4gICAgICogKiBgbGFyZ2VgXG4gICAgICogKiBgZnVsbGAgKERlZmF1bHQpXG4gICAgICogKiBudWxsXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgcm91bmRlZChyb3VuZGVkKSB7XG4gICAgICAgIGlmIChyb3VuZGVkICE9PSB0aGlzLl9yb3VuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsYXNzZXMoJ3JvdW5kZWQnLCByb3VuZGVkKTtcbiAgICAgICAgICAgIHRoaXMuX3JvdW5kZWQgPSByb3VuZGVkID09PSBudWxsID8gbnVsbCA6IHJvdW5kZWQgfHwgJ2Z1bGwnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCByb3VuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm91bmRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSB0aGVtZSBjb2xvciBvZiB0aGUgYXZhdGFyLlxuICAgICAqIFRoZSB0aGVtZSBjb2xvciB3aWxsIGJlIGFwcGxpZWQgYXMgYmFja2dyb3VuZCBhbmQgYm9yZGVyIGNvbG9yLCB3aGlsZSBhbHNvIGFtZW5kaW5nIHRoZSB0ZXh0IGNvbG9yIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgYmFzZWAmbWRhc2g7IEFwcGxpZXMgdGhlIGJhc2UgY29sb3JpbmcgdmFsdWUuXG4gICAgICogKiBgcHJpbWFyeWAgKERlZmF1bHQpJm1kYXNoO0FwcGxpZXMgY29sb3JpbmcgYmFzZWQgb24gcHJpbWFyeSB0aGVtZSBjb2xvci5cbiAgICAgKiAqIGBzZWNvbmRhcnlgJm1kYXNoO0FwcGxpZXMgY29sb3JpbmcgYmFzZWQgb24gc2Vjb25kYXJ5IHRoZW1lIGNvbG9yLlxuICAgICAqICogYHRlcnRpYXJ5YCZtZGFzaDsgQXBwbGllcyBjb2xvcmluZyBiYXNlZCBvbiB0ZXJ0aWFyeSB0aGVtZSBjb2xvci5cbiAgICAgKiAqIGBpbmZvYCZtZGFzaDtBcHBsaWVzIGNvbG9yaW5nIGJhc2VkIG9uIGluZm8gdGhlbWUgY29sb3IuXG4gICAgICogKiBgc3VjY2Vzc2AmbWRhc2g7IEFwcGxpZXMgY29sb3JpbmcgYmFzZWQgb24gc3VjY2VzcyB0aGVtZSBjb2xvci5cbiAgICAgKiAqIGB3YXJuaW5nYCZtZGFzaDsgQXBwbGllcyBjb2xvcmluZyBiYXNlZCBvbiB3YXJuaW5nIHRoZW1lIGNvbG9yLlxuICAgICAqICogYGVycm9yYCZtZGFzaDsgQXBwbGllcyBjb2xvcmluZyBiYXNlZCBvbiBlcnJvciB0aGVtZSBjb2xvci5cbiAgICAgKiAqIGBkYXJrYCZtZGFzaDsgQXBwbGllcyBjb2xvcmluZyBiYXNlZCBvbiBkYXJrIHRoZW1lIGNvbG9yLlxuICAgICAqICogYGxpZ2h0YCZtZGFzaDsgQXBwbGllcyBjb2xvcmluZyBiYXNlZCBvbiBsaWdodCB0aGVtZSBjb2xvci5cbiAgICAgKiAqIGBpbnZlcnNlYCZtZGFzaDsgQXBwbGllcyBjb2xvcmluZyBiYXNlZCBvbiBpbnZlcnRlZCB0aGVtZSBjb2xvci5cbiAgICAgKi9cbiAgICBzZXQgdGhlbWVDb2xvcih0aGVtZUNvbG9yKSB7XG4gICAgICAgIGlmICh0aGVtZUNvbG9yICE9PSB0aGlzLl90aGVtZUNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLl90aGVtZUNvbG9yID0gdGhlbWVDb2xvciA9PT0gbnVsbCA/IG51bGwgOiAodGhlbWVDb2xvciB8fCAncHJpbWFyeScpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVGaWxsTW9kZUFuZFRoZW1lQ29sb3JDbGFzc2VzKHRoaXMuZmlsbE1vZGUsIHRoaXMudGhlbWVDb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRoZW1lQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aGVtZUNvbG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGFwcGVhcmFuY2UgZmlsbCBzdHlsZSBvZiB0aGUgYXZhdGFyLlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgc29saWRgIChEZWZhdWx0KVxuICAgICAqICogYG91dGxpbmVgXG4gICAgICogKiBudWxsXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgZmlsbE1vZGUoZmlsbE1vZGUpIHtcbiAgICAgICAgaWYgKGZpbGxNb2RlICE9PSB0aGlzLmZpbGxNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsTW9kZSA9IGZpbGxNb2RlID09PSBudWxsID8gbnVsbCA6IChmaWxsTW9kZSB8fCAnc29saWQnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRmlsbE1vZGVBbmRUaGVtZUNvbG9yQ2xhc3Nlcyh0aGlzLmZpbGxNb2RlLCB0aGlzLnRoZW1lQ29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaWxsTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxNb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGFwcGVhcmFuY2UgZmlsbCBzdHlsZSBvZiB0aGUgYXZhdGFyLlxuICAgICAqIERlcHJlY2F0ZWQsIGxlZnQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGZpbGwoZmlsbE1vZGUpIHtcbiAgICAgICAgdGhpcy5maWxsTW9kZSA9IGZpbGxNb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGF2YXRhcldpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBhdmF0YXJIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5UHJvcGVydGllcygpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGNvbnN0IHN0eWxpbmdJbnB1dHMgPSBbJ3NpemUnLCAncm91bmRlZCddO1xuICAgICAgICBzdHlsaW5nSW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGFzc2VzKGlucHV0LCB0aGlzW2lucHV0XSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbmRsZUZpbGxNb2RlQW5kVGhlbWVDb2xvckNsYXNzZXModGhpcy5maWxsTW9kZSwgdGhpcy50aGVtZUNvbG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGljb25DbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5pY29uKSB7XG4gICAgICAgICAgICByZXR1cm4gYGstaWNvbiBrLWktJHt0aGlzLmljb259YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pY29uQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmljb25DbGFzc31gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY3VzdG9tQXZhdGFyKCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLmltYWdlU3JjIHx8IHRoaXMuaW5pdGlhbHMgfHwgdGhpcy5pY29uIHx8IHRoaXMuaWNvbkNsYXNzKTtcbiAgICB9XG4gICAgdmVyaWZ5UHJvcGVydGllcygpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IFt0aGlzLmljb24gfHwgdGhpcy5pY29uQ2xhc3MsIHRoaXMuaW1hZ2VTcmMsIHRoaXMuaW5pdGlhbHNdO1xuICAgICAgICBjb25zdCBpbnB1dHNMZW5ndGggPSBpbnB1dHMuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUpLmxlbmd0aDtcbiAgICAgICAgaWYgKGlucHV0c0xlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgICAgICAgICAgSW52YWxpZCBwcm9wZXJ0eSBjb25maWd1cmF0aW9uIGdpdmVuLlxuICAgICAgICAgICAgICAgIFRoZSBrZW5kby1hdmF0YXIgY29tcG9uZW50IGNhbiBhY2NlcHQgb25seSBvbmUgb2Y6XG4gICAgICAgICAgICAgICAgaWNvbiwgaW1hZ2VTcmMgb3IgaW5pdGlhbHMgcHJvcGVydGllcy5cbiAgICAgICAgICAgIGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNsYXNzZXMoc3R5bGVUeXBlLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBnZXRTdHlsaW5nQ2xhc3NlcygnYXZhdGFyJywgc3R5bGVUeXBlLCB0aGlzW3N0eWxlVHlwZV0sIHZhbHVlKTtcbiAgICAgICAgaWYgKGNsYXNzZXMudG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbSwgY2xhc3Nlcy50b1JlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzZXMudG9BZGQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbSwgY2xhc3Nlcy50b0FkZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRmlsbE1vZGVBbmRUaGVtZUNvbG9yQ2xhc3NlcyhmaWxsLCB0aGVtZUNvbG9yKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXJFbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZyBmaWxsIGFuZCB0aGVtZSBjb2xvciBjbGFzc2VzXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDbGFzc2VzID0gQXJyYXkuZnJvbSh3cmFwcGVyRWxlbWVudC5jbGFzc0xpc3QpO1xuICAgICAgICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBjdXJyZW50Q2xhc3Nlcy5maWx0ZXIoY2wgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNsLnN0YXJ0c1dpdGgoJ2stYXZhdGFyLXNvbGlkJykgfHwgY2wuc3RhcnRzV2l0aCgnay1hdmF0YXItb3V0bGluZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlLmZvckVhY2goKGNsID0+IHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3Mod3JhcHBlckVsZW1lbnQsIGNsKSkpO1xuICAgICAgICAvLyBhZGQgZmlsbCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKGZpbGwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3Mod3JhcHBlckVsZW1lbnQsIGBrLWF2YXRhci0ke2ZpbGx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRoZW1lIGNvbG9yIGNsYXNzIGlmIGZpbGwgYW5kIHRoZW1lIGNvbG9yXG4gICAgICAgIGlmIChmaWxsICE9PSBudWxsICYmIHRoZW1lQ29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3Mod3JhcHBlckVsZW1lbnQsIGBrLWF2YXRhci0ke2ZpbGx9LSR7dGhlbWVDb2xvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1hdmF0YXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEF2YXRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1hdmF0YXItYm9yZGVyZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQXZhdGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJib3JkZXJDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5mbGV4QmFzaXMnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBBdmF0YXJDb21wb25lbnQucHJvdG90eXBlLCBcImZsZXhCYXNpc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgQXZhdGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaGFwZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgQXZhdGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaXplXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBBdmF0YXJDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIEF2YXRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGhlbWVDb2xvclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgQXZhdGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsTW9kZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgQXZhdGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEF2YXRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBdmF0YXJDb21wb25lbnQucHJvdG90eXBlLCBcImljb25DbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXZhdGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLndpZHRoJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQXZhdGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhdmF0YXJXaWR0aFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF2YXRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnc3R5bGUuaGVpZ2h0JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQXZhdGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhdmF0YXJIZWlnaHRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBdmF0YXJDb21wb25lbnQucHJvdG90eXBlLCBcImNzc1N0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBdmF0YXJDb21wb25lbnQucHJvdG90eXBlLCBcImluaXRpYWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBdmF0YXJDb21wb25lbnQucHJvdG90eXBlLCBcImljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF2YXRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW1hZ2VTcmNcIiwgdm9pZCAwKTtcbkF2YXRhckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tYXZhdGFyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgKm5nSWY9XCJjdXN0b21BdmF0YXJcIj48L25nLWNvbnRlbnQ+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImltYWdlU3JjXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstYXZhdGFyLWltYWdlXCI+XG4gICAgICAgICAgICAgICAgPGltZyBzcmM9XCJ7e2ltYWdlU3JjfX1cIiBbbmdTdHlsZV09XCJjc3NTdHlsZVwiIC8+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJpbml0aWFsc1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWF2YXRhci10ZXh0XCIgW25nU3R5bGVdPVwiY3NzU3R5bGVcIj57eyBpbml0aWFscy5zdWJzdHJpbmcoMCwgMikgfX08L3NwYW4+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJpY29uIHx8IGljb25DbGFzc1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWF2YXRhci1pY29uXCIgW25nU3R5bGVdPVwiY3NzU3R5bGVcIiBbbmdDbGFzc109XCJpY29uQ2xhc3NlcygpXCI+PC9zcGFuPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtSZW5kZXJlcjIsIEVsZW1lbnRSZWZdKVxuXSwgQXZhdGFyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgQ2FyZCBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfY2FyZCAlfSlcbiAqL1xubGV0IENhcmRDb21wb25lbnQgPSBjbGFzcyBDYXJkQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbGF5b3V0IG9mIHRoZSBDYXJkIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgdmVydGljYWxgXG4gICAgICAgICAqICogYGhvcml6b250YWxgXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIHdpZHRoIG9mIHRoZSBDYXJkLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgMjg1cHhgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9ICcyODVweCc7XG4gICAgICAgIHRoaXMucnRsID0gZmFsc2U7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMucnRsID0gcnRsO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgd2lkdGhTdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIGdldCB2ZXJ0aWNhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCc7XG4gICAgfVxuICAgIGdldCBob3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstd2lkZ2V0JyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY2FyZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnc3R5bGUud2lkdGgnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFN0eWxlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY2FyZC12ZXJ0aWNhbCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWNhcmQtaG9yaXpvbnRhbCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3Jpem9udGFsXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwib3JpZW50YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XG5DYXJkQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYXJkJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uY2FyZC5jb21wb25lbnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIENhcmRDb21wb25lbnQpO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgY29udGVudCBpbiB0aGUgQ2FyZCBoZWFkZXIuXG4gKi9cbmxldCBDYXJkSGVhZGVyQ29tcG9uZW50ID0gY2xhc3MgQ2FyZEhlYWRlckNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBjb250ZW50IGluIHRoZSBDYXJkIGhlYWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jYXJkLWhlYWRlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2FyZEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5DYXJkSGVhZGVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYXJkLWhlYWRlcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgXG4gICAgfSlcbl0sIENhcmRIZWFkZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgY29udGVudCBpbiB0aGUgQ2FyZCBib2R5LlxuICovXG5sZXQgQ2FyZEJvZHlDb21wb25lbnQgPSBjbGFzcyBDYXJkQm9keUNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBjb250ZW50IGluIHRoZSBDYXJkIGJvZHkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY2FyZC1ib2R5JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXJkQm9keUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5DYXJkQm9keUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2FyZC1ib2R5JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGBcbiAgICB9KVxuXSwgQ2FyZEJvZHlDb21wb25lbnQpO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgY29udGVudCBpbiB0aGUgQ2FyZCBmb290ZXIuXG4gKi9cbmxldCBDYXJkRm9vdGVyQ29tcG9uZW50ID0gY2xhc3MgQ2FyZEZvb3RlckNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBjb250ZW50IGluIHRoZSBDYXJkIGZvb3Rlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jYXJkLWZvb3RlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2FyZEZvb3RlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5DYXJkRm9vdGVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYXJkLWZvb3RlcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgXG4gICAgfSlcbl0sIENhcmRGb290ZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYWN0aW9uIGJ1dHRvbnMgb2YgdGhlIENhcmQuXG4gKiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYWN0aW9uc19jYXJkICV9KSkuXG4gKi9cbmxldCBDYXJkQWN0aW9uc0NvbXBvbmVudCA9IGNsYXNzIENhcmRBY3Rpb25zQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGFjdGlvbiBidXR0b25zIG9mIHRoZSBDYXJkLlxuICAgICAqICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhY3Rpb25zX2NhcmQgJX0pKS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBsYXlvdXQgb2YgdGhlIENhcmQgYWN0aW9uIGJ1dHRvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICogKERlZmF1bHQpIGBob3Jpem9udGFsYFxuICAgICAgICAgKiAqIGB2ZXJ0aWNhbGBcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGxheW91dCBvZiB0aGUgQ2FyZCBhY3Rpb24gYnV0dG9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICogKERlZmF1bHQpIGBzdGFydGBcbiAgICAgICAgICogKiBgY2VudGVyYFxuICAgICAgICAgKiAqIGBlbmRgXG4gICAgICAgICAqICogYHN0cmV0Y2hlZGBcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGF5b3V0ID0gJ3N0YXJ0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGFuIGFjdGlvbiBidXR0b24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGlvbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IHN0cmV0Y2hlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQgPT09ICdzdHJldGNoZWQnO1xuICAgIH1cbiAgICBnZXQgc3RhcnRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0ID09PSAnc3RhcnQnO1xuICAgIH1cbiAgICBnZXQgZW5kQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dCA9PT0gJ2VuZCc7XG4gICAgfVxuICAgIGdldCBjZW50ZXJDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0ID09PSAnY2VudGVyJztcbiAgICB9XG4gICAgZ2V0IHZlcnRpY2FsQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnO1xuICAgIH1cbiAgICBnZXQgaG9yaXpvbnRhbENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25DbGljayhhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5hY3Rpb24uZW1pdChhY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgYWN0aW9uVGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnMgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY2FyZC1hY3Rpb25zJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXJkQWN0aW9uc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jYXJkLWFjdGlvbnMtc3RyZXRjaGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIENhcmRBY3Rpb25zQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdHJldGNoZWRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWNhcmQtYWN0aW9ucy1zdGFydCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDYXJkQWN0aW9uc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWNhcmQtYWN0aW9ucy1lbmQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ2FyZEFjdGlvbnNDb21wb25lbnQucHJvdG90eXBlLCBcImVuZENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY2FyZC1hY3Rpb25zLWNlbnRlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDYXJkQWN0aW9uc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VudGVyQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jYXJkLWFjdGlvbnMtdmVydGljYWwnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ2FyZEFjdGlvbnNDb21wb25lbnQucHJvdG90eXBlLCBcInZlcnRpY2FsQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jYXJkLWFjdGlvbnMtaG9yaXpvbnRhbCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDYXJkQWN0aW9uc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9yaXpvbnRhbENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2FyZEFjdGlvbnNDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXJkQWN0aW9uc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibGF5b3V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXJkQWN0aW9uc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENhcmRBY3Rpb25zQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3Rpb25cIiwgdm9pZCAwKTtcbkNhcmRBY3Rpb25zQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYXJkLWFjdGlvbnMnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudCAqbmdJZj1cIiFhY3Rpb25zXCI+PC9uZy1jb250ZW50PlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhYWN0aW9uVGVtcGxhdGUoKVwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1wcmltYXJ5XT1cImFjdGlvbi5wcmltYXJ5XCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1mbGF0XT1cImFjdGlvbi5mbGF0XCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwib25DbGljayhhY3Rpb24pXCJcbiAgICAgICAgICAgICAgICAqbmdGb3I9XCJsZXQgYWN0aW9uIG9mIGFjdGlvbnNcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHt7IGFjdGlvbi50ZXh0IH19XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImFjdGlvbnNcIiAqbmdJZj1cImFjdGlvblRlbXBsYXRlKClcIj48L25nLXRlbXBsYXRlPlxuICAgIGBcbiAgICB9KVxuXSwgQ2FyZEFjdGlvbnNDb21wb25lbnQpO1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIHNlcGFyYXRvciBpbiB0aGUgY29udGVudCBvZiB0aGUgQ2FyZC5cbiAqL1xubGV0IENhcmRTZXBhcmF0b3JEaXJlY3RpdmUgPSBjbGFzcyBDYXJkU2VwYXJhdG9yRGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgYSBzZXBhcmF0b3IgaW4gdGhlIGNvbnRlbnQgb2YgdGhlIENhcmQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgb3JpZW50YXRpb24gb2YgdGhlIENhcmQgc2VwYXJhdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKERlZmF1bHQpIGBob3Jpem9udGFsYFxuICAgICAgICAgKiBgdmVydGljYWxgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICBnZXQgdmVydGljYWxDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCc7XG4gICAgfVxuICAgIGdldCBob3Jpem9udGFsQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWNhcmQtc2VwYXJhdG9yJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXJkU2VwYXJhdG9yRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJob3N0Q2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXNlcGFyYXRvci12ZXJ0aWNhbCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDYXJkU2VwYXJhdG9yRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc2VwYXJhdG9yLWhvcml6b250YWwnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ2FyZFNlcGFyYXRvckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaG9yaXpvbnRhbENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLmNvbG9yJyksXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2FyZFNlcGFyYXRvckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhcmRTZXBhcmF0b3JEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XG5DYXJkU2VwYXJhdG9yRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DYXJkU2VwYXJhdG9yXSdcbiAgICB9KVxuXSwgQ2FyZFNlcGFyYXRvckRpcmVjdGl2ZSk7XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSB0ZXh0IGFuZCBzdHlsZXMgZm9yIHRoZSB0aXRsZSBvZiB0aGUgQ2FyZC5cbiAqL1xubGV0IENhcmRUaXRsZURpcmVjdGl2ZSA9IGNsYXNzIENhcmRUaXRsZURpcmVjdGl2ZSB7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSB0ZXh0IGFuZCBzdHlsZXMgZm9yIHRoZSB0aXRsZSBvZiB0aGUgQ2FyZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jYXJkLXRpdGxlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXJkVGl0bGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhvc3RDbGFzc1wiLCB2b2lkIDApO1xuQ2FyZFRpdGxlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DYXJkVGl0bGVdJ1xuICAgIH0pXG5dLCBDYXJkVGl0bGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgdGV4dCBhbmQgc3R5bGVzIGZvciB0aGUgc3VidGl0bGUgb2YgdGhlIENhcmQuXG4gKi9cbmxldCBDYXJkU3VidGl0bGVEaXJlY3RpdmUgPSBjbGFzcyBDYXJkU3VidGl0bGVEaXJlY3RpdmUge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgdGV4dCBhbmQgc3R5bGVzIGZvciB0aGUgc3VidGl0bGUgb2YgdGhlIENhcmQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY2FyZC1zdWJ0aXRsZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2FyZFN1YnRpdGxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJob3N0Q2xhc3NcIiwgdm9pZCAwKTtcbkNhcmRTdWJ0aXRsZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2FyZFN1YnRpdGxlXSdcbiAgICB9KVxuXSwgQ2FyZFN1YnRpdGxlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYW55IG1lZGlhIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgYW5kIGFsaWduZWQgaW4gdGhlIENhcmQuXG4gKi9cbmxldCBDYXJkTWVkaWFEaXJlY3RpdmUgPSBjbGFzcyBDYXJkTWVkaWFEaXJlY3RpdmUge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBhbnkgbWVkaWEgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBhbmQgYWxpZ25lZCBpbiB0aGUgQ2FyZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jYXJkLW1lZGlhJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXJkTWVkaWFEaXJlY3RpdmUucHJvdG90eXBlLCBcImhvc3RDbGFzc1wiLCB2b2lkIDApO1xuQ2FyZE1lZGlhRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DYXJkTWVkaWFdJ1xuICAgIH0pXG5dLCBDYXJkTWVkaWFEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFRoZSBzZXR0aW5ncyBvZiB0aGUgQ2FyZCBhY3Rpb24gYnV0dG9ucy5cbiAqL1xuY2xhc3MgQ2FyZEFjdGlvbiB7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRlbXBsYXRlIHRoYXQgZGVmaW5lcyB0aGUgY29udGVudCBvZiB0aGUgRXhwYW5zaW9uUGFuZWwgdGl0bGUuXG4gKiBUbyBkZWZpbmUgdGhlIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWdcbiAqIHdpdGggdGhlIGBrZW5kb0V4cGFuc2lvblBhbmVsVGl0bGVEaXJlY3RpdmVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGA8a2VuZG8tZXhwYW5zaW9ucGFuZWw+YCB0YWcuXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRpdGxlX2V4cGFuc2lvbnBhbmVsICV9I3RvYy10aXRsZS10ZW1wbGF0ZSkpLlxuICovXG5sZXQgRXhwYW5zaW9uUGFuZWxUaXRsZURpcmVjdGl2ZSA9IGNsYXNzIEV4cGFuc2lvblBhbmVsVGl0bGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuRXhwYW5zaW9uUGFuZWxUaXRsZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRXhwYW5zaW9uUGFuZWxUaXRsZURpcmVjdGl2ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIEV4cGFuc2lvblBhbmVsVGl0bGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZXhwYW5kKGR1cmF0aW9uLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdHlsZSh7IG92ZXJmbG93OiAnaGlkZGVuJywgZGlzcGxheTogJ2Jsb2NrJywgaGVpZ2h0OiAwIH0pLFxuICAgICAgICBhbmltYXRlKGAke2R1cmF0aW9ufW1zIGVhc2UtaW5gLCBzdHlsZSh7IGhlaWdodDogYCR7aGVpZ2h0fWAgfSkpXG4gICAgXTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBjb2xsYXBzZShkdXJhdGlvbiwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIGhlaWdodDogYCR7aGVpZ2h0fWAgfSksXG4gICAgICAgIGFuaW1hdGUoYCR7ZHVyYXRpb259bXMgZWFzZS1pbmAsIHN0eWxlKHsgb3ZlcmZsb3c6ICdoaWRkZW4nLCBoZWlnaHQ6IDAgfSkpXG4gICAgXTtcbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgYWN0aW9uYCBldmVudCBvZiB0aGUgRXhwYW5zaW9uUGFuZWwuXG4gKi9cbmNsYXNzIEV4cGFuc2lvblBhbmVsQWN0aW9uRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50JDEge1xufVxuXG5jb25zdCBERUZBVUxUX0RVUkFUSU9OID0gMjAwO1xuY29uc3QgQ09OVEVOVF9ISURERU5fQ0xBU1MgPSAnay1oaWRkZW4nO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgRXhwYW5zaW9uUGFuZWwgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2V4cGFuc2lvbnBhbmVsICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tZXhwYW5zaW9ucGFuZWwgdGl0bGU9XCJDaGlsZVwiIHN1YnRpdGxlPVwiU291dGggQW1lcmljYVwiPlxuICogICAgICAgICAgICAgIFRoZXJlIGFyZSB2YXJpb3VzIHRoZW9yaWVzIGFib3V0IHRoZSBvcmlnaW4gb2YgdGhlIHdvcmQgQ2hpbGUuXG4gKiAgICAgICAgPC9rZW5kby1leHBhbnNpb25wYW5lbD5cbiAqICAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge31cbiAqIGBgYFxuICovXG5sZXQgRXhwYW5zaW9uUGFuZWxDb21wb25lbnQgPSBjbGFzcyBFeHBhbnNpb25QYW5lbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGhvc3RFbGVtZW50LCBuZ1pvbmUsIGxvY2FsaXphdGlvblNlcnZpY2UsIGJ1aWxkZXIpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBwcmltYXJ5IHRleHQgaW4gdGhlIGhlYWRlciBvZiB0aGUgRXhwYW5zaW9uUGFuZWxcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0aXRsZV9leHBhbnNpb25wYW5lbCAlfSN0b2MtdGl0bGUtYW5kLXN1YnRpdGxlKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpdGxlID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHNlY29uZGFyeSB0ZXh0IGluIHRoZSBoZWFkZXIgb2YgdGhlIEV4cGFuc2lvblBhbmVsLCB3aGljaCBpcyByZW5kZXJlZCBuZXh0IHRvIHRoZSBjb2xsYXBzZS9leHBhbmQgaWNvblxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRpdGxlX2V4cGFuc2lvbnBhbmVsICV9I3RvYy10aXRsZS1hbmQtc3VidGl0bGUpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VidGl0bGUgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBFeHBhbnNpb25QYW5lbCBpcyBkaXNhYmxlZC4gSWYgZGlzYWJsZWQsIHRoZSBFeHBhbnNpb25QYW5lbCBjYW4gYmUgbmVpdGhlciBleHBhbmRlZCBub3IgY29sbGFwc2VkXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGlzYWJsZWRfZXhwYW5zaW9ucGFuZWwgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgYW5pbWF0aW9uIHNldHRpbmdzIG9mIHRoZSBFeHBhbnNpb25QYW5lbFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFuaW1hdGlvbnNfZXhwYW5zaW9ucGFuZWwgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICogQm9vbGVhblxuICAgICAgICAgKiAgICAqIChEZWZhdWx0KSBgdHJ1ZWAgTnVtZXJpYyB2YWx1ZXMgcmVwcmVzZW50IGR1cmF0aW9uLiBEZWZhdWx0IGR1cmF0aW9uIGlzIDIwMG1zLlxuICAgICAgICAgKiAgICAqIGZhbHNlXG4gICAgICAgICAqICogTnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBgZXhwYW5kZWRgIHByb3BlcnR5IG9mIHRoZSBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICAgICAgICogVXNlZCB0byBwcm92aWRlIGEgdHdvLXdheSBiaW5kaW5nIGZvciB0aGUgYGV4cGFuZGVkYCBwcm9wZXJ0eVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2V4cGFuc2lvbnBhbmVsICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgRXhwYW5zaW9uUGFuZWwgaXMgYWJvdXQgdG8gY2hhbmdlLiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfZXhwYW5zaW9ucGFuZWwgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3Rpb24gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBFeHBhbnNpb25QYW5lbCBpcyBleHBhbmRlZC4gSWYgdGhlcmUgaXMgYW5pbWF0aW9uIGl0IHdpbGwgZmlyZSB3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19leHBhbnNpb25wYW5lbCAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIEV4cGFuc2lvblBhbmVsIGlzIGNvbGxhcHNlZC4gSWYgdGhlcmUgaXMgYW5pbWF0aW9uIGl0IHdpbGwgZmlyZSB3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19leHBhbnNpb25wYW5lbCAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxhcHNlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRW5kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuX2V4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGxvY2FsaXphdGlvblNlcnZpY2UucnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdGhlIEV4cGFuc2lvblBhbmVsIGlzIGV4cGFuZGVkLiBUaGUgcHJvcGVydHkgc3VwcG9ydHMgdHdvLXdheSBiaW5kaW5nLlxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaW50ZXJhY3Rpb25fZXhwYW5zaW9ucGFuZWwgJX0jdG9jLXNldHRpbmctdGhlLWluaXRpYWwtc3RhdGUpKS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgc2V0IGV4cGFuZGVkKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V4cGFuZGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNvbnRlbnRIaWRkZW5DbGFzcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRDb250ZW50SGlkZGVuQ2xhc3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZXhwYW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbmRlZDtcbiAgICB9XG4gICAgZ2V0IGV4cGFuZGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuZGVkICYmICF0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICBnZXQgZm9jdXNDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNlZDtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25Db21wb25lbnRCbHVyKCkge1xuICAgICAgICBpZiAodGhpcy5mb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25Db21wb25lbnRGb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3RpdGxlJyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4geyB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7IH0pO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdERvbUV2ZW50cygpO1xuICAgICAgICBpZiAoIXRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5jb250ZW50Lm5hdGl2ZUVsZW1lbnQsIENPTlRFTlRfSElEREVOX0NMQVNTKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpbml0RG9tRXZlbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4obmF0aXZlRWxlbWVudCwgJ2tleWRvd24nLCB0aGlzLmtleURvd25IYW5kbGVyLmJpbmQodGhpcykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBrZXlEb3duSGFuZGxlcihldikge1xuICAgICAgICBjb25zdCBpc0VudGVyT3JTcGFjZSA9IGV2LmtleUNvZGUgPT09IEtleXMuRW50ZXIgfHwgZXYua2V5Q29kZSA9PT0gS2V5cy5TcGFjZTtcbiAgICAgICAgaWYgKCFpc0VudGVyT3JTcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDbGFzcyhldi50YXJnZXQsICdrLWV4cGFuZGVyJykpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25IZWFkZXJBY3Rpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkhlYWRlckNsaWNrKGV2KSB7XG4gICAgICAgIGlmICghaXNGb2N1c2FibGUoZXYudGFyZ2V0KSAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5vbkhlYWRlckFjdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkhlYWRlckFjdGlvbigpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzID0gbmV3IEV4cGFuc2lvblBhbmVsQWN0aW9uRXZlbnQoKTtcbiAgICAgICAgZXZlbnRBcmdzLmFjdGlvbiA9IHRoaXMuZXhwYW5kZWQgPyAnY29sbGFwc2UnIDogJ2V4cGFuZCc7XG4gICAgICAgIHRoaXMuYWN0aW9uLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgaWYgKCFldmVudEFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXhwYW5kZWQoIXRoaXMuZXhwYW5kZWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbnRlbnRIaWRkZW5DbGFzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlQ29udGVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29udGVudEhpZGRlbkNsYXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXRFeHBhbmRDb2xsYXBzZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpbmRpY2F0b3JDbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sbGFwc2VJY29uID8gdGhpcy5jb2xsYXBzZUljb24gOiBgay1pY29uIGstaS1hcnJvdy1jaGV2cm9uLXVwYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZEljb24gPyB0aGlzLmV4cGFuZEljb24gOiBgay1pY29uIGstaS1hcnJvdy1jaGV2cm9uLWRvd25gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIEV4cGFuc2lvblBhbmVsXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBpbnRlcmFjdGlvbl9leHBhbnNpb25wYW5lbCAlfSN0b2MtdG9nZ2xpbmctdGhlLWNvbnRlbnQpKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHBhbmRlZD8gLSBCb29sZWFuLiBTcGVjaWZpZXMsIHdoZXRoZXIgdGhlIEV4cGFuc2lvblBhbmVsIHdpbGwgYmUgZXhwYW5kZWQgb3IgY29sbGFwc2VkLlxuICAgICAqL1xuICAgIHRvZ2dsZShleHBhbmRlZCkge1xuICAgICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuZXhwYW5kZWQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBpc1ByZXNlbnQoZXhwYW5kZWQpID8gZXhwYW5kZWQgOiAhcHJldmlvdXM7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBwcmV2aW91cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RXhwYW5kZWQoY3VycmVudCk7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNvbnRlbnRIaWRkZW5DbGFzcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlQ29udGVudCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGRDb250ZW50SGlkZGVuQ2xhc3MoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRFeHBhbmRDb2xsYXBzZUV2ZW50KCk7XG4gICAgfVxuICAgIHNldEV4cGFuZGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuZGVkID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgfVxuICAgIGFuaW1hdGVDb250ZW50KCkge1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IHR5cGVvZiB0aGlzLmFuaW1hdGlvbiA9PT0gJ2Jvb2xlYW4nID8gREVGQVVMVF9EVVJBVElPTiA6IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICBjb25zdCBjb250ZW50SGVpZ2h0ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmNvbnRlbnQubmF0aXZlRWxlbWVudCkuaGVpZ2h0O1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLmV4cGFuZGVkID8gZXhwYW5kKGR1cmF0aW9uLCBjb250ZW50SGVpZ2h0KSA6IGNvbGxhcHNlKGR1cmF0aW9uLCBjb250ZW50SGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5jcmVhdGVQbGF5ZXIoYW5pbWF0aW9uLCB0aGlzLmNvbnRlbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRW5kLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29udGVudEhpZGRlbkNsYXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXRFeHBhbmRDb2xsYXBzZUV2ZW50KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwbGF5ZXIucGxheSgpO1xuICAgIH1cbiAgICBjcmVhdGVQbGF5ZXIoYW5pbWF0aW9uLCBhbmltYXRlZEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuYnVpbGRlci5idWlsZChhbmltYXRpb24pO1xuICAgICAgICBsZXQgcGxheWVyID0gZmFjdG9yeS5jcmVhdGUoYW5pbWF0ZWRFbGVtZW50KTtcbiAgICAgICAgcGxheWVyLm9uRG9uZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25FbmQuZW1pdCgpO1xuICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfVxuICAgIGVtaXRFeHBhbmRDb2xsYXBzZUV2ZW50KCkge1xuICAgICAgICB0aGlzW3RoaXMuZXhwYW5kZWQgPyAnZXhwYW5kJyA6ICdjb2xsYXBzZSddLmVtaXQoKTtcbiAgICB9XG4gICAgYWRkQ29udGVudEhpZGRlbkNsYXNzKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuY29udGVudC5uYXRpdmVFbGVtZW50LCBDT05URU5UX0hJRERFTl9DTEFTUyk7XG4gICAgfVxuICAgIHJlbW92ZUNvbnRlbnRIaWRkZW5DbGFzcygpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmNvbnRlbnQubmF0aXZlRWxlbWVudCwgQ09OVEVOVF9ISURERU5fQ0xBU1MpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBFeHBhbnNpb25QYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEV4cGFuc2lvblBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdWJ0aXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEV4cGFuc2lvblBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIEV4cGFuc2lvblBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBhbmRlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEV4cGFuc2lvblBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBhbmRJY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBFeHBhbnNpb25QYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sbGFwc2VJY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBFeHBhbnNpb25QYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRXhwYW5zaW9uUGFuZWxDb21wb25lbnQucHJvdG90eXBlLCBcImV4cGFuZGVkQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRXhwYW5zaW9uUGFuZWxDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEV4cGFuc2lvblBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBhbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBFeHBhbnNpb25QYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sbGFwc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChFeHBhbnNpb25QYW5lbFRpdGxlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV4cGFuc2lvblBhbmVsVGl0bGVEaXJlY3RpdmUpXG5dLCBFeHBhbnNpb25QYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwidGl0bGVUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdjb250ZW50JywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBFeHBhbnNpb25QYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZXhwYW5kZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEV4cGFuc2lvblBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0Q2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZXhwYW5kZWQnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1leHBhbmRlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBFeHBhbnNpb25QYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kZWRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXN0YXRlLWZvY3VzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEV4cGFuc2lvblBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c0NsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1kaXNhYmxlZCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXN0YXRlLWRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEV4cGFuc2lvblBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEV4cGFuc2lvblBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEV4cGFuc2lvblBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdibHVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBFeHBhbnNpb25QYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwib25Db21wb25lbnRCbHVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdmb2N1cycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgRXhwYW5zaW9uUGFuZWxDb21wb25lbnQucHJvdG90eXBlLCBcIm9uQ29tcG9uZW50Rm9jdXNcIiwgbnVsbCk7XG5FeHBhbnNpb25QYW5lbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9FeHBhbnNpb25QYW5lbCcsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmV4cGFuc2lvbnBhbmVsJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWV4cGFuc2lvbnBhbmVsJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgW2NsYXNzLmstZXhwYW5kZXItaGVhZGVyXT1cInRydWVcIlxuICAgICAgICAgICAgKGNsaWNrKT1cIm9uSGVhZGVyQ2xpY2soJGV2ZW50KVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiF0aXRsZVRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cInRpdGxlXCIgY2xhc3M9XCJrLWV4cGFuZGVyLXRpdGxlXCI+e3sgdGl0bGUgfX08L2Rpdj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstc3BhY2VyXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJzdWJ0aXRsZVwiIGNsYXNzPVwiay1leHBhbmRlci1zdWItdGl0bGVcIj5cbiAgICAgICAgICAgICAgICAgICAge3sgc3VidGl0bGUgfX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJ0aXRsZVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJ0aXRsZVRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1leHBhbmRlci1pbmRpY2F0b3JcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBbbmdDbGFzc109XCJpbmRpY2F0b3JDbGFzc2VzXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiAjY29udGVudCBjbGFzcz1cImstZXhwYW5kZXItY29udGVudC13cmFwcGVyXCI+XG4gICAgICAgICAgICA8ZGl2ICBjbGFzcz1cImstZXhwYW5kZXItY29udGVudFwiIFthdHRyLmFyaWEtaGlkZGVuXT1cIiFleHBhbmRlZFwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtSZW5kZXJlcjIsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgQW5pbWF0aW9uQnVpbGRlcl0pXG5dLCBFeHBhbnNpb25QYW5lbENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub3JtYWxpemVWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSA/ICt2YWx1ZSA6IHVuZGVmaW5lZDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNSb3dJdGVtUHJlc2VudCA9IChpdGVtcykgPT4ge1xuICAgIHJldHVybiBpdGVtcy5zb21lKGl0ZW0gPT4gaXNQcmVzZW50KGl0ZW0ucm93KSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHByb3BzQ2hhbmdlZCA9IChpbml0aWFsUHJvcHMsIG5ld1Byb3BzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbml0aWFsUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluaXRpYWxQcm9wc1tpXSAhPT0gbmV3UHJvcHNbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBFeHRyYWN0cyB0aGUgZXZlbnQgdGFyZ2V0IGZyb20gdGhlIHZpZXdwb3J0IGNvb3Jkcy4gUmVxdWlyZWQgZm9yIHRvdWNoIGRldmljZXNcbiAqIHdoZXJlIHRoZSBgZXZlbnQudGFyZ2V0YCBvZiBhIGBwb2ludGVybW92ZWAgZXZlbnQgaXMgYWx3YXlzIHRoZSBpbml0aWFsbHkgZHJhZ2dlZCBpdGVtLlxuICovXG5jb25zdCBnZXREcm9wVGFyZ2V0ID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCEoaXNEb2N1bWVudEF2YWlsYWJsZSgpICYmIGlzUHJlc2VudChkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludCkpKSB7XG4gICAgICAgIHJldHVybiBbZXZlbnQudGFyZ2V0XTtcbiAgICB9XG4gICAgcmV0dXJuIGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmNsYXNzTGlzdCAmJiAoaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2stdGlsZWxheW91dC1pdGVtJykgfHwgaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2stbGF5b3V0LWl0ZW0taGludCcpKSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNldEVsZW1lbnRTdHlsZXMgPSAocmVuZGVyZXIsIGVsZW0sIHN0eWxlcykgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoc3R5bGVzKTtcbiAgICBwcm9wcy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICByZW5kZXJlci5zZXRTdHlsZShlbGVtLCBwLCBzdHlsZXNbcF0pO1xuICAgIH0pO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjYWxjdWxhdGVDZWxsRnJvbVBvc2l0aW9uID0gKGNvb3JkaW5hdGVzLCB0aWxlTGF5b3V0RWxlbWVudCwgZ2FwLCBjZWxsU2l6ZSwgY29sdW1ucywgcnRsID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB0aWxlTGF5b3V0UmVjdCA9IHRpbGVMYXlvdXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHRvdGFsUm93cyA9ICh0aWxlTGF5b3V0UmVjdC5oZWlnaHQgLSBnYXAucm93cykgLyAoY2VsbFNpemUuaGVpZ2h0ICsgZ2FwLnJvd3MpO1xuICAgIGNvbnN0IGRpc3RhbmNlRnJvbVRvcCA9IGNvb3JkaW5hdGVzLnkgLSB0aWxlTGF5b3V0UmVjdC55O1xuICAgIGNvbnN0IGRpc3RhbmNlRnJvbUxlZnQgPSBjb29yZGluYXRlcy54IC0gdGlsZUxheW91dFJlY3QueDtcbiAgICBjb25zdCBkaXN0YW5jZUZyb21SaWdodCA9IHRpbGVMYXlvdXRSZWN0LnJpZ2h0IC0gY29vcmRpbmF0ZXMueDtcbiAgICBjb25zdCBkaXN0YW5jZVRvQ2VsbFdpZHRoUmF0aW8gPSBNYXRoLmZsb29yKChydGwgPyBkaXN0YW5jZUZyb21SaWdodCA6IGRpc3RhbmNlRnJvbUxlZnQpIC8gKGdhcC5jb2x1bW5zICsgY2VsbFNpemUud2lkdGgpKTtcbiAgICBjb25zdCBjYXBwZWRDb2x1bW5Qb3NpdGlvbiA9IE1hdGgubWluKGRpc3RhbmNlVG9DZWxsV2lkdGhSYXRpbyArIDEsIGNvbHVtbnMpO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9DZWxsSGVpZ2h0UmF0aW8gPSBNYXRoLmZsb29yKGRpc3RhbmNlRnJvbVRvcCAvIChnYXAucm93cyArIGNlbGxTaXplLmhlaWdodCkpO1xuICAgIGNvbnN0IGNhcHBlZFJvd1Bvc2l0aW9uID0gTWF0aC5taW4oZGlzdGFuY2VUb0NlbGxIZWlnaHRSYXRpbyArIDEsIHRvdGFsUm93cyk7XG4gICAgY29uc3QgY29sID0gTWF0aC5tYXgoY2FwcGVkQ29sdW1uUG9zaXRpb24sIDApO1xuICAgIGNvbnN0IHJvdyA9IE1hdGgubWF4KGNhcHBlZFJvd1Bvc2l0aW9uLCAwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByb3csIGNvbFxuICAgIH07XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUkVTSVpFX0hBTkRMRV9VTklESVJFQ1RJT05BTF9TSVpFID0gOTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBSRVNJWkVfSEFORExFX0JJRElSRUNUSU9OQUxfU0laRSA9IDI1O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFJFU0laRV9IQU5ETEVfVU5JRElSRUNUSU9OQUxfT1ZFUkxBUCA9IDU7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUkVTSVpFX0hBTkRMRV9CSURJUkVDVElPTkFMX09WRVJMQVAgPSAxODtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBEUkFHR0VEX1pJTkRFWCA9IDEwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFJFU0laRV9ESVJFQ1RJT05TID0gWydldycsICducycsICdud3NlJ107XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUlRMX1JFU0laRV9ESVJFQ1RJT05TID0gWydldycsICducycsICduZXN3J107XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUkVTSVpFX0hBTkRMRV9ESU1FTlNJT05TID0ge1xuICAgIC8vIG51bWVyaWMgdmFsdWVzIHJlcHJlc2VudCBwaXhlbHNcbiAgICBldzoge1xuICAgICAgICB3aWR0aDogUkVTSVpFX0hBTkRMRV9VTklESVJFQ1RJT05BTF9TSVpFLFxuICAgICAgICBvdmVybGFwWDogUkVTSVpFX0hBTkRMRV9VTklESVJFQ1RJT05BTF9PVkVSTEFQXG4gICAgfSxcbiAgICBuczoge1xuICAgICAgICBoZWlnaHQ6IFJFU0laRV9IQU5ETEVfVU5JRElSRUNUSU9OQUxfU0laRSxcbiAgICAgICAgb3ZlcmxhcFk6IFJFU0laRV9IQU5ETEVfVU5JRElSRUNUSU9OQUxfT1ZFUkxBUFxuICAgIH0sXG4gICAgbndzZToge1xuICAgICAgICB3aWR0aDogUkVTSVpFX0hBTkRMRV9CSURJUkVDVElPTkFMX1NJWkUsXG4gICAgICAgIGhlaWdodDogUkVTSVpFX0hBTkRMRV9CSURJUkVDVElPTkFMX1NJWkUsXG4gICAgICAgIG92ZXJsYXBYOiBSRVNJWkVfSEFORExFX0JJRElSRUNUSU9OQUxfT1ZFUkxBUCxcbiAgICAgICAgb3ZlcmxhcFk6IFJFU0laRV9IQU5ETEVfQklESVJFQ1RJT05BTF9PVkVSTEFQXG4gICAgfSxcbiAgICBuZXN3OiB7XG4gICAgICAgIHdpZHRoOiBSRVNJWkVfSEFORExFX0JJRElSRUNUSU9OQUxfU0laRSxcbiAgICAgICAgaGVpZ2h0OiBSRVNJWkVfSEFORExFX0JJRElSRUNUSU9OQUxfU0laRSxcbiAgICAgICAgb3ZlcmxhcFg6IFJFU0laRV9IQU5ETEVfQklESVJFQ1RJT05BTF9PVkVSTEFQLFxuICAgICAgICBvdmVybGFwWTogUkVTSVpFX0hBTkRMRV9CSURJUkVDVElPTkFMX09WRVJMQVBcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE9WRVJMQVBfVEhSRVNIT0xEID0gMC4zO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFJFVkVSU0VfT1ZFUkxBUF9USFJFU0hPTEQgPSAtMC43O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEhJTlRfQk9SREVSU19IRUlHSFQgPSAyO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUHJldmVudGFibGVFdmVudCQyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3NlcyB0aGUgYnVpbHQtaW4gYmVoYXZpb3IgdGhhdCBmb2xsb3dzIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgcHJldmVudGVkIGJ5IGFueSBvZiBpdHMgc3Vic2NyaWJlcnMsIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBkZWZhdWx0IGFjdGlvbiB3YXMgcHJldmVudGVkLiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHJlb3JkZXJgIGV2ZW50LiBUaGUgZXZlbnQgZmlyZXMgd2hlbiB0aGUgb3JkZXIgb3Igc3RhcnRpbmdcbiAqIHBvc2l0aW9ucyBvZiB0aGUgaXRlbXMgaXMgY2hhbmdlZCB2aWEgdGhlIFVJLiBJZiB5b3UgcHJldmVudCB0aGUgZXZlbnQsIHRoZSBjaGFuZ2UgaXMgY2FuY2VsZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZW9yZGVyaW5nX3RpbGVsYXlvdXQgJX0jdG9jLWhhbmRsaW5nLXRoZS1yZW9yZGVyLWV2ZW50KSkuXG4gKi9cbmNsYXNzIFRpbGVMYXlvdXRSZW9yZGVyRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50JDIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgdGhlIGV2ZW50IGFyZ3VtZW50cyBmb3IgdGhlIGByZW9yZGVyYCBldmVudC5cbiAgICAgKiBAcGFyYW0gaXRlbSAtIFRoZSBUaWxlTGF5b3V0SXRlbSBiZWluZyByZW9yZGVyZWQuXG4gICAgICogQHBhcmFtIGl0ZW1zIC0gVGhlIFRpbGVMYXlvdXRJdGVtIGNvbGxlY3Rpb24gdGhhdCBob2xkcyB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGl0ZW1zIGFuZCB0aGVpciBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gbmV3SW5kZXggLSBUaGUgbmV3IG9yZGVyIGluZGV4IG9mIHRoZSByZW9yZGVyZWQgaXRlbSB1c2VkIHRvIGRldGVybWluZSBpdHMgcG9zaXRpb25pbmcgcmVsYXRpdmUgdG8gdGhlIG90aGVyIGl0ZW1zLlxuICAgICAqIEBwYXJhbSBvbGRJbmRleCAtIFRoZSBpbml0aWFsIG9yZGVyIGluZGV4IG9mIHRoZSByZW9yZGVyZWQgaXRlbSB1c2VkIHRvIGRldGVybWluZSBpdHMgcG9zaXRpb25pbmcgcmVsYXRpdmUgdG8gdGhlIG90aGVyIGl0ZW1zLlxuICAgICAqIEBwYXJhbSBuZXdDb2wgLSBUaGUgbmV3IHN0YXJ0IGNvbHVtbiBvZiB0aGUgcmVvcmRlcmVkIGl0ZW0uXG4gICAgICogQHBhcmFtIG9sZENvbCAtIFRoZSBpbml0aWFsIHN0YXJ0IGNvbHVtbiBvZiB0aGUgcmVvcmRlcmVkIGl0ZW0uXG4gICAgICogQHBhcmFtIG5ld1JvdyAtIFRoZSBuZXcgc3RhcnQgcm93IG9mIHRoZSByZW9yZGVyZWQgaXRlbS5cbiAgICAgKiBAcGFyYW0gb2xkUm93IC0gVGhlIGluaXRpYWwgc3RhcnQgcm93IG9mIHRoZSByZW9yZGVyZWQgaXRlbS5cbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaXRlbSwgaXRlbXMsIG5ld0luZGV4LCBvbGRJbmRleCwgbmV3Q29sLCBvbGRDb2wsIG5ld1Jvdywgb2xkUm93KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXRlbSA9IGl0ZW07XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy5uZXdJbmRleCA9IG5ld0luZGV4O1xuICAgICAgICB0aGlzLm9sZEluZGV4ID0gb2xkSW5kZXg7XG4gICAgICAgIHRoaXMubmV3Q29sID0gbmV3Q29sO1xuICAgICAgICB0aGlzLm9sZENvbCA9IG9sZENvbDtcbiAgICAgICAgdGhpcy5uZXdSb3cgPSBuZXdSb3c7XG4gICAgICAgIHRoaXMub2xkUm93ID0gb2xkUm93O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgcmVzaXplYCBldmVudC4gVGhlIGByZXNpemVgIGV2ZW50IGZpcmVzIHdoZW4gYW55IGl0ZW0gc2l6ZVxuICogaXMgY2hhbmdlZCBmcm9tIHRoZSBVSS4gSWYgeW91IGNhbmNlbCB0aGUgZXZlbnQsIHRoZSBjaGFuZ2UgaXMgcHJldmVudGVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcmVzaXppbmdfdGlsZWxheW91dCAlfSN0b2MtaGFuZGxpbmctdGhlLXJlc2l6ZS1ldmVudCkpLlxuICovXG5jbGFzcyBUaWxlTGF5b3V0UmVzaXplRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50JDIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgdGhlIGV2ZW50IGFyZ3VtZW50cyBmb3IgdGhlIGByZXNpemVgIGV2ZW50LlxuICAgICAqIEBwYXJhbSBpdGVtIC0gVGhlIFRpbGVMYXlvdXRJdGVtIGJlaW5nIHJlc2l6ZWRcbiAgICAgKiBAcGFyYW0gaXRlbXMgLSBUaGUgVGlsZUxheW91dEl0ZW0gY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBuZXdSb3dTcGFuIC0gVGhlIG5ldyByb3dTcGFuIG9mIHRoZSByZXNpemVkIGl0ZW1cbiAgICAgKiBAcGFyYW0gb2xkUm93U3BhbiAtIFRoZSBpbml0aWFsIHJvd1NwYW4gb2YgdGhlIHJlc2l6ZWQgaXRlbVxuICAgICAqIEBwYXJhbSBuZXdDb2xTcGFuIC0gVGhlIG5ldyBjb2xTcGFuIG9mIHRoZSByZXNpemVkIGl0ZW1cbiAgICAgKiBAcGFyYW0gb2xkQ29sU3BhbiAtIFRoZSBpbml0aWFsIGNvbFNwYW4gb2YgdGhlIHJlc2l6ZWQgaXRlbVxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpdGVtLCBpdGVtcywgbmV3Um93U3Bhbiwgb2xkUm93U3BhbiwgbmV3Q29sU3Bhbiwgb2xkQ29sU3Bhbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLml0ZW0gPSBpdGVtO1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMubmV3Um93U3BhbiA9IG5ld1Jvd1NwYW47XG4gICAgICAgIHRoaXMub2xkUm93U3BhbiA9IG9sZFJvd1NwYW47XG4gICAgICAgIHRoaXMubmV3Q29sU3BhbiA9IG5ld0NvbFNwYW47XG4gICAgICAgIHRoaXMub2xkQ29sU3BhbiA9IG9sZENvbFNwYW47XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFRpbGVMYXlvdXREcmFnZ2luZ1NlcnZpY2UgPSBjbGFzcyBUaWxlTGF5b3V0RHJhZ2dpbmdTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcih6b25lLCByZW5kZXJlciwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMucmVvcmRlcmFibGUgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KG51bGwpO1xuICAgICAgICB0aGlzLnJlc2l6YWJsZSA9IG5ldyBCZWhhdmlvclN1YmplY3QobnVsbCk7XG4gICAgICAgIHRoaXMucmVvcmRlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMucmVzaXplID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5sYXN0RHJhZ0N1cnNvck9mZnNldCA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHRoaXMucnRsID0gcnRsKTtcbiAgICB9XG4gICAgZ2V0IGNvbFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Q29sU3RhcnQ7XG4gICAgfVxuICAgIGdldCByb3dTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFJvd1N0YXJ0O1xuICAgIH1cbiAgICBnZXQgaXRlbVdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdnZWRJdGVtV3JhcHBlcjtcbiAgICB9XG4gICAgZ2V0IG9yZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRPcmRlcjtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGhhbmRsZVByZXNzKG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgY29uc3QgcmVzaXppbmcgPSAhIW9yaWdpbmFsRXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnay1yZXNpemUtaGFuZGxlJyk7XG4gICAgICAgIGNvbnN0IGNsb3Nlc3RUaWxlID0gY2xvc2VzdEluU2NvcGUob3JpZ2luYWxFdmVudC50YXJnZXQsIGVsID0+IGVsLmNsYXNzTGlzdC5jb250YWlucygnay10aWxlbGF5b3V0LWl0ZW0nKSwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MudGlsZUxheW91dEVsZW1lbnQpO1xuICAgICAgICBjb25zdCBjbG9zZXN0SGVhZGVyID0gY2xvc2VzdEluU2NvcGUob3JpZ2luYWxFdmVudC50YXJnZXQsIGVsID0+IGVsLmNsYXNzTGlzdC5jb250YWlucygnay10aWxlbGF5b3V0LWl0ZW0taGVhZGVyJyksIHRoaXMudGlsZUxheW91dFNldHRpbmdzLnRpbGVMYXlvdXRFbGVtZW50KTtcbiAgICAgICAgaWYgKCFjbG9zZXN0VGlsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkSXRlbVdyYXBwZXIgPSBjbG9zZXN0VGlsZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZEl0ZW0gPSB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy5pdGVtc1xuICAgICAgICAgICAgICAgIC5maW5kKGl0ZW0gPT4gaXRlbS5vcmRlciA9PT0gK2Nsb3Nlc3RUaWxlLnN0eWxlLm9yZGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlb3JkZXJpbmcgPSAhcmVzaXppbmcgJiYgdGhpcy5yZW9yZGVyYWJsZS5nZXRWYWx1ZSgpICYmIHRoaXMuZHJhZ2dlZEl0ZW0ucmVvcmRlcmFibGUgJiYgY2xvc2VzdEhlYWRlcjtcbiAgICAgICAgaWYgKCEocmVvcmRlcmluZyB8fCByZXNpemluZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVvcmRlcmluZyA9IHJlb3JkZXJpbmc7XG4gICAgICAgICAgICB0aGlzLnJlc2l6aW5nID0gcmVzaXppbmc7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0aWxlUmVjdCA9IHRoaXMuZHJhZ2dlZEl0ZW1XcmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgIHRvcDogb3JpZ2luYWxFdmVudC5jbGllbnRZIC0gdGlsZVJlY3QudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG9yaWdpbmFsRXZlbnQuY2xpZW50WCAtIHRpbGVSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgeDogdGlsZVJlY3QueCxcbiAgICAgICAgICAgICAgICB5OiB0aWxlUmVjdC55LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aWxlUmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRpbGVSZWN0LmhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0U2l6ZSA9IHtcbiAgICAgICAgICAgICAgICByb3dTcGFuOiB0aGlzLmRyYWdnZWRJdGVtLnJvd1NwYW4sXG4gICAgICAgICAgICAgICAgY29sU3BhbjogdGhpcy5kcmFnZ2VkSXRlbS5jb2xTcGFuXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jZWxsU2l6ZSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogKHRpbGVSZWN0LndpZHRoIC0gKCh0aGlzLnRhcmdldFNpemUuY29sU3BhbiAtIDEpICogdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuZ2FwLmNvbHVtbnMpKSAvIHRoaXMudGFyZ2V0U2l6ZS5jb2xTcGFuLFxuICAgICAgICAgICAgICAgIGhlaWdodDogKHRpbGVSZWN0LmhlaWdodCAtICgodGhpcy50YXJnZXRTaXplLnJvd1NwYW4gLSAxKSAqIHRoaXMudGlsZUxheW91dFNldHRpbmdzLmdhcC5yb3dzKSkgLyB0aGlzLnRhcmdldFNpemUucm93U3BhblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubGFzdERyYWdDdXJzb3JPZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgeDogb3JpZ2luYWxFdmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IG9yaWdpbmFsRXZlbnQuY2xpZW50WVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldEVsZW1lbnRTdHlsZXModGhpcy5yZW5kZXJlciwgdGhpcy5kcmFnZ2VkSXRlbVdyYXBwZXIsIHtcbiAgICAgICAgICAgIGxlZnQ6IHRpbGVSZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQgKyAncHgnLFxuICAgICAgICAgICAgdG9wOiB0aWxlUmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgKyAncHgnLFxuICAgICAgICAgICAgd2lkdGg6IHRpbGVSZWN0LndpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgIGhlaWdodDogdGlsZVJlY3QuaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgICAgIHpJbmRleDogRFJBR0dFRF9aSU5ERVhcbiAgICAgICAgfSk7XG4gICAgICAgIHNldEVsZW1lbnRTdHlsZXModGhpcy5yZW5kZXJlciwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuaGludEVsZW1lbnQsIHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgIGhlaWdodDogKHRpbGVSZWN0LmhlaWdodCAtIEhJTlRfQk9SREVSU19IRUlHSFQpICsgJ3B4J1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLnRhcmdldE9yZGVyID0gdGhpcy5kcmFnZ2VkSXRlbS5vcmRlcik7XG4gICAgICAgIHNldEVsZW1lbnRTdHlsZXModGhpcy5yZW5kZXJlciwgdGhpcy5kcmFnZ2VkSXRlbVdyYXBwZXIsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5yZW9yZGVyYWJsZS5nZXRWYWx1ZSgpICYmICFyZXNpemluZykge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sU3RhcnQgPSB0aGlzLmRyYWdnZWRJdGVtLmNvbFN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd1N0YXJ0ID0gdGhpcy5kcmFnZ2VkSXRlbS5yb3dTdGFydDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyRWwgPSB0aGlzLmRyYWdnZWRJdGVtLmVsZW0ubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuay10aWxlbGF5b3V0LWl0ZW0taGVhZGVyJyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGhlYWRlckVsLCAnay1jdXJzb3ItZ3JhYmJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJlc2l6YWJsZSAmJiByZXNpemluZykge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydGluZ1BvaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IG9yaWdpbmFsRXZlbnQuY2xpZW50WSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogb3JpZ2luYWxFdmVudC5jbGllbnRYXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNpemluZ0NvbFNwYW4gPSB0aGlzLmRyYWdnZWRJdGVtLmNvbFNwYW47XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzaXppbmdSb3dTcGFuID0gdGhpcy5kcmFnZ2VkSXRlbS5yb3dTcGFuO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyYWdnZWRJdGVtLmNvbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xTdGFydCA9IHRoaXMuZHJhZ2dlZEl0ZW0uY29sLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyYWdnZWRJdGVtLnJvdykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dTdGFydCA9IHRoaXMuZHJhZ2dlZEl0ZW0ucm93LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gb3JpZ2luYWxFdmVudC50YXJnZXQuY2xhc3NMaXN0WzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRHJhZyhvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnZWRJdGVtV3JhcHBlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVvcmRlcmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVvcmRlckl0ZW1zKG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplSXRlbShvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdERyYWdDdXJzb3JPZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgeDogb3JpZ2luYWxFdmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IG9yaWdpbmFsRXZlbnQuY2xpZW50WVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVSZWxlYXNlKG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5yZW9yZGVyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsT3JkZXIgPSB0aGlzLmRyYWdnZWRJdGVtLm9yZGVyO1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbENvbCA9IHRoaXMuZHJhZ2dlZEl0ZW0uY29sO1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFJvdyA9IHRoaXMuZHJhZ2dlZEl0ZW0ucm93O1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sID0gbm9ybWFsaXplVmFsdWUodGhpcy5jdXJyZW50Q29sU3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Um93ID0gbm9ybWFsaXplVmFsdWUodGhpcy5jdXJyZW50Um93U3RhcnQpO1xuICAgICAgICAgICAgaWYgKHByb3BzQ2hhbmdlZChbdGhpcy50YXJnZXRPcmRlciwgdGFyZ2V0Q29sLCB0YXJnZXRSb3ddLCBbaW5pdGlhbE9yZGVyLCBpbml0aWFsQ29sLCBpbml0aWFsUm93XSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW9yZGVyRXZlbnQgPSBuZXcgVGlsZUxheW91dFJlb3JkZXJFdmVudCh0aGlzLmRyYWdnZWRJdGVtLCB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy5pdGVtcywgdGhpcy50YXJnZXRPcmRlciwgaW5pdGlhbE9yZGVyLCBub3JtYWxpemVWYWx1ZSh0aGlzLmN1cnJlbnRDb2xTdGFydCksIGluaXRpYWxDb2wsIHRhcmdldFJvdywgaW5pdGlhbFJvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW9yZGVyLm5leHQocmVvcmRlckV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlb3JkZXJFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXRPcmRlciA+IGluaXRpYWxPcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluaXRpYWxPcmRlciArIDE7IGkgPD0gdGhpcy50YXJnZXRPcmRlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGlsZUxheW91dFNldHRpbmdzLml0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLm9yZGVyID09PSBpKS5vcmRlciA9IGkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMudGFyZ2V0T3JkZXI7IGkgPCBpbml0aWFsT3JkZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5vcmRlciA9PT0gaSkub3JkZXIgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnZWRJdGVtLm9yZGVyID0gdGhpcy50YXJnZXRPcmRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ2dlZEl0ZW0uY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnZWRJdGVtLmNvbCA9ICt0aGlzLmN1cnJlbnRDb2xTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2VkSXRlbS5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dlZEl0ZW0ucm93ID0gK3RoaXMuY3VycmVudFJvd1N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MudGlsZUxheW91dEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuaGludEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLmNsZWFuVXAoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMucmVvcmRlcmluZyAmJiB0aGlzLnJlc2l6aW5nKSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUm93U3BhbiA9IHRoaXMuZHJhZ2dlZEl0ZW0ucm93U3BhbjtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxDb2xTcGFuID0gdGhpcy5kcmFnZ2VkSXRlbS5jb2xTcGFuO1xuICAgICAgICAgICAgY29uc3QgeyB0YXJnZXRDb2xTcGFuLCB0YXJnZXRSb3dTcGFuIH0gPSBpc1Jvd0l0ZW1QcmVzZW50KHRoaXMudGlsZUxheW91dFNldHRpbmdzLml0ZW1zKSA/XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTcGFuKCkgOlxuICAgICAgICAgICAgICAgIHsgdGFyZ2V0Q29sU3BhbjogdGhpcy5jdXJyZW50UmVzaXppbmdDb2xTcGFuLCB0YXJnZXRSb3dTcGFuOiB0aGlzLmN1cnJlbnRSZXNpemluZ1Jvd1NwYW4gfTtcbiAgICAgICAgICAgIGlmIChwcm9wc0NoYW5nZWQoW2luaXRpYWxSb3dTcGFuLCBpbml0aWFsQ29sU3Bhbl0sIFt0YXJnZXRSb3dTcGFuLCB0YXJnZXRDb2xTcGFuXSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNpemVFdmVudCA9IG5ldyBUaWxlTGF5b3V0UmVzaXplRXZlbnQodGhpcy5kcmFnZ2VkSXRlbSwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuaXRlbXMsIHRhcmdldFJvd1NwYW4sIGluaXRpYWxSb3dTcGFuLCB0YXJnZXRDb2xTcGFuLCBpbml0aWFsQ29sU3Bhbik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUubmV4dChyZXNpemVFdmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNpemVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnZWRJdGVtLmNvbFNwYW4gPSB0aGlzLmN1cnJlbnRSZXNpemluZ0NvbFNwYW47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dlZEl0ZW0ucm93U3BhbiA9IHRoaXMuY3VycmVudFJlc2l6aW5nUm93U3BhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHRoaXMuY2xlYW5VcCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW9yZGVySXRlbXMoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0cyA9IGdldERyb3BUYXJnZXQoZXZlbnQpO1xuICAgICAgICBjb25zdCBjbG9zZXN0VGlsZSA9IHRhcmdldHMuZmluZCh0ID0+IHQgIT09IHRoaXMuZHJhZ2dlZEl0ZW1XcmFwcGVyKTtcbiAgICAgICAgbGV0IHRpbGVPcmRlciA9IGNsb3Nlc3RUaWxlID8gK2Nsb3Nlc3RUaWxlLnN0eWxlLm9yZGVyIDogK3RoaXMuZHJhZ2dlZEl0ZW1XcmFwcGVyLnN0eWxlLm9yZGVyO1xuICAgICAgICBpZiAodGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuYXV0b0Zsb3cgIT09ICdub25lJykge1xuICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMubGFzdERyYWdDdXJzb3JPZmZzZXQueDtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWSA9IGV2ZW50LmNsaWVudFkgLSB0aGlzLmxhc3REcmFnQ3Vyc29yT2Zmc2V0Lnk7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25YID0gZGVsdGFYID4gMCA/ICdyaWdodCcgOiBkZWx0YVggPCAwID8gJ2xlZnQnIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uWSA9IGRlbHRhWSA+IDAgPyAnZG93bicgOiBkZWx0YVggPCAwID8gJ3VwJyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLmRyYWdnZWRJdGVtV3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGhvcml6b250YWxHYXAgPSB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy5nYXAuY29sdW1ucztcbiAgICAgICAgICAgIGNvbnN0IHZlcnRpY2FsR2FwID0gdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuZ2FwLnJvd3M7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uWCAmJiB0aGlzLmRyYWdnZWRJdGVtLmNvbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29sIH0gPSBjYWxjdWxhdGVDZWxsRnJvbVBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgeDogZGlyZWN0aW9uWCA9PT0gJ3JpZ2h0JyA/IHJlY3QucmlnaHQgLSBob3Jpem9udGFsR2FwIDogcmVjdC5sZWZ0ICsgaG9yaXpvbnRhbEdhcCxcbiAgICAgICAgICAgICAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgICAgICAgICAgIH0sIHRoaXMudGlsZUxheW91dFNldHRpbmdzLnRpbGVMYXlvdXRFbGVtZW50LCB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy5nYXAsIHRoaXMuY2VsbFNpemUsIHRoaXMudGlsZUxheW91dFNldHRpbmdzLmNvbHVtbnMsIHRoaXMucnRsKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRTdGFydENvbCA9IHRoaXMuZ2V0VGFyZ2V0Q29sKGNvbCwgZGlyZWN0aW9uWCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sU3RhcnQgPSB0YXJnZXRTdGFydENvbC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvblkgJiYgdGhpcy5kcmFnZ2VkSXRlbS5yb3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJvdyB9ID0gY2FsY3VsYXRlQ2VsbEZyb21Qb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGRpcmVjdGlvblkgPT09ICdkb3duJyA/IHJlY3QuYm90dG9tIC0gdmVydGljYWxHYXAgOiByZWN0LnRvcCArIHZlcnRpY2FsR2FwXG4gICAgICAgICAgICAgICAgfSwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MudGlsZUxheW91dEVsZW1lbnQsIHRoaXMudGlsZUxheW91dFNldHRpbmdzLmdhcCwgdGhpcy5jZWxsU2l6ZSwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuY29sdW1ucywgdGhpcy5ydGwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFN0YXJ0Um93ID0gdGhpcy5nZXRUYXJnZXRSb3cocm93LCBkaXJlY3Rpb25ZKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dTdGFydCA9IHRhcmdldFN0YXJ0Um93LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGludEJlZm9yZSA9IHRpbGVPcmRlciA8IHRoaXMudGFyZ2V0T3JkZXI7XG4gICAgICAgIGNvbnN0IGhpbnRBZnRlciA9IHRpbGVPcmRlciA+IHRoaXMudGFyZ2V0T3JkZXI7XG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy50YXJnZXRPcmRlciA9IHRpbGVPcmRlcik7XG4gICAgICAgIGlmIChoaW50QmVmb3JlKSB7XG4gICAgICAgICAgICB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy50aWxlTGF5b3V0RWxlbWVudFxuICAgICAgICAgICAgICAgIC5pbnNlcnRCZWZvcmUodGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuaGludEVsZW1lbnQsIHRoaXMudGlsZUxheW91dFNldHRpbmdzLnRpbGVMYXlvdXRFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhpbnRBZnRlcikge1xuICAgICAgICAgICAgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MudGlsZUxheW91dEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuaGludEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHNldEVsZW1lbnRTdHlsZXModGhpcy5yZW5kZXJlciwgdGhpcy5kcmFnZ2VkSXRlbVdyYXBwZXIsIHtcbiAgICAgICAgICAgIHRvcDogKGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQudG9wKSArICdweCcsXG4gICAgICAgICAgICBsZWZ0OiAoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5sZWZ0KSArICdweCdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc2l6ZUl0ZW0oZXZlbnQpIHtcbiAgICAgICAgc2V0RWxlbWVudFN0eWxlcyh0aGlzLnJlbmRlcmVyLCB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy50aWxlTGF5b3V0RWxlbWVudCwge1xuICAgICAgICAgICAgY3Vyc29yOiB0aGlzLmRpcmVjdGlvbi5zcGxpdCgnay1jdXJzb3ItJylbMV1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IHRoaXMucnRsID9cbiAgICAgICAgICAgIHRoaXMub2Zmc2V0LndpZHRoICsgKHRoaXMub2Zmc2V0LnggLSBldmVudC5jbGllbnRYKSA6XG4gICAgICAgICAgICB0aGlzLm9mZnNldC53aWR0aCArIChldmVudC5jbGllbnRYIC0gdGhpcy5zdGFydGluZ1BvaW50LmxlZnQpO1xuICAgICAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gdGhpcy5vZmZzZXQuaGVpZ2h0ICsgKGV2ZW50LmNsaWVudFkgLSB0aGlzLnN0YXJ0aW5nUG9pbnQudG9wKTtcbiAgICAgICAgY29uc3QgaGludFJlY3QgPSB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy5oaW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgaGludFdpZHRoID0gaGludFJlY3Qud2lkdGg7XG4gICAgICAgIGNvbnN0IGhpbnRIZWlnaHQgPSBoaW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGhvcml6b250YWxEcmFnRGlyZWN0aW9uID0gZXZlbnQuY2xpZW50WCAtIHRoaXMubGFzdERyYWdDdXJzb3JPZmZzZXQueDtcbiAgICAgICAgY29uc3QgdmVydGljYWxEcmFnRGlyZWN0aW9uID0gZXZlbnQuY2xpZW50WSAtIHRoaXMubGFzdERyYWdDdXJzb3JPZmZzZXQueTtcbiAgICAgICAgY29uc3Qgc3RhcnRDb2wgPSB0aGlzLmRyYWdnZWRJdGVtLmNvbCA/IHRoaXMuZHJhZ2dlZEl0ZW0uY29sIDogY2FsY3VsYXRlQ2VsbEZyb21Qb3NpdGlvbih7XG4gICAgICAgICAgICB4OiB0aGlzLnJ0bCA/IGhpbnRSZWN0LnJpZ2h0IDogaGludFJlY3QueCxcbiAgICAgICAgICAgIHk6IGhpbnRSZWN0LnlcbiAgICAgICAgfSwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MudGlsZUxheW91dEVsZW1lbnQsIHRoaXMudGlsZUxheW91dFNldHRpbmdzLmdhcCwgdGhpcy5jZWxsU2l6ZSwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuY29sdW1ucywgdGhpcy5ydGwpLmNvbDtcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSAodGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuY29sdW1ucyAtIHN0YXJ0Q29sKSAqICh0aGlzLmNlbGxTaXplLndpZHRoICsgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuZ2FwLmNvbHVtbnMpICsgdGhpcy5jZWxsU2l6ZS53aWR0aDtcbiAgICAgICAgY29uc3QgcmVzaXplSG9yaXpvbnRhbGx5ID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0RWxlbWVudFN0eWxlcyh0aGlzLnJlbmRlcmVyLCB0aGlzLmRyYWdnZWRJdGVtV3JhcHBlciwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1pbihNYXRoLm1heChjdXJyZW50V2lkdGgsIHRoaXMuY2VsbFNpemUud2lkdGgpLCBtYXhXaWR0aCkgKyAncHgnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJ0bCAmJiBjdXJyZW50V2lkdGggPiB0aGlzLmNlbGxTaXplLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWxXaWR0aCA9IHRoaXMudGlsZUxheW91dFNldHRpbmdzLmNvbHVtbnMgKiAodGhpcy5jZWxsU2l6ZS53aWR0aCArIHRoaXMudGlsZUxheW91dFNldHRpbmdzLmdhcC5jb2x1bW5zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0Qm91bmRhcnkgPSB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy50aWxlTGF5b3V0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCAtIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFN0eWxlcyh0aGlzLnJlbmRlcmVyLCB0aGlzLmRyYWdnZWRJdGVtV3JhcHBlciwge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBNYXRoLm1heChldmVudC5jbGllbnRYLCBsZWZ0Qm91bmRhcnkpICsgJ3B4J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gY3VycmVudFdpZHRoIC0gaGludFdpZHRoO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5LCByaWdodCB9ID0gdGhpcy5kcmFnZ2VkSXRlbS5lbGVtLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCB7IGNvbCB9ID0gY2FsY3VsYXRlQ2VsbEZyb21Qb3NpdGlvbih7IHg6ICh0aGlzLnJ0bCA/IHJpZ2h0IDogeCksIHk6IHkgfSwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MudGlsZUxheW91dEVsZW1lbnQsIHRoaXMudGlsZUxheW91dFNldHRpbmdzLmdhcCwgdGhpcy5jZWxsU2l6ZSwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuY29sdW1ucywgdGhpcy5ydGwpO1xuICAgICAgICAgICAgY29uc3QgcmVzaXplZENvbFNwYW4gPSBjb2wgKyB0aGlzLmN1cnJlbnRSZXNpemluZ0NvbFNwYW47XG4gICAgICAgICAgICBjb25zdCBleHBhbmRpbmdDb25kaXRpb24gPSB0aGlzLnJ0bCA/IGhvcml6b250YWxEcmFnRGlyZWN0aW9uIDwgMCA6IGhvcml6b250YWxEcmFnRGlyZWN0aW9uID4gMDtcbiAgICAgICAgICAgIGNvbnN0IHNocmlua2luZ0NvbmRpdGlvbiA9IHRoaXMucnRsID8gaG9yaXpvbnRhbERyYWdEaXJlY3Rpb24gPiAwIDogaG9yaXpvbnRhbERyYWdEaXJlY3Rpb24gPCAwO1xuICAgICAgICAgICAgaWYgKGRlbHRhWCA+IE9WRVJMQVBfVEhSRVNIT0xEICogdGhpcy5jZWxsU2l6ZS53aWR0aCAmJlxuICAgICAgICAgICAgICAgIGV4cGFuZGluZ0NvbmRpdGlvbiAmJlxuICAgICAgICAgICAgICAgIHJlc2l6ZWRDb2xTcGFuIDw9IHRoaXMudGlsZUxheW91dFNldHRpbmdzLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNpemluZ0NvbFNwYW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VycmVudFJlc2l6aW5nQ29sU3BhbiA+IDEgJiZcbiAgICAgICAgICAgICAgICBzaHJpbmtpbmdDb25kaXRpb24gJiZcbiAgICAgICAgICAgICAgICBkZWx0YVggPCBSRVZFUlNFX09WRVJMQVBfVEhSRVNIT0xEICogdGhpcy5jZWxsU2l6ZS53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc2l6aW5nQ29sU3Bhbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RWxlbWVudFN0eWxlcyh0aGlzLnJlbmRlcmVyLCB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy5oaW50RWxlbWVudCwge1xuICAgICAgICAgICAgICAgIGdyaWRDb2x1bW5FbmQ6IGBzcGFuICR7dGhpcy5jdXJyZW50UmVzaXppbmdDb2xTcGFufWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNpemVWZXJ0aWNhbGx5ID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0RWxlbWVudFN0eWxlcyh0aGlzLnJlbmRlcmVyLCB0aGlzLmRyYWdnZWRJdGVtV3JhcHBlciwge1xuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoY3VycmVudEhlaWdodCwgdGhpcy5jZWxsU2l6ZS5oZWlnaHQpICsgJ3B4J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVkgPSBjdXJyZW50SGVpZ2h0IC0gaGludEhlaWdodDtcbiAgICAgICAgICAgIGlmIChkZWx0YVkgPiBPVkVSTEFQX1RIUkVTSE9MRCAqIHRoaXMuY2VsbFNpemUuaGVpZ2h0ICYmIHZlcnRpY2FsRHJhZ0RpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNpemluZ1Jvd1NwYW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VycmVudFJlc2l6aW5nUm93U3BhbiA+IDEgJiZcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbERyYWdEaXJlY3Rpb24gPCAwICYmIGRlbHRhWSA8IFJFVkVSU0VfT1ZFUkxBUF9USFJFU0hPTEQgKiB0aGlzLmNlbGxTaXplLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc2l6aW5nUm93U3Bhbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RWxlbWVudFN0eWxlcyh0aGlzLnJlbmRlcmVyLCB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy5oaW50RWxlbWVudCwge1xuICAgICAgICAgICAgICAgIGdyaWRSb3dFbmQ6IGBzcGFuICR7dGhpcy5jdXJyZW50UmVzaXppbmdSb3dTcGFufWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0RWxlbWVudFN0eWxlcyh0aGlzLnJlbmRlcmVyLCB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy5oaW50RWxlbWVudCwge1xuICAgICAgICAgICAgICAgIGhlaWdodDogYCR7dGhpcy5jYWxjdWxhdGVIaW50SGVpZ2h0KCl9cHhgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uLmluZGV4T2YoJ2V3JykgPiAtMSkge1xuICAgICAgICAgICAgcmVzaXplSG9yaXpvbnRhbGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24uaW5kZXhPZignbnMnKSA+IC0xKSB7XG4gICAgICAgICAgICByZXNpemVWZXJ0aWNhbGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNpemVIb3Jpem9udGFsbHkoKTtcbiAgICAgICAgICAgIHJlc2l6ZVZlcnRpY2FsbHkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhblVwKCkge1xuICAgICAgICB0aGlzLnRhcmdldE9yZGVyID0gdGhpcy5jdXJyZW50UmVzaXppbmdDb2xTcGFuID0gdGhpcy5jdXJyZW50Q29sU3RhcnQgPSB0aGlzLmN1cnJlbnRSZXNpemluZ1Jvd1NwYW4gPSB0aGlzLmN1cnJlbnRSb3dTdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZXNpemluZyA9IHRoaXMucmVvcmRlcmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnZWRJdGVtV3JhcHBlcikge1xuICAgICAgICAgICAgY29uc3QgZ3JhYkhhbmRsZSA9IHRoaXMuZHJhZ2dlZEl0ZW1XcmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5rLWN1cnNvci1ncmFiJyk7XG4gICAgICAgICAgICBpZiAoZ3JhYkhhbmRsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZ3JhYkhhbmRsZSwgJ2stY3Vyc29yLWdyYWJiaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRFbGVtZW50U3R5bGVzKHRoaXMucmVuZGVyZXIsIHRoaXMuZHJhZ2dlZEl0ZW1XcmFwcGVyLCB7XG4gICAgICAgICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJycsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6ICcnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRFbGVtZW50U3R5bGVzKHRoaXMucmVuZGVyZXIsIHRoaXMudGlsZUxheW91dFNldHRpbmdzLmhpbnRFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJ2F1dG8nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldEVsZW1lbnRTdHlsZXModGhpcy5yZW5kZXJlciwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MudGlsZUxheW91dEVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRyYWdnZWRJdGVtV3JhcHBlciA9XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnZWRJdGVtID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXppbmcgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVvcmRlcmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc2l6aW5nQ29sU3BhbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNpemluZ1Jvd1NwYW4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRpbmdQb2ludCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubGFzdERyYWdDdXJzb3JPZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhcmdldFNwYW4oKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1SZWN0ID0gdGhpcy5kcmFnZ2VkSXRlbS5lbGVtLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0aW5nQ2VsbCA9IGNhbGN1bGF0ZUNlbGxGcm9tUG9zaXRpb24oeyB4OiB0aGlzLnJ0bCA/IGl0ZW1SZWN0LnJpZ2h0IDogaXRlbVJlY3QueCwgeTogaXRlbVJlY3QueSB9LCB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy50aWxlTGF5b3V0RWxlbWVudCwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuZ2FwLCB0aGlzLmNlbGxTaXplLCB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy5jb2x1bW5zLCB0aGlzLnJ0bCk7XG4gICAgICAgIGNvbnN0IHRhcmdldEVuZENlbGwgPSBjYWxjdWxhdGVDZWxsRnJvbVBvc2l0aW9uKHtcbiAgICAgICAgICAgIHg6IHRoaXMucnRsID8gaXRlbVJlY3QueCArIE9WRVJMQVBfVEhSRVNIT0xEICogdGhpcy5jZWxsU2l6ZS53aWR0aCA6IGl0ZW1SZWN0LnJpZ2h0IC0gT1ZFUkxBUF9USFJFU0hPTEQgKiB0aGlzLmNlbGxTaXplLndpZHRoLFxuICAgICAgICAgICAgeTogaXRlbVJlY3QuYm90dG9tIC0gT1ZFUkxBUF9USFJFU0hPTEQgKiB0aGlzLmNlbGxTaXplLmhlaWdodFxuICAgICAgICB9LCB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy50aWxlTGF5b3V0RWxlbWVudCwgdGhpcy50aWxlTGF5b3V0U2V0dGluZ3MuZ2FwLCB0aGlzLmNlbGxTaXplLCB0aGlzLnRpbGVMYXlvdXRTZXR0aW5ncy5jb2x1bW5zLCB0aGlzLnJ0bCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXRDb2xTcGFuOiB0YXJnZXRFbmRDZWxsLmNvbCAtIHN0YXJ0aW5nQ2VsbC5jb2wgKyAxLFxuICAgICAgICAgICAgdGFyZ2V0Um93U3BhbjogdGFyZ2V0RW5kQ2VsbC5yb3cgLSBzdGFydGluZ0NlbGwucm93ICsgMVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRUYXJnZXRDb2woY29sLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMucnRsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09PSAnbGVmdCcgPyBjb2wgLSB0aGlzLmRyYWdnZWRJdGVtLmNvbFNwYW4gKyAxIDogY29sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBjb2wgLSB0aGlzLmRyYWdnZWRJdGVtLmNvbFNwYW4gKyAxIDogY29sO1xuICAgIH1cbiAgICBnZXRUYXJnZXRSb3cocm93LCBkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2Rvd24nID8gcm93IC0gdGhpcy5kcmFnZ2VkSXRlbS5yb3dTcGFuICsgMSA6IHJvdztcbiAgICB9XG4gICAgY2FsY3VsYXRlSGludEhlaWdodCgpIHtcbiAgICAgICAgY29uc3QgdG90YWxIaW50Q2VsbHNIZWlnaHQgPSB0aGlzLmN1cnJlbnRSZXNpemluZ1Jvd1NwYW4gKiB0aGlzLmNlbGxTaXplLmhlaWdodDtcbiAgICAgICAgY29uc3QgdG90YWxIaW50R2Fwc0hlaWdodCA9ICh0aGlzLmN1cnJlbnRSZXNpemluZ1Jvd1NwYW4gLSAxKSAqIHRoaXMudGlsZUxheW91dFNldHRpbmdzLmdhcC5yb3dzO1xuICAgICAgICBjb25zdCBoaW50SGVpZ2h0ID0gdG90YWxIaW50Q2VsbHNIZWlnaHQgKyB0b3RhbEhpbnRHYXBzSGVpZ2h0IC0gSElOVF9CT1JERVJTX0hFSUdIVDtcbiAgICAgICAgcmV0dXJuIGhpbnRIZWlnaHQ7XG4gICAgfVxufTtcblRpbGVMYXlvdXREcmFnZ2luZ1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOZ1pvbmUsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBUaWxlTGF5b3V0RHJhZ2dpbmdTZXJ2aWNlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdGlsZSBpdGVtIHdpdGhpbiB0aGUgVGlsZUxheW91dENvbXBvbmVudC5cbiAqL1xubGV0IFRpbGVMYXlvdXRJdGVtQ29tcG9uZW50ID0gY2xhc3MgVGlsZUxheW91dEl0ZW1Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW0sIHJlbmRlcmVyLCBsb2NhbGl6YXRpb24sIGRyYWdnaW5nU2VydmljZSkge1xuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmRyYWdnaW5nU2VydmljZSA9IGRyYWdnaW5nU2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaG93IG1hbnkgcm93cyB3aWxsIHRoZSB0aWxlIGl0ZW0gc3BhbiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRpbGVzX3RpbGVsYXlvdXQgJX0jdG9jLXRpbGUtc2l6ZS1hbmQtcG9zaXRpb24pKS5cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yb3dTcGFuID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaG93IG1hbnkgY29sdW1ucyB3aWxsIHRoZSB0aWxlIGl0ZW0gc3BhbiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRpbGVzX3RpbGVsYXlvdXQgJX0jdG9jLXRpbGUtc2l6ZS1hbmQtcG9zaXRpb24pKS5cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xTcGFuID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgaXRlbSBjYW4gYmUgcmVvcmRlcmVkLiBCeSBkZWZhdWx0IGFsbCBpdGVtcyBhcmUgcmVvcmRlcmFibGUgd2hlbiB0aGUgW3Jlb3JkZXJhYmxlXSh7JSBzbHVnIGFwaV9sYXlvdXRfdGlsZWxheW91dGNvbXBvbmVudCAlfSN0b2MtcmVvcmRlcmFibGUpIHByb3BlcnR5IG9mIHRoZSBUaWxlTGF5b3V0Q29tcG9uZW50IGlzIHNldCB0byBgdHJ1ZWAgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZW9yZGVyaW5nX3RpbGVsYXlvdXQgJX0jdG9jLWRpc2FibGUtcmVvcmRlcmluZykpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlb3JkZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgaXRlbSBjYW4gYmUgcmVzaXplZC4gQnkgZGVmYXVsdCBhbGwgaXRlbXMgYXJlIHJlc2l6YWJsZSB3aGVuIHRoZSBbcmVzaXphYmxlXSh7JSBzbHVnIGFwaV9sYXlvdXRfdGlsZWxheW91dGNvbXBvbmVudCAlfSNyZXNpemFibGUpIHByb3BlcnR5IG9mIHRoZSBUaWxlTGF5b3V0Q29tcG9uZW50IGlzIHNldCB0byBgdHJ1ZWAgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZXNpemluZ190aWxlbGF5b3V0ICV9I3RvYy1kaXNhYmxlLXJlc2l6aW5nKSkuXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXphYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pdGVtQ2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLnN1YnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMucnRsID0gcnRsO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5kcmFnZ2luZ1NlcnZpY2UucmVzaXphYmxlLnN1YnNjcmliZShyZXNpemFibGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVEaXJlY3Rpb25zID0gcmVzaXphYmxlICYmIHRoaXMucmVzaXphYmxlID9cbiAgICAgICAgICAgICAgICB0aGlzLnJ0bCA/IFJUTF9SRVNJWkVfRElSRUNUSU9OUyA6IFJFU0laRV9ESVJFQ1RJT05TIDogdW5kZWZpbmVkO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIG9yZGVyIG9mIHRoZSB0aWxlIGl0ZW1zIHdpdGhpbiB0aGUgVGlsZUxheW91dC5cbiAgICAgKiBJZiBub3Qgc2V0LCB0aGUgaXRlbXMgd2lsbCByZWNlaXZlIGluY3JlYXNpbmcgc2VxdWVudGlhbCBvcmRlciBpbiBhY2NvcmRhbmNlIHdpdGhcbiAgICAgKiB0aGVpciBwb3NpdGlvbiBpbiB0aGUgRE9NIHdoZW4gaW5pdGlhbGx5IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHNldCBvcmRlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vcmRlciA9IHZhbHVlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LCAnb3JkZXInLCBgJHt0aGlzLl9vcmRlcn1gKTtcbiAgICB9XG4gICAgZ2V0IG9yZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkZXI7XG4gICAgfVxuICAgIGdldCBjb2xFbmQoKSB7XG4gICAgICAgIHJldHVybiBgc3BhbiAke3RoaXMuY29sU3Bhbn1gO1xuICAgIH1cbiAgICBnZXQgcm93RW5kKCkge1xuICAgICAgICByZXR1cm4gYHNwYW4gJHt0aGlzLnJvd1NwYW59YDtcbiAgICB9XG4gICAgZ2V0IGNvbFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29sKSA/IHRoaXMuY29sLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCByb3dTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnJvdykgPyB0aGlzLnJvdy50b1N0cmluZygpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5kcmFnZ2luZ1NlcnZpY2UucmVvcmRlcmFibGUuc3Vic2NyaWJlKHJlb3JkZXJhYmxlID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQ3Vyc29yQ2xhc3MocmVvcmRlcmFibGUgJiYgdGhpcy5yZW9yZGVyYWJsZSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5yZW9yZGVyYWJsZSAmJiAhY2hhbmdlcy5yZW9yZGVyYWJsZS5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVDdXJzb3JDbGFzcyhjaGFuZ2VzLnJlb3JkZXJhYmxlLmN1cnJlbnRWYWx1ZSAmJiB0aGlzLmRyYWdnaW5nU2VydmljZS5yZW9yZGVyYWJsZS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplRGlyZWN0aW9ucyA9IHRoaXMucmVzaXphYmxlICYmIHRoaXMuZHJhZ2dpbmdTZXJ2aWNlLnJlc2l6YWJsZS5nZXRWYWx1ZSgpID9cbiAgICAgICAgICAgICAgICB0aGlzLnJ0bCA/IFJUTF9SRVNJWkVfRElSRUNUSU9OUyA6IFJFU0laRV9ESVJFQ1RJT05TIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdG9nZ2xlQ3Vyc29yQ2xhc3MoaXNSZW9yZGVyYWJsZSkge1xuICAgICAgICBjb25zdCBoZWFkZXJFbCA9IHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5rLXRpbGVsYXlvdXQtaXRlbS1oZWFkZXInKTtcbiAgICAgICAgaWYgKCFoZWFkZXJFbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Jlb3JkZXJhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGhlYWRlckVsLCAnay1jdXJzb3ItZ3JhYicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhoZWFkZXJFbCwgJ2stY3Vyc29yLWdyYWInKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaWxlTGF5b3V0SXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFRpbGVMYXlvdXRJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3dTcGFuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBUaWxlTGF5b3V0SXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sU3BhblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBUaWxlTGF5b3V0SXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3JkZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBUaWxlTGF5b3V0SXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBUaWxlTGF5b3V0SXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwicm93XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGlsZUxheW91dEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInJlb3JkZXJhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGlsZUxheW91dEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdGlsZWxheW91dC1pdGVtJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY2FyZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGlsZUxheW91dEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1DbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLmdyaWQtY29sdW1uLWVuZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRpbGVMYXlvdXRJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xFbmRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnc3R5bGUuZ3JpZC1yb3ctZW5kJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVGlsZUxheW91dEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInJvd0VuZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5ncmlkLWNvbHVtbi1zdGFydCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRpbGVMYXlvdXRJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xTdGFydFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5ncmlkLXJvdy1zdGFydCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRpbGVMYXlvdXRJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3dTdGFydFwiLCBudWxsKTtcblRpbGVMYXlvdXRJdGVtQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10aWxlbGF5b3V0LWl0ZW0nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8a2VuZG8tdGlsZWxheW91dC1pdGVtLWhlYWRlciAqbmdJZj1cInRpdGxlXCI+XG4gICAgICAgICAgICA8aDUgY2xhc3M9XCJrLWNhcmQtdGl0bGVcIj57eyB0aXRsZSB9fTwvaDU+XG4gICAgICAgIDwva2VuZG8tdGlsZWxheW91dC1pdGVtLWhlYWRlcj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwicmVzaXphYmxlXCI+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IGRpciBvZiByZXNpemVEaXJlY3Rpb25zXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstcmVzaXplLWhhbmRsZSBrLWN1cnNvci17e2Rpcn19LXJlc2l6ZSBrLXRvdWNoLWFjdGlvbi1ub25lXCJcbiAgICAgICAgICAgICAgICBrZW5kb1RpbGVMYXlvdXRSZXNpemVIYW5kbGVcbiAgICAgICAgICAgICAgICBbcnRsXT1cInJ0bFwiXG4gICAgICAgICAgICAgICAgW3Jlc2l6ZURpcmVjdGlvbl09XCJkaXJcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIFRpbGVMYXlvdXREcmFnZ2luZ1NlcnZpY2VdKVxuXSwgVGlsZUxheW91dEl0ZW1Db21wb25lbnQpO1xuXG5jb25zdCBhdXRvRmxvd0NsYXNzZXMgPSB7XG4gICAgY29sdW1uOiAnay1ncmlkLWZsb3ctY29sJyxcbiAgICByb3c6ICdrLWdyaWQtZmxvdy1yb3cnLFxuICAgICdjb2x1bW4tZGVuc2UnOiAnay1ncmlkLWZsb3ctY29sLWRlbnNlJyxcbiAgICAncm93LWRlbnNlJzogJ2stZ3JpZC1mbG93LXJvdy1kZW5zZSdcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBUaWxlTGF5b3V0IGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld190aWxlbGF5b3V0ICV9KVxuICovXG5sZXQgVGlsZUxheW91dENvbXBvbmVudCA9IGNsYXNzIFRpbGVMYXlvdXRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW0sIHJlbmRlcmVyLCBsb2NhbGl6YXRpb24sIGRyYWdnaW5nU2VydmljZSwgem9uZSkge1xuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmRyYWdnaW5nU2VydmljZSA9IGRyYWdnaW5nU2VydmljZTtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIG51bWJlciBvZiBjb2x1bW5zIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdGlsZXNfdGlsZWxheW91dCAlfSN0b2MtdGlsZS1zaXplLWFuZC1wb3NpdGlvbikpLlxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbnMuIE51bWVyaWMgdmFsdWVzIGFyZSB0cmVhdGVkIGFzIHBpeGVscyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRpbGVzX3RpbGVsYXlvdXQgJX0jdG9jLXRpbGUtc2l6ZS1hbmQtcG9zaXRpb24pKS5cbiAgICAgICAgICogQGRlZmF1bHQgJzFmcidcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sdW1uV2lkdGggPSAnMWZyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgcmVvcmRlcmluZyBmdW5jdGlvbmFsaXR5IHdpbGwgYmUgZW5hYmxlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlb3JkZXJpbmdfdGlsZWxheW91dCAlfSkpLlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW9yZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSByZXNpemluZyBmdW5jdGlvbmFsaXR5IHdpbGwgYmUgZW5hYmxlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlc2l6aW5nX3RpbGVsYXlvdXQgJX0pKS5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXphYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBoZWlnaHQgb2YgdGhlIHJvd3MuIE51bWVyaWMgdmFsdWVzIGFyZSB0cmVhdGVkIGFzIHBpeGVscyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRpbGVzX3RpbGVsYXlvdXQgJX0jdG9jLXRpbGUtc2l6ZS1hbmQtcG9zaXRpb24pKS5cbiAgICAgICAgICogQGRlZmF1bHQgJzFmcidcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm93SGVpZ2h0ID0gJzFmcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyBob3cgdGhlIGF1dG8tcGxhY2VtZW50IGFsZ29yaXRobSB3b3Jrcywgc3BlY2lmeWluZyBleGFjdGx5IGhvdyBhdXRvLXBsYWNlZCBpdGVtcyBhcmUgZmxvd2VkIGluIHRoZSBUaWxlTGF5b3V0IChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdGlsZXNfYXV0b2Zsb3dfdGlsZWxheW91dCAlfSkpLlxuICAgICAgICAgKiBGb3IgZnVydGhlciByZWZlcmVuY2UsIGNoZWNrIHRoZSBbZ3JpZC1hdXRvLWZsb3cgQ1NTIGFydGljbGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9ncmlkLWF1dG8tZmxvdykuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgY29sdW1uYFxuICAgICAgICAgKiAqIGByb3dgXG4gICAgICAgICAqICogYHJvdyBkZW5zZWBcbiAgICAgICAgICogKiBgY29sdW1uIGRlbnNlYFxuICAgICAgICAgKiAqIGBub25lYFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvRmxvdyA9ICdjb2x1bW4nO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIHJlb3JkZXJpbmcgb2YgdGhlIGl0ZW0gKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld190aWxlbGF5b3V0ICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCBpdCwgdGhlIGl0ZW0gd2lsbCBub3QgYmUgcmVvcmRlcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW9yZGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIHJlc2l6aW5nIG9mIHRoZSBpdGVtIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfdGlsZWxheW91dCAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgaXQsIHRoZSBpdGVtIHdpbGwgbm90IGJlIHJlc2l6ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2l6ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLnN1YnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuX2dhcCA9IHtcbiAgICAgICAgICAgIHJvd3M6IDE2LFxuICAgICAgICAgICAgY29sdW1uczogMTZcbiAgICAgICAgfTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1lcmljIHZhbHVlcyB3aGljaCBkZXRlcm1pbmUgdGhlIHNwYWNpbmcgaW4gcGl4ZWxzIGJldHdlZW4gdGhlIGxheW91dCBpdGVtcyBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkuXG4gICAgICogUHJvcGVydGllczpcbiAgICAgKiAqIHJvd3MgLSB0aGUgdmVydGljYWwgc3BhY2luZy4gTnVtZXJpYyB2YWx1ZXMgYXJlIHRyZWF0ZWQgYXMgcGl4ZWxzLiBEZWZhdWx0cyB0byBgMTZgLlxuICAgICAqICogY29sdW1ucyAtIHRoZSBob3Jpem9udGFsIHNwYWNpbmcuIE51bWVyaWMgdmFsdWVzIGFyZSB0cmVhdGVkIGFzIHBpeGVscy4gRGVmYXVsdHMgdG8gYDE2YC5cbiAgICAgKlxuICAgICAqIFdoZW4gYm91bmQgdG8gYSBzaW5nbGUgbnVtZXJpYyB2YWx1ZSwgaXQgd2lsbCBiZSBzZXQgdG8gYm90aCBgcm93c2AgYW5kIGBjb2x1bW5zYCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNldCBnYXAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZ2FwID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpID8geyByb3dzOiB2YWx1ZSwgY29sdW1uczogdmFsdWUgfSA6IE9iamVjdC5hc3NpZ24odGhpcy5fZ2FwLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBnYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nYXA7XG4gICAgfVxuICAgIGdldCBnYXBTdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2FwLnJvd3N9cHggJHt0aGlzLmdhcC5jb2x1bW5zfXB4YDtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRDb2xTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ2dpbmdTZXJ2aWNlLmNvbFN0YXJ0O1xuICAgIH1cbiAgICBnZXQgY3VycmVudFJvd1N0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnZ2luZ1NlcnZpY2Uucm93U3RhcnQ7XG4gICAgfVxuICAgIGdldCBkcmFnZ2VkSXRlbVdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdnaW5nU2VydmljZS5pdGVtV3JhcHBlcjtcbiAgICB9XG4gICAgZ2V0IHRhcmdldE9yZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnZ2luZ1NlcnZpY2Uub3JkZXI7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmFwcGx5Q29sU3R5bGluZygpO1xuICAgICAgICB0aGlzLmFwcGx5Um93U3R5bGluZygpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nU2VydmljZS5yZW9yZGVyYWJsZS5uZXh0KHRoaXMucmVvcmRlcmFibGUpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nU2VydmljZS5yZXNpemFibGUubmV4dCh0aGlzLnJlc2l6YWJsZSk7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5yZW9yZGVyKSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzLmFkZCh0aGlzLmRyYWdnaW5nU2VydmljZS5yZW9yZGVyLnN1YnNjcmliZShlID0+IHRoaXMucmVvcmRlci5lbWl0KGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLnJlc2l6ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5kcmFnZ2luZ1NlcnZpY2UucmVzaXplLnN1YnNjcmliZShlID0+IHRoaXMucmVzaXplLmVtaXQoZSkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnMuYWRkKHRoaXMuZHJhZ2dpbmdTZXJ2aWNlLnJlb3JkZXJhYmxlLnN1YnNjcmliZShyZW9yZGVyYWJsZSA9PiB7XG4gICAgICAgICAgICBpZiAocmVvcmRlcmFibGUgJiYgIXRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRHJhZ2dhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5zdWJzLmFkZCh0aGlzLmRyYWdnaW5nU2VydmljZS5yZXNpemFibGUuc3Vic2NyaWJlKHJlc2l6YWJsZSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzaXphYmxlICYmICF0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZURyYWdnYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTZXJ2aWNlLnRpbGVMYXlvdXRTZXR0aW5ncyA9IHRoaXMuZHJhZ2dpbmdTZXJ2aWNlQ29uZmlnKCk7XG4gICAgICAgIHRoaXMuYXBwbHlBdXRvRmxvdyhudWxsLCBhdXRvRmxvd0NsYXNzZXNbdGhpcy5hdXRvRmxvd10pO1xuICAgICAgICB0aGlzLml0ZW1zLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0SXRlbXNPcmRlcigpO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ1NlcnZpY2UudGlsZUxheW91dFNldHRpbmdzLml0ZW1zID0gdGhpcy5pdGVtcy50b0FycmF5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMuc2V0SXRlbXNPcmRlcigpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmNvbHVtbnMgfHwgY2hhbmdlcy5jb2x1bW5XaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5hcHBseUNvbFN0eWxpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5yb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlSb3dTdHlsaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMucmVvcmRlcmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZXJ2aWNlLnJlb3JkZXJhYmxlLm5leHQoY2hhbmdlcy5yZW9yZGVyYWJsZS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnJlc2l6YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ1NlcnZpY2UucmVzaXphYmxlLm5leHQoY2hhbmdlcy5yZXNpemFibGUuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5nYXAgfHwgY2hhbmdlcy5hdXRvRmxvdyB8fCBjaGFuZ2VzLmNvbHVtbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZXJ2aWNlLnRpbGVMYXlvdXRTZXR0aW5ncyA9IHRoaXMuZHJhZ2dpbmdTZXJ2aWNlQ29uZmlnKCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5hdXRvRmxvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlBdXRvRmxvdyhhdXRvRmxvd0NsYXNzZXNbY2hhbmdlcy5hdXRvRmxvdy5wcmV2aW91c1ZhbHVlXSB8fCAnJywgYXV0b0Zsb3dDbGFzc2VzW2NoYW5nZXMuYXV0b0Zsb3cuY3VycmVudFZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vicy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBoYW5kbGVQcmVzcyh7IG9yaWdpbmFsRXZlbnQgfSkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nU2VydmljZS5oYW5kbGVQcmVzcyhvcmlnaW5hbEV2ZW50KTtcbiAgICB9XG4gICAgaGFuZGxlRHJhZyh7IG9yaWdpbmFsRXZlbnQgfSkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nU2VydmljZS5oYW5kbGVEcmFnKG9yaWdpbmFsRXZlbnQpO1xuICAgIH1cbiAgICBoYW5kbGVSZWxlYXNlKHsgb3JpZ2luYWxFdmVudCB9KSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTZXJ2aWNlLmhhbmRsZVJlbGVhc2Uob3JpZ2luYWxFdmVudCk7XG4gICAgfVxuICAgIGFwcGx5Q29sU3R5bGluZygpIHtcbiAgICAgICAgY29uc3QgY29sV2lkdGggPSB0eXBlb2YgdGhpcy5jb2x1bW5XaWR0aCA9PT0gJ251bWJlcicgPyBgJHt0aGlzLmNvbHVtbldpZHRofXB4YCA6IHRoaXMuY29sdW1uV2lkdGg7XG4gICAgICAgIGNvbnN0IGdyaWRUZW1wbGF0ZUNvbHVtbnNTdHlsZSA9IGByZXBlYXQoJHt0aGlzLmNvbHVtbnN9LCAke2NvbFdpZHRofSlgO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LCAnZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zJywgZ3JpZFRlbXBsYXRlQ29sdW1uc1N0eWxlKTtcbiAgICB9XG4gICAgYXBwbHlSb3dTdHlsaW5nKCkge1xuICAgICAgICBjb25zdCByb3dIZWlnaHQgPSB0eXBlb2YgdGhpcy5yb3dIZWlnaHQgPT09ICdudW1iZXInID8gYCR7dGhpcy5yb3dIZWlnaHR9cHhgIDogdGhpcy5yb3dIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGdyaWRBdXRvUm93c1N0eWxlID0gYCR7cm93SGVpZ2h0fWA7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQsICdncmlkLWF1dG8tcm93cycsIGdyaWRBdXRvUm93c1N0eWxlKTtcbiAgICB9XG4gICAgZHJhZ2dpbmdTZXJ2aWNlQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGlsZUxheW91dEVsZW1lbnQ6IHRoaXMuZWxlbSA/IHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGludEVsZW1lbnQ6IHRoaXMuaGludCA/IHRoaXMuaGludC5uYXRpdmVFbGVtZW50IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ2FwOiB0aGlzLmdhcCxcbiAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuY29sdW1ucyxcbiAgICAgICAgICAgIGF1dG9GbG93OiB0aGlzLmF1dG9GbG93LFxuICAgICAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMgPyB0aGlzLml0ZW1zLnRvQXJyYXkoKSA6IFtdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRpYWxpemVEcmFnZ2FibGUoKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZSh7XG4gICAgICAgICAgICBwcmVzczogdGhpcy5oYW5kbGVQcmVzcy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZHJhZzogdGhpcy5oYW5kbGVEcmFnLmJpbmQodGhpcyksXG4gICAgICAgICAgICByZWxlYXNlOiB0aGlzLmhhbmRsZVJlbGVhc2UuYmluZCh0aGlzKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuZHJhZ2dhYmxlLmJpbmRUbyh0aGlzLmVsZW0ubmF0aXZlRWxlbWVudCkpO1xuICAgIH1cbiAgICBhcHBseUF1dG9GbG93KGNsYXNzVG9SZW1vdmUsIGNsYXNzVG9BZGQpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAoY2xhc3NUb1JlbW92ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc1RvUmVtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRvRmxvdyAhPT0gJ25vbmUnICYmIGlzUHJlc2VudChjbGFzc1RvQWRkKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50LCBjbGFzc1RvQWRkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRJdGVtc09yZGVyKCkge1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChpdGVtLm9yZGVyKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0ub3JkZXIgPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFRpbGVMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRpbGVMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbldpZHRoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIFRpbGVMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcImdhcFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaWxlTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZW9yZGVyYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpbGVMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGlsZUxheW91dENvbXBvbmVudC5wcm90b3R5cGUsIFwicm93SGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaWxlTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhdXRvRmxvd1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRpbGVMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcInJlb3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUaWxlTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXdpZGdldCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXRpbGVsYXlvdXQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpbGVMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLmdhcCcpLFxuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5wYWRkaW5nJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVGlsZUxheW91dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2FwU3R5bGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5kaXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGlsZUxheW91dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlyZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oVGlsZUxheW91dEl0ZW1Db21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBUaWxlTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdoaW50JywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgVGlsZUxheW91dENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGludFwiLCB2b2lkIDApO1xuVGlsZUxheW91dENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdGlsZWxheW91dCcsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIFRpbGVMYXlvdXREcmFnZ2luZ1NlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby50aWxlbGF5b3V0LmNvbXBvbmVudCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8ZGl2ICNoaW50IGNsYXNzPVwiay1sYXlvdXQtaXRlbS1oaW50IGstbGF5b3V0LWl0ZW0taGludC1yZW9yZGVyXCJcbiAgICAgICAgICAgIFtzdHlsZS5kaXNwbGF5XT1cIidub25lJ1wiXG4gICAgICAgICAgICBbc3R5bGUub3JkZXJdPVwidGFyZ2V0T3JkZXJcIlxuICAgICAgICAgICAgW3N0eWxlLmdyaWRDb2x1bW5FbmRdPVwiZHJhZ2dlZEl0ZW1XcmFwcGVyPy5zdHlsZS5ncmlkQ29sdW1uRW5kXCJcbiAgICAgICAgICAgIFtzdHlsZS5ncmlkUm93RW5kXT1cImRyYWdnZWRJdGVtV3JhcHBlcj8uc3R5bGUuZ3JpZFJvd0VuZFwiXG4gICAgICAgICAgICBbc3R5bGUuZ3JpZENvbHVtblN0YXJ0XT1cImN1cnJlbnRDb2xTdGFydFwiXG4gICAgICAgICAgICBbc3R5bGUuZ3JpZFJvd1N0YXJ0XT1cImN1cnJlbnRSb3dTdGFydFwiXG4gICAgICAgICAgICBbc3R5bGUuekluZGV4XT1cIicxJ1wiPjwvZGl2PlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgVGlsZUxheW91dERyYWdnaW5nU2VydmljZSxcbiAgICAgICAgTmdab25lXSlcbl0sIFRpbGVMYXlvdXRDb21wb25lbnQpO1xuXG4vKipcbiAqIEhvbGRzIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIFRpbGVMYXlvdXRJdGVtIGNvbXBvbmVudC5cbiAqL1xubGV0IFRpbGVMYXlvdXRJdGVtQm9keUNvbXBvbmVudCA9IGNsYXNzIFRpbGVMYXlvdXRJdGVtQm9keUNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgVGlsZUxheW91dEl0ZW0gY29tcG9uZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMubWluSGVpZ2h0ID0gMDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdGlsZWxheW91dC1pdGVtLWJvZHknKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jYXJkLWJvZHknKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpbGVMYXlvdXRJdGVtQm9keUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnc3R5bGUubWluLWhlaWdodCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBUaWxlTGF5b3V0SXRlbUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcIm1pbkhlaWdodFwiLCB2b2lkIDApO1xuVGlsZUxheW91dEl0ZW1Cb2R5Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10aWxlbGF5b3V0LWl0ZW0tYm9keScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgXG4gICAgfSlcbl0sIFRpbGVMYXlvdXRJdGVtQm9keUNvbXBvbmVudCk7XG5cbi8qKlxuICogSG9sZHMgdGhlIGNvbnRlbnQgb2YgdGhlIGhlYWRlciBzZWN0aW9uIG9mIHRoZSBUaWxlTGF5b3V0SXRlbSBjb21wb25lbnQuXG4gKiBUaGlzIGlzIHRoZSBhcmVhIHdoaWNoIGNhbiBiZSBkcmFnZ2VkIHRvIHJlb3JkZXIgdGhlIGl0ZW1zIGlmIHJlb3JkZXJpbmcgaXMgZW5hYmxlZCBmb3IgdGhpcyBpdGVtLlxuICovXG5sZXQgVGlsZUxheW91dEl0ZW1IZWFkZXJDb21wb25lbnQgPSBjbGFzcyBUaWxlTGF5b3V0SXRlbUhlYWRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZHJhZ2dpbmdTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTZXJ2aWNlID0gZHJhZ2dpbmdTZXJ2aWNlO1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgfVxuICAgIGdldCB0b3VjaEFjdGlvbk5vbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdnaW5nU2VydmljZS5yZW9yZGVyYWJsZS5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICBnZXQgdG91Y2hBY3Rpb25BdXRvKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZHJhZ2dpbmdTZXJ2aWNlLnJlb3JkZXJhYmxlLmdldFZhbHVlKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXRpbGVsYXlvdXQtaXRlbS1oZWFkZXInKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jYXJkLWhlYWRlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGlsZUxheW91dEl0ZW1IZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdG91Y2gtYWN0aW9uLW5vbmUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVGlsZUxheW91dEl0ZW1IZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRvdWNoQWN0aW9uTm9uZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXRvdWNoLWFjdGlvbi1hdXRvJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRpbGVMYXlvdXRJdGVtSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b3VjaEFjdGlvbkF1dG9cIiwgbnVsbCk7XG5UaWxlTGF5b3V0SXRlbUhlYWRlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdGlsZWxheW91dC1pdGVtLWhlYWRlcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUaWxlTGF5b3V0RHJhZ2dpbmdTZXJ2aWNlXSlcbl0sIFRpbGVMYXlvdXRJdGVtSGVhZGVyQ29tcG9uZW50KTtcblxuY29uc3QgZXhwb3J0ZWRNb2R1bGVzID0gW1xuICAgIEF2YXRhckNvbXBvbmVudFxuXTtcbmNvbnN0IGRlY2xhcmF0aW9ucyA9IFtcbiAgICAuLi5leHBvcnRlZE1vZHVsZXNcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBBdmF0YXIgY29tcG9uZW50LlxuICovXG5sZXQgQXZhdGFyTW9kdWxlID0gY2xhc3MgQXZhdGFyTW9kdWxlIHtcbn07XG5BdmF0YXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9uc10sXG4gICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZE1vZHVsZXNdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxuICAgIH0pXG5dLCBBdmF0YXJNb2R1bGUpO1xuXG5jb25zdCBjYXJkRGlyZWN0aXZlcyA9IFtcbiAgICBDYXJkVGl0bGVEaXJlY3RpdmUsXG4gICAgQ2FyZFN1YnRpdGxlRGlyZWN0aXZlLFxuICAgIENhcmRTZXBhcmF0b3JEaXJlY3RpdmUsXG4gICAgQ2FyZE1lZGlhRGlyZWN0aXZlXG5dO1xuY29uc3QgZXhwb3J0ZWRNb2R1bGVzJDEgPSBbXG4gICAgQ2FyZENvbXBvbmVudCxcbiAgICBDYXJkSGVhZGVyQ29tcG9uZW50LFxuICAgIENhcmRCb2R5Q29tcG9uZW50LFxuICAgIENhcmRGb290ZXJDb21wb25lbnQsXG4gICAgQ2FyZEFjdGlvbnNDb21wb25lbnQsXG4gICAgLi4uY2FyZERpcmVjdGl2ZXNcbl07XG5jb25zdCBkZWNsYXJhdGlvbnMkMSA9IFsuLi5leHBvcnRlZE1vZHVsZXMkMV07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBDYXJkIGNvbXBvbmVudC5cbiAqL1xubGV0IENhcmRNb2R1bGUgPSBjbGFzcyBDYXJkTW9kdWxlIHtcbn07XG5DYXJkTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtkZWNsYXJhdGlvbnMkMV0sXG4gICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZE1vZHVsZXMkMV0sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdXG4gICAgfSlcbl0sIENhcmRNb2R1bGUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgRFJBV0VSX0xJTktfU0VMRUNUT1IgPSAnLmstZHJhd2VyLWxpbmsnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEFDVElWRV9ORVNURURfTElOS19TRUxFQ1RPUiA9ICc6Zm9jdXM6bm90KC5rLXN0YXRlLWRpc2FibGVkKSAuay1kcmF3ZXItbGluayc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbmVzdGVkTGluayA9IChlbGVtZW50LCBzZWxlY3RvcikgPT4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBEcmF3ZXJJdGVtQ29tcG9uZW50ID0gY2xhc3MgRHJhd2VySXRlbUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZHJhd2VyLCBlbGVtZW50LCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmRyYXdlciA9IGRyYXdlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5kaXNhYmxlZDtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdlci5zZWxlY3RlZEluZGljZXMuaW5kZXhPZih0aGlzLmluZGV4KSA+PSAwO1xuICAgIH1cbiAgICBnZXQgbGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0udGV4dCA/IHRoaXMuaXRlbS50ZXh0IDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgY29uc3QgbGluayA9IG5lc3RlZExpbmsodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIERSQVdFUl9MSU5LX1NFTEVDVE9SKTtcbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKGxpbmssICd0YWJpbmRleCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaWNvbkNsYXNzZXMoKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaXRlbS5pY29uKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goYGstaWNvbiAke3RoaXMuaXRlbS5pY29ufWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLml0ZW0uaWNvbkNsYXNzKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goYCR7dGhpcy5pdGVtLmljb25DbGFzc31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRHJhd2VySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRHJhd2VySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgRHJhd2VySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbVRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRHJhd2VySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluaVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyYXdlckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImV4cGFuZGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRHJhd2VySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEcmF3ZXJJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjc3NDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyYXdlckl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImNzc1N0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLWRpc2FibGVkJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc3RhdGUtZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRHJhd2VySXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtc2VsZWN0ZWQnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1zZWxlY3RlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBEcmF3ZXJJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1sYWJlbCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBEcmF3ZXJJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCBudWxsKTtcbkRyYXdlckl0ZW1Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RyYXdlckl0ZW1dJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaXRlbVRlbXBsYXRlOyBlbHNlIGRlZmF1bHRUZW1wbGF0ZVwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJpdGVtVGVtcGxhdGVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgJGltcGxpY2l0OiBpdGVtIH1cIj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRUZW1wbGF0ZT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJleHBhbmRlZFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIFtuZ0NsYXNzXT1cImljb25DbGFzc2VzXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pdGVtLXRleHRcIj57eyBpdGVtLnRleHQgfX08L3NwYW4+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJtaW5pICYmICFleHBhbmRlZFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIFtuZ0NsYXNzXT1cImljb25DbGFzc2VzXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRHJhd2VyU2VydmljZSwgRWxlbWVudFJlZiwgUmVuZGVyZXIyXSlcbl0sIERyYXdlckl0ZW1Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgRFJBV0VSX0lURU1fSU5ERVggPSAnZGF0YS1rZW5kby1kcmF3ZXItaW5kZXgnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERyYXdlckxpc3RDb21wb25lbnQgPSBjbGFzcyBEcmF3ZXJMaXN0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkcmF3ZXJTZXJ2aWNlLCByZW5kZXJlciwgbmdab25lLCBjaGFuZ2VEZXRlY3RvciwgZWxlbWVudCkge1xuICAgICAgICB0aGlzLmRyYXdlclNlcnZpY2UgPSBkcmF3ZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmluaXREb21FdmVudHMoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpbml0aWFsU2VsZWN0aW9uKCkge1xuICAgICAgICAvKiBEaWZmZXJlbnRpYXRlcyBhIHVzZXIgc2VsZWN0ZWQgaXRlbSAqL1xuICAgICAgICBpZiAodGhpcy5kcmF3ZXJTZXJ2aWNlLnNlbGVjdGVkSW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd2VyU2VydmljZS5pbml0U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdERvbUV2ZW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucmVuZGVyZXIubGlzdGVuKG5hdGl2ZUVsZW1lbnQsICdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcykpKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4obmF0aXZlRWxlbWVudCwgJ2tleWRvd24nLCB0aGlzLmtleURvd25IYW5kbGVyLmJpbmQodGhpcykpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1JZHggPSB0aGlzLmdldERyYXdlckl0ZW1JbmRleChlLnRhcmdldCk7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zW2l0ZW1JZHhdO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgICAgICBpbmRleDogaXRlbUlkeCxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZHJhd2VyU2VydmljZS5lbWl0KCdzZWxlY3QnLCBhcmdzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd2VyU2VydmljZS5vblNlbGVjdChpdGVtSWR4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGtleURvd25IYW5kbGVyKGUpIHtcbiAgICAgICAgY29uc3QgaXNFbnRlck9yU3BhY2UgPSBlLmtleUNvZGUgPT09IEtleXMuRW50ZXIgfHwgZS5rZXlDb2RlID09PSBLZXlzLlNwYWNlO1xuICAgICAgICBpZiAoIWlzRW50ZXJPclNwYWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGlja0hhbmRsZXIoZSk7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBuZXN0ZWRMaW5rKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBBQ1RJVkVfTkVTVEVEX0xJTktfU0VMRUNUT1IpO1xuICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgbGluay5jbGljaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0RHJhd2VySXRlbUluZGV4KHRhcmdldCkge1xuICAgICAgICBjb25zdCBpdGVtID0gY2xvc2VzdEl0ZW0odGFyZ2V0LCBEUkFXRVJfSVRFTV9JTkRFWCwgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1JbmRleChpdGVtLCBEUkFXRVJfSVRFTV9JTkRFWCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBEcmF3ZXJMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBEcmF3ZXJMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEcmF3ZXJMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5pXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRHJhd2VyTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kZWRcIiwgdm9pZCAwKTtcbkRyYXdlckxpc3RDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RyYXdlckxpc3RdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtczsgbGV0IGlkeCA9IGluZGV4XCI+XG4gICAgICAgICAgICA8bGkgKm5nSWY9XCIhaXRlbS5zZXBhcmF0b3JcIiBrZW5kb0RyYXdlckl0ZW1cbiAgICAgICAgICAgICAgICBjbGFzcz1cImstZHJhd2VyLWl0ZW1cIlxuICAgICAgICAgICAgICAgIFtpdGVtXT1cIml0ZW1cIlxuICAgICAgICAgICAgICAgIFtpbmRleF09XCJpZHhcIlxuICAgICAgICAgICAgICAgIFttaW5pXT1cIm1pbmlcIlxuICAgICAgICAgICAgICAgIFtleHBhbmRlZF09XCJleHBhbmRlZFwiXG4gICAgICAgICAgICAgICAgW2l0ZW1UZW1wbGF0ZV09XCJpdGVtVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFthdHRyLiR7RFJBV0VSX0lURU1fSU5ERVh9XT1cImlkeFwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiaXRlbS5jc3NDbGFzc1wiXG4gICAgICAgICAgICAgICAgW25nU3R5bGVdPVwiaXRlbS5jc3NTdHlsZVwiXG4gICAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCI+XG4gICAgICAgICAgICA8L2xpPlxuXG4gICAgICAgICAgICA8bGkgKm5nSWY9XCJpdGVtLnNlcGFyYXRvclwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWRyYXdlci1pdGVtIGstZHJhd2VyLXNlcGFyYXRvclwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiaXRlbS5jc3NDbGFzc1wiXG4gICAgICAgICAgICAgICAgW25nU3R5bGVdPVwiaXRlbS5jc3NTdHlsZVwiPlxuICAgICAgICAgICAgICAgICZuYnNwO1xuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRHJhd2VyU2VydmljZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBFbGVtZW50UmVmXSlcbl0sIERyYXdlckxpc3RDb21wb25lbnQpO1xuXG5jb25zdCB0ZW1wbGF0ZURpcmVjdGl2ZXMgPSBbXG4gICAgRHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRHJhd2VySGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRHJhd2VyRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRHJhd2VySXRlbVRlbXBsYXRlRGlyZWN0aXZlXG5dO1xuY29uc3QgZXhwb3J0ZWRNb2R1bGVzJDIgPSBbXG4gICAgRHJhd2VyQ29tcG9uZW50LFxuICAgIERyYXdlckNvbnRhaW5lckNvbXBvbmVudCxcbiAgICBEcmF3ZXJDb250ZW50Q29tcG9uZW50LFxuICAgIC4uLnRlbXBsYXRlRGlyZWN0aXZlc1xuXTtcbmNvbnN0IGRlY2xhcmF0aW9ucyQyID0gW1xuICAgIERyYXdlckl0ZW1Db21wb25lbnQsXG4gICAgRHJhd2VyTGlzdENvbXBvbmVudCxcbiAgICAuLi5leHBvcnRlZE1vZHVsZXMkMlxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIERyYXdlciBjb21wb25lbnQuXG4gKi9cbmxldCBEcmF3ZXJNb2R1bGUgPSBjbGFzcyBEcmF3ZXJNb2R1bGUge1xufTtcbkRyYXdlck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbZGVjbGFyYXRpb25zJDJdLFxuICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWRNb2R1bGVzJDJdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxuICAgIH0pXG5dLCBEcmF3ZXJNb2R1bGUpO1xuXG5jb25zdCBleHBvcnRlZE1vZHVsZXMkMyA9IFtcbiAgICBFeHBhbnNpb25QYW5lbENvbXBvbmVudCxcbiAgICBFeHBhbnNpb25QYW5lbFRpdGxlRGlyZWN0aXZlXG5dO1xuY29uc3QgZGVjbGFyYXRpb25zJDMgPSBbXG4gICAgLi4uZXhwb3J0ZWRNb2R1bGVzJDNcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBFeHBhbnNpb25QYW5lbCBjb21wb25lbnQuXG4gKi9cbmxldCBFeHBhbnNpb25QYW5lbE1vZHVsZSA9IGNsYXNzIEV4cGFuc2lvblBhbmVsTW9kdWxlIHtcbn07XG5FeHBhbnNpb25QYW5lbE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbZGVjbGFyYXRpb25zJDNdLFxuICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWRNb2R1bGVzJDNdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBFdmVudHNNb2R1bGVdXG4gICAgfSlcbl0sIEV4cGFuc2lvblBhbmVsTW9kdWxlKTtcblxuY29uc3QgZXhwb3J0ZWRNb2R1bGVzJDQgPSBbXG4gICAgUGFuZWxCYXJDb21wb25lbnQsXG4gICAgUGFuZWxCYXJJdGVtQ29tcG9uZW50LFxuICAgIFBhbmVsQmFyQ29udGVudERpcmVjdGl2ZSxcbiAgICBQYW5lbEJhckl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBQYW5lbEJhckl0ZW1UaXRsZURpcmVjdGl2ZVxuXTtcbmNvbnN0IGRlY2xhcmF0aW9ucyQ0ID0gW1xuICAgIC4uLmV4cG9ydGVkTW9kdWxlcyQ0XG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgUGFuZWxCYXIgY29tcG9uZW50LlxuICpcbiAqIFRoZSBtb2R1bGUgcmVnaXN0ZXJzOlxuICogLSBgUGFuZWxCYXJDb21wb25lbnRgJm1kYXNoO1RoZSBgUGFuZWxCYXJgIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYFBhbmVsQmFySXRlbUNvbXBvbmVudGAmbWRhc2g7VGhlIGBQYW5lbEJhckl0ZW1gIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYFBhbmVsQmFyQ29udGVudENvbXBvbmVudGAmbWRhc2g7VGhlIGBQYW5lbEJhckNvbnRlbnRgIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYFBhbmVsQmFySXRlbVRlbXBsYXRlRGlyZWN0aXZlJm1kYXNoO1RoZSBgUGFuZWxCYXJJdGVtVGVtcGxhdGVgIGRpcmVjdGl2ZS5cbiAqIC0gYFBhbmVsQmFySXRlbVRpdGxlRGlyZWN0aXZlJm1kYXNoO1RoZSBgUGFuZWxCYXJJdGVtVGl0bGVgIGRpcmVjdGl2ZS5cbiAqL1xubGV0IFBhbmVsQmFyTW9kdWxlID0gY2xhc3MgUGFuZWxCYXJNb2R1bGUge1xufTtcblBhbmVsQmFyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtkZWNsYXJhdGlvbnMkNF0sXG4gICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZE1vZHVsZXMkNF0sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdXG4gICAgfSlcbl0sIFBhbmVsQmFyTW9kdWxlKTtcblxuY29uc3QgZXhwb3J0ZWRNb2R1bGVzJDUgPSBbXG4gICAgU3BsaXR0ZXJDb21wb25lbnQsXG4gICAgU3BsaXR0ZXJQYW5lQ29tcG9uZW50XG5dO1xuY29uc3QgZGVjbGFyYXRpb25zJDUgPSBbXG4gICAgU3BsaXR0ZXJCYXJDb21wb25lbnQsXG4gICAgLi4uZXhwb3J0ZWRNb2R1bGVzJDVcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBTcGxpdHRlciBjb21wb25lbnQuXG4gKlxuICogVGhlIG1vZHVsZSByZWdpc3RlcnM6XG4gKiAtIGBTcGxpdHRlckNvbXBvbmVudGAmbWRhc2g7VGhlIGBTcGxpdHRlcmAgY29tcG9uZW50IGNsYXNzLlxuICogLSBgU3BsaXR0ZXJQYW5lQ29tcG9uZW50YCZtZGFzaDtUaGUgYFNwbGl0dGVyUGFuZWAgY29tcG9uZW50IGNsYXNzLlxuICovXG5sZXQgU3BsaXR0ZXJNb2R1bGUgPSBjbGFzcyBTcGxpdHRlck1vZHVsZSB7XG59O1xuU3BsaXR0ZXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9ucyQ1XSxcbiAgICAgICAgZXhwb3J0czogW2V4cG9ydGVkTW9kdWxlcyQ1XSxcbiAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgRHJhZ2dhYmxlTW9kdWxlXG4gICAgICAgIF1cbiAgICB9KVxuXSwgU3BsaXR0ZXJNb2R1bGUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFN0ZXBwZXJTdGVwQ29tcG9uZW50ID0gY2xhc3MgU3RlcHBlclN0ZXBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UsIGxvY2FsaXphdGlvbiwgbmdab25lKSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5pc1N0ZXBWYWxpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaG91bGRDaGVja1ZhbGlkaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5zdWJzID0gdGhpcy5zZXJ2aWNlLmZvY3VzZWRTdGVwQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRm9jdXNlZFN0ZXBDaGFuZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5zZXJ2aWNlLnRyaWdnZXJWYWxpZGF0aW9uLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVZhbGlkaXR5Q2hlY2tzKCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0IGVycm9yU3RlcENsYXNzKCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaXNTdGVwVmFsaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuaXNTdGVwVmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgc3VjY2Vzc1N0ZXBDbGFzcygpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmlzU3RlcFZhbGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTdGVwVmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVWYWxpZGl0eUNoZWNrcygpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmN1cnJlbnQgJiYgIWNoYW5nZXMuY3VycmVudC5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVWYWxpZGl0eUNoZWNrcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkZvY3VzZWRTdGVwQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5zZXJ2aWNlLmZvY3VzZWRTdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwTGluay5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbkZvY3VzKCkge1xuICAgICAgICB0aGlzLnNlcnZpY2UuZm9jdXModGhpcy5pbmRleCk7XG4gICAgfVxuICAgIGdldCB0YWJJbmRleEF0dHIoKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuc2VydmljZS5mb2N1c2VkU3RlcCB8fCB0aGlzLnNlcnZpY2UuY3VycmVudFN0ZXA7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ID09PSBhY3RpdmUgPyAwIDogLTE7XG4gICAgfVxuICAgIGdldCBpbmRpY2F0b3JJY29uQ2xhc3NlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RlcC5pY29uKSB7XG4gICAgICAgICAgICByZXR1cm4gYGstaWNvbiBrLWktJHt0aGlzLnN0ZXAuaWNvbn1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0ZXAuaWNvbkNsYXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5zdGVwLmljb25DbGFzc31gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3VsZENoZWNrVmFsaWRpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRpb25JY29uQ2xhc3NlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2hvd0luZGljYXRvckljb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZENoZWNrVmFsaWRpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0ZXAuaWNvbiB8fCB0aGlzLnN0ZXAuaWNvbkNsYXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBzaG93TGFiZWxJY29uKCkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRDaGVja1ZhbGlkaXR5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbGFiZWwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGVwLmljb24gfHwgdGhpcy5zdGVwLmljb25DbGFzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHNob3dMYWJlbFRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdsYWJlbCcgfHwgdGhpcy50eXBlID09PSAnZnVsbCc7XG4gICAgfVxuICAgIGdldCB2YWxpZGF0aW9uSWNvbkNsYXNzZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RlcFZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWNjZXNzSWNvbiA/IGAke3RoaXMuc3VjY2Vzc0ljb259YCA6ICdrLWljb24gay1pLWNoZWNrJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9ySWNvbiA/IGAke3RoaXMuZXJyb3JJY29ufWAgOiAnay1pY29uIGstaS13YXJuaW5nJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaW5kaWNhdG9yVGV4dCgpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMuc3RlcC50ZXh0O1xuICAgICAgICByZXR1cm4gdGV4dCA/IHRleHQgOiB0aGlzLmluZGV4ICsgMTtcbiAgICB9XG4gICAgdXBkYXRlU3RlcFZhbGlkaXR5KCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3RlcC5pc1ZhbGlkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXAuaXNWYWxpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3RlcC5pc1ZhbGlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwLmlzVmFsaWQodGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IHNob3dJbmRpY2F0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdpbmRpY2F0b3InIHx8IHRoaXMudHlwZSA9PT0gJ2Z1bGwnO1xuICAgIH1cbiAgICBnZXQgc2hvd0xhYmVsKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbGFiZWwnIHx8IHRoaXMudHlwZSA9PT0gJ2Z1bGwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGVwLm9wdGlvbmFsO1xuICAgIH1cbiAgICBnZXQgb3B0aW9uYWxUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdvcHRpb25hbCcpO1xuICAgIH1cbiAgICBnZXQgdHJhbnNpdGlvbkR1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLm93bmVyLmFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIH1cbiAgICBfc2hvdWxkQ2hlY2tWYWxpZGl0eSgpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0ZXAudmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3RlcC52YWxpZGF0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcC52YWxpZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdGVwLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcC52YWxpZGF0ZSh0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuc3RlcC5pc1ZhbGlkKSAmJiB0aGlzLmluZGV4IDwgdGhpcy5jdXJyZW50O1xuICAgIH1cbiAgICBoYW5kbGVWYWxpZGl0eUNoZWNrcygpIHtcbiAgICAgICAgdGhpcy5pc1N0ZXBWYWxpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaG91bGRDaGVja1ZhbGlkaXR5ID0gdGhpcy5fc2hvdWxkQ2hlY2tWYWxpZGl0eSgpO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRDaGVja1ZhbGlkaXR5KSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RlcFZhbGlkID0gdGhpcy51cGRhdGVTdGVwVmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTdGVwcGVyU3RlcENvbXBvbmVudC5wcm90b3R5cGUsIFwic3RlcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU3RlcHBlclN0ZXBDb21wb25lbnQucHJvdG90eXBlLCBcImluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTdGVwcGVyU3RlcENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VycmVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3RlcHBlclN0ZXBDb21wb25lbnQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFN0ZXBwZXJTdGVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdWNjZXNzSWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3RlcHBlclN0ZXBDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9ySWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBTdGVwcGVyU3RlcENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5kaWNhdG9yVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgU3RlcHBlclN0ZXBDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgU3RlcHBlclN0ZXBDb21wb25lbnQucHJvdG90eXBlLCBcInN0ZXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdzdGVwTGluaycsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgU3RlcHBlclN0ZXBDb21wb25lbnQucHJvdG90eXBlLCBcInN0ZXBMaW5rXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGVwLWVycm9yJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFN0ZXBwZXJTdGVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvclN0ZXBDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXN0ZXAtc3VjY2VzcycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBTdGVwcGVyU3RlcENvbXBvbmVudC5wcm90b3R5cGUsIFwic3VjY2Vzc1N0ZXBDbGFzc1wiLCBudWxsKTtcblN0ZXBwZXJTdGVwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9TdGVwcGVyU3RlcF0nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YSBocmVmPScjJyBjbGFzcz0nay1zdGVwLWxpbmsnICNzdGVwTGlua1xuICAgICAgICAgICAgW2F0dHIudGFiaW5kZXhdPSd0YWJJbmRleEF0dHInXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09J3N0ZXAubGFiZWwnXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT0nc3RlcC5kaXNhYmxlZCdcbiAgICAgICAgICAgIFthdHRyLmFyaWEtY3VycmVudF09J2luZGV4ID09PSBjdXJyZW50ID8gXCJzdGVwXCIgOiBudWxsJ1xuICAgICAgICAgICAgKGZvY3VzKT0nb25Gb2N1cygpJ1xuICAgICAgICA+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9J3N0ZXBUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09J3N0ZXBUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPSd7ICRpbXBsaWNpdDogc3RlcCwgaW5kZXg6IGluZGV4IH0nPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj0nIXN0ZXBUZW1wbGF0ZSc+XG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9J3Nob3dJbmRpY2F0b3InXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPSdrLXN0ZXAtaW5kaWNhdG9yJ1xuICAgICAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbj0ndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLnRyYW5zaXRpb24tZHVyYXRpb24ubXNdPSd0cmFuc2l0aW9uRHVyYXRpb24nXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9J2luZGljYXRvclRlbXBsYXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPSdpbmRpY2F0b3JUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09J3sgJGltcGxpY2l0OiBzdGVwLCBpbmRleDogaW5kZXggfSc+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj0nIWluZGljYXRvclRlbXBsYXRlJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPSdzaG93SW5kaWNhdG9ySWNvbicgY2xhc3M9J2stc3RlcC1pbmRpY2F0b3ItaWNvbicgW25nQ2xhc3NdPSdpbmRpY2F0b3JJY29uQ2xhc3Nlcyc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2stc3RlcC1pbmRpY2F0b3ItdGV4dCcgKm5nSWY9JyFzaG93SW5kaWNhdG9ySWNvbic+e3sgaW5kaWNhdG9yVGV4dCB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2stc3RlcC1sYWJlbCcgKm5nSWY9J3Nob3dMYWJlbCc+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj0nbGFiZWxUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT0nbGFiZWxUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09J3sgJGltcGxpY2l0OiBzdGVwLCBpbmRleDogaW5kZXggfSc+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj0nIWxhYmVsVGVtcGxhdGUnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2stc3RlcC10ZXh0JyAqbmdJZj0nc2hvd0xhYmVsVGV4dCc+e3sgc3RlcC5sYWJlbCB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIFtuZ0NsYXNzXT0ndmFsaWRhdGlvbkljb25DbGFzc2VzJyAqbmdJZj0nc2hvd0xhYmVsSWNvbicgYXJpYS1oaWRkZW49J3RydWUnPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdrLXN0ZXAtbGFiZWwtb3B0aW9uYWwnICpuZ0lmPSdzdGVwLm9wdGlvbmFsJz4oe3tvcHRpb25hbFRleHR9fSk8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2E+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RlcHBlclNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBTdGVwcGVyU3RlcENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBTVEVQUEVSX1NURVBfSU5ERVggPSAnZGF0YS1rZW5kby1zdGVwcGVyLWluZGV4JztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTdGVwcGVyTGlzdENvbXBvbmVudCA9IGNsYXNzIFN0ZXBwZXJMaXN0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgbmdab25lLCBzZXJ2aWNlLCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmluaXREb21FdmVudHMoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbVN1YnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tU3VicygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtYXhTdGVwV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heFN0ZXBEaW1lbnNpb24oJ3dpZHRoJyk7XG4gICAgfVxuICAgIGdldCBtYXhTdGVwSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhTdGVwRGltZW5zaW9uKCdoZWlnaHQnKTtcbiAgICB9XG4gICAgbWF4U3RlcERpbWVuc2lvbihkaW1lbnNpb24pIHtcbiAgICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gJ3dpZHRoJyAmJiB0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltZW5zaW9uID09PSAnaGVpZ2h0JyAmJiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxMDAgLyB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICB9XG4gICAgaW5pdERvbUV2ZW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBjbGlja1N1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKG5hdGl2ZUVsZW1lbnQsICdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgY29uc3Qga2V5ZG93blN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKG5hdGl2ZUVsZW1lbnQsICdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MoZS50YXJnZXQsICdrLXN0ZXAtbGluaycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZS5rZXlkb3duKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kb21TdWJzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsaWNrU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAga2V5ZG93blN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3Qgc3RlcElkeCA9IHRoaXMuZ2V0U3RlcEluZGV4KGUudGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuc3RlcHNbc3RlcElkeF07XG4gICAgICAgIGlmICghc3RlcCB8fCBzdGVwLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ZXBJZHggPT09IHRoaXMuY3VycmVudFN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS5mb2N1cyhzdGVwSWR4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lYXIgJiYgdGhpcy5zZXJ2aWNlLmlzUHJldk9yTmV4dFN0ZXAoc3RlcElkeCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2aWNlLm9uQWN0aXZhdGUoc3RlcElkeCwgZSk7XG4gICAgfVxuICAgIGdldFN0ZXBJbmRleCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IGNsb3Nlc3RJdGVtKHRhcmdldCwgU1RFUFBFUl9TVEVQX0lOREVYLCB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbUluZGV4KHN0ZXAsIFNURVBQRVJfU1RFUF9JTkRFWCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFN0ZXBwZXJMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsaW5lYXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFN0ZXBwZXJMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwVHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3RlcHBlckxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTdGVwcGVyTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VycmVudFN0ZXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgU3RlcHBlckxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInN0ZXBzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTdGVwcGVyTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwic3VjY2Vzc0ljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFN0ZXBwZXJMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvckljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgU3RlcHBlckxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImluZGljYXRvclRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIFN0ZXBwZXJMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIFN0ZXBwZXJMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwVGVtcGxhdGVcIiwgdm9pZCAwKTtcblN0ZXBwZXJMaXN0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9TdGVwcGVyTGlzdF0nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj0nbGV0IHN0ZXAgb2Ygc3RlcHM7IGxldCBpZHggPSBpbmRleCc+XG4gICAgICAgICAgICA8bGkga2VuZG9TdGVwcGVyU3RlcFxuICAgICAgICAgICAgICAgIFthdHRyLiR7U1RFUFBFUl9TVEVQX0lOREVYfV09J2lkeCdcbiAgICAgICAgICAgICAgICBbdHlwZV09J3N0ZXBUeXBlJ1xuICAgICAgICAgICAgICAgIFtzdGVwXT0nc3RlcCdcbiAgICAgICAgICAgICAgICBbaW5kZXhdPSdpZHgnXG4gICAgICAgICAgICAgICAgW2N1cnJlbnRdPSdjdXJyZW50U3RlcCdcbiAgICAgICAgICAgICAgICBbc3VjY2Vzc0ljb25dPSdzdWNjZXNzSWNvbidcbiAgICAgICAgICAgICAgICBbZXJyb3JJY29uXT0nZXJyb3JJY29uJ1xuICAgICAgICAgICAgICAgIFtpbmRpY2F0b3JUZW1wbGF0ZV09J2luZGljYXRvclRlbXBsYXRlJ1xuICAgICAgICAgICAgICAgIFtsYWJlbFRlbXBsYXRlXT0nbGFiZWxUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICBbc3RlcFRlbXBsYXRlXT0nc3RlcFRlbXBsYXRlJ1xuICAgICAgICAgICAgICAgIGNsYXNzPSdrLXN0ZXAnXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstc3RlcC1maXJzdF09J2lkeCA9PT0gMCdcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGVwLWxhc3RdPSdpZHggPT09IHN0ZXBzLmxlbmd0aCAtIDEnXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstc3RlcC1kb25lXT0naWR4IDwgY3VycmVudFN0ZXAnXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstc3RlcC1jdXJyZW50XT0naWR4ID09PSBjdXJyZW50U3RlcCdcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGVwLW9wdGlvbmFsXT0nc3RlcC5vcHRpb25hbCdcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGVwLWRpc2FibGVkXT0nc3RlcC5kaXNhYmxlZCdcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109J3N0ZXAuY3NzQ2xhc3MnXG4gICAgICAgICAgICAgICAgW25nU3R5bGVdPSdzdGVwLmNzc1N0eWxlJ1xuICAgICAgICAgICAgICAgIFtzdHlsZS5tYXgtd2lkdGguJV0gPSAnbWF4U3RlcFdpZHRoJ1xuICAgICAgICAgICAgICAgIFtzdHlsZS5tYXgtaGVpZ2h0LiVdID0gJ21heFN0ZXBIZWlnaHQnXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgU3RlcHBlclNlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRSZWZdKVxuXSwgU3RlcHBlckxpc3RDb21wb25lbnQpO1xuXG5jb25zdCB0ZW1wbGF0ZURpcmVjdGl2ZXMkMSA9IFtcbiAgICBTdGVwcGVyU3RlcFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIFN0ZXBwZXJMYWJlbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIFN0ZXBwZXJJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZVxuXTtcbmNvbnN0IGV4cG9ydGVkTW9kdWxlcyQ2ID0gW1xuICAgIFN0ZXBwZXJDb21wb25lbnQsXG4gICAgU3RlcHBlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgIC4uLnRlbXBsYXRlRGlyZWN0aXZlcyQxXG5dO1xuY29uc3QgZGVjbGFyYXRpb25zJDYgPSBbXG4gICAgU3RlcHBlclN0ZXBDb21wb25lbnQsXG4gICAgU3RlcHBlckxpc3RDb21wb25lbnQsXG4gICAgTG9jYWxpemVkU3RlcHBlck1lc3NhZ2VzRGlyZWN0aXZlLFxuICAgIC4uLmV4cG9ydGVkTW9kdWxlcyQ2XG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgU3RlcHBlciBjb21wb25lbnQuXG4gKi9cbmxldCBTdGVwcGVyTW9kdWxlID0gY2xhc3MgU3RlcHBlck1vZHVsZSB7XG59O1xuU3RlcHBlck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbZGVjbGFyYXRpb25zJDZdLFxuICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWRNb2R1bGVzJDZdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBQcm9ncmVzc0Jhck1vZHVsZV1cbiAgICB9KVxuXSwgU3RlcHBlck1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVGFiQ29tcG9uZW50ID0gY2xhc3MgVGFiQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIHRhYnN0cmlwU2VydmljZSkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy50YWJzdHJpcFNlcnZpY2UgPSB0YWJzdHJpcFNlcnZpY2U7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYi5zZWxlY3RlZDtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYi5kaXNhYmxlZDtcbiAgICB9XG4gICAgZ2V0IGZvY3VzZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiLmZvY3VzZWQ7XG4gICAgfVxuICAgIGdldCB0YWJJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiLnNlbGVjdGVkIHx8IHRoaXMudGFiLmZvY3VzZWQgPyAwIDogLTE7XG4gICAgfVxuICAgIGdldCB0YWJDbG9zYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGFiLmNsb3NhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYi5jbG9zYWJsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50YWJTdHJpcENsb3NhYmxlO1xuICAgIH1cbiAgICBnZXQgY2xvc2VCdXR0b25DbGFzc2VzKCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMudGFiLmNsb3NlSWNvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYi5jbG9zZUljb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGFiU3RyaXBDbG9zZUljb247XG4gICAgfVxuICAgIGdldCBjbG9zZUJ1dHRvblRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdjbG9zZVRpdGxlJyk7XG4gICAgfVxuICAgIGNsb3NlVGFiKGluZGV4KSB7XG4gICAgICAgIHRoaXMudGFic3RyaXBTZXJ2aWNlLm9uVGFiQ2xvc2UodGhpcy50YWIsIGluZGV4KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGFiU3RyaXBUYWJDb21wb25lbnQpXG5dLCBUYWJDb21wb25lbnQucHJvdG90eXBlLCBcInRhYlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVGFiQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiU3RyaXBDbG9zYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGFiQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJTdHJpcENsb3NlSWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstaXRlbScpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXN0YXRlLWRlZmF1bHQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtc2VsZWN0ZWRdJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc3RhdGUtYWN0aXZlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLWRpc2FibGVkXScpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXN0YXRlLWRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXN0YXRlLWZvY3VzZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVGFiQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c2VkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgbnVsbCk7XG5UYWJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RhYlN0cmlwVGFiXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiay1saW5rXCIgKm5nSWY9XCIhdGFiLnRhYlRpdGxlXCI+e3sgdGFiLnRpdGxlIH19PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImstbGlua1wiICpuZ0lmPVwidGFiLnRhYlRpdGxlXCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwidGFiLnRhYlRpdGxlPy50ZW1wbGF0ZVJlZlwiPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImstcmVtb3ZlLXRhYiBrLWJ1dHRvbiBrLWljb24tYnV0dG9uIGstZmxhdFwiICpuZ0lmPVwidGFiQ2xvc2FibGVcIlxuICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBbdGl0bGVdPVwiY2xvc2VCdXR0b25UaXRsZVwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImNsb3NlQnV0dG9uVGl0bGVcIlxuICAgICAgICAgICAgKGNsaWNrKT1cImNsb3NlVGFiKGluZGV4KVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIFtuZ0NsYXNzXT1cImNsb3NlQnV0dG9uQ2xhc3Nlc1wiPjwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIFRhYlN0cmlwU2VydmljZV0pXG5dLCBUYWJDb21wb25lbnQpO1xuXG5jb25zdCBleHBvcnRlZE1vZHVsZXMkNyA9IFtcbiAgICBUYWJTdHJpcENvbXBvbmVudCxcbiAgICBUYWJTdHJpcFRhYkNvbXBvbmVudCxcbiAgICBUYWJDb250ZW50RGlyZWN0aXZlLFxuICAgIFRhYlRpdGxlRGlyZWN0aXZlLFxuICAgIFRhYkNvbXBvbmVudCxcbiAgICBUYWJTdHJpcEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgIExvY2FsaXplZFRhYlN0cmlwTWVzc2FnZXNEaXJlY3RpdmVcbl07XG5jb25zdCBkZWNsYXJhdGlvbnMkNyA9IFtcbiAgICAuLi5leHBvcnRlZE1vZHVsZXMkNyxcbiAgICBUYWJTdHJpcFNjcm9sbGFibGVCdXR0b25Db21wb25lbnRcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBUYWJTdHJpcCBjb21wb25lbnQuXG4gKlxuICogVGhlIG1vZHVsZSByZWdpc3RlcnM6XG4gKiAtIGBUYWJTdHJpcENvbXBvbmVudGAmbWRhc2g7VGhlIGBUYWJTdHJpcGAgY29tcG9uZW50IGNsYXNzLlxuICogLSBgVGFiU3RyaXBUYWJDb21wb25lbnRgJm1kYXNoO1RoZSBgVGFiU3RyaXBUYWJgIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYFRhYkNvbnRlbnREaXJlY3RpdmVgJm1kYXNoO1RoZSB0YWIgY29udGVudCBkaXJlY3RpdmUgdXNlZCBvbiB0aGUgYDxuZy10ZW1wbGF0ZT5gIHRhZy5cbiAqIC0gYFRhYlRpdGxlRGlyZWN0aXZlYCZtZGFzaDtUaGUgdGFiIHRpdGxlIGRpcmVjdGl2ZSB1c2VkIG9uIHRoZSBgPG5nLXRlbXBsYXRlPmAgdGFnLlxuICovXG5sZXQgVGFiU3RyaXBNb2R1bGUgPSBjbGFzcyBUYWJTdHJpcE1vZHVsZSB7XG59O1xuVGFiU3RyaXBNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9ucyQ3XSxcbiAgICAgICAgZXhwb3J0czogW2V4cG9ydGVkTW9kdWxlcyQ3XSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgUmVzaXplU2Vuc29yTW9kdWxlXVxuICAgIH0pXG5dLCBUYWJTdHJpcE1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVGlsZUxheW91dFJlc2l6ZUhhbmRsZURpcmVjdGl2ZSA9IGNsYXNzIFRpbGVMYXlvdXRSZXNpemVIYW5kbGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc2l6ZUhhbmRsZSgpO1xuICAgIH1cbiAgICBzZXRIb3Jpem9udGFsUG9zaXRpb24oZWxlbWVudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsIHRoaXMucnRsID8gJ2xlZnQnIDogJ3JpZ2h0JywgLVJFU0laRV9IQU5ETEVfRElNRU5TSU9OU1t0aGlzLnJlc2l6ZURpcmVjdGlvbl0ub3ZlcmxhcFggKyAncHgnKTtcbiAgICB9XG4gICAgc2V0Qm90dG9tKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbGVtZW50LCAnYm90dG9tJywgLVJFU0laRV9IQU5ETEVfRElNRU5TSU9OU1t0aGlzLnJlc2l6ZURpcmVjdGlvbl0ub3ZlcmxhcFkgKyAncHgnKTtcbiAgICB9XG4gICAgc2l6ZUhhbmRsZSgpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgaGFuZGxlV2lkdGggPSBSRVNJWkVfSEFORExFX0RJTUVOU0lPTlNbdGhpcy5yZXNpemVEaXJlY3Rpb25dLndpZHRoID9cbiAgICAgICAgICAgIGAke1JFU0laRV9IQU5ETEVfRElNRU5TSU9OU1t0aGlzLnJlc2l6ZURpcmVjdGlvbl0ud2lkdGh9cHhgIDogJzEwMCUnO1xuICAgICAgICBjb25zdCBoYW5kbGVIZWlnaHQgPSBSRVNJWkVfSEFORExFX0RJTUVOU0lPTlNbdGhpcy5yZXNpemVEaXJlY3Rpb25dLmhlaWdodCA/XG4gICAgICAgICAgICBgJHtSRVNJWkVfSEFORExFX0RJTUVOU0lPTlNbdGhpcy5yZXNpemVEaXJlY3Rpb25dLmhlaWdodH1weGAgOiAnMTAwJSc7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWxlbWVudCwgJ3dpZHRoJywgaGFuZGxlV2lkdGgpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsICdoZWlnaHQnLCBoYW5kbGVIZWlnaHQpO1xuICAgICAgICBpZiAodGhpcy5yZXNpemVEaXJlY3Rpb24gPT09ICdldycpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SG9yaXpvbnRhbFBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplRGlyZWN0aW9uID09PSAnbnMnKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJvdHRvbShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SG9yaXpvbnRhbFBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRCb3R0b20oZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGlsZUxheW91dFJlc2l6ZUhhbmRsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwicmVzaXplRGlyZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGlsZUxheW91dFJlc2l6ZUhhbmRsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwicnRsXCIsIHZvaWQgMCk7XG5UaWxlTGF5b3V0UmVzaXplSGFuZGxlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UaWxlTGF5b3V0UmVzaXplSGFuZGxlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBUaWxlTGF5b3V0UmVzaXplSGFuZGxlRGlyZWN0aXZlKTtcblxuY29uc3QgZXhwb3J0ZWRNb2R1bGVzJDggPSBbXG4gICAgVGlsZUxheW91dENvbXBvbmVudCxcbiAgICBUaWxlTGF5b3V0SXRlbUNvbXBvbmVudCxcbiAgICBUaWxlTGF5b3V0SXRlbUhlYWRlckNvbXBvbmVudCxcbiAgICBUaWxlTGF5b3V0SXRlbUJvZHlDb21wb25lbnQsXG4gICAgVGlsZUxheW91dFJlc2l6ZUhhbmRsZURpcmVjdGl2ZVxuXTtcbmNvbnN0IGRlY2xhcmF0aW9ucyQ4ID0gW1xuICAgIC4uLmV4cG9ydGVkTW9kdWxlcyQ4XG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgVGlsZUxheW91dCBjb21wb25lbnQuXG4gKlxuICogVGhlIG1vZHVsZSByZWdpc3RlcnM6XG4gKiAtIGBUaWxlTGF5b3V0Q29tcG9uZW50YCZtZGFzaDtUaGUgYFRpbGVMYXlvdXRDb21wb25lbnRgIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYFRpbGVMYXlvdXRJdGVtQ29tcG9uZW50YCZtZGFzaDtUaGUgYFRpbGVMYXlvdXRJdGVtQ29tcG9uZW50YCBjb21wb25lbnQgY2xhc3MuXG4gKiAtIGBUaWxlTGF5b3V0SXRlbUhlYWRlckNvbXBvbmVudGAmbWRhc2g7VGhlIGBUaWxlTGF5b3V0SXRlbUhlYWRlckNvbXBvbmVudGAgY29tcG9uZW50IGNsYXNzLlxuICogLSBgVGlsZUxheW91dEl0ZW1Cb2R5Q29tcG9uZW50YCZtZGFzaDtUaGUgYFRpbGVMYXlvdXRJdGVtQm9keUNvbXBvbmVudGAgY29tcG9uZW50IGNsYXNzLlxuICovXG5sZXQgVGlsZUxheW91dE1vZHVsZSA9IGNsYXNzIFRpbGVMYXlvdXRNb2R1bGUge1xufTtcblRpbGVMYXlvdXRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9ucyQ4XSxcbiAgICAgICAgZXhwb3J0czogW2V4cG9ydGVkTW9kdWxlcyQ4XSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICB9KVxuXSwgVGlsZUxheW91dE1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBWRVJUSUNBTF9TVUZGSVggPSB7XG4gICAgdG9wOiAnc3RhcnQnLFxuICAgIG1pZGRsZTogJ2NlbnRlcicsXG4gICAgYm90dG9tOiAnZW5kJyxcbiAgICBzdHJldGNoOiAnc3RyZXRjaCdcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgSlVTVElGWV9QUkVGSVggPSBgay1qdXN0aWZ5LWNvbnRlbnRgO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEdSSURfSlVTVElGWV9QUkVGSVggPSBgay1qdXN0aWZ5LWl0ZW1zYDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBBTElHTl9QUkVGSVggPSBgay1hbGlnbi1pdGVtc2A7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgbm9ybWFsaXplR2FwID0gKGdhcCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2FwID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZ2FwID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geyBjb2xzOiBnYXAsIHJvd3M6IGdhcCB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHBhcnNlZEdhcCA9IHt9O1xuICAgICAgICBwYXJzZWRHYXAucm93cyA9IGdhcC5yb3dzID8gZ2FwLnJvd3MgOiAwO1xuICAgICAgICBwYXJzZWRHYXAuY29scyA9IGdhcC5jb2xzID8gZ2FwLmNvbHMgOiAwO1xuICAgICAgICByZXR1cm4gcGFyc2VkR2FwO1xuICAgIH1cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2VuZXJhdGVHYXBTdHlsZSA9IChnYXApID0+IHtcbiAgICBpZiAoZ2FwLnJvd3MgPT09IGdhcC5jb2xzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZ2FwLnJvd3MgPT09ICdudW1iZXInID8gYCR7Z2FwLnJvd3N9cHhgIDogZ2FwLnJvd3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgcm93U3R5bGUgPSBgJHt0eXBlb2YgZ2FwLnJvd3MgPT09ICdudW1iZXInID8gZ2FwLnJvd3MgKyAncHgnIDogZ2FwLnJvd3N9YDtcbiAgICAgICAgbGV0IGNvbFN0eWxlID0gYCR7dHlwZW9mIGdhcC5jb2xzID09PSAnbnVtYmVyJyA/IGdhcC5jb2xzICsgJ3B4JyA6IGdhcC5jb2xzfWA7XG4gICAgICAgIHJldHVybiBgJHtyb3dTdHlsZX0gJHtjb2xTdHlsZX1gO1xuICAgIH1cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2VuZXJhdGVHcmlkU3R5bGUgPSAoaXRlbXMsIGl0ZW1UeXBlKSA9PiB7XG4gICAgbGV0IHN0eWxpbmcgPSBbXTtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHN0eWxpbmcucHVzaChgJHtpdGVtfXB4YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdHlsaW5nLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXRlbVR5cGUgPT09ICdyb3dzJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd0hlaWdodCA9IGl0ZW0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChyb3dIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGluZy5wdXNoKHR5cGVvZiByb3dIZWlnaHQgPT09ICdudW1iZXInID8gYCR7cm93SGVpZ2h0fXB4YCA6IHJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsaW5nLnB1c2goJzBweCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbFdpZHRoID0gaXRlbS53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoY29sV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGluZy5wdXNoKHR5cGVvZiBjb2xXaWR0aCA9PT0gJ251bWJlcicgPyBgJHtjb2xXaWR0aH1weGAgOiBjb2xXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsaW5nLnB1c2goJzBweCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHlsaW5nO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB2YWxpZGF0ZUdyaWRMYXlvdXRSb3dzQ29scyA9IChhcnIpID0+IHtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIGFycikge1xuICAgICAgICBjb25zdCBpc051bSA9IHR5cGVvZiBlbCA9PT0gJ251bWJlcic7XG4gICAgICAgIGNvbnN0IGlzU3RyID0gdHlwZW9mIGVsID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgaXNPYmplY3QgPSB0eXBlb2YgZWwgPT09ICdvYmplY3QnICYmIGVsICE9PSBudWxsO1xuICAgICAgICBpZiAoIWlzTnVtICYmICFpc1N0ciAmJiAhaXNPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIFN0YWNrTGF5b3V0IGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19zdGFja2xheW91dCAlfSkuXG4gKi9cbmxldCBTdGFja0xheW91dENvbXBvbmVudCA9IGNsYXNzIFN0YWNrTGF5b3V0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgZWxlbWVudCwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgZ2FwIGJldHdlZW4gdGhlIGlubmVyIFN0YWNrTGF5b3V0IGVsZW1lbnRzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgMGBcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBsYXlvdXRfc3RhY2tsYXlvdXQgJX0jdG9jLWdhcHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2FwID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgb3JpZW50YXRpb24gb2YgdGhlIFN0YWNrTGF5b3V0XG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbGF5b3V0X3N0YWNrbGF5b3V0ICV9I3RvYy1vcmllbnRhdGlvbikpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKERlZmF1bHQpIGBob3Jpem9udGFsYFxuICAgICAgICAgKiBgdmVydGljYWxgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnO1xuICAgICAgICB0aGlzLl9hbGlnbiA9IHtcbiAgICAgICAgICAgIGhvcml6b250YWw6ICdzdHJldGNoJyxcbiAgICAgICAgICAgIHZlcnRpY2FsOiAnc3RyZXRjaCdcbiAgICAgICAgfTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldCBob3Jpem9udGFsQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIGdldCB2ZXJ0aWNhbENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJztcbiAgICB9XG4gICAgZ2V0IGRpcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgaW5uZXIgU3RhY2tMYXlvdXQgZWxlbWVudHNcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGxheW91dF9zdGFja2xheW91dCAlfSN0b2MtYWxpZ25tZW50KSkuXG4gICAgICovXG4gICAgc2V0IGFsaWduKGFsaWduKSB7XG4gICAgICAgIHRoaXMuX2FsaWduID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fYWxpZ24sIGFsaWduKTtcbiAgICAgICAgdGhpcy5oYW5kbGVBbGlnbkNsYXNzZXMoKTtcbiAgICB9XG4gICAgZ2V0IGFsaWduKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVBbGlnbkNsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5zZXRHYXAoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdnYXAnLCBjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRHYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdvcmllbnRhdGlvbicsIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUFsaWduQ2xhc3NlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUFsaWduQ2xhc3NlcygpIHtcbiAgICAgICAgY29uc3QgZWxlbSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuanVzdGlmeUNsYXNzKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtLCB0aGlzLmp1c3RpZnlDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmFsaWduQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW0sIHRoaXMuYWxpZ25DbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5qdXN0aWZ5Q2xhc3MgPSBgJHtKVVNUSUZZX1BSRUZJWH0tJHt0aGlzLmFsaWduLmhvcml6b250YWx9YDtcbiAgICAgICAgICAgIHRoaXMuYWxpZ25DbGFzcyA9IGAke0FMSUdOX1BSRUZJWH0tJHtWRVJUSUNBTF9TVUZGSVhbdGhpcy5hbGlnbi52ZXJ0aWNhbF19YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuanVzdGlmeUNsYXNzID0gYCR7SlVTVElGWV9QUkVGSVh9LSR7VkVSVElDQUxfU1VGRklYW3RoaXMuYWxpZ24udmVydGljYWxdfWA7XG4gICAgICAgICAgICB0aGlzLmFsaWduQ2xhc3MgPSBgJHtBTElHTl9QUkVGSVh9LSR7dGhpcy5hbGlnbi5ob3Jpem9udGFsfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbGVtLCB0aGlzLmp1c3RpZnlDbGFzcyk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbSwgdGhpcy5hbGlnbkNsYXNzKTtcbiAgICB9XG4gICAgc2V0R2FwKCkge1xuICAgICAgICBjb25zdCBwYXJzZWRHYXAgPSBpc051bWJlcih0aGlzLmdhcCkgPyBgJHt0aGlzLmdhcH1weGAgOiB0aGlzLmdhcDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2dhcCcsIHBhcnNlZEdhcCk7XG4gICAgfVxuICAgIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGFjay1sYXlvdXQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFN0YWNrTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0Q2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWhzdGFjaycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBTdGFja0xheW91dENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9yaXpvbnRhbENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdnN0YWNrJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFN0YWNrTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgU3RhY2tMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcImRpclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgU3RhY2tMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcImFsaWduXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU3RhY2tMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcImdhcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3RhY2tMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XG5TdGFja0xheW91dENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9TdGFja0xheW91dCcsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tc3RhY2tsYXlvdXQnLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5zdGFja2xheW91dCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JlbmRlcmVyMixcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBTdGFja0xheW91dENvbXBvbmVudCk7XG5cbmNvbnN0IGV4cG9ydGVkTW9kdWxlcyQ5ID0gW1xuICAgIFN0YWNrTGF5b3V0Q29tcG9uZW50XG5dO1xuY29uc3QgZGVjbGFyYXRpb25zJDkgPSBbXG4gICAgLi4uZXhwb3J0ZWRNb2R1bGVzJDlcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBTdGFja0xheW91dCBjb21wb25lbnQuXG4gKi9cbmxldCBTdGFja0xheW91dE1vZHVsZSA9IGNsYXNzIFN0YWNrTGF5b3V0TW9kdWxlIHtcbn07XG5TdGFja0xheW91dE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbZGVjbGFyYXRpb25zJDldLFxuICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWRNb2R1bGVzJDldLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxuICAgIH0pXG5dLCBTdGFja0xheW91dE1vZHVsZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIEdyaWRMYXlvdXQgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2dyaWRsYXlvdXQgJX0pLlxuICovXG5sZXQgR3JpZExheW91dENvbXBvbmVudCA9IGNsYXNzIEdyaWRMYXlvdXRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBlbGVtZW50LCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBnYXBzIGJldHdlZW4gdGhlIGVsZW1lbnRzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgMGBcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBsYXlvdXRfZ3JpZGxheW91dCAlfSN0b2MtZ2FwcykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nYXAgPSAwO1xuICAgICAgICB0aGlzLl9hbGlnbiA9IHtcbiAgICAgICAgICAgIGhvcml6b250YWw6ICdzdHJldGNoJyxcbiAgICAgICAgICAgIHZlcnRpY2FsOiAnc3RyZXRjaCdcbiAgICAgICAgfTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldCBkaXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGhlIGlubmVyIEdyaWRMYXlvdXQgZWxlbWVudHNcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGxheW91dF9ncmlkbGF5b3V0ICV9I3RvYy1hbGlnbm1lbnQpKS5cbiAgICAgKi9cbiAgICBzZXQgYWxpZ24oYWxpZ24pIHtcbiAgICAgICAgdGhpcy5fYWxpZ24gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9hbGlnbiwgYWxpZ24pO1xuICAgICAgICB0aGlzLmhhbmRsZUFsaWduQ2xhc3NlcygpO1xuICAgIH1cbiAgICBnZXQgYWxpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGlnbjtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmhhbmRsZUFsaWduQ2xhc3NlcygpO1xuICAgICAgICB0aGlzLmhhbmRsZUdyaWRUZW1wbGF0ZVN0eWxpbmcoJ3Jvd3MnKTtcbiAgICAgICAgdGhpcy5oYW5kbGVHcmlkVGVtcGxhdGVTdHlsaW5nKCdjb2xzJyk7XG4gICAgICAgIHRoaXMuc2V0R2FwKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGlzQ2hhbmdlZCgnZ2FwJywgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0R2FwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2hhbmdlZCgncm93cycsIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUdyaWRUZW1wbGF0ZVN0eWxpbmcoJ3Jvd3MnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdjb2xzJywgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlR3JpZFRlbXBsYXRlU3R5bGluZygnY29scycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUFsaWduQ2xhc3NlcygpIHtcbiAgICAgICAgY29uc3QgZWxlbSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuanVzdGlmeUNsYXNzKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtLCB0aGlzLmp1c3RpZnlDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmFsaWduQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW0sIHRoaXMuYWxpZ25DbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5qdXN0aWZ5Q2xhc3MgPSBgJHtHUklEX0pVU1RJRllfUFJFRklYfS0ke3RoaXMuYWxpZ24uaG9yaXpvbnRhbH1gO1xuICAgICAgICB0aGlzLmFsaWduQ2xhc3MgPSBgJHtBTElHTl9QUkVGSVh9LSR7VkVSVElDQUxfU1VGRklYW3RoaXMuYWxpZ24udmVydGljYWxdfWA7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbSwgdGhpcy5qdXN0aWZ5Q2xhc3MpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW0sIHRoaXMuYWxpZ25DbGFzcyk7XG4gICAgfVxuICAgIHNldEdhcCgpIHtcbiAgICAgICAgbGV0IHBhcnNlZEdhcCA9IG5vcm1hbGl6ZUdhcCh0aGlzLmdhcCk7XG4gICAgICAgIGxldCBnYXBTdHlsZSA9IGdlbmVyYXRlR2FwU3R5bGUocGFyc2VkR2FwKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2dhcCcsIGdhcFN0eWxlKTtcbiAgICB9XG4gICAgaGFuZGxlR3JpZFRlbXBsYXRlU3R5bGluZyh0eXBlKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXNbdHlwZV0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRlR3JpZExheW91dFJvd3NDb2xzKHRoaXNbdHlwZV0pO1xuICAgICAgICBpZiAoIWlzVmFsaWQgJiYgaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGUgPT09ICdyb3dzJyA/ICdHcmlkTGF5b3V0Um93U2l6ZScgOiAnR3JpZExheW91dENvbFNpemUnO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcHJvdmlkZWQgJHt0eXBlfSB2YWx1ZSBjb250YWlucyBpbnZhbGlkIGVsZW1lbnRzLiBUaGUgYXJyYXkgc3VwcG9ydHMgdmFsdWVzIG9mIHR5cGUgbnVtYmVyLCBzdHJpbmcgb3IgJHt2YWx1ZVR5cGV9LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyaWRUZW1wbGF0ZVN0eWxlID0gdHlwZSA9PT0gJ3Jvd3MnID8gJ2dyaWQtdGVtcGxhdGUtcm93cycgOiAnZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zJztcbiAgICAgICAgY29uc3QgZ3JpZFN0eWxlID0gZ2VuZXJhdGVHcmlkU3R5bGUodGhpc1t0eXBlXSwgdHlwZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGdyaWRUZW1wbGF0ZVN0eWxlLCBncmlkU3R5bGUuam9pbignICcpKTtcbiAgICB9XG4gICAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWdyaWQtbGF5b3V0JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBHcmlkTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0Q2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmRpcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEdyaWRMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcImRpclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgR3JpZExheW91dENvbXBvbmVudC5wcm90b3R5cGUsIFwicm93c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBHcmlkTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBHcmlkTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJnYXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgR3JpZExheW91dENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWxpZ25cIiwgbnVsbCk7XG5HcmlkTGF5b3V0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb0dyaWRMYXlvdXQnLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWdyaWRsYXlvdXQnLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5ncmlkbGF5b3V0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUmVuZGVyZXIyLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIEdyaWRMYXlvdXRDb21wb25lbnQpO1xuXG5sZXQgR3JpZExheW91dEl0ZW1Db21wb25lbnQgPSBjbGFzcyBHcmlkTGF5b3V0SXRlbUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXRJdGVtU3R5bGUoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMuc2V0SXRlbVN0eWxlKCk7XG4gICAgfVxuICAgIHNldEl0ZW1TdHlsZSgpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5yb3cgfHwgJ2F1dG8nO1xuICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbCB8fCAnYXV0byc7XG4gICAgICAgIGNvbnN0IHJvd1NwYW4gPSB0aGlzLnJvd1NwYW4gPyBgc3BhbiAke3RoaXMucm93U3Bhbn1gIDogJ2F1dG8nO1xuICAgICAgICBjb25zdCBjb2xTcGFuID0gdGhpcy5jb2xTcGFuID8gYHNwYW4gJHt0aGlzLmNvbFNwYW59YCA6ICdhdXRvJztcbiAgICAgICAgY29uc3QgZ3JpZEFyZWFTdHlsZSA9IGAke3Jvd30gLyAke2NvbH0gLyAke3Jvd1NwYW59IC8gJHtjb2xTcGFufWA7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdncmlkLWFyZWEnLCBncmlkQXJlYVN0eWxlKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgR3JpZExheW91dEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInJvd1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgR3JpZExheW91dEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImNvbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgR3JpZExheW91dEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInJvd1NwYW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEdyaWRMYXlvdXRJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xTcGFuXCIsIHZvaWQgMCk7XG5HcmlkTGF5b3V0SXRlbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZ3JpZGxheW91dC1pdGVtJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JlbmRlcmVyMixcbiAgICAgICAgRWxlbWVudFJlZl0pXG5dLCBHcmlkTGF5b3V0SXRlbUNvbXBvbmVudCk7XG5cbmNvbnN0IGV4cG9ydGVkTW9kdWxlcyRhID0gW1xuICAgIEdyaWRMYXlvdXRDb21wb25lbnQsXG4gICAgR3JpZExheW91dEl0ZW1Db21wb25lbnRcbl07XG5jb25zdCBkZWNsYXJhdGlvbnMkYSA9IFtcbiAgICAuLi5leHBvcnRlZE1vZHVsZXMkYVxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIEdyaWRMYXlvdXQgY29tcG9uZW50LlxuICovXG5sZXQgR3JpZExheW91dE1vZHVsZSA9IGNsYXNzIEdyaWRMYXlvdXRNb2R1bGUge1xufTtcbkdyaWRMYXlvdXRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9ucyRhXSxcbiAgICAgICAgZXhwb3J0czogW2V4cG9ydGVkTW9kdWxlcyRhXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICB9KVxuXSwgR3JpZExheW91dE1vZHVsZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIExheW91dCBjb21wb25lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIExheW91dCBtb2R1bGVcbiAqIGltcG9ydCB7IExheW91dE1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWxheW91dCc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIExheW91dE1vZHVsZV0sIC8vIGltcG9ydCBMYXlvdXQgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5sZXQgTGF5b3V0TW9kdWxlID0gY2xhc3MgTGF5b3V0TW9kdWxlIHtcbn07XG5MYXlvdXRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIEF2YXRhck1vZHVsZSxcbiAgICAgICAgICAgIENhcmRNb2R1bGUsXG4gICAgICAgICAgICBEcmF3ZXJNb2R1bGUsXG4gICAgICAgICAgICBQYW5lbEJhck1vZHVsZSxcbiAgICAgICAgICAgIEV4cGFuc2lvblBhbmVsTW9kdWxlLFxuICAgICAgICAgICAgU3BsaXR0ZXJNb2R1bGUsXG4gICAgICAgICAgICBTdGVwcGVyTW9kdWxlLFxuICAgICAgICAgICAgVGFiU3RyaXBNb2R1bGUsXG4gICAgICAgICAgICBUaWxlTGF5b3V0TW9kdWxlLFxuICAgICAgICAgICAgU3RhY2tMYXlvdXRNb2R1bGUsXG4gICAgICAgICAgICBHcmlkTGF5b3V0TW9kdWxlXG4gICAgICAgIF1cbiAgICB9KVxuXSwgTGF5b3V0TW9kdWxlKTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBQcmV2ZW50YWJsZUV2ZW50JDEgYXMgUHJldmVudGFibGVFdmVudCwgRHJhd2VyU2VydmljZSwgRHJhd2VySXRlbUNvbXBvbmVudCwgRHJhd2VyTGlzdENvbXBvbmVudCwgRFJBV0VSX0lURU1fSU5ERVgsIFBhbmVsQmFyU2VydmljZSwgU3BsaXR0ZXJCYXJDb21wb25lbnQsIFNwbGl0dGVyU2VydmljZSwgU3RlcHBlckxpc3RDb21wb25lbnQsIFN0ZXBwZXJNZXNzYWdlcywgU1RFUFBFUl9TVEVQX0lOREVYLCBTdGVwcGVyU3RlcENvbXBvbmVudCwgU3RlcHBlclNlcnZpY2UsIFRhYlN0cmlwTWVzc2FnZXMsIFRhYkNvbXBvbmVudCwgVGFiU3RyaXBTY3JvbGxhYmxlQnV0dG9uQ29tcG9uZW50LCBTY3JvbGxTZXJ2aWNlLCBUYWJTdHJpcFNlcnZpY2UsIFRpbGVMYXlvdXREcmFnZ2luZ1NlcnZpY2UsIFByZXZlbnRhYmxlRXZlbnQkMiBhcyBQcmV2ZW50YWJsZUV2ZW50JDEsIFRpbGVMYXlvdXRSZXNpemVIYW5kbGVEaXJlY3RpdmUsIFBhbmVsQmFyQ29tcG9uZW50LCBQYW5lbEJhckl0ZW1Db21wb25lbnQsIFBhbmVsQmFyQ29udGVudERpcmVjdGl2ZSwgUGFuZWxCYXJJdGVtVGVtcGxhdGVEaXJlY3RpdmUsIFBhbmVsQmFySXRlbVRpdGxlRGlyZWN0aXZlLCBQYW5lbEJhckV4cGFuZE1vZGUsIFNwbGl0dGVyQ29tcG9uZW50LCBTcGxpdHRlclBhbmVDb21wb25lbnQsIFRhYlN0cmlwQ29tcG9uZW50LCBUYWJTdHJpcFRhYkNvbXBvbmVudCwgVGFiQ29udGVudERpcmVjdGl2ZSwgVGFiVGl0bGVEaXJlY3RpdmUsIExvY2FsaXplZFRhYlN0cmlwTWVzc2FnZXNEaXJlY3RpdmUsIFRhYlN0cmlwQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsIERyYXdlckNvbXBvbmVudCwgRHJhd2VyQ29udGFpbmVyQ29tcG9uZW50LCBEcmF3ZXJDb250ZW50Q29tcG9uZW50LCBEcmF3ZXJTZWxlY3RFdmVudCwgU3RlcHBlckNvbXBvbmVudCwgU3RlcHBlckFjdGl2YXRlRXZlbnQsIFN0ZXBwZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCwgTG9jYWxpemVkU3RlcHBlck1lc3NhZ2VzRGlyZWN0aXZlLCBBdmF0YXJDb21wb25lbnQsIENhcmRDb21wb25lbnQsIENhcmRIZWFkZXJDb21wb25lbnQsIENhcmRCb2R5Q29tcG9uZW50LCBDYXJkRm9vdGVyQ29tcG9uZW50LCBDYXJkQWN0aW9uc0NvbXBvbmVudCwgQ2FyZFNlcGFyYXRvckRpcmVjdGl2ZSwgQ2FyZFRpdGxlRGlyZWN0aXZlLCBDYXJkU3VidGl0bGVEaXJlY3RpdmUsIENhcmRNZWRpYURpcmVjdGl2ZSwgQ2FyZEFjdGlvbiwgRXhwYW5zaW9uUGFuZWxDb21wb25lbnQsIEV4cGFuc2lvblBhbmVsVGl0bGVEaXJlY3RpdmUsIEV4cGFuc2lvblBhbmVsQWN0aW9uRXZlbnQsIFRpbGVMYXlvdXRDb21wb25lbnQsIFRpbGVMYXlvdXRJdGVtQ29tcG9uZW50LCBUaWxlTGF5b3V0SXRlbUJvZHlDb21wb25lbnQsIFRpbGVMYXlvdXRJdGVtSGVhZGVyQ29tcG9uZW50LCBUaWxlTGF5b3V0UmVvcmRlckV2ZW50LCBUaWxlTGF5b3V0UmVzaXplRXZlbnQsIEF2YXRhck1vZHVsZSwgQ2FyZE1vZHVsZSwgRHJhd2VyTW9kdWxlLCBMYXlvdXRNb2R1bGUsIFBhbmVsQmFyTW9kdWxlLCBTcGxpdHRlck1vZHVsZSwgU3RlcHBlck1vZHVsZSwgVGFiU3RyaXBNb2R1bGUsIEV4cGFuc2lvblBhbmVsTW9kdWxlLCBUaWxlTGF5b3V0TW9kdWxlLCBTdGFja0xheW91dE1vZHVsZSwgR3JpZExheW91dE1vZHVsZSwgU3RhY2tMYXlvdXRDb21wb25lbnQsIEdyaWRMYXlvdXRDb21wb25lbnQsIEdyaWRMYXlvdXRJdGVtQ29tcG9uZW50LCBQYW5lbEJhckNvbGxhcHNlRXZlbnQsIFBhbmVsQmFyRXhwYW5kRXZlbnQsIFBhbmVsQmFyU2VsZWN0RXZlbnQsIFRhYkNsb3NlRXZlbnQsIFNlbGVjdEV2ZW50LCBEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgRHJhd2VySXRlbVRlbXBsYXRlRGlyZWN0aXZlLCBEcmF3ZXJIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgRHJhd2VyRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsIFN0ZXBwZXJJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZSwgU3RlcHBlckxhYmVsVGVtcGxhdGVEaXJlY3RpdmUsIFN0ZXBwZXJTdGVwVGVtcGxhdGVEaXJlY3RpdmUgfTtcbiJdfQ==