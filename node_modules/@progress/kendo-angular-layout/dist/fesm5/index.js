/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param, __extends, __assign } from 'tslib';
import { Injectable, Directive, TemplateRef, Optional, isDevMode, Input, ViewChild, ElementRef, HostBinding, ViewChildren, QueryList, ContentChildren, Component, SkipSelf, Host, Renderer2, Output, EventEmitter, ContentChild, HostListener, ChangeDetectorRef, NgZone, Inject, forwardRef, ViewEncapsulation, NgModule } from '@angular/core';
import { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';
import { Keys, DraggableDirective, PreventableEvent, isDocumentAvailable, hasObservers, EventsModule, DraggableModule, ResizeSensorModule, isChanged } from '@progress/kendo-angular-common';
import { validatePackage } from '@progress/kendo-licensing';
import { trigger, state, style, transition, animate, AUTO_STYLE, AnimationBuilder } from '@angular/animations';
import { Subject, BehaviorSubject, Subscription, of } from 'rxjs';
import { tap, filter, switchMap, delay, takeUntil, map, take } from 'rxjs/operators';
import Draggable from '@telerik/kendo-draggable';
import { CommonModule } from '@angular/common';
import { ProgressBarModule } from '@progress/kendo-angular-progressbar';

/**
 * @hidden
 */
var packageMetadata = {
    name: '@progress/kendo-angular-layout',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1649340417,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * Represents the expand modes of the PanelBar.
 * By default, the expand mode is set to `multiple`.
 */
var PanelBarExpandMode;
(function (PanelBarExpandMode) {
    /**
     * Allows you to expand only one item at a time.
     * When you expand an item, the item that was previously expanded is coll.
     */
    PanelBarExpandMode[PanelBarExpandMode["Single"] = 0] = "Single";
    /**
     * Allows you to expand only one item at a time and requires you to set the `height` property.
     * The expanded area occupies the entire height of the PanelBar.
     */
    PanelBarExpandMode[PanelBarExpandMode["Full"] = 1] = "Full";
    /**
     * The default mode of the PanelBar.
     * Allows you to expand more than one item at a time. Items can also be toggled.
     */
    PanelBarExpandMode[PanelBarExpandMode["Multiple"] = 2] = "Multiple";
    /**
     * By default, the expand mode is set to `multiple`.
     */
    PanelBarExpandMode[PanelBarExpandMode["Default"] = 2] = "Default";
})(PanelBarExpandMode || (PanelBarExpandMode = {}));

/**
 * @hidden
 */
var nextPanelbarId = 0;
/**
 * @hidden
 */
var PanelBarService = /** @class */ (function () {
    function PanelBarService() {
        this.parentSource = new Subject();
        this.keepContentSource = new BehaviorSubject(false);
        this.childSource = new Subject();
        this.parent$ = this.parentSource.asObservable();
        this.children$ = this.childSource.asObservable();
        this.keepContent$ = this.keepContentSource.asObservable();
        this.pbId = nextPanelbarId++;
    }
    PanelBarService.prototype.onKeepContent = function (keepContent) {
        this.keepContentSource.next(keepContent);
    };
    PanelBarService.prototype.onSelect = function (event) {
        this.childSource.next(event);
    };
    PanelBarService.prototype.onFocus = function () {
        this.parentSource.next(true);
    };
    PanelBarService.prototype.onBlur = function () {
        this.parentSource.next(false);
    };
    PanelBarService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [])
    ], PanelBarService);
    return PanelBarService;
}());

/**
 * Represents the content template of the declaratively initialized PanelBar items.
 * The content can be expanded or collapsed through the item.
 */
var PanelBarContentDirective = /** @class */ (function () {
    function PanelBarContentDirective(templateRef) {
        this.templateRef = templateRef;
    }
    PanelBarContentDirective = __decorate([
        Directive({
            selector: "[kendoPanelBarContent]"
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], PanelBarContentDirective);
    return PanelBarContentDirective;
}());

/**
 * Represents the template directive of the PanelBar which helps to customize the item title
 * ([more information and example]({% slug templates_panelbar %}#toc-customizing-the-appearance-of-the-title)).
 *
 * > The `kendoPanelBarItemTitle` directive overrides the PanelBarItem [title]({% slug api_layout_panelbaritemcomponent %}#toc-title) option.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *        <kendo-panelbar>
 *            <kendo-panelbar-item [expanded]="true">
 *                <ng-template kendoPanelBarItemTitle>
 *                    Item Title
 *                </ng-template>
 *            </kendo-panelbar-item>
 *        </kendo-panelbar>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
var PanelBarItemTitleDirective = /** @class */ (function () {
    function PanelBarItemTitleDirective(templateRef) {
        this.templateRef = templateRef;
    }
    PanelBarItemTitleDirective = __decorate([
        Directive({
            selector: '[kendoPanelBarItemTitle]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], PanelBarItemTitleDirective);
    return PanelBarItemTitleDirective;
}());

var nextId = 0;
var SIZES = {
    small: 'sm',
    medium: 'md',
    large: 'lg'
};
var ROUNDNESS = {
    small: 'sm',
    medium: 'md',
    large: 'lg',
    full: 'full'
};
var SHAPE_TO_ROUNDED = {
    rounded: 'large',
    circle: 'full'
};
var parsePanelBarItems = function (data) {
    return data.map(function (item) {
        if (!item.id) {
            item.id = "default-" + nextId++;
        }
        if (item.children) {
            item.children = parsePanelBarItems(item.children);
        }
        return item;
    });
};
var util = {
    parsePanelBarItems: parsePanelBarItems
};
/**
 * @hidden
 */
var isPresent = function (value) { return value !== null && value !== undefined; };
/**
 * @hidden
 */
var isHorizontalArrowKey = function (keyCode) { return keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight; };
/**
 * @hidden
 */
var isVerticalArrowKey = function (keyCode) { return keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown; };
/**
 * @hidden
 */
var isArrowKey = function (keyCode) {
    return isHorizontalArrowKey(keyCode) || isVerticalArrowKey(keyCode);
};
/**
 * @hidden
 */
var isNavigationKey = function (keyCode) {
    return keyCode === Keys.PageUp || keyCode === Keys.PageDown ||
        keyCode === Keys.Home || keyCode === Keys.End;
};
/**
 * @hidden
 *
 * Returns the styling classes to be added and removed
 */
var getStylingClasses = function (componentType, stylingOption, previousValue, newValue) {
    switch (stylingOption) {
        case 'size':
            return {
                toRemove: "k-" + componentType + "-" + SIZES[previousValue],
                toAdd: newValue ? "k-" + componentType + "-" + SIZES[newValue] : null
            };
        case 'rounded':
            return {
                toRemove: "k-rounded-" + ROUNDNESS[previousValue],
                toAdd: newValue ? "k-rounded-" + ROUNDNESS[newValue] : null
            };
        default:
            break;
    }
};
/**
 * @hidden
 */
var mapShapeToRounded = function (shape) { return SHAPE_TO_ROUNDED[shape] || null; };
/**
 * @hidden
 */
var isNumber = function (value) { return typeof value === 'number' && isFinite(value); };

var focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
var toClassList = function (classNames) { return String(classNames).trim().split(' '); };
/**
 * @hidden
 */
var isFocusable = function (element) {
    if (element.tagName) {
        var tagName = element.tagName.toLowerCase();
        var tabIndex = element.getAttribute('tabIndex');
        var skipTab = tabIndex === '-1';
        var focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
/**
 * @hidden
 */
var hasClass = function (element, className) {
    return Boolean(toClassList(element.className).find(function (name) { return name === className; }));
};
/**
 * @hidden
 */
var closestInScope = function (target, predicate, scope, targetAttr) {
    while (target && target !== scope && !predicate(target, targetAttr)) {
        target = target.parentNode;
    }
    if (target !== scope) {
        return target;
    }
};
/**
 * @hidden
 */
var itemIndex = function (item, indexAttr) { return +item.getAttribute(indexAttr); };
var hasItemIndex = function (item, indexAttr) { return isPresent(item.getAttribute(indexAttr)); };
/**
 * @hidden
 */
var closestItem = function (target, targetAttr, scope) { return closestInScope(target, hasItemIndex, scope, targetAttr); };

/**
 * @hidden
 */
var nextId$1 = 0;
/**
 * Represents the items of the PanelBar.
 */
var PanelBarItemComponent = /** @class */ (function () {
    function PanelBarItemComponent(parent, eventService, element, renderer) {
        var _this = this;
        this.parent = parent;
        this.eventService = eventService;
        this.element = element;
        this.renderer = renderer;
        /**
         * Allows the component to set the `"id"` property to each item.
         * Used to set the `id` attributes of the nested elements and to enable the WAI-ARIA support.
         */
        this.id = "default-" + nextId$1++;
        /**
         * Defines the icon that will be rendered next to the title ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.icon = '';
        /**
         * Defines  the icon that will be rendered next to the title by using a custom CSS class
         * ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.iconClass = '';
        /**
         * Defines the location of the image that will be displayed next to the title
         * ([see example]({% slug items_panelbar %}#toc-title-images)).
         */
        this.imageUrl = '';
        /**
         * When set to `true`, disables a PanelBar item ([see example]({% slug items_panelbar %}#toc-disabled-state)).
         */
        this.disabled = false;
        /**
         * Sets the selected state of a PanelBar item ([see example]({% slug items_panelbar %}#toc-selected-state)).
         */
        this.selected = false;
        this.keepContent = false;
        this.hasChildItems = false;
        this.hasItems = false;
        this.hasContent = false;
        this.state = "inactive";
        this.role = "treeitem";
        this.titleAttribute = null; // tslint:disable-line
        this.kItemClass = true;
        this.focused = false;
        this.wrapperFocused = false;
        this.subscriptions = new Subscription(function () { });
        this._expanded = false;
        this.subscriptions.add(eventService.parent$.subscribe(function (focused) { return _this.onWrapperFocusChange(focused); }));
        this.subscriptions.add(eventService.keepContent$.subscribe(function (keepContent) { return _this.keepContent = keepContent; }));
        this.wrapperFocused = parent ? parent.focused : false;
        this.level = this.parent ? this.parent.level + 1 : 0;
    }
    PanelBarItemComponent_1 = PanelBarItemComponent;
    Object.defineProperty(PanelBarItemComponent.prototype, "expanded", {
        get: function () {
            return this._expanded;
        },
        /**
         * When set to `true`, expands the PanelBar item ([see example]({% slug items_panelbar %}#toc-expanded-state)).
         */
        set: function (value) {
            var activeState = this.animate ? "active" : "activeWithoutAnimation";
            this.state = value ? activeState : "inactive";
            if (!this.keepContent) {
                this.toggleExpandedChildAnimations(value);
            }
            this._expanded = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "animate", {
        get: function () {
            return this.eventService.animate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "kStateDefaultClass", {
        get: function () {
            return !this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "kStateDisabledClass", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "kStateExpandedClass", {
        get: function () {
            return !this.disabled && this.expanded && (this.hasChildItems || this.hasContent);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "itemId", {
        get: function () {
            return 'k-panelbar-' + this.eventService.pbId + '-item-' + this.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "ariaExpanded", {
        get: function () {
            return (this.hasChildItems || this.hasContent) ? !this.disabled && this.expanded : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "ariaSelected", {
        get: function () {
            return !this.disabled && this.selected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "ariaDisabled", {
        get: function () {
            return this.disabled ? true : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "headerClass", {
        get: function () {
            return this.parent ? null : true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "childClass", {
        get: function () {
            return this.parent ? true : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "titleTemplate", {
        /**
         * @hidden
         */
        get: function () {
            return this.titleTemplates.length > 0 ? this.titleTemplates.toArray()[0].templateRef : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.headerHeight = function () {
        return this.element.nativeElement.offsetHeight - (this.contentWrapper ? this.contentWrapper.nativeElement.offsetHeight : 0);
    };
    PanelBarItemComponent.prototype.ngOnInit = function () {
        this.addLevelClass();
    };
    PanelBarItemComponent.prototype.ngAfterContentChecked = function () {
        var _this = this;
        this.hasItems = this.items && this.items.filter(function (item) { return !item.hidden; }).length > 0;
        this.hasChildItems = this.contentItems.filter(function (item) { return item !== _this; }).length > 0 || this.hasItems;
        this.hasContent = (this.contentTemplate !== undefined && this.contentTemplate.length > 0) ||
            this.content !== undefined;
        this.validateConfiguration();
    };
    PanelBarItemComponent.prototype.ngAfterViewChecked = function () {
        var _this = this;
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
        }
        else {
            this.childrenItems = this.contentItems.filter(function (item) { return item !== _this; });
        }
    };
    PanelBarItemComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.onItemAction = function () {
        if (!this.disabled) {
            this.eventService.onSelect(this);
        }
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.onItemClick = function (e) {
        if (!isFocusable(e.target)) {
            this.onItemAction();
        }
    };
    Object.defineProperty(PanelBarItemComponent.prototype, "iconClasses", {
        /**
         * @hidden
         */
        get: function () {
            var _a;
            var icon = this.icon ? 'k-i-' + this.icon : null;
            return _a = {},
                _a[icon || this.iconClass] = true,
                _a;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.serialize = function () {
        return {
            content: this.content,
            disabled: this.disabled,
            expanded: this.expanded,
            focused: this.focused,
            icon: this.icon,
            iconClass: this.iconClass,
            id: this.id,
            imageUrl: this.imageUrl,
            selected: this.selected,
            title: this.title
        };
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.subTreeViewItems = function () {
        var subTree = [];
        this.viewChildItems.forEach(function (item) {
            subTree = subTree.concat(item.subTreeViewItems());
            subTree.push(item);
        });
        return subTree;
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.validateConfiguration = function () {
        if (isDevMode()) {
            if (this.content && (this.contentTemplate !== undefined && this.contentTemplate.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and component property.");
            }
        }
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.toggleAnimationState = function (value) {
        if (!this.animate) {
            return;
        }
        this.state = value && this.eventService.expandMode !== PanelBarExpandMode.Single ? 'active' : 'activeWithoutAnimation';
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.toggleExpandedChildAnimations = function (value) {
        if (this.childrenItems) {
            this.childrenItems.forEach(function (child) {
                if (child.expanded) {
                    child.toggleAnimationState(value);
                    child.toggleExpandedChildAnimations(value);
                }
            });
        }
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.addLevelClass = function () {
        if (this.level >= 0) {
            this.renderer.addClass(this.element.nativeElement, "k-level-" + this.level);
        }
    };
    PanelBarItemComponent.prototype.onWrapperFocusChange = function (focused) {
        this.wrapperFocused = focused;
    };
    var PanelBarItemComponent_1;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PanelBarItemComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PanelBarItemComponent.prototype, "id", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PanelBarItemComponent.prototype, "icon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PanelBarItemComponent.prototype, "iconClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PanelBarItemComponent.prototype, "imageUrl", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PanelBarItemComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], PanelBarItemComponent.prototype, "expanded", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PanelBarItemComponent.prototype, "selected", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PanelBarItemComponent.prototype, "content", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PanelBarItemComponent.prototype, "items", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], PanelBarItemComponent.prototype, "template", void 0);
    __decorate([
        ViewChild('header', { static: false }),
        __metadata("design:type", ElementRef)
    ], PanelBarItemComponent.prototype, "header", void 0);
    __decorate([
        ViewChild('contentWrapper', { static: false }),
        __metadata("design:type", ElementRef)
    ], PanelBarItemComponent.prototype, "contentWrapper", void 0);
    __decorate([
        HostBinding('attr.role'),
        __metadata("design:type", String)
    ], PanelBarItemComponent.prototype, "role", void 0);
    __decorate([
        HostBinding('attr.title'),
        __metadata("design:type", String)
    ], PanelBarItemComponent.prototype, "titleAttribute", void 0);
    __decorate([
        HostBinding('class.k-item'),
        __metadata("design:type", Boolean)
    ], PanelBarItemComponent.prototype, "kItemClass", void 0);
    __decorate([
        HostBinding('class.k-state-default'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], PanelBarItemComponent.prototype, "kStateDefaultClass", null);
    __decorate([
        HostBinding('class.k-state-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], PanelBarItemComponent.prototype, "kStateDisabledClass", null);
    __decorate([
        HostBinding('class.k-state-expanded'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], PanelBarItemComponent.prototype, "kStateExpandedClass", null);
    __decorate([
        HostBinding('id'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], PanelBarItemComponent.prototype, "itemId", null);
    __decorate([
        HostBinding('attr.aria-expanded'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], PanelBarItemComponent.prototype, "ariaExpanded", null);
    __decorate([
        HostBinding('attr.aria-selected'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], PanelBarItemComponent.prototype, "ariaSelected", null);
    __decorate([
        HostBinding('attr.aria-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], PanelBarItemComponent.prototype, "ariaDisabled", null);
    __decorate([
        HostBinding('class.k-panelbar-header'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], PanelBarItemComponent.prototype, "headerClass", null);
    __decorate([
        HostBinding('class.k-panelbar-item'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], PanelBarItemComponent.prototype, "childClass", null);
    __decorate([
        ViewChildren(PanelBarItemComponent_1),
        __metadata("design:type", QueryList)
    ], PanelBarItemComponent.prototype, "viewChildItems", void 0);
    __decorate([
        ContentChildren(PanelBarItemComponent_1),
        __metadata("design:type", QueryList)
    ], PanelBarItemComponent.prototype, "contentItems", void 0);
    __decorate([
        ContentChildren(PanelBarContentDirective, { descendants: false }),
        __metadata("design:type", QueryList)
    ], PanelBarItemComponent.prototype, "contentTemplate", void 0);
    __decorate([
        ContentChildren(PanelBarItemTitleDirective, { descendants: false }),
        __metadata("design:type", QueryList)
    ], PanelBarItemComponent.prototype, "titleTemplates", void 0);
    PanelBarItemComponent = PanelBarItemComponent_1 = __decorate([
        Component({
            animations: [
                trigger('toggle', [
                    state('inactive', style({ display: 'none' })),
                    transition('* => active', [
                        style({ overflow: 'hidden', display: 'block', height: 0 }),
                        animate(200, style({ height: AUTO_STYLE }))
                    ]),
                    transition('active => *', [
                        style({ overflow: 'hidden', height: AUTO_STYLE }),
                        animate(200, style({ height: 0, display: 'none' }))
                    ])
                ])
            ],
            exportAs: 'kendoPanelbarItem',
            selector: "kendo-panelbar-item",
            template: "\n            <span\n                #header\n                [class.k-link]=\"true\"\n                [class.k-state-selected]=\"!disabled && selected\"\n                [class.k-state-focused]=\"focused && wrapperFocused\"\n                (click)=\"onItemClick($event)\">\n                <span\n                    *ngIf=\"icon || iconClass\"\n                    class=\"k-icon k-panelbar-item-icon\"\n                    [ngClass]=\"iconClasses\">\n                </span>\n                <img\n                    *ngIf=\"imageUrl\"\n                    class=\"k-image k-panelbar-item-icon\"\n                    [src]=\"imageUrl\"\n                    alt=\"\">\n                <ng-container *ngIf=\"!titleTemplate\"><span class=\"k-panelbar-item-text\">{{title}}</span></ng-container>\n                <ng-template *ngIf=\"titleTemplate\"\n                [ngTemplateOutlet]=\"titleTemplate\"\n                [ngTemplateOutletContext]=\"{\n                    item: {\n                        title: title,\n                        id: id,\n                        icon: icon,\n                        iconClass: iconClass,\n                        imageUrl: imageUrl,\n                        selected: selected,\n                        expanded: expanded,\n                        disabled: disabled,\n                        focused: focused,\n                        content: content\n                    }\n                }\"></ng-template>\n                <span *ngIf=\"hasChildItems || hasContent\"\n                    class=\"k-icon k-panelbar-toggle\"\n                    [ngClass]=\"{'k-i-arrow-chevron-up k-panelbar-collapse': expanded, 'k-i-arrow-chevron-down k-panelbar-expand': !expanded}\">\n                </span>\n            </span>\n            <div #contentWrapper\n                *ngIf=\"keepContent || (!disabled && expanded && (hasChildItems || hasContent))\"\n                [@toggle]=\"state\"\n                [attr.role]=\"'group'\"\n                [attr.aria-hidden]=\"!disabled && !expanded\">\n                <div\n                    *ngIf=\"hasChildItems && !items?.length\"\n                    [style.overflow]=\"contentOverflow\"\n                    [style.height]=\"contentHeight\"\n                    class=\"k-panel k-group k-panelbar-group\">\n                        <ng-content select=\"kendo-panelbar-item\"></ng-content>\n                </div>\n                <div\n                    *ngIf=\"hasContent && !content\"\n                    [style.overflow]=\"contentOverflow\"\n                    [style.height]=\"contentHeight\"\n                    class=\"k-content k-panelbar-content\">\n                    <ng-template\n                        [ngTemplateOutlet]=\"contentTemplate.first.templateRef\"\n                        [ngTemplateOutletContext]=\"{\n                            $implicit: {\n                                title: title,\n                                id: id,\n                                icon: icon,\n                                imageUrl: imageUrl,\n                                disabled: disabled,\n                                content: content\n                            }\n                        }\">\n                    </ng-template>\n                </div>\n                <div *ngIf=\"hasItems\"\n                    [style.overflow]=\"contentOverflow\"\n                    [style.height]=\"contentHeight\"\n                    class=\"k-panel k-group k-panelbar-group\">\n                    <ng-container *ngFor=\"let item of items\">\n                        <kendo-panelbar-item *ngIf=\"!item.hidden\"\n                            [title]=\"item.title\"\n                            [id]=\"item.id\"\n                            [icon]=\"item.icon\"\n                            [iconClass]=\"item.iconClass\"\n                            [imageUrl]=\"item.imageUrl\"\n                            [selected]=\"!!item.selected\"\n                            [expanded]=\"!!item.expanded\"\n                            [disabled]=\"!!item.disabled\"\n                            [template]=\"template\"\n                            [items]=\"item.children\"\n                            [content]=\"item.content\">\n                        </kendo-panelbar-item>\n                    </ng-container>\n                </div>\n                <div\n                    *ngIf=\"content\"\n                    [style.overflow]=\"contentOverflow\"\n                    [style.height]=\"contentHeight\"\n                    class=\"k-content k-panelbar-content\">\n                    <ng-template\n                        [ngTemplateOutlet]=\"template\"\n                        [ngTemplateOutletContext]=\"{\n                            $implicit: {\n                                title: title,\n                                id: id,\n                                icon: icon,\n                                imageUrl: imageUrl,\n                                disabled: disabled,\n                                content: content\n                            }\n                        }\">\n                    </ng-template>\n                    <ng-template [ngIf]=\"!template\">{{content}}</ng-template>\n                </div>\n            </div>"
        }),
        __param(0, SkipSelf()), __param(0, Host()), __param(0, Optional()),
        __metadata("design:paramtypes", [PanelBarItemComponent,
            PanelBarService,
            ElementRef,
            Renderer2])
    ], PanelBarItemComponent);
    return PanelBarItemComponent;
}());

/**
 * Represents the template directive of the PanelBar which helps to customize the item content.
 */
var PanelBarItemTemplateDirective = /** @class */ (function () {
    function PanelBarItemTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    PanelBarItemTemplateDirective = __decorate([
        Directive({
            selector: '[kendoPanelBarItemTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], PanelBarItemTemplateDirective);
    return PanelBarItemTemplateDirective;
}());

/**
 * @hidden
 */
var PreventableEvent$1 = /** @class */ (function () {
    /**
     * @hidden
     */
    function PreventableEvent$$1(args) {
        this.prevented = false;
        Object.assign(this, args);
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    PreventableEvent$$1.prototype.preventDefault = function () {
        this.prevented = true;
    };
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    PreventableEvent$$1.prototype.isDefaultPrevented = function () {
        return this.prevented;
    };
    return PreventableEvent$$1;
}());

/**
 * Arguments for the `collapse` event of the PanelBar.
 */
var PanelBarCollapseEvent = /** @class */ (function (_super) {
    __extends(PanelBarCollapseEvent, _super);
    function PanelBarCollapseEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PanelBarCollapseEvent;
}(PreventableEvent$1));

/**
 * Arguments for the `expand` event of the PanelBar.
 */
var PanelBarExpandEvent = /** @class */ (function (_super) {
    __extends(PanelBarExpandEvent, _super);
    function PanelBarExpandEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PanelBarExpandEvent;
}(PreventableEvent$1));

/**
 * Arguments for the `select` event of the PanelBar.
 */
var PanelBarSelectEvent = /** @class */ (function (_super) {
    __extends(PanelBarSelectEvent, _super);
    function PanelBarSelectEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PanelBarSelectEvent;
}(PreventableEvent$1));

/**
 * Represents the [Kendo UI PanelBar component for Angular]({% slug overview_panelbar %}).
 */
var PanelBarComponent = /** @class */ (function () {
    function PanelBarComponent(elementRef, eventService, localization) {
        var _this = this;
        this.localization = localization;
        /**
         * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum ([see example]({% slug expandmodes_panelbar %})).
         *
         * The available modes are:
         * - `"single"`&mdash;Expands only one item at a time. Expanding an item collapses the item that was previously expanded.
         * - `"multiple"`&mdash;The default mode of the PanelBar.
         * Expands more than one item at a time. Items can also be toggled.
         * - `"full"`&mdash;Expands only one item at a time.
         * The expanded area occupies the entire height of the PanelBar. Requires you to set the `height` property.
         */
        this.expandMode = PanelBarExpandMode.Default;
        /**
         * Allows the PanelBar to modify the selected state of the items.
         */
        this.selectable = true;
        /**
         * Sets the animate state of the PanelBar ([see example]({% slug animations_panelbar %})).
         */
        this.animate = true;
        /**
         * Sets the height of the component when the `"full"` expand mode is used.
         * This option is ignored in the `"multiple"` and `"single"` expand modes.
         */
        this.height = '400px';
        /**
         * Fires each time the user interacts with a PanelBar item
         * ([see example]({% slug routing_panelbar %}#toc-getting-the-selected-item)).
         * The event data contains all items that are modified.
         */
        this.stateChange = new EventEmitter();
        /**
         * Fires when an item is about to be selected.
         * ([see example]({% slug events_panelbar %}))
         * This event is preventable. If you cancel it, the item will not be selected.
         */
        this.select = new EventEmitter();
        /**
         * Fires when an item is about to be expanded.
         * ([see example]({% slug events_panelbar %}))
         * This event is preventable. If you cancel it, the item will remain collapsed.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when an item is about to be collapsed.
         * ([see example]({% slug events_panelbar %}))
         * This event is preventable. If you cancel it, the item will remain expanded.
         */
        this.collapse = new EventEmitter();
        this.tabIndex = 0;
        this.role = 'tree';
        this.hostClass = true;
        this.activeDescendant = '';
        this.isViewInit = true;
        this.focused = false;
        this._keepItemContent = false;
        this.updateChildrenHeight = function () {
            var childrenHeight = 0;
            var panelbarHeight = _this.elementRef.nativeElement.offsetHeight;
            var contentOverflow = _this.expandMode === PanelBarExpandMode.Full ? 'auto' : 'visible';
            _this.childrenItems.forEach(function (item) {
                childrenHeight += item.headerHeight();
            });
            _this.childrenItems.forEach(function (item) {
                item.contentHeight = PanelBarExpandMode.Full === _this.expandMode ? (panelbarHeight - childrenHeight) + 'px' : 'auto';
                item.contentOverflow = contentOverflow;
            });
        };
        validatePackage(packageMetadata);
        /* tslint:disable-line */
        this.keyBindings = this.computedKeys;
        this.elementRef = elementRef;
        this.eventService = eventService;
        this.eventService.children$.subscribe(function (event) { return _this.onItemAction(event); });
    }
    Object.defineProperty(PanelBarComponent.prototype, "keepItemContent", {
        /**
         * When set to `true`, the PanelBar renders the content of all items and they are persisted in the DOM
         * ([see example]({% slug templates_panelbar %}#toc-collections)).
         * By default, this option is set to `false`.
         */
        get: function () {
            return this._keepItemContent;
        },
        set: function (keepItemContent) {
            this._keepItemContent = keepItemContent;
            this.eventService.onKeepContent(keepItemContent);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarComponent.prototype, "items", {
        get: function () {
            return this._items;
        },
        /**
         * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances
         * ([see example]({% slug items_panelbar %})).
         */
        set: function (data) {
            if (data) {
                this._items = util.parsePanelBarItems(data);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarComponent.prototype, "hostHeight", {
        get: function () {
            return this.expandMode === PanelBarExpandMode.Full ? this.height : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarComponent.prototype, "overflow", {
        get: function () {
            return this.expandMode === PanelBarExpandMode.Full ? 'hidden' : 'visible';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarComponent.prototype, "dir", {
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    PanelBarComponent.prototype.invertKeys = function (original, inverted) {
        return this.localization.rtl ? inverted : original;
    };
    Object.defineProperty(PanelBarComponent.prototype, "computedKeys", {
        get: function () {
            var _this = this;
            var _a;
            return _a = {},
                _a[Keys.Space] = function () { return _this.selectFocusedItem(); },
                _a[Keys.Enter] = function () { return _this.selectFocusedItem(); },
                _a[Keys.ArrowUp] = function () { return _this.focusPreviousItem(); },
                _a[this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)] = function () { return _this.collapseItem(); },
                _a[Keys.ArrowDown] = function () { return _this.focusNextItem(); },
                _a[this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)] = function () { return _this.expandItem(); },
                _a[Keys.End] = function () { return _this.focusLastItem(); },
                _a[Keys.Home] = function () { return _this.focusFirstItem(); },
                _a;
        },
        enumerable: true,
        configurable: true
    });
    PanelBarComponent.prototype.ngOnDestroy = function () {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    };
    PanelBarComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(function () {
            return _this.keyBindings = _this.computedKeys;
        });
        this.eventService.animate = this.animate;
        this.eventService.expandMode = this.expandMode;
    };
    PanelBarComponent.prototype.ngAfterViewChecked = function () {
        var _this = this;
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
            this.allItems = this.viewItems;
        }
        else {
            this.childrenItems = this.contentChildItems.toArray();
            this.allItems = this.contentItems.toArray();
        }
        if (this.isViewInit && this.childrenItems.length) {
            this.isViewInit = false;
            setTimeout(function () { return _this.updateChildrenHeight(); });
        }
        this.validateConfiguration();
    };
    PanelBarComponent.prototype.ngOnChanges = function (changes) {
        if (changes['height'] || changes['expandMode'] || changes['items']) { // tslint:disable-line
            if (this.childrenItems) {
                setTimeout(this.updateChildrenHeight);
            }
        }
        if (changes.animate) {
            this.eventService.animate = this.animate;
        }
        if (changes.expandMode) {
            this.eventService.expandMode = this.expandMode;
        }
    };
    Object.defineProperty(PanelBarComponent.prototype, "templateRef", {
        get: function () {
            return this.template ? this.template.templateRef : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    PanelBarComponent.prototype.onComponentClick = function (event) {
        var itemClicked = this.visibleItems().some(function (item) {
            return item.header.nativeElement.contains(event.target);
        });
        if (!isFocusable(event.target) && !this.focused && itemClicked) {
            this.elementRef.nativeElement.focus();
        }
    };
    /**
     * @hidden
     */
    PanelBarComponent.prototype.onComponentFocus = function () {
        this.eventService.onFocus();
        this.focused = true;
        if (this.allItems.length > 0) {
            var visibleItems = this.visibleItems();
            var focusedItems = visibleItems.filter(function (item) { return item.focused; });
            if (!focusedItems.length && visibleItems.length > 0) {
                visibleItems[0].focused = true;
                this.activeDescendant = visibleItems[0].itemId;
            }
        }
    };
    /**
     * @hidden
     */
    PanelBarComponent.prototype.onComponentBlur = function () {
        this.eventService.onBlur();
        this.focused = false;
        this.activeDescendant = '';
    };
    /**
     * @hidden
     */
    PanelBarComponent.prototype.onComponentKeyDown = function (event) {
        if (event.target === this.elementRef.nativeElement) {
            if (event.keyCode === Keys.Space || event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowDown ||
                event.keyCode === Keys.ArrowLeft || event.keyCode === Keys.ArrowRight || event.keyCode === Keys.Home ||
                event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {
                event.preventDefault();
            }
            var handler = this.keyBindings[event.keyCode];
            //TODO: check if next item is disabled and skip operation?
            if (handler) {
                handler();
            }
        }
    };
    /**
     * @hidden
     */
    PanelBarComponent.prototype.emitEvent = function (event, item) {
        var eventArgs;
        switch (event) {
            case 'select':
                eventArgs = new PanelBarSelectEvent();
                break;
            case 'collapse':
                eventArgs = new PanelBarCollapseEvent();
                break;
            default:
                eventArgs = new PanelBarExpandEvent();
                break;
        }
        eventArgs.item = item.serialize();
        this[event].emit(eventArgs);
        return eventArgs;
    };
    Object.defineProperty(PanelBarComponent.prototype, "viewItems", {
        get: function () {
            var treeItems = [];
            this.viewChildItems.toArray().forEach(function (item) {
                treeItems.push(item);
                treeItems = treeItems.concat(item.subTreeViewItems());
            });
            return treeItems;
        },
        enumerable: true,
        configurable: true
    });
    PanelBarComponent.prototype.validateConfiguration = function () {
        if (isDevMode()) {
            if (this.items && (this.contentItems && this.contentItems.length > 0)) {
                throw new Error('Invalid configuration: mixed template components and items property.');
            }
        }
    };
    PanelBarComponent.prototype.onItemAction = function (item) {
        var _this = this;
        if (!item) {
            return;
        }
        var modifiedItems = new Array();
        this.allItems
            .forEach(function (currentItem) {
            var selectedState = currentItem === item;
            var focusedState = selectedState;
            selectedState = _this.selectable ? selectedState : currentItem.selected;
            if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {
                var isSelectPrevented = selectedState ? _this.emitEvent('select', currentItem).isDefaultPrevented() : false;
                if (!isSelectPrevented) {
                    currentItem.selected = selectedState;
                    currentItem.focused = focusedState;
                    _this.activeDescendant = focusedState ? currentItem.itemId : '';
                    modifiedItems.push(currentItem);
                }
            }
        });
        if (this.expandMode === PanelBarExpandMode.Multiple) {
            if ((item.hasChildItems || item.hasContent) && item.selected) {
                var isEventPrevented = item.expanded ?
                    this.emitEvent('collapse', item).isDefaultPrevented() :
                    this.emitEvent('expand', item).isDefaultPrevented();
                if (!isEventPrevented) {
                    item.expanded = !item.expanded;
                    if (modifiedItems.indexOf(item) < 0) {
                        modifiedItems.push(item);
                    }
                }
            }
        }
        else {
            var siblings = item.parent ? item.parent.childrenItems : this.childrenItems;
            var preventedCollapseItem_1;
            var expandedItems_1 = [];
            if ((item.hasChildItems || item.hasContent) && item.selected) {
                siblings
                    .forEach(function (currentItem) {
                    var expandedState = currentItem === item;
                    if (currentItem.expanded !== expandedState) {
                        var isEventPrevented = currentItem.expanded ?
                            _this.emitEvent('collapse', currentItem).isDefaultPrevented() :
                            _this.emitEvent('expand', currentItem).isDefaultPrevented();
                        if (!isEventPrevented) {
                            currentItem.expanded = expandedState;
                            if (currentItem.expanded) {
                                expandedItems_1.push(currentItem);
                            }
                            if (modifiedItems.indexOf(currentItem) < 0) {
                                modifiedItems.push(currentItem);
                            }
                        }
                        else if (isEventPrevented && currentItem.expanded) {
                            preventedCollapseItem_1 = currentItem;
                        }
                    }
                    else if (currentItem.expanded === expandedState && expandedState) {
                        var isCollapsePrevented = _this.emitEvent('collapse', currentItem).isDefaultPrevented();
                        if (!isCollapsePrevented) {
                            currentItem.expanded = !currentItem.expanded;
                            if (modifiedItems.indexOf(currentItem) < 0) {
                                modifiedItems.push(currentItem);
                            }
                        }
                    }
                });
                expandedItems_1.forEach(function (item) {
                    if (preventedCollapseItem_1 && item.id !== preventedCollapseItem_1.id) {
                        item.expanded = false;
                        if (isDevMode()) {
                            var expandMode = PanelBarExpandMode[_this.expandMode].toLowerCase();
                            console.warn("\n                            The " + expandMode + " expandMode allows the expansion of only one item at a time.\n                            See https://www.telerik.com/kendo-angular-ui-develop/components/layout/panelbar/expand-modes/");
                        }
                    }
                });
            }
        }
        if (modifiedItems.length > 0) {
            this.stateChange.emit(modifiedItems.map(function (currentItem) { return currentItem.serialize(); }));
        }
    };
    PanelBarComponent.prototype.isVisible = function (item) {
        var visibleItems = this.visibleItems();
        return visibleItems.some(function (i) { return i === item; });
    };
    PanelBarComponent.prototype.getVisibleParent = function (item) {
        var visibleItems = this.visibleItems();
        if (!item.parent) {
            return item;
        }
        return visibleItems.some(function (i) { return i === item.parent; }) ? item.parent : this.getVisibleParent(item.parent);
    };
    PanelBarComponent.prototype.focusItem = function (action) {
        var visibleItems = this.visibleItems();
        var currentIndex = visibleItems.findIndex(function (item) { return item.focused; });
        var currentItem = visibleItems[currentIndex];
        var nextItem;
        if (currentIndex === -1) {
            var focusedItem = this.allItems.find(function (item) { return item.focused; });
            focusedItem.focused = false;
            currentItem = this.getVisibleParent(focusedItem);
            currentIndex = visibleItems.findIndex(function (item) { return item === currentItem; });
        }
        switch (action) {
            case 'lastItem':
                nextItem = visibleItems[visibleItems.length - 1];
                break;
            case 'firstItem':
                nextItem = visibleItems[0];
                break;
            case 'nextItem':
                nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];
                break;
            case 'previousItem':
                nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];
                break;
            default:
        }
        if (currentItem && nextItem && currentItem !== nextItem) {
            this.moveFocus(currentItem, nextItem);
        }
    };
    PanelBarComponent.prototype.moveFocus = function (from, to) {
        from.focused = false;
        to.focused = true;
        this.activeDescendant = to.itemId;
        var modifiedItems = new Array(from.serialize(), to.serialize());
        this.stateChange.emit(modifiedItems);
    };
    PanelBarComponent.prototype.focusLastItem = function () {
        this.focusItem('lastItem');
    };
    PanelBarComponent.prototype.focusFirstItem = function () {
        this.focusItem('firstItem');
    };
    PanelBarComponent.prototype.focusNextItem = function () {
        this.focusItem('nextItem');
    };
    PanelBarComponent.prototype.focusPreviousItem = function () {
        this.focusItem('previousItem');
    };
    PanelBarComponent.prototype.expandItem = function () {
        var currentItem = this.allItems.filter(function (item) { return item.focused; })[0];
        if (!this.isVisible(currentItem)) {
            currentItem.focused = false;
            currentItem = this.getVisibleParent(currentItem);
        }
        if (currentItem.hasChildItems || currentItem.hasContent) {
            if (!currentItem.expanded) {
                this.onItemAction(currentItem);
            }
            else if (currentItem.hasChildItems) {
                var firstChildIndex = currentItem.childrenItems.findIndex(function (item) { return !item.disabled; });
                if (firstChildIndex > -1) {
                    this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);
                }
            }
        }
    };
    PanelBarComponent.prototype.collapseItem = function () {
        var currentItem = this.allItems.filter(function (item) { return item.focused; })[0];
        if (currentItem.expanded) {
            this.onItemAction(currentItem);
        }
        else if (currentItem.parent) {
            this.moveFocus(currentItem, currentItem.parent);
        }
    };
    PanelBarComponent.prototype.selectFocusedItem = function () {
        var focusedItem = this.allItems.filter(function (item) { return item.focused; })[0];
        if (!this.isVisible(focusedItem)) {
            focusedItem.focused = false;
            focusedItem = this.getVisibleParent(focusedItem);
        }
        if (focusedItem) {
            focusedItem.onItemAction();
        }
    };
    PanelBarComponent.prototype.visibleItems = function () {
        return this.flatVisibleItems(this.childrenItems);
    };
    PanelBarComponent.prototype.flatVisibleItems = function (listOfItems, flattedItems) {
        var _this = this;
        if (listOfItems === void 0) { listOfItems = new Array(); }
        if (flattedItems === void 0) { flattedItems = new Array(); }
        listOfItems.forEach(function (item) {
            flattedItems.push(item);
            if (item.expanded && item.hasChildItems) {
                _this.flatVisibleItems(item.childrenItems, flattedItems);
            }
        });
        return flattedItems;
    };
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PanelBarComponent.prototype, "expandMode", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PanelBarComponent.prototype, "selectable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PanelBarComponent.prototype, "animate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PanelBarComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], PanelBarComponent.prototype, "keepItemContent", null);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], PanelBarComponent.prototype, "items", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], PanelBarComponent.prototype, "stateChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], PanelBarComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], PanelBarComponent.prototype, "expand", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], PanelBarComponent.prototype, "collapse", void 0);
    __decorate([
        HostBinding('attr.tabIndex'),
        __metadata("design:type", Number)
    ], PanelBarComponent.prototype, "tabIndex", void 0);
    __decorate([
        HostBinding('attr.role'),
        __metadata("design:type", String)
    ], PanelBarComponent.prototype, "role", void 0);
    __decorate([
        HostBinding('class.k-panelbar'),
        __metadata("design:type", Boolean)
    ], PanelBarComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('attr.aria-activedescendant'),
        __metadata("design:type", String)
    ], PanelBarComponent.prototype, "activeDescendant", void 0);
    __decorate([
        HostBinding('style.height'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], PanelBarComponent.prototype, "hostHeight", null);
    __decorate([
        HostBinding('style.overflow'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], PanelBarComponent.prototype, "overflow", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], PanelBarComponent.prototype, "dir", null);
    __decorate([
        ContentChild(PanelBarItemTemplateDirective, { static: false }),
        __metadata("design:type", PanelBarItemTemplateDirective)
    ], PanelBarComponent.prototype, "template", void 0);
    __decorate([
        ContentChildren(PanelBarItemComponent, { descendants: true }),
        __metadata("design:type", QueryList)
    ], PanelBarComponent.prototype, "contentItems", void 0);
    __decorate([
        ContentChildren(PanelBarItemComponent),
        __metadata("design:type", QueryList)
    ], PanelBarComponent.prototype, "contentChildItems", void 0);
    __decorate([
        ViewChildren(PanelBarItemComponent),
        __metadata("design:type", QueryList)
    ], PanelBarComponent.prototype, "viewChildItems", void 0);
    __decorate([
        HostListener('click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], PanelBarComponent.prototype, "onComponentClick", null);
    __decorate([
        HostListener('focus'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], PanelBarComponent.prototype, "onComponentFocus", null);
    __decorate([
        HostListener('blur'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], PanelBarComponent.prototype, "onComponentBlur", null);
    __decorate([
        HostListener('keydown', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], PanelBarComponent.prototype, "onComponentKeyDown", null);
    PanelBarComponent = __decorate([
        Component({
            exportAs: 'kendoPanelbar',
            providers: [
                PanelBarService,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.panelbar'
                }
            ],
            selector: 'kendo-panelbar',
            template: "\n        <ng-content *ngIf=\"contentChildItems && !items\" select=\"kendo-panelbar-item\"></ng-content>\n        <ng-template [ngIf]=\"items?.length\">\n            <ng-container *ngFor=\"let item of items\">\n                <kendo-panelbar-item *ngIf=\"!item.hidden\"\n                    [title]=\"item.title\"\n                    [id]=\"item.id\"\n                    [icon]=\"item.icon\"\n                    [iconClass]=\"item.iconClass\"\n                    [imageUrl]=\"item.imageUrl\"\n                    [selected]=\"!!item.selected\"\n                    [expanded]=\"!!item.expanded\"\n                    [disabled]=\"!!item.disabled\"\n                    [template]=\"templateRef\"\n                    [items]=\"item.children\"\n                    [content]=\"item.content\"\n                >\n                </kendo-panelbar-item>\n            </ng-container>\n        </ng-template>\n    "
        })
        // TODO: add styles as input prop
        ,
        __metadata("design:paramtypes", [ElementRef,
            PanelBarService,
            LocalizationService])
    ], PanelBarComponent);
    return PanelBarComponent;
}());

/**
 * Represents the pane component of the Splitter.
 */
var SplitterPaneComponent = /** @class */ (function () {
    function SplitterPaneComponent(element, renderer, cdr) {
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        /**
         * Specifies if the user is allowed to resize the pane and provide space for other panes.
         */
        this.resizable = true;
        /**
         * Specifies if the user is allowed to hide the pane and provide space for other panes.
         */
        this.collapsible = false;
        /**
         * Specifies if overflowing content is scrollable or hidden.
         */
        this.scrollable = true;
        /**
         * Specifies if the pane is initially collapsed.
         */
        this.collapsed = false;
        /**
         * @hidden
         */
        this.orientation = 'horizontal';
        /**
         * @hidden
         */
        this.overlayContent = false;
        /**
         * Fires each time the user resizes the Splitter pane.
         * The event data contains the new pane size.
         * Allows a two-way binding of the pane `size` property.
         */
        this.sizeChange = new EventEmitter();
        /**
         * Fires each time the `collapsed` property changes.
         * The event data contains the new property state.
         * Allows a two-way binding of the `collapsed` pane property.
         */
        this.collapsedChange = new EventEmitter();
        this.hostClass = true;
        /**
         * @hidden
         */
        this.forceExpand = false;
        /**
         * @hidden
         */
        this.isResized = false;
    }
    Object.defineProperty(SplitterPaneComponent.prototype, "order", {
        get: function () {
            return this._order;
        },
        /**
         * @hidden
         */
        set: function (paneOrder) {
            this._order = paneOrder;
            this.setOrderStyles();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "size", {
        get: function () {
            return this._size;
        },
        /**
         * Sets the initial size of the pane.
         * Has to be between the `min` and `max` properties.
         */
        set: function (newSize) {
            this._size = newSize;
            var element = this.element.nativeElement;
            this.renderer.setStyle(element, '-ms-flex-preferred-size', newSize);
            this.renderer.setStyle(element, 'flex-basis', newSize);
            if (this.staticPaneClass) {
                this.renderer.addClass(element, 'k-pane-static');
            }
            else {
                this.renderer.removeClass(element, 'k-pane-static');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "containsSplitter", {
        /**
         * @hidden
         */
        set: function (value) {
            var element = this.element.nativeElement;
            if (value) {
                this.renderer.addClass(element, 'k-pane-flex');
            }
            else {
                this.renderer.removeClass(element, 'k-pane-flex');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "isHidden", {
        get: function () {
            return this.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "staticPaneClass", {
        get: function () {
            if (this.forceExpand) {
                return false;
            }
            return !this.resizable && !this.collapsible || this.fixedSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "scrollablePaneClass", {
        get: function () {
            return this.scrollable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "fixedSize", {
        get: function () {
            return this.size && this.size.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    SplitterPaneComponent.prototype.ngAfterViewChecked = function () {
        var element = this.element.nativeElement;
        if (this.isHidden) {
            this.renderer.addClass(element, 'k-state-hidden');
            this.renderer.addClass(element, 'hidden');
        }
        else {
            this.renderer.removeClass(element, 'k-state-hidden');
            this.renderer.removeClass(element, 'hidden');
        }
    };
    Object.defineProperty(SplitterPaneComponent.prototype, "computedSize", {
        /**
         * @hidden
         */
        get: function () {
            if (this.orientation === 'vertical') {
                return this.element.nativeElement.offsetHeight;
            }
            else {
                return this.element.nativeElement.offsetWidth;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    SplitterPaneComponent.prototype.toggleOverlay = function (show) {
        this.overlayContent = show;
        this.cdr.detectChanges();
    };
    /**
     * @hidden
     */
    SplitterPaneComponent.prototype.detectChanges = function () {
        this.cdr.detectChanges();
    };
    SplitterPaneComponent.prototype.setOrderStyles = function () {
        var element = this.element.nativeElement;
        this.renderer.setStyle(element, '-ms-flex-order', this.order);
        this.renderer.setStyle(element, 'order', this.order);
    };
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], SplitterPaneComponent.prototype, "order", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], SplitterPaneComponent.prototype, "size", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitterPaneComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitterPaneComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SplitterPaneComponent.prototype, "resizable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SplitterPaneComponent.prototype, "collapsible", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SplitterPaneComponent.prototype, "scrollable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SplitterPaneComponent.prototype, "collapsed", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitterPaneComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], SplitterPaneComponent.prototype, "containsSplitter", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SplitterPaneComponent.prototype, "overlayContent", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SplitterPaneComponent.prototype, "sizeChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SplitterPaneComponent.prototype, "collapsedChange", void 0);
    __decorate([
        HostBinding('class.k-pane'),
        __metadata("design:type", Boolean)
    ], SplitterPaneComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('class.k-pane-static'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], SplitterPaneComponent.prototype, "staticPaneClass", null);
    __decorate([
        HostBinding('class.k-scrollable'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], SplitterPaneComponent.prototype, "scrollablePaneClass", null);
    SplitterPaneComponent = __decorate([
        Component({
            exportAs: 'kendoSplitterPane',
            selector: 'kendo-splitter-pane',
            template: "\n        <ng-container *ngIf=\"!collapsed\"><ng-content></ng-content></ng-container>\n        <div *ngIf=\"overlayContent\" class=\"k-splitter-overlay k-overlay\"></div>\n    "
        }),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            ChangeDetectorRef])
    ], SplitterPaneComponent);
    return SplitterPaneComponent;
}());

var SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#toc-size';
/**
 * @hidden
 */
var SplitterService = /** @class */ (function () {
    function SplitterService(zone) {
        this.zone = zone;
        this.layoutChange = new EventEmitter();
        this.containerSize = function () { };
    }
    SplitterService.prototype.tryToggle = function (paneIndex) {
        var pane = this.pane(paneIndex);
        if (pane.collapsible) {
            pane.collapsed = !pane.collapsed;
            pane.collapsedChange.emit(pane.collapsed);
            this.emit(this.layoutChange, {});
            if (pane.collapsed) {
                pane.detectChanges();
            }
        }
        var notCollapsed = this.panes.filter(function (p) { return !p.collapsed; });
        var allHaveFixedSize = notCollapsed.every(function (p) { return p.fixedSize; });
        notCollapsed[notCollapsed.length - 1].forceExpand = allHaveFixedSize ? true : false;
        return pane.collapsible;
    };
    SplitterService.prototype.toggleContentOverlay = function (index, show) {
        this.pane(index).toggleOverlay(show);
        this.pane(index + 1).toggleOverlay(show);
    };
    SplitterService.prototype.dragState = function (splitbarIndex) {
        var _this = this;
        var prev = this.pane(splitbarIndex);
        var next = this.pane(splitbarIndex + 1);
        var total = prev.computedSize + next.computedSize;
        var px = function (s) { return _this.toPixels(s); };
        return {
            prev: {
                index: splitbarIndex,
                initialSize: prev.computedSize,
                min: px(prev.min) || total - px(next.max) || 0,
                max: px(prev.max) || total - px(next.min) || total
            },
            next: {
                index: splitbarIndex + 1,
                initialSize: next.computedSize,
                min: px(next.min) || total - px(prev.max) || 0,
                max: px(next.max) || total - px(prev.min) || total
            }
        };
    };
    SplitterService.prototype.setSize = function (state$$1, delta) {
        var _this = this;
        var clamp = function (min, max, v) { return Math.min(max, Math.max(min, v)); };
        var resize = function (paneState, change) {
            var pane = _this.pane(paneState.index);
            var splitterSize = _this.containerSize();
            var newSize = clamp(paneState.min, paneState.max, paneState.initialSize + change);
            var size = "";
            if (_this.isPercent(pane.size)) {
                size = (100 * newSize / splitterSize) + "%";
            }
            else {
                size = newSize + "px";
            }
            pane.size = size;
            pane.isResized = true;
            _this.emit(pane.sizeChange, size);
        };
        var prev = this.pane(state$$1.prev.index);
        var next = this.pane(state$$1.next.index);
        // determine which pane to resize
        if (prev.fixedSize && next.fixedSize) {
            // resizing both panes
            resize(state$$1.prev, delta);
            resize(state$$1.next, -delta);
        }
        else if (next.collapsible || next.fixedSize) {
            // resizing next
            resize(state$$1.next, -delta);
        }
        else {
            // resizing prev
            resize(state$$1.prev, delta);
        }
        this.emit(this.layoutChange, {});
    };
    SplitterService.prototype.isDraggable = function (splitBarIndex) {
        var prev = this.pane(splitBarIndex);
        var next = this.pane(splitBarIndex + 1);
        var betweenResizablePanes = prev.resizable && next.resizable;
        var nearCollapsedPane = prev.collapsed || next.collapsed;
        return betweenResizablePanes && !nearCollapsedPane;
    };
    SplitterService.prototype.isStatic = function (splitBarIndex) {
        var prev = this.pane(splitBarIndex);
        var next = this.pane(splitBarIndex + 1);
        var betweenResizablePanes = prev.resizable && next.resizable;
        var nearCollapsiblePane = prev.collapsible || next.collapsible;
        return !betweenResizablePanes && !nearCollapsiblePane;
    };
    SplitterService.prototype.pane = function (index) {
        if (!this.panes) {
            throw new Error("Panes not initialized");
        }
        if (index < 0 || index >= this.panes.length) {
            throw new Error("Index out of range");
        }
        return this.panes[index];
    };
    SplitterService.prototype.configure = function (_a) {
        var panes = _a.panes, orientation = _a.orientation, containerSize = _a.containerSize;
        this.panes = panes;
        this.panes.forEach(function (pane, index) {
            pane.order = index * 2;
            pane.orientation = orientation;
        });
        if (isDevMode()) {
            var allPanesWithSize = panes.length && !panes.some(function (pane) { return !pane.fixedSize; });
            var hasResizedPane = panes.length && panes.some(function (pane) { return pane.isResized; });
            if (allPanesWithSize && !hasResizedPane) {
                throw new Error("\n                    The Splitter should have at least one pane without a set size.\n                    See " + SIZING_DOC_LINK + " for more information.\n                ");
            }
        }
        this.containerSize = containerSize;
    };
    SplitterService.prototype.isPercent = function (size) {
        return /%$/.test(size);
    };
    SplitterService.prototype.toPixels = function (size) {
        var result = parseFloat(size);
        if (this.isPercent(size)) {
            result = (this.containerSize() * result / 100);
        }
        return result;
    };
    SplitterService.prototype.emit = function (emitter, args) {
        if (emitter.observers.length) {
            this.zone.run(function () { return emitter.emit(args); });
        }
    };
    SplitterService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [NgZone])
    ], SplitterService);
    return SplitterService;
}());

var stopPropagation = function (_a) {
    var event = _a.originalEvent;
    event.stopPropagation();
    event.preventDefault();
};
var preventOnDblClick = function (release) { return function (mouseDown) {
    return of(mouseDown).pipe(delay(150), takeUntil(release));
}; };
var classFromObject = function (classes) { return Object.keys(classes).filter(function (c) { return classes[c]; }).join(' '); };
var createMoveStream = function (draggable) { return function (mouseDown) {
    return draggable.kendoDrag
        .pipe(takeUntil(draggable.kendoRelease), map(function (_a) {
        var pageX = _a.pageX, pageY = _a.pageY;
        return ({
            originalX: mouseDown.pageX,
            originalY: mouseDown.pageY,
            pageX: pageX,
            pageY: pageY
        });
    }));
}; };
/**
 * @hidden
 */
var SplitterBarComponent = /** @class */ (function () {
    function SplitterBarComponent(draggable, element, splitter, localization) {
        this.draggable = draggable;
        this.element = element;
        this.splitter = splitter;
        this.localization = localization;
        this.orientation = 'horizontal';
        this.index = 0;
        this.ariaRole = 'separator';
        this.focused = false;
        this.subscriptions = new Subscription();
    }
    Object.defineProperty(SplitterBarComponent.prototype, "direction", {
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterBarComponent.prototype, "tabIndex", {
        get: function () {
            return this.splitter.isStatic(this.index) ? -1 : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterBarComponent.prototype, "hostClasses", {
        get: function () {
            var isHorizontal = this.orientation === 'horizontal';
            var isDraggable = this.splitter.isDraggable(this.index);
            var isStatic = this.splitter.isStatic(this.index);
            return classFromObject({
                'k-state-focused': this.focused,
                'k-splitbar': true,
                'k-splitbar-horizontal': isHorizontal,
                'k-splitbar-vertical': !isHorizontal,
                'k-splitbar-draggable-horizontal': isHorizontal && isDraggable,
                'k-splitbar-draggable-vertical': !isHorizontal && isDraggable,
                'k-splitbar-static-horizontal': isHorizontal && isStatic,
                'k-splitbar-static-vertical': !isHorizontal && isStatic,
                'k-touch-action-none': isDraggable
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterBarComponent.prototype, "order", {
        get: function () {
            return 2 * this.index + 1;
        },
        enumerable: true,
        configurable: true
    });
    SplitterBarComponent.prototype.collapseAny = function () {
        if (this.expandLast) {
            this.toggleNext();
        }
        else {
            this.tryToggleNearest();
        }
    };
    SplitterBarComponent.prototype.onFocusIn = function () {
        this.focused = true;
    };
    SplitterBarComponent.prototype.onFocusOut = function () {
        this.focused = false;
    };
    SplitterBarComponent.prototype.onKeyDown = function (event) {
        var _this = this;
        var keyCode = event && event.keyCode;
        var isHorizontal = this.orientation === 'horizontal';
        var resize = function (delta) {
            event.preventDefault();
            var state$$1 = _this.splitter.dragState(_this.index);
            _this.splitter.setSize(state$$1, delta);
        };
        if (keyCode === Keys.Enter) {
            event.preventDefault();
            this.collapseAny();
        }
        else if (isHorizontal && keyCode === Keys.ArrowLeft) {
            resize(-10);
        }
        else if (isHorizontal && keyCode === Keys.ArrowRight) {
            resize(10);
        }
        else if (!isHorizontal && keyCode === Keys.ArrowUp) {
            resize(-10);
        }
        else if (!isHorizontal && keyCode === Keys.ArrowDown) {
            resize(10);
        }
    };
    Object.defineProperty(SplitterBarComponent.prototype, "expandLast", {
        get: function () {
            var panes = this.splitter.panes;
            return panes.length === 2 && panes[1].collapsed;
        },
        enumerable: true,
        configurable: true
    });
    SplitterBarComponent.prototype.ngOnInit = function () {
        var _this = this;
        var state$$1;
        var listener = this.draggable.kendoPress.pipe(tap(stopPropagation), filter(function () { return _this.splitter.isDraggable(_this.index); }), tap(function () { return state$$1 = _this.splitter.dragState(_this.index); }), tap(function () { return _this.splitter.toggleContentOverlay(_this.index, true); }), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.draggable))).subscribe(function (_a) {
            var pageX = _a.pageX, pageY = _a.pageY, originalX = _a.originalX, originalY = _a.originalY;
            var delta;
            if (_this.orientation === 'vertical') {
                delta = pageY - originalY;
            }
            else if (_this.direction === 'rtl') {
                delta = originalX - pageX;
            }
            else {
                delta = pageX - originalX;
            }
            _this.splitter.setSize(state$$1, delta);
        });
        this.subscriptions.add(listener);
        this.subscriptions.add(this.draggable.kendoRelease.subscribe(function () { return _this.splitter.toggleContentOverlay(_this.index, false); }));
    };
    SplitterBarComponent.prototype.ngOnDestroy = function () {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    };
    SplitterBarComponent.prototype.togglePrevious = function () {
        this.splitter.tryToggle(this.index);
    };
    SplitterBarComponent.prototype.toggleNext = function () {
        this.splitter.tryToggle(this.index + 1);
    };
    SplitterBarComponent.prototype.previousArrowClass = function () {
        var pane = this.splitter.pane(this.index);
        var nextPane = this.splitter.pane(this.index + 1);
        var isCollapsible = pane.collapsible;
        var isCollapsed = pane.collapsed;
        var isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible || nextPane.isHidden,
            'k-collapse-prev': isCollapsible,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && isCollapsed
        });
    };
    SplitterBarComponent.prototype.nextArrowClass = function () {
        var pane = this.splitter.pane(this.index + 1);
        var prevPane = this.splitter.pane(this.index);
        var isCollapsible = pane.collapsible;
        var isCollapsed = pane.collapsed;
        var isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible || prevPane.isHidden,
            'k-collapse-next': isCollapsible,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && isCollapsed
        });
    };
    SplitterBarComponent.prototype.tryToggleNearest = function () {
        var prev = this.index;
        var next = this.index + 1;
        if (!this.splitter.tryToggle(prev)) {
            this.splitter.tryToggle(next);
        }
    };
    __decorate([
        Input(),
        HostBinding('attr.aria-orientation'),
        __metadata("design:type", String)
    ], SplitterBarComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SplitterBarComponent.prototype, "index", void 0);
    __decorate([
        HostBinding('attr.role'),
        __metadata("design:type", String)
    ], SplitterBarComponent.prototype, "ariaRole", void 0);
    __decorate([
        HostBinding('class.k-state-focused'),
        __metadata("design:type", Boolean)
    ], SplitterBarComponent.prototype, "focused", void 0);
    __decorate([
        HostBinding('attr.tabindex'),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [])
    ], SplitterBarComponent.prototype, "tabIndex", null);
    __decorate([
        HostBinding('class'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], SplitterBarComponent.prototype, "hostClasses", null);
    __decorate([
        HostBinding('style.-ms-flex-order'),
        HostBinding('style.order'),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [])
    ], SplitterBarComponent.prototype, "order", null);
    __decorate([
        HostListener('dblclick'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], SplitterBarComponent.prototype, "collapseAny", null);
    __decorate([
        HostListener('focusin'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], SplitterBarComponent.prototype, "onFocusIn", null);
    __decorate([
        HostListener('focusout'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], SplitterBarComponent.prototype, "onFocusOut", null);
    __decorate([
        HostListener('keydown', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SplitterBarComponent.prototype, "onKeyDown", null);
    SplitterBarComponent = __decorate([
        Component({
            selector: 'kendo-splitter-bar',
            template: "\n      <div [class]=\"previousArrowClass()\" (click)=\"togglePrevious()\"></div>\n      <div class=\"k-resize-handle\"></div>\n      <div [class]=\"nextArrowClass()\" (click)=\"toggleNext()\"></div>\n    "
        }),
        __param(0, Host()),
        __metadata("design:paramtypes", [DraggableDirective,
            ElementRef,
            SplitterService,
            LocalizationService])
    ], SplitterBarComponent);
    return SplitterBarComponent;
}());

/**
 * Represents the [Kendo UI Splitter component for Angular]({% slug overview_splitter %}).
 *
 * ```ts-preview
 *
 *  @Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-splitter style="height: 280px;">
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / left pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane>
 *            <h3>Inner splitter / center pane</h3>
 *            <p>Resizable only.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / right pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *        </kendo-splitter>
 *      `,
 *    styles: [ `
 *        h3 { font-size: 1.2em; }
 *        h3, p { margin: 10px; padding: 0; }
 *    ` ]
 *  })
 *  class AppComponent {}
 * ```
 */
var SplitterComponent = /** @class */ (function () {
    function SplitterComponent(element, splitterService, localization, renderer, enclosingPane) {
        this.element = element;
        this.splitterService = splitterService;
        this.localization = localization;
        this.renderer = renderer;
        this.enclosingPane = enclosingPane;
        /**
         * Specifies the orientation of the panes within the Splitter.
         * Panes in a horizontal Splitter are placed horizontally.
         * Panes in a vertical Splitter are placed vertically.
         */
        this.orientation = 'horizontal';
        this.ariaRole = 'splitter';
        validatePackage(packageMetadata);
        if (enclosingPane) {
            enclosingPane.containsSplitter = true;
        }
        // the handler only runs in NgZone if there are bound handlers
        // this line merges both streams
        this.layoutChange = this.splitterService.layoutChange;
        this.configure = this.configure.bind(this);
    }
    Object.defineProperty(SplitterComponent.prototype, "hostClasses", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterComponent.prototype, "horizontalHostClasses", {
        get: function () {
            return this.orientation === 'horizontal';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterComponent.prototype, "verticalHostClasses", {
        get: function () {
            return this.orientation === 'vertical';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterComponent.prototype, "splitbars", {
        set: function (splitbars) {
            var _this = this;
            if (!isPresent(splitbars) || !isPresent(this.panes)) {
                return;
            }
            var components = this.panes.toArray().concat(splitbars.toArray()).sort(function (a, b) { return a.order - b.order; });
            var elements = components.map(function (component) { return component.element.nativeElement; });
            elements.forEach(function (element) { return _this.renderer.appendChild(_this.element.nativeElement, element); });
        },
        enumerable: true,
        configurable: true
    });
    SplitterComponent.prototype.ngAfterContentInit = function () {
        this.reconfigure();
    };
    SplitterComponent.prototype.ngOnChanges = function (changes) {
        if (changes.orientation && !changes.orientation.isFirstChange()) {
            this.reconfigure();
        }
    };
    SplitterComponent.prototype.ngOnDestroy = function () {
        if (this.enclosingPane) {
            this.enclosingPane.containsSplitter = false;
        }
        this.unsubscribeChanges();
    };
    SplitterComponent.prototype.reconfigure = function () {
        this.unsubscribeChanges();
        this.configure();
        this.paneChangesSubscription = this.panes.changes.subscribe(this.configure);
    };
    SplitterComponent.prototype.unsubscribeChanges = function () {
        if (this.paneChangesSubscription) {
            this.paneChangesSubscription.unsubscribe();
            this.paneChangesSubscription = null;
        }
    };
    SplitterComponent.prototype.configure = function () {
        var _this = this;
        this.splitterService.configure({
            panes: this.panes.toArray(),
            orientation: this.orientation,
            containerSize: function () {
                if (_this.orientation === 'vertical') {
                    return _this.element.nativeElement.clientHeight;
                }
                else {
                    return _this.element.nativeElement.clientWidth;
                }
            }
        });
    };
    Object.defineProperty(SplitterComponent.prototype, "direction", {
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SplitterComponent.prototype, "orientation", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SplitterComponent.prototype, "layoutChange", void 0);
    __decorate([
        HostBinding('class.k-widget'),
        HostBinding('class.k-splitter'),
        HostBinding('class.k-splitter-flex'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], SplitterComponent.prototype, "hostClasses", null);
    __decorate([
        HostBinding('class.k-splitter-horizontal'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], SplitterComponent.prototype, "horizontalHostClasses", null);
    __decorate([
        HostBinding('class.k-splitter-vertical'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], SplitterComponent.prototype, "verticalHostClasses", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], SplitterComponent.prototype, "dir", null);
    __decorate([
        HostBinding('attr.role'),
        __metadata("design:type", String)
    ], SplitterComponent.prototype, "ariaRole", void 0);
    __decorate([
        ViewChildren(SplitterBarComponent),
        __metadata("design:type", QueryList),
        __metadata("design:paramtypes", [QueryList])
    ], SplitterComponent.prototype, "splitbars", null);
    __decorate([
        ContentChildren(SplitterPaneComponent),
        __metadata("design:type", QueryList)
    ], SplitterComponent.prototype, "panes", void 0);
    SplitterComponent = __decorate([
        Component({
            exportAs: 'kendoSplitter',
            selector: 'kendo-splitter',
            providers: [
                SplitterService,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.spliter'
                }
            ],
            template: "\n      <ng-content select=\"kendo-splitter-pane\"></ng-content>\n      <ng-container *ngFor=\"\n        let pane of panes;\n        let index = index;\n        let last = last;\n      \">\n        <kendo-splitter-bar\n          kendoDraggable\n          *ngIf=\"!last\"\n          [index]=\"index\"\n          [orientation]=\"orientation\">\n        </kendo-splitter-bar>\n      </ng-container>\n    "
        }),
        __param(4, Optional()), __param(4, Host()), __param(4, Inject(SplitterPaneComponent)),
        __metadata("design:paramtypes", [ElementRef,
            SplitterService,
            LocalizationService,
            Renderer2,
            SplitterPaneComponent])
    ], SplitterComponent);
    return SplitterComponent;
}());

/**
 * Represents the content template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabContent` inside the component tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip [ngStyle]="{'width': '400px'}" [animate]="true">
 *           <kendo-tabstrip-tab title="Paris" [selected]="true">
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab title="Sofia">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
var TabContentDirective = /** @class */ (function () {
    function TabContentDirective(templateRef) {
        this.templateRef = templateRef;
    }
    TabContentDirective = __decorate([
        Directive({
            selector: '[kendoTabContent]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], TabContentDirective);
    return TabContentDirective;
}());

/**
 * Represents the title template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabTitle` directive inside the component tag.
 *
 * > The `kendoTabTitle` directive overrides the TabStripTab [title]({% slug api_layout_tabstriptabcomponent %}#toc-title) option.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip>
 *           <kendo-tabstrip-tab [selected]="true">
 *             <ng-template kendoTabTitle>
 *               <h4>Custom Title</h4>
 *             </ng-template>
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab title="Sofia">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
var TabTitleDirective = /** @class */ (function () {
    function TabTitleDirective(templateRef) {
        this.templateRef = templateRef;
    }
    TabTitleDirective = __decorate([
        Directive({
            selector: '[kendoTabTitle]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], TabTitleDirective);
    return TabTitleDirective;
}());

/**
 * Represents the tab component of the TabStrip.
 */
var TabStripTabComponent = /** @class */ (function () {
    function TabStripTabComponent() {
        /**
         * Used to disable a tab ([see example]({% slug tabs_tabstrip %}#toc-disabled-tabs)).
         *
         * Defaults to `false`.
         */
        this.disabled = false;
        this._tabContent = new QueryList();
        /**
         * @hidden
         *
         * Currently only disabled tabs can be focused. Otherwise they will be
         * immediately selected
         */
        this.focused = false;
    }
    Object.defineProperty(TabStripTabComponent.prototype, "tabContent", {
        get: function () {
            return this._tabContent.first;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripTabComponent.prototype, "tabTitle", {
        get: function () {
            return this._tabTitleDirective.first;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TabStripTabComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TabStripTabComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TabStripTabComponent.prototype, "cssClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TabStripTabComponent.prototype, "cssStyle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TabStripTabComponent.prototype, "selected", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TabStripTabComponent.prototype, "closable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TabStripTabComponent.prototype, "closeIcon", void 0);
    __decorate([
        ContentChildren(TabContentDirective),
        __metadata("design:type", QueryList)
    ], TabStripTabComponent.prototype, "_tabContent", void 0);
    __decorate([
        ContentChildren(TabTitleDirective),
        __metadata("design:type", QueryList)
    ], TabStripTabComponent.prototype, "_tabTitleDirective", void 0);
    TabStripTabComponent = __decorate([
        Component({
            exportAs: 'kendoTabStripTab',
            selector: 'kendo-tabstrip-tab',
            template: ""
        })
    ], TabStripTabComponent);
    return TabStripTabComponent;
}());

/**
 * Arguments for the `tabClose` event of the TabStrip.
 * The `tabClose` event fires when the close button of the tab is clicked.
 *
 */
var TabCloseEvent = /** @class */ (function () {
    /**
     * Constructs the event arguments for the `tabClose` event.
     * @param index - The index of the closed tab.
     * @param tab - The closed tab instance
     */
    function TabCloseEvent(index, tab) {
        this.index = index;
        this.tab = tab;
    }
    return TabCloseEvent;
}());

/**
 * Arguments for the `select` event of the TabStrip.
 * The `select` event fires when a tab is selected (clicked).
 */
var SelectEvent = /** @class */ (function (_super) {
    __extends(SelectEvent, _super);
    /**
     * Constructs the event arguments for the `select` event.
     * @param index - The index of the selected tab.
     * @param title - The title of the selected tab.
     */
    function SelectEvent(index, title) {
        var _this = _super.call(this) || this;
        _this.index = index;
        _this.title = title;
        return _this;
    }
    return SelectEvent;
}(PreventableEvent));

/**
 * @hidden
 *
 * Checks if the current target is a TabStrip tab element
 */
var isTabElement = function (target) {
    var targetId = target.getAttribute('id');
    if (isPresent(targetId) || targetId.indexOf('k-tabstrip-tab-') >= 0) {
        return true;
    }
    return false;
};
/**
 * @hidden
 *
 * Checks if the current tab is closable. Depends on the value of the TabStrip closable property.
 */
var isTabClosable = function (tab, tabStripClosable) {
    if (tab.closable !== undefined) {
        return tab.closable;
    }
    return tabStripClosable;
};
/**
 * @hidden
 *
 * Checks if the TabStrip scroll buttons will be rendered. Depends on the value of the TabStrip scrollable settings.
 */
var tabStripHasScrollButtons = function (scrollableSettings) {
    return scrollableSettings.enabled && scrollableSettings.scrollButtons !== 'hidden';
};
/**
 * @hidden
 *
 * Checks if the TabStrip mouse scroll will be enabled. Depends on the value of the TabStrip scrollable settings.
 */
var mouseScrollEnabled = function (scrollableSettings) {
    return scrollableSettings.enabled && scrollableSettings.mouseScroll;
};
/**
 * @hidden
 *
 * Retrieves the current active tab element and its index.
 * This could either be the currently selected tab or the currently focused tab.
 */
var getActiveTab = function (tabs) {
    var focusedTab;
    var selectedTab;
    var focusedIndex = -1;
    var selectedIndex = -1;
    tabs.forEach(function (tab, index) {
        if (tab.selected) {
            selectedTab = tab;
            selectedIndex = index;
        }
        else if (tab.focused) {
            focusedTab = tab;
            focusedIndex = index;
        }
    });
    return focusedIndex >= 0 ?
        { tab: focusedTab, index: focusedIndex } :
        { tab: selectedTab, index: selectedIndex };
};
/**
 * @hidden
 */
var getTabByIndex = function (tabs, index) {
    var filtered = tabs.filter(function (_tab, i) { return i === index; });
    if (filtered.length > 0) {
        return filtered[0];
    }
    return null;
};
/**
 * @hidden
 */
var getTabHeaderByIndex = function (tabHeaderContainers, index) {
    var filtered = tabHeaderContainers.filter(function (_tabHeader, i) { return i === index; });
    if (filtered.length > 0) {
        return filtered[0];
    }
    return null;
};
/**
 * @hidden
 */
var resetTabFocus = function (tabs) {
    tabs.forEach(function (tab) {
        tab.focused = false;
    });
};
/**
 * @hidden
 */
var resetTabSelection = function (tabs) {
    tabs.forEach(function (tab) {
        tab.selected = false;
    });
};
/**
 * @hidden
 */
var isTablistHorizontal = function (tabPosition) {
    return tabPosition === 'top' || tabPosition === 'bottom';
};

/**
 * @hidden
 */
var TabStripService = /** @class */ (function () {
    function TabStripService(localization, ngZone) {
        this.localization = localization;
        this.ngZone = ngZone;
    }
    TabStripService.prototype.onKeyDown = function (event) {
        if (!isTabElement(event.target)) {
            return;
        }
        var key = event.keyCode;
        if (this.shouldHandleKey(key)) {
            event.preventDefault();
        }
        else {
            return;
        }
        if (isNavigationKey(key) || isArrowKey(key)) {
            this.onNavigate(key);
        }
        else if (key === Keys.Delete) {
            this.onDelete();
        }
    };
    TabStripService.prototype.onTabSelect = function (tab, index) {
        var selectArgs = new SelectEvent(index, tab.title);
        this.owner.tabSelect.emit(selectArgs);
        if (!selectArgs.isDefaultPrevented()) {
            if (tab.selected) {
                this.focusTabHeader(index);
                return;
            }
            this.selectTab(tab, index);
        }
    };
    TabStripService.prototype.selectTab = function (tab, index) {
        resetTabSelection(this.owner.tabs);
        this.focusTabHeader(index);
        tab.selected = true;
        if (this.owner.isScrollable) {
            this.owner.scrollToSelectedTab();
        }
    };
    TabStripService.prototype.onTabClose = function (tab, index) {
        var closeArgs = new TabCloseEvent(index, tab);
        this.owner.tabClose.emit(closeArgs);
    };
    TabStripService.prototype.onNavigate = function (keyCode) {
        var _this = this;
        var _a = getActiveTab(this.owner.tabs), activeTab = _a.tab, activeIndex = _a.index;
        if (!NgZone.isInAngularZone()) {
            this.ngZone.run(function () {
                if (activeIndex < 0) {
                    _this.owner.selectTab(_this.firstNavigatableIndex());
                    return;
                }
                activeTab.focused = false;
                var nextIndex = _this.computeNextIndex(activeIndex, keyCode);
                _this.activateTab(nextIndex);
            });
        }
    };
    TabStripService.prototype.onDelete = function () {
        var _this = this;
        var _a = getActiveTab(this.owner.tabs), activeTab = _a.tab, activeTabIndex = _a.index;
        if (isTabClosable(activeTab, this.owner.closable) && !activeTab.disabled) {
            this.ngZone.run(function () {
                _this.onTabClose(activeTab, activeTabIndex);
            });
        }
    };
    TabStripService.prototype.activateTab = function (index) {
        var tab = getTabByIndex(this.owner.tabs, index);
        if (tab.disabled) {
            this.focusTabHeader(index);
            tab.focused = true;
        }
        else {
            this.onTabSelect(tab, index);
        }
    };
    TabStripService.prototype.focusTabHeader = function (index) {
        var tabHeader = getTabHeaderByIndex(this.owner.tabHeaderContainers, index);
        tabHeader.nativeElement.focus();
    };
    TabStripService.prototype.shouldHandleKey = function (keyCode) {
        if (isNavigationKey(keyCode)) {
            return true;
        }
        if (isTablistHorizontal(this.owner.tabPosition) && isHorizontalArrowKey(keyCode)) {
            return true;
        }
        if (!isTablistHorizontal(this.owner.tabPosition) && isVerticalArrowKey(keyCode)) {
            return true;
        }
        if (keyCode === Keys.Delete) {
            return true;
        }
        return false;
    };
    TabStripService.prototype.computeNextIndex = function (activeIndex, keyCode) {
        switch (keyCode) {
            case this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight):
            case this.invertKeys(Keys.ArrowUp, Keys.ArrowDown):
                return this.prevNavigatableIndex(activeIndex);
            case this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft):
            case this.invertKeys(Keys.ArrowDown, Keys.ArrowUp):
                return this.nextNavigatableIndex(activeIndex);
            case Keys.Home:
                return this.firstNavigatableIndex();
            case Keys.End:
                return this.lastNavigatableIndex();
            default:
                return;
        }
    };
    TabStripService.prototype.invertKeys = function (original, inverted) {
        return this.localization.rtl ? inverted : original;
    };
    TabStripService.prototype.firstNavigatableIndex = function () {
        return 0;
    };
    TabStripService.prototype.lastNavigatableIndex = function () {
        return this.owner.tabs.length - 1;
    };
    TabStripService.prototype.prevNavigatableIndex = function (selectedIndex) {
        if (selectedIndex - 1 < 0) {
            return this.lastNavigatableIndex();
        }
        return selectedIndex - 1;
    };
    TabStripService.prototype.nextNavigatableIndex = function (selectedIndex) {
        if (selectedIndex + 1 >= this.owner.tabs.length) {
            return this.firstNavigatableIndex();
        }
        return selectedIndex + 1;
    };
    TabStripService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [LocalizationService,
            NgZone])
    ], TabStripService);
    return TabStripService;
}());

/**
 * @hidden
 */
var MOUSE_SCROLL_SPEED = 10;
/**
 * @hidden
 */
var BUTTON_SCROLL_SPEED = 100;
/**
 * @hidden
 */
var HIDDEN_CLASS = 'k-hidden';
/**
 * @hidden
 */
var DIRECTION_CLASSES = {
    left: 'k-i-arrow-60-left',
    right: 'k-i-arrow-60-right',
    up: 'k-i-arrow-60-up',
    down: 'k-i-arrow-60-down'
};
/**
 * @hidden
 */
var DEFAULT_SCROLL_BEHAVIOR = 'smooth';

/**
 * Arguments for the `tabScroll` event of the TabStrip.
 * The `tabScroll` event fires when the tabs are being scrolled.
 *
 */
var TabScrollEvent = /** @class */ (function (_super) {
    __extends(TabScrollEvent, _super);
    function TabScrollEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TabScrollEvent;
}(PreventableEvent$1));

/**
 * @hidden
 */
var ScrollService = /** @class */ (function () {
    function ScrollService(ngZone) {
        this.ngZone = ngZone;
        this.position = 0;
        this.scrollButtonActiveStateChange = new Subject();
    }
    Object.defineProperty(ScrollService.prototype, "tablistElement", {
        get: function () {
            return this.owner.tablist.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollService.prototype, "scrollButtonIconClass", {
        get: function () {
            var tabStrip = this.owner;
            var defaultPrevIcon = isTablistHorizontal(tabStrip.tabPosition) ? DIRECTION_CLASSES.left : DIRECTION_CLASSES.up;
            var defaultNextIcon = isTablistHorizontal(tabStrip.tabPosition) ? DIRECTION_CLASSES.right : DIRECTION_CLASSES.down;
            if (typeof tabStrip.scrollable === 'object') {
                var prevIcon = typeof tabStrip.scrollable.prevButtonIcon === 'undefined' ? defaultPrevIcon : tabStrip.scrollable.prevButtonIcon;
                var nextIcon = typeof tabStrip.scrollable.nextButtonIcon === 'undefined' ? defaultNextIcon : tabStrip.scrollable.nextButtonIcon;
                return { prevScrollButton: prevIcon, nextScrollButton: nextIcon };
            }
            return { prevScrollButton: defaultPrevIcon, nextScrollButton: defaultNextIcon };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollService.prototype, "tabstripSize", {
        get: function () {
            var hostElement = this.owner.wrapper.nativeElement;
            var wrapperWidth = parseFloat(getComputedStyle(hostElement).width);
            var wrapperHeight = parseFloat(getComputedStyle(hostElement).height);
            return isTablistHorizontal(this.owner.tabPosition) ? wrapperWidth : wrapperHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollService.prototype, "tablistOverflowSize", {
        get: function () {
            if (!isDocumentAvailable()) {
                return 0;
            }
            var isHorizontal = isTablistHorizontal(this.owner.tabPosition);
            var overflowSize = Math.floor(this.tablistElement[isHorizontal ? 'scrollWidth' : 'scrollHeight']
                - this.tablistElement.getBoundingClientRect()[isHorizontal ? 'width' : 'height']);
            return overflowSize < 0 ? 0 : overflowSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollService.prototype, "tabsOverflow", {
        get: function () {
            return this.tablistOverflowSize > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollService.prototype, "scrollButtonsSize", {
        get: function () {
            if (!this.owner.hasScrollButtons) {
                return 0;
            }
            var prevRect = this.owner.prevScrollButton.hostBoundingClientRect;
            var prevSize = isTablistHorizontal(this.owner.tabPosition) ? prevRect.width : prevRect.height;
            var nextRect = this.owner.nextScrollButton.hostBoundingClientRect;
            var nextSize = isTablistHorizontal(this.owner.tabPosition) ? nextRect.width : nextRect.height;
            return prevSize + nextSize;
        },
        enumerable: true,
        configurable: true
    });
    ScrollService.prototype.toggleScrollButtonsState = function () {
        var _this = this;
        var tabStrip = this.owner;
        if (!tabStrip.hasScrollButtons) {
            return;
        }
        var currentPrevButtonActive = !tabStrip.prevScrollButton.disabled;
        var currentNextButtonActive = !tabStrip.nextScrollButton.disabled;
        var calculatedPrevButtonActive = this.position > 0 && this.tablistOverflowSize > 0;
        var calculatedNextButtonActive = this.position < this.tablistOverflowSize + this.scrollButtonsSize && this.tablistOverflowSize > 0;
        if (calculatedPrevButtonActive !== currentPrevButtonActive) {
            this.ngZone.run(function () { return _this.toggleButtonActiveState('prev', calculatedPrevButtonActive); });
        }
        if (calculatedNextButtonActive !== currentNextButtonActive) {
            this.ngZone.run(function () { return _this.toggleButtonActiveState('next', calculatedNextButtonActive); });
        }
    };
    ScrollService.prototype.scrollToSelectedTab = function () {
        var _this = this;
        if (!this.tabsOverflow) {
            return;
        }
        var activeIndex = getActiveTab(this.owner.tabs).index;
        if (activeIndex === -1) {
            return;
        }
        this.position += this.getScrollOffset(activeIndex);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollLeft = this.position;
        }
        else {
            this.tablistElement.scrollTop = this.position;
        }
        this.toggleScrollButtonsState();
        var tabStrip = this.owner;
        if (!tabStrip.hasScrollButtons) {
            return;
        }
        var isFirstTabActive = activeIndex === 0;
        var isLastTabActive = activeIndex === this.owner.tabs.length - 1;
        if (isFirstTabActive && !tabStrip.prevScrollButton.disabled) {
            this.ngZone.run(function () { return _this.toggleButtonActiveState('prev', false); });
        }
        if (isLastTabActive && !tabStrip.nextScrollButton.disabled) {
            this.ngZone.run(function () { return _this.toggleButtonActiveState('next', false); });
        }
    };
    ScrollService.prototype.getScrollOffset = function (activeIndex) {
        if (!isDocumentAvailable()) {
            return 0;
        }
        var isHorizontal = isTablistHorizontal(this.owner.tabPosition);
        this.tablistElement["scroll" + (isHorizontal ? 'Left' : 'Top')] = this.position;
        var activeTabRect = this.tablistElement.children[activeIndex].getBoundingClientRect();
        var tablistRect = this.tablistElement.getBoundingClientRect();
        var end = isHorizontal ? 'right' : 'bottom';
        var start = isHorizontal ? 'left' : 'top';
        var activeTabStart = activeTabRect[start];
        var activeTabEnd = activeTabRect[end];
        var tablistStart = tablistRect[start];
        var tablistEnd = tablistRect[end];
        var tabEndIsInVisibleRange = activeTabEnd <= tablistEnd;
        var tabStartIsInVisibleRange = activeTabStart >= tablistStart;
        var isWholeTabVisible = tabEndIsInVisibleRange && tabStartIsInVisibleRange;
        if (isWholeTabVisible) {
            return 0;
        }
        if (!tabEndIsInVisibleRange) {
            return activeTabEnd - tablistEnd;
        }
        if (!tabStartIsInVisibleRange) {
            return activeTabStart - tablistStart;
        }
    };
    ScrollService.prototype.onMouseScroll = function (event) {
        event.preventDefault();
        if (!mouseScrollEnabled(this.owner.scrollable)) {
            return;
        }
        var direction = event.deltaY < 0 ? 'prev' : 'next';
        this.calculateListPosition(direction, this.owner.scrollable.mouseScrollSpeed);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollLeft = this.position;
        }
        else {
            this.tablistElement.scrollTop = this.position;
        }
        this.toggleScrollButtonsState();
    };
    ScrollService.prototype.scrollTabs = function (direction) {
        this.calculateListPosition(direction, this.owner.scrollable.buttonScrollSpeed);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollTo({ left: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        else {
            this.tablistElement.scrollTo({ top: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        this.toggleScrollButtonsState();
    };
    ScrollService.prototype.calculateListPosition = function (direction, scrollSpeed) {
        var adjustedMaxScroll = this.tablistOverflowSize + this.scrollButtonsSize;
        if (direction === 'prev' && this.position > 0) {
            this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;
        }
        else if (direction === 'next' && this.position < adjustedMaxScroll) {
            if (this.position + scrollSpeed > adjustedMaxScroll) {
                this.position = adjustedMaxScroll;
                return;
            }
            this.position += scrollSpeed;
        }
    };
    ScrollService.prototype.emitScrollEvent = function (ev) {
        var scrollEvent = new TabScrollEvent({
            originalEvent: ev
        });
        if (hasObservers(this.owner.tabScroll)) {
            this.owner.tabScroll.emit(scrollEvent);
        }
        return scrollEvent;
    };
    ScrollService.prototype.restoreScrollPosition = function () {
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollTo({ left: this.position });
        }
        else {
            this.tablistElement.scrollTo({ top: this.position });
        }
        this.toggleScrollButtonsState();
    };
    ScrollService.prototype.toggleButtonActiveState = function (buttonType, active) {
        this.scrollButtonActiveStateChange.next({ buttonType: buttonType, active: active });
    };
    ScrollService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [NgZone])
    ], ScrollService);
    return ScrollService;
}());

/**
 * @hidden
 */
var normalizeSettings = function (_a) {
    var _b = _a.enabled, enabled = _b === void 0 ? true : _b, _c = _a.scrollButtons, scrollButtons = _c === void 0 ? 'auto' : _c, _d = _a.mouseScroll, mouseScroll = _d === void 0 ? true : _d, _e = _a.buttonScrollSpeed, buttonScrollSpeed = _e === void 0 ? BUTTON_SCROLL_SPEED : _e, _f = _a.mouseScrollSpeed, mouseScrollSpeed = _f === void 0 ? MOUSE_SCROLL_SPEED : _f, prevButtonIcon = _a.prevButtonIcon, nextButtonIcon = _a.nextButtonIcon;
    return ({
        enabled: enabled,
        scrollButtons: scrollButtons,
        mouseScroll: mouseScroll,
        buttonScrollSpeed: buttonScrollSpeed,
        mouseScrollSpeed: mouseScrollSpeed,
        prevButtonIcon: prevButtonIcon,
        nextButtonIcon: nextButtonIcon
    });
};
/**
 * @hidden
 */
var normalizeScrollableSettings = function (settings) {
    return normalizeSettings(settings === false ? { enabled: false } : settings);
};

/**
 * @hidden
 */
var TabStripScrollableButtonComponent = /** @class */ (function () {
    function TabStripScrollableButtonComponent(host, scrollService, renderer, ngZone) {
        var _this = this;
        this.host = host;
        this.scrollService = scrollService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.btnClasses = true;
        this.prev = false;
        this._disabled = false;
        this.subs = new Subscription();
        this.clickHandler = function (scrollEvent) {
            var tabStripScrollEvent = _this.scrollService.emitScrollEvent(scrollEvent);
            var isTabStripScrollEventPrevented = tabStripScrollEvent.isDefaultPrevented();
            if (isTabStripScrollEventPrevented) {
                return;
            }
            var buttonType = _this.prev ? 'prev' : 'next';
            _this.scrollService.scrollTabs(buttonType);
        };
        this.subs.add(this.scrollService.scrollButtonActiveStateChange.subscribe(function (activeButtonSettings) {
            var applyActiveState = (_this.prev && activeButtonSettings.buttonType === 'prev') ||
                (!_this.prev && activeButtonSettings.buttonType === 'next');
            if (applyActiveState) {
                _this.disabled = !activeButtonSettings.active;
            }
        }));
    }
    Object.defineProperty(TabStripScrollableButtonComponent.prototype, "prevClass", {
        get: function () {
            return this.prev;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripScrollableButtonComponent.prototype, "nextClass", {
        get: function () {
            return !this.prev;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripScrollableButtonComponent.prototype, "disabled", {
        get: function () {
            return this._disabled;
        },
        set: function (value) {
            this._disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripScrollableButtonComponent.prototype, "hostBoundingClientRect", {
        get: function () {
            return this.host.nativeElement.getBoundingClientRect();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripScrollableButtonComponent.prototype, "iconClass", {
        get: function () {
            return this.scrollService.scrollButtonIconClass[this.prev ? 'prevScrollButton' : 'nextScrollButton'];
        },
        enumerable: true,
        configurable: true
    });
    TabStripScrollableButtonComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            _this.subs.add(_this.renderer.listen(_this.host.nativeElement, 'click', _this.clickHandler));
        });
    };
    TabStripScrollableButtonComponent.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    TabStripScrollableButtonComponent.prototype.toggle = function (show) {
        this.renderer[show ? 'removeClass' : 'addClass'](this.host.nativeElement, HIDDEN_CLASS);
    };
    __decorate([
        HostBinding('class.k-button'),
        HostBinding('class.k-button-md'),
        HostBinding('class.k-icon-button'),
        HostBinding('class.k-rounded-md'),
        HostBinding('class.k-button-flat'),
        HostBinding('class.k-button-flat-base'),
        __metadata("design:type", Boolean)
    ], TabStripScrollableButtonComponent.prototype, "btnClasses", void 0);
    __decorate([
        HostBinding('class.k-tabstrip-prev'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TabStripScrollableButtonComponent.prototype, "prevClass", null);
    __decorate([
        HostBinding('class.k-tabstrip-next'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TabStripScrollableButtonComponent.prototype, "nextClass", null);
    __decorate([
        HostBinding('class.k-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], TabStripScrollableButtonComponent.prototype, "disabled", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TabStripScrollableButtonComponent.prototype, "prev", void 0);
    TabStripScrollableButtonComponent = __decorate([
        Component({
            template: "\n        <span class=\"k-icon k-button-icon\" [ngClass]=\"iconClass\"></span>\n    ",
            selector: '[kendoTabStripScrollableButton]'
        }),
        __metadata("design:paramtypes", [ElementRef,
            ScrollService,
            Renderer2,
            NgZone])
    ], TabStripScrollableButtonComponent);
    return TabStripScrollableButtonComponent;
}());

/**
 * Represents the [Kendo UI TabStrip component for Angular]({% slug overview_tabstrip %}).
 */
var TabStripComponent = /** @class */ (function () {
    function TabStripComponent(localization, renderer, wrapper, tabstripService, scrollService, ngZone) {
        this.localization = localization;
        this.renderer = renderer;
        this.wrapper = wrapper;
        this.tabstripService = tabstripService;
        this.scrollService = scrollService;
        this.ngZone = ngZone;
        /**
         * Enables the tab animation.
         *
         * @default true
         */
        this.animate = true;
        /**
         * Sets the position of the tabs. Defaults to `top`.
         *
         * @default 'top'
         */
        this.tabPosition = 'top';
        /**
         * When set to `true`, the component renders all tabs and they are persisted in the DOM.
         * By default, `keepTabContent` is `false`.
         *
         * @default false
         */
        this.keepTabContent = false;
        /**
         * When set to `true`, a close button will be rendered inside each tab.
         * By default, `closable` is `false`.
         *
         * @default false
         */
        this.closable = false;
        /**
         * Allows defining a custom CSS class, or multiple classes separated by spaces, which will be applied to the close button span element.
         * Allows the usage of custom icons.
         */
        this.closeIcon = 'k-icon k-i-x';
        /**
         * Fires each time the user selects a tab ([see example]({% slug overview_tabstrip %}#toc-basic-usage)).
         * The event data contains the index of the selected tab and its title.
         */
        this.tabSelect = new EventEmitter();
        /**
         * Fires each time the user closes a tab.
         * The event data contains the index of the closed tab and its instance.
         */
        this.tabClose = new EventEmitter();
        /**
         * Fires each time the user scrolls the TabStrip list.
         * The event is preventable.
         */
        this.tabScroll = new EventEmitter();
        this.hostClasses = true;
        /**
         * A query list of all declared tabs.
         */
        this.tabs = new QueryList();
        this._scrollableSettings = normalizeScrollableSettings(false);
        this.subscriptions = new Subscription();
        this.subscriptionsArePresent = false;
        validatePackage(packageMetadata);
        this.tabstripService.owner = this;
        this.scrollService.owner = this;
    }
    Object.defineProperty(TabStripComponent.prototype, "height", {
        get: function () {
            return this._height;
        },
        /**
         * Sets the height of the TabStrip.
         */
        set: function (value) {
            this._height = value;
            this.renderer.setStyle(this.wrapper.nativeElement, 'height', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "scrollable", {
        get: function () {
            return this._scrollableSettings;
        },
        /**
         * Enables the scrolling of the tab list. When set to `true` and the total size of all tabs
         * is greater than the size of the TabStrip container, scroll buttons will be rendered on each end of the tab list.
         *
         * By default, `scrollable` is `false`.
         *
         * @default false
         */
        set: function (value) {
            this._scrollableSettings = normalizeScrollableSettings(value);
            if (this.tablist) {
                this.toggleScrollButtons(this.scrollService.tabsOverflow);
                this.attachWheelHandler(this.tablist.nativeElement);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabsAtTop", {
        get: function () {
            return this.tabPosition === 'top';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabsAtRight", {
        get: function () {
            return this.tabPosition === 'right';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabsAtBottom", {
        get: function () {
            return this.tabPosition === 'bottom';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabsAtLeft", {
        get: function () {
            return this.tabPosition === 'left';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "dir", {
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabStripScrollable", {
        get: function () {
            return this._scrollableSettings.enabled;
        },
        enumerable: true,
        configurable: true
    });
    TabStripComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            if (_this.scrollService.tabsOverflow) {
                _this.toggleScrollButtons(true);
            }
            else {
                _this.toggleScrollButtons(false);
            }
            setTimeout(function () {
                _this.scrollToSelectedTab();
            });
        });
        this.initDomEvents();
    };
    TabStripComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        var positionChange = changes.tabPosition;
        if (positionChange) {
            var tabsAtBottomChanged_1 = positionChange.previousValue === 'bottom' || positionChange.currentValue === 'bottom';
            this.ngZone.onStable.pipe(take(1)).subscribe(function () {
                if (tabsAtBottomChanged_1) {
                    if (_this.subscriptionsArePresent) {
                        _this.subscriptions.unsubscribe();
                        _this.subscriptions = new Subscription();
                        _this.subscriptionsArePresent = false;
                    }
                    _this.initDomEvents();
                }
                _this.scrollService.restoreScrollPosition();
            });
        }
    };
    TabStripComponent.prototype.ngOnDestroy = function () {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    };
    Object.defineProperty(TabStripComponent.prototype, "tabsAlignmentStyles", {
        /**
         * @hidden
         */
        get: function () {
            return {
                start: 'flex-start',
                end: 'flex-end',
                center: 'center',
                justify: 'space-between'
            }[this.tabAlignment];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabListWidth", {
        /**
         * @hidden
         */
        get: function () {
            if (this.tabPosition === 'top' || this.tabPosition === 'bottom') {
                return '100%';
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabListHeight", {
        /**
         * @hidden
         */
        get: function () {
            if (this.tabPosition === 'left' || this.tabPosition === 'right') {
                return '100%';
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "isScrollable", {
        /**
         * @hidden
         */
        get: function () {
            return this._scrollableSettings.enabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "hasScrollButtons", {
        /**
         * @hidden
         */
        get: function () {
            return tabStripHasScrollButtons(this._scrollableSettings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "mouseScrollEnabled", {
        /**
         * @hidden
         */
        get: function () {
            return mouseScrollEnabled(this._scrollableSettings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "itemsWrapperClass", {
        /**
         * @hidden
         */
        get: function () {
            return isTablistHorizontal(this.tabPosition) ? 'k-hstack' : 'k-vstack';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Allows the user to select a tab programmatically.
     * @param {number} index - The index of the tab that will be selected.
     */
    TabStripComponent.prototype.selectTab = function (index) {
        var tab = getTabByIndex(this.tabs, index);
        if (!tab || tab.disabled) {
            return;
        }
        this.tabstripService.selectTab(tab, index);
        this.scrollToSelectedTab();
    };
    /**
     * @hidden
     */
    TabStripComponent.prototype.onTabClick = function (originalEvent, tabIndex) {
        if (isFocusable(originalEvent.target)) {
            return;
        }
        var targetElement = originalEvent.target;
        var isTargetCloseButton = hasClass(targetElement, 'k-remove-tab') || hasClass(targetElement.parentElement, 'k-remove-tab');
        if (isTargetCloseButton) {
            return;
        }
        var tab = getTabByIndex(this.tabs, tabIndex);
        this.tabstripService.onTabSelect(tab, tabIndex);
        this.scrollToSelectedTab();
    };
    /**
     * @hidden
     */
    TabStripComponent.prototype.onResize = function () {
        var _this = this;
        if (this.scrollService.tabsOverflow) {
            this.toggleScrollButtons(true);
        }
        else {
            this.toggleScrollButtons(false);
        }
        this.ngZone.runOutsideAngular(function () {
            _this.scrollService.toggleScrollButtonsState();
        });
    };
    /**
     * @hidden
     */
    TabStripComponent.prototype.scrollToSelectedTab = function () {
        if (this._scrollableSettings.enabled) {
            this.scrollService.scrollToSelectedTab();
        }
    };
    TabStripComponent.prototype.initDomEvents = function () {
        var _this = this;
        if (!this.wrapper || this.subscriptionsArePresent) {
            return;
        }
        var tablist = this.tablist.nativeElement;
        this.ngZone.runOutsideAngular(function () {
            _this.subscriptions.add(_this.renderer.listen(tablist, 'keydown', function (ev) {
                _this.tabstripService.onKeyDown(ev);
            }));
        });
        this.subscriptions.add(this.renderer.listen(tablist, 'focusout', function () {
            resetTabFocus(_this.tabs);
        }));
        if (this.isScrollable && this.mouseScrollEnabled) {
            this.attachWheelHandler(tablist);
        }
        this.subscriptionsArePresent = true;
    };
    TabStripComponent.prototype.toggleScrollButtons = function (tabsOverflow) {
        var _this = this;
        this.ngZone.onStable.pipe(take(1)).subscribe(function () {
            var scrollButtonsSetting = _this._scrollableSettings.scrollButtons;
            var scrollButtonsArePresent = _this.prevScrollButton && _this.nextScrollButton;
            var shouldShowButtons = scrollButtonsArePresent && tabsOverflow;
            var shouldHideButtons = scrollButtonsArePresent &&
                !tabsOverflow &&
                scrollButtonsSetting !== 'visible';
            var alwaysVisible = scrollButtonsSetting === 'visible';
            if (shouldHideButtons) {
                _this.prevScrollButton.toggle(false);
                _this.nextScrollButton.toggle(false);
            }
            else if (shouldShowButtons || alwaysVisible) {
                _this.prevScrollButton.toggle(true);
                _this.nextScrollButton.toggle(true);
            }
            if (scrollButtonsArePresent && alwaysVisible) {
                _this.ngZone.runOutsideAngular(function () {
                    _this.scrollService.toggleScrollButtonsState();
                });
            }
        });
    };
    TabStripComponent.prototype.attachWheelHandler = function (tablist) {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            _this.subscriptions.add(_this.renderer.listen(tablist, 'wheel', function (wheelEvent) {
                var tabStripScrollEvent = _this.scrollService.emitScrollEvent(wheelEvent);
                var isTabStripScrollEventPrevented = tabStripScrollEvent.isDefaultPrevented();
                if (isTabStripScrollEventPrevented || !_this.scrollService.tabsOverflow) {
                    return;
                }
                _this.scrollService.onMouseScroll(wheelEvent);
            }));
        });
    };
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], TabStripComponent.prototype, "height", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TabStripComponent.prototype, "animate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TabStripComponent.prototype, "tabAlignment", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TabStripComponent.prototype, "tabPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TabStripComponent.prototype, "keepTabContent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TabStripComponent.prototype, "closable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], TabStripComponent.prototype, "scrollable", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TabStripComponent.prototype, "closeIcon", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TabStripComponent.prototype, "tabSelect", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TabStripComponent.prototype, "tabClose", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TabStripComponent.prototype, "tabScroll", void 0);
    __decorate([
        HostBinding('class.k-tabstrip'),
        HostBinding('class.k-floatwrap'),
        __metadata("design:type", Boolean)
    ], TabStripComponent.prototype, "hostClasses", void 0);
    __decorate([
        HostBinding('class.k-tabstrip-top'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TabStripComponent.prototype, "tabsAtTop", null);
    __decorate([
        HostBinding('class.k-tabstrip-right'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TabStripComponent.prototype, "tabsAtRight", null);
    __decorate([
        HostBinding('class.k-tabstrip-bottom'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TabStripComponent.prototype, "tabsAtBottom", null);
    __decorate([
        HostBinding('class.k-tabstrip-left'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TabStripComponent.prototype, "tabsAtLeft", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TabStripComponent.prototype, "dir", null);
    __decorate([
        HostBinding('class.k-tabstrip-scrollable'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TabStripComponent.prototype, "tabStripScrollable", null);
    __decorate([
        ContentChildren(TabStripTabComponent),
        __metadata("design:type", QueryList)
    ], TabStripComponent.prototype, "tabs", void 0);
    __decorate([
        ViewChild('tablist', { static: false }),
        __metadata("design:type", ElementRef)
    ], TabStripComponent.prototype, "tablist", void 0);
    __decorate([
        ViewChildren('tabHeaderContainer', { read: ElementRef }),
        __metadata("design:type", QueryList)
    ], TabStripComponent.prototype, "tabHeaderContainers", void 0);
    __decorate([
        ViewChild('prevScrollButton', { static: false }),
        __metadata("design:type", TabStripScrollableButtonComponent)
    ], TabStripComponent.prototype, "prevScrollButton", void 0);
    __decorate([
        ViewChild('nextScrollButton', { static: false }),
        __metadata("design:type", TabStripScrollableButtonComponent)
    ], TabStripComponent.prototype, "nextScrollButton", void 0);
    TabStripComponent = __decorate([
        Component({
            animations: [
                trigger('state', [
                    state('active', style({ opacity: 1 })),
                    transition('* => active', [
                        style({ opacity: 0 }),
                        animate('400ms ease-in')
                    ])
                ])
            ],
            providers: [
                TabStripService,
                ScrollService,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.tabstrip'
                }
            ],
            exportAs: 'kendoTabStrip',
            selector: 'kendo-tabstrip',
            template: "\n        <ng-container kendoTabStripLocalizedMessages\n            i18n-closeTitle=\"kendo.tabstrip.closeTitle|The title for the **Close** button in the TabStrip tab.\"\n            closeTitle=\"Close\">\n        </ng-container>\n        <ng-container *ngIf=\"!tabsAtBottom\">\n            <ng-container *ngTemplateOutlet=\"heading\">\n            </ng-container>\n            <ng-container *ngTemplateOutlet=\"content\">\n            </ng-container>\n        </ng-container>\n\n        <ng-container *ngIf=\"tabsAtBottom\">\n            <ng-container *ngTemplateOutlet=\"content\">\n            </ng-container>\n            <ng-container *ngTemplateOutlet=\"heading\">\n            </ng-container>\n        </ng-container>\n        <ng-template #heading>\n            <div class=\"k-tabstrip-items-wrapper\" [ngClass]=\"itemsWrapperClass\">\n                <span *ngIf=\"hasScrollButtons\"\n                     #prevScrollButton\n                    kendoTabStripScrollableButton\n                    [prev]=\"true\"></span>\n                <ul role=\"tablist\" #tablist\n                    class=\"k-reset k-tabstrip-items\"\n                    [style.justifyContent]=\"tabsAlignmentStyles\"\n                    [style.width]=\"tabListWidth\"\n                    [style.height]=\"tabListHeight\"\n                >\n                    <ng-container *ngFor=\"let tab of tabs; let i = index;\">\n                        <li *ngIf=\"!tab.closed\"\n                            #tabHeaderContainer\n                            kendoTabStripTab\n                            [ngClass]=\"tab.cssClass\"\n                            [ngStyle]=\"tab.cssStyle\"\n                            [tab]=\"tab\"\n                            [index]=\"i\"\n                            role=\"tab\"\n                            [tabStripClosable]=\"closable\"\n                            [tabStripCloseIcon]=\"closeIcon\"\n                            (click)=\"onTabClick($event, i)\"\n                            [id]=\"'k-tabstrip-tab-' + i\"\n                            [attr.aria-controls]=\"'k-tabstrip-tabpanel-' + i\">\n                        </li>\n                    </ng-container>\n                </ul>\n                <span *ngIf=\"hasScrollButtons\" #nextScrollButton\n                    kendoTabStripScrollableButton\n                    [prev]=\"false\">\n                </span>\n            </div>\n        </ng-template>\n        <ng-template #content>\n            <ng-template ngFor let-tab [ngForOf]=\"tabs\" let-i=\"index\">\n                <div\n                    [@state]=\"tab.selected && animate ? 'active' : 'inactive'\"\n                    *ngIf=\"!tab.closed && (tab.selected || keepTabContent)\"\n                    [ngClass]=\"!this.keepTabContent || tab.selected ? 'k-content k-state-active' : 'k-content'\"\n                    [tabIndex]=\"0\"\n                    role=\"tabpanel\"\n                    [id]=\"'k-tabstrip-tabpanel-' + i\"\n                    [attr.aria-hidden]=\"!tab.selected\"\n                    [attr.aria-expanded]=\"tab.selected\"\n                    [attr.aria-labelledby]=\"'k-tabstrip-tab-' + i\"\n                    [attr.aria-disabled]=\"tab.disabled\"\n                >\n                    <ng-template [ngTemplateOutlet]=\"tab.tabContent?.templateRef\">\n                    </ng-template>\n                </div>\n            </ng-template>\n        </ng-template>\n        <kendo-resize-sensor *ngIf=\"isScrollable\" (resize)=\"onResize()\"></kendo-resize-sensor>\n    "
        }),
        __metadata("design:paramtypes", [LocalizationService,
            Renderer2,
            ElementRef,
            TabStripService,
            ScrollService,
            NgZone])
    ], TabStripComponent);
    return TabStripComponent;
}());

/**
 * @hidden
 */
var TabStripMessages = /** @class */ (function (_super) {
    __extends(TabStripMessages, _super);
    function TabStripMessages() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TabStripMessages.prototype, "closeTitle", void 0);
    return TabStripMessages;
}(ComponentMessages));

/**
 * @hidden
 */
var LocalizedTabStripMessagesDirective = /** @class */ (function (_super) {
    __extends(LocalizedTabStripMessagesDirective, _super);
    function LocalizedTabStripMessagesDirective(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    LocalizedTabStripMessagesDirective_1 = LocalizedTabStripMessagesDirective;
    var LocalizedTabStripMessagesDirective_1;
    LocalizedTabStripMessagesDirective = LocalizedTabStripMessagesDirective_1 = __decorate([
        Directive({
            providers: [
                {
                    provide: TabStripMessages,
                    useExisting: forwardRef(function () { return LocalizedTabStripMessagesDirective_1; })
                }
            ],
            selector: "[kendoTabStripLocalizedMessages]"
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], LocalizedTabStripMessagesDirective);
    return LocalizedTabStripMessagesDirective;
}(TabStripMessages));

/**
 * Custom component messages override default component messages
 * ([see example]({% slug rtl_layout %})).
 */
var TabStripCustomMessagesComponent = /** @class */ (function (_super) {
    __extends(TabStripCustomMessagesComponent, _super);
    function TabStripCustomMessagesComponent(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    TabStripCustomMessagesComponent_1 = TabStripCustomMessagesComponent;
    Object.defineProperty(TabStripCustomMessagesComponent.prototype, "override", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    var TabStripCustomMessagesComponent_1;
    TabStripCustomMessagesComponent = TabStripCustomMessagesComponent_1 = __decorate([
        Component({
            providers: [
                {
                    provide: TabStripMessages,
                    useExisting: forwardRef(function () { return TabStripCustomMessagesComponent_1; })
                }
            ],
            selector: 'kendo-tabstrip-messages',
            template: ""
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], TabStripCustomMessagesComponent);
    return TabStripCustomMessagesComponent;
}(TabStripMessages));

/**
 * Represents a template that defines the content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerTemplate` directive inside the `<kendo-drawer>` tag.
 * Using this template directive will override all other templates,
 * for example, `kendoDrawerHeaderTemplate` and `kendoDrawerItemTemplate`.
 */
var DrawerTemplateDirective = /** @class */ (function () {
    function DrawerTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DrawerTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDrawerTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], DrawerTemplateDirective);
    return DrawerTemplateDirective;
}());

/**
 * Represents a template that defines the item content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerItemTemplate` directive inside the `<kendo-drawer>` tag.
 */
var DrawerItemTemplateDirective = /** @class */ (function () {
    function DrawerItemTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DrawerItemTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDrawerItemTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], DrawerItemTemplateDirective);
    return DrawerItemTemplateDirective;
}());

/**
 * Represents a template that defines the header content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerHeaderTemplate` directive inside the `<kendo-drawer>` tag.
 */
var DrawerHeaderTemplateDirective = /** @class */ (function () {
    function DrawerHeaderTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DrawerHeaderTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDrawerHeaderTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], DrawerHeaderTemplateDirective);
    return DrawerHeaderTemplateDirective;
}());

/**
 * Represents a template that defines the footer content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerFooterTemplate` directive inside the `<kendo-drawer>` tag.
 */
var DrawerFooterTemplateDirective = /** @class */ (function () {
    function DrawerFooterTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DrawerFooterTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDrawerFooterTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], DrawerFooterTemplateDirective);
    return DrawerFooterTemplateDirective;
}());

/**
 * @hidden
 */
function miniExpandPush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: miniWidth + "px" }),
        animate(duration + "ms ease-in", style({ flexBasis: width + "px" }))
    ];
}
/**
 * @hidden
 */
function miniCollapsePush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: width + "px" }),
        animate(duration + "ms ease-in", style({ flexBasis: miniWidth + "px" }))
    ];
}
/**
 * @hidden
 *
 */
function miniExpandOverlay(duration, width, miniWidth) {
    return [
        style({ width: miniWidth + "px" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', width: width + "px" }))
    ];
}
/**
 * @hidden
 */
function expandPush(duration, width) {
    return [
        style({ overflow: 'hidden', flexBasis: '0px' }),
        animate(duration + "ms ease-in", style({ flexBasis: width + "px" }))
    ];
}
/**
 * @hidden
 */
function collapsePush(duration, width) {
    return [
        style({ flexBasis: width + "px" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', flexBasis: "0px" }))
    ];
}
/**
 * @hidden
 */
function expandRTLOverlay(duration) {
    return [
        style({ transform: "translateX(100%)" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', transform: "translateX(0)" }))
    ];
}
/**
 * @hidden
 */
function expandOverlay(duration, position) {
    var translateDir = position !== 'end' ? "-100%" : "100%";
    return [
        style({ transform: "translateX(" + translateDir + ")" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', transform: "translateX(0)" }))
    ];
}
/**
 * @hidden
 */
function miniCollapseOverlay(duration, width, miniWidth) {
    return [
        style({ width: width + "px" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', width: miniWidth + "px" }))
    ];
}
/**
 * @hidden
 */
function collapseOverlay(duration, position) {
    var translateDir = position !== 'end' ? '-100%' : '100%';
    return [
        style({ transform: "translateX(0)" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', transform: "translateX(" + translateDir + ")" }))
    ];
}
/**
 * @hidden
 */
function collapseRTLOverlay(duration) {
    return [
        style({ transform: "translateX(0)" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', transform: "translateX(100%)" }))
    ];
}
/**
 * @hidden
 */
function expandAnimation(settings) {
    var duration = settings.animation.duration;
    var width = settings.width;
    var miniWidth = settings.miniWidth;
    var mode = settings.mode;
    var mini = settings.mini;
    var rtl = settings.rtl;
    var position = settings.position;
    if (mini && mode === 'push') {
        return miniExpandPush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return expandPush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? expandRTLOverlay(duration) : expandOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniExpandOverlay(duration, width, miniWidth);
    }
}
/**
 * @hidden
 */
function collapseAnimation(settings) {
    var duration = settings.animation.duration;
    var width = settings.width;
    var miniWidth = settings.miniWidth;
    var mode = settings.mode;
    var mini = settings.mini;
    var rtl = settings.rtl;
    var position = settings.position;
    if (mini && mode === 'push') {
        return miniCollapsePush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return collapsePush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? collapseRTLOverlay(duration) : collapseOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniCollapseOverlay(duration, width, miniWidth);
    }
}

/**
 * Arguments for the `select` event of the Drawer.
 */
var DrawerSelectEvent = /** @class */ (function (_super) {
    __extends(DrawerSelectEvent, _super);
    function DrawerSelectEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DrawerSelectEvent;
}(PreventableEvent$1));

/**
 * @hidden
 */
var DrawerService = /** @class */ (function () {
    function DrawerService() {
        this.selectedIndices = [];
    }
    DrawerService.prototype.emit = function (event, args) {
        var drawer = this.owner;
        var eventArgs = new DrawerSelectEvent(__assign({}, args, { sender: drawer }));
        if (hasObservers(drawer[event])) {
            drawer[event].emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    };
    DrawerService.prototype.onSelect = function (selectedIdx) {
        this.selectedIndices = [selectedIdx];
        var drawer = this.owner;
        if (drawer.autoCollapse && !drawer.minimized) {
            drawer.toggle(false);
        }
    };
    DrawerService.prototype.initSelection = function () {
        var items = this.owner.items;
        this.selectedIndices = [];
        for (var i = 0; i < items.length; i++) {
            if (items[i].selected) {
                this.selectedIndices.push(i);
            }
        }
    };
    DrawerService = __decorate([
        Injectable()
    ], DrawerService);
    return DrawerService;
}());

var DEFAULT_ANIMATION = { type: 'slide', duration: 200 };
/**
 * Represents the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-drawer-container>
 *             <kendo-drawer #drawer
 *                  [items]="items"
 *                  mode="overlay"
 *                  [(expanded)]="expanded">
 *              </kendo-drawer>
 *              <kendo-drawer-content>
 *                  <button class="k-button" (click)="drawer.toggle()">Open the Drawer</button>
 *              </kendo-drawer-content>
 *        </kendo-drawer-container>
 *    `
 * })
 * class AppComponent {
 *    public expanded = false;
 *
 *    public items: any[] = [
 *      { text: 'Inbox', icon: 'k-i-inbox' },
 *      { text: 'Notifications', icon: 'k-i-bell' },
 *      { text: 'Date', icon: 'k-i-calendar' }
 *    ];
 * }
 * ```
 */
var DrawerComponent = /** @class */ (function () {
    function DrawerComponent(element, builder, localizationService, drawerService) {
        var _this = this;
        this.element = element;
        this.builder = builder;
        this.localizationService = localizationService;
        this.drawerService = drawerService;
        this.hostClasses = true;
        /**
         * Specifies the mode in which the Drawer will be displayed.
         *
         * The possible values are:
         * * (Default) `overlay`
         * * `push`
         */
        this.mode = 'overlay';
        /**
         * Specifies the position of the Drawer
         * ([see example]({% slug positioning_drawer %})).
         *
         * The possible values are:
         * * (Default) `start`
         * * `end`
         */
        this.position = 'start';
        /**
         * Enables the mini (compact) view of the Drawer which is displayed when the component is collapsed
         * ([see example]({% slug expandmodespositions_drawer %}#toc-mini-view)).
         */
        this.mini = false;
        /**
         * Specifies the state of the Drawer.
         */
        this.expanded = false;
        /**
         * Defines the width of the Drawer when it is expanded.
         * Defaults to `240`.
         */
        this.width = 240;
        /**
         * Defines the width of the Drawer when the mini view is enabled
         * and the component is collapsed. Defaults to `60`.
         */
        this.miniWidth = 50;
        /**
         * Specifies if the Drawer will be automatically collapsed when an item
         * or the overlay is clicked. Defaults to `true`.
         */
        this.autoCollapse = true;
        /**
         * Specifies the animation settings of the Drawer.
         * ([see example]({% slug interaction_drawer %}#toc-toggling-between-states)).
         *
         * The possible values are:
         * * Boolean
         *    * (Default) `true`
         *    * `false`
         * * `DrawerAnimation`
         *    * (Default) `type?: 'slide'`
         *    * `duration`&mdash;Accepts a number in milliseconds. Defaults to `300ms`.
         */
        this.animation = DEFAULT_ANIMATION;
        /**
         * Fires when the Drawer is expanded and its animation is complete.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the Drawer is collapsed and its animation is complete.
         */
        this.collapse = new EventEmitter();
        /**
         * Fires when a Drawer item is selected. This event is preventable.
         */
        this.select = new EventEmitter();
        /**
         * Fires when the `expanded` property of the component was updated.
         * Used to provide a two-way binding for the `expanded` property.
         */
        this.expandedChange = new EventEmitter();
        this.animationEnd = new EventEmitter();
        this.rtl = false;
        this._items = [];
        validatePackage(packageMetadata);
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.rtl = rtl;
            _this.direction = _this.rtl ? 'rtl' : 'ltr';
        });
        this.drawerService.owner = this;
    }
    Object.defineProperty(DrawerComponent.prototype, "startPositionClass", {
        get: function () {
            return this.position === 'start';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerComponent.prototype, "endPositionClass", {
        get: function () {
            return this.position === 'end';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerComponent.prototype, "overlayTransofrmStyles", {
        get: function () {
            if (this.mode === 'push') {
                return;
            }
            if (this.expanded || this.minimized) {
                return "translateX(0px)";
            }
            return "translateX(-100%)";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerComponent.prototype, "flexStyles", {
        get: function () {
            if (this.mode === 'overlay') {
                return;
            }
            if (!this.expanded && !this.minimized) {
                return 0;
            }
            return this.drawerWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerComponent.prototype, "items", {
        get: function () {
            return this._items;
        },
        /**
         * The collection of items that will be rendered in the Drawer.
         */
        set: function (items) {
            if (isPresent(items)) {
                this._items = items;
                this.drawerService.initSelection();
            }
        },
        enumerable: true,
        configurable: true
    });
    DrawerComponent.prototype.ngOnDestroy = function () {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    };
    Object.defineProperty(DrawerComponent.prototype, "minimized", {
        /**
         * @hidden
         */
        get: function () {
            return this.mini && !this.expanded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerComponent.prototype, "drawerWidth", {
        /**
         * @hidden
         */
        get: function () {
            return this.minimized ? this.miniWidth : this.width;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Toggles the visibility of the Drawer.
     *
     * @param expanded? - Boolean. Specifies if the Drawer will be expanded or collapsed.
     */
    DrawerComponent.prototype.toggle = function (expanded) {
        var _this = this;
        var previous = this.expanded;
        var current = isPresent(expanded) ? expanded : !previous;
        if (current === previous) {
            return;
        }
        if (current === true) {
            this.setExpanded(true);
        }
        else if (current === false && !this.animation) {
            this.setExpanded(false);
        }
        if (this.animation) {
            this.animationEnd.pipe(take(1))
                .subscribe(function () { _this.onAnimationEnd(current); });
            this.animate(current);
        }
        else {
            this[current ? 'expand' : 'collapse'].emit();
        }
    };
    DrawerComponent.prototype.onAnimationEnd = function (currentExpanded) {
        if (currentExpanded) {
            this.expand.emit();
        }
        else {
            this.setExpanded(false);
            this.collapse.emit();
        }
    };
    DrawerComponent.prototype.setExpanded = function (value) {
        this.expanded = value;
        this.expandedChange.emit(value);
    };
    DrawerComponent.prototype.animate = function (expanded) {
        var settings = {
            mode: this.mode,
            mini: this.mini,
            miniWidth: this.miniWidth,
            width: this.width,
            rtl: this.rtl,
            position: this.position,
            animation: (typeof this.animation !== 'boolean') ? this.animation : DEFAULT_ANIMATION
        };
        var animation = expanded ? expandAnimation(settings) : collapseAnimation(settings);
        var player = this.createPlayer(animation, this.element.nativeElement);
        player.play();
    };
    DrawerComponent.prototype.createPlayer = function (animation, animatedElement) {
        var _this = this;
        var factory = this.builder.build(animation);
        var player = factory.create(animatedElement);
        player.onDone(function () {
            if (player) {
                _this.animationEnd.emit();
                player.destroy();
                player = null;
            }
        });
        return player;
    };
    __decorate([
        HostBinding('class.k-widget'),
        HostBinding('class.k-drawer'),
        __metadata("design:type", Boolean)
    ], DrawerComponent.prototype, "hostClasses", void 0);
    __decorate([
        HostBinding('class.k-drawer-start'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DrawerComponent.prototype, "startPositionClass", null);
    __decorate([
        HostBinding('class.k-drawer-end'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DrawerComponent.prototype, "endPositionClass", null);
    __decorate([
        HostBinding('style.transform'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], DrawerComponent.prototype, "overlayTransofrmStyles", null);
    __decorate([
        HostBinding('style.flexBasis.px'),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [])
    ], DrawerComponent.prototype, "flexStyles", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DrawerComponent.prototype, "mode", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DrawerComponent.prototype, "position", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DrawerComponent.prototype, "mini", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DrawerComponent.prototype, "expanded", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], DrawerComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], DrawerComponent.prototype, "miniWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DrawerComponent.prototype, "autoCollapse", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], DrawerComponent.prototype, "items", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], DrawerComponent.prototype, "direction", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DrawerComponent.prototype, "animation", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DrawerComponent.prototype, "expand", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DrawerComponent.prototype, "collapse", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DrawerComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DrawerComponent.prototype, "expandedChange", void 0);
    __decorate([
        ContentChild(DrawerTemplateDirective, { static: false }),
        __metadata("design:type", DrawerTemplateDirective)
    ], DrawerComponent.prototype, "drawerTemplate", void 0);
    __decorate([
        ContentChild(DrawerFooterTemplateDirective, { static: false }),
        __metadata("design:type", DrawerFooterTemplateDirective)
    ], DrawerComponent.prototype, "footerTemplate", void 0);
    __decorate([
        ContentChild(DrawerHeaderTemplateDirective, { static: false }),
        __metadata("design:type", DrawerHeaderTemplateDirective)
    ], DrawerComponent.prototype, "headerTemplate", void 0);
    __decorate([
        ContentChild(DrawerItemTemplateDirective, { static: false }),
        __metadata("design:type", DrawerItemTemplateDirective)
    ], DrawerComponent.prototype, "itemTemplate", void 0);
    DrawerComponent = __decorate([
        Component({
            exportAs: 'kendoDrawer',
            providers: [
                LocalizationService,
                DrawerService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.drawer'
                }
            ],
            selector: 'kendo-drawer',
            template: "\n        <div class=\"k-drawer-wrapper\" *ngIf=\"expanded || mini\" [style.width.px]=\"drawerWidth\">\n            <ng-container *ngIf=\"!drawerTemplate\">\n                <ng-template *ngIf=\"headerTemplate\"\n                    [ngTemplateOutlet]=\"headerTemplate?.templateRef\">\n                </ng-template>\n\n                <ul kendoDrawerList\n                    [items]=\"items\" [mini]=\"mini\" [expanded]=\"expanded\"\n                    [itemTemplate]=\"itemTemplate?.templateRef\"\n                    class=\"k-drawer-items\">\n                </ul>\n\n                <ng-template *ngIf=\"footerTemplate\"\n                    [ngTemplateOutlet]=\"footerTemplate?.templateRef\">\n                </ng-template>\n            </ng-container>\n\n            <ng-template *ngIf=\"drawerTemplate\"\n                [ngTemplateOutlet]=\"drawerTemplate?.templateRef\">\n            </ng-template>\n        </div>\n    "
        }),
        __metadata("design:paramtypes", [ElementRef,
            AnimationBuilder,
            LocalizationService,
            DrawerService])
    ], DrawerComponent);
    return DrawerComponent;
}());

/**
 * Serves as a container for the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}) and its content.
 */
var DrawerContainerComponent = /** @class */ (function () {
    function DrawerContainerComponent(localizationService) {
        var _this = this;
        this.localizationService = localizationService;
        this.rtl = false;
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.rtl = rtl;
            _this.direction = _this.rtl ? 'rtl' : 'ltr';
        });
    }
    Object.defineProperty(DrawerContainerComponent.prototype, "hostClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerContainerComponent.prototype, "overlayClass", {
        get: function () {
            return this.drawer.mode === 'overlay';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerContainerComponent.prototype, "miniClass", {
        get: function () {
            return this.drawer.mini;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerContainerComponent.prototype, "pushClass", {
        get: function () {
            return this.drawer.mode === 'push';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerContainerComponent.prototype, "isExpandedClass", {
        get: function () {
            return this.drawer.expanded;
        },
        enumerable: true,
        configurable: true
    });
    DrawerContainerComponent.prototype.ngOnDestroy = function () {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    };
    Object.defineProperty(DrawerContainerComponent.prototype, "overlay", {
        /**
         * @hidden
         */
        get: function () {
            return isPresent(this.drawer) &&
                this.drawer.expanded &&
                this.drawer.mode === 'overlay';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    DrawerContainerComponent.prototype.closeDrawer = function () {
        if (this.overlay && this.drawer.autoCollapse) {
            this.drawer.toggle(false);
        }
    };
    __decorate([
        HostBinding('class.k-drawer-container'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DrawerContainerComponent.prototype, "hostClass", null);
    __decorate([
        HostBinding('class.k-drawer-overlay'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DrawerContainerComponent.prototype, "overlayClass", null);
    __decorate([
        HostBinding('class.k-drawer-mini'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DrawerContainerComponent.prototype, "miniClass", null);
    __decorate([
        HostBinding('class.k-drawer-push'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DrawerContainerComponent.prototype, "pushClass", null);
    __decorate([
        HostBinding('class.k-drawer-expanded'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DrawerContainerComponent.prototype, "isExpandedClass", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], DrawerContainerComponent.prototype, "direction", void 0);
    __decorate([
        ContentChild(DrawerComponent, { static: false }),
        __metadata("design:type", DrawerComponent)
    ], DrawerContainerComponent.prototype, "drawer", void 0);
    DrawerContainerComponent = __decorate([
        Component({
            selector: 'kendo-drawer-container',
            providers: [
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.drawer.container'
                }
            ],
            template: "\n        <div class=\"k-overlay\" *ngIf=\"overlay\" (click)=\"closeDrawer()\"></div>\n        <ng-content></ng-content>\n    "
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], DrawerContainerComponent);
    return DrawerContainerComponent;
}());

/**
 * Represents the content of the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).
 */
var DrawerContentComponent = /** @class */ (function () {
    function DrawerContentComponent() {
        this.hostClasses = true;
    }
    __decorate([
        HostBinding('class.k-drawer-content'),
        __metadata("design:type", Boolean)
    ], DrawerContentComponent.prototype, "hostClasses", void 0);
    DrawerContentComponent = __decorate([
        Component({
            selector: 'kendo-drawer-content',
            template: "\n        <ng-content></ng-content>\n    ",
            encapsulation: ViewEncapsulation.None
        }),
        __metadata("design:paramtypes", [])
    ], DrawerContentComponent);
    return DrawerContentComponent;
}());

/**
 * Represents a template that defines the content of the whole Step.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperStepTemplate` directive inside the `<kendo-stepper>` tag.
 */
var StepperStepTemplateDirective = /** @class */ (function () {
    function StepperStepTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    StepperStepTemplateDirective = __decorate([
        Directive({
            selector: '[kendoStepperStepTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], StepperStepTemplateDirective);
    return StepperStepTemplateDirective;
}());

/**
 * Represents a template that defines the content of the Step label.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperLabelTemplate` directive inside the `<kendo-stepper>` tag.
 */
var StepperLabelTemplateDirective = /** @class */ (function () {
    function StepperLabelTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    StepperLabelTemplateDirective = __decorate([
        Directive({
            selector: '[kendoStepperLabelTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], StepperLabelTemplateDirective);
    return StepperLabelTemplateDirective;
}());

/**
 * Represents a template that defines the content of the Step indicator.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperIndicatorTemplate` directive inside the `<kendo-stepper>` tag.
 */
var StepperIndicatorTemplateDirective = /** @class */ (function () {
    function StepperIndicatorTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    StepperIndicatorTemplateDirective = __decorate([
        Directive({
            selector: '[kendoStepperIndicatorTemplate]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], StepperIndicatorTemplateDirective);
    return StepperIndicatorTemplateDirective;
}());

/**
 * Arguments for the `activate` event of the Stepper.
 */
var StepperActivateEvent = /** @class */ (function (_super) {
    __extends(StepperActivateEvent, _super);
    function StepperActivateEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StepperActivateEvent;
}(PreventableEvent$1));

var DEFAULT_CURRENT_STEP = 0;
var handlers = {};
handlers[Keys.ArrowLeft] = 'left';
handlers[Keys.ArrowRight] = 'right';
handlers[Keys.ArrowUp] = 'up';
handlers[Keys.ArrowDown] = 'down';
handlers[Keys.Home] = 'home';
handlers[Keys.End] = 'end';
handlers[Keys.Enter] = 'enter';
handlers[Keys.Space] = 'enter';
var handlersRTL = Object.assign({}, handlers);
handlersRTL[Keys.ArrowLeft] = 'right';
handlersRTL[Keys.ArrowRight] = 'left';
/**
 * @hidden
 */
var StepperService = /** @class */ (function () {
    function StepperService(localization, ngZone, changeDetector) {
        this.localization = localization;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.currentStep = DEFAULT_CURRENT_STEP;
        this.triggerValidation = new EventEmitter();
        this.focusedStepChange = new EventEmitter();
    }
    Object.defineProperty(StepperService.prototype, "handlers", {
        get: function () {
            return this.localization.rtl ? handlersRTL : handlers;
        },
        enumerable: true,
        configurable: true
    });
    StepperService.prototype.emit = function (event, eventArgs) {
        var stepper = this.owner;
        if (hasObservers(stepper[event])) {
            stepper[event].emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    };
    StepperService.prototype.onActivate = function (currentIdx, originalEvent) {
        var _this = this;
        var eventArgs = new StepperActivateEvent({
            index: currentIdx,
            step: this.owner.steps[currentIdx],
            originalEvent: originalEvent,
            sender: this.owner
        });
        this.ngZone.run(function () {
            if (!_this.emit('activate', eventArgs)) {
                _this.currentStep = currentIdx;
                _this.owner['currentStepChange'].emit(currentIdx);
                _this.changeDetector.detectChanges();
            }
        });
    };
    StepperService.prototype.validateSteps = function () {
        this.triggerValidation.emit();
    };
    StepperService.prototype.keydown = function (e) {
        var current = this.focusedStep || this.currentStep;
        var handler = this.handlers[e.keyCode];
        if (!isPresent(current)) {
            return;
        }
        if (handler) {
            e.preventDefault();
            this[handler](e);
        }
    };
    StepperService.prototype.left = function () {
        if (!this.isHorizontal) {
            return;
        }
        this.focusPrevStep();
    };
    StepperService.prototype.right = function () {
        if (!this.isHorizontal) {
            return;
        }
        this.focusNextStep();
    };
    StepperService.prototype.up = function () {
        if (this.isHorizontal) {
            return;
        }
        this.focusPrevStep();
    };
    StepperService.prototype.down = function () {
        if (this.isHorizontal) {
            return;
        }
        this.focusNextStep();
    };
    StepperService.prototype.home = function () {
        this.focusedStep = 0;
        this.focusedStepChange.emit();
    };
    StepperService.prototype.end = function () {
        this.focusedStep = this.owner.steps.length - 1;
        this.focusedStepChange.emit();
    };
    StepperService.prototype.enter = function (event) {
        if (this.focusedStep === this.currentStep) {
            return;
        }
        if (this.isStepDisabled(this.focusedStep)) {
            return;
        }
        if (this.owner.linear && this.isPrevOrNextStep(this.focusedStep) === false) {
            return;
        }
        this.onActivate(this.focusedStep, event);
    };
    StepperService.prototype.focus = function (focusedIdx) {
        this.focusedStep = focusedIdx;
    };
    StepperService.prototype.focusNextStep = function () {
        if (this.focusedStep < this.owner.steps.length) {
            this.focusedStep += 1;
            this.focusedStepChange.emit();
        }
    };
    StepperService.prototype.focusPrevStep = function () {
        if (this.focusedStep > 0) {
            this.focusedStep -= 1;
            this.focusedStepChange.emit();
        }
    };
    StepperService.prototype.isStepDisabled = function (index) {
        return this.owner.steps[index].disabled;
    };
    StepperService.prototype.isPrevOrNextStep = function (index) {
        return index === this.currentStep + 1 || index === this.currentStep - 1;
    };
    Object.defineProperty(StepperService.prototype, "isHorizontal", {
        get: function () {
            return this.owner.orientation === 'horizontal';
        },
        enumerable: true,
        configurable: true
    });
    StepperService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [LocalizationService,
            NgZone,
            ChangeDetectorRef])
    ], StepperService);
    return StepperService;
}());

var DEFAULT_ANIMATION_DURATION = 400;
/**
 * Represents the [Kendo UI Stepper component for Angular]({% slug overview_stepper %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-stepper [steps]="steps">
 *        </kendo-stepper>
 *    `
 * })
 * class AppComponent {
 *    public steps: Array<StepperStep> = [
 *      { label: 'Step One' }, { label: 'Step Two' }, { label: 'Step Three' }
 *    ];
 * }
 * ```
 */
var StepperComponent = /** @class */ (function () {
    function StepperComponent(renderer, elem, localization, stepperService) {
        var _this = this;
        this.renderer = renderer;
        this.elem = elem;
        this.localization = localization;
        this.stepperService = stepperService;
        this.hostClasses = true;
        this.ariaRole = 'navigation';
        this.displayStyle = 'grid';
        /**
         * Specifies the type of the steps in the Stepper.
         *
         * The possible values are:
         * * (Default) `indicator`
         * * `label`
         * * `full`
         */
        this.stepType = 'indicator';
        /**
         * Specifies the linear flow of the Stepper.
         *
         * @default true
         */
        this.linear = true;
        /**
         * Specifies the orientation of the Stepper
         * ([see example]({% slug orientation_stepper %})).
         *
         * The possible values are:
         * * (Default) `horizontal`
         * * `vertical`
         */
        this.orientation = 'horizontal';
        /**
         * Specifies the duration of the progress indicator animation in milliseconds. Defaults to `400ms`.
         *
         * The possible values are:
         *  * Boolean
         *    * (Default) `true`
         *    * false
         *  * Number
         */
        this.animation = true;
        /**
         * Fires when a step is about to be activated. This event is preventable.
         */
        this.activate = new EventEmitter();
        /**
         * Fires when the `currentStep` property of the component was updated.
         * Used to provide a two-way binding for the `currentStep` property.
         */
        this.currentStepChange = new EventEmitter();
        this._steps = [];
        this.dynamicRTLSubscription = this.localization.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.stepperService.owner = this;
    }
    Object.defineProperty(StepperComponent.prototype, "linearClass", {
        get: function () {
            return this.linear;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperComponent.prototype, "currentStep", {
        get: function () {
            return this.stepperService.currentStep;
        },
        /**
         * The index of the current step.
         */
        set: function (value) {
            this.stepperService.currentStep = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperComponent.prototype, "steps", {
        get: function () {
            return this._steps;
        },
        /**
         * The collection of steps that will be rendered in the Stepper.
         * ([see example]({% slug step_appearance_stepper %}))
         */
        set: function (steps) {
            if (isPresent(steps) && steps.length > 0) {
                this._steps = steps;
            }
        },
        enumerable: true,
        configurable: true
    });
    StepperComponent.prototype.ngOnInit = function () {
        this.applyHostStyling();
    };
    StepperComponent.prototype.ngOnChanges = function (changes) {
        if (changes.steps && !changes.steps.firstChange) {
            this.applyHostStyling();
        }
        if (changes.orientation) {
            this.resetHostStyling();
            this.applyHostStyling();
        }
    };
    StepperComponent.prototype.ngOnDestroy = function () {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    };
    /**
     * Manually triggers the validity check configured by the [isValid]({% slug api_layout_stepperstep %}#toc-isvalid) property of the steps ([see example]({% slug step_validation_stepper %}#toc-triggering-the-validation)).
     *
     * Steps that have their [validate]({% slug api_layout_stepperstep %}#toc-validate) property set to `false`, will not be validated.
     */
    StepperComponent.prototype.validateSteps = function () {
        this.stepperService.validateSteps();
    };
    StepperComponent.prototype.applyHostStyling = function () {
        var stepFramesStyle = this.orientation === 'horizontal' ? 'grid-template-columns' : 'grid-template-rows';
        var stepFramesValue = "repeat(" + this.steps.length * 2 + ", 1fr)";
        this.renderer.setStyle(this.elem.nativeElement, stepFramesStyle, stepFramesValue);
    };
    StepperComponent.prototype.resetHostStyling = function () {
        this.renderer.removeStyle(this.elem.nativeElement, 'grid-template-columns');
        this.renderer.removeStyle(this.elem.nativeElement, 'grid-template-rows');
    };
    Object.defineProperty(StepperComponent.prototype, "progressAnimation", {
        /**
         * @hidden
         */
        get: function () {
            return { duration: this.animationDuration };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperComponent.prototype, "animationDuration", {
        /**
         * @hidden
         */
        get: function () {
            if (typeof this.animation === 'number') {
                return this.animation;
            }
            if (typeof this.animation === 'boolean' && this.animation) {
                return DEFAULT_ANIMATION_DURATION;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperComponent.prototype, "stepsListStyling", {
        /**
         * @hidden
         */
        get: function () {
            if (this.orientation === 'horizontal') {
                return { 'grid-column-start': 1, 'grid-column-end': -1 };
            }
            return { 'grid-row-start': 1, 'grid-row-end': -1 };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperComponent.prototype, "progressBarStyling", {
        /**
         * @hidden
         */
        get: function () {
            if (this.orientation === 'horizontal') {
                return {
                    'grid-column-start': 2,
                    'grid-column-end': this.steps.length * 2
                };
            }
            return {
                'grid-row-start': 2,
                'grid-row-end': this.steps.length * 2
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperComponent.prototype, "isHorizontal", {
        /***
         * @hidden
         */
        get: function () {
            return this.stepperService.isHorizontal;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        HostBinding('class.k-widget'),
        HostBinding('class.k-stepper'),
        __metadata("design:type", Boolean)
    ], StepperComponent.prototype, "hostClasses", void 0);
    __decorate([
        HostBinding('class.k-stepper-linear'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], StepperComponent.prototype, "linearClass", null);
    __decorate([
        HostBinding('attr.role'),
        __metadata("design:type", String)
    ], StepperComponent.prototype, "ariaRole", void 0);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], StepperComponent.prototype, "direction", void 0);
    __decorate([
        HostBinding('style.display'),
        __metadata("design:type", String)
    ], StepperComponent.prototype, "displayStyle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperComponent.prototype, "stepType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], StepperComponent.prototype, "linear", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], StepperComponent.prototype, "currentStep", null);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], StepperComponent.prototype, "steps", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperComponent.prototype, "successIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperComponent.prototype, "errorIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], StepperComponent.prototype, "animation", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], StepperComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], StepperComponent.prototype, "currentStepChange", void 0);
    __decorate([
        ContentChild(StepperStepTemplateDirective, { static: false }),
        __metadata("design:type", StepperStepTemplateDirective)
    ], StepperComponent.prototype, "stepTemplate", void 0);
    __decorate([
        ContentChild(StepperLabelTemplateDirective, { static: false }),
        __metadata("design:type", StepperLabelTemplateDirective)
    ], StepperComponent.prototype, "labelTemplate", void 0);
    __decorate([
        ContentChild(StepperIndicatorTemplateDirective, { static: false }),
        __metadata("design:type", StepperIndicatorTemplateDirective)
    ], StepperComponent.prototype, "indicatorTemplate", void 0);
    StepperComponent = __decorate([
        Component({
            exportAs: 'kendoStepper',
            providers: [
                LocalizationService,
                StepperService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.stepper'
                }
            ],
            selector: 'kendo-stepper',
            template: "\n        <ng-container kendoStepperLocalizedMessages\n            i18n-optional=\"kendo.stepper.optional|The text for the optional segment of the step label\"\n            optional=\"Optional\"\n         >\n        </ng-container>\n        <ol kendoStepperList\n            [stepType]='stepType'\n            [linear]='linear'\n            [orientation]='orientation'\n            [steps]='steps'\n            [currentStep]='currentStep'\n            [successIcon]='successIcon'\n            [errorIcon]='errorIcon'\n            [indicatorTemplate]='indicatorTemplate?.templateRef'\n            [labelTemplate]='labelTemplate?.templateRef'\n            [stepTemplate]='stepTemplate?.templateRef'\n            class='k-step-list'\n            [class.k-step-list-horizontal]='isHorizontal'\n            [class.k-step-list-vertical]='!isHorizontal'\n            [ngStyle]='stepsListStyling'>\n        </ol>\n\n        <kendo-progressbar *ngIf='steps.length > 0'\n            [attr.aria-hidden]='true'\n            [animation]='progressAnimation'\n            [max]='steps.length - 1'\n            [label]='false'\n            [orientation]='orientation'\n            [reverse]='!isHorizontal'\n            [value]='currentStep'\n            [ngStyle]='progressBarStyling'>\n        </kendo-progressbar>\n    "
        }),
        __metadata("design:paramtypes", [Renderer2,
            ElementRef,
            LocalizationService,
            StepperService])
    ], StepperComponent);
    return StepperComponent;
}());

/**
 * @hidden
 */
var StepperMessages = /** @class */ (function (_super) {
    __extends(StepperMessages, _super);
    function StepperMessages() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperMessages.prototype, "optional", void 0);
    return StepperMessages;
}(ComponentMessages));

/**
 * Custom component messages override default component messages
 * ([see example]({% slug rtl_layout %})).
 */
var StepperCustomMessagesComponent = /** @class */ (function (_super) {
    __extends(StepperCustomMessagesComponent, _super);
    function StepperCustomMessagesComponent(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    StepperCustomMessagesComponent_1 = StepperCustomMessagesComponent;
    Object.defineProperty(StepperCustomMessagesComponent.prototype, "override", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    var StepperCustomMessagesComponent_1;
    StepperCustomMessagesComponent = StepperCustomMessagesComponent_1 = __decorate([
        Component({
            providers: [
                {
                    provide: StepperMessages,
                    useExisting: forwardRef(function () { return StepperCustomMessagesComponent_1; })
                }
            ],
            selector: 'kendo-stepper-messages',
            template: ""
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], StepperCustomMessagesComponent);
    return StepperCustomMessagesComponent;
}(StepperMessages));

/**
 * @hidden
 */
var LocalizedStepperMessagesDirective = /** @class */ (function (_super) {
    __extends(LocalizedStepperMessagesDirective, _super);
    function LocalizedStepperMessagesDirective(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    LocalizedStepperMessagesDirective_1 = LocalizedStepperMessagesDirective;
    var LocalizedStepperMessagesDirective_1;
    LocalizedStepperMessagesDirective = LocalizedStepperMessagesDirective_1 = __decorate([
        Directive({
            providers: [
                {
                    provide: StepperMessages,
                    useExisting: forwardRef(function () { return LocalizedStepperMessagesDirective_1; })
                }
            ],
            selector: "\n      [kendoStepperLocalizedMessages]\n    "
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], LocalizedStepperMessagesDirective);
    return LocalizedStepperMessagesDirective;
}(StepperMessages));

/**
 * Displays images, icons or initials representing people or other entities.
 */
var AvatarComponent = /** @class */ (function () {
    function AvatarComponent(renderer, element) {
        this.renderer = renderer;
        this.element = element;
        this.hostClass = true;
        /**
         * Sets a border to the avatar.
         */
        this.border = false;
        this._themeColor = 'primary';
        this._size = 'medium';
        this._fillMode = 'solid';
        this._rounded = 'full';
        validatePackage(packageMetadata);
    }
    Object.defineProperty(AvatarComponent.prototype, "borderClass", {
        /**
         * @hidden
         */
        get: function () {
            return this.border;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvatarComponent.prototype, "flexBasis", {
        /**
         * @hidden
         */
        get: function () {
            return this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvatarComponent.prototype, "shape", {
        /**
         * Sets the shape for the avatar.
         * @hidden
         */
        set: function (shape) {
            this.rounded = mapShapeToRounded(shape);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvatarComponent.prototype, "size", {
        get: function () {
            return this._size;
        },
        /**
         * Specifies the size of the avatar
         * ([see example]({% slug appearance_avatar %}#toc-size)).
         *
         * The possible values are:
         * * `small`
         * * `medium` (Default)
         * * `large`
         *
         */
        set: function (size) {
            if (size !== this._size) {
                this.handleClasses('size', size);
                this._size = size === null ? null : size || 'medium';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvatarComponent.prototype, "rounded", {
        get: function () {
            return this._rounded;
        },
        /**
         * Specifies the rounded styling of the avatar
         * ([see example]({% slug appearance_avatar %}#toc-rounded-corners)).
         *
         * The possible values are:
         * * `small`
         * * `medium`
         * * `large`
         * * `full` (Default)
         * * null
         *
         */
        set: function (rounded) {
            if (rounded !== this._rounded) {
                this.handleClasses('rounded', rounded);
                this._rounded = rounded === null ? null : rounded || 'full';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvatarComponent.prototype, "themeColor", {
        get: function () {
            return this._themeColor;
        },
        /**
         * Specifies the theme color of the avatar.
         * The theme color will be applied as background and border color, while also amending the text color accordingly.
         *
         * The possible values are:
         * * `base`&mdash; Applies the base coloring value.
         * * `primary` (Default)&mdash;Applies coloring based on primary theme color.
         * * `secondary`&mdash;Applies coloring based on secondary theme color.
         * * `tertiary`&mdash; Applies coloring based on tertiary theme color.
         * * `info`&mdash;Applies coloring based on info theme color.
         * * `success`&mdash; Applies coloring based on success theme color.
         * * `warning`&mdash; Applies coloring based on warning theme color.
         * * `error`&mdash; Applies coloring based on error theme color.
         * * `dark`&mdash; Applies coloring based on dark theme color.
         * * `light`&mdash; Applies coloring based on light theme color.
         * * `inverse`&mdash; Applies coloring based on inverted theme color.
         */
        set: function (themeColor) {
            if (themeColor !== this._themeColor) {
                this._themeColor = themeColor === null ? null : (themeColor || 'primary');
                this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvatarComponent.prototype, "fillMode", {
        get: function () {
            return this._fillMode;
        },
        /**
         * Specifies the appearance fill style of the avatar.
         *
         * The possible values are:
         * * `solid` (Default)
         * * `outline`
         * * null
         *
         */
        set: function (fillMode) {
            if (fillMode !== this.fillMode) {
                this._fillMode = fillMode === null ? null : (fillMode || 'solid');
                this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvatarComponent.prototype, "fill", {
        /**
         * Specifies the appearance fill style of the avatar.
         * Deprecated, left for backward compatibility.
         *
         * @hidden
         */
        set: function (fillMode) {
            this.fillMode = fillMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvatarComponent.prototype, "avatarWidth", {
        /**
         * @hidden
         */
        get: function () {
            return this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvatarComponent.prototype, "avatarHeight", {
        /**
         * @hidden
         */
        get: function () {
            return this.height;
        },
        enumerable: true,
        configurable: true
    });
    AvatarComponent.prototype.ngOnInit = function () {
        this.verifyProperties();
    };
    AvatarComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        var stylingInputs = ['size', 'rounded'];
        stylingInputs.forEach(function (input) {
            _this.handleClasses(input, _this[input]);
        });
        this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
    };
    /**
     * @hidden
     */
    AvatarComponent.prototype.iconClasses = function () {
        if (this.icon) {
            return "k-icon k-i-" + this.icon;
        }
        if (this.iconClass) {
            return "" + this.iconClass;
        }
    };
    Object.defineProperty(AvatarComponent.prototype, "customAvatar", {
        /**
         * @hidden
         */
        get: function () {
            return !(this.imageSrc || this.initials || this.icon || this.iconClass);
        },
        enumerable: true,
        configurable: true
    });
    AvatarComponent.prototype.verifyProperties = function () {
        if (!isDevMode()) {
            return;
        }
        var inputs = [this.icon || this.iconClass, this.imageSrc, this.initials];
        var inputsLength = inputs.filter(function (value) { return value; }).length;
        if (inputsLength > 1) {
            throw new Error("\n                Invalid property configuration given.\n                The kendo-avatar component can accept only one of:\n                icon, imageSrc or initials properties.\n            ");
        }
    };
    AvatarComponent.prototype.handleClasses = function (styleType, value) {
        var elem = this.element.nativeElement;
        var classes = getStylingClasses('avatar', styleType, this[styleType], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    };
    AvatarComponent.prototype.handleFillModeAndThemeColorClasses = function (fill, themeColor) {
        var _this = this;
        var wrapperElement = this.element.nativeElement;
        // remove existing fill and theme color classes
        var currentClasses = Array.from(wrapperElement.classList);
        var classesToRemove = currentClasses.filter(function (cl) {
            return cl.startsWith('k-avatar-solid') || cl.startsWith('k-avatar-outline');
        });
        classesToRemove.forEach((function (cl) { return _this.renderer.removeClass(wrapperElement, cl); }));
        // add fill if needed
        if (fill !== null) {
            this.renderer.addClass(wrapperElement, "k-avatar-" + fill);
        }
        // add theme color class if fill and theme color
        if (fill !== null && themeColor !== null) {
            this.renderer.addClass(wrapperElement, "k-avatar-" + fill + "-" + themeColor);
        }
    };
    __decorate([
        HostBinding('class.k-avatar'),
        __metadata("design:type", Boolean)
    ], AvatarComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('class.k-avatar-bordered'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], AvatarComponent.prototype, "borderClass", null);
    __decorate([
        HostBinding('style.flexBasis'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], AvatarComponent.prototype, "flexBasis", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], AvatarComponent.prototype, "shape", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], AvatarComponent.prototype, "size", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], AvatarComponent.prototype, "rounded", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], AvatarComponent.prototype, "themeColor", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], AvatarComponent.prototype, "fillMode", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], AvatarComponent.prototype, "fill", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AvatarComponent.prototype, "border", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AvatarComponent.prototype, "iconClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AvatarComponent.prototype, "width", void 0);
    __decorate([
        HostBinding('style.width'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], AvatarComponent.prototype, "avatarWidth", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AvatarComponent.prototype, "height", void 0);
    __decorate([
        HostBinding('style.height'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], AvatarComponent.prototype, "avatarHeight", null);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AvatarComponent.prototype, "cssStyle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AvatarComponent.prototype, "initials", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AvatarComponent.prototype, "icon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AvatarComponent.prototype, "imageSrc", void 0);
    AvatarComponent = __decorate([
        Component({
            selector: 'kendo-avatar',
            template: "\n        <ng-content *ngIf=\"customAvatar\"></ng-content>\n\n        <ng-container *ngIf=\"imageSrc\">\n            <span class=\"k-avatar-image\">\n                <img src=\"{{imageSrc}}\" [ngStyle]=\"cssStyle\" />\n            </span>\n        </ng-container>\n\n        <ng-container *ngIf=\"initials\">\n            <span class=\"k-avatar-text\" [ngStyle]=\"cssStyle\">{{ initials.substring(0, 2) }}</span>\n        </ng-container>\n\n        <ng-container *ngIf=\"icon || iconClass\">\n            <span class=\"k-avatar-icon\" [ngStyle]=\"cssStyle\" [ngClass]=\"iconClasses()\"></span>\n        </ng-container>\n    "
        }),
        __metadata("design:paramtypes", [Renderer2, ElementRef])
    ], AvatarComponent);
    return AvatarComponent;
}());

/**
 * Represents the [Kendo UI Card component for Angular]({% slug overview_card %})
 */
var CardComponent = /** @class */ (function () {
    function CardComponent(localizationService) {
        var _this = this;
        this.localizationService = localizationService;
        this.hostClass = true;
        /**
         * Specifies the layout of the Card content.
         *
         * The possible values are:
         * * (Default) `vertical`
         * * `horizontal`
         *
         */
        this.orientation = 'vertical';
        /**
         * Defines the width of the Card.
         * Defaults to `285px`.
         */
        this.width = '285px';
        this.rtl = false;
        validatePackage(packageMetadata);
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.rtl = rtl;
            _this.direction = _this.rtl ? 'rtl' : 'ltr';
        });
    }
    Object.defineProperty(CardComponent.prototype, "widthStyle", {
        get: function () {
            return this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CardComponent.prototype, "vertical", {
        get: function () {
            return this.orientation === 'vertical';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CardComponent.prototype, "horizontal", {
        get: function () {
            return this.orientation === 'horizontal';
        },
        enumerable: true,
        configurable: true
    });
    CardComponent.prototype.ngOnDestroy = function () {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    };
    __decorate([
        HostBinding('class.k-widget'),
        HostBinding('class.k-card'),
        __metadata("design:type", Boolean)
    ], CardComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('style.width'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], CardComponent.prototype, "widthStyle", null);
    __decorate([
        HostBinding('class.k-card-vertical'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], CardComponent.prototype, "vertical", null);
    __decorate([
        HostBinding('class.k-card-horizontal'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], CardComponent.prototype, "horizontal", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], CardComponent.prototype, "direction", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CardComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CardComponent.prototype, "width", void 0);
    CardComponent = __decorate([
        Component({
            selector: 'kendo-card',
            providers: [
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.card.component'
                }
            ],
            template: "\n        <ng-content></ng-content>\n    "
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], CardComponent);
    return CardComponent;
}());

/**
 * Specifies the content in the Card header.
 */
var CardHeaderComponent = /** @class */ (function () {
    function CardHeaderComponent() {
        this.hostClass = true;
    }
    __decorate([
        HostBinding('class.k-card-header'),
        __metadata("design:type", Boolean)
    ], CardHeaderComponent.prototype, "hostClass", void 0);
    CardHeaderComponent = __decorate([
        Component({
            selector: 'kendo-card-header',
            template: "\n        <ng-content></ng-content>\n    "
        })
    ], CardHeaderComponent);
    return CardHeaderComponent;
}());

/**
 * Specifies the content in the Card body.
 */
var CardBodyComponent = /** @class */ (function () {
    function CardBodyComponent() {
        this.hostClass = true;
    }
    __decorate([
        HostBinding('class.k-card-body'),
        __metadata("design:type", Boolean)
    ], CardBodyComponent.prototype, "hostClass", void 0);
    CardBodyComponent = __decorate([
        Component({
            selector: 'kendo-card-body',
            template: "\n        <ng-content></ng-content>\n    "
        })
    ], CardBodyComponent);
    return CardBodyComponent;
}());

/**
 * Specifies the content in the Card footer.
 */
var CardFooterComponent = /** @class */ (function () {
    function CardFooterComponent() {
        this.hostClass = true;
    }
    __decorate([
        HostBinding('class.k-card-footer'),
        __metadata("design:type", Boolean)
    ], CardFooterComponent.prototype, "hostClass", void 0);
    CardFooterComponent = __decorate([
        Component({
            selector: 'kendo-card-footer',
            template: "\n        <ng-content></ng-content>\n    "
        })
    ], CardFooterComponent);
    return CardFooterComponent;
}());

/**
 * Specifies the action buttons of the Card.
 * * ([see example]({% slug actions_card %})).
 */
var CardActionsComponent = /** @class */ (function () {
    function CardActionsComponent() {
        this.hostClass = true;
        /**
         * Specifies the layout of the Card action buttons.
         *
         * * The possible values are:
         * * (Default) `horizontal`
         * * `vertical`
         *
         */
        this.orientation = 'horizontal';
        /**
         * Specifies the layout of the Card action buttons.
         *
         * The possible values are:
         * * (Default) `start`
         * * `center`
         * * `end`
         * * `stretched`
         *
         */
        this.layout = 'start';
        /**
         * Fires when the user clicks an action button.
         */
        this.action = new EventEmitter();
    }
    Object.defineProperty(CardActionsComponent.prototype, "stretchedClass", {
        get: function () {
            return this.layout === 'stretched';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CardActionsComponent.prototype, "startClass", {
        get: function () {
            return this.layout === 'start';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CardActionsComponent.prototype, "endClass", {
        get: function () {
            return this.layout === 'end';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CardActionsComponent.prototype, "centerClass", {
        get: function () {
            return this.layout === 'center';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CardActionsComponent.prototype, "verticalClass", {
        get: function () {
            return this.orientation === 'vertical';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CardActionsComponent.prototype, "horizontalClass", {
        get: function () {
            return this.orientation === 'horizontal';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    CardActionsComponent.prototype.onClick = function (action) {
        this.action.emit(action);
    };
    /**
     * @hidden
     */
    CardActionsComponent.prototype.actionTemplate = function () {
        return this.actions instanceof TemplateRef;
    };
    __decorate([
        HostBinding('class.k-card-actions'),
        __metadata("design:type", Boolean)
    ], CardActionsComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('class.k-card-actions-stretched'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], CardActionsComponent.prototype, "stretchedClass", null);
    __decorate([
        HostBinding('class.k-card-actions-start'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], CardActionsComponent.prototype, "startClass", null);
    __decorate([
        HostBinding('class.k-card-actions-end'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], CardActionsComponent.prototype, "endClass", null);
    __decorate([
        HostBinding('class.k-card-actions-center'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], CardActionsComponent.prototype, "centerClass", null);
    __decorate([
        HostBinding('class.k-card-actions-vertical'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], CardActionsComponent.prototype, "verticalClass", null);
    __decorate([
        HostBinding('class.k-card-actions-horizontal'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], CardActionsComponent.prototype, "horizontalClass", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CardActionsComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CardActionsComponent.prototype, "layout", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardActionsComponent.prototype, "actions", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], CardActionsComponent.prototype, "action", void 0);
    CardActionsComponent = __decorate([
        Component({
            selector: 'kendo-card-actions',
            template: "\n        <ng-content *ngIf=\"!actions\"></ng-content>\n\n        <ng-container *ngIf=\"!actionTemplate()\">\n            <button type=\"button\"\n                class=\"k-button\"\n                [class.k-primary]=\"action.primary\"\n                [class.k-flat]=\"action.flat\"\n                (click)=\"onClick(action)\"\n                *ngFor=\"let action of actions\"\n            >\n                {{ action.text }}\n            </button>\n        </ng-container>\n\n        <ng-template [ngTemplateOutlet]=\"actions\" *ngIf=\"actionTemplate()\"></ng-template>\n    "
        })
    ], CardActionsComponent);
    return CardActionsComponent;
}());

/**
 * Specifies a separator in the content of the Card.
 */
var CardSeparatorDirective = /** @class */ (function () {
    function CardSeparatorDirective() {
        this.hostClass = true;
        /**
         * Specifies the orientation of the Card separator.
         *
         * The possible values are:
         * (Default) `horizontal`
         * `vertical`
         */
        this.orientation = 'horizontal';
    }
    Object.defineProperty(CardSeparatorDirective.prototype, "verticalClass", {
        get: function () {
            return this.orientation === 'vertical';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CardSeparatorDirective.prototype, "horizontalClass", {
        get: function () {
            return this.orientation === 'horizontal';
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        HostBinding('class.k-card-separator'),
        __metadata("design:type", Boolean)
    ], CardSeparatorDirective.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('class.k-separator-vertical'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], CardSeparatorDirective.prototype, "verticalClass", null);
    __decorate([
        HostBinding('class.k-separator-horizontal'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], CardSeparatorDirective.prototype, "horizontalClass", null);
    __decorate([
        HostBinding('style.color'),
        Input(),
        __metadata("design:type", String)
    ], CardSeparatorDirective.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CardSeparatorDirective.prototype, "orientation", void 0);
    CardSeparatorDirective = __decorate([
        Directive({
            selector: '[kendoCardSeparator]'
        })
    ], CardSeparatorDirective);
    return CardSeparatorDirective;
}());

/**
 * Specifies the text and styles for the title of the Card.
 */
var CardTitleDirective = /** @class */ (function () {
    function CardTitleDirective() {
        this.hostClass = true;
    }
    __decorate([
        HostBinding('class.k-card-title'),
        __metadata("design:type", Boolean)
    ], CardTitleDirective.prototype, "hostClass", void 0);
    CardTitleDirective = __decorate([
        Directive({
            selector: '[kendoCardTitle]'
        })
    ], CardTitleDirective);
    return CardTitleDirective;
}());

/**
 * Specifies the text and styles for the subtitle of the Card.
 */
var CardSubtitleDirective = /** @class */ (function () {
    function CardSubtitleDirective() {
        this.hostClass = true;
    }
    __decorate([
        HostBinding('class.k-card-subtitle'),
        __metadata("design:type", Boolean)
    ], CardSubtitleDirective.prototype, "hostClass", void 0);
    CardSubtitleDirective = __decorate([
        Directive({
            selector: '[kendoCardSubtitle]'
        })
    ], CardSubtitleDirective);
    return CardSubtitleDirective;
}());

/**
 * Specifies any media that will be displayed and aligned in the Card.
 */
var CardMediaDirective = /** @class */ (function () {
    function CardMediaDirective() {
        this.hostClass = true;
    }
    __decorate([
        HostBinding('class.k-card-media'),
        __metadata("design:type", Boolean)
    ], CardMediaDirective.prototype, "hostClass", void 0);
    CardMediaDirective = __decorate([
        Directive({
            selector: '[kendoCardMedia]'
        })
    ], CardMediaDirective);
    return CardMediaDirective;
}());

/**
 * The settings of the Card action buttons.
 */
var CardAction = /** @class */ (function () {
    function CardAction() {
    }
    return CardAction;
}());

/**
 * Represents a template that defines the content of the ExpansionPanel title.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoExpansionPanelTitleDirective` directive inside the `<kendo-expansionpanel>` tag.
 * ([see example]({% slug title_expansionpanel %}#toc-title-template)).
 */
var ExpansionPanelTitleDirective = /** @class */ (function () {
    function ExpansionPanelTitleDirective(templateRef) {
        this.templateRef = templateRef;
    }
    ExpansionPanelTitleDirective = __decorate([
        Directive({
            selector: '[kendoExpansionPanelTitleDirective]'
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [TemplateRef])
    ], ExpansionPanelTitleDirective);
    return ExpansionPanelTitleDirective;
}());

/**
 * @hidden
 */
function expand(duration, height) {
    return [
        style({ overflow: 'hidden', display: 'block', height: 0 }),
        animate(duration + "ms ease-in", style({ height: "" + height }))
    ];
}
/**
 * @hidden
 */
function collapse(duration, height) {
    return [
        style({ overflow: 'hidden', height: "" + height }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', height: 0 }))
    ];
}

/**
 * Arguments for the `action` event of the ExpansionPanel.
 */
var ExpansionPanelActionEvent = /** @class */ (function (_super) {
    __extends(ExpansionPanelActionEvent, _super);
    function ExpansionPanelActionEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ExpansionPanelActionEvent;
}(PreventableEvent$1));

var DEFAULT_DURATION = 200;
var CONTENT_HIDDEN_CLASS = 'k-hidden';
/**
 * Represents the [Kendo UI ExpansionPanel component for Angular]({% slug overview_expansionpanel %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-expansionpanel title="Chile" subtitle="South America">
 *              There are various theories about the origin of the word Chile.
 *        </kendo-expansionpanel>
 *    `
 * })
 * class AppComponent {}
 * ```
 */
var ExpansionPanelComponent = /** @class */ (function () {
    function ExpansionPanelComponent(renderer, hostElement, ngZone, localizationService, builder) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.ngZone = ngZone;
        this.localizationService = localizationService;
        this.builder = builder;
        /**
         * Specifies the primary text in the header of the ExpansionPanel
         * ([see example]({% slug title_expansionpanel %}#toc-title-and-subtitle)).
         */
        this.title = '';
        /**
         * Specifies the secondary text in the header of the ExpansionPanel, which is rendered next to the collapse/expand icon
         * ([see example]({% slug title_expansionpanel %}#toc-title-and-subtitle)).
         */
        this.subtitle = '';
        /**
         * Specifies whether the ExpansionPanel is disabled. If disabled, the ExpansionPanel can be neither expanded nor collapsed
         * ([see example]({% slug disabled_expansionpanel %})).
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Specifies the animation settings of the ExpansionPanel
         * ([see example]({% slug animations_expansionpanel %})).
         *
         * The possible values are:
         * * Boolean
         *    * (Default) `true` Numeric values represent duration. Default duration is 200ms.
         *    * false
         * * Number
         */
        this.animation = true;
        /**
         * Fires when the `expanded` property of the component is updated.
         * Used to provide a two-way binding for the `expanded` property
         * ([see example]({% slug overview_expansionpanel %}#toc-events)).
         */
        this.expandedChange = new EventEmitter();
        /**
         * Fires when the expanded state of the ExpansionPanel is about to change. This event is preventable
         * ([see example]({% slug overview_expansionpanel %}#toc-events)).
         */
        this.action = new EventEmitter();
        /**
         * Fires when the ExpansionPanel is expanded. If there is animation it will fire when the animation is complete
         * ([see example]({% slug overview_expansionpanel %}#toc-events)).
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the ExpansionPanel is collapsed. If there is animation it will fire when the animation is complete
         * ([see example]({% slug overview_expansionpanel %}#toc-events)).
         */
        this.collapse = new EventEmitter();
        this.hostClass = true;
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.focused = false;
        this.animationEnd = new EventEmitter();
        this.subscriptions = new Subscription();
        this._expanded = false;
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    Object.defineProperty(ExpansionPanelComponent.prototype, "expanded", {
        get: function () {
            return this._expanded;
        },
        /**
         * Specifies whether the ExpansionPanel is expanded. The property supports two-way binding.
         * ([see example]({% slug interaction_expansionpanel %}#toc-setting-the-initial-state)).
         *
         * @default false
         */
        set: function (value) {
            if (value === this.expanded) {
                return;
            }
            this._expanded = value;
            if (this.expanded) {
                this.removeContentHiddenClass();
            }
            else {
                this.addContentHiddenClass();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExpansionPanelComponent.prototype, "expandedClass", {
        get: function () {
            return this.expanded && !this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExpansionPanelComponent.prototype, "focusClass", {
        get: function () {
            return this.focused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExpansionPanelComponent.prototype, "disabledClass", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    ExpansionPanelComponent.prototype.onComponentBlur = function () {
        if (this.focused) {
            this.focused = false;
        }
    };
    /**
     * @hidden
     */
    ExpansionPanelComponent.prototype.onComponentFocus = function () {
        if (!this.focused) {
            this.focused = true;
        }
    };
    ExpansionPanelComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.renderer.removeAttribute(this.hostElement.nativeElement, 'title');
        this.subscriptions = this.localizationService.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
        });
    };
    ExpansionPanelComponent.prototype.ngAfterViewInit = function () {
        this.initDomEvents();
        if (!this.expanded) {
            this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
        }
    };
    ExpansionPanelComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    /**
     * @hidden
     */
    ExpansionPanelComponent.prototype.initDomEvents = function () {
        var _this = this;
        if (!this.hostElement) {
            return;
        }
        if (!this.disabled) {
            this.ngZone.runOutsideAngular(function () {
                var nativeElement = _this.hostElement.nativeElement;
                _this.subscriptions.add(_this.renderer.listen(nativeElement, 'keydown', _this.keyDownHandler.bind(_this)));
            });
        }
    };
    /**
     * @hidden
     */
    ExpansionPanelComponent.prototype.keyDownHandler = function (ev) {
        var _this = this;
        var isEnterOrSpace = ev.keyCode === Keys.Enter || ev.keyCode === Keys.Space;
        if (!isEnterOrSpace) {
            return;
        }
        if (hasClass(ev.target, 'k-expander')) {
            ev.preventDefault();
            this.ngZone.run(function () {
                _this.onHeaderAction();
            });
        }
    };
    /**
     * @hidden
     */
    ExpansionPanelComponent.prototype.onHeaderClick = function (ev) {
        if (!isFocusable(ev.target) && !this.disabled) {
            this.onHeaderAction();
        }
    };
    /**
     * @hidden
     */
    ExpansionPanelComponent.prototype.onHeaderAction = function () {
        this.focused = true;
        var eventArgs = new ExpansionPanelActionEvent();
        eventArgs.action = this.expanded ? 'collapse' : 'expand';
        this.action.emit(eventArgs);
        if (!eventArgs.isDefaultPrevented()) {
            this.setExpanded(!this.expanded);
            if (this.expanded) {
                this.removeContentHiddenClass();
            }
            if (this.animation) {
                this.animateContent();
                return;
            }
            if (!this.expanded) {
                this.addContentHiddenClass();
            }
            this.emitExpandCollapseEvent();
        }
    };
    Object.defineProperty(ExpansionPanelComponent.prototype, "indicatorClasses", {
        /**
         * @hidden
         */
        get: function () {
            if (this.expanded) {
                return this.collapseIcon ? this.collapseIcon : "k-icon k-i-arrow-chevron-up";
            }
            else {
                return this.expandIcon ? this.expandIcon : "k-icon k-i-arrow-chevron-down";
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Toggles the visibility of the ExpansionPanel
     * ([see example]({% slug interaction_expansionpanel %}#toc-toggling-the-content)).
     *
     * @param expanded? - Boolean. Specifies, whether the ExpansionPanel will be expanded or collapsed.
     */
    ExpansionPanelComponent.prototype.toggle = function (expanded) {
        var previous = this.expanded;
        var current = isPresent(expanded) ? expanded : !previous;
        if (current === previous) {
            return;
        }
        this.setExpanded(current);
        if (this.expanded) {
            this.removeContentHiddenClass();
        }
        if (this.animation) {
            this.animateContent();
            return;
        }
        if (!this.expanded) {
            this.addContentHiddenClass();
        }
        this.emitExpandCollapseEvent();
    };
    ExpansionPanelComponent.prototype.setExpanded = function (value) {
        this._expanded = value;
        this.expandedChange.emit(value);
    };
    ExpansionPanelComponent.prototype.animateContent = function () {
        var _this = this;
        var duration = typeof this.animation === 'boolean' ? DEFAULT_DURATION : this.animation;
        var contentHeight = getComputedStyle(this.content.nativeElement).height;
        var animation = this.expanded ? expand(duration, contentHeight) : collapse(duration, contentHeight);
        var player = this.createPlayer(animation, this.content.nativeElement);
        this.animationEnd.pipe(take(1)).subscribe(function () {
            if (!_this.expanded) {
                _this.addContentHiddenClass();
            }
            _this.emitExpandCollapseEvent();
        });
        player.play();
    };
    ExpansionPanelComponent.prototype.createPlayer = function (animation, animatedElement) {
        var _this = this;
        var factory = this.builder.build(animation);
        var player = factory.create(animatedElement);
        player.onDone(function () {
            if (player) {
                _this.animationEnd.emit();
                player.destroy();
                player = null;
            }
        });
        return player;
    };
    ExpansionPanelComponent.prototype.emitExpandCollapseEvent = function () {
        this[this.expanded ? 'expand' : 'collapse'].emit();
    };
    ExpansionPanelComponent.prototype.addContentHiddenClass = function () {
        this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
    };
    ExpansionPanelComponent.prototype.removeContentHiddenClass = function () {
        this.renderer.removeClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ExpansionPanelComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ExpansionPanelComponent.prototype, "subtitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ExpansionPanelComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], ExpansionPanelComponent.prototype, "expanded", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ExpansionPanelComponent.prototype, "expandIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ExpansionPanelComponent.prototype, "collapseIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ExpansionPanelComponent.prototype, "animation", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ExpansionPanelComponent.prototype, "expandedChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ExpansionPanelComponent.prototype, "action", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ExpansionPanelComponent.prototype, "expand", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ExpansionPanelComponent.prototype, "collapse", void 0);
    __decorate([
        ContentChild(ExpansionPanelTitleDirective, { static: false }),
        __metadata("design:type", ExpansionPanelTitleDirective)
    ], ExpansionPanelComponent.prototype, "titleTemplate", void 0);
    __decorate([
        ViewChild('content', { static: true }),
        __metadata("design:type", ElementRef)
    ], ExpansionPanelComponent.prototype, "content", void 0);
    __decorate([
        HostBinding('class.k-expander'),
        __metadata("design:type", Boolean)
    ], ExpansionPanelComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('attr.aria-expanded'),
        HostBinding('class.k-expanded'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ExpansionPanelComponent.prototype, "expandedClass", null);
    __decorate([
        HostBinding('class.k-state-focus'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ExpansionPanelComponent.prototype, "focusClass", null);
    __decorate([
        HostBinding('attr.aria-disabled'),
        HostBinding('class.k-state-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ExpansionPanelComponent.prototype, "disabledClass", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], ExpansionPanelComponent.prototype, "direction", void 0);
    __decorate([
        HostBinding('attr.tabindex'),
        __metadata("design:type", Number)
    ], ExpansionPanelComponent.prototype, "tabindex", void 0);
    __decorate([
        HostListener('blur'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ExpansionPanelComponent.prototype, "onComponentBlur", null);
    __decorate([
        HostListener('focus'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ExpansionPanelComponent.prototype, "onComponentFocus", null);
    ExpansionPanelComponent = __decorate([
        Component({
            exportAs: 'kendoExpansionPanel',
            providers: [
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.expansionpanel'
                }
            ],
            selector: 'kendo-expansionpanel',
            template: "\n        <div\n            [class.k-expander-header]=\"true\"\n            (click)=\"onHeaderClick($event)\">\n            <ng-container *ngIf=\"!titleTemplate\">\n                <div *ngIf=\"title\" class=\"k-expander-title\">{{ title }}</div>\n                <span class=\"k-spacer\"></span>\n                <div *ngIf=\"subtitle\" class=\"k-expander-sub-title\">\n                    {{ subtitle }}\n                </div>\n            </ng-container>\n            <ng-template\n                *ngIf=\"titleTemplate\"\n                [ngTemplateOutlet]=\"titleTemplate?.templateRef\">\n            </ng-template>\n            <span class=\"k-expander-indicator\">\n                <span [ngClass]=\"indicatorClasses\"></span>\n            </span>\n        </div>\n        <div #content class=\"k-expander-content-wrapper\">\n            <div  class=\"k-expander-content\" [attr.aria-hidden]=\"!expanded\">\n                <ng-content></ng-content>\n            </div>\n        </div>\n    "
        }),
        __metadata("design:paramtypes", [Renderer2,
            ElementRef,
            NgZone,
            LocalizationService,
            AnimationBuilder])
    ], ExpansionPanelComponent);
    return ExpansionPanelComponent;
}());

/**
 * @hidden
 */
var normalizeValue = function (value) {
    return value ? +value : undefined;
};
/**
 * @hidden
 */
var isRowItemPresent = function (items) {
    return items.some(function (item) { return isPresent(item.row); });
};
/**
 * @hidden
 */
var propsChanged = function (initialProps, newProps) {
    for (var i = 0; i < initialProps.length; i++) {
        if (initialProps[i] !== newProps[i]) {
            return true;
        }
    }
    return false;
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
var getDropTarget = function (event) {
    if (!(isDocumentAvailable() && isPresent(document.elementsFromPoint))) {
        return [event.target];
    }
    return document.elementsFromPoint(event.clientX, event.clientY)
        .filter(function (item) { return item.classList && (item.classList.contains('k-tilelayout-item') || item.classList.contains('k-layout-item-hint')); });
};
/**
 * @hidden
 */
var setElementStyles = function (renderer, elem, styles) {
    var props = Object.keys(styles);
    props.forEach(function (p) {
        renderer.setStyle(elem, p, styles[p]);
    });
};
/**
 * @hidden
 */
var calculateCellFromPosition = function (coordinates, tileLayoutElement, gap, cellSize, columns, rtl) {
    if (rtl === void 0) { rtl = false; }
    var tileLayoutRect = tileLayoutElement.getBoundingClientRect();
    var totalRows = (tileLayoutRect.height - gap.rows) / (cellSize.height + gap.rows);
    var distanceFromTop = coordinates.y - tileLayoutRect.y;
    var distanceFromLeft = coordinates.x - tileLayoutRect.x;
    var distanceFromRight = tileLayoutRect.right - coordinates.x;
    var distanceToCellWidthRatio = Math.floor((rtl ? distanceFromRight : distanceFromLeft) / (gap.columns + cellSize.width));
    var cappedColumnPosition = Math.min(distanceToCellWidthRatio + 1, columns);
    var distanceToCellHeightRatio = Math.floor(distanceFromTop / (gap.rows + cellSize.height));
    var cappedRowPosition = Math.min(distanceToCellHeightRatio + 1, totalRows);
    var col = Math.max(cappedColumnPosition, 0);
    var row = Math.max(cappedRowPosition, 0);
    return {
        row: row, col: col
    };
};

/**
 * @hidden
 */
var RESIZE_HANDLE_UNIDIRECTIONAL_SIZE = 9;
/**
 * @hidden
 */
var RESIZE_HANDLE_BIDIRECTIONAL_SIZE = 25;
/**
 * @hidden
 */
var RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP = 5;
/**
 * @hidden
 */
var RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP = 18;
/**
 * @hidden
 */
var DRAGGED_ZINDEX = 10;
/**
 * @hidden
 */
var RESIZE_DIRECTIONS = ['ew', 'ns', 'nwse'];
/**
 * @hidden
 */
var RTL_RESIZE_DIRECTIONS = ['ew', 'ns', 'nesw'];
/**
 * @hidden
 */
var RESIZE_HANDLE_DIMENSIONS = {
    // numeric values represent pixels
    ew: {
        width: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,
        overlapX: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP
    },
    ns: {
        height: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,
        overlapY: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP
    },
    nwse: {
        width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,
        overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP
    },
    nesw: {
        width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,
        overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP
    }
};
/**
 * @hidden
 */
var OVERLAP_THRESHOLD = 0.3;
/**
 * @hidden
 */
var REVERSE_OVERLAP_THRESHOLD = -0.7;
/**
 * @hidden
 */
var HINT_BORDERS_HEIGHT = 2;

/**
 * @hidden
 */
var PreventableEvent$2 = /** @class */ (function () {
    function PreventableEvent$$1() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    PreventableEvent$$1.prototype.preventDefault = function () {
        this.prevented = true;
    };
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    PreventableEvent$$1.prototype.isDefaultPrevented = function () {
        return this.prevented;
    };
    return PreventableEvent$$1;
}());

/**
 * Arguments for the `reorder` event. The event fires when the order or starting
 * positions of the items is changed via the UI. If you prevent the event, the change is canceled ([see example]({% slug reordering_tilelayout %}#toc-handling-the-reorder-event)).
 */
var TileLayoutReorderEvent = /** @class */ (function (_super) {
    __extends(TileLayoutReorderEvent, _super);
    /**
     * Constructs the event arguments for the `reorder` event.
     * @param item - The TileLayoutItem being reordered.
     * @param items - The TileLayoutItem collection that holds the currently rendered items and their internal state.
     * @param newIndex - The new order index of the reordered item used to determine its positioning relative to the other items.
     * @param oldIndex - The initial order index of the reordered item used to determine its positioning relative to the other items.
     * @param newCol - The new start column of the reordered item.
     * @param oldCol - The initial start column of the reordered item.
     * @param newRow - The new start row of the reordered item.
     * @param oldRow - The initial start row of the reordered item.
     * @hidden
     */
    function TileLayoutReorderEvent(item, items, newIndex, oldIndex, newCol, oldCol, newRow, oldRow) {
        var _this = _super.call(this) || this;
        _this.item = item;
        _this.items = items;
        _this.newIndex = newIndex;
        _this.oldIndex = oldIndex;
        _this.newCol = newCol;
        _this.oldCol = oldCol;
        _this.newRow = newRow;
        _this.oldRow = oldRow;
        return _this;
    }
    return TileLayoutReorderEvent;
}(PreventableEvent$2));

/**
 * Arguments for the `resize` event. The `resize` event fires when any item size
 * is changed from the UI. If you cancel the event, the change is prevented ([see example]({% slug resizing_tilelayout %}#toc-handling-the-resize-event)).
 */
var TileLayoutResizeEvent = /** @class */ (function (_super) {
    __extends(TileLayoutResizeEvent, _super);
    /**
     * Constructs the event arguments for the `resize` event.
     * @param item - The TileLayoutItem being resized
     * @param items - The TileLayoutItem collection
     * @param newRowSpan - The new rowSpan of the resized item
     * @param oldRowSpan - The initial rowSpan of the resized item
     * @param newColSpan - The new colSpan of the resized item
     * @param oldColSpan - The initial colSpan of the resized item
     * @hidden
     */
    function TileLayoutResizeEvent(item, items, newRowSpan, oldRowSpan, newColSpan, oldColSpan) {
        var _this = _super.call(this) || this;
        _this.item = item;
        _this.items = items;
        _this.newRowSpan = newRowSpan;
        _this.oldRowSpan = oldRowSpan;
        _this.newColSpan = newColSpan;
        _this.oldColSpan = oldColSpan;
        return _this;
    }
    return TileLayoutResizeEvent;
}(PreventableEvent$2));

/**
 * @hidden
 */
var TileLayoutDraggingService = /** @class */ (function () {
    function TileLayoutDraggingService(zone, renderer, localization) {
        var _this = this;
        this.zone = zone;
        this.renderer = renderer;
        this.localization = localization;
        this.reorderable = new BehaviorSubject(null);
        this.resizable = new BehaviorSubject(null);
        this.reorder = new Subject();
        this.resize = new Subject();
        this.lastDragCursorOffset = {
            x: 0,
            y: 0
        };
        this.localizationSubscription = this.localization.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            return _this.rtl = rtl;
        });
    }
    Object.defineProperty(TileLayoutDraggingService.prototype, "colStart", {
        get: function () {
            return this.currentColStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutDraggingService.prototype, "rowStart", {
        get: function () {
            return this.currentRowStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutDraggingService.prototype, "itemWrapper", {
        get: function () {
            return this.draggedItemWrapper;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutDraggingService.prototype, "order", {
        get: function () {
            return this.targetOrder;
        },
        enumerable: true,
        configurable: true
    });
    TileLayoutDraggingService.prototype.ngOnDestroy = function () {
        this.localizationSubscription.unsubscribe();
    };
    TileLayoutDraggingService.prototype.handlePress = function (originalEvent) {
        var _this = this;
        var resizing = !!originalEvent.target.classList.contains('k-resize-handle');
        var closestTile = closestInScope(originalEvent.target, function (el) { return el.classList.contains('k-tilelayout-item'); }, this.tileLayoutSettings.tileLayoutElement);
        var closestHeader = closestInScope(originalEvent.target, function (el) { return el.classList.contains('k-tilelayout-item-header'); }, this.tileLayoutSettings.tileLayoutElement);
        if (!closestTile) {
            return;
        }
        this.zone.run(function () {
            _this.draggedItemWrapper = closestTile;
            _this.draggedItem = _this.tileLayoutSettings.items
                .find(function (item) { return item.order === +closestTile.style.order; });
        });
        var reordering = !resizing && this.reorderable.getValue() && this.draggedItem.reorderable && closestHeader;
        if (!(reordering || resizing)) {
            return;
        }
        else {
            originalEvent.preventDefault();
        }
        this.zone.run(function () {
            _this.reordering = reordering;
            _this.resizing = resizing;
        });
        var tileRect = this.draggedItemWrapper.getBoundingClientRect();
        this.zone.run(function () {
            _this.offset = {
                top: originalEvent.clientY - tileRect.top,
                left: originalEvent.clientX - tileRect.left,
                x: tileRect.x,
                y: tileRect.y,
                width: tileRect.width,
                height: tileRect.height
            };
            _this.targetSize = {
                rowSpan: _this.draggedItem.rowSpan,
                colSpan: _this.draggedItem.colSpan
            };
            _this.cellSize = {
                width: (tileRect.width - ((_this.targetSize.colSpan - 1) * _this.tileLayoutSettings.gap.columns)) / _this.targetSize.colSpan,
                height: (tileRect.height - ((_this.targetSize.rowSpan - 1) * _this.tileLayoutSettings.gap.rows)) / _this.targetSize.rowSpan
            };
            _this.lastDragCursorOffset = {
                x: originalEvent.clientX,
                y: originalEvent.clientY
            };
        });
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            left: tileRect.left + window.pageXOffset + 'px',
            top: tileRect.top + window.pageYOffset + 'px',
            width: tileRect.width + 'px',
            height: tileRect.height + 'px',
            zIndex: DRAGGED_ZINDEX
        });
        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
            display: 'flex',
            height: (tileRect.height - HINT_BORDERS_HEIGHT) + 'px'
        });
        this.zone.run(function () { return _this.targetOrder = _this.draggedItem.order; });
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            position: 'absolute'
        });
        if (this.reorderable.getValue() && !resizing) {
            this.zone.run(function () {
                _this.currentColStart = _this.draggedItem.colStart;
                _this.currentRowStart = _this.draggedItem.rowStart;
            });
            var headerEl = this.draggedItem.elem.nativeElement.querySelector('.k-tilelayout-item-header');
            this.renderer.addClass(headerEl, 'k-cursor-grabbing');
        }
        else if (this.resizable && resizing) {
            this.zone.run(function () {
                _this.startingPoint = {
                    top: originalEvent.clientY,
                    left: originalEvent.clientX
                };
                _this.currentResizingColSpan = _this.draggedItem.colSpan;
                _this.currentResizingRowSpan = _this.draggedItem.rowSpan;
                if (_this.draggedItem.col) {
                    _this.currentColStart = _this.draggedItem.col.toString();
                }
                if (_this.draggedItem.row) {
                    _this.currentRowStart = _this.draggedItem.row.toString();
                }
                _this.direction = originalEvent.target.classList[1];
            });
        }
    };
    TileLayoutDraggingService.prototype.handleDrag = function (originalEvent) {
        if (this.draggedItemWrapper) {
            if (this.reordering) {
                this.reorderItems(originalEvent);
            }
            else if (this.resizing) {
                this.resizeItem(originalEvent);
            }
            this.lastDragCursorOffset = {
                x: originalEvent.clientX,
                y: originalEvent.clientY
            };
        }
    };
    TileLayoutDraggingService.prototype.handleRelease = function (originalEvent) {
        var _this = this;
        originalEvent.preventDefault();
        if (this.reordering) {
            var initialOrder_1 = this.draggedItem.order;
            var initialCol = this.draggedItem.col;
            var initialRow = this.draggedItem.row;
            var targetCol = normalizeValue(this.currentColStart);
            var targetRow = normalizeValue(this.currentRowStart);
            if (propsChanged([this.targetOrder, targetCol, targetRow], [initialOrder_1, initialCol, initialRow])) {
                var reorderEvent = new TileLayoutReorderEvent(this.draggedItem, this.tileLayoutSettings.items, this.targetOrder, initialOrder_1, normalizeValue(this.currentColStart), initialCol, targetRow, initialRow);
                this.reorder.next(reorderEvent);
                if (!reorderEvent.isDefaultPrevented()) {
                    if (this.targetOrder > initialOrder_1) {
                        this.zone.run(function () {
                            var _loop_1 = function (i) {
                                _this.tileLayoutSettings.items.find(function (item) { return item.order === i; }).order = i - 1;
                            };
                            for (var i = initialOrder_1 + 1; i <= _this.targetOrder; i++) {
                                _loop_1(i);
                            }
                        });
                    }
                    else {
                        this.zone.run(function () {
                            var _loop_2 = function (i) {
                                _this.tileLayoutSettings.items.find(function (item) { return item.order === i; }).order = i + 1;
                            };
                            for (var i = _this.targetOrder; i < initialOrder_1; i++) {
                                _loop_2(i);
                            }
                        });
                    }
                    this.draggedItem.order = this.targetOrder;
                    if (this.draggedItem.col) {
                        this.draggedItem.col = +this.currentColStart;
                    }
                    if (this.draggedItem.row) {
                        this.draggedItem.row = +this.currentRowStart;
                    }
                }
            }
            this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);
            this.zone.run(function () { return _this.cleanUp(); });
        }
        else if (!this.reordering && this.resizing) {
            var initialRowSpan = this.draggedItem.rowSpan;
            var initialColSpan = this.draggedItem.colSpan;
            var _a = isRowItemPresent(this.tileLayoutSettings.items) ?
                this.targetSpan() :
                { targetColSpan: this.currentResizingColSpan, targetRowSpan: this.currentResizingRowSpan }, targetColSpan = _a.targetColSpan, targetRowSpan = _a.targetRowSpan;
            if (propsChanged([initialRowSpan, initialColSpan], [targetRowSpan, targetColSpan])) {
                var resizeEvent = new TileLayoutResizeEvent(this.draggedItem, this.tileLayoutSettings.items, targetRowSpan, initialRowSpan, targetColSpan, initialColSpan);
                this.resize.next(resizeEvent);
                if (!resizeEvent.isDefaultPrevented()) {
                    this.draggedItem.colSpan = this.currentResizingColSpan;
                    this.draggedItem.rowSpan = this.currentResizingRowSpan;
                }
            }
            this.zone.run(function () { return _this.cleanUp(); });
        }
    };
    TileLayoutDraggingService.prototype.reorderItems = function (event) {
        var _this = this;
        var targets = getDropTarget(event);
        var closestTile = targets.find(function (t) { return t !== _this.draggedItemWrapper; });
        var tileOrder = closestTile ? +closestTile.style.order : +this.draggedItemWrapper.style.order;
        if (this.tileLayoutSettings.autoFlow !== 'none') {
            var deltaX = event.clientX - this.lastDragCursorOffset.x;
            var deltaY = event.clientY - this.lastDragCursorOffset.y;
            var directionX = deltaX > 0 ? 'right' : deltaX < 0 ? 'left' : undefined;
            var directionY = deltaY > 0 ? 'down' : deltaX < 0 ? 'up' : undefined;
            var rect = this.draggedItemWrapper.getBoundingClientRect();
            var horizontalGap = this.tileLayoutSettings.gap.columns;
            var verticalGap = this.tileLayoutSettings.gap.rows;
            if (directionX && this.draggedItem.col) {
                var col = calculateCellFromPosition({
                    x: directionX === 'right' ? rect.right - horizontalGap : rect.left + horizontalGap,
                    y: event.clientY
                }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl).col;
                var targetStartCol = this.getTargetCol(col, directionX);
                this.currentColStart = targetStartCol.toString();
            }
            if (directionY && this.draggedItem.row) {
                var row = calculateCellFromPosition({
                    x: event.clientX,
                    y: directionY === 'down' ? rect.bottom - verticalGap : rect.top + verticalGap
                }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl).row;
                var targetStartRow = this.getTargetRow(row, directionY);
                this.currentRowStart = targetStartRow.toString();
            }
        }
        var hintBefore = tileOrder < this.targetOrder;
        var hintAfter = tileOrder > this.targetOrder;
        this.zone.run(function () { return _this.targetOrder = tileOrder; });
        if (hintBefore) {
            this.tileLayoutSettings.tileLayoutElement
                .insertBefore(this.tileLayoutSettings.hintElement, this.tileLayoutSettings.tileLayoutElement.firstChild);
        }
        else if (hintAfter) {
            this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);
        }
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            top: (event.pageY - this.offset.top) + 'px',
            left: (event.pageX - this.offset.left) + 'px'
        });
    };
    TileLayoutDraggingService.prototype.resizeItem = function (event) {
        var _this = this;
        setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {
            cursor: this.direction.split('k-cursor-')[1]
        });
        var currentWidth = this.rtl ?
            this.offset.width + (this.offset.x - event.clientX) :
            this.offset.width + (event.clientX - this.startingPoint.left);
        var currentHeight = this.offset.height + (event.clientY - this.startingPoint.top);
        var hintRect = this.tileLayoutSettings.hintElement.getBoundingClientRect();
        var hintWidth = hintRect.width;
        var hintHeight = hintRect.height;
        var horizontalDragDirection = event.clientX - this.lastDragCursorOffset.x;
        var verticalDragDirection = event.clientY - this.lastDragCursorOffset.y;
        var startCol = this.draggedItem.col ? this.draggedItem.col : calculateCellFromPosition({
            x: this.rtl ? hintRect.right : hintRect.x,
            y: hintRect.y
        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl).col;
        var maxWidth = (this.tileLayoutSettings.columns - startCol) * (this.cellSize.width + this.tileLayoutSettings.gap.columns) + this.cellSize.width;
        var resizeHorizontally = function () {
            setElementStyles(_this.renderer, _this.draggedItemWrapper, {
                width: Math.min(Math.max(currentWidth, _this.cellSize.width), maxWidth) + 'px'
            });
            if (_this.rtl && currentWidth > _this.cellSize.width) {
                var totalWidth = _this.tileLayoutSettings.columns * (_this.cellSize.width + _this.tileLayoutSettings.gap.columns);
                var leftBoundary = _this.tileLayoutSettings.tileLayoutElement.getBoundingClientRect().right - totalWidth;
                setElementStyles(_this.renderer, _this.draggedItemWrapper, {
                    left: Math.max(event.clientX, leftBoundary) + 'px'
                });
            }
            var deltaX = currentWidth - hintWidth;
            var _a = _this.draggedItem.elem.nativeElement.getBoundingClientRect(), x = _a.x, y = _a.y, right = _a.right;
            var col = calculateCellFromPosition({ x: (_this.rtl ? right : x), y: y }, _this.tileLayoutSettings.tileLayoutElement, _this.tileLayoutSettings.gap, _this.cellSize, _this.tileLayoutSettings.columns, _this.rtl).col;
            var resizedColSpan = col + _this.currentResizingColSpan;
            var expandingCondition = _this.rtl ? horizontalDragDirection < 0 : horizontalDragDirection > 0;
            var shrinkingCondition = _this.rtl ? horizontalDragDirection > 0 : horizontalDragDirection < 0;
            if (deltaX > OVERLAP_THRESHOLD * _this.cellSize.width &&
                expandingCondition &&
                resizedColSpan <= _this.tileLayoutSettings.columns) {
                _this.currentResizingColSpan++;
            }
            else if (_this.currentResizingColSpan > 1 &&
                shrinkingCondition &&
                deltaX < REVERSE_OVERLAP_THRESHOLD * _this.cellSize.width) {
                _this.currentResizingColSpan--;
            }
            setElementStyles(_this.renderer, _this.tileLayoutSettings.hintElement, {
                gridColumnEnd: "span " + _this.currentResizingColSpan
            });
        };
        var resizeVertically = function () {
            setElementStyles(_this.renderer, _this.draggedItemWrapper, {
                height: Math.max(currentHeight, _this.cellSize.height) + 'px'
            });
            var deltaY = currentHeight - hintHeight;
            if (deltaY > OVERLAP_THRESHOLD * _this.cellSize.height && verticalDragDirection > 0) {
                _this.currentResizingRowSpan++;
            }
            else if (_this.currentResizingRowSpan > 1 &&
                verticalDragDirection < 0 && deltaY < REVERSE_OVERLAP_THRESHOLD * _this.cellSize.height) {
                _this.currentResizingRowSpan--;
            }
            setElementStyles(_this.renderer, _this.tileLayoutSettings.hintElement, {
                gridRowEnd: "span " + _this.currentResizingRowSpan
            });
            setElementStyles(_this.renderer, _this.tileLayoutSettings.hintElement, {
                height: _this.calculateHintHeight() + "px"
            });
        };
        if (this.direction.indexOf('ew') > -1) {
            resizeHorizontally();
        }
        else if (this.direction.indexOf('ns') > -1) {
            resizeVertically();
        }
        else {
            resizeHorizontally();
            resizeVertically();
        }
    };
    TileLayoutDraggingService.prototype.cleanUp = function () {
        this.targetOrder = this.currentResizingColSpan = this.currentColStart = this.currentResizingRowSpan = this.currentRowStart = undefined;
        this.resizing = this.reordering = false;
        this.direction = null;
        if (this.draggedItemWrapper) {
            var grabHandle = this.draggedItemWrapper.querySelector('.k-cursor-grab');
            if (grabHandle) {
                this.renderer.removeClass(grabHandle, 'k-cursor-grabbing');
            }
            setElementStyles(this.renderer, this.draggedItemWrapper, {
                top: '',
                left: '',
                display: '',
                width: '',
                height: '',
                zIndex: '',
                position: ''
            });
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                display: 'none',
                height: 'auto'
            });
            setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {
                cursor: 'default'
            });
            this.draggedItemWrapper =
                this.offset =
                    this.draggedItem =
                        this.resizing =
                            this.reordering =
                                this.currentResizingColSpan =
                                    this.currentResizingRowSpan =
                                        this.startingPoint = undefined;
            this.lastDragCursorOffset = {
                x: 0,
                y: 0
            };
        }
    };
    TileLayoutDraggingService.prototype.targetSpan = function () {
        var itemRect = this.draggedItem.elem.nativeElement.getBoundingClientRect();
        var startingCell = calculateCellFromPosition({ x: this.rtl ? itemRect.right : itemRect.x, y: itemRect.y }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
        var targetEndCell = calculateCellFromPosition({
            x: this.rtl ? itemRect.x + OVERLAP_THRESHOLD * this.cellSize.width : itemRect.right - OVERLAP_THRESHOLD * this.cellSize.width,
            y: itemRect.bottom - OVERLAP_THRESHOLD * this.cellSize.height
        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
        return {
            targetColSpan: targetEndCell.col - startingCell.col + 1,
            targetRowSpan: targetEndCell.row - startingCell.row + 1
        };
    };
    TileLayoutDraggingService.prototype.getTargetCol = function (col, direction) {
        if (this.rtl) {
            return direction === 'left' ? col - this.draggedItem.colSpan + 1 : col;
        }
        return direction === 'right' ? col - this.draggedItem.colSpan + 1 : col;
    };
    TileLayoutDraggingService.prototype.getTargetRow = function (row, direction) {
        return direction === 'down' ? row - this.draggedItem.rowSpan + 1 : row;
    };
    TileLayoutDraggingService.prototype.calculateHintHeight = function () {
        var totalHintCellsHeight = this.currentResizingRowSpan * this.cellSize.height;
        var totalHintGapsHeight = (this.currentResizingRowSpan - 1) * this.tileLayoutSettings.gap.rows;
        var hintHeight = totalHintCellsHeight + totalHintGapsHeight - HINT_BORDERS_HEIGHT;
        return hintHeight;
    };
    TileLayoutDraggingService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [NgZone,
            Renderer2,
            LocalizationService])
    ], TileLayoutDraggingService);
    return TileLayoutDraggingService;
}());

/**
 * Represents a tile item within the TileLayoutComponent.
 */
var TileLayoutItemComponent = /** @class */ (function () {
    function TileLayoutItemComponent(elem, renderer, localization, draggingService) {
        var _this = this;
        this.elem = elem;
        this.renderer = renderer;
        this.localization = localization;
        this.draggingService = draggingService;
        /**
         * Determines how many rows will the tile item span ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default 1
         */
        this.rowSpan = 1;
        /**
         * Determines how many columns will the tile item span ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default 1
         */
        this.colSpan = 1;
        /**
         * Determines whether the item can be reordered. By default all items are reorderable when the [reorderable]({% slug api_layout_tilelayoutcomponent %}#toc-reorderable) property of the TileLayoutComponent is set to `true` ([see example]({% slug reordering_tilelayout %}#toc-disable-reordering)).
         *
         * @default true
         */
        this.reorderable = true;
        /**
         * Determines whether the item can be resized. By default all items are resizable when the [resizable]({% slug api_layout_tilelayoutcomponent %}#resizable) property of the TileLayoutComponent is set to `true` ([see example]({% slug resizing_tilelayout %}#toc-disable-resizing)).
         * @default true
         */
        this.resizable = true;
        this.itemClass = true;
        this.subs = new Subscription();
        this.subs.add(this.localization.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.rtl = rtl;
        }));
        this.subs.add(this.draggingService.resizable.subscribe(function (resizable) {
            _this.resizeDirections = resizable && _this.resizable ?
                _this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;
        }));
    }
    Object.defineProperty(TileLayoutItemComponent.prototype, "order", {
        get: function () {
            return this._order;
        },
        /**
         * Determines the order of the tile items within the TileLayout.
         * If not set, the items will receive increasing sequential order in accordance with
         * their position in the DOM when initially rendered.
         */
        set: function (value) {
            this._order = value;
            this.renderer.setStyle(this.elem.nativeElement, 'order', "" + this._order);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutItemComponent.prototype, "colEnd", {
        get: function () {
            return "span " + this.colSpan;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutItemComponent.prototype, "rowEnd", {
        get: function () {
            return "span " + this.rowSpan;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutItemComponent.prototype, "colStart", {
        get: function () {
            return isPresent(this.col) ? this.col.toString() : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutItemComponent.prototype, "rowStart", {
        get: function () {
            return isPresent(this.row) ? this.row.toString() : undefined;
        },
        enumerable: true,
        configurable: true
    });
    TileLayoutItemComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.subs.add(this.draggingService.reorderable.subscribe(function (reorderable) {
            _this.toggleCursorClass(reorderable && _this.reorderable);
        }));
    };
    TileLayoutItemComponent.prototype.ngOnChanges = function (changes) {
        if (changes.reorderable && !changes.reorderable.firstChange) {
            this.toggleCursorClass(changes.reorderable.currentValue && this.draggingService.reorderable.getValue());
        }
        if (changes.resizable) {
            this.resizeDirections = this.resizable && this.draggingService.resizable.getValue() ?
                this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;
        }
    };
    TileLayoutItemComponent.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    TileLayoutItemComponent.prototype.toggleCursorClass = function (isReorderable) {
        var headerEl = this.elem.nativeElement.querySelector('.k-tilelayout-item-header');
        if (!headerEl) {
            return;
        }
        if (isReorderable) {
            this.renderer.addClass(headerEl, 'k-cursor-grab');
        }
        else {
            this.renderer.removeClass(headerEl, 'k-cursor-grab');
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TileLayoutItemComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TileLayoutItemComponent.prototype, "rowSpan", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TileLayoutItemComponent.prototype, "colSpan", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], TileLayoutItemComponent.prototype, "order", null);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TileLayoutItemComponent.prototype, "col", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TileLayoutItemComponent.prototype, "row", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TileLayoutItemComponent.prototype, "reorderable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TileLayoutItemComponent.prototype, "resizable", void 0);
    __decorate([
        HostBinding('class.k-tilelayout-item'),
        HostBinding('class.k-card'),
        __metadata("design:type", Boolean)
    ], TileLayoutItemComponent.prototype, "itemClass", void 0);
    __decorate([
        HostBinding('style.grid-column-end'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TileLayoutItemComponent.prototype, "colEnd", null);
    __decorate([
        HostBinding('style.grid-row-end'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TileLayoutItemComponent.prototype, "rowEnd", null);
    __decorate([
        HostBinding('style.grid-column-start'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TileLayoutItemComponent.prototype, "colStart", null);
    __decorate([
        HostBinding('style.grid-row-start'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TileLayoutItemComponent.prototype, "rowStart", null);
    TileLayoutItemComponent = __decorate([
        Component({
            selector: 'kendo-tilelayout-item',
            template: "\n        <kendo-tilelayout-item-header *ngIf=\"title\">\n            <h5 class=\"k-card-title\">{{ title }}</h5>\n        </kendo-tilelayout-item-header>\n        <ng-content></ng-content>\n        <ng-container *ngIf=\"resizable\">\n            <div\n                *ngFor=\"let dir of resizeDirections\"\n                class=\"k-resize-handle k-cursor-{{dir}}-resize k-touch-action-none\"\n                kendoTileLayoutResizeHandle\n                [rtl]=\"rtl\"\n                [resizeDirection]=\"dir\">\n            </div>\n        </ng-container>\n    "
        }),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            LocalizationService,
            TileLayoutDraggingService])
    ], TileLayoutItemComponent);
    return TileLayoutItemComponent;
}());

var autoFlowClasses = {
    column: 'k-grid-flow-col',
    row: 'k-grid-flow-row',
    'column-dense': 'k-grid-flow-col-dense',
    'row-dense': 'k-grid-flow-row-dense'
};
/**
 * Represents the [Kendo UI TileLayout component for Angular]({% slug overview_tilelayout %})
 */
var TileLayoutComponent = /** @class */ (function () {
    function TileLayoutComponent(elem, renderer, localization, draggingService, zone) {
        this.elem = elem;
        this.renderer = renderer;
        this.localization = localization;
        this.draggingService = draggingService;
        this.zone = zone;
        /**
         * Defines the number of columns ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default 1
         */
        this.columns = 1;
        /**
         * Determines the width of the columns. Numeric values are treated as pixels ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default '1fr'
         */
        this.columnWidth = '1fr';
        /**
         * Determines whether the reordering functionality will be enabled ([see example]({% slug reordering_tilelayout %})).
         * @default false
         */
        this.reorderable = false;
        /**
         * Determines whether the resizing functionality will be enabled ([see example]({% slug resizing_tilelayout %})).
         * @default false
         */
        this.resizable = false;
        /**
         * Determines the height of the rows. Numeric values are treated as pixels ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).
         * @default '1fr'
         */
        this.rowHeight = '1fr';
        /**
         * Controls how the auto-placement algorithm works, specifying exactly how auto-placed items are flowed in the TileLayout ([see example]({% slug tiles_autoflow_tilelayout %})).
         * For further reference, check the [grid-auto-flow CSS article](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow).
         *
         * The possible values are:
         * * (Default) `column`
         * * `row`
         * * `row dense`
         * * `column dense`
         * * `none`
         *
         */
        this.autoFlow = 'column';
        /**
         * Fires when the user completes the reordering of the item ([see example]({% slug overview_tilelayout %}#toc-events)).
         * This event is preventable. If you cancel it, the item will not be reordered.
         */
        this.reorder = new EventEmitter();
        /**
         * Fires when the user completes the resizing of the item ([see example]({% slug overview_tilelayout %}#toc-events)).
         * This event is preventable. If you cancel it, the item will not be resized.
         */
        this.resize = new EventEmitter();
        this.hostClass = true;
        this.subs = new Subscription();
        this._gap = {
            rows: 16,
            columns: 16
        };
        validatePackage(packageMetadata);
    }
    Object.defineProperty(TileLayoutComponent.prototype, "gap", {
        get: function () {
            return this._gap;
        },
        /**
         * The numeric values which determine the spacing in pixels between the layout items horizontally and vertically.
         * Properties:
         * * rows - the vertical spacing. Numeric values are treated as pixels. Defaults to `16`.
         * * columns - the horizontal spacing. Numeric values are treated as pixels. Defaults to `16`.
         *
         * When bound to a single numeric value, it will be set to both `rows` and `columns` properties.
         */
        set: function (value) {
            this._gap = (typeof value === 'number') ? { rows: value, columns: value } : Object.assign(this._gap, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutComponent.prototype, "gapStyle", {
        get: function () {
            return this.gap.rows + "px " + this.gap.columns + "px";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutComponent.prototype, "currentColStart", {
        get: function () {
            return this.draggingService.colStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutComponent.prototype, "currentRowStart", {
        get: function () {
            return this.draggingService.rowStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutComponent.prototype, "draggedItemWrapper", {
        get: function () {
            return this.draggingService.itemWrapper;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutComponent.prototype, "targetOrder", {
        get: function () {
            return this.draggingService.order;
        },
        enumerable: true,
        configurable: true
    });
    TileLayoutComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.applyColStyling();
        this.applyRowStyling();
        this.draggingService.reorderable.next(this.reorderable);
        this.draggingService.resizable.next(this.resizable);
        if (hasObservers(this.reorder)) {
            this.subs.add(this.draggingService.reorder.subscribe(function (e) { return _this.reorder.emit(e); }));
        }
        if (hasObservers(this.resize)) {
            this.subs.add(this.draggingService.resize.subscribe(function (e) { return _this.resize.emit(e); }));
        }
        this.subs.add(this.draggingService.reorderable.subscribe(function (reorderable) {
            if (reorderable && !_this.draggable) {
                _this.initializeDraggable();
            }
        }));
        this.subs.add(this.draggingService.resizable.subscribe(function (resizable) {
            if (resizable && !_this.draggable) {
                _this.initializeDraggable();
            }
        }));
        this.subs.add(this.localization.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
        }));
    };
    TileLayoutComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.draggingService.tileLayoutSettings = this.draggingServiceConfig();
        this.applyAutoFlow(null, autoFlowClasses[this.autoFlow]);
        this.items.changes.subscribe(function () {
            _this.setItemsOrder();
            _this.draggingService.tileLayoutSettings.items = _this.items.toArray();
        });
    };
    TileLayoutComponent.prototype.ngAfterContentInit = function () {
        this.setItemsOrder();
    };
    TileLayoutComponent.prototype.ngOnChanges = function (changes) {
        if (changes.columns || changes.columnWidth) {
            this.applyColStyling();
        }
        if (changes.rowHeight) {
            this.applyRowStyling();
        }
        if (changes.reorderable) {
            this.draggingService.reorderable.next(changes.reorderable.currentValue);
        }
        if (changes.resizable) {
            this.draggingService.resizable.next(changes.resizable.currentValue);
        }
        if (changes.gap || changes.autoFlow || changes.columns) {
            this.draggingService.tileLayoutSettings = this.draggingServiceConfig();
            if (changes.autoFlow) {
                this.applyAutoFlow(autoFlowClasses[changes.autoFlow.previousValue] || '', autoFlowClasses[changes.autoFlow.currentValue]);
            }
        }
    };
    TileLayoutComponent.prototype.ngOnDestroy = function () {
        if (this.draggable) {
            this.draggable.destroy();
        }
        this.subs.unsubscribe();
    };
    TileLayoutComponent.prototype.handlePress = function (_a) {
        var originalEvent = _a.originalEvent;
        this.draggingService.handlePress(originalEvent);
    };
    TileLayoutComponent.prototype.handleDrag = function (_a) {
        var originalEvent = _a.originalEvent;
        this.draggingService.handleDrag(originalEvent);
    };
    TileLayoutComponent.prototype.handleRelease = function (_a) {
        var originalEvent = _a.originalEvent;
        this.draggingService.handleRelease(originalEvent);
    };
    TileLayoutComponent.prototype.applyColStyling = function () {
        var colWidth = typeof this.columnWidth === 'number' ? this.columnWidth + "px" : this.columnWidth;
        var gridTemplateColumnsStyle = "repeat(" + this.columns + ", " + colWidth + ")";
        this.renderer.setStyle(this.elem.nativeElement, 'grid-template-columns', gridTemplateColumnsStyle);
    };
    TileLayoutComponent.prototype.applyRowStyling = function () {
        var rowHeight = typeof this.rowHeight === 'number' ? this.rowHeight + "px" : this.rowHeight;
        var gridAutoRowsStyle = "" + rowHeight;
        this.renderer.setStyle(this.elem.nativeElement, 'grid-auto-rows', gridAutoRowsStyle);
    };
    TileLayoutComponent.prototype.draggingServiceConfig = function () {
        return {
            tileLayoutElement: this.elem ? this.elem.nativeElement : undefined,
            hintElement: this.hint ? this.hint.nativeElement : undefined,
            gap: this.gap,
            columns: this.columns,
            autoFlow: this.autoFlow,
            items: this.items ? this.items.toArray() : []
        };
    };
    TileLayoutComponent.prototype.initializeDraggable = function () {
        var _this = this;
        this.draggable = new Draggable({
            press: this.handlePress.bind(this),
            drag: this.handleDrag.bind(this),
            release: this.handleRelease.bind(this)
        });
        this.zone.runOutsideAngular(function () { return _this.draggable.bindTo(_this.elem.nativeElement); });
    };
    TileLayoutComponent.prototype.applyAutoFlow = function (classToRemove, classToAdd) {
        var element = this.elem.nativeElement;
        if (classToRemove) {
            this.renderer.removeClass(element, classToRemove);
        }
        if (this.autoFlow !== 'none' && isPresent(classToAdd)) {
            this.renderer.addClass(element, classToAdd);
        }
    };
    TileLayoutComponent.prototype.setItemsOrder = function () {
        this.items.forEach(function (item, index) {
            if (!isPresent(item.order)) {
                item.order = index;
            }
        });
    };
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TileLayoutComponent.prototype, "columns", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TileLayoutComponent.prototype, "columnWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], TileLayoutComponent.prototype, "gap", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TileLayoutComponent.prototype, "reorderable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TileLayoutComponent.prototype, "resizable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TileLayoutComponent.prototype, "rowHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TileLayoutComponent.prototype, "autoFlow", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TileLayoutComponent.prototype, "reorder", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TileLayoutComponent.prototype, "resize", void 0);
    __decorate([
        HostBinding('class.k-widget'),
        HostBinding('class.k-tilelayout'),
        __metadata("design:type", Boolean)
    ], TileLayoutComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('style.gap'),
        HostBinding('style.padding'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TileLayoutComponent.prototype, "gapStyle", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], TileLayoutComponent.prototype, "direction", void 0);
    __decorate([
        ContentChildren(TileLayoutItemComponent),
        __metadata("design:type", QueryList)
    ], TileLayoutComponent.prototype, "items", void 0);
    __decorate([
        ViewChild('hint', { static: false }),
        __metadata("design:type", ElementRef)
    ], TileLayoutComponent.prototype, "hint", void 0);
    TileLayoutComponent = __decorate([
        Component({
            selector: 'kendo-tilelayout',
            providers: [
                LocalizationService,
                TileLayoutDraggingService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.tilelayout.component'
                }
            ],
            template: "\n        <ng-content></ng-content>\n        <div #hint class=\"k-layout-item-hint k-layout-item-hint-reorder\"\n            [style.display]=\"'none'\"\n            [style.order]=\"targetOrder\"\n            [style.gridColumnEnd]=\"draggedItemWrapper?.style.gridColumnEnd\"\n            [style.gridRowEnd]=\"draggedItemWrapper?.style.gridRowEnd\"\n            [style.gridColumnStart]=\"currentColStart\"\n            [style.gridRowStart]=\"currentRowStart\"\n            [style.zIndex]=\"'1'\"></div>\n    "
        }),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            LocalizationService,
            TileLayoutDraggingService,
            NgZone])
    ], TileLayoutComponent);
    return TileLayoutComponent;
}());

/**
 * Holds the main content of the TileLayoutItem component.
 */
var TileLayoutItemBodyComponent = /** @class */ (function () {
    function TileLayoutItemBodyComponent() {
        this.hostClass = true;
        this.minHeight = 0;
    }
    __decorate([
        HostBinding('class.k-tilelayout-item-body'),
        HostBinding('class.k-card-body'),
        __metadata("design:type", Boolean)
    ], TileLayoutItemBodyComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('style.min-height'),
        __metadata("design:type", Number)
    ], TileLayoutItemBodyComponent.prototype, "minHeight", void 0);
    TileLayoutItemBodyComponent = __decorate([
        Component({
            selector: 'kendo-tilelayout-item-body',
            template: "\n        <ng-content></ng-content>\n    "
        })
    ], TileLayoutItemBodyComponent);
    return TileLayoutItemBodyComponent;
}());

/**
 * Holds the content of the header section of the TileLayoutItem component.
 * This is the area which can be dragged to reorder the items if reordering is enabled for this item.
 */
var TileLayoutItemHeaderComponent = /** @class */ (function () {
    function TileLayoutItemHeaderComponent(draggingService) {
        this.draggingService = draggingService;
        this.hostClass = true;
    }
    Object.defineProperty(TileLayoutItemHeaderComponent.prototype, "touchActionNone", {
        get: function () {
            return this.draggingService.reorderable.getValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileLayoutItemHeaderComponent.prototype, "touchActionAuto", {
        get: function () {
            return !this.draggingService.reorderable.getValue();
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        HostBinding('class.k-tilelayout-item-header'),
        HostBinding('class.k-card-header'),
        __metadata("design:type", Boolean)
    ], TileLayoutItemHeaderComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('class.k-touch-action-none'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TileLayoutItemHeaderComponent.prototype, "touchActionNone", null);
    __decorate([
        HostBinding('class.k-touch-action-auto'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TileLayoutItemHeaderComponent.prototype, "touchActionAuto", null);
    TileLayoutItemHeaderComponent = __decorate([
        Component({
            selector: 'kendo-tilelayout-item-header',
            template: "\n        <ng-content></ng-content>\n    "
        }),
        __metadata("design:paramtypes", [TileLayoutDraggingService])
    ], TileLayoutItemHeaderComponent);
    return TileLayoutItemHeaderComponent;
}());

var exportedModules = [
    AvatarComponent
];
var declarations = exportedModules.slice();
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Avatar component.
 */
var AvatarModule = /** @class */ (function () {
    function AvatarModule() {
    }
    AvatarModule = __decorate([
        NgModule({
            declarations: [declarations],
            exports: [exportedModules],
            imports: [CommonModule]
        })
    ], AvatarModule);
    return AvatarModule;
}());

var cardDirectives = [
    CardTitleDirective,
    CardSubtitleDirective,
    CardSeparatorDirective,
    CardMediaDirective
];
var exportedModules$1 = [
    CardComponent,
    CardHeaderComponent,
    CardBodyComponent,
    CardFooterComponent,
    CardActionsComponent
].concat(cardDirectives);
var declarations$1 = exportedModules$1.slice();
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Card component.
 */
var CardModule = /** @class */ (function () {
    function CardModule() {
    }
    CardModule = __decorate([
        NgModule({
            declarations: [declarations$1],
            exports: [exportedModules$1],
            imports: [CommonModule]
        })
    ], CardModule);
    return CardModule;
}());

/**
 * @hidden
 */
var DRAWER_LINK_SELECTOR = '.k-drawer-link';
/**
 * @hidden
 */
var ACTIVE_NESTED_LINK_SELECTOR = ':focus:not(.k-state-disabled) .k-drawer-link';
/**
 * @hidden
 */
var nestedLink = function (element, selector) { return element.querySelector(selector); };

/**
 * @hidden
 */
var DrawerItemComponent = /** @class */ (function () {
    function DrawerItemComponent(drawer, element, renderer) {
        this.drawer = drawer;
        this.element = element;
        this.renderer = renderer;
    }
    Object.defineProperty(DrawerItemComponent.prototype, "disabledClass", {
        get: function () {
            return this.item.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerItemComponent.prototype, "selectedClass", {
        get: function () {
            return this.drawer.selectedIndices.indexOf(this.index) >= 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerItemComponent.prototype, "label", {
        get: function () {
            return this.item.text ? this.item.text : null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    DrawerItemComponent.prototype.ngAfterViewInit = function () {
        var link = nestedLink(this.element.nativeElement, DRAWER_LINK_SELECTOR);
        if (link) {
            this.renderer.removeAttribute(link, 'tabindex');
        }
    };
    Object.defineProperty(DrawerItemComponent.prototype, "iconClasses", {
        /**
         * @hidden
         */
        get: function () {
            var classes = [];
            if (this.item.icon) {
                classes.push("k-icon " + this.item.icon);
            }
            if (this.item.iconClass) {
                classes.push("" + this.item.iconClass);
            }
            return classes;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DrawerItemComponent.prototype, "item", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], DrawerItemComponent.prototype, "index", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], DrawerItemComponent.prototype, "itemTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DrawerItemComponent.prototype, "mini", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DrawerItemComponent.prototype, "expanded", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DrawerItemComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DrawerItemComponent.prototype, "cssClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DrawerItemComponent.prototype, "cssStyle", void 0);
    __decorate([
        HostBinding('attr.aria-disabled'),
        HostBinding('class.k-state-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DrawerItemComponent.prototype, "disabledClass", null);
    __decorate([
        HostBinding('attr.aria-selected'),
        HostBinding('class.k-state-selected'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DrawerItemComponent.prototype, "selectedClass", null);
    __decorate([
        HostBinding('attr.aria-label'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DrawerItemComponent.prototype, "label", null);
    DrawerItemComponent = __decorate([
        Component({
            selector: '[kendoDrawerItem]',
            template: "\n        <ng-template *ngIf=\"itemTemplate; else defaultTemplate\"\n            [ngTemplateOutlet]=\"itemTemplate\"\n            [ngTemplateOutletContext]=\"{ $implicit: item }\">\n        </ng-template>\n\n        <ng-template #defaultTemplate>\n            <ng-container *ngIf=\"expanded\">\n                <span [ngClass]=\"iconClasses\"></span>\n                <span class=\"k-item-text\">{{ item.text }}</span>\n            </ng-container>\n            <ng-container *ngIf=\"mini && !expanded\">\n                <span [ngClass]=\"iconClasses\"></span>\n            </ng-container>\n        </ng-template>\n    "
        }),
        __metadata("design:paramtypes", [DrawerService, ElementRef, Renderer2])
    ], DrawerItemComponent);
    return DrawerItemComponent;
}());

/**
 * @hidden
 */
var DRAWER_ITEM_INDEX = 'data-kendo-drawer-index';

/**
 * @hidden
 */
var DrawerListComponent = /** @class */ (function () {
    function DrawerListComponent(drawerService, renderer, ngZone, changeDetector, element) {
        this.drawerService = drawerService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.element = element;
        this.subscriptions = new Subscription();
    }
    DrawerListComponent.prototype.ngOnInit = function () {
        this.initialSelection();
        this.initDomEvents();
    };
    DrawerListComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    DrawerListComponent.prototype.initialSelection = function () {
        /* Differentiates a user selected item */
        if (this.drawerService.selectedIndices.length === 0) {
            this.drawerService.initSelection();
        }
    };
    DrawerListComponent.prototype.initDomEvents = function () {
        var _this = this;
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(function () {
            var nativeElement = _this.element.nativeElement;
            _this.subscriptions.add(_this.renderer.listen(nativeElement, 'click', _this.clickHandler.bind(_this)));
            _this.subscriptions.add(_this.renderer.listen(nativeElement, 'keydown', _this.keyDownHandler.bind(_this)));
        });
    };
    DrawerListComponent.prototype.clickHandler = function (e) {
        var _this = this;
        var itemIdx = this.getDrawerItemIndex(e.target);
        var item = this.items[itemIdx];
        if (!item) {
            return;
        }
        if (item.disabled) {
            e.preventDefault();
            return;
        }
        var args = {
            index: itemIdx,
            item: item,
            originalEvent: e
        };
        this.ngZone.run(function () {
            if (!_this.drawerService.emit('select', args)) {
                _this.drawerService.onSelect(itemIdx);
                _this.changeDetector.detectChanges();
            }
        });
    };
    DrawerListComponent.prototype.keyDownHandler = function (e) {
        var isEnterOrSpace = e.keyCode === Keys.Enter || e.keyCode === Keys.Space;
        if (!isEnterOrSpace) {
            return;
        }
        this.clickHandler(e);
        var link = nestedLink(this.element.nativeElement, ACTIVE_NESTED_LINK_SELECTOR);
        if (link) {
            link.click();
        }
        return false;
    };
    DrawerListComponent.prototype.getDrawerItemIndex = function (target) {
        var item = closestItem(target, DRAWER_ITEM_INDEX, this.element.nativeElement);
        if (item) {
            return itemIndex(item, DRAWER_ITEM_INDEX);
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], DrawerListComponent.prototype, "items", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], DrawerListComponent.prototype, "itemTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DrawerListComponent.prototype, "mini", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DrawerListComponent.prototype, "expanded", void 0);
    DrawerListComponent = __decorate([
        Component({
            selector: '[kendoDrawerList]',
            template: "\n        <ng-container *ngFor=\"let item of items; let idx = index\">\n            <li *ngIf=\"!item.separator\" kendoDrawerItem\n                class=\"k-drawer-item\"\n                [item]=\"item\"\n                [index]=\"idx\"\n                [mini]=\"mini\"\n                [expanded]=\"expanded\"\n                [itemTemplate]=\"itemTemplate\"\n                [attr." + DRAWER_ITEM_INDEX + "]=\"idx\"\n                [ngClass]=\"item.cssClass\"\n                [ngStyle]=\"item.cssStyle\"\n                tabindex=\"0\">\n            </li>\n\n            <li *ngIf=\"item.separator\"\n                class=\"k-drawer-item k-drawer-separator\"\n                [ngClass]=\"item.cssClass\"\n                [ngStyle]=\"item.cssStyle\">\n                &nbsp;\n            </li>\n        </ng-container>\n    "
        }),
        __metadata("design:paramtypes", [DrawerService,
            Renderer2,
            NgZone,
            ChangeDetectorRef,
            ElementRef])
    ], DrawerListComponent);
    return DrawerListComponent;
}());

var templateDirectives = [
    DrawerTemplateDirective,
    DrawerHeaderTemplateDirective,
    DrawerFooterTemplateDirective,
    DrawerItemTemplateDirective
];
var exportedModules$2 = [
    DrawerComponent,
    DrawerContainerComponent,
    DrawerContentComponent
].concat(templateDirectives);
var declarations$2 = [
    DrawerItemComponent,
    DrawerListComponent
].concat(exportedModules$2);
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Drawer component.
 */
var DrawerModule = /** @class */ (function () {
    function DrawerModule() {
    }
    DrawerModule = __decorate([
        NgModule({
            declarations: [declarations$2],
            exports: [exportedModules$2],
            imports: [CommonModule]
        })
    ], DrawerModule);
    return DrawerModule;
}());

var exportedModules$3 = [
    ExpansionPanelComponent,
    ExpansionPanelTitleDirective
];
var declarations$3 = exportedModules$3.slice();
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the ExpansionPanel component.
 */
var ExpansionPanelModule = /** @class */ (function () {
    function ExpansionPanelModule() {
    }
    ExpansionPanelModule = __decorate([
        NgModule({
            declarations: [declarations$3],
            exports: [exportedModules$3],
            imports: [CommonModule, EventsModule]
        })
    ], ExpansionPanelModule);
    return ExpansionPanelModule;
}());

var exportedModules$4 = [
    PanelBarComponent,
    PanelBarItemComponent,
    PanelBarContentDirective,
    PanelBarItemTemplateDirective,
    PanelBarItemTitleDirective
];
var declarations$4 = exportedModules$4.slice();
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the PanelBar component.
 *
 * The module registers:
 * - `PanelBarComponent`&mdash;The `PanelBar` component class.
 * - `PanelBarItemComponent`&mdash;The `PanelBarItem` component class.
 * - `PanelBarContentComponent`&mdash;The `PanelBarContent` component class.
 * - `PanelBarItemTemplateDirective&mdash;The `PanelBarItemTemplate` directive.
 * - `PanelBarItemTitleDirective&mdash;The `PanelBarItemTitle` directive.
 */
var PanelBarModule = /** @class */ (function () {
    function PanelBarModule() {
    }
    PanelBarModule = __decorate([
        NgModule({
            declarations: [declarations$4],
            exports: [exportedModules$4],
            imports: [CommonModule]
        })
    ], PanelBarModule);
    return PanelBarModule;
}());

var exportedModules$5 = [
    SplitterComponent,
    SplitterPaneComponent
];
var declarations$5 = [
    SplitterBarComponent
].concat(exportedModules$5);
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Splitter component.
 *
 * The module registers:
 * - `SplitterComponent`&mdash;The `Splitter` component class.
 * - `SplitterPaneComponent`&mdash;The `SplitterPane` component class.
 */
var SplitterModule = /** @class */ (function () {
    function SplitterModule() {
    }
    SplitterModule = __decorate([
        NgModule({
            declarations: [declarations$5],
            exports: [exportedModules$5],
            imports: [
                CommonModule,
                DraggableModule
            ]
        })
    ], SplitterModule);
    return SplitterModule;
}());

/**
 * @hidden
 */
var StepperStepComponent = /** @class */ (function () {
    function StepperStepComponent(service, localization, ngZone) {
        var _this = this;
        this.service = service;
        this.localization = localization;
        this.ngZone = ngZone;
        this.isStepValid = undefined;
        this.shouldCheckValidity = undefined;
        validatePackage(packageMetadata);
        this.subs = this.service.focusedStepChange.subscribe(function () {
            _this.onFocusedStepChange();
        });
        this.subs.add(this.service.triggerValidation.subscribe(function () {
            _this.handleValidityChecks();
        }));
    }
    Object.defineProperty(StepperStepComponent.prototype, "errorStepClass", {
        get: function () {
            if (isPresent(this.isStepValid)) {
                return !this.isStepValid;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperStepComponent.prototype, "successStepClass", {
        get: function () {
            if (isPresent(this.isStepValid)) {
                return this.isStepValid;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    StepperStepComponent.prototype.ngOnInit = function () {
        this.handleValidityChecks();
    };
    StepperStepComponent.prototype.ngOnChanges = function (changes) {
        if (changes.current && !changes.current.firstChange) {
            this.handleValidityChecks();
        }
    };
    StepperStepComponent.prototype.ngOnDestroy = function () {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    };
    StepperStepComponent.prototype.onFocusedStepChange = function () {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            if (_this.index === _this.service.focusedStep) {
                _this.stepLink.nativeElement.focus();
            }
        });
    };
    StepperStepComponent.prototype.onFocus = function () {
        this.service.focus(this.index);
    };
    Object.defineProperty(StepperStepComponent.prototype, "tabIndexAttr", {
        get: function () {
            var active = this.service.focusedStep || this.service.currentStep;
            return this.index === active ? 0 : -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperStepComponent.prototype, "indicatorIconClasses", {
        get: function () {
            if (this.step.icon) {
                return "k-icon k-i-" + this.step.icon;
            }
            if (this.step.iconClass) {
                return "" + this.step.iconClass;
            }
            if (this.shouldCheckValidity) {
                return this.validationIconClasses;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperStepComponent.prototype, "showIndicatorIcon", {
        get: function () {
            if (this.shouldCheckValidity) {
                return true;
            }
            if (this.step.icon || this.step.iconClass) {
                return true;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperStepComponent.prototype, "showLabelIcon", {
        get: function () {
            if (this.shouldCheckValidity) {
                if (this.type === 'label') {
                    return true;
                }
                if (this.step.icon || this.step.iconClass) {
                    return true;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperStepComponent.prototype, "showLabelText", {
        get: function () {
            return this.type === 'label' || this.type === 'full';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperStepComponent.prototype, "validationIconClasses", {
        get: function () {
            if (this.isStepValid) {
                return this.successIcon ? "" + this.successIcon : 'k-icon k-i-check';
            }
            else {
                return this.errorIcon ? "" + this.errorIcon : 'k-icon k-i-warning';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperStepComponent.prototype, "indicatorText", {
        get: function () {
            var text = this.step.text;
            return text ? text : this.index + 1;
        },
        enumerable: true,
        configurable: true
    });
    StepperStepComponent.prototype.updateStepValidity = function () {
        if (typeof this.step.isValid === 'boolean') {
            return this.step.isValid;
        }
        if (typeof this.step.isValid === 'function') {
            return this.step.isValid(this.index);
        }
        return undefined;
    };
    Object.defineProperty(StepperStepComponent.prototype, "showIndicator", {
        get: function () {
            return this.type === 'indicator' || this.type === 'full';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperStepComponent.prototype, "showLabel", {
        get: function () {
            if (this.type === 'label' || this.type === 'full') {
                return true;
            }
            return this.step.optional;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperStepComponent.prototype, "optionalText", {
        get: function () {
            return this.localization.get('optional');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperStepComponent.prototype, "transitionDuration", {
        get: function () {
            return this.service.owner.animationDuration;
        },
        enumerable: true,
        configurable: true
    });
    StepperStepComponent.prototype._shouldCheckValidity = function () {
        if (isPresent(this.step.validate)) {
            if (typeof this.step.validate === 'boolean') {
                return this.step.validate;
            }
            if (typeof this.step.validate === 'function') {
                return this.step.validate(this.index);
            }
        }
        return isPresent(this.step.isValid) && this.index < this.current;
    };
    StepperStepComponent.prototype.handleValidityChecks = function () {
        this.isStepValid = undefined;
        this.shouldCheckValidity = this._shouldCheckValidity();
        if (this.shouldCheckValidity) {
            this.isStepValid = this.updateStepValidity();
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], StepperStepComponent.prototype, "step", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], StepperStepComponent.prototype, "index", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], StepperStepComponent.prototype, "current", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperStepComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperStepComponent.prototype, "successIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperStepComponent.prototype, "errorIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], StepperStepComponent.prototype, "indicatorTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], StepperStepComponent.prototype, "labelTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], StepperStepComponent.prototype, "stepTemplate", void 0);
    __decorate([
        ViewChild('stepLink', { static: true }),
        __metadata("design:type", ElementRef)
    ], StepperStepComponent.prototype, "stepLink", void 0);
    __decorate([
        HostBinding('class.k-step-error'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], StepperStepComponent.prototype, "errorStepClass", null);
    __decorate([
        HostBinding('class.k-step-success'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], StepperStepComponent.prototype, "successStepClass", null);
    StepperStepComponent = __decorate([
        Component({
            selector: '[kendoStepperStep]',
            template: "\n        <a href='#' class='k-step-link' #stepLink\n            [attr.tabindex]='tabIndexAttr'\n            [attr.title]='step.label'\n            [attr.aria-disabled]='step.disabled'\n            [attr.aria-current]='index === current ? \"step\" : null'\n            (focus)='onFocus()'\n        >\n            <ng-template *ngIf='stepTemplate'\n                [ngTemplateOutlet]='stepTemplate'\n                [ngTemplateOutletContext]='{ $implicit: step, index: index }'>\n            </ng-template>\n\n            <ng-container *ngIf='!stepTemplate'>\n                <span *ngIf='showIndicator'\n                    class='k-step-indicator'\n                    aria-hidden='true'\n                    [style.transition-duration.ms]='transitionDuration'\n                >\n                    <ng-template *ngIf='indicatorTemplate'\n                        [ngTemplateOutlet]='indicatorTemplate'\n                        [ngTemplateOutletContext]='{ $implicit: step, index: index }'>\n                    </ng-template>\n\n                    <ng-container *ngIf='!indicatorTemplate'>\n                        <span *ngIf='showIndicatorIcon' class='k-step-indicator-icon' [ngClass]='indicatorIconClasses'></span>\n                        <span class='k-step-indicator-text' *ngIf='!showIndicatorIcon'>{{ indicatorText }}</span>\n                    </ng-container>\n                </span>\n\n                <span class='k-step-label' *ngIf='showLabel'>\n                    <ng-template *ngIf='labelTemplate'\n                        [ngTemplateOutlet]='labelTemplate'\n                        [ngTemplateOutletContext]='{ $implicit: step, index: index }'>\n                    </ng-template>\n\n                    <ng-container *ngIf='!labelTemplate'>\n                        <span class='k-step-text' *ngIf='showLabelText'>{{ step.label }}</span>\n                        <span [ngClass]='validationIconClasses' *ngIf='showLabelIcon' aria-hidden='true'></span>\n                        <span class='k-step-label-optional' *ngIf='step.optional'>({{optionalText}})</span>\n                    </ng-container>\n                </span>\n            </ng-container>\n        </a>\n    "
        }),
        __metadata("design:paramtypes", [StepperService,
            LocalizationService,
            NgZone])
    ], StepperStepComponent);
    return StepperStepComponent;
}());

/**
 * @hidden
 */
var STEPPER_STEP_INDEX = 'data-kendo-stepper-index';

/**
 * @hidden
 */
var StepperListComponent = /** @class */ (function () {
    function StepperListComponent(renderer, ngZone, service, element) {
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.service = service;
        this.element = element;
    }
    StepperListComponent.prototype.ngOnInit = function () {
        this.initDomEvents();
    };
    StepperListComponent.prototype.ngOnDestroy = function () {
        if (this.domSubs) {
            this.domSubs();
        }
    };
    Object.defineProperty(StepperListComponent.prototype, "maxStepWidth", {
        get: function () {
            return this.maxStepDimension('width');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepperListComponent.prototype, "maxStepHeight", {
        get: function () {
            return this.maxStepDimension('height');
        },
        enumerable: true,
        configurable: true
    });
    StepperListComponent.prototype.maxStepDimension = function (dimension) {
        if (dimension === 'width' && this.orientation === 'vertical') {
            return null;
        }
        if (dimension === 'height' && this.orientation === 'horizontal') {
            return null;
        }
        return 100 / this.steps.length;
    };
    StepperListComponent.prototype.initDomEvents = function () {
        var _this = this;
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(function () {
            var nativeElement = _this.element.nativeElement;
            var clickSubscription = _this.renderer.listen(nativeElement, 'click', _this.clickHandler.bind(_this));
            var keydownSubscription = _this.renderer.listen(nativeElement, 'keydown', function (e) {
                if (hasClass(e.target, 'k-step-link')) {
                    _this.service.keydown(e);
                }
            });
            _this.domSubs = function () {
                clickSubscription();
                keydownSubscription();
            };
        });
    };
    StepperListComponent.prototype.clickHandler = function (e) {
        e.preventDefault();
        var stepIdx = this.getStepIndex(e.target);
        var step = this.steps[stepIdx];
        if (!step || step.disabled) {
            return;
        }
        if (stepIdx === this.currentStep) {
            this.service.focus(stepIdx);
            return;
        }
        if (this.linear && this.service.isPrevOrNextStep(stepIdx) === false) {
            return;
        }
        this.service.onActivate(stepIdx, e);
    };
    StepperListComponent.prototype.getStepIndex = function (target) {
        var step = closestItem(target, STEPPER_STEP_INDEX, this.element.nativeElement);
        if (step) {
            return itemIndex(step, STEPPER_STEP_INDEX);
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], StepperListComponent.prototype, "linear", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperListComponent.prototype, "stepType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperListComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], StepperListComponent.prototype, "currentStep", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], StepperListComponent.prototype, "steps", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperListComponent.prototype, "successIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StepperListComponent.prototype, "errorIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], StepperListComponent.prototype, "indicatorTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], StepperListComponent.prototype, "labelTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], StepperListComponent.prototype, "stepTemplate", void 0);
    StepperListComponent = __decorate([
        Component({
            selector: '[kendoStepperList]',
            template: "\n        <ng-container *ngFor='let step of steps; let idx = index'>\n            <li kendoStepperStep\n                [attr." + STEPPER_STEP_INDEX + "]='idx'\n                [type]='stepType'\n                [step]='step'\n                [index]='idx'\n                [current]='currentStep'\n                [successIcon]='successIcon'\n                [errorIcon]='errorIcon'\n                [indicatorTemplate]='indicatorTemplate'\n                [labelTemplate]='labelTemplate'\n                [stepTemplate]='stepTemplate'\n                class='k-step'\n                [class.k-step-first]='idx === 0'\n                [class.k-step-last]='idx === steps.length - 1'\n                [class.k-step-done]='idx < currentStep'\n                [class.k-step-current]='idx === currentStep'\n                [class.k-step-optional]='step.optional'\n                [class.k-step-disabled]='step.disabled'\n                [ngClass]='step.cssClass'\n                [ngStyle]='step.cssStyle'\n                [style.max-width.%] = 'maxStepWidth'\n                [style.max-height.%] = 'maxStepHeight'\n            >\n            </li>\n        </ng-container>\n    "
        }),
        __metadata("design:paramtypes", [Renderer2,
            NgZone,
            StepperService,
            ElementRef])
    ], StepperListComponent);
    return StepperListComponent;
}());

var templateDirectives$1 = [
    StepperStepTemplateDirective,
    StepperLabelTemplateDirective,
    StepperIndicatorTemplateDirective
];
var exportedModules$6 = [
    StepperComponent,
    StepperCustomMessagesComponent
].concat(templateDirectives$1);
var declarations$6 = [
    StepperStepComponent,
    StepperListComponent,
    LocalizedStepperMessagesDirective
].concat(exportedModules$6);
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Stepper component.
 */
var StepperModule = /** @class */ (function () {
    function StepperModule() {
    }
    StepperModule = __decorate([
        NgModule({
            declarations: [declarations$6],
            exports: [exportedModules$6],
            imports: [CommonModule, ProgressBarModule]
        })
    ], StepperModule);
    return StepperModule;
}());

/**
 * @hidden
 */
var TabComponent = /** @class */ (function () {
    function TabComponent(localization, tabstripService) {
        this.localization = localization;
        this.tabstripService = tabstripService;
        this.hostClasses = true;
    }
    Object.defineProperty(TabComponent.prototype, "activeClass", {
        get: function () {
            return this.tab.selected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabComponent.prototype, "disabledClass", {
        get: function () {
            return this.tab.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabComponent.prototype, "focusedClass", {
        get: function () {
            return this.tab.focused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabComponent.prototype, "tabIndex", {
        get: function () {
            return this.tab.selected || this.tab.focused ? 0 : -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabComponent.prototype, "tabClosable", {
        get: function () {
            if (this.tab.closable !== undefined) {
                return this.tab.closable;
            }
            return this.tabStripClosable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabComponent.prototype, "closeButtonClasses", {
        get: function () {
            if (isPresent(this.tab.closeIcon)) {
                return this.tab.closeIcon;
            }
            return this.tabStripCloseIcon;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabComponent.prototype, "closeButtonTitle", {
        get: function () {
            return this.localization.get('closeTitle');
        },
        enumerable: true,
        configurable: true
    });
    TabComponent.prototype.closeTab = function (index) {
        this.tabstripService.onTabClose(this.tab, index);
    };
    __decorate([
        Input(),
        __metadata("design:type", TabStripTabComponent)
    ], TabComponent.prototype, "tab", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TabComponent.prototype, "index", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TabComponent.prototype, "tabStripClosable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TabComponent.prototype, "tabStripCloseIcon", void 0);
    __decorate([
        HostBinding('class.k-item'),
        HostBinding('class.k-state-default'),
        __metadata("design:type", Boolean)
    ], TabComponent.prototype, "hostClasses", void 0);
    __decorate([
        HostBinding('attr.aria-selected]'),
        HostBinding('class.k-state-active'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TabComponent.prototype, "activeClass", null);
    __decorate([
        HostBinding('attr.aria-disabled]'),
        HostBinding('class.k-state-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TabComponent.prototype, "disabledClass", null);
    __decorate([
        HostBinding('class.k-state-focused'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], TabComponent.prototype, "focusedClass", null);
    __decorate([
        HostBinding('attr.tabindex'),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [])
    ], TabComponent.prototype, "tabIndex", null);
    TabComponent = __decorate([
        Component({
            selector: '[kendoTabStripTab]',
            template: "\n        <span class=\"k-link\" *ngIf=\"!tab.tabTitle\">{{ tab.title }}</span>\n        <span class=\"k-link\" *ngIf=\"tab.tabTitle\">\n            <ng-template [ngTemplateOutlet]=\"tab.tabTitle?.templateRef\">\n            </ng-template>\n        </span>\n        <span class=\"k-remove-tab k-button k-icon-button k-flat\" *ngIf=\"tabClosable\"\n            role=\"button\"\n            [title]=\"closeButtonTitle\"\n            [attr.aria-label]=\"closeButtonTitle\"\n            (click)=\"closeTab(index)\"\n        >\n            <span [ngClass]=\"closeButtonClasses\"></span>\n        </span>\n    "
        }),
        __metadata("design:paramtypes", [LocalizationService,
            TabStripService])
    ], TabComponent);
    return TabComponent;
}());

var exportedModules$7 = [
    TabStripComponent,
    TabStripTabComponent,
    TabContentDirective,
    TabTitleDirective,
    TabComponent,
    TabStripCustomMessagesComponent,
    LocalizedTabStripMessagesDirective
];
var declarations$7 = exportedModules$7.concat([
    TabStripScrollableButtonComponent
]);
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TabStrip component.
 *
 * The module registers:
 * - `TabStripComponent`&mdash;The `TabStrip` component class.
 * - `TabStripTabComponent`&mdash;The `TabStripTab` component class.
 * - `TabContentDirective`&mdash;The tab content directive used on the `<ng-template>` tag.
 * - `TabTitleDirective`&mdash;The tab title directive used on the `<ng-template>` tag.
 */
var TabStripModule = /** @class */ (function () {
    function TabStripModule() {
    }
    TabStripModule = __decorate([
        NgModule({
            declarations: [declarations$7],
            exports: [exportedModules$7],
            imports: [CommonModule, ResizeSensorModule]
        })
    ], TabStripModule);
    return TabStripModule;
}());

/**
 * @hidden
 */
var TileLayoutResizeHandleDirective = /** @class */ (function () {
    function TileLayoutResizeHandleDirective(el, renderer) {
        this.el = el;
        this.renderer = renderer;
    }
    TileLayoutResizeHandleDirective.prototype.ngOnInit = function () {
        this.sizeHandle();
    };
    TileLayoutResizeHandleDirective.prototype.setHorizontalPosition = function (element) {
        this.renderer.setStyle(element, this.rtl ? 'left' : 'right', -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapX + 'px');
    };
    TileLayoutResizeHandleDirective.prototype.setBottom = function (element) {
        this.renderer.setStyle(element, 'bottom', -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapY + 'px');
    };
    TileLayoutResizeHandleDirective.prototype.sizeHandle = function () {
        var element = this.el.nativeElement;
        var handleWidth = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width ?
            RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width + "px" : '100%';
        var handleHeight = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height ?
            RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height + "px" : '100%';
        this.renderer.setStyle(element, 'width', handleWidth);
        this.renderer.setStyle(element, 'height', handleHeight);
        if (this.resizeDirection === 'ew') {
            this.setHorizontalPosition(element);
        }
        else if (this.resizeDirection === 'ns') {
            this.setBottom(element);
        }
        else {
            this.setHorizontalPosition(element);
            this.setBottom(element);
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TileLayoutResizeHandleDirective.prototype, "resizeDirection", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TileLayoutResizeHandleDirective.prototype, "rtl", void 0);
    TileLayoutResizeHandleDirective = __decorate([
        Directive({
            selector: '[kendoTileLayoutResizeHandle]'
        }),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2])
    ], TileLayoutResizeHandleDirective);
    return TileLayoutResizeHandleDirective;
}());

var exportedModules$8 = [
    TileLayoutComponent,
    TileLayoutItemComponent,
    TileLayoutItemHeaderComponent,
    TileLayoutItemBodyComponent,
    TileLayoutResizeHandleDirective
];
var declarations$8 = exportedModules$8.slice();
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TileLayout component.
 *
 * The module registers:
 * - `TileLayoutComponent`&mdash;The `TileLayoutComponent` component class.
 * - `TileLayoutItemComponent`&mdash;The `TileLayoutItemComponent` component class.
 * - `TileLayoutItemHeaderComponent`&mdash;The `TileLayoutItemHeaderComponent` component class.
 * - `TileLayoutItemBodyComponent`&mdash;The `TileLayoutItemBodyComponent` component class.
 */
var TileLayoutModule = /** @class */ (function () {
    function TileLayoutModule() {
    }
    TileLayoutModule = __decorate([
        NgModule({
            declarations: [declarations$8],
            exports: [exportedModules$8],
            imports: [CommonModule]
        })
    ], TileLayoutModule);
    return TileLayoutModule;
}());

/**
 * @hidden
 */
var VERTICAL_SUFFIX = {
    top: 'start',
    middle: 'center',
    bottom: 'end',
    stretch: 'stretch'
};
/**
 * @hidden
 */
var JUSTIFY_PREFIX = "k-justify-content";
/**
 * @hidden
 */
var GRID_JUSTIFY_PREFIX = "k-justify-items";
/**
 * @hidden
 */
var ALIGN_PREFIX = "k-align-items";
/**
 * @hidden
 */
var normalizeGap = function (gap) {
    if (typeof gap === 'number' || typeof gap === 'string') {
        return { cols: gap, rows: gap };
    }
    else {
        var parsedGap = {};
        parsedGap.rows = gap.rows ? gap.rows : 0;
        parsedGap.cols = gap.cols ? gap.cols : 0;
        return parsedGap;
    }
};
/**
 * @hidden
 */
var generateGapStyle = function (gap) {
    if (gap.rows === gap.cols) {
        return typeof gap.rows === 'number' ? gap.rows + "px" : gap.rows;
    }
    else {
        var rowStyle = "" + (typeof gap.rows === 'number' ? gap.rows + 'px' : gap.rows);
        var colStyle = "" + (typeof gap.cols === 'number' ? gap.cols + 'px' : gap.cols);
        return rowStyle + " " + colStyle;
    }
};
/**
 * @hidden
 */
var generateGridStyle = function (items, itemType) {
    var styling = [];
    items.forEach(function (item) {
        if (typeof item === 'number') {
            styling.push(item + "px");
        }
        else if (typeof item === 'string') {
            styling.push(item);
        }
        else {
            if (itemType === 'rows') {
                var rowHeight = item.height;
                if (rowHeight) {
                    styling.push(typeof rowHeight === 'number' ? rowHeight + "px" : rowHeight);
                }
                else {
                    styling.push('0px');
                }
            }
            else {
                var colWidth = item.width;
                if (colWidth) {
                    styling.push(typeof colWidth === 'number' ? colWidth + "px" : colWidth);
                }
                else {
                    styling.push('0px');
                }
            }
        }
    });
    return styling;
};
/**
 * @hidden
 */
var validateGridLayoutRowsCols = function (arr) {
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var el = arr_1[_i];
        var isNum = typeof el === 'number';
        var isStr = typeof el === 'string';
        var isObject = typeof el === 'object' && el !== null;
        if (!isNum && !isStr && !isObject) {
            return false;
        }
    }
    return true;
};

/**
 * Represents the [Kendo UI StackLayout component for Angular]({% slug overview_stacklayout %}).
 */
var StackLayoutComponent = /** @class */ (function () {
    function StackLayoutComponent(renderer, element, localization) {
        this.renderer = renderer;
        this.element = element;
        this.localization = localization;
        this.hostClass = true;
        /**
         * Specifies the gap between the inner StackLayout elements. The default value is `0`
         * ([see example]({% slug layout_stacklayout %}#toc-gaps)).
         */
        this.gap = 0;
        /**
         * Specifies the orientation of the StackLayout
         * ([see example]({% slug layout_stacklayout %}#toc-orientation)).
         *
         * The possible values are:
         * (Default) `horizontal`
         * `vertical`
         */
        this.orientation = 'horizontal';
        this._align = {
            horizontal: 'stretch',
            vertical: 'stretch'
        };
        validatePackage(packageMetadata);
    }
    Object.defineProperty(StackLayoutComponent.prototype, "horizontalClass", {
        get: function () {
            return this.orientation === 'horizontal';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StackLayoutComponent.prototype, "verticalClass", {
        get: function () {
            return this.orientation === 'vertical';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StackLayoutComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StackLayoutComponent.prototype, "align", {
        get: function () {
            return this._align;
        },
        /**
         * Specifies the horizontal and vertical alignment of the inner StackLayout elements
         * ([see example]({% slug layout_stacklayout %}#toc-alignment)).
         */
        set: function (align) {
            this._align = Object.assign({}, this._align, align);
            this.handleAlignClasses();
        },
        enumerable: true,
        configurable: true
    });
    StackLayoutComponent.prototype.ngAfterViewInit = function () {
        this.handleAlignClasses();
        this.setGap();
    };
    StackLayoutComponent.prototype.ngOnChanges = function (changes) {
        if (isChanged('gap', changes)) {
            this.setGap();
        }
        if (isChanged('orientation', changes)) {
            this.handleAlignClasses();
        }
    };
    StackLayoutComponent.prototype.handleAlignClasses = function () {
        var elem = this.element.nativeElement;
        if (isPresent(this.justifyClass)) {
            this.renderer.removeClass(elem, this.justifyClass);
        }
        if (isPresent(this.alignClass)) {
            this.renderer.removeClass(elem, this.alignClass);
        }
        if (this.orientation === 'horizontal') {
            this.justifyClass = JUSTIFY_PREFIX + "-" + this.align.horizontal;
            this.alignClass = ALIGN_PREFIX + "-" + VERTICAL_SUFFIX[this.align.vertical];
        }
        else {
            this.justifyClass = JUSTIFY_PREFIX + "-" + VERTICAL_SUFFIX[this.align.vertical];
            this.alignClass = ALIGN_PREFIX + "-" + this.align.horizontal;
        }
        this.renderer.addClass(elem, this.justifyClass);
        this.renderer.addClass(elem, this.alignClass);
    };
    StackLayoutComponent.prototype.setGap = function () {
        var parsedGap = isNumber(this.gap) ? this.gap + "px" : this.gap;
        this.renderer.setStyle(this.element.nativeElement, 'gap', parsedGap);
    };
    Object.defineProperty(StackLayoutComponent.prototype, "direction", {
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        HostBinding('class.k-stack-layout'),
        __metadata("design:type", Boolean)
    ], StackLayoutComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('class.k-hstack'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], StackLayoutComponent.prototype, "horizontalClass", null);
    __decorate([
        HostBinding('class.k-vstack'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], StackLayoutComponent.prototype, "verticalClass", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], StackLayoutComponent.prototype, "dir", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], StackLayoutComponent.prototype, "align", null);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], StackLayoutComponent.prototype, "gap", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StackLayoutComponent.prototype, "orientation", void 0);
    StackLayoutComponent = __decorate([
        Component({
            exportAs: 'kendoStackLayout',
            selector: 'kendo-stacklayout',
            providers: [
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.stacklayout'
                }
            ],
            template: "\n        <ng-content></ng-content>\n    "
        }),
        __metadata("design:paramtypes", [Renderer2,
            ElementRef,
            LocalizationService])
    ], StackLayoutComponent);
    return StackLayoutComponent;
}());

var exportedModules$9 = [
    StackLayoutComponent
];
var declarations$9 = exportedModules$9.slice();
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the StackLayout component.
 */
var StackLayoutModule = /** @class */ (function () {
    function StackLayoutModule() {
    }
    StackLayoutModule = __decorate([
        NgModule({
            declarations: [declarations$9],
            exports: [exportedModules$9],
            imports: [CommonModule]
        })
    ], StackLayoutModule);
    return StackLayoutModule;
}());

/**
 * Represents the [Kendo UI GridLayout component for Angular]({% slug overview_gridlayout %}).
 */
var GridLayoutComponent = /** @class */ (function () {
    function GridLayoutComponent(renderer, element, localization) {
        this.renderer = renderer;
        this.element = element;
        this.localization = localization;
        this.hostClass = true;
        /**
         * Specifies the gaps between the elements. The default value is `0`
         * ([see example]({% slug layout_gridlayout %}#toc-gaps)).
         */
        this.gap = 0;
        this._align = {
            horizontal: 'stretch',
            vertical: 'stretch'
        };
        validatePackage(packageMetadata);
    }
    Object.defineProperty(GridLayoutComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GridLayoutComponent.prototype, "align", {
        get: function () {
            return this._align;
        },
        /**
         * Specifies the horizontal and vertical alignment of the inner GridLayout elements
         * ([see example]({% slug layout_gridlayout %}#toc-alignment)).
         */
        set: function (align) {
            this._align = Object.assign({}, this._align, align);
            this.handleAlignClasses();
        },
        enumerable: true,
        configurable: true
    });
    GridLayoutComponent.prototype.ngAfterViewInit = function () {
        this.handleAlignClasses();
        this.handleGridTemplateStyling('rows');
        this.handleGridTemplateStyling('cols');
        this.setGap();
    };
    GridLayoutComponent.prototype.ngOnChanges = function (changes) {
        if (isChanged('gap', changes)) {
            this.setGap();
        }
        if (isChanged('rows', changes)) {
            this.handleGridTemplateStyling('rows');
        }
        if (isChanged('cols', changes)) {
            this.handleGridTemplateStyling('cols');
        }
    };
    GridLayoutComponent.prototype.handleAlignClasses = function () {
        var elem = this.element.nativeElement;
        if (isPresent(this.justifyClass)) {
            this.renderer.removeClass(elem, this.justifyClass);
        }
        if (isPresent(this.alignClass)) {
            this.renderer.removeClass(elem, this.alignClass);
        }
        this.justifyClass = GRID_JUSTIFY_PREFIX + "-" + this.align.horizontal;
        this.alignClass = ALIGN_PREFIX + "-" + VERTICAL_SUFFIX[this.align.vertical];
        this.renderer.addClass(elem, this.justifyClass);
        this.renderer.addClass(elem, this.alignClass);
    };
    GridLayoutComponent.prototype.setGap = function () {
        var parsedGap = normalizeGap(this.gap);
        var gapStyle = generateGapStyle(parsedGap);
        this.renderer.setStyle(this.element.nativeElement, 'gap', gapStyle);
    };
    GridLayoutComponent.prototype.handleGridTemplateStyling = function (type) {
        if (!isPresent(this[type])) {
            return;
        }
        var isValid = validateGridLayoutRowsCols(this[type]);
        if (!isValid && isDevMode()) {
            var valueType = type === 'rows' ? 'GridLayoutRowSize' : 'GridLayoutColSize';
            throw new Error("The provided " + type + " value contains invalid elements. The array supports values of type number, string or " + valueType + ".");
        }
        var gridTemplateStyle = type === 'rows' ? 'grid-template-rows' : 'grid-template-columns';
        var gridStyle = generateGridStyle(this[type], type);
        this.renderer.setStyle(this.element.nativeElement, gridTemplateStyle, gridStyle.join(' '));
    };
    Object.defineProperty(GridLayoutComponent.prototype, "direction", {
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        HostBinding('class.k-grid-layout'),
        __metadata("design:type", Boolean)
    ], GridLayoutComponent.prototype, "hostClass", void 0);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], GridLayoutComponent.prototype, "dir", null);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GridLayoutComponent.prototype, "rows", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GridLayoutComponent.prototype, "cols", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridLayoutComponent.prototype, "gap", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], GridLayoutComponent.prototype, "align", null);
    GridLayoutComponent = __decorate([
        Component({
            exportAs: 'kendoGridLayout',
            selector: 'kendo-gridlayout',
            providers: [
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.gridlayout'
                }
            ],
            template: "\n        <ng-content></ng-content>\n    "
        }),
        __metadata("design:paramtypes", [Renderer2,
            ElementRef,
            LocalizationService])
    ], GridLayoutComponent);
    return GridLayoutComponent;
}());

var GridLayoutItemComponent = /** @class */ (function () {
    function GridLayoutItemComponent(renderer, element) {
        this.renderer = renderer;
        this.element = element;
    }
    GridLayoutItemComponent.prototype.ngOnInit = function () {
        this.setItemStyle();
    };
    GridLayoutItemComponent.prototype.ngOnChanges = function () {
        this.setItemStyle();
    };
    GridLayoutItemComponent.prototype.setItemStyle = function () {
        var row = this.row || 'auto';
        var col = this.col || 'auto';
        var rowSpan = this.rowSpan ? "span " + this.rowSpan : 'auto';
        var colSpan = this.colSpan ? "span " + this.colSpan : 'auto';
        var gridAreaStyle = row + " / " + col + " / " + rowSpan + " / " + colSpan;
        this.renderer.setStyle(this.element.nativeElement, 'grid-area', gridAreaStyle);
    };
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GridLayoutItemComponent.prototype, "row", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GridLayoutItemComponent.prototype, "col", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GridLayoutItemComponent.prototype, "rowSpan", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GridLayoutItemComponent.prototype, "colSpan", void 0);
    GridLayoutItemComponent = __decorate([
        Component({
            selector: 'kendo-gridlayout-item',
            template: "\n        <ng-content></ng-content>\n    "
        }),
        __metadata("design:paramtypes", [Renderer2,
            ElementRef])
    ], GridLayoutItemComponent);
    return GridLayoutItemComponent;
}());

var exportedModules$a = [
    GridLayoutComponent,
    GridLayoutItemComponent
];
var declarations$a = exportedModules$a.slice();
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the GridLayout component.
 */
var GridLayoutModule = /** @class */ (function () {
    function GridLayoutModule() {
    }
    GridLayoutModule = __decorate([
        NgModule({
            declarations: [declarations$a],
            exports: [exportedModules$a],
            imports: [CommonModule]
        })
    ], GridLayoutModule);
    return GridLayoutModule;
}());

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Layout components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Layout module
 * import { LayoutModule } from '@progress/kendo-angular-layout';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, LayoutModule], // import Layout module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var LayoutModule = /** @class */ (function () {
    function LayoutModule() {
    }
    LayoutModule = __decorate([
        NgModule({
            exports: [
                AvatarModule,
                CardModule,
                DrawerModule,
                PanelBarModule,
                ExpansionPanelModule,
                SplitterModule,
                StepperModule,
                TabStripModule,
                TileLayoutModule,
                StackLayoutModule,
                GridLayoutModule
            ]
        })
    ], LayoutModule);
    return LayoutModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { PreventableEvent$1 as PreventableEvent, DrawerService, DrawerItemComponent, DrawerListComponent, DRAWER_ITEM_INDEX, PanelBarService, SplitterBarComponent, SplitterService, StepperListComponent, StepperMessages, STEPPER_STEP_INDEX, StepperStepComponent, StepperService, TabStripMessages, TabComponent, TabStripScrollableButtonComponent, ScrollService, TabStripService, TileLayoutDraggingService, PreventableEvent$2 as PreventableEvent$1, TileLayoutResizeHandleDirective, PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, PanelBarExpandMode, SplitterComponent, SplitterPaneComponent, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, LocalizedTabStripMessagesDirective, TabStripCustomMessagesComponent, DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerSelectEvent, StepperComponent, StepperActivateEvent, StepperCustomMessagesComponent, LocalizedStepperMessagesDirective, AvatarComponent, CardComponent, CardHeaderComponent, CardBodyComponent, CardFooterComponent, CardActionsComponent, CardSeparatorDirective, CardTitleDirective, CardSubtitleDirective, CardMediaDirective, CardAction, ExpansionPanelComponent, ExpansionPanelTitleDirective, ExpansionPanelActionEvent, TileLayoutComponent, TileLayoutItemComponent, TileLayoutItemBodyComponent, TileLayoutItemHeaderComponent, TileLayoutReorderEvent, TileLayoutResizeEvent, AvatarModule, CardModule, DrawerModule, LayoutModule, PanelBarModule, SplitterModule, StepperModule, TabStripModule, ExpansionPanelModule, TileLayoutModule, StackLayoutModule, GridLayoutModule, StackLayoutComponent, GridLayoutComponent, GridLayoutItemComponent, PanelBarCollapseEvent, PanelBarExpandEvent, PanelBarSelectEvent, TabCloseEvent, SelectEvent, DrawerTemplateDirective, DrawerItemTemplateDirective, DrawerHeaderTemplateDirective, DrawerFooterTemplateDirective, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective };
