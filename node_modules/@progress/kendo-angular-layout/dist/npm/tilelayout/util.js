/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var kendo_angular_common_1 = require("@progress/kendo-angular-common");
var util_1 = require("../common/util");
/**
 * @hidden
 */
exports.normalizeValue = function (value) {
    return value ? +value : undefined;
};
/**
 * @hidden
 */
exports.isRowItemPresent = function (items) {
    return items.some(function (item) { return util_1.isPresent(item.row); });
};
/**
 * @hidden
 */
exports.propsChanged = function (initialProps, newProps) {
    for (var i = 0; i < initialProps.length; i++) {
        if (initialProps[i] !== newProps[i]) {
            return true;
        }
    }
    return false;
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
exports.getDropTarget = function (event) {
    if (!(kendo_angular_common_1.isDocumentAvailable() && util_1.isPresent(document.elementsFromPoint))) {
        return [event.target];
    }
    return document.elementsFromPoint(event.clientX, event.clientY)
        .filter(function (item) { return item.classList && (item.classList.contains('k-tilelayout-item') || item.classList.contains('k-layout-item-hint')); });
};
/**
 * @hidden
 */
exports.setElementStyles = function (renderer, elem, styles) {
    var props = Object.keys(styles);
    props.forEach(function (p) {
        renderer.setStyle(elem, p, styles[p]);
    });
};
/**
 * @hidden
 */
exports.calculateCellFromPosition = function (coordinates, tileLayoutElement, gap, cellSize, columns, rtl) {
    if (rtl === void 0) { rtl = false; }
    var tileLayoutRect = tileLayoutElement.getBoundingClientRect();
    var totalRows = (tileLayoutRect.height - gap.rows) / (cellSize.height + gap.rows);
    var distanceFromTop = coordinates.y - tileLayoutRect.y;
    var distanceFromLeft = coordinates.x - tileLayoutRect.x;
    var distanceFromRight = tileLayoutRect.right - coordinates.x;
    var distanceToCellWidthRatio = Math.floor((rtl ? distanceFromRight : distanceFromLeft) / (gap.columns + cellSize.width));
    var cappedColumnPosition = Math.min(distanceToCellWidthRatio + 1, columns);
    var distanceToCellHeightRatio = Math.floor(distanceFromTop / (gap.rows + cellSize.height));
    var cappedRowPosition = Math.min(distanceToCellHeightRatio + 1, totalRows);
    var col = Math.max(cappedColumnPosition, 0);
    var row = Math.max(cappedRowPosition, 0);
    return {
        row: row, col: col
    };
};
/**
 * @hidden
 */
exports.calculateOrderFromCell = function (row, col, items, draggedItem, tileLayoutElement, gap, cellSize, columns) {
    var order = 0;
    items.forEach(function (item) {
        var rect = item.elem.nativeElement.getBoundingClientRect();
        var start = exports.calculateCellFromPosition({
            x: rect.x,
            y: rect.y
        }, tileLayoutElement, gap, cellSize, columns);
        if (item !== draggedItem && ((start.row === row && start.col < col) || start.row < row)) {
            order++;
        }
    });
    return order;
};
