/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Injectable, NgZone } from '@angular/core';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { Keys } from '@progress/kendo-angular-common';
import { isArrowKey, isHorizontalArrowKey, isNavigationKey, isVerticalArrowKey } from '../common/util';
import { SelectEvent, TabCloseEvent } from './events';
import { isTabClosable, getActiveTab, isTabElement, isTablistHorizontal, getTabByIndex, getTabHeaderByIndex, resetTabSelection } from './util';
/**
 * @hidden
 */
var TabStripService = /** @class */ (function () {
    function TabStripService(localization, ngZone) {
        this.localization = localization;
        this.ngZone = ngZone;
    }
    TabStripService.prototype.onKeyDown = function (event) {
        if (!isTabElement(event.target)) {
            return;
        }
        var key = event.keyCode;
        if (this.shouldHandleKey(key)) {
            event.preventDefault();
        }
        else {
            return;
        }
        if (isNavigationKey(key) || isArrowKey(key)) {
            this.onNavigate(key);
        }
        else if (key === Keys.Delete) {
            this.onDelete();
        }
    };
    TabStripService.prototype.onTabSelect = function (tab, index) {
        var selectArgs = new SelectEvent(index, tab.title);
        this.owner.tabSelect.emit(selectArgs);
        if (!selectArgs.isDefaultPrevented()) {
            if (tab.selected) {
                this.focusTabHeader(index);
                return;
            }
            this.selectTab(tab, index);
        }
    };
    TabStripService.prototype.selectTab = function (tab, index) {
        resetTabSelection(this.owner.tabs);
        this.focusTabHeader(index);
        tab.selected = true;
        if (this.owner.isScrollable) {
            this.owner.scrollToSelectedTab();
        }
    };
    TabStripService.prototype.onTabClose = function (tab, index) {
        var closeArgs = new TabCloseEvent(index, tab);
        this.owner.tabClose.emit(closeArgs);
    };
    TabStripService.prototype.onNavigate = function (keyCode) {
        var _this = this;
        var _a = getActiveTab(this.owner.tabs), activeTab = _a.tab, activeIndex = _a.index;
        if (!NgZone.isInAngularZone()) {
            this.ngZone.run(function () {
                if (activeIndex < 0) {
                    _this.owner.selectTab(_this.firstNavigatableIndex());
                    return;
                }
                activeTab.focused = false;
                var nextIndex = _this.computeNextIndex(activeIndex, keyCode);
                _this.activateTab(nextIndex);
            });
        }
    };
    TabStripService.prototype.onDelete = function () {
        var _this = this;
        var _a = getActiveTab(this.owner.tabs), activeTab = _a.tab, activeTabIndex = _a.index;
        if (isTabClosable(activeTab, this.owner.closable) && !activeTab.disabled) {
            this.ngZone.run(function () {
                _this.onTabClose(activeTab, activeTabIndex);
            });
        }
    };
    TabStripService.prototype.activateTab = function (index) {
        var tab = getTabByIndex(this.owner.tabs, index);
        if (tab.disabled) {
            this.focusTabHeader(index);
            tab.focused = true;
        }
        else {
            this.onTabSelect(tab, index);
        }
    };
    TabStripService.prototype.focusTabHeader = function (index) {
        var tabHeader = getTabHeaderByIndex(this.owner.tabHeaderContainers, index);
        tabHeader.nativeElement.focus();
    };
    TabStripService.prototype.shouldHandleKey = function (keyCode) {
        if (isNavigationKey(keyCode)) {
            return true;
        }
        if (isTablistHorizontal(this.owner.tabPosition) && isHorizontalArrowKey(keyCode)) {
            return true;
        }
        if (!isTablistHorizontal(this.owner.tabPosition) && isVerticalArrowKey(keyCode)) {
            return true;
        }
        if (keyCode === Keys.Delete) {
            return true;
        }
        return false;
    };
    TabStripService.prototype.computeNextIndex = function (activeIndex, keyCode) {
        switch (keyCode) {
            case this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight):
            case this.invertKeys(Keys.ArrowUp, Keys.ArrowDown):
                return this.prevNavigatableIndex(activeIndex);
            case this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft):
            case this.invertKeys(Keys.ArrowDown, Keys.ArrowUp):
                return this.nextNavigatableIndex(activeIndex);
            case Keys.Home:
                return this.firstNavigatableIndex();
            case Keys.End:
                return this.lastNavigatableIndex();
            default:
                return;
        }
    };
    TabStripService.prototype.invertKeys = function (original, inverted) {
        return this.localization.rtl ? inverted : original;
    };
    TabStripService.prototype.firstNavigatableIndex = function () {
        return 0;
    };
    TabStripService.prototype.lastNavigatableIndex = function () {
        return this.owner.tabs.length - 1;
    };
    TabStripService.prototype.prevNavigatableIndex = function (selectedIndex) {
        if (selectedIndex - 1 < 0) {
            return this.lastNavigatableIndex();
        }
        return selectedIndex - 1;
    };
    TabStripService.prototype.nextNavigatableIndex = function (selectedIndex) {
        if (selectedIndex + 1 >= this.owner.tabs.length) {
            return this.firstNavigatableIndex();
        }
        return selectedIndex + 1;
    };
    TabStripService = tslib_1.__decorate([
        Injectable(),
        tslib_1.__metadata("design:paramtypes", [LocalizationService,
            NgZone])
    ], TabStripService);
    return TabStripService;
}());
export { TabStripService };
