/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Injectable, NgZone } from '@angular/core';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { Keys } from '@progress/kendo-angular-common';
import { isArrowKey, isHorizontalArrowKey, isNavigationKey, isVerticalArrowKey } from '../common/util';
import { SelectEvent, TabCloseEvent } from './events';
import { isTabClosable, getActiveTab, isTabElement, isTablistHorizontal, getTabByIndex, getTabHeaderByIndex, resetTabSelection } from './util';
/**
 * @hidden
 */
let TabStripService = class TabStripService {
    constructor(localization, ngZone) {
        this.localization = localization;
        this.ngZone = ngZone;
    }
    onKeyDown(event) {
        if (!isTabElement(event.target)) {
            return;
        }
        const key = event.keyCode;
        if (this.shouldHandleKey(key)) {
            event.preventDefault();
        }
        else {
            return;
        }
        if (isNavigationKey(key) || isArrowKey(key)) {
            this.onNavigate(key);
        }
        else if (key === Keys.Delete) {
            this.onDelete();
        }
    }
    onTabSelect(tab, index) {
        const selectArgs = new SelectEvent(index, tab.title);
        this.owner.tabSelect.emit(selectArgs);
        if (!selectArgs.isDefaultPrevented()) {
            if (tab.selected) {
                this.focusTabHeader(index);
                return;
            }
            this.selectTab(tab, index);
        }
    }
    selectTab(tab, index) {
        resetTabSelection(this.owner.tabs);
        this.focusTabHeader(index);
        tab.selected = true;
        if (this.owner.isScrollable) {
            this.owner.scrollToSelectedTab();
        }
    }
    onTabClose(tab, index) {
        const closeArgs = new TabCloseEvent(index, tab);
        this.owner.tabClose.emit(closeArgs);
    }
    onNavigate(keyCode) {
        let { tab: activeTab, index: activeIndex } = getActiveTab(this.owner.tabs);
        if (!NgZone.isInAngularZone()) {
            this.ngZone.run(() => {
                if (activeIndex < 0) {
                    this.owner.selectTab(this.firstNavigatableIndex());
                    return;
                }
                activeTab.focused = false;
                const nextIndex = this.computeNextIndex(activeIndex, keyCode);
                this.activateTab(nextIndex);
            });
        }
    }
    onDelete() {
        let { tab: activeTab, index: activeTabIndex } = getActiveTab(this.owner.tabs);
        if (isTabClosable(activeTab, this.owner.closable) && !activeTab.disabled) {
            this.ngZone.run(() => {
                this.onTabClose(activeTab, activeTabIndex);
            });
        }
    }
    activateTab(index) {
        const tab = getTabByIndex(this.owner.tabs, index);
        if (tab.disabled) {
            this.focusTabHeader(index);
            tab.focused = true;
        }
        else {
            this.onTabSelect(tab, index);
        }
    }
    focusTabHeader(index) {
        const tabHeader = getTabHeaderByIndex(this.owner.tabHeaderContainers, index);
        tabHeader.nativeElement.focus();
    }
    shouldHandleKey(keyCode) {
        if (isNavigationKey(keyCode)) {
            return true;
        }
        if (isTablistHorizontal(this.owner.tabPosition) && isHorizontalArrowKey(keyCode)) {
            return true;
        }
        if (!isTablistHorizontal(this.owner.tabPosition) && isVerticalArrowKey(keyCode)) {
            return true;
        }
        if (keyCode === Keys.Delete) {
            return true;
        }
        return false;
    }
    computeNextIndex(activeIndex, keyCode) {
        switch (keyCode) {
            case this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight):
            case this.invertKeys(Keys.ArrowUp, Keys.ArrowDown):
                return this.prevNavigatableIndex(activeIndex);
            case this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft):
            case this.invertKeys(Keys.ArrowDown, Keys.ArrowUp):
                return this.nextNavigatableIndex(activeIndex);
            case Keys.Home:
                return this.firstNavigatableIndex();
            case Keys.End:
                return this.lastNavigatableIndex();
            default:
                return;
        }
    }
    invertKeys(original, inverted) {
        return this.localization.rtl ? inverted : original;
    }
    firstNavigatableIndex() {
        return 0;
    }
    lastNavigatableIndex() {
        return this.owner.tabs.length - 1;
    }
    prevNavigatableIndex(selectedIndex) {
        if (selectedIndex - 1 < 0) {
            return this.lastNavigatableIndex();
        }
        return selectedIndex - 1;
    }
    nextNavigatableIndex(selectedIndex) {
        if (selectedIndex + 1 >= this.owner.tabs.length) {
            return this.firstNavigatableIndex();
        }
        return selectedIndex + 1;
    }
};
TabStripService = tslib_1.__decorate([
    Injectable(),
    tslib_1.__metadata("design:paramtypes", [LocalizationService,
        NgZone])
], TabStripService);
export { TabStripService };
