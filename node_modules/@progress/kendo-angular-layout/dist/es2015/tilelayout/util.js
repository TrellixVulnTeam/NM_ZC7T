/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { isDocumentAvailable } from '@progress/kendo-angular-common';
import { isPresent } from '../common/util';
/**
 * @hidden
 */
export const normalizeValue = (value) => {
    return value ? +value : undefined;
};
/**
 * @hidden
 */
export const isRowItemPresent = (items) => {
    return items.some(item => isPresent(item.row));
};
/**
 * @hidden
 */
export const propsChanged = (initialProps, newProps) => {
    for (let i = 0; i < initialProps.length; i++) {
        if (initialProps[i] !== newProps[i]) {
            return true;
        }
    }
    return false;
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
export const getDropTarget = (event) => {
    if (!(isDocumentAvailable() && isPresent(document.elementsFromPoint))) {
        return [event.target];
    }
    return document.elementsFromPoint(event.clientX, event.clientY)
        .filter(item => item.classList && (item.classList.contains('k-tilelayout-item') || item.classList.contains('k-layout-item-hint')));
};
/**
 * @hidden
 */
export const setElementStyles = (renderer, elem, styles) => {
    const props = Object.keys(styles);
    props.forEach(p => {
        renderer.setStyle(elem, p, styles[p]);
    });
};
/**
 * @hidden
 */
export const calculateCellFromPosition = (coordinates, tileLayoutElement, gap, cellSize, columns, rtl = false) => {
    const tileLayoutRect = tileLayoutElement.getBoundingClientRect();
    const totalRows = (tileLayoutRect.height - gap.rows) / (cellSize.height + gap.rows);
    const distanceFromTop = coordinates.y - tileLayoutRect.y;
    const distanceFromLeft = coordinates.x - tileLayoutRect.x;
    const distanceFromRight = tileLayoutRect.right - coordinates.x;
    const distanceToCellWidthRatio = Math.floor((rtl ? distanceFromRight : distanceFromLeft) / (gap.columns + cellSize.width));
    const cappedColumnPosition = Math.min(distanceToCellWidthRatio + 1, columns);
    const distanceToCellHeightRatio = Math.floor(distanceFromTop / (gap.rows + cellSize.height));
    const cappedRowPosition = Math.min(distanceToCellHeightRatio + 1, totalRows);
    const col = Math.max(cappedColumnPosition, 0);
    const row = Math.max(cappedRowPosition, 0);
    return {
        row, col
    };
};
/**
 * @hidden
 */
export const calculateOrderFromCell = (row, col, items, draggedItem, tileLayoutElement, gap, cellSize, columns) => {
    let order = 0;
    items.forEach(item => {
        const rect = item.elem.nativeElement.getBoundingClientRect();
        const start = calculateCellFromPosition({
            x: rect.x,
            y: rect.y
        }, tileLayoutElement, gap, cellSize, columns);
        if (item !== draggedItem && ((start.row === row && start.col < col) || start.row < row)) {
            order++;
        }
    });
    return order;
};
