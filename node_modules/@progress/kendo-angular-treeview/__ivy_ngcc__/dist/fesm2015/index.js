/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param } from 'tslib';
import { EventEmitter, Injectable, Directive, Optional, TemplateRef, forwardRef, isDevMode, HostBinding, ViewChild, ViewContainerRef, Input, Output, ContentChild, Component, ChangeDetectionStrategy, ElementRef, ChangeDetectorRef, NgZone, Renderer2, ComponentFactoryResolver, Host, NgModule } from '@angular/core';
import { isDocumentAvailable, Keys, anyChanged, hasObservers, isChanged, guid } from '@progress/kendo-angular-common';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { Subject, of, BehaviorSubject, Subscription, EMPTY, merge } from 'rxjs';
import { validatePackage } from '@progress/kendo-licensing';
import { getter, setter } from '@progress/kendo-common';
import { trigger, transition, style, animate } from '@angular/animations';
import { filter, catchError, tap, finalize, switchMap, take, map, delay, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import Draggable from '@telerik/kendo-draggable';
import { InputsModule } from '@progress/kendo-angular-inputs';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@progress/kendo-angular-inputs';

const _c0 = ["assetsContainer"];
function TreeViewComponent_span_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 6);
} }
function TreeViewComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 3)(1, "kendo-textbox", 4);
    ɵngcc0.ɵɵlistener("valueChange", function TreeViewComponent_span_0_Template_kendo_textbox_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.filterChange.emit($event); });
    ɵngcc0.ɵɵtemplate(2, TreeViewComponent_span_0_ng_template_2_Template, 1, 0, "ng-template", 5);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("size", ctx_r0.size)("value", ctx_r0.filter)("clearButton", true)("placeholder", ctx_r0.filterInputPlaceholder);
} }
const _c1 = ["kendoTreeViewGroup", ""];
function TreeViewGroupComponent_li_0_span_2_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 12);
    ɵngcc0.ɵɵlistener("click", function TreeViewGroupComponent_li_0_span_2_Template_span_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(); const index_r3 = ctx_r10.index; const node_r2 = ctx_r10.$implicit; const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.expandNode(ctx_r9.nodeIndex(index_r3), node_r2, !ctx_r9.isExpanded(node_r2, ctx_r9.nodeIndex(index_r3))); });
    ɵngcc0.ɵɵelement(1, "span", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext();
    const index_r3 = ctx_r12.index;
    const node_r2 = ctx_r12.$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("kendoTreeViewLoading", ctx_r4.nodeIndex(index_r3));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("k-i-collapse", ctx_r4.isExpanded(node_r2, ctx_r4.nodeIndex(index_r3)))("k-i-expand", !ctx_r4.isExpanded(node_r2, ctx_r4.nodeIndex(index_r3)));
} }
function TreeViewGroupComponent_li_0_kendo_checkbox_3_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-checkbox", 14);
    ɵngcc0.ɵɵlistener("checkStateChange", function TreeViewGroupComponent_li_0_kendo_checkbox_3_Template_kendo_checkbox_checkStateChange_0_listener() { ɵngcc0.ɵɵrestoreView(_r15); const index_r3 = ɵngcc0.ɵɵnextContext().index; const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.checkNode(ctx_r13.nodeIndex(index_r3)); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext();
    const node_r2 = ctx_r16.$implicit;
    const index_r3 = ctx_r16.index;
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("size", ctx_r5.size)("node", node_r2)("index", ctx_r5.nodeIndex(index_r3))("isChecked", ctx_r5.isChecked);
} }
function TreeViewGroupComponent_li_0_ng_container_7_ng_template_1_Template(rf, ctx) { }
const _c2 = function (a0, a1) { return { $implicit: a0, index: a1 }; };
function TreeViewGroupComponent_li_0_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TreeViewGroupComponent_li_0_ng_container_7_ng_template_1_Template, 0, 0, "ng-template", 15);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r18 = ɵngcc0.ɵɵnextContext();
    const node_r2 = ctx_r18.$implicit;
    const index_r3 = ctx_r18.index;
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r6.nodeTemplateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c2, node_r2, ctx_r6.nodeIndex(index_r3)));
} }
function TreeViewGroupComponent_li_0_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const node_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r7.nodeText(node_r2), " ");
} }
function TreeViewGroupComponent_li_0_ul_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", 16);
} if (rf & 2) {
    const ctx_r20 = ɵngcc0.ɵɵnextContext();
    const node_r2 = ctx_r20.$implicit;
    const index_r3 = ctx_r20.index;
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nodes", ctx_r8.fetchChildren)("loadOnDemand", ctx_r8.loadOnDemand)("checkboxes", ctx_r8.checkboxes)("expandIcons", ctx_r8.expandIcons)("selectable", ctx_r8.selectable)("touchActions", ctx_r8.touchActions)("children", ctx_r8.children)("hasChildren", ctx_r8.hasChildren)("isChecked", ctx_r8.isChecked)("isDisabled", ctx_r8.isDisabled)("disabled", ctx_r8.disabled || ctx_r8.isDisabled(node_r2, ctx_r8.nodeIndex(index_r3)))("isExpanded", ctx_r8.isExpanded)("isSelected", ctx_r8.isSelected)("isVisible", ctx_r8.isVisible)("nodeTemplateRef", ctx_r8.nodeTemplateRef)("loadMoreButtonTemplateRef", ctx_r8.loadMoreButtonTemplateRef)("parentIndex", ctx_r8.nodeIndex(index_r3))("parentDataItem", node_r2)("textField", ctx_r8.nextFields)("loadMoreService", ctx_r8.loadMoreService)("@toggle", true)("trackBy", ctx_r8.trackBy);
} }
function TreeViewGroupComponent_li_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 2)(1, "div", 3);
    ɵngcc0.ɵɵtemplate(2, TreeViewGroupComponent_li_0_span_2_Template, 2, 5, "span", 4);
    ɵngcc0.ɵɵtemplate(3, TreeViewGroupComponent_li_0_kendo_checkbox_3_Template, 1, 4, "kendo-checkbox", 5);
    ɵngcc0.ɵɵelementStart(4, "span", 6)(5, "span", 7);
    ɵngcc0.ɵɵelementContainerStart(6, 8);
    ɵngcc0.ɵɵtemplate(7, TreeViewGroupComponent_li_0_ng_container_7_Template, 2, 5, "ng-container", 9);
    ɵngcc0.ɵɵtemplate(8, TreeViewGroupComponent_li_0_ng_container_8_Template, 2, 1, "ng-container", 10);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementEnd()()();
    ɵngcc0.ɵɵtemplate(9, TreeViewGroupComponent_li_0_ul_9_Template, 1, 22, "ul", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r2 = ctx.$implicit;
    const index_r3 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-display-none", !ctx_r0.isVisible(node_r2, ctx_r0.nodeIndex(index_r3)));
    ɵngcc0.ɵɵproperty("dataItem", node_r2)("index", ctx_r0.nodeIndex(index_r3))("parentDataItem", ctx_r0.parentDataItem)("parentIndex", ctx_r0.parentIndex)("loadOnDemand", ctx_r0.loadOnDemand)("checkable", ctx_r0.checkboxes)("isChecked", ctx_r0.isChecked(node_r2, ctx_r0.nodeIndex(index_r3)))("isDisabled", ctx_r0.disabled || ctx_r0.isDisabled(node_r2, ctx_r0.nodeIndex(index_r3)))("isVisible", ctx_r0.isVisible(node_r2, ctx_r0.nodeIndex(index_r3)))("expandable", ctx_r0.expandIcons && ctx_r0.hasChildren(node_r2))("isExpanded", ctx_r0.isExpanded(node_r2, ctx_r0.nodeIndex(index_r3)))("selectable", ctx_r0.selectable)("isSelected", ctx_r0.isSelected(node_r2, ctx_r0.nodeIndex(index_r3)));
    ɵngcc0.ɵɵattribute("aria-setsize", ctx_r0.totalNodesCount)("data-treeindex", ctx_r0.nodeIndex(index_r3));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.expandIcons && ctx_r0.hasChildren(node_r2));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.checkboxes);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("touch-action", ctx_r0.touchActions ? "" : "none");
    ɵngcc0.ɵɵproperty("dataItem", node_r2)("index", ctx_r0.nodeIndex(index_r3))("initialSelection", ctx_r0.isSelected(node_r2, ctx_r0.nodeIndex(index_r3)))("isSelected", ctx_r0.isSelected);
    ɵngcc0.ɵɵattribute("data-treeindex", ctx_r0.nodeIndex(index_r3));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r0.hasTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", true);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isExpanded(node_r2, ctx_r0.nodeIndex(index_r3)) && ctx_r0.hasChildren(node_r2));
} }
function TreeViewGroupComponent_li_1_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 21);
} }
function TreeViewGroupComponent_li_1_5_ng_template_0_Template(rf, ctx) { }
const _c3 = function (a0) { return { index: a0 }; };
function TreeViewGroupComponent_li_1_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TreeViewGroupComponent_li_1_5_ng_template_0_Template, 0, 0, "ng-template", 15);
} if (rf & 2) {
    const ctx_r22 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r22.loadMoreButtonTemplateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c3, ctx_r22.loadMoreButtonIndex));
} }
function TreeViewGroupComponent_li_1_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1, " Load more ");
    ɵngcc0.ɵɵelementContainerEnd();
} }
function TreeViewGroupComponent_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 17)(1, "div", 3);
    ɵngcc0.ɵɵtemplate(2, TreeViewGroupComponent_li_1_span_2_Template, 1, 0, "span", 18);
    ɵngcc0.ɵɵelementStart(3, "span", 19)(4, "span", 7);
    ɵngcc0.ɵɵtemplate(5, TreeViewGroupComponent_li_1_5_Template, 1, 4, null, 20);
    ɵngcc0.ɵɵtemplate(6, TreeViewGroupComponent_li_1_ng_container_6_Template, 2, 0, "ng-container", 20);
    ɵngcc0.ɵɵelementEnd()()()();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-treeview-load-more-checkboxes-container", ctx_r1.checkboxes);
    ɵngcc0.ɵɵproperty("selectable", false)("checkable", false)("expandable", false)("index", ctx_r1.loadMoreButtonIndex)("parentDataItem", ctx_r1.parentDataItem)("parentIndex", ctx_r1.parentIndex);
    ɵngcc0.ɵɵattribute("data-treeindex", ctx_r1.loadMoreButtonIndex);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.loadingMoreNodes);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("index", ctx_r1.loadMoreButtonIndex);
    ɵngcc0.ɵɵattribute("data-treeindex", ctx_r1.loadMoreButtonIndex);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.loadMoreButtonTemplateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.loadMoreButtonTemplateRef);
} }
function DragClueComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span");
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("k-icon ", ctx_r0.statusIconClass, " k-drag-status");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.text);
} }
function DragClueComponent_1_ng_template_0_Template(rf, ctx) { }
const _c4 = function (a0, a1, a2, a3) { return { text: a0, action: a1, sourceItem: a2, destinationItem: a3 }; };
function DragClueComponent_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DragClueComponent_1_ng_template_0_Template, 0, 0, "ng-template", 1);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction4(2, _c4, ctx_r1.text, ctx_r1.action, ctx_r1.sourceItem, ctx_r1.destinationItem));
} }
function DropHintComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵelement(1, "div", 3)(2, "div", 4);
    ɵngcc0.ɵɵelementEnd();
} }
function DropHintComponent_1_ng_template_0_ng_template_0_Template(rf, ctx) { }
function DropHintComponent_1_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DropHintComponent_1_ng_template_0_ng_template_0_Template, 0, 0, "ng-template");
} }
const _c5 = function (a0, a1, a2) { return { action: a0, sourceItem: a1, destinationItem: a2 }; };
function DropHintComponent_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DropHintComponent_1_ng_template_0_Template, 1, 0, "ng-template", 5);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction3(2, _c5, ctx_r1.action, ctx_r1.sourceItem, ctx_r1.destinationItem));
} }
const packageMetadata = {
    name: '@progress/kendo-angular-treeview',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1646219256,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * @hidden
 */
class DataChangeNotificationService {
    constructor() {
        this.changes = new EventEmitter();
    }
    notify() {
        this.changes.emit();
    }
}
DataChangeNotificationService.ɵfac = function DataChangeNotificationService_Factory(t) { return new (t || DataChangeNotificationService)(); };
DataChangeNotificationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DataChangeNotificationService, factory: DataChangeNotificationService.ɵfac });

/**
 * @hidden
 */
const hasChildren = () => false;
/**
 * @hidden
 */
const isChecked = () => 'none';
/**
 * @hidden
 */
const isDisabled = () => false;
/**
 * @hidden
 */
const isExpanded = () => true;
/**
 * @hidden
 */
const isSelected = () => false;
/**
 * @hidden
 */
const isVisible = () => true;
/**
 * @hidden
 */
const trackBy = (_, item) => item;

/**
 * @hidden
 */
let ExpandStateService = class ExpandStateService {
    /**
     * @hidden
     */
    constructor() {
        this.changes = new Subject();
    }
    expand(index, dataItem) {
        this.changes.next({ dataItem, index, expand: true });
    }
    collapse(index, dataItem) {
        this.changes.next({ dataItem, index, expand: false });
    }
};
ExpandStateService.ɵfac = function ExpandStateService_Factory(t) { return new (t || ExpandStateService)(); };
ExpandStateService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ExpandStateService, factory: function (t) { return ExpandStateService.ɵfac(t); } });

/**
 * @hidden
 */
let IndexBuilderService = class IndexBuilderService {
    /**
     * @hidden
     */
    constructor() {
        this.INDEX_SEPARATOR = '_';
    }
    nodeIndex(index = '', parentIndex = '') {
        return `${parentIndex}${parentIndex ? this.INDEX_SEPARATOR : ''}${index}`;
    }
    indexForLevel(index, level) {
        return index.split(this.INDEX_SEPARATOR).slice(0, level).join(this.INDEX_SEPARATOR);
    }
    lastLevelIndex(index = '') {
        const parts = index.split(this.INDEX_SEPARATOR);
        if (!parts.length) {
            return NaN;
        }
        return parseInt(parts[parts.length - 1], 10);
    }
    level(index) {
        return index.split(this.INDEX_SEPARATOR).length;
    }
};
IndexBuilderService.ɵfac = function IndexBuilderService_Factory(t) { return new (t || IndexBuilderService)(); };
IndexBuilderService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: IndexBuilderService, factory: function (t) { return IndexBuilderService.ɵfac(t); } });

/**
 * @hidden
 */
let LoadingNotificationService = class LoadingNotificationService {
    /**
     * @hidden
     */
    constructor() {
        this.changes = new Subject();
    }
    notifyLoaded(index) {
        this.changes.next(index);
    }
};
LoadingNotificationService.ɵfac = function LoadingNotificationService_Factory(t) { return new (t || LoadingNotificationService)(); };
LoadingNotificationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: LoadingNotificationService, factory: function (t) { return LoadingNotificationService.ɵfac(t); } });

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
/**
 * @hidden
 */
const match = (element, selector) => {
    const matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
    if (!matcher) {
        return false;
    }
    return matcher.call(element, selector);
};
/**
 * @hidden
 */
const closestWithMatch = (element, selector) => {
    if (!document.documentElement.contains(element)) {
        return null;
    }
    let parent = element;
    while (parent !== null && parent.nodeType === 1) {
        if (match(parent, selector)) {
            return parent;
        }
        parent = parent.parentElement || parent.parentNode;
    }
    return null;
};
/**
 * @hidden
 */
const noop = () => { };
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const isBlank = (value) => value === null || value === undefined;
/**
 * @hidden
 */
const isArray = (value) => Array.isArray(value);
/**
 * @hidden
 */
const isNullOrEmptyString = (value) => isBlank(value) || value.trim().length === 0;
/**
 * @hidden
 */
const isBoolean = (value) => typeof value === 'boolean';
/**
 * @hidden
 */
const closestNode = (element) => {
    const selector = 'li.k-treeview-item';
    if (!isDocumentAvailable()) {
        return null;
    }
    if (element.closest) {
        return element.closest(selector);
    }
    else {
        return closestWithMatch(element, selector);
    }
};
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabIndex');
        const skipTab = tabIndex === '-1';
        let focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
/**
 * @hidden
 */
const isContent = (element) => {
    const scopeSelector = '.k-treeview-leaf:not(.k-treeview-load-more-button),.k-treeview-item,.k-treeview';
    if (!isDocumentAvailable()) {
        return null;
    }
    let node = element;
    while (node && !match(node, scopeSelector)) {
        node = node.parentNode;
    }
    if (node) {
        return match(node, '.k-treeview-leaf:not(.k-treeview-load-more-button)');
    }
};
/**
 * @hidden
 *
 * Returns the nested .k-treeview-leaf:not(.k-treeview-load-more-button) element.
 * If the passed parent item is itself a content node, it is returned.
 */
const getContentElement = (parent) => {
    if (!isPresent(parent)) {
        return null;
    }
    const selector = '.k-treeview-leaf:not(.k-treeview-load-more-button)';
    if (match(parent, selector)) {
        return parent;
    }
    return parent.querySelector(selector);
};
/**
 * @hidden
 */
const isLoadMoreButton = (element) => {
    return isPresent(closestWithMatch(element, '.k-treeview-leaf.k-treeview-load-more-button'));
};
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
const hasParent = (element, container) => {
    return Boolean(closest(element, (node) => node === container));
};
/**
 * @hidden
 */
const focusableNode = (element) => element.nativeElement.querySelector('li[tabindex="0"]');
/**
 * @hidden
 */
const nodeId = (node) => node ? node.getAttribute('data-treeindex') : '';
/**
 * @hidden
 */
const nodeIndex = (item) => (item || {}).index;
/**
 * @hidden
 */
const dataItemsEqual = (first, second) => {
    if (!isPresent(first) && !isPresent(second)) {
        return true;
    }
    return isPresent(first) && isPresent(second) && first.item.dataItem === second.item.dataItem;
};
/**
 * @hidden
 */
const getDataItem = (lookup) => {
    if (!isPresent(lookup)) {
        return lookup;
    }
    return lookup.item.dataItem;
};
/**
 * @hidden
 */
const isArrayWithAtLeastOneItem = v => v && Array.isArray(v) && v.length !== 0;
/**
 * @hidden
 * A recursive tree-filtering algorithm that returns:
 * - all child nodes of matching nodes
 * - a chain parent nodes from the match to the root node
 */
const filterTree = (items, term, { operator, ignoreCase, mode }, textField, depth = 0) => {
    const field = typeof textField === "string" ? textField : textField[depth];
    items.forEach((wrapper) => {
        const matcher = typeof operator === "string" ? matchByFieldAndCase(field, operator, ignoreCase) : operator;
        const isMatch = matcher(wrapper.dataItem, term);
        wrapper.isMatch = isMatch;
        wrapper.visible = isMatch;
        wrapper.containsMatches = false;
        if (isMatch) {
            setParentChain(wrapper.parent);
        }
        if (wrapper.children && wrapper.children.length > 0) {
            if (mode === "strict" || !isMatch) {
                filterTree(wrapper.children, term, { operator, ignoreCase, mode }, textField, depth + 1);
            }
            else {
                makeAllVisible(wrapper.children);
            }
        }
    });
};
const setParentChain = (node) => {
    if (!isPresent(node)) {
        return;
    }
    node.containsMatches = true;
    node.visible = true;
    if (isPresent(node.parent) && !node.parent.containsMatches) {
        setParentChain(node.parent);
    }
};
const makeAllVisible = (nodes) => {
    nodes.forEach(node => {
        node.visible = true;
        if (node.children) {
            makeAllVisible(node.children);
        }
    });
};
const ɵ2 = (a, b) => a.indexOf(b) >= 0, ɵ3 = (a, b) => a.indexOf(b) === -1, ɵ4 = (a, b) => a.lastIndexOf(b, 0) === 0, ɵ5 = (a, b) => a.lastIndexOf(b, 0) === -1, ɵ6 = (a, b) => a.indexOf(b, a.length - b.length) >= 0, ɵ7 = (a, b) => a.indexOf(b, a.length - b.length) < 0;
const operators = {
    contains: ɵ2,
    doesnotcontain: ɵ3,
    startswith: ɵ4,
    doesnotstartwith: ɵ5,
    endswith: ɵ6,
    doesnotendwith: ɵ7
};
const matchByCase = (matcher, ignoreCase) => (a, b) => {
    if (ignoreCase) {
        return matcher(a.toLowerCase(), b.toLowerCase());
    }
    return matcher(a, b);
};
const matchByFieldAndCase = (field, operator, ignoreCase) => (dataItem, term) => matchByCase(operators[operator], ignoreCase)(getter(field)(dataItem), term);
/**
 * @hidden
 */
const buildTreeIndex = (parentIndex, itemIndex) => {
    return [parentIndex, itemIndex].filter(part => isPresent(part)).join('_');
};
/**
 * @hidden
 */
const buildTreeItem = (dataItem, currentLevelIndex, parentIndex) => {
    if (!isPresent(dataItem)) {
        return null;
    }
    return {
        dataItem,
        index: buildTreeIndex(parentIndex, currentLevelIndex)
    };
};
/**
 * @hidden
 *
 * Retrieves all descendant nodes' lookups which are currently registered in the provided lookup item as a flat array.
 */
const fetchLoadedDescendants = (lookup, filterExpression) => {
    if (!isPresent(lookup) || lookup.children.length === 0) {
        return [];
    }
    let descendants = lookup.children;
    if (isPresent(filterExpression)) {
        descendants = descendants.filter(filterExpression);
    }
    descendants.forEach(child => descendants = descendants.concat(fetchLoadedDescendants(child, filterExpression)));
    return descendants;
};
/**
 * @hidden
 *
 * Compares two Seets to determine whether all unique elements in one, are present in the other.
 * Important:
 *  - it disregards the element order
 */
const sameValues = (as, bs) => {
    if (as.size !== bs.size) {
        return false;
    }
    return Array.from(as).every(v => bs.has(v));
};
/**
 * @hidden
 * Returns the size class based on the component and size input.
 */
const getSizeClass = (component, size) => {
    const SIZE_CLASSES = {
        'small': `k-${component}-sm`,
        'medium': `k-${component}-md`,
        'large': `k-${component}-lg`
    };
    return SIZE_CLASSES[size];
};

const safe = node => (node || {});
const safeChildren = node => (safe(node).children || []);
const lastVisibleNode = (nodes) => {
    if (!Array.isArray(nodes) || nodes.length === 0) {
        return null;
    }
    const nodesCount = nodes.length;
    const lastIndex = nodesCount - 1;
    for (let index = lastIndex; index >= 0; index -= 1) {
        const node = nodes[index];
        if (node.visible) {
            return node;
        }
    }
    return null;
};
/**
 * @hidden
 */
class NavigationModel {
    constructor() {
        this.ib = new IndexBuilderService();
        this.nodes = [];
    }
    firstVisibleNode() {
        return (this.nodes || []).find(node => node.visible);
    }
    lastVisibleNode() {
        let node = lastVisibleNode(this.nodes);
        while (isPresent(node) && safeChildren(node).length > 0) {
            const children = safeChildren(node);
            const lastVisibleChild = lastVisibleNode(children);
            if (!isPresent(lastVisibleChild)) {
                return node;
            }
            node = lastVisibleChild;
        }
        return node;
    }
    closestNode(index) {
        const { prev } = safe(this.findNode(index));
        const sibling = prev || this.firstVisibleNode();
        return safe(sibling).index === index ? this.visibleSibling(sibling, 1) : sibling;
    }
    firstFocusableNode() {
        return this.nodes.find((node) => {
            return !node.disabled && node.visible;
        });
    }
    findNode(index) {
        return this.find(index, this.nodes);
    }
    findParent(index) {
        const parentLevel = this.ib.level(index) - 1;
        return this.findNode(this.ib.indexForLevel(index, parentLevel));
    }
    findVisibleChild(index) {
        const node = this.findNode(index);
        const children = safeChildren(node);
        return children.find((child) => child.visible);
    }
    findVisiblePrev(item) {
        const index = item.index;
        const parent = this.findParent(index);
        const levelIndex = this.ib.lastLevelIndex(index);
        const prevNodes = this.container(parent).slice(0, levelIndex);
        const prevNodesHidden = prevNodes.every(node => !node.visible);
        if (levelIndex === 0 || prevNodesHidden) {
            return parent;
        }
        const currentNode = this.findNode(index);
        let prev = this.visibleSibling(currentNode, -1);
        if (prev) {
            let children = this.container(prev);
            while (children.length > 0 && children.some(node => node.visible)) {
                prev = lastVisibleNode(children);
                children = this.container(prev);
            }
        }
        return prev;
    }
    findVisibleNext(item) {
        const children = this.container(item);
        const hasVisibleChildren = children.some(child => child.visible);
        if (children.length === 0 || !hasVisibleChildren) {
            return this.visibleSibling(item, 1);
        }
        return children.find(child => child.visible);
    }
    registerItem(id, index, disabled, loadMoreButton = false, visible = true) {
        const children = [];
        const level = this.ib.level(index);
        const parent = this.findParent(index);
        if (parent || level === 1) {
            const node = { id, children, index, parent, disabled, loadMoreButton, visible };
            this.insert(node, parent);
        }
    }
    unregisterItem(id, index) {
        const node = this.find(index, this.nodes);
        if (!node || node.id !== id) {
            return;
        }
        const children = this.container(node.parent);
        children.splice(children.indexOf(node), 1);
    }
    childLevel(nodes) {
        const children = nodes.filter(node => isPresent(node));
        if (!children || !children.length) {
            return 1;
        }
        return this.ib.level(children[0].index);
    }
    container(node) {
        return node ? node.children : this.nodes;
    }
    find(index, nodes) {
        const childLevel = this.childLevel(nodes);
        const indexToMatch = this.ib.indexForLevel(index, childLevel);
        const isLeaf = childLevel === this.ib.level(index);
        const node = nodes.find(n => n && n.index === indexToMatch);
        if (!node) {
            return null;
        }
        return isLeaf ? node : this.find(index, node.children);
    }
    insert(node, parent) {
        const nodes = this.container(parent);
        nodes.splice(this.ib.lastLevelIndex(node.index), 0, node);
    }
    visibleSibling(node, offset) {
        if (!node) {
            return null;
        }
        const parent = this.findParent(node.index);
        const container = this.container(parent);
        let nextItemIndex = container.indexOf(node) + offset;
        let nextItem = container[nextItemIndex];
        while (isPresent(nextItem)) {
            if (nextItem.visible) {
                return nextItem;
            }
            nextItemIndex += offset;
            nextItem = container[nextItemIndex];
        }
        return this.visibleSibling(parent, offset);
    }
}

/**
 * @hidden
 */
let NavigationService = class NavigationService {
    constructor(localization) {
        this.localization = localization;
        this.expands = new Subject();
        this.moves = new Subject();
        this.checks = new Subject();
        this.selects = new Subject();
        this.loadMore = new Subject();
        this.navigable = true;
        this.actions = {
            [Keys.ArrowUp]: () => this.activate(this.model.findVisiblePrev(this.focusableItem), true),
            [Keys.ArrowDown]: () => this.activate(this.model.findVisibleNext(this.focusableItem), true),
            [Keys.ArrowLeft]: () => !this.isLoadMoreButton && (this.expand({
                expand: this.localization.rtl,
                intercept: this.localization.rtl ? this.moveToFirstVisibleChild : this.moveToParent
            })),
            [Keys.ArrowRight]: () => !this.isLoadMoreButton && (this.expand({
                expand: !this.localization.rtl,
                intercept: this.localization.rtl ? this.moveToParent : this.moveToFirstVisibleChild
            })),
            [Keys.Home]: () => this.activate(this.model.firstVisibleNode(), true),
            [Keys.End]: () => this.activate(this.model.lastVisibleNode(), true),
            [Keys.Enter]: () => this.handleEnter(),
            [Keys.Space]: () => this.handleSpace()
        };
        this.isFocused = false;
        this.shouldScroll = false;
        this._model = new NavigationModel();
        this.moveToFirstVisibleChild = this.moveToFirstVisibleChild.bind(this);
        this.moveToParent = this.moveToParent.bind(this);
    }
    get model() {
        return this._model;
    }
    set model(model) {
        this._model = model;
    }
    get activeIndex() {
        return nodeIndex(this.activeItem) || null;
    }
    get isActiveExpanded() {
        return this.activeItem && this.activeItem.children.length > 0;
    }
    get isLoadMoreButton() {
        return this.activeItem && this.activeItem.loadMoreButton;
    }
    get focusableItem() {
        return this.activeItem || this.model.firstFocusableNode();
    }
    activate(item, shouldScroll = false) {
        if (!this.navigable || !item || this.isActive(nodeIndex(item))) {
            return;
        }
        this.isFocused = true;
        this.activeItem = item || this.activeItem;
        this.shouldScroll = shouldScroll;
        this.notifyMove();
    }
    activateParent(index) {
        this.activate(this.model.findParent(index));
    }
    activateIndex(index) {
        if (!index) {
            return;
        }
        this.activate(this.model.findNode(index));
    }
    activateClosest(index) {
        if (!index || nodeIndex(this.focusableItem) !== index) {
            return;
        }
        this.activeItem = this.model.closestNode(index);
        this.notifyMove();
    }
    activateFocusable() {
        if (this.activeItem) {
            return;
        }
        this.activeItem = this.model.firstVisibleNode();
        this.notifyMove();
    }
    deactivate() {
        if (!this.navigable || !this.isFocused) {
            return;
        }
        this.isFocused = false;
        this.notifyMove();
    }
    checkIndex(index) {
        if (!this.isDisabled(index)) {
            this.checks.next(index);
        }
    }
    selectIndex(index) {
        if (!this.isDisabled(index)) {
            this.selects.next(index);
        }
    }
    notifyLoadMore(index) {
        if (!isPresent(index)) {
            return;
        }
        this.loadMore.next(index);
    }
    isActive(index) {
        if (!index) {
            return false;
        }
        return this.isFocused && this.activeIndex === index;
    }
    isFocusable(index) {
        return nodeIndex(this.focusableItem) === index;
    }
    isDisabled(index) {
        return this.model.findNode(index).disabled;
    }
    registerItem(id, index, disabled, loadMoreButton = false, visible = true) {
        const itemAtIndex = this.model.findNode(index);
        if (isPresent(itemAtIndex)) {
            this.model.unregisterItem(itemAtIndex.id, itemAtIndex.index);
            if (this.isActive(index)) {
                this.deactivate();
            }
        }
        this.model.registerItem(id, index, disabled, loadMoreButton, visible);
    }
    unregisterItem(id, index) {
        if (this.isActive(index)) {
            this.activateParent(index);
        }
        this.model.unregisterItem(id, index);
    }
    move(e) {
        if (!this.navigable) {
            return;
        }
        const moveAction = this.actions[e.keyCode];
        if (!moveAction) {
            return;
        }
        moveAction();
        e.preventDefault();
    }
    expand({ expand, intercept }) {
        const index = nodeIndex(this.activeItem);
        if (!index || intercept(index)) {
            return;
        }
        this.notifyExpand(expand);
    }
    moveToParent() {
        if (this.isActiveExpanded) {
            return false;
        }
        this.activate(this.model.findParent(nodeIndex(this.activeItem)));
        return true;
    }
    moveToFirstVisibleChild() {
        if (!this.isActiveExpanded) {
            return false;
        }
        this.activate(this.model.findVisibleChild(nodeIndex(this.activeItem)));
        return true;
    }
    notifyExpand(expand) {
        this.expands.next(this.navigationState(expand));
    }
    notifyMove() {
        this.moves.next(this.navigationState());
    }
    navigationState(expand = false) {
        return ({ expand, index: this.activeIndex, isFocused: this.isFocused, shouldScroll: this.shouldScroll });
    }
    handleEnter() {
        if (!this.navigable) {
            return;
        }
        if (this.isLoadMoreButton) {
            this.notifyLoadMore(this.activeIndex);
        }
        else {
            this.selectIndex(this.activeIndex);
        }
    }
    handleSpace() {
        if (!this.navigable) {
            return;
        }
        if (this.isLoadMoreButton) {
            this.notifyLoadMore(this.activeIndex);
        }
        else {
            this.checkIndex(this.activeIndex);
        }
    }
};
NavigationService.ɵfac = function NavigationService_Factory(t) { return new (t || NavigationService)(ɵngcc0.ɵɵinject(ɵngcc1.LocalizationService)); };
NavigationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NavigationService, factory: function (t) { return NavigationService.ɵfac(t); } });
NavigationService = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], NavigationService);

/**
 * @hidden
 */
let NodeChildrenService = class NodeChildrenService {
    /**
     * @hidden
     */
    constructor() {
        this.changes = new Subject();
    }
    childrenLoaded(item, children) {
        this.changes.next({ item, children });
    }
};
NodeChildrenService.ɵfac = function NodeChildrenService_Factory(t) { return new (t || NodeChildrenService)(); };
NodeChildrenService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NodeChildrenService, factory: function (t) { return NodeChildrenService.ɵfac(t); } });

/**
 * Represents the template for the TreeView nodes ([more information and example]({% slug nodetemplate_treeview %})).
 * The template helps to customize the content of the nodes. To define the node template, nest an `<ng-template>`
 * tag with the `kendoTreeViewNodeTemplate` directive inside a `<kendo-treeview>` tag.
 *
 *
 * The node data item and its hierarchical index are available as context variables:
 *
 * - `let-dataItem` (`any`) - available as implicit context variable
 * - `let-index="index"` (`string`)
 *
 *
 * @example
 * ```ts
 *
 *  import { Component } from '@angular/core';
 *  @Component({
 *      selector: 'my-app',
 *      template: `
 *      <kendo-treeview
 *          [nodes]="data"
 *          kendoTreeViewExpandable
 *
 *          kendoTreeViewHierarchyBinding
 *          childrenField="items">
 *        <ng-template kendoTreeViewNodeTemplate let-dataItem let-index="index">
 *          <span [style.fontWeight]="dataItem.items ? 'bolder': 'normal' ">{{ index }}: {{ dataItem.text }}</span>
 *        </ng-template>
 *      </kendo-treeview>
 *    `
 *  })
 *  export class AppComponent {
 *      public data: any[] = [
 *          {
 *              text: "Inbox",
 *              items: [{ text: "Read Mail" }]
 *          },
 *          {
 *              text: "Drafts"
 *          },
 *          {
 *              text: "Search Folders",
 *              items: [
 *                  { text: "Categorized Mail" },
 *                  { text: "Large Mail" },
 *                  { text: "Unread Mail"}
 *              ]
 *          },
 *          { text: "Settings" }
 *      ];
 *  }
 *
 * ```
 */
let NodeTemplateDirective = class NodeTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NodeTemplateDirective.ɵfac = function NodeTemplateDirective_Factory(t) { return new (t || NodeTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
NodeTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NodeTemplateDirective, selectors: [["", "kendoTreeViewNodeTemplate", ""]] });
NodeTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], NodeTemplateDirective);

/**
 * Represents the template for the TreeView load more buttons.
 * To define a button template, nest an `<ng-template>`
 * tag with the `kendoTreeViewLoadMoreButtonTemplate` directive inside a `<kendo-treeview>` tag
 * ([see example]({% slug loadmorebutton_treeview %}#toc-button-template)).
 *
 * The hierarchical index of the load more button node is available as a context variable:
 *
 * - `let-index="index"` (`string`)
 */
let LoadMoreButtonTemplateDirective = class LoadMoreButtonTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
LoadMoreButtonTemplateDirective.ɵfac = function LoadMoreButtonTemplateDirective_Factory(t) { return new (t || LoadMoreButtonTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
LoadMoreButtonTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LoadMoreButtonTemplateDirective, selectors: [["", "kendoTreeViewLoadMoreButtonTemplate", ""]] });
LoadMoreButtonTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], LoadMoreButtonTemplateDirective);

/**
 * @hidden
 *
 * An injection token used by the data binding directives to interface with
 * the TreeView or the DropDownTree components.
 */
let DataBoundComponent = class DataBoundComponent {
};
DataBoundComponent.ɵfac = function DataBoundComponent_Factory(t) { return new (t || DataBoundComponent)(); };
DataBoundComponent.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DataBoundComponent, factory: function (t) { return DataBoundComponent.ɵfac(t); } });

/**
 * @hidden
 *
 * An injection token used by the expand-directive to interface with
 * the TreeView or the DropDownTree components.
 */
let ExpandableComponent = class ExpandableComponent {
};
ExpandableComponent.ɵfac = function ExpandableComponent_Factory(t) { return new (t || ExpandableComponent)(); };
ExpandableComponent.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ExpandableComponent, factory: function (t) { return ExpandableComponent.ɵfac(t); } });

/**
 * @hidden
 */
let SelectionService = class SelectionService {
    /**
     * @hidden
     */
    constructor() {
        this.changes = new Subject();
    }
    isFirstSelected(index) {
        return this.firstIndex === index;
    }
    setFirstSelected(index, selected) {
        if (this.firstIndex === index && selected === false) {
            this.firstIndex = null;
        }
        else if (!this.firstIndex && selected) {
            this.firstIndex = index;
        }
    }
    select(index, dataItem) {
        this.changes.next({ dataItem, index });
    }
};
SelectionService.ɵfac = function SelectionService_Factory(t) { return new (t || SelectionService)(); };
SelectionService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SelectionService, factory: function (t) { return SelectionService.ɵfac(t); } });

const INDEX_REGEX = /\d+$/;
/**
 * @hidden
 */
let TreeViewLookupService = class TreeViewLookupService {
    /**
     * @hidden
     */
    constructor() {
        this.map = new Map();
    }
    reset() {
        this.map.clear();
    }
    registerItem(item, parent) {
        const currentLookup = {
            children: [],
            item,
            parent: this.item(nodeIndex(parent))
        };
        this.map.set(item.index, currentLookup);
    }
    registerChildren(index, children) {
        const item = this.item(index);
        if (!item) {
            return;
        }
        item.children = children;
    }
    unregisterItem(index, dataItem) {
        const current = this.item(index);
        if (current && current.item.dataItem === dataItem) {
            this.map.delete(index);
            if (current.parent && current.parent.children) {
                current.parent.children = current.parent.children.filter(item => item.dataItem !== dataItem);
            }
        }
    }
    replaceItem(index, item, parent) {
        if (!item) {
            return;
        }
        this.unregisterItem(index, item.dataItem);
        this.registerItem(item, parent);
        this.addToParent(item, parent);
    }
    itemLookup(index) {
        const item = this.item(index);
        if (!item) {
            return null;
        }
        return {
            children: this.mapChildren(item.children),
            item: item.item,
            parent: item.parent
        };
    }
    hasItem(index) {
        return this.map.has(index);
    }
    item(index) {
        return this.map.get(index) || null;
    }
    addToParent(item, parent) {
        if (parent) {
            const parentItem = this.item(parent.index);
            const index = parseInt(INDEX_REGEX.exec(item.index)[0], 10);
            parentItem.children = parentItem.children || [];
            parentItem.children.splice(index, 0, item);
        }
    }
    mapChildren(children = []) {
        return children.map(c => {
            const { item, parent, children } = this.item(c.index);
            return {
                children: this.mapChildren(children),
                item,
                parent
            };
        });
    }
};
TreeViewLookupService.ɵfac = function TreeViewLookupService_Factory(t) { return new (t || TreeViewLookupService)(); };
TreeViewLookupService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: TreeViewLookupService, factory: function (t) { return TreeViewLookupService.ɵfac(t); } });

const LOAD_MORE_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';
const providers = [
    ExpandStateService,
    IndexBuilderService,
    TreeViewLookupService,
    LoadingNotificationService,
    NodeChildrenService,
    NavigationService,
    SelectionService,
    DataChangeNotificationService,
    LocalizationService,
    {
        provide: L10N_PREFIX,
        useValue: 'kendo.treeview'
    },
    {
        provide: DataBoundComponent,
        useExisting: forwardRef(() => TreeViewComponent)
    },
    {
        provide: ExpandableComponent,
        useExisting: forwardRef(() => TreeViewComponent)
    }
];
/* tslint:disable:member-ordering */
/**
 * Represents the [Kendo UI TreeView component for Angular]({% slug overview_treeview %}).
 *
 * @example
 * {% meta height:450 %}
 * {% embed_file get-started/app.component.ts preview %}
 * {% embed_file get-started/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% endmeta %}
 */
let TreeViewComponent = class TreeViewComponent {
    constructor(element, changeDetectorRef, expandService, navigationService, nodeChildrenService, selectionService, treeViewLookupService, ngZone, renderer, dataChangeNotification, localization) {
        this.element = element;
        this.changeDetectorRef = changeDetectorRef;
        this.expandService = expandService;
        this.navigationService = navigationService;
        this.nodeChildrenService = nodeChildrenService;
        this.selectionService = selectionService;
        this.treeViewLookupService = treeViewLookupService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.dataChangeNotification = dataChangeNotification;
        this.localization = localization;
        this.classNames = true;
        this.role = 'tree';
        /**
         * The hint which is displayed when the component is empty.
         */
        this.filterInputPlaceholder = "";
        /** @hidden */
        this.fetchNodes = () => this.data;
        /**
         * Fires when the children of the expanded node are loaded.
         */
        this.childrenLoaded = new EventEmitter();
        /**
         * Fires when the user blurs the component.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires when the user focuses the component.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires when the user expands a TreeView node.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the user collapses a TreeView node.
         */
        this.collapse = new EventEmitter();
        /**
         * Fires just before the dragging of the node starts ([see example]({% slug draganddrop_treeview %}#toc-setup)). This event is preventable.
         * If you prevent the event default, no drag hint will be created and the subsequent drag-related events will not be fired.
         */
        this.nodeDragStart = new EventEmitter();
        /**
         * Fires when an item is being dragged ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         */
        this.nodeDrag = new EventEmitter();
        /**
         * Emits when the built-in filtering mechanism in the data-binding directives updates the node's visibility.
         * Used for the built-in auto-expand functionalities of the component and available for custom implementations.
         */
        this.filterStateChange = new EventEmitter();
        /**
         * Fires on the target TreeView when a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * This event is preventable. If you prevent the event default (`event.preventDefualt()`) or invalidate its state (`event.setValid(false)`),
         * the `addItem` and `removeItem` events will not be triggered.
         *
         * Both operations cancel the default drop operation, but the indication to the user is different. `event.setValid(false)` indicates that the operation was
         * unsuccessful by animating the drag clue to its original position. `event.preventDefault()` simply removes the clue, as if it has been dropped successfully.
         * As a general rule, use `preventDefault` to manually handle the add and remove operations, and `setValid(false)` to indicate the operation was unsuccessful.
         */
        this.nodeDrop = new EventEmitter();
        /**
         * Fires on the source TreeView after the dragged item has been dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         */
        this.nodeDragEnd = new EventEmitter();
        /**
         * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * Called on the TreeView where the item is dropped.
         */
        this.addItem = new EventEmitter();
        /**
         * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * Called on the TreeView from where the item is dragged.
         */
        this.removeItem = new EventEmitter();
        /**
         * Fires when the user selects a TreeView node checkbox
         * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
         */
        this.checkedChange = new EventEmitter();
        /**
         * Fires when the user selects a TreeView node
         * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires when the value of the built-in filter input element changes.
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires when the user clicks a TreeView node.
         */
        this.nodeClick = new EventEmitter();
        /**
         * Fires when the user double clicks a TreeView node.
         */
        this.nodeDblClick = new EventEmitter();
        /**
         * A function that defines how to track node changes.
         * By default, the TreeView tracks the nodes by data item object reference.
         *
         * @example
         * ```ts
         *  @Component({
         *      selector: 'my-app',
         *      template: `
         *          <kendo-treeview
         *              [nodes]="data"
         *              textField="text"
         *              [trackBy]="trackBy"
         *          >
         *          </kendo-treeview>
         *      `
         *  })
         *  export class AppComponent {
         *      public data: any[] = [
         *          { text: "Furniture" },
         *          { text: "Decor" }
         *      ];
         *
         *      public trackBy(index: number, item: any): any {
         *          return item.text;
         *      }
         *  }
         * ```
         */
        this.trackBy = trackBy;
        /**
         * A function which determines if a specific node is disabled.
         */
        this.isDisabled = isDisabled;
        /**
         * A callback which determines whether a TreeView node should be rendered as hidden. The utility .k-display-none class is used to hide the nodes.
         * Useful for custom filtering implementations.
         */
        this.isVisible = isVisible;
        /**
         * Determines whether the TreeView keyboard navigable is enabled.
         */
        this.navigable = true;
        /**
         * A function which provides the child nodes for a given parent node
         * ([see example]({% slug databinding_treeview %})).
         */
        this.children = () => of([]);
        /**
         * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.
         * @default true
         */
        this.loadOnDemand = true;
        /**
         * Renders the built-in input element for filtering the TreeView.
         * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the TreeView manually]({% slug filtering_treeview %}#toc-manual-filtering).
         * A built-in filtering implementation is available to use with the [`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %}) and [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %}) directives.
         */
        this.filterable = false;
        /**
         * Sets an initial value of the built-in input element used for filtering.
         */
        this.filter = '';
        this.checkboxes = false;
        this.expandIcons = false;
        this.selectable = false;
        this.touchActions = true;
        this.isActive = false;
        this.data = new BehaviorSubject([]);
        this._animate = true;
        this._size = 'medium';
        this.subscriptions = new Subscription();
        this.domSubscriptions = [];
        validatePackage(packageMetadata);
    }
    /** @hidden */
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    /**
     * Determines whether the content animation is enabled.
     */
    set animate(value) {
        this._animate = value;
    }
    get animate() {
        return !this._animate;
    }
    /**
     * @hidden
     *
     * Defines the template for each node.
     * Takes precedence over nested templates in the TreeView tag.
     */
    set nodeTemplateRef(template) {
        this._nodeTemplateRef = template;
    }
    get nodeTemplateRef() {
        return this._nodeTemplateRef || this.nodeTemplateQuery;
    }
    /**
     * @hidden
     *
     * Defines the template for each load-more button.
     * Takes precedence over nested templates in the TreeView tag.
     */
    set loadMoreButtonTemplateRef(template) {
        this._loadMoreButtonTemplateRef = template;
    }
    get loadMoreButtonTemplateRef() {
        return this._loadMoreButtonTemplateRef || this.loadMoreButtonTemplateQuery;
    }
    /**
     * The nodes which will be displayed by the TreeView
     * ([see example]({% slug databinding_treeview %})).
     */
    set nodes(value) {
        this.data.next(value || []);
        this.dataChangeNotification.notify();
    }
    get nodes() {
        return this.data.value;
    }
    /**
     * A function which determines if a specific node has child nodes
     * ([see example]({% slug databinding_treeview %})).
     */
    get hasChildren() {
        return this._hasChildren || hasChildren;
    }
    set hasChildren(callback) {
        this._hasChildren = callback;
        this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
    }
    /**
     * A function which determines if a specific node is checked
     * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
     */
    get isChecked() {
        return this._isChecked || isChecked;
    }
    set isChecked(callback) {
        this._isChecked = callback;
        this.checkboxes = Boolean(this._isChecked);
    }
    /**
     * A function which determines if a specific node is expanded.
     */
    get isExpanded() {
        return this._isExpanded || isExpanded;
    }
    set isExpanded(callback) {
        this._isExpanded = callback;
        this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
    }
    /**
     * A function which determines if a specific node is selected
     * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
     */
    get isSelected() {
        return this._isSelected || isSelected;
    }
    set isSelected(callback) {
        this._isSelected = callback;
        this.selectable = Boolean(this._isSelected);
    }
    /**
     * Sets the size of the component.
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     *
     */
    set size(size) {
        this.renderer.removeClass(this.element.nativeElement, getSizeClass('treeview', this.size));
        if (size) {
            this.renderer.addClass(this.element.nativeElement, getSizeClass('treeview', size));
        }
        this._size = size;
    }
    get size() {
        return this._size;
    }
    ngOnChanges(changes) {
        this.navigationService.navigable = Boolean(this.navigable);
        // TODO: should react to changes.loadOnDemand as well - should preload the data or clear the already cached items
        if (anyChanged(['nodes', 'children', 'hasChildren', 'loadOnDemand'], changes, false) && !this.loadOnDemand) {
            this.preloadChildNodes();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.domSubscriptions.forEach(subscription => subscription());
    }
    ngOnInit() {
        this.subscriptions.add(this.nodeChildrenService
            .changes
            .subscribe((x) => this.childrenLoaded.emit(x)));
        this.subscriptions.add(this.expandService.changes
            .subscribe(({ index, dataItem, expand }) => expand
            ? this.expand.emit({ index, dataItem })
            : this.collapse.emit({ index, dataItem })));
        this.subscriptions.add(this.navigationService.checks
            .subscribe((x) => this.checkedChange.emit(this.treeViewLookupService.itemLookup(x))));
        this.subscriptions.add(this.selectionService.changes
            .subscribe((x) => {
            if (hasObservers(this.selectionChange)) {
                this.ngZone.run(() => {
                    this.selectionChange.emit(x);
                });
            }
        }));
        if (this.element) {
            this.ngZone.runOutsideAngular(() => {
                this.attachDomHandlers();
            });
        }
        if (this.size) {
            this.renderer.addClass(this.element.nativeElement, getSizeClass('treeview', this.size));
        }
    }
    /**
     * Blurs the focused TreeView item.
     */
    blur() {
        if (!isDocumentAvailable()) {
            return;
        }
        const target = focusableNode(this.element);
        if (document.activeElement === target) {
            target.blur();
        }
    }
    /**
     * Focuses the first focusable item in the TreeView component if no hierarchical index is provided.
     *
     * @example
     * ```ts
     * import { Component } from '@angular/core';
     *
     *  @Component({
     *      selector: 'my-app',
     *      template: `
     *      <button (click)="treeview.focus('1')">Focuses the second node</button>
     *      <kendo-treeview
     *          #treeview
     *          [nodes]="data"
     *          textField="text"
     *      >
     *      </kendo-treeview>
     *  `
     *  })
     *  export class AppComponent {
     *      public data: any[] = [
     *          { text: "Furniture" },
     *          { text: "Decor" }
     *      ];
     *  }
     * ```
     */
    focus(index) {
        const focusIndex = index || nodeIndex(this.navigationService.focusableItem);
        this.navigationService.activateIndex(focusIndex);
        const target = focusableNode(this.element);
        if (target) {
            target.focus();
        }
    }
    /**
     * Based on the specified index, returns the TreeItemLookup node.
     *
     * @param index - The index of the node.
     * @returns {TreeItemLookup} - The item that was searched (looked up).
     */
    itemLookup(index) {
        return this.treeViewLookupService.itemLookup(index);
    }
    /**
     * Triggers the [`children`]({% slug api_treeview_treeviewcomponent %}#toc-children) function for every expanded node,
     * causing all rendered child nodes to be fetched again.
     */
    rebindChildren() {
        this.dataChangeNotification.notify();
    }
    /**
     * Triggers the `expand` event for the provided node and displays it's loading indicator.
     */
    expandNode(item, index) {
        this.expandService.expand(index, item);
    }
    /**
     * Triggers the `collapse` event for the provided node.
     */
    collapseNode(item, index) {
        this.expandService.collapse(index, item);
    }
    /**
     * Gets the current page size of the checked data item children collection
     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).
     *
     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to get its page size.
     *
     * @param dataItem {any} - The parent data item of the targeted collection.
     * @returns {number} - The page size of the checked data item children collection.
     */
    getNodePageSize(dataItem) {
        this.verifyLoadMoreService();
        return this.loadMoreService.getGroupSize(dataItem);
    }
    /**
     * Sets the page size of the targeted data item children collection
     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).
     *
     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to target its page size.
     *
     * @param dataItem {any} - The parent data item of the targeted collection.
     * @param pageSize {number} - The new page size.
     */
    setNodePageSize(dataItem, pageSize) {
        this.verifyLoadMoreService();
        this.loadMoreService.setGroupSize(dataItem, pageSize);
    }
    /**
     * @hidden
     *
     * Clears the current TreeViewLookupService node map and re-registers all nodes anew.
     * Child nodes are acquired through the provided `children` callback.
     */
    preloadChildNodes() {
        this.treeViewLookupService.reset();
        this.registerLookupItems(this.nodes);
    }
    attachDomHandlers() {
        const element = this.element.nativeElement;
        this.clickHandler = this.clickHandler.bind(this);
        this.domSubscriptions.push(this.renderer.listen(element, 'contextmenu', this.clickHandler), this.renderer.listen(element, 'click', this.clickHandler), this.renderer.listen(element, 'dblclick', this.clickHandler), this.renderer.listen(element, 'focusin', this.focusHandler.bind(this)), this.renderer.listen(element, 'focusout', this.blurHandler.bind(this)), this.renderer.listen(element, 'keydown', this.keydownHandler.bind(this)));
    }
    focusHandler(e) {
        let focusItem;
        if (match(e.target, '.k-treeview-item')) {
            focusItem = e.target;
        }
        else if (!isFocusable(e.target)) { // with compliments to IE
            focusItem = closestNode(e.target);
        }
        if (focusItem) {
            this.navigationService.activateIndex(nodeId(e.target));
            if (!this.isActive && hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
            this.isActive = true;
        }
    }
    blurHandler(e) {
        if (this.isActive && match(e.target, '.k-treeview-item') &&
            (!e.relatedTarget || !match(e.relatedTarget, '.k-treeview-item') || !hasParent(e.relatedTarget, this.element.nativeElement))) {
            this.navigationService.deactivate();
            this.isActive = false;
            if (hasObservers(this.onBlur)) {
                this.ngZone.run(() => {
                    this.onBlur.emit();
                });
            }
        }
    }
    clickHandler(e) {
        const target = e.target;
        if ((e.type === 'contextmenu' && !hasObservers(this.nodeClick)) ||
            (e.type === 'click' && !hasObservers(this.nodeClick) && !hasObservers(this.selectionChange) && !isLoadMoreButton(target)) ||
            (e.type === 'dblclick' && !hasObservers(this.nodeDblClick)) || isFocusable(target) ||
            (!isContent(target) && !isLoadMoreButton(target)) || !hasParent(target, this.element.nativeElement)) {
            return;
        }
        const index = nodeId(closestNode(target));
        // the disabled check is probably not needed due to the k-disabled styles
        if (!index || this.navigationService.isDisabled(index)) {
            return;
        }
        this.ngZone.run(() => {
            // record this value before emitting selectionChange (`this.navigationService.selectIndex`), as the treeview state may be changed on its emission
            const lookup = this.treeViewLookupService.itemLookup(index);
            if (e.type === 'click') {
                const loadMoreButton = this.navigationService.model.findNode(index).loadMoreButton;
                if (loadMoreButton) {
                    this.navigationService.notifyLoadMore(index);
                    return;
                }
                else {
                    this.navigationService.selectIndex(index);
                }
            }
            const emitter = e.type === 'dblclick' ? this.nodeDblClick : this.nodeClick;
            emitter.emit({
                item: lookup.item,
                originalEvent: e,
                type: e.type
            });
        });
    }
    keydownHandler(e) {
        if (this.isActive && this.navigable) {
            this.ngZone.run(() => {
                this.navigationService.move(e);
            });
        }
    }
    verifyLoadMoreService() {
        if (isDevMode() && !isPresent(this.loadMoreService)) {
            throw new Error(`To use the TreeView paging functionality, you need to assign the \`kendoTreeViewLoadMore\` directive. See ${LOAD_MORE_DOC_LINK}.`);
        }
    }
    registerLookupItems(data, parentItem = null) {
        if (!isPresent(data) || data.length === 0) {
            return;
        }
        const parentIndex = nodeIndex(parentItem);
        const treeItems = data.map((node, index) => buildTreeItem(node, index, parentIndex));
        if (isPresent(parentItem)) {
            this.treeViewLookupService.registerChildren(parentIndex, treeItems);
        }
        treeItems.forEach(item => {
            this.treeViewLookupService.registerItem(item, parentItem);
            if (this.hasChildren(item.dataItem)) {
                this.children(item.dataItem)
                    .subscribe(children => this.registerLookupItems(children, item));
            }
        });
    }
};
TreeViewComponent.ɵfac = function TreeViewComponent_Factory(t) { return new (t || TreeViewComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(NodeChildrenService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(TreeViewLookupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DataChangeNotificationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
TreeViewComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TreeViewComponent, selectors: [["kendo-treeview"]], contentQueries: function TreeViewComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NodeTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, LoadMoreButtonTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nodeTemplateQuery = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadMoreButtonTemplateQuery = _t.first);
    } }, viewQuery: function TreeViewComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 7, ViewContainerRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.assetsContainer = _t.first);
    } }, hostVars: 5, hostBindings: function TreeViewComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("dir", ctx.direction);
        ɵngcc0.ɵɵsyntheticHostProperty("@.disabled", ctx.animate);
        ɵngcc0.ɵɵclassProp("k-treeview", ctx.classNames);
    } }, inputs: { filterInputPlaceholder: "filterInputPlaceholder", trackBy: "trackBy", isDisabled: "isDisabled", isVisible: "isVisible", navigable: "navigable", children: "children", loadOnDemand: "loadOnDemand", filterable: "filterable", filter: "filter", animate: "animate", nodeTemplateRef: ["nodeTemplate", "nodeTemplateRef"], loadMoreButtonTemplateRef: ["loadMoreButtonTemplate", "loadMoreButtonTemplateRef"], nodes: "nodes", hasChildren: "hasChildren", isChecked: "isChecked", isExpanded: "isExpanded", isSelected: "isSelected", size: "size", textField: "textField" }, outputs: { childrenLoaded: "childrenLoaded", onBlur: "blur", onFocus: "focus", expand: "expand", collapse: "collapse", nodeDragStart: "nodeDragStart", nodeDrag: "nodeDrag", filterStateChange: "filterStateChange", nodeDrop: "nodeDrop", nodeDragEnd: "nodeDragEnd", addItem: "addItem", removeItem: "removeItem", checkedChange: "checkedChange", selectionChange: "selectionChange", filterChange: "filterChange", nodeClick: "nodeClick", nodeDblClick: "nodeDblClick" }, exportAs: ["kendoTreeView"], features: [ɵngcc0.ɵɵProvidersFeature(providers), ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 20, consts: [["class", "k-treeview-filter", 4, "ngIf"], ["kendoTreeViewGroup", "", "role", "group", 1, "k-treeview-lines", 3, "size", "loadOnDemand", "checkboxes", "expandIcons", "selectable", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "isExpanded", "isSelected", "isVisible", "nodeTemplateRef", "loadMoreButtonTemplateRef", "textField", "nodes", "loadMoreService", "trackBy"], ["assetsContainer", ""], [1, "k-treeview-filter"], [3, "size", "value", "clearButton", "placeholder", "valueChange"], ["kendoTextBoxPrefixTemplate", ""], [1, "k-input-icon", "k-icon", "k-i-search"]], template: function TreeViewComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TreeViewComponent_span_0_Template, 3, 4, "span", 0);
        ɵngcc0.ɵɵelement(1, "ul", 1);
        ɵngcc0.ɵɵelementContainer(2, null, 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.filterable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("size", ctx.size)("loadOnDemand", ctx.loadOnDemand)("checkboxes", ctx.checkboxes)("expandIcons", ctx.expandIcons)("selectable", ctx.selectable)("touchActions", ctx.touchActions)("children", ctx.children)("hasChildren", ctx.hasChildren)("isChecked", ctx.isChecked)("isDisabled", ctx.isDisabled)("isExpanded", ctx.isExpanded)("isSelected", ctx.isSelected)("isVisible", ctx.isVisible)("nodeTemplateRef", ctx.nodeTemplateRef == null ? null : ctx.nodeTemplateRef.templateRef)("loadMoreButtonTemplateRef", ctx.loadMoreButtonTemplateRef == null ? null : ctx.loadMoreButtonTemplateRef.templateRef)("textField", ctx.textField)("nodes", ctx.fetchNodes)("loadMoreService", ctx.loadMoreService)("trackBy", ctx.trackBy);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc3.TextBoxComponent, ɵngcc3.TextBoxPrefixTemplateDirective, TreeViewGroupComponent]; }, encapsulation: 2 });
__decorate([
    HostBinding("class.k-treeview"),
    __metadata("design:type", Boolean)
], TreeViewComponent.prototype, "classNames", void 0);
__decorate([
    HostBinding("attr.role"),
    __metadata("design:type", String)
], TreeViewComponent.prototype, "role", void 0);
__decorate([
    HostBinding("attr.dir"),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], TreeViewComponent.prototype, "direction", null);
__decorate([
    ViewChild('assetsContainer', { read: ViewContainerRef, static: true }),
    __metadata("design:type", ViewContainerRef)
], TreeViewComponent.prototype, "assetsContainer", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TreeViewComponent.prototype, "filterInputPlaceholder", void 0);
__decorate([
    Input(),
    HostBinding('@.disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], TreeViewComponent.prototype, "animate", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "childrenLoaded", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "onBlur", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "onFocus", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "expand", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "collapse", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "nodeDragStart", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "nodeDrag", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "filterStateChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "nodeDrop", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "nodeDragEnd", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "addItem", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "removeItem", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "checkedChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "selectionChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "filterChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "nodeClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TreeViewComponent.prototype, "nodeDblClick", void 0);
__decorate([
    ContentChild(NodeTemplateDirective, { static: false }),
    __metadata("design:type", NodeTemplateDirective)
], TreeViewComponent.prototype, "nodeTemplateQuery", void 0);
__decorate([
    Input('nodeTemplate'),
    __metadata("design:type", NodeTemplateDirective),
    __metadata("design:paramtypes", [NodeTemplateDirective])
], TreeViewComponent.prototype, "nodeTemplateRef", null);
__decorate([
    ContentChild(LoadMoreButtonTemplateDirective, { static: false }),
    __metadata("design:type", LoadMoreButtonTemplateDirective)
], TreeViewComponent.prototype, "loadMoreButtonTemplateQuery", void 0);
__decorate([
    Input('loadMoreButtonTemplate'),
    __metadata("design:type", LoadMoreButtonTemplateDirective),
    __metadata("design:paramtypes", [LoadMoreButtonTemplateDirective])
], TreeViewComponent.prototype, "loadMoreButtonTemplateRef", null);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewComponent.prototype, "trackBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], TreeViewComponent.prototype, "nodes", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TreeViewComponent.prototype, "textField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], TreeViewComponent.prototype, "hasChildren", null);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], TreeViewComponent.prototype, "isChecked", null);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewComponent.prototype, "isDisabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], TreeViewComponent.prototype, "isExpanded", null);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], TreeViewComponent.prototype, "isSelected", null);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewComponent.prototype, "isVisible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewComponent.prototype, "navigable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewComponent.prototype, "children", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewComponent.prototype, "loadOnDemand", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewComponent.prototype, "filterable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TreeViewComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TreeViewComponent.prototype, "size", null);
TreeViewComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        ChangeDetectorRef,
        ExpandStateService,
        NavigationService,
        NodeChildrenService,
        SelectionService,
        TreeViewLookupService,
        NgZone,
        Renderer2,
        DataChangeNotificationService,
        LocalizationService])
], TreeViewComponent);

/**
 * @hidden
 */
let TreeViewGroupComponent = class TreeViewGroupComponent {
    constructor(expandService, loadingService, indexBuilder, treeViewLookupService, navigationService, nodeChildrenService, dataChangeNotification, changeDetectorRef) {
        this.expandService = expandService;
        this.loadingService = loadingService;
        this.indexBuilder = indexBuilder;
        this.treeViewLookupService = treeViewLookupService;
        this.navigationService = navigationService;
        this.nodeChildrenService = nodeChildrenService;
        this.dataChangeNotification = dataChangeNotification;
        this.changeDetectorRef = changeDetectorRef;
        this.kGroupClass = true;
        this.role = 'group';
        this.loadOnDemand = true;
        this.textField = "";
        this.size = 'medium';
        this.initialNodesLoaded = false;
        this.loadingMoreNodes = false;
        this._data = [];
        this.singleRecordSubscriptions = new Subscription();
        this.isChecked = () => 'none';
        this.isDisabled = () => false;
        this.isExpanded = () => false;
        this.isVisible = () => true;
        this.isSelected = () => false;
        this.children = () => of([]);
        this.hasChildren = () => false;
    }
    get moreNodesAvailable() {
        if (!isPresent(this.loadMoreService) || this.data.length === 0) {
            return false;
        }
        return this.pageSize < this.totalNodesCount;
    }
    get pageSize() {
        if (!isPresent(this.loadMoreService)) {
            return null;
        }
        return this.loadMoreService.getGroupSize(this.parentDataItem);
    }
    set pageSize(pageSize) {
        this.loadMoreService.setGroupSize(this.parentDataItem, pageSize);
    }
    get data() {
        if (isPresent(this.pageSize)) {
            const normalizedSizeValue = this.pageSize > 0 ? this.pageSize : 0;
            return this._data.slice(0, normalizedSizeValue);
        }
        return this._data;
    }
    set data(data) {
        this._data = data;
        this.registerLoadedNodes(this.data);
    }
    get loadMoreButtonIndex() {
        if (!this.loadMoreService) {
            return null;
        }
        return this.nodeIndex(this.data.length);
    }
    /**
     * Represents the total number of nodes for the current level.
     */
    get totalNodesCount() {
        if (!this.loadMoreService) {
            return this.data.length;
        }
        return this.loadMoreService.getTotalNodesCount(this.parentDataItem, this._data.length);
    }
    get hasTemplate() {
        return isPresent(this.nodeTemplateRef);
    }
    expandNode(index, dataItem, expand) {
        if (expand) {
            this.expandService.expand(index, dataItem);
        }
        else {
            this.expandService.collapse(index, dataItem);
        }
    }
    checkNode(index) {
        this.navigationService.checkIndex(index);
        this.navigationService.activateIndex(index);
    }
    nodeIndex(index) {
        return this.indexBuilder.nodeIndex(index.toString(), this.parentIndex);
    }
    nodeText(dataItem) {
        const textField = isArray(this.textField) ? this.textField[0] : this.textField;
        return getter(textField)(dataItem);
    }
    ngOnDestroy() {
        if (isPresent(this.nodesSubscription)) {
            this.nodesSubscription.unsubscribe();
        }
        if (isPresent(this.loadMoreNodesSubscription)) {
            this.loadMoreNodesSubscription.unsubscribe();
        }
        this.singleRecordSubscriptions.unsubscribe();
    }
    ngOnInit() {
        this.subscribeToNodesChange();
        this.singleRecordSubscriptions.add(this.dataChangeNotification
            .changes
            .subscribe(this.subscribeToNodesChange.bind(this)));
        this.singleRecordSubscriptions.add(this.navigationService.loadMore
            .pipe(filter(index => index === this.loadMoreButtonIndex))
            .subscribe(this.loadMoreNodes.bind(this)));
    }
    ngOnChanges(changes) {
        if (changes.parentIndex && this.loadOnDemand) {
            this.setNodeChildren(this.mapToTreeItem(this.data));
        }
    }
    fetchChildren(node, index) {
        return this.children(node)
            .pipe(catchError(() => {
            this.loadingService.notifyLoaded(index);
            return EMPTY;
        }), tap(() => this.loadingService.notifyLoaded(index)));
    }
    get nextFields() {
        if (isArray(this.textField)) {
            return this.textField.length > 1 ? this.textField.slice(1) : this.textField;
        }
        return [this.textField];
    }
    loadMoreNodes() {
        if (isPresent(this.loadMoreService.loadMoreNodes)) {
            this.fetchMoreNodes();
        }
        else {
            this.loadMoreLocalNodes();
        }
    }
    loadMoreLocalNodes() {
        const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;
        this.pageSize += this.loadMoreService.getInitialPageSize(this.parentDataItem);
        this.registerLoadedNodes(this.data);
        // forces the new items to be registered before the focus is changed
        this.changeDetectorRef.detectChanges();
        this.reselectItemAt(initialLoadMoreButtonIndex);
    }
    fetchMoreNodes() {
        if (this.loadingMoreNodes) {
            return;
        }
        this.loadingMoreNodes = true;
        if (isPresent(this.loadMoreNodesSubscription)) {
            this.loadMoreNodesSubscription.unsubscribe();
        }
        this.loadMoreNodesSubscription = this.loadMoreService
            .loadMoreNodes({
            dataItem: this.parentDataItem,
            skip: this.data.length,
            take: this.loadMoreService.getInitialPageSize(this.parentDataItem)
        })
            .pipe(finalize(() => this.loadingMoreNodes = false))
            .subscribe(items => {
            if (!(Array.isArray(items) && items.length > 0)) {
                return;
            }
            const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;
            this.pageSize += items.length;
            this.data = this.data.concat(items);
            if (this.navigationService.isActive(initialLoadMoreButtonIndex)) {
                // forces the new items to be registered before the focus is changed
                this.changeDetectorRef.detectChanges();
                this.reselectItemAt(initialLoadMoreButtonIndex);
            }
        });
    }
    setNodeChildren(children) {
        this.treeViewLookupService.registerChildren(this.parentIndex, children);
    }
    mapToTreeItem(data) {
        if (!this.parentIndex) {
            return [];
        }
        return data.map((dataItem, idx) => ({ dataItem, index: this.nodeIndex(idx) }));
    }
    emitChildrenLoaded(children) {
        if (!this.parentIndex) {
            return;
        }
        // ignores the registered load-more button
        const contentChildren = children.filter(item => item.dataItem);
        this.nodeChildrenService.childrenLoaded({ dataItem: this.parentDataItem, index: this.parentIndex }, contentChildren);
    }
    subscribeToNodesChange() {
        if (this.nodesSubscription) {
            this.nodesSubscription.unsubscribe();
        }
        this.nodesSubscription = this.nodes(this.parentDataItem, this.parentIndex)
            .subscribe(data => {
            this.data = data;
            this.initialNodesLoaded = true;
        });
    }
    reselectItemAt(index) {
        if (!isPresent(index)) {
            return;
        }
        // make sure the old index is cleared first
        this.navigationService.deactivate();
        this.navigationService.activateIndex(index);
    }
    registerLoadedNodes(nodes = []) {
        const mappedChildren = this.mapToTreeItem(nodes);
        if (this.loadOnDemand) {
            this.setNodeChildren(mappedChildren);
        }
        this.emitChildrenLoaded(mappedChildren);
    }
};
TreeViewGroupComponent.ɵfac = function TreeViewGroupComponent_Factory(t) { return new (t || TreeViewGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(LoadingNotificationService), ɵngcc0.ɵɵdirectiveInject(IndexBuilderService), ɵngcc0.ɵɵdirectiveInject(TreeViewLookupService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(NodeChildrenService), ɵngcc0.ɵɵdirectiveInject(DataChangeNotificationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
TreeViewGroupComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TreeViewGroupComponent, selectors: [["", "kendoTreeViewGroup", ""]], hostVars: 3, hostBindings: function TreeViewGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("k-treeview-group", ctx.kGroupClass);
    } }, inputs: { loadOnDemand: "loadOnDemand", textField: "textField", size: "size", isChecked: "isChecked", isDisabled: "isDisabled", isExpanded: "isExpanded", isVisible: "isVisible", isSelected: "isSelected", children: "children", hasChildren: "hasChildren", checkboxes: "checkboxes", expandIcons: "expandIcons", disabled: "disabled", selectable: "selectable", touchActions: "touchActions", trackBy: "trackBy", nodes: "nodes", parentDataItem: "parentDataItem", parentIndex: "parentIndex", nodeTemplateRef: "nodeTemplateRef", loadMoreButtonTemplateRef: "loadMoreButtonTemplateRef", loadMoreService: "loadMoreService" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c1, decls: 2, vars: 3, consts: [["class", "k-treeview-item", "kendoTreeViewItem", "", 3, "k-display-none", "dataItem", "index", "parentDataItem", "parentIndex", "loadOnDemand", "checkable", "isChecked", "isDisabled", "isVisible", "expandable", "isExpanded", "selectable", "isSelected", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "k-treeview-item", "kendoTreeViewItem", "", "role", "button", 3, "k-treeview-load-more-checkboxes-container", "selectable", "checkable", "expandable", "index", "parentDataItem", "parentIndex", 4, "ngIf"], ["kendoTreeViewItem", "", 1, "k-treeview-item", 3, "dataItem", "index", "parentDataItem", "parentIndex", "loadOnDemand", "checkable", "isChecked", "isDisabled", "isVisible", "expandable", "isExpanded", "selectable", "isSelected"], [1, "k-treeview-mid"], ["class", "k-treeview-toggle", 3, "kendoTreeViewLoading", "click", 4, "ngIf"], ["tabindex", "-1", 3, "size", "node", "index", "isChecked", "checkStateChange", 4, "ngIf"], ["kendoTreeViewItemContent", "", 1, "k-treeview-leaf", 3, "dataItem", "index", "initialSelection", "isSelected"], [1, "k-treeview-leaf-text"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], ["kendoTreeViewGroup", "", "role", "group", 3, "nodes", "loadOnDemand", "checkboxes", "expandIcons", "selectable", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "disabled", "isExpanded", "isSelected", "isVisible", "nodeTemplateRef", "loadMoreButtonTemplateRef", "parentIndex", "parentDataItem", "textField", "loadMoreService", "trackBy", 4, "ngIf"], [1, "k-treeview-toggle", 3, "kendoTreeViewLoading", "click"], [1, "k-icon"], ["tabindex", "-1", 3, "size", "node", "index", "isChecked", "checkStateChange"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoTreeViewGroup", "", "role", "group", 3, "nodes", "loadOnDemand", "checkboxes", "expandIcons", "selectable", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "disabled", "isExpanded", "isSelected", "isVisible", "nodeTemplateRef", "loadMoreButtonTemplateRef", "parentIndex", "parentDataItem", "textField", "loadMoreService", "trackBy"], ["kendoTreeViewItem", "", "role", "button", 1, "k-treeview-item", 3, "selectable", "checkable", "expandable", "index", "parentDataItem", "parentIndex"], ["class", "k-icon k-i-loading k-i-expand", 4, "ngIf"], ["kendoTreeViewItemContent", "", 1, "k-treeview-leaf", "k-treeview-load-more-button", 3, "index"], [4, "ngIf"], [1, "k-icon", "k-i-loading", "k-i-expand"]], template: function TreeViewGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TreeViewGroupComponent_li_0_Template, 10, 29, "li", 0);
        ɵngcc0.ɵɵtemplate(1, TreeViewGroupComponent_li_1_Template, 7, 14, "li", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.initialNodesLoaded && ctx.moreNodesAvailable);
    } }, directives: function () { return [ɵngcc2.NgForOf, TreeViewItemDirective, ɵngcc2.NgIf, LoadingIndicatorDirective, CheckBoxComponent, TreeViewItemContentDirective, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgSwitchDefault, TreeViewGroupComponent]; }, encapsulation: 2, data: { animation: [
            trigger('toggle', [
                transition('void => *', [
                    style({ height: 0 }),
                    animate('0.1s ease-in', style({ height: "*" }))
                ]),
                transition('* => void', [
                    style({ height: "*" }),
                    animate('0.1s ease-in', style({ height: 0 }))
                ])
            ])
        ] } });
__decorate([
    HostBinding("class.k-treeview-group"),
    __metadata("design:type", Boolean)
], TreeViewGroupComponent.prototype, "kGroupClass", void 0);
__decorate([
    HostBinding("attr.role"),
    __metadata("design:type", String)
], TreeViewGroupComponent.prototype, "role", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewGroupComponent.prototype, "checkboxes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewGroupComponent.prototype, "expandIcons", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewGroupComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewGroupComponent.prototype, "selectable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewGroupComponent.prototype, "touchActions", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewGroupComponent.prototype, "loadOnDemand", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewGroupComponent.prototype, "trackBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewGroupComponent.prototype, "nodes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TreeViewGroupComponent.prototype, "textField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TreeViewGroupComponent.prototype, "parentDataItem", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TreeViewGroupComponent.prototype, "parentIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], TreeViewGroupComponent.prototype, "nodeTemplateRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], TreeViewGroupComponent.prototype, "loadMoreButtonTemplateRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TreeViewGroupComponent.prototype, "loadMoreService", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TreeViewGroupComponent.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewGroupComponent.prototype, "isChecked", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewGroupComponent.prototype, "isDisabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewGroupComponent.prototype, "isExpanded", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewGroupComponent.prototype, "isVisible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewGroupComponent.prototype, "isSelected", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewGroupComponent.prototype, "children", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewGroupComponent.prototype, "hasChildren", void 0);
TreeViewGroupComponent = __decorate([ __metadata("design:paramtypes", [ExpandStateService,
        LoadingNotificationService,
        IndexBuilderService,
        TreeViewLookupService,
        NavigationService,
        NodeChildrenService,
        DataChangeNotificationService,
        ChangeDetectorRef])
], TreeViewGroupComponent);

const indexChecked = (keys, index) => keys.filter(k => k === index).length > 0;
const matchKey = index => k => {
    if (index === k) {
        return true;
    }
    if (!k.split) {
        return false;
    }
    return k.split('_').reduce(({ key, result }, part) => {
        key += part;
        if (index === key || result) {
            return { result: true };
        }
        key += "_";
        return { key, result: false };
    }, { key: "", result: false }).result;
};
/**
 * A directive which manages the in-memory checked state of the TreeView node
 * ([see example]({% slug checkboxes_treeview %})).
 */
let CheckDirective = class CheckDirective {
    constructor(treeView, zone) {
        this.treeView = treeView;
        this.zone = zone;
        /**
         * Fires when the `checkedKeys` collection was updated.
         */
        this.checkedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        this.checkActions = {
            'multiple': (e) => this.checkMultiple(e),
            'single': (e) => this.checkSingle(e)
        };
        /**
         * Reflectes the internal `checkedKeys` state.
         */
        this.state = new Set();
        this.subscriptions.add(this.treeView.checkedChange
            .subscribe((e) => this.check(e)));
        let expandedItems = [];
        this.subscriptions.add(this.treeView.childrenLoaded
            .pipe(filter(() => this.options.checkChildren && this.treeView.loadOnDemand), tap(item => expandedItems.push(item)), switchMap(() => this.zone.onStable.pipe(take(1))))
            .subscribe(() => this.addCheckedItemsChildren(expandedItems)));
        this.treeView.isChecked = this.isItemChecked.bind(this);
    }
    /**
     * @hidden
     */
    set isChecked(value) {
        this.treeView.isChecked = value;
    }
    get options() {
        const defaultOptions = {
            checkChildren: true,
            checkParents: true,
            enabled: true,
            mode: "multiple"
        };
        if (!isPresent(this.checkable) || typeof this.checkable === 'string') {
            return defaultOptions;
        }
        const checkSettings = isBoolean(this.checkable)
            ? { enabled: this.checkable }
            : this.checkable;
        return Object.assign(defaultOptions, checkSettings);
    }
    ngOnChanges(changes) {
        if (changes.checkable) {
            this.treeView.checkboxes = this.options.enabled;
            this.toggleCheckOnClick();
        }
        if (isChanged('checkedKeys', changes, false) && changes.checkedKeys.currentValue !== this.lastChange) {
            this.state = new Set(changes.checkedKeys.currentValue);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.unsubscribeClick();
    }
    isItemChecked(dataItem, index) {
        if (!this.checkKey) {
            return this.isIndexChecked(index);
        }
        const hasKey = this.state.has(this.itemKey({ dataItem, index }));
        return hasKey ? 'checked' : 'none';
    }
    isIndexChecked(index) {
        const checkedKeys = Array.from(this.state).filter(matchKey(index));
        if (indexChecked(checkedKeys, index)) {
            return 'checked';
        }
        const { mode, checkParents } = this.options;
        if (mode === 'multiple' && checkParents && checkedKeys.length) {
            return 'indeterminate';
        }
        return 'none';
    }
    itemKey(item) {
        if (!isPresent(this.checkKey)) {
            return item.index;
        }
        if (typeof this.checkKey === "string" && isPresent(item.dataItem)) {
            return item.dataItem[this.checkKey];
        }
        if (typeof this.checkKey === "function") {
            return this.checkKey(item);
        }
    }
    check(e) {
        const { enabled, mode } = this.options;
        const performSelection = this.checkActions[mode] || noop;
        if (!enabled) {
            return;
        }
        performSelection(e);
    }
    checkSingle(node) {
        const key = this.itemKey(node.item);
        const hasKey = this.state.has(key);
        this.state.clear();
        if (!hasKey) {
            this.state.add(key);
        }
        this.notify();
    }
    checkMultiple(node) {
        this.checkNode(node);
        if (this.options.checkParents) {
            this.checkParents(node.parent);
        }
        this.notify();
    }
    toggleCheckOnClick() {
        this.unsubscribeClick();
        if (this.options.checkOnClick) {
            this.clickSubscription = this.treeView.nodeClick.subscribe(args => {
                if (args.type === 'click') {
                    const lookup = this.treeView.itemLookup(args.item.index);
                    this.check(lookup);
                }
            });
        }
    }
    unsubscribeClick() {
        if (this.clickSubscription) {
            this.clickSubscription.unsubscribe();
            this.clickSubscription = null;
        }
    }
    checkNode(node) {
        if (!isPresent(node.item.dataItem) || this.treeView.isDisabled(node.item.dataItem, node.item.index)) {
            return;
        }
        const currentKey = this.itemKey(node.item);
        if (!isPresent(currentKey)) {
            return;
        }
        const pendingCheck = [currentKey];
        if (this.options.checkChildren) {
            const descendants = fetchLoadedDescendants(node, ({ item }) => this.treeView.isVisible(item.dataItem, item.index) &&
                !this.treeView.isDisabled(item.dataItem, item.index))
                .map(({ item }) => this.itemKey(item));
            pendingCheck.push(...descendants);
        }
        const shouldCheck = !this.state.has(currentKey);
        pendingCheck.forEach(key => {
            if (shouldCheck) {
                this.state.add(key);
            }
            else {
                this.state.delete(key);
            }
        });
    }
    checkParents(parent) {
        if (!isPresent(parent)) {
            return;
        }
        let currentParent = parent;
        while (currentParent) {
            const parentKey = this.itemKey(currentParent.item);
            const allChildrenSelected = currentParent.children.every(item => this.state.has(this.itemKey(item)));
            if (allChildrenSelected) {
                this.state.add(parentKey);
            }
            else {
                this.state.delete(parentKey);
            }
            currentParent = currentParent.parent;
        }
    }
    notify() {
        this.lastChange = Array.from(this.state);
        this.checkedKeysChange.emit(this.lastChange);
    }
    addCheckedItemsChildren(lookups) {
        if (!isPresent(lookups) || lookups.length === 0) {
            return;
        }
        const initiallyCheckedItemsCount = this.state.size;
        lookups.forEach(lookup => {
            const itemKey = this.itemKey(lookup.item);
            if (!this.state.has(itemKey)) {
                return;
            }
            lookup.children.forEach(item => {
                // ensure both the parent item and each child node is enabled
                if (!this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index) &&
                    !this.treeView.isDisabled(item.dataItem, item.index)) {
                    this.state.add(this.itemKey(item));
                }
            });
        });
        const hasNewlyCheckedItems = initiallyCheckedItemsCount !== this.state.size;
        if (hasNewlyCheckedItems) {
            this.zone.run(() => this.notify());
        }
    }
};
CheckDirective.ɵfac = function CheckDirective_Factory(t) { return new (t || CheckDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
CheckDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CheckDirective, selectors: [["", "kendoTreeViewCheckable", ""]], inputs: { isChecked: "isChecked", checkKey: ["checkBy", "checkKey"], checkedKeys: "checkedKeys", checkable: ["kendoTreeViewCheckable", "checkable"] }, outputs: { checkedKeysChange: "checkedKeysChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], CheckDirective.prototype, "isChecked", null);
__decorate([
    Input("checkBy"),
    __metadata("design:type", Object)
], CheckDirective.prototype, "checkKey", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], CheckDirective.prototype, "checkedKeys", void 0);
__decorate([
    Input('kendoTreeViewCheckable'),
    __metadata("design:type", Object)
], CheckDirective.prototype, "checkable", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], CheckDirective.prototype, "checkedKeysChange", void 0);
CheckDirective = __decorate([ __metadata("design:paramtypes", [TreeViewComponent,
        NgZone])
], CheckDirective);

/**
 * A directive which manages the disabled in-memory state of the TreeView node
 * ([see example]({% slug disabledstate_treeview %})).
 */
let DisableDirective = class DisableDirective {
    constructor(treeView, cdr) {
        this.treeView = treeView;
        this.cdr = cdr;
        /**
         * Defines the collection that will store the disabled keys.
         */
        this.disabledKeys = [];
        this.treeView.isDisabled = (dataItem, index) => (this.disabledKeys.indexOf(this.itemKey({ dataItem, index })) > -1);
    }
    /**
     * @hidden
     */
    set isDisabled(value) {
        this.treeView.isDisabled = value;
    }
    ngOnChanges(changes = {}) {
        const { disabledKeys } = changes;
        if (disabledKeys && !disabledKeys.firstChange) {
            this.cdr.markForCheck();
        }
    }
    itemKey(e) {
        if (!this.disableKey) {
            return e.index;
        }
        if (typeof this.disableKey === "string") {
            return e.dataItem[this.disableKey];
        }
        if (typeof this.disableKey === "function") {
            return this.disableKey(e);
        }
    }
};
DisableDirective.ɵfac = function DisableDirective_Factory(t) { return new (t || DisableDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
DisableDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DisableDirective, selectors: [["", "kendoTreeViewDisable", ""]], inputs: { disabledKeys: "disabledKeys", isDisabled: "isDisabled", disableKey: ["kendoTreeViewDisable", "disableKey"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], DisableDirective.prototype, "isDisabled", null);
__decorate([
    Input("kendoTreeViewDisable"),
    __metadata("design:type", Object)
], DisableDirective.prototype, "disableKey", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], DisableDirective.prototype, "disabledKeys", void 0);
DisableDirective = __decorate([ __metadata("design:paramtypes", [TreeViewComponent,
        ChangeDetectorRef])
], DisableDirective);

const DEFAULT_FILTER_EXPAND_SETTINGS = {
    maxAutoExpandResults: -1,
    expandMatches: false,
    expandedOnClear: "none"
};
/**
 * A directive which manages the expanded state of the TreeView.
 * ([see example]({% slug expandedstate_treeview %})).
 */
let ExpandDirective = class ExpandDirective {
    constructor(component) {
        this.component = component;
        /**
         * Whether or not to auto-expand the nodes leading from the root node to each filter result.
         * To fine-tune this behavior, pass a [`FilterExpandSettings`]({% slug api_treeview_filterexpandsettings %}) object to this input.
         * @default false
         */
        this.expandOnFilter = false;
        /**
         * Fires when the `expandedKeys` collection was updated.
         */
        this.expandedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        /**
         * Reflectes the internal `expandedKeys` state.
         */
        this.state = new Set();
        this.originalExpandedKeys = new Set();
        this.isFiltered = false;
        /**
         * Fills array with the correct expand keys according to wrapper metadata.
         */
        this.updateExpandedNodes = (collection, node, autoExpandMatches) => {
            if (node.containsMatches || node.isMatch && autoExpandMatches && isArrayWithAtLeastOneItem(node.children)) {
                collection.push(this.itemKey({ dataItem: node.dataItem, index: node.index }));
            }
            if (isArrayWithAtLeastOneItem(node.children)) {
                node.children.forEach(child => {
                    this.updateExpandedNodes(collection, child, autoExpandMatches);
                });
            }
        };
        /**
         * Fills array with the expand key of every node.
         */
        this.getEveryExpandKey = (collection, node) => {
            if (isArrayWithAtLeastOneItem(node.children)) {
                collection.push(this.itemKey({ dataItem: node.dataItem, index: node.index }));
            }
            if (isArrayWithAtLeastOneItem(node.children)) {
                node.children.forEach(child => {
                    this.getEveryExpandKey(collection, child);
                });
            }
        };
        this.subscriptions.add(merge(this.component.expand.pipe(map(e => (Object.assign({ expand: true }, e)))), this.component.collapse.pipe(map(e => (Object.assign({ expand: false }, e))))).subscribe(this.toggleExpand.bind(this)));
        if (this.component.filterStateChange) {
            this.subscriptions.add(this.component.filterStateChange.subscribe(this.handleAutoExpand.bind(this)));
        }
        this.component.isExpanded = (dataItem, index) => this.state.has(this.itemKey({ dataItem, index }));
    }
    /**
     * @hidden
     */
    set isExpanded(value) {
        this.component.isExpanded = value;
    }
    get filterExpandSettings() {
        const settings = isBoolean(this.expandOnFilter) ? { enabled: this.expandOnFilter } : Object.assign({}, this.expandOnFilter, { enabled: true });
        return Object.assign({}, DEFAULT_FILTER_EXPAND_SETTINGS, settings);
    }
    ngOnChanges(changes) {
        if (isChanged('expandedKeys', changes, false) && changes.expandedKeys.currentValue !== this.lastChange) {
            this.state = new Set(changes.expandedKeys.currentValue);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    itemKey(e) {
        if (this.expandKey) {
            if (typeof this.expandKey === "string") {
                return e.dataItem[this.expandKey];
            }
            if (typeof this.expandKey === "function") {
                return this.expandKey(e);
            }
        }
        return e.index;
    }
    toggleExpand({ index, dataItem, expand }) {
        const key = this.itemKey({ index, dataItem });
        const isExpanded = this.state.has(key);
        let notify = false;
        if (isExpanded && !expand) {
            this.state.delete(key);
            notify = true;
        }
        else if (!isExpanded && expand) {
            this.state.add(key);
            notify = true;
        }
        if (notify) {
            this.notify();
        }
    }
    handleAutoExpand({ nodes, matchCount, term }) {
        if (!this.filterExpandSettings.enabled) {
            return;
        }
        const { maxAutoExpandResults, expandMatches: autoExpandMatches, expandedOnClear } = this.filterExpandSettings;
        if (!this.isFiltered) {
            this.originalExpandedKeys = new Set(this.state);
        }
        const exitingFilteredState = this.isFiltered && !term;
        const maxExceeded = maxAutoExpandResults !== -1 && matchCount > maxAutoExpandResults;
        const exitAutoExpandedState = exitingFilteredState || maxExceeded;
        if (exitAutoExpandedState) {
            switch (expandedOnClear) {
                case "initial": {
                    if (!sameValues(this.state, this.originalExpandedKeys)) {
                        this.state = this.originalExpandedKeys;
                        this.notify();
                    }
                    break;
                }
                case "all": {
                    this.state = new Set(nodes.reduce((acc, rootNode) => {
                        this.getEveryExpandKey(acc, rootNode);
                        return acc;
                    }, []));
                    this.notify();
                    break;
                }
                case "unchanged": {
                    break;
                }
                case "none":
                default: {
                    if (this.state.size !== 0) {
                        this.state.clear();
                        this.notify();
                    }
                    break;
                }
            }
            this.isFiltered = false;
            return;
        }
        const indicesToExpand = new Set(nodes.reduce((acc, rootNode) => {
            this.updateExpandedNodes(acc, rootNode, autoExpandMatches);
            return acc;
        }, []));
        if (!sameValues(this.state, indicesToExpand)) {
            this.state = indicesToExpand;
            this.notify();
        }
        this.isFiltered = true;
    }
    notify() {
        this.lastChange = Array.from(this.state);
        this.expandedKeysChange.emit(this.lastChange);
    }
};
ExpandDirective.ɵfac = function ExpandDirective_Factory(t) { return new (t || ExpandDirective)(ɵngcc0.ɵɵdirectiveInject(ExpandableComponent)); };
ExpandDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ExpandDirective, selectors: [["", "kendoTreeViewExpandable", ""]], inputs: { expandOnFilter: "expandOnFilter", isExpanded: "isExpanded", expandKey: ["expandBy", "expandKey"], expandedKeys: "expandedKeys" }, outputs: { expandedKeysChange: "expandedKeysChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], ExpandDirective.prototype, "isExpanded", null);
__decorate([
    Input("expandBy"),
    __metadata("design:type", Object)
], ExpandDirective.prototype, "expandKey", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ExpandDirective.prototype, "expandOnFilter", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ExpandDirective.prototype, "expandedKeysChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ExpandDirective.prototype, "expandedKeys", void 0);
ExpandDirective = __decorate([ __metadata("design:paramtypes", [ExpandableComponent])
], ExpandDirective);

/**
 * A directive which manages the in-memory selection state of the TreeView node
 * ([see example]({% slug selection_treeview %})).
 */
let SelectDirective = class SelectDirective {
    constructor(treeView) {
        this.treeView = treeView;
        /**
         * Fires when the `selectedKeys` collection was updated.
         */
        this.selectedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        this.selectActions = {
            'multiple': (e) => this.selectMultiple(e),
            'single': (e) => this.selectSingle(e)
        };
        /**
         * Reflectes the internal `selectedKeys` state.
         */
        this.state = new Set();
        this.subscriptions.add(this.treeView.selectionChange.subscribe(this.select.bind(this)));
        this.treeView.isSelected = (dataItem, index) => (this.state.has(this.itemKey({ dataItem, index })));
    }
    /**
     * @hidden
     */
    set isSelected(value) {
        this.treeView.isSelected = value;
    }
    get getAriaMultiselectable() {
        return this.options.mode === 'multiple';
    }
    get options() {
        const defaultOptions = {
            enabled: true,
            mode: 'single'
        };
        if (!isPresent(this.selection) || typeof this.selection === 'string') {
            return defaultOptions;
        }
        const selectionSettings = isBoolean(this.selection) ? { enabled: this.selection } : this.selection;
        return Object.assign(defaultOptions, selectionSettings);
    }
    ngOnChanges(changes) {
        if (isChanged('selectedKeys', changes, false) && changes.selectedKeys.currentValue !== this.lastChange) {
            this.state = new Set(changes.selectedKeys.currentValue);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    itemKey(e) {
        if (!this.selectKey) {
            return e.index;
        }
        if (typeof this.selectKey === 'string') {
            return e.dataItem[this.selectKey];
        }
        if (typeof this.selectKey === 'function') {
            return this.selectKey(e);
        }
    }
    select(e) {
        const { enabled, mode } = this.options;
        const performSelection = this.selectActions[mode] || noop;
        if (!enabled) {
            return;
        }
        performSelection(e);
    }
    selectSingle(node) {
        const key = this.itemKey(node);
        if (!this.state.has(key)) {
            this.state.clear();
            this.state.add(key);
            this.notify();
        }
    }
    selectMultiple(node) {
        const key = this.itemKey(node);
        const isSelected = this.state.has(key);
        if (!isPresent(key)) {
            return;
        }
        if (isSelected) {
            this.state.delete(key);
        }
        else {
            this.state.add(key);
        }
        this.notify();
    }
    notify() {
        this.lastChange = Array.from(this.state);
        this.selectedKeysChange.emit(this.lastChange);
    }
};
SelectDirective.ɵfac = function SelectDirective_Factory(t) { return new (t || SelectDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent)); };
SelectDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SelectDirective, selectors: [["", "kendoTreeViewSelectable", ""]], hostVars: 1, hostBindings: function SelectDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-multiselectable", ctx.getAriaMultiselectable);
    } }, inputs: { isSelected: "isSelected", selectKey: ["selectBy", "selectKey"], selection: ["kendoTreeViewSelectable", "selection"], selectedKeys: "selectedKeys" }, outputs: { selectedKeysChange: "selectedKeysChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], SelectDirective.prototype, "isSelected", null);
__decorate([
    Input('selectBy'),
    __metadata("design:type", Object)
], SelectDirective.prototype, "selectKey", void 0);
__decorate([
    Input('kendoTreeViewSelectable'),
    __metadata("design:type", Object)
], SelectDirective.prototype, "selection", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SelectDirective.prototype, "selectedKeys", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], SelectDirective.prototype, "selectedKeysChange", void 0);
__decorate([
    HostBinding('attr.aria-multiselectable'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SelectDirective.prototype, "getAriaMultiselectable", null);
SelectDirective = __decorate([ __metadata("design:paramtypes", [TreeViewComponent])
], SelectDirective);

/**
 * Describes the attempted drop action during dragging.
 * Passed as `action` value to the [`kendoTreeViewDragClueTemplate`]({% slug api_treeview_dragcluetemplatedirective %}) directive.
 * By default, this value defines the rendered icon in the drag clue.
 */
var DropAction;
(function (DropAction) {
    DropAction[DropAction["Add"] = 0] = "Add";
    DropAction[DropAction["InsertTop"] = 1] = "InsertTop";
    DropAction[DropAction["InsertBottom"] = 2] = "InsertBottom";
    DropAction[DropAction["InsertMiddle"] = 3] = "InsertMiddle";
    DropAction[DropAction["Invalid"] = 4] = "Invalid";
})(DropAction || (DropAction = {}));

/**
 * Describes where the dragged item is dropped relative to the drop target item.
 */
var DropPosition;
(function (DropPosition) {
    DropPosition[DropPosition["Over"] = 0] = "Over";
    DropPosition[DropPosition["Before"] = 1] = "Before";
    DropPosition[DropPosition["After"] = 2] = "After";
})(DropPosition || (DropPosition = {}));

/**
 * @hidden
 */
var ScrollDirection;
(function (ScrollDirection) {
    ScrollDirection[ScrollDirection["Up"] = -1] = "Up";
    ScrollDirection[ScrollDirection["Down"] = 1] = "Down";
})(ScrollDirection || (ScrollDirection = {}));

/**
 * @hidden
 */
class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the TreeView [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop) event.
 */
class TreeItemDropEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(initializer, originalEvent) {
        super();
        /**
         * @hidden
         */
        this.isValid = true;
        Object.assign(this, initializer);
        this.originalEvent = originalEvent;
    }
    /**
     * Specifies if the drop action should be marked as valid.
     * If set to `false`, the [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
     * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events will not be fired and the drag clue
     * will be animated back to the source item to indicate the action is marked as invalid.
     */
    setValid(isValid) {
        this.isValid = isValid;
    }
}

/**
 * Arguments for the TreeView [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart) event.
 */
class TreeItemDragStartEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(initializer) {
        super();
        Object.assign(this, initializer);
    }
}

/**
 * Arguments for the TreeView [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag) and
 * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend) events.
 */
class TreeItemDragEvent {
}

const ɵ0$3 = () => {
    if (!(isDocumentAvailable() && isPresent(document.body))) {
        return false;
    }
    const top = 10;
    const parent = document.createElement("div");
    parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
    parent.innerHTML = `<div style="position: fixed; top: ${top}px;">child</div>`;
    document.body.appendChild(parent);
    const isDifferent = parent.children[0].getBoundingClientRect().top !== top;
    document.body.removeChild(parent);
    return isDifferent;
};
/**
 * Checks if the browser supports relative stacking context.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 */
const hasRelativeStackingContext = memoize(ɵ0$3);
/**
 * Stores the result of the passed function's first invokation and returns it instead of invoking it again afterwards.
 */
function memoize(fn) {
    let result;
    let called = false;
    return (...args) => {
        if (called) {
            return result;
        }
        result = fn(...args);
        called = true;
        return result;
    };
}
/**
 * @hidden
 *
 * Gets the offset of the parent element if the latter has the `transform` CSS prop applied.
 * Transformed parents create new stacking context and the `fixed` children must be position based on the transformed parent.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 *
 * If no parent container is `transform`-ed the function will return `{ left: 0, top: 0 }`;
 */
const getContainerOffset = (element) => {
    if (!(element && hasRelativeStackingContext())) {
        return { left: 0, top: 0 };
    }
    let offsetParent = element.parentElement;
    while (offsetParent) {
        if (window.getComputedStyle(offsetParent).transform !== 'none') {
            break;
        }
        offsetParent = offsetParent.parentElement;
    }
    if (offsetParent) {
        const rect = offsetParent.getBoundingClientRect();
        return {
            left: rect.left - offsetParent.scrollLeft,
            top: rect.top - offsetParent.scrollTop
        };
    }
    return { left: 0, top: 0 };
};
/**
 * @hidden
 */
const getDropAction = (dropPosition, dropTarget) => {
    if (!(isPresent(dropPosition) && isPresent(dropTarget))) {
        return DropAction.Invalid;
    }
    switch (dropPosition) {
        case DropPosition.Over:
            return DropAction.Add;
        case DropPosition.Before:
            return isPresent(closestNode(dropTarget).previousElementSibling) ? DropAction.InsertMiddle : DropAction.InsertTop;
        case DropPosition.After:
            return isPresent(closestNode(dropTarget).nextElementSibling) ? DropAction.InsertMiddle : DropAction.InsertBottom;
        default:
            return DropAction.Invalid;
    }
};
/**
 * @hidden
 */
const getDropPosition = (draggedItem, target, clientY, targetTreeView, containerOffset) => {
    if (!(isPresent(draggedItem) && isPresent(target) && isPresent(targetTreeView) && isPresent(containerOffset))) {
        return;
    }
    // the .k-treeview-mid element starts just after the checkbox/expand arrow and stretches till the end of the treeview on the right
    const item = closestWithMatch(target, '.k-treeview-mid');
    if (!isPresent(item)) {
        return;
    }
    // the content element (.k-treeview-leaf:not(.k-treeview-load-more-button)) holds just the treeview item text
    const content = getContentElement(item);
    const targetChildOfDraggedItem = hasParent(item, closestNode(draggedItem));
    if (!isPresent(content) || (content === draggedItem) || targetChildOfDraggedItem) {
        return;
    }
    const itemViewPortCoords = content.getBoundingClientRect();
    /*
        if the user is hovering a treeview item, split the item height into four parts:
            - dropping into the top quarter should insert the dragged item before the drop target
            - dropping into the bottom quarter should insert the dragged item after the drop target
            - dropping into the second or third quarter should add the item as child node of the drop target

        if the user is NOT hovering a treeview item (he's dragging somewhere on the right), split the item height to just two parts:
            - dropping should insert before or after
    */
    const itemDivisionHeight = itemViewPortCoords.height / (isContent(target) ? 4 : 2);
    // clear any possible container offset created by parent elements with `transform` css property set
    const pointerPosition = clientY - containerOffset.top;
    const itemTop = itemViewPortCoords.top - containerOffset.top;
    if (pointerPosition < itemTop + itemDivisionHeight) {
        return DropPosition.Before;
    }
    if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
        return DropPosition.After;
    }
    return DropPosition.Over;
};
/**
 * @hidden
 */
const treeItemFromEventTarget = (treeView, dropTarget) => {
    if (!(isPresent(treeView) && isPresent(dropTarget))) {
        return null;
    }
    const node = closestNode(dropTarget);
    const index = nodeId(node);
    const lookup = treeView.itemLookup(index);
    if (!(isPresent(lookup) && isPresent(lookup.item.dataItem))) {
        return null;
    }
    return lookup;
};
/**
 * @hidden
 *
 * Emits `collapse` on the specified TreeView node if the latter is left empty after its last child node was dragged out.
 */
const collapseEmptyParent = (parent, parentNodes, treeview) => {
    if (isPresent(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {
        treeview.collapseNode(parent.item.dataItem, parent.item.index);
    }
};
/**
 * @hidden
 *
 * Expands the node if it's dropped into and it's not yet expanded.
 */
const expandDropTarget = (dropTarget, treeView) => {
    if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {
        treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);
    }
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
const getDropTarget = (event) => {
    if (!(isDocumentAvailable() && isPresent(document.elementFromPoint))) {
        return event.target;
    }
    return document.elementFromPoint(event.clientX, event.clientY);
};
/**
 * @hidden
 *
 * Checks if the original index is before the new one and corrects the new one by decrementing the index for the level, where the original item stood.
 */
const updateMovedItemIndex = (newIndex, originalIndex) => {
    const movedItemNewIndexParts = newIndex.split('_');
    const originalItemIndexParts = originalIndex.split('_');
    // if the original item was moved from a deeper level, there's no need for index correction
    // e.g. 4_0_1 is moved to 5_0 => removing 4_0_1 will not cause 5_0 to be moved
    if (movedItemNewIndexParts.length < originalItemIndexParts.length) {
        return newIndex;
    }
    // check if the parent item paths are the same - index correction is not required when the original item path differs from the path of the moved item - they belong to different hierarchies
    // e.g. 4_1 is moved to 5_1 - the parent item paths are differen (4 compared to 5) => removing 4_1 will not cause 5_1 to be moved
    // e.g 4_1 is moved to 4_3 - the parent paths are the same (both 4) => removing 4_1 will cause 4_3 to be moved
    const originalItemParentPathLength = originalItemIndexParts.length - 1;
    const originalItemParentPath = originalItemIndexParts.slice(0, originalItemParentPathLength).join('_');
    const movedItemParentPath = movedItemNewIndexParts.slice(0, originalItemParentPathLength).join('_');
    // check if the the index of the level where the original item is taken from is greater than the one of the moved item
    // e.g. 4_5 is moved to 4_1 (comapre 5 and 1) => removing 4_5 will not cause 4_1 to be moved
    // e.g. 4_1 is moved to 4_5 (comapre 1 and 5) => removing 4_1 will cause 4_5 to be moved
    const originalItemIndexLevel = originalItemIndexParts.length - 1;
    const originalItemLevelIndex = Number(originalItemIndexParts[originalItemIndexLevel]);
    const movedItemLevelIndex = Number(movedItemNewIndexParts[originalItemIndexLevel]);
    if ((originalItemParentPath === movedItemParentPath) && (movedItemLevelIndex > originalItemLevelIndex)) {
        // if the removed item causes the dropped item to be moved a position up - decrement the index at that level
        movedItemNewIndexParts[originalItemIndexLevel] = String(movedItemLevelIndex - 1);
        return movedItemNewIndexParts.join('_');
    }
    return newIndex;
};
/**
 * @hidden
 */
const SCROLLBAR_REG_EXP = new RegExp('(auto|scroll)');
/**
 * @hidden
 *
 * Retrives the first scrollable element starting the search from the provided one, traversing to the top of the DOM tree.
 */
const getScrollableContainer = (node) => {
    while (isPresent(node) && node.nodeName !== 'HTML') {
        const hasOverflow = node.scrollHeight > node.clientHeight;
        const hasScrollbar = SCROLLBAR_REG_EXP.test(getComputedStyle(node).overflowY);
        if (hasOverflow && hasScrollbar) {
            return node;
        }
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 *
 * Checks if the top of the scrollable element is reached.
 * Floors the scrollTop value.
 */
const isTopReached = (element) => Math.floor(element.scrollTop) <= 0;
/**
 * @hidden
 *
 * Checks if the bottom of the scrollable element is reached.
 * Ceils the scrollTop value.
 */
const isBottomReached = (element) => Math.ceil(element.scrollTop) >= element.scrollHeight - element.clientHeight;
/**
 * @hidden
 *
 * Scrolls the element in the given direction by the provided step.
 *
 * If the targeted scroll incrementation doesn't yield any result due to device pixel ratio issues (https://github.com/dimitar-pechev/RenderingIndependentScrollOffsets#readme),
 * increments the step with 1px and again attempts to change the scrollTop of the element, until the content is actually scrolled.
 *
 * Cuts the operation short after 20 unsuccessful attempts to prevent infinite loops in possible corner-case scenarios.
 */
const scrollElementBy = (element, step, direction) => {
    if (!(isPresent(element) && isDocumentAvailable())) {
        return;
    }
    const initialScrollTop = element.scrollTop;
    let currentStep = step;
    let iterations = 0;
    while (initialScrollTop === element.scrollTop &&
        !(direction === ScrollDirection.Up && isTopReached(element)) &&
        !(direction === ScrollDirection.Down && isBottomReached(element)) &&
        iterations < 20 // as the bulgarian saying goes - to ties our underpants
    ) {
        element.scrollTop += (currentStep * direction);
        currentStep += 1;
        iterations += 1;
    }
};

/**
 * @hidden
 */
const copyPageSize = (treeview, source, target) => {
    if (!isPresent(treeview.loadMoreService)) {
        return;
    }
    const sourceGroupSize = treeview.getNodePageSize(source);
    treeview.setNodePageSize(target, sourceGroupSize);
};
/**
 * @hidden
 */
const incrementPageSize = (treeview, dataItem) => {
    if (!isPresent(treeview.loadMoreService)) {
        return;
    }
    const currentPageSize = treeview.getNodePageSize(dataItem);
    treeview.setNodePageSize(dataItem, currentPageSize + 1);
};
/**
 * @hidden
 */
const decrementPageSize = (treeview, dataItem) => {
    if (!isPresent(treeview.loadMoreService)) {
        return;
    }
    const currentPageSize = treeview.getNodePageSize(dataItem);
    treeview.setNodePageSize(dataItem, currentPageSize - 1);
};

/**
 * @hidden
 */
class HierarchyEditingService {
    constructor(hierarchyBinding) {
        this.hierarchyBinding = hierarchyBinding;
    }
    add({ sourceItem, destinationItem, dropPosition, sourceTree, destinationTree }) {
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));
        if (dropPosition === DropPosition.Over) {
            // expand the item that was dropped into
            expandDropTarget(destinationItem, destinationTree);
            const destinationChildren = this.childrenFor(getDataItem(destinationItem));
            // add the moved node just before the load more button if load more is enabled
            const targetIndex = isPresent(destinationTree.loadMoreService) ?
                Math.min(destinationTree.loadMoreService.getGroupSize(getDataItem(destinationItem)), destinationChildren.length) : // the page size might be greater than the actual children array length
                destinationChildren.length;
            destinationChildren.splice(targetIndex, 0, clonedSourceDataItem);
            setter(this.hierarchyBinding.childrenField)(getDataItem(destinationItem), destinationChildren);
            this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, targetIndex);
        }
        else {
            const destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);
            const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
            const targetIndex = destinationParentNodes.indexOf(getDataItem(destinationItem)) + shiftIndex;
            destinationParentNodes.splice(targetIndex, 0, clonedSourceDataItem);
            const parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;
            this.movedItemNewIndex = buildTreeIndex(parentIndex, targetIndex);
        }
        // increment the parent page size => an item is moved into it
        const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);
        incrementPageSize(destinationTree, updatedParent);
        // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference
        copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);
        // the source tree nodes are reloaded on `removeItem` - reload the destination tree nodes if the soruce and the destination tree are different
        if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {
            destinationTree.preloadChildNodes();
        }
        // if the source and destination trees are the same, focusing the moved item here will not have the desired effect
        // as the `remove` handler has not yet kicked-in to remove the item from its old position
        if (sourceTree !== destinationTree) {
            // ensure the focus target is rendered and registered
            destinationTree.changeDetectorRef.detectChanges();
            destinationTree.focus(this.movedItemNewIndex);
        }
    }
    remove({ sourceItem, sourceTree, destinationTree }) {
        const sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);
        const sourceItemIndex = sourceParentNodes.indexOf(getDataItem(sourceItem));
        sourceParentNodes.splice(sourceItemIndex, 1);
        // emit collapse for the parent node if its last child node was spliced
        collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree);
        // decrement source item parent page size => an item has been removed from it
        decrementPageSize(sourceTree, getDataItem(sourceItem.parent));
        // reload the treeview nodes
        if (!sourceTree.loadOnDemand) {
            sourceTree.preloadChildNodes();
        }
        // if the source and destination trees are different we want to focus only the moved item in the destination tree
        if (sourceTree === destinationTree) {
            // ensure the focus target is rendered and registered
            destinationTree.changeDetectorRef.detectChanges();
            // after the source item is removed from its original position, the candidate index might have to be corrected
            const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);
            destinationTree.focus(index);
        }
    }
    getParentNodes(node, treeView) {
        return isPresent(node.parent) ?
            this.childrenFor(getDataItem(node.parent)) :
            treeView.nodes;
    }
    childrenFor(dataItem) {
        return getter(this.hierarchyBinding.childrenField)(dataItem) || [];
    }
}

/**
 * @hidden
 */
let DragClueComponent = class DragClueComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.hostClasses = true;
        this.posistionStyle = 'fixed';
    }
    get statusIconClass() {
        switch (this.action) {
            case DropAction.Add: return 'k-i-plus';
            case DropAction.InsertTop: return 'k-i-insert-up';
            case DropAction.InsertBottom: return 'k-i-insert-down';
            case DropAction.InsertMiddle: return 'k-i-insert-middle';
            case DropAction.Invalid:
            default: return 'k-i-cancel';
        }
    }
    // exposed as a public method that can be called from outside as the component uses `OnPush` strategy
    detectChanges() {
        this.cdr.detectChanges();
    }
};
DragClueComponent.ɵfac = function DragClueComponent_Factory(t) { return new (t || DragClueComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
DragClueComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DragClueComponent, selectors: [["kendo-treeview-drag-clue"]], hostVars: 6, hostBindings: function DragClueComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("position", ctx.posistionStyle);
        ɵngcc0.ɵɵclassProp("k-header", ctx.hostClasses)("k-drag-clue", ctx.hostClasses);
    } }, decls: 2, vars: 2, consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function DragClueComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DragClueComponent_ng_container_0_Template, 4, 4, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, DragClueComponent_1_Template, 1, 7, null, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.template);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    HostBinding('class.k-header'),
    HostBinding('class.k-drag-clue'),
    __metadata("design:type", Boolean)
], DragClueComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('style.position'),
    __metadata("design:type", String)
], DragClueComponent.prototype, "posistionStyle", void 0);
DragClueComponent = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef])
], DragClueComponent);

/**
 * @hidden
 */
class DragAndDropAssetService {
    get componentRef() {
        if (!isPresent(this._componentRef)) {
            throw new Error('The `initalize` method must be called before calling other service methods.');
        }
        return this._componentRef;
    }
    set componentRef(componentRef) {
        this._componentRef = componentRef;
    }
    get element() {
        return this.componentRef.location.nativeElement;
    }
    ngOnDestroy() {
        if (!isPresent(this._componentRef)) {
            return;
        }
        this.element.parentElement.removeChild(this.element);
        this.componentRef.destroy();
        this.componentRef = null;
    }
    show() {
        this.element.style.display = '';
    }
    hide() {
        this.element.style.display = 'none';
    }
    move(left, top, offset = 0) {
        this.element.style.left = `${left + offset}px`;
        this.element.style.top = `${top + offset}px`;
    }
}
DragAndDropAssetService.ɵfac = function DragAndDropAssetService_Factory(t) { return new (t || DragAndDropAssetService)(); };
DragAndDropAssetService.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DragAndDropAssetService });

/**
 * @hidden
 */
const CLUE_OFFSET = 10;
/**
 * @hidden
 */
const RETURN_ANIMATION_DURATION = 200;
/**
 * @hidden
 */
let DragClueService = class DragClueService extends DragAndDropAssetService {
    constructor(componentFactoryResolver) {
        super();
        this.componentFactoryResolver = componentFactoryResolver;
    }
    initialize(container, template) {
        if (isPresent(this._componentRef)) {
            this.ngOnDestroy();
        }
        const clueComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DragClueComponent);
        this.componentRef = container.createComponent(clueComponentFactory);
        this.hide();
        this.componentRef.instance.template = template;
        this.componentRef.changeDetectorRef.detectChanges();
    }
    ngOnDestroy() {
        this.cancelReturnAnimation();
        this.cancelScroll();
        super.ngOnDestroy();
    }
    move(left, top) {
        super.move(left, top, CLUE_OFFSET);
    }
    animateDragClueToElementPosition(target) {
        if (!(isPresent(target) && isPresent(this.element.animate))) {
            this.hide();
            return;
        }
        const targetElementViewPortCoords = target.getBoundingClientRect();
        const clueElementViewPortCoords = this.element.getBoundingClientRect();
        this.returnAnimation = this.element.animate([
            { transform: 'translate(0, 0)' },
            { transform: `translate(${targetElementViewPortCoords.left - clueElementViewPortCoords.left}px, ${targetElementViewPortCoords.top - clueElementViewPortCoords.top}px)` }
        ], RETURN_ANIMATION_DURATION);
        this.returnAnimation.onfinish = () => this.hide();
    }
    cancelReturnAnimation() {
        if (!isPresent(this.returnAnimation)) {
            return;
        }
        this.returnAnimation.cancel();
        this.returnAnimation = null;
    }
    updateDragClueData(action, sourceItem, destinationItem) {
        const dragClue = this.componentRef.instance;
        if (action === dragClue.action && dataItemsEqual(sourceItem, dragClue.sourceItem) && dataItemsEqual(destinationItem, dragClue.destinationItem)) {
            return;
        }
        dragClue.action = action;
        dragClue.sourceItem = sourceItem;
        dragClue.destinationItem = destinationItem;
        dragClue.detectChanges();
    }
    updateText(text) {
        if (text === this.componentRef.instance.text) {
            return;
        }
        this.componentRef.instance.text = text;
        this.componentRef.instance.detectChanges();
    }
    /**
     * Triggers the first scrollable parent to scroll upwards or downwards.
     * Uses setInterval, so should be called outside the angular zone.
     */
    scrollIntoView({ step, interval }) {
        this.cancelScroll();
        const scrollableContainer = getScrollableContainer(this.element);
        if (!isPresent(scrollableContainer)) {
            return;
        }
        const containerRect = scrollableContainer.getBoundingClientRect();
        const clueRect = this.element.getBoundingClientRect();
        // if the beginning of the scrollable container is above the current viewport, fall-back to 0
        const firstVisibleClientTopPart = Math.max(containerRect.top, 0);
        // start scrolling up when the first visible item is dragged over
        const topLimit = firstVisibleClientTopPart + clueRect.height;
        // if the end of the scrollable container is beneath the current viewport, fall-back to its client height
        // add the distance from the start of the viewport to the beginning of the container to ensure scrolling bottom begins when the actual end of the container is reached
        const bottomLimit = firstVisibleClientTopPart + Math.min(containerRect.bottom, scrollableContainer.clientHeight);
        if (clueRect.top < topLimit) {
            this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Up), interval);
        }
        else if (clueRect.bottom > bottomLimit) {
            this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Down), interval);
        }
    }
    /**
     * Cancels out the on-going scroll animation, if present.
     */
    cancelScroll() {
        if (isPresent(this.scrollInterval)) {
            clearInterval(this.scrollInterval);
            this.scrollInterval = null;
        }
    }
};
DragClueService.ɵfac = function DragClueService_Factory(t) { return new (t || DragClueService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver)); };
DragClueService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DragClueService, factory: function (t) { return DragClueService.ɵfac(t); } });
DragClueService = __decorate([ __metadata("design:paramtypes", [ComponentFactoryResolver])
], DragClueService);

/**
 * @hidden
 */
let DropHintComponent = class DropHintComponent {
    constructor(changeDetectorRef) {
        this.changeDetectorRef = changeDetectorRef;
        this.hostClass = true;
        this.position = 'fixed';
        this.pointerEvents = 'none';
    }
    // exposed as a public method that can be called from outside as the component uses `OnPush` strategy
    detectChanges() {
        this.changeDetectorRef.detectChanges();
    }
};
DropHintComponent.ɵfac = function DropHintComponent_Factory(t) { return new (t || DropHintComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
DropHintComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DropHintComponent, selectors: [["kendo-treeview-drop-hint"]], hostVars: 6, hostBindings: function DropHintComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("position", ctx.position)("pointer-events", ctx.pointerEvents);
        ɵngcc0.ɵɵclassProp("k-drop-hint-container", ctx.hostClass);
    } }, decls: 2, vars: 2, consts: [["class", "k-drop-hint k-drop-hint-h", 4, "ngIf"], [4, "ngIf"], [1, "k-drop-hint", "k-drop-hint-h"], [1, "k-drop-hint-start"], [1, "k-drop-hint-line"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function DropHintComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DropHintComponent_div_0_Template, 3, 0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, DropHintComponent_1_Template, 1, 6, null, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.template);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    HostBinding('class.k-drop-hint-container'),
    __metadata("design:type", Boolean)
], DropHintComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('style.position'),
    __metadata("design:type", String)
], DropHintComponent.prototype, "position", void 0);
__decorate([
    HostBinding('style.pointer-events'),
    __metadata("design:type", String)
], DropHintComponent.prototype, "pointerEvents", void 0);
DropHintComponent = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef])
], DropHintComponent);

/**
 * @hidden
 */
let DropHintService = class DropHintService extends DragAndDropAssetService {
    constructor(componentFactoryResolver) {
        super();
        this.componentFactoryResolver = componentFactoryResolver;
    }
    initialize(container, template) {
        if (isPresent(this._componentRef)) {
            this.ngOnDestroy();
        }
        const hintComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DropHintComponent);
        this.componentRef = container.createComponent(hintComponentFactory);
        this.hide();
        this.componentRef.instance.template = template;
        this.componentRef.changeDetectorRef.detectChanges();
    }
    updateDropHintData(action, sourceItem, destinationItem) {
        const dropHint = this.componentRef.instance;
        if (action === dropHint.action && dataItemsEqual(sourceItem, dropHint.sourceItem) && dataItemsEqual(destinationItem, dropHint.destinationItem)) {
            return;
        }
        dropHint.action = action;
        dropHint.sourceItem = sourceItem;
        dropHint.destinationItem = destinationItem;
        dropHint.detectChanges();
    }
};
DropHintService.ɵfac = function DropHintService_Factory(t) { return new (t || DropHintService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver)); };
DropHintService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DropHintService, factory: function (t) { return DropHintService.ɵfac(t); } });
DropHintService = __decorate([ __metadata("design:paramtypes", [ComponentFactoryResolver])
], DropHintService);

/**
 * Represents the template for the TreeView drag clue when an item is dragged. To define the clue template,
 * nest an `<ng-template>` tag with the `kendoTreeViewDragClueTemplate` directive inside a `<kendo-treeview>` tag
 * ([see example]({% slug draganddrop_treeview %}#toc-templates)).
 *
 *
 * The text, attempted drop action, source item and destination item are available as context variables in the template:
 *
 *
 * - `let-text="text"` (`string`)
 * - `let-action="action"` ([`DropAction`]({% slug api_treeview_dropaction %}))
 * - `let-sourceItem="sourceItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 * - `let-destinationItem="destinationItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 */
let DragClueTemplateDirective = class DragClueTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
DragClueTemplateDirective.ɵfac = function DragClueTemplateDirective_Factory(t) { return new (t || DragClueTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DragClueTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DragClueTemplateDirective, selectors: [["", "kendoTreeViewDragClueTemplate", ""]] });
DragClueTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], DragClueTemplateDirective);

/**
 * Represents the template for the TreeView drop hint when an item is dragged. To define the hint template,
 * nest an `<ng-template>` tag with the `kendoTreeViewDropHintTemplate` directive inside a `<kendo-treeview>` tag
 * ([see example]({% slug draganddrop_treeview %}#toc-templates)).
 *
 * The attempted drop action, source item and destination item are available as context variables in the template:
 *
 * - `let-action="action"` ([`DropAction`]({% slug api_treeview_dropaction %}))
 * - `let-sourceItem="sourceItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 * - `let-destinationItem="destinationItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 */
let DropHintTemplateDirective = class DropHintTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
DropHintTemplateDirective.ɵfac = function DropHintTemplateDirective_Factory(t) { return new (t || DropHintTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DropHintTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DropHintTemplateDirective, selectors: [["", "kendoTreeViewDropHintTemplate", ""]] });
DropHintTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], DropHintTemplateDirective);

const DEFAULT_SCROLL_SETTINGS = {
    enabled: true,
    step: 1,
    interval: 1
};
/**
 * A directive which enables the dragging and dropping items inside the current TreeView or between multiple linked TreeView component instances
 * ([see example]({% slug draganddrop_treeview %})).
 *
 * Triggers the [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart),
 * [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag),
 * [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop),
 * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend),
 * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
 * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)
 * events when the corresponding actions occur on the respective TreeView instance.
 */
let DragAndDropDirective = class DragAndDropDirective {
    constructor(element, zone, treeview, dragClueService, dropHintService) {
        this.element = element;
        this.zone = zone;
        this.treeview = treeview;
        this.dragClueService = dragClueService;
        this.dropHintService = dropHintService;
        /**
         * Specifies whether the `removeItem` event will be fired after an item is dropped when the `ctrl` key is pressed.
         * If enabled, the `removeItem` event will not be fired on the source TreeView
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         *
         * @default false
         */
        this.allowCopy = false;
        /**
         * Specifes the TreeViewComponent instances into which dragged items from the current TreeViewComponent can be dropped
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         */
        this.dropZoneTreeViews = [];
        /**
         * Specifies the distance in pixels from the initial item pointerdown event, before the dragging is initiated.
         * The `nodeDragStart` and all consequent TreeView drag events will not be fired until the actual dragging begins.
         *
         * @default 5
         */
        this.startDragAfter = 5;
        /**
         * Controlls the auto-scrolling behavior during drag-and-drop ([see example]({% slug draganddrop_treeview %}#toc-auto-scrolling)).
         * Enbaled by default. To turn the auto-scrolling off, set this prop to `false`.
         *
         * By default, the scrolling will be performed by 1 pixel at every 1 millisecond, when the dragged item reaches the top or the bottom of the scrollable container.
         * The `step` and `interval` can be overridden by providing a `DragAndDropScrollSettings` object to this prop.
         *
         * @default true
         */
        this.autoScroll = true;
        /**
         * @hidden
         */
        this.userSelectStyle = 'none';
        /**
         * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.
         * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.
         * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
         */
        this.containerOffset = { top: 0, left: 0 };
        this.treeview.touchActions = false;
    }
    get scrollSettings() {
        const userProvidedSettings = typeof this.autoScroll === 'boolean' ?
            { enabled: this.autoScroll } :
            this.autoScroll;
        return Object.assign({}, DEFAULT_SCROLL_SETTINGS, userProvidedSettings);
    }
    ngAfterContentInit() {
        this.initalizeDraggable();
        this.dragClueService.initialize(this.treeview.assetsContainer, this.dragClueTemplate && this.dragClueTemplate.templateRef);
        this.dropHintService.initialize(this.treeview.assetsContainer, this.dropHintTemplate && this.dropHintTemplate.templateRef);
    }
    ngOnDestroy() {
        this.draggable.destroy();
    }
    /**
     * @hidden
     */
    handlePress({ originalEvent }) {
        if (!isContent(originalEvent.target)) {
            return;
        }
        // store the drag target on press, show it only when it's actually dragged
        this.draggedItem = closestWithMatch(originalEvent.target, '.k-treeview-leaf');
        // record the current pointer down coords - copared to the `startDragAfter` value to calculate whether to initiate dragging
        this.pendingDragStartEvent = originalEvent;
    }
    /**
     * @hidden
     */
    handleDrag({ originalEvent, clientX, clientY }) {
        if (this.shouldInitiateDragStart({ clientX, clientY })) {
            this.initiateDragStart();
        }
        if (!isPresent(this.draggedItem) || isPresent(this.pendingDragStartEvent)) {
            return;
        }
        const dropTarget = getDropTarget(originalEvent);
        if (hasObservers(this.treeview.nodeDrag)) {
            this.zone.run(() => this.notifyDrag(originalEvent, dropTarget));
        }
        const targetTreeView = this.getTargetTreeView(dropTarget);
        const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, targetTreeView, this.containerOffset);
        const dropHintAnchor = closestWithMatch(dropTarget, '.k-treeview-mid');
        const dropAction = getDropAction(dropPosition, dropTarget);
        const sourceItem = treeItemFromEventTarget(this.treeview, this.draggedItem);
        const destinationItem = treeItemFromEventTarget(targetTreeView, dropTarget);
        this.updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem);
        this.updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem);
        if (this.scrollSettings.enabled) {
            this.dragClueService.scrollIntoView(this.scrollSettings);
        }
    }
    /**
     * @hidden
     */
    handleRelease({ originalEvent, clientY }) {
        if (this.scrollSettings.enabled) {
            this.dragClueService.cancelScroll();
        }
        if (!isPresent(this.draggedItem) || isPresent(this.pendingDragStartEvent)) {
            this.pendingDragStartEvent = null;
            this.draggedItem = null;
            return;
        }
        const dropTarget = getDropTarget(originalEvent);
        const sourceTree = this.treeview;
        const destinationTree = this.getTargetTreeView(dropTarget);
        const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, this.getTargetTreeView(dropTarget), this.containerOffset);
        const sourceItem = treeItemFromEventTarget(sourceTree, this.draggedItem);
        const destinationItem = treeItemFromEventTarget(destinationTree, dropTarget);
        if (isPresent(destinationItem) && isPresent(dropPosition)) {
            this.zone.run(() => this.notifyDrop({ sourceItem, destinationItem, dropPosition, sourceTree, destinationTree }, originalEvent));
        }
        else {
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
        if (hasObservers(this.treeview.nodeDragEnd)) {
            this.zone.run(() => this.notifyDragEnd({ sourceItem, destinationItem, originalEvent }));
        }
        this.dropHintService.hide();
        this.draggedItem = null;
    }
    updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem) {
        if (!isPresent(dropHintAnchor) || dropPosition === DropPosition.Over || !isPresent(dropPosition)) {
            this.dropHintService.hide();
            return;
        }
        const anchorViewPortCoords = dropHintAnchor.getBoundingClientRect();
        const insertBefore = dropPosition === DropPosition.Before;
        const top = insertBefore ? anchorViewPortCoords.top : (anchorViewPortCoords.top + anchorViewPortCoords.height);
        this.dropHintService.updateDropHintData(dropAction, sourceItem, destinationItem);
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dropHintService.move(anchorViewPortCoords.left - this.containerOffset.left, top - this.containerOffset.top);
        this.dropHintService.show();
    }
    updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem) {
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dragClueService.move(clientX - this.containerOffset.left, clientY - this.containerOffset.top);
        this.dragClueService.updateDragClueData(dropAction, sourceItem, destinationItem);
        this.dragClueService.show();
    }
    initalizeDraggable() {
        this.draggable = new Draggable({
            press: this.handlePress.bind(this),
            drag: this.handleDrag.bind(this),
            release: this.handleRelease.bind(this)
        });
        this.zone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));
    }
    notifyDragStart(originalEvent, dropTarget) {
        const sourceItem = treeItemFromEventTarget(this.treeview, dropTarget);
        const event = new TreeItemDragStartEvent({ sourceItem, originalEvent });
        this.treeview.nodeDragStart.emit(event);
        return event;
    }
    notifyDrag(originalEvent, dropTarget) {
        const dragEvent = {
            sourceItem: treeItemFromEventTarget(this.treeview, this.draggedItem),
            destinationItem: treeItemFromEventTarget(this.getTargetTreeView(dropTarget), dropTarget),
            originalEvent
        };
        this.treeview.nodeDrag.emit(dragEvent);
    }
    notifyDrop(args, originalEvent) {
        const event = new TreeItemDropEvent(args, originalEvent);
        args.destinationTree.nodeDrop.emit(event);
        // disable the animations on drop and restore them afterwards (if they were initially turned on)
        this.disableAnimationsForNextTick(args.destinationTree);
        if (args.sourceTree !== args.destinationTree) {
            this.disableAnimationsForNextTick(args.sourceTree);
        }
        if (!event.isDefaultPrevented() && event.isValid) {
            this.dragClueService.hide();
            // order matters in a flat data binding scenario (first add, then remove)
            args.destinationTree.addItem.emit(args);
            if (!(originalEvent.ctrlKey && this.allowCopy)) {
                args.sourceTree.removeItem.emit(args);
            }
        }
        else if (event.isDefaultPrevented()) {
            // directly hide the clue if the default is prevented
            this.dragClueService.hide();
        }
        else if (!event.isValid) {
            // animate the clue back to the source item position if marked as invalid
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
    }
    notifyDragEnd(dragEndEvent) {
        this.treeview.nodeDragEnd.emit(dragEndEvent);
    }
    getTargetTreeView(dropTarget) {
        const treeViewTagName = this.treeview.element.nativeElement.tagName;
        const targetTreeView = closestWithMatch(dropTarget, treeViewTagName);
        return [this.treeview, ...this.dropZoneTreeViews].find(treeView => isPresent(treeView) && treeView.element.nativeElement === targetTreeView);
    }
    disableAnimationsForNextTick(treeView) {
        // the treeView.animate getter returns `true` when the animations are turned off
        // confusing, but seems on purpose (the `animate` prop sets the value of the @.disabled host-bound attribute)
        if (treeView.animate) {
            return;
        }
        treeView.animate = false;
        this.zone.runOutsideAngular(() => setTimeout(() => treeView.animate = true));
    }
    shouldInitiateDragStart(currentPointerCoords) {
        if (!isPresent(this.pendingDragStartEvent)) {
            return false;
        }
        const distanceFromPointerDown = Math.sqrt(Math.pow((this.pendingDragStartEvent.clientX - currentPointerCoords.clientX), 2) +
            Math.pow((this.pendingDragStartEvent.clientY - currentPointerCoords.clientY), 2));
        return distanceFromPointerDown >= this.startDragAfter;
    }
    initiateDragStart() {
        if (hasObservers(this.treeview.nodeDragStart)) {
            const dragStartEvent = this.zone.run(() => this.notifyDragStart(this.pendingDragStartEvent, getDropTarget(this.pendingDragStartEvent)));
            if (dragStartEvent.isDefaultPrevented()) {
                this.pendingDragStartEvent = null;
                this.draggedItem = null;
                return;
            }
        }
        this.dragClueService.cancelReturnAnimation();
        this.dragClueService.updateText(this.draggedItem.innerText);
        this.containerOffset = getContainerOffset(this.draggedItem);
        this.pendingDragStartEvent = null;
    }
};
DragAndDropDirective.ɵfac = function DragAndDropDirective_Factory(t) { return new (t || DragAndDropDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(TreeViewComponent), ɵngcc0.ɵɵdirectiveInject(DragClueService), ɵngcc0.ɵɵdirectiveInject(DropHintService)); };
DragAndDropDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DragAndDropDirective, selectors: [["", "kendoTreeViewDragAndDrop", ""]], contentQueries: function DragAndDropDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DragClueTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DropHintTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragClueTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropHintTemplate = _t.first);
    } }, hostVars: 8, hostBindings: function DragAndDropDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("user-select", ctx.userSelectStyle)("-ms-user-select", ctx.userSelectStyle)("-moz-user-select", ctx.userSelectStyle)("-webkit-user-select", ctx.userSelectStyle);
    } }, inputs: { allowCopy: "allowCopy", dropZoneTreeViews: "dropZoneTreeViews", startDragAfter: "startDragAfter", autoScroll: "autoScroll" }, features: [ɵngcc0.ɵɵProvidersFeature([
            DragClueService,
            DropHintService
        ])] });
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DragAndDropDirective.prototype, "allowCopy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], DragAndDropDirective.prototype, "dropZoneTreeViews", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DragAndDropDirective.prototype, "startDragAfter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DragAndDropDirective.prototype, "autoScroll", void 0);
__decorate([
    ContentChild(DragClueTemplateDirective, { static: false }),
    __metadata("design:type", DragClueTemplateDirective)
], DragAndDropDirective.prototype, "dragClueTemplate", void 0);
__decorate([
    ContentChild(DropHintTemplateDirective, { static: false }),
    __metadata("design:type", DropHintTemplateDirective)
], DragAndDropDirective.prototype, "dropHintTemplate", void 0);
__decorate([
    HostBinding('style.user-select'),
    HostBinding('style.-ms-user-select'),
    HostBinding('style.-moz-user-select'),
    HostBinding('style.-webkit-user-select'),
    __metadata("design:type", String)
], DragAndDropDirective.prototype, "userSelectStyle", void 0);
DragAndDropDirective = __decorate([ __metadata("design:paramtypes", [ElementRef,
        NgZone,
        TreeViewComponent,
        DragClueService,
        DropHintService])
], DragAndDropDirective);

/**
 * @hidden
 */
const DEFAULT_FILTER_SETTINGS = {
    operator: 'contains',
    ignoreCase: true,
    mode: "lenient"
};

/**
 * @hidden
 */
class FilteringBase {
    constructor(component) {
        this.component = component;
        this.visibleNodes = new Set();
        this._filterSettings = DEFAULT_FILTER_SETTINGS;
    }
    /**
     * The settings which are applied when performing a filter on the component's data.
     */
    set filterSettings(settings) {
        this._filterSettings = Object.assign({}, DEFAULT_FILTER_SETTINGS, settings);
    }
    get filterSettings() {
        return this._filterSettings;
    }
    /**
     * Applies a filter and changes the visibility of the component's nodes accordingly.
     */
    set filter(term) {
        this.handleFilterChange(term);
    }
    /**
     * @hidden
     */
    handleFilterChange(term) {
        if (!this.filterData) {
            return;
        }
        this.resetNodesVisibility(this.filterData);
        if (term) {
            filterTree(this.filterData, term, this.filterSettings, this.component.textField);
        }
        this.updateVisibleNodes(this.filterData);
        if (isPresent(this.component.filterStateChange)) {
            this.component.filterStateChange.emit({
                nodes: this.filterData,
                matchCount: this.visibleNodes.size,
                term,
                filterSettings: this.filterSettings
            });
        }
    }
    updateVisibleNodes(items) {
        items.forEach((wrapper) => {
            if (wrapper.visible) {
                this.visibleNodes.add(wrapper.dataItem);
            }
            if (wrapper.children) {
                this.updateVisibleNodes(wrapper.children);
            }
        });
    }
    resetNodesVisibility(items) {
        this.visibleNodes.clear();
        items.forEach((wrapper) => {
            wrapper.visible = true;
            if (wrapper.children) {
                this.resetNodesVisibility(wrapper.children);
            }
        });
    }
}
FilteringBase.ɵfac = function FilteringBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
FilteringBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FilteringBase, inputs: { filterSettings: "filterSettings", filter: "filter" } });
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], FilteringBase.prototype, "filterSettings", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], FilteringBase.prototype, "filter", null);

const indexBuilder = new IndexBuilderService();
const mapToWrappers = (currentLevelNodes, childrenField, parent = null, parentIndex = '') => {
    if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {
        return [];
    }
    return currentLevelNodes.map((node, idx) => {
        const index = indexBuilder.nodeIndex(idx.toString(), parentIndex);
        const wrapper = {
            dataItem: node,
            index,
            parent,
            visible: true
        };
        wrapper.children = mapToWrappers(getter(childrenField)(node), childrenField, wrapper, index);
        return wrapper;
    });
};
/**
 * A directive which encapsulates the retrieval of child nodes.
 */
let HierarchyBindingDirective = class HierarchyBindingDirective extends FilteringBase {
    constructor(component, dragAndDropDirective) {
        super(component);
        this.component = component;
        this.dragAndDropDirective = dragAndDropDirective;
        /**
         * @hidden
         */
        this.loadOnDemand = true;
        this.originalData = [];
        const shouldFilter = !isPresent(this.dragAndDropDirective);
        this.component.isVisible = shouldFilter ? (node) => this.visibleNodes.has(node) : isVisible;
    }
    /**
     * The field name which holds the data items of the child component.
     */
    set childrenField(value) {
        if (!value) {
            throw new Error("'childrenField' cannot be empty");
        }
        this._childrenField = value;
    }
    /**
     * The nodes which will be displayed by the TreeView.
     */
    set nodes(values) {
        this.originalData = values || [];
        this.filterData = mapToWrappers(values, this.childrenField) || [];
        this.updateVisibleNodes(this.filterData);
    }
    /**
     * @hidden
     * A callback which determines whether a TreeView node should be rendered as hidden.
     */
    set isVisible(fn) {
        this.component.isVisible = fn;
    }
    /**
     * The field name which holds the data items of the child component.
     */
    get childrenField() {
        return this._childrenField;
    }
    ngOnInit() {
        if (isPresent(this.childrenField)) {
            this.component.children = item => of(getter(this.childrenField)(item));
            this.component.hasChildren = item => {
                const children = getter(this.childrenField)(item);
                return Boolean(children && children.length);
            };
            this.component.editService = new HierarchyEditingService(this);
            this.component.filterChange.subscribe(this.handleFilterChange.bind(this));
            if (this.component.filter) {
                this.handleFilterChange(this.component.filter);
            }
            if (!this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {
                this.component.preloadChildNodes();
            }
        }
    }
    ngOnChanges(changes) {
        if (isChanged('childrenField', changes, false)) {
            this.nodes = this.originalData;
        }
        // should react to changes.loadOnDemand as well - should preload the data or clear the already cached items
        if (anyChanged(['nodes', 'loadOnDemand'], changes) && !this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {
            this.component.preloadChildNodes();
        }
    }
};
HierarchyBindingDirective.ɵfac = function HierarchyBindingDirective_Factory(t) { return new (t || HierarchyBindingDirective)(ɵngcc0.ɵɵdirectiveInject(DataBoundComponent), ɵngcc0.ɵɵdirectiveInject(DragAndDropDirective, 9)); };
HierarchyBindingDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: HierarchyBindingDirective, selectors: [["", "kendoTreeViewHierarchyBinding", ""]], inputs: { loadOnDemand: "loadOnDemand", childrenField: "childrenField", nodes: "nodes", isVisible: "isVisible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], HierarchyBindingDirective.prototype, "childrenField", null);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], HierarchyBindingDirective.prototype, "nodes", null);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], HierarchyBindingDirective.prototype, "isVisible", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HierarchyBindingDirective.prototype, "loadOnDemand", void 0);
HierarchyBindingDirective = __decorate([ __param(1, Optional()), __param(1, Host()),
    __metadata("design:paramtypes", [DataBoundComponent,
        DragAndDropDirective])
], HierarchyBindingDirective);

/**
 * @hidden
 */
let LoadingIndicatorDirective = class LoadingIndicatorDirective {
    constructor(expandService, loadingService, cd) {
        this.expandService = expandService;
        this.loadingService = loadingService;
        this.cd = cd;
        this._loading = false;
    }
    get loading() {
        return this._loading;
    }
    set loading(value) {
        this._loading = value;
        this.cd.markForCheck();
    }
    ngOnInit() {
        const loadingNotifications = this.loadingService
            .changes
            .pipe(filter(index => index === this.index));
        this.subscription = this.expandService
            .changes
            .pipe(filter(({ index }) => index === this.index), tap(({ expand }) => {
            if (!expand && this.loading) {
                this.loading = false;
            }
        }), filter(({ expand }) => expand), switchMap(x => of(x).pipe(delay(100), takeUntil(loadingNotifications))))
            .subscribe(() => this.loading = true);
        this.subscription.add(loadingNotifications.subscribe(() => this.loading = false));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
};
LoadingIndicatorDirective.ɵfac = function LoadingIndicatorDirective_Factory(t) { return new (t || LoadingIndicatorDirective)(ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(LoadingNotificationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
LoadingIndicatorDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LoadingIndicatorDirective, selectors: [["", "kendoTreeViewLoading", ""]], hostVars: 2, hostBindings: function LoadingIndicatorDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-i-loading", ctx.loading);
    } }, inputs: { index: ["kendoTreeViewLoading", "index"] } });
__decorate([
    HostBinding("class.k-i-loading"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], LoadingIndicatorDirective.prototype, "loading", null);
__decorate([
    Input("kendoTreeViewLoading"),
    __metadata("design:type", String)
], LoadingIndicatorDirective.prototype, "index", void 0);
LoadingIndicatorDirective = __decorate([ __metadata("design:paramtypes", [ExpandStateService,
        LoadingNotificationService,
        ChangeDetectorRef])
], LoadingIndicatorDirective);

/**
 * @hidden
 * Performs the right-to-left function composition. Functions must have a unary.
 */
const compose = (...args) => (data) => args.reduceRight((acc, curr) => curr(acc), data);

/**
 * @hidden
 */
class FlatEditingService {
    constructor(flatBinding) {
        this.flatBinding = flatBinding;
    }
    add({ sourceItem, destinationItem, dropPosition, sourceTree, destinationTree }) {
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));
        if (dropPosition === DropPosition.Over) {
            // expand the item that was dropped into
            expandDropTarget(destinationItem, destinationTree);
            const destinationItemId = getter(this.flatBinding.idField)(getDataItem(destinationItem));
            setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemId);
            const lastChildNodeIndex = this.getLastVisibleChildNodeIndex(destinationTree, this.flatBinding.originalData, getDataItem(destinationItem));
            // insert after the last visible child
            const targetIndex = lastChildNodeIndex + 1;
            this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);
            // rebind the treeview data before searching for the focus target index
            this.rebindData();
            const focusTarget = this.fetchChildNodes(getDataItem(destinationItem), destinationTree).indexOf(clonedSourceDataItem);
            this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, focusTarget);
        }
        else {
            const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
            const targetIndex = this.flatBinding.originalData.indexOf(getDataItem(destinationItem)) + shiftIndex;
            this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);
            const destinationItemParentId = getter(this.flatBinding.parentIdField)(getDataItem(destinationItem));
            setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemParentId);
            // rebind the treeview data before searching for the focus target index
            this.rebindData();
            const parentIndex = destinationItem.parent ?
                destinationItem.parent.item.index :
                null;
            const parentContainer = destinationItem.parent ?
                this.fetchChildNodes(getDataItem(destinationItem.parent), destinationTree) :
                destinationTree.nodes;
            const focusTarget = parentContainer.indexOf(clonedSourceDataItem);
            this.movedItemNewIndex = buildTreeIndex(parentIndex, focusTarget);
        }
        if (sourceTree !== destinationTree) {
            this.addChildNodes(clonedSourceDataItem, sourceTree);
        }
        // increment the parent page size => an item is moved into it
        const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);
        incrementPageSize(destinationTree, updatedParent);
        // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference
        copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);
        // the source tree nodes are reloaded on `removeItem` - reload the destination tree nodes if the soruce and the destination tree are different
        if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {
            destinationTree.preloadChildNodes();
        }
        // if the source and destination trees are the same, focusing the moved item here will not have the desired effect
        // as the `remove` handler has not yet kicked-in to remove the item from its old position
        if (sourceTree !== destinationTree) {
            // ensure the focus target is rendered and registered
            destinationTree.changeDetectorRef.detectChanges();
            destinationTree.focus(this.movedItemNewIndex);
        }
    }
    remove({ sourceItem, sourceTree, destinationTree }) {
        const sourceDataItem = getDataItem(sourceItem);
        const sourceItemIndex = this.flatBinding.originalData.indexOf(sourceDataItem);
        this.flatBinding.originalData.splice(sourceItemIndex, 1);
        if (sourceTree !== destinationTree) {
            this.removeChildNodes(sourceDataItem, sourceTree);
        }
        this.rebindData();
        // emit collapse for the parent node if its last child node was spliced
        const parentChildren = sourceItem.parent ? sourceItem.parent.children : [];
        collapseEmptyParent(sourceItem.parent, parentChildren, sourceTree);
        // decrement source item parent page size => an item has been removed from it
        decrementPageSize(sourceTree, getDataItem(sourceItem.parent));
        // reload the treeview nodes
        if (!sourceTree.loadOnDemand) {
            sourceTree.preloadChildNodes();
        }
        // if the source and destination trees are different we want to focus only the moved item in the destination tree
        if (sourceTree === destinationTree) {
            // ensure the focus target is rendered and registered
            destinationTree.changeDetectorRef.detectChanges();
            // after the source item is removed from its original position, the candidate index might have to be corrected
            const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);
            destinationTree.focus(index);
        }
    }
    addChildNodes(dataItem, source) {
        const itemChildren = this.fetchAllDescendantNodes(dataItem, source);
        this.flatBinding.originalData.push(...itemChildren);
    }
    removeChildNodes(dataItem, source) {
        const sourceChildren = this.fetchAllDescendantNodes(dataItem, source);
        sourceChildren.forEach(item => {
            const index = this.flatBinding.originalData.indexOf(item);
            this.flatBinding.originalData.splice(index, 1);
        });
    }
    fetchAllDescendantNodes(node, treeview) {
        let nodes = this.fetchChildNodes(node, treeview);
        nodes.forEach(node => nodes = nodes.concat(this.fetchAllDescendantNodes(node, treeview) || []));
        return nodes;
    }
    fetchChildNodes(node, treeview) {
        if (!node) {
            return [];
        }
        let nodes = [];
        treeview
            .children(node)
            .pipe(take(1))
            .subscribe(children => nodes = nodes.concat(children || []));
        return nodes;
    }
    getLastVisibleChildNodeIndex(treeview, data, node) {
        if (!isPresent(treeview.loadMoreService) || !treeview.hasChildren(node)) {
            return data.length;
        }
        const visibleNodesCount = treeview.loadMoreService.getGroupSize(node);
        const visibleChildren = this.fetchChildNodes(node, treeview).slice(0, visibleNodesCount);
        const lastNode = visibleChildren[visibleChildren.length - 1];
        const lastNodeIndex = data.indexOf(lastNode);
        return lastNodeIndex;
    }
    rebindData() {
        this.flatBinding.nodes = this.flatBinding.originalData;
    }
}

const findChildren = (prop, nodes, value) => nodes.filter((x) => prop(x) === value);
const indexBuilder$1 = new IndexBuilderService();
const mapToTree = (currentLevelNodes, allNodes, parentIdField, idField, parent = null, parentIndex = '') => {
    if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {
        return [];
    }
    return currentLevelNodes.map((node, idx) => {
        const index = indexBuilder$1.nodeIndex(idx.toString(), parentIndex);
        const wrapper = {
            dataItem: node,
            index,
            parent,
            visible: true
        };
        wrapper.children = mapToTree(findChildren(getter(parentIdField), allNodes || [], getter(idField)(node)), allNodes, parentIdField, idField, wrapper, index);
        return wrapper;
    });
};
/**
 * A directive which encapsulates the retrieval of the child nodes.
 */
let FlatDataBindingDirective = class FlatDataBindingDirective extends FilteringBase {
    constructor(component) {
        super(component);
        this.component = component;
        /**
         * @hidden
         */
        this.loadOnDemand = true;
        /**
         * @hidden
         */
        this.originalData = [];
        this.component.isVisible = (node) => this.visibleNodes.has(node);
    }
    /**
     * The nodes which will be displayed by the TreeView.
     */
    set nodes(values) {
        this.originalData = values || [];
        if (!isNullOrEmptyString(this.parentIdField)) {
            const prop = getter(this.parentIdField);
            this.component.nodes = this.originalData.filter(compose(isBlank, prop));
            this.filterData = mapToTree(this.component.nodes, this.originalData, this.parentIdField, this.idField);
            this.updateVisibleNodes(this.filterData);
        }
        else {
            this.component.nodes = this.originalData.slice(0);
        }
    }
    /**
     * @hidden
     * A callback which determines whether a TreeView node should be rendered as hidden.
     */
    set isVisible(fn) {
        this.component.isVisible = fn;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (isPresent(this.parentIdField) && isPresent(this.idField)) {
            const fetchChildren = (node) => findChildren(getter(this.parentIdField), this.originalData || [], getter(this.idField)(node));
            this.component.hasChildren = (node) => fetchChildren(node).length > 0;
            this.component.children = (node) => of(fetchChildren(node));
            this.component.editService = new FlatEditingService(this);
            this.component.filterChange.subscribe(this.handleFilterChange.bind(this));
            if (this.component.filter) {
                this.handleFilterChange(this.component.filter);
            }
            if (!this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {
                this.component.preloadChildNodes();
            }
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (isChanged('parentIdField', changes, false)) {
            this.nodes = this.originalData;
        }
        // should react to changes.loadOnDemand as well - should preload the data or clear the already cached items
        if (anyChanged(['nodes', 'loadOnDemand'], changes) && !this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {
            this.component.preloadChildNodes();
        }
    }
};
FlatDataBindingDirective.ɵfac = function FlatDataBindingDirective_Factory(t) { return new (t || FlatDataBindingDirective)(ɵngcc0.ɵɵdirectiveInject(DataBoundComponent)); };
FlatDataBindingDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FlatDataBindingDirective, selectors: [["", "kendoTreeViewFlatDataBinding", ""]], inputs: { loadOnDemand: "loadOnDemand", nodes: "nodes", isVisible: "isVisible", parentIdField: "parentIdField", idField: "idField" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], FlatDataBindingDirective.prototype, "nodes", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatDataBindingDirective.prototype, "parentIdField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatDataBindingDirective.prototype, "idField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FlatDataBindingDirective.prototype, "loadOnDemand", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function])
], FlatDataBindingDirective.prototype, "isVisible", null);
FlatDataBindingDirective = __decorate([ __metadata("design:paramtypes", [DataBoundComponent])
], FlatDataBindingDirective);

const buildItem = (index, dataItem) => ({ dataItem, index });
let id = 0;
const TREE_ITEM_ROLE = 'treeitem';
const BUTTON_ROLE = 'button';
/**
 * @hidden
 *
 * A directive which manages the expanded state of the TreeView.
 */
let TreeViewItemDirective = class TreeViewItemDirective {
    constructor(element, expandService, navigationService, selectionService, lookupService, renderer, ib) {
        this.element = element;
        this.expandService = expandService;
        this.navigationService = navigationService;
        this.selectionService = selectionService;
        this.lookupService = lookupService;
        this.renderer = renderer;
        this.ib = ib;
        this.role = TREE_ITEM_ROLE;
        this.loadOnDemand = true;
        this.isDisabled = false;
        this.isVisible = true;
        this.ariaChecked = 'false';
        this.id = id++;
        this.isInitialized = false;
        this.subscriptions = [];
        this.subscribe();
    }
    set isChecked(checked) {
        if (checked === 'checked') {
            this.ariaChecked = 'true';
        }
        else if (checked === 'indeterminate') {
            this.ariaChecked = 'mixed';
        }
        else {
            this.ariaChecked = 'false';
        }
    }
    get isExpanded() {
        return this._isExpanded || false;
    }
    set isExpanded(isExpanded) {
        this._isExpanded = isExpanded;
    }
    get isSelected() {
        return this._isSelected || false;
    }
    set isSelected(isSelected) {
        this._isSelected = isSelected;
    }
    get isButton() {
        return this.role === BUTTON_ROLE;
    }
    get treeItem() {
        return buildItem(this.index, this.dataItem);
    }
    get parentTreeItem() {
        return this.parentDataItem ? buildItem(this.parentIndex, this.parentDataItem) : null;
    }
    ngOnInit() {
        if (this.loadOnDemand && !this.isButton) {
            this.lookupService.registerItem(this.treeItem, this.parentTreeItem);
        }
        this.registerNavigationItem();
        this.isInitialized = true;
        this.setAttribute('role', this.role);
        this.setAriaAttributes();
        this.setDisabledClass();
        this.updateTabIndex();
    }
    ngOnChanges(changes) {
        const { index, isDisabled } = changes;
        if (anyChanged(['index', 'checkable', 'isChecked', 'expandable', 'isExpanded', 'selectable', 'isSelected'], changes)) {
            this.setAriaAttributes();
        }
        if (isDisabled) {
            this.setDisabledClass();
        }
        if (this.loadOnDemand && !this.isButton) {
            this.moveLookupItem(changes);
        }
        this.moveNavigationItem(index);
        if (anyChanged(['isDisabled', 'isVisible'], changes)) {
            this.updateNodeAvailability();
        }
    }
    ngOnDestroy() {
        this.navigationService.unregisterItem(this.id, this.index);
        if (this.loadOnDemand && !this.isButton) {
            this.lookupService.unregisterItem(this.index, this.dataItem);
        }
        this.subscriptions = this.subscriptions.reduce((list, callback) => (callback.unsubscribe(), list), []);
    }
    subscribe() {
        this.subscriptions = [
            this.navigationService.moves
                .subscribe((navState) => {
                this.updateTabIndex();
                this.focusItem(navState.shouldScroll);
            }),
            this.navigationService.expands
                .pipe(filter(({ index }) => index === this.index && !this.isDisabled))
                .subscribe(({ expand }) => this.expand(expand))
        ];
    }
    registerNavigationItem() {
        this.navigationService.registerItem(this.id, this.index, this.isDisabled, this.isButton, this.isVisible);
        this.activateItem();
    }
    activateItem() {
        if (this.isDisabled) {
            return;
        }
        const navigationService = this.navigationService;
        const selectionService = this.selectionService;
        const index = this.index;
        selectionService.setFirstSelected(index, this.isSelected);
        if (!navigationService.isActive(index) && selectionService.isFirstSelected(index)) {
            navigationService.activateIndex(index);
        }
    }
    expand(shouldExpand) {
        this.expandService[shouldExpand ? 'expand' : 'collapse'](this.index, this.dataItem);
    }
    isFocusable() {
        return !this.isDisabled && this.navigationService.isFocusable(this.index);
    }
    focusItem(scrollIntoView = false) {
        if (this.isInitialized && this.navigationService.isActive(this.index)) {
            this.element.nativeElement.focus({ preventScroll: !scrollIntoView });
        }
    }
    moveLookupItem(changes = {}) {
        const { dataItem, index, parentDataItem, parentIndex } = changes;
        if ((index && index.firstChange) || //skip first change
            (!dataItem && !index && !parentDataItem && !parentIndex)) {
            return;
        }
        const oldIndex = (index || {}).previousValue || this.index;
        this.lookupService.replaceItem(oldIndex, this.treeItem, this.parentTreeItem);
    }
    moveNavigationItem(indexChange = {}) {
        const { currentValue, firstChange, previousValue } = indexChange;
        if (!firstChange && isPresent(currentValue) && isPresent(previousValue)) {
            this.navigationService.unregisterItem(this.id, previousValue);
            this.navigationService.registerItem(this.id, currentValue, this.isDisabled, this.isButton);
        }
    }
    updateNodeAvailability() {
        const service = this.navigationService;
        if (this.isDisabled || !this.isVisible) {
            service.activateClosest(this.index); // activate before unregister the item
        }
        else {
            service.activateFocusable();
        }
        service.unregisterItem(this.id, this.index);
        service.registerItem(this.id, this.index, this.isDisabled, this.isButton, this.isVisible);
    }
    setAriaAttributes() {
        this.setAttribute('aria-level', this.ib.level(this.index).toString());
        // don't render attributes when the component configuration doesn't allow the specified state
        this.setAttribute('aria-expanded', this.expandable ? this.isExpanded.toString() : null);
        this.setAttribute('aria-selected', this.selectable ? this.isSelected.toString() : null);
        this.setAttribute('aria-checked', this.checkable ? this.ariaChecked : null);
    }
    setDisabledClass() {
        this.setClass('k-disabled', this.isDisabled);
    }
    setClass(className, toggle) {
        const action = toggle ? 'addClass' : 'removeClass';
        this.renderer[action](this.element.nativeElement, className);
    }
    updateTabIndex() {
        this.setAttribute('tabIndex', this.isFocusable() ? '0' : '-1');
    }
    setAttribute(attr, value) {
        if (!isPresent(value)) {
            this.renderer.removeAttribute(this.element.nativeElement, attr);
            return;
        }
        this.renderer.setAttribute(this.element.nativeElement, attr, value);
    }
};
TreeViewItemDirective.ɵfac = function TreeViewItemDirective_Factory(t) { return new (t || TreeViewItemDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(TreeViewLookupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(IndexBuilderService)); };
TreeViewItemDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TreeViewItemDirective, selectors: [["", "kendoTreeViewItem", ""]], inputs: { role: "role", loadOnDemand: "loadOnDemand", isDisabled: "isDisabled", isVisible: "isVisible", isChecked: "isChecked", isExpanded: "isExpanded", isSelected: "isSelected", dataItem: "dataItem", index: "index", parentDataItem: "parentDataItem", parentIndex: "parentIndex", checkable: "checkable", selectable: "selectable", expandable: "expandable" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], TreeViewItemDirective.prototype, "dataItem", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TreeViewItemDirective.prototype, "index", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TreeViewItemDirective.prototype, "parentDataItem", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TreeViewItemDirective.prototype, "parentIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TreeViewItemDirective.prototype, "role", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewItemDirective.prototype, "loadOnDemand", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewItemDirective.prototype, "checkable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewItemDirective.prototype, "selectable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewItemDirective.prototype, "expandable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TreeViewItemDirective.prototype, "isChecked", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewItemDirective.prototype, "isDisabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewItemDirective.prototype, "isVisible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], TreeViewItemDirective.prototype, "isExpanded", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], TreeViewItemDirective.prototype, "isSelected", null);
TreeViewItemDirective = __decorate([ __metadata("design:paramtypes", [ElementRef,
        ExpandStateService,
        NavigationService,
        SelectionService,
        TreeViewLookupService,
        Renderer2,
        IndexBuilderService])
], TreeViewItemDirective);

/**
 * @hidden
 *
 * A directive which manages the expanded state of the TreeView.
 */
let TreeViewItemContentDirective = class TreeViewItemContentDirective {
    constructor(element, navigationService, selectionService, renderer) {
        this.element = element;
        this.navigationService = navigationService;
        this.selectionService = selectionService;
        this.renderer = renderer;
        this.initialSelection = false;
        this.isSelected = isSelected;
        this.subscriptions = new Subscription();
        this.subscriptions.add(this.navigationService.moves
            .subscribe(this.updateFocusClass.bind(this)));
        this.subscriptions.add(this.navigationService.selects
            .pipe(filter((index) => index === this.index))
            .subscribe((index) => this.selectionService.select(index, this.dataItem)));
        this.subscriptions.add(this.selectionService.changes
            .subscribe(() => {
            this.updateSelectionClass(this.isSelected(this.dataItem, this.index));
        }));
    }
    ngOnChanges(changes) {
        if (changes.initialSelection) {
            this.updateSelectionClass(this.initialSelection);
        }
        if (changes.index) {
            this.updateFocusClass();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    updateFocusClass() {
        this.render(this.navigationService.isActive(this.index), 'k-focus');
    }
    updateSelectionClass(selected) {
        this.render(selected, 'k-selected');
    }
    render(addClass, className) {
        const action = addClass ? 'addClass' : 'removeClass';
        this.renderer[action](this.element.nativeElement, className);
    }
};
TreeViewItemContentDirective.ɵfac = function TreeViewItemContentDirective_Factory(t) { return new (t || TreeViewItemContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
TreeViewItemContentDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TreeViewItemContentDirective, selectors: [["", "kendoTreeViewItemContent", ""]], inputs: { initialSelection: "initialSelection", isSelected: "isSelected", dataItem: "dataItem", index: "index" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], TreeViewItemContentDirective.prototype, "dataItem", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TreeViewItemContentDirective.prototype, "index", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TreeViewItemContentDirective.prototype, "initialSelection", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], TreeViewItemContentDirective.prototype, "isSelected", void 0);
TreeViewItemContentDirective = __decorate([ __metadata("design:paramtypes", [ElementRef,
        NavigationService,
        SelectionService,
        Renderer2])
], TreeViewItemContentDirective);

/**
 * @hidden
 *
 * Represents the CheckBox component of the Kendo UI TreeView for Angular.
 *
 */
let CheckBoxComponent = class CheckBoxComponent {
    constructor(element, renderer, changeDetector) {
        this.element = element;
        this.renderer = renderer;
        this.changeDetector = changeDetector;
        /**
         * Specifies the [`id`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id) of the component.
         */
        this.id = `_${guid()}`;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Specifies the size of the component.
         */
        this.size = 'medium';
        /**
         * Fires when the user changes the check state of the component.
         */
        this.checkStateChange = new EventEmitter();
        this.checkState = 'none';
    }
    //XXX: implement ComponentValueAccessor
    //XXX: focus/blur methods
    get classWrapper() { return true; }
    get indeterminate() {
        return this.checkState === 'indeterminate';
    }
    get checked() {
        return this.checkState === 'checked';
    }
    get checkBoxClasses() {
        return `k-checkbox ${this.size ? getSizeClass('checkbox', this.size) : ''} k-rounded-md`;
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.element.nativeElement, "tabindex");
    }
    ngDoCheck() {
        this.checkState = this.isChecked(this.node, this.index);
    }
    handleChange(e) {
        const state = e.target.checked ? 'checked' : 'none';
        // update the View State so that Angular updates the input if the isChecked value is the same
        this.checkState = state;
        this.changeDetector.detectChanges();
        this.checkStateChange.emit(state);
    }
};
CheckBoxComponent.ɵfac = function CheckBoxComponent_Factory(t) { return new (t || CheckBoxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
CheckBoxComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CheckBoxComponent, selectors: [["kendo-checkbox"]], hostVars: 2, hostBindings: function CheckBoxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-checkbox-wrapper", ctx.classWrapper);
    } }, inputs: { id: "id", tabindex: "tabindex", size: "size", isChecked: "isChecked", node: "node", index: "index", labelText: "labelText" }, outputs: { checkStateChange: "checkStateChange" }, decls: 3, vars: 8, consts: [["type", "checkbox", 3, "id", "checked", "indeterminate", "tabindex", "change"], ["tabindex", "-1", 1, "k-checkbox-label", 3, "for"]], template: function CheckBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "input", 0);
        ɵngcc0.ɵɵlistener("change", function CheckBoxComponent_Template_input_change_0_listener($event) { return ctx.handleChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(1, "label", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.checkBoxClasses);
        ɵngcc0.ɵɵproperty("id", ctx.id)("checked", ctx.checked)("indeterminate", ctx.indeterminate)("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("for", ctx.id);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.labelText);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-checkbox-wrapper'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CheckBoxComponent.prototype, "classWrapper", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], CheckBoxComponent.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CheckBoxComponent.prototype, "isChecked", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CheckBoxComponent.prototype, "node", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CheckBoxComponent.prototype, "index", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CheckBoxComponent.prototype, "labelText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CheckBoxComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CheckBoxComponent.prototype, "size", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], CheckBoxComponent.prototype, "checkStateChange", void 0);
CheckBoxComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        ChangeDetectorRef])
], CheckBoxComponent);

const COMPONENT_DIRECTIVES = [
    CheckBoxComponent
];
/**
 * @hidden
 *
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the CheckBox component.
 */
let CheckBoxModule = class CheckBoxModule {
};
CheckBoxModule.ɵfac = function CheckBoxModule_Factory(t) { return new (t || CheckBoxModule)(); };
CheckBoxModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CheckBoxModule });
CheckBoxModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});

/**
 * A directive which enables the update of the initially provided data array during drag-and-drop.
 *
 * Either use this directive in combination with one of the data binding directives ([`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %})
 * or [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %})) which set their own edit handlers, or provide
 * your own [`editService`]({% slug api_treeview_editservice %}) to this directive. The latter subscribes to and calls the
 * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)
 * handlers when the corresponding events are triggered by the TreeView component.
 */
let DragAndDropEditingDirective = class DragAndDropEditingDirective {
    constructor(treeview) {
        this.treeview = treeview;
        this.subscriptions = new Subscription();
        this.subscriptions.add(this.treeview.addItem.subscribe(this.handleAdd.bind(this)));
        this.subscriptions.add(this.treeview.removeItem.subscribe(this.handleRemove.bind(this)));
    }
    /**
     * Specifies the handlers called on drag-and-drop [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem)
     * and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events.
     */
    set editService(service) {
        this.treeview.editService = service;
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    handleAdd(args) {
        if (!isPresent(this.treeview.editService)) {
            throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');
        }
        this.treeview.editService.add(args);
    }
    handleRemove(args) {
        if (!isPresent(this.treeview.editService)) {
            throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');
        }
        this.treeview.editService.remove(args);
    }
};
DragAndDropEditingDirective.ɵfac = function DragAndDropEditingDirective_Factory(t) { return new (t || DragAndDropEditingDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent)); };
DragAndDropEditingDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DragAndDropEditingDirective, selectors: [["", "kendoTreeViewDragAndDropEditing", ""]], inputs: { editService: "editService" } });
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DragAndDropEditingDirective.prototype, "editService", null);
DragAndDropEditingDirective = __decorate([ __metadata("design:paramtypes", [TreeViewComponent])
], DragAndDropEditingDirective);

const LOAD_MORE_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';
/**
 * A directive that enables the display of only a limited amount of nodes per level
 * ([see example]({% slug loadmorebutton_treeview %})).
 */
let LoadMoreDirective = class LoadMoreDirective {
    constructor(treeview) {
        this.treeview = treeview;
        /**
         * Keeps track of the current page size of each node over expand/collapse cycles.
         */
        this.pageSizes = new Map();
        /**
         * Used as an identifier for the root page size as the root collection of nodes is not associated with a data item.
         */
        this.rootLevelId = guid();
        this.treeview.loadMoreService = {
            getInitialPageSize: this.getInitalPageSize.bind(this),
            getGroupSize: this.getGroupSize.bind(this),
            setGroupSize: this.setGroupSize.bind(this),
            getTotalNodesCount: this.getTotalNodesCount.bind(this)
        };
    }
    /**
     * Specifies the callback that will be called when the load more button is clicked.
     * Providing a function is only required when additional nodes are fetched on demand
     * ([see example]({% slug loadmorebutton_treeview %}#toc-remote-data)).
     */
    set loadMoreNodes(loadMoreNodes) {
        if (typeof loadMoreNodes === 'string') {
            return;
        }
        this.treeview.loadMoreService.loadMoreNodes = loadMoreNodes;
    }
    ngOnChanges() {
        this.verifySettings();
    }
    verifySettings() {
        if (!isDevMode()) {
            return;
        }
        if (!isPresent(this.pageSize)) {
            throw new Error(`To use the TreeView \`kendoTreeViewLoadMore\` directive, you need to assign a \`pageSize\` value. See ${LOAD_MORE_DOC_LINK$1}.`);
        }
        const loadMoreNodes = this.treeview.loadMoreService.loadMoreNodes;
        if (isPresent(loadMoreNodes) && typeof loadMoreNodes !== 'function') {
            throw new Error(`The passed value to the \`kendoTreeViewLoadMore\` directive must be a function that retrieves additional nodes. See ${LOAD_MORE_DOC_LINK$1}.`);
        }
        if (isPresent(loadMoreNodes) && !isPresent(this.totalField)) {
            throw new Error(`When a function to fetch additional nodes is provided to the \`kendoTreeViewLoadMore\` directive, the \`totalField\` and \`totalRootNodes\` values must also be provided. See ${LOAD_MORE_DOC_LINK$1}.`);
        }
    }
    getGroupSize(dataItem) {
        const itemKey = dataItem || this.rootLevelId;
        return this.pageSizes.has(itemKey) ? this.pageSizes.get(itemKey) : this.pageSize;
    }
    setGroupSize(dataItem, pageSize) {
        const itemKey = dataItem || this.rootLevelId;
        const normalizedSizeValue = pageSize > 0 ? pageSize : 0;
        this.pageSizes.set(itemKey, normalizedSizeValue);
    }
    getTotalNodesCount(dataItem, loadedNodesCount) {
        if (isPresent(dataItem) && isPresent(this.totalField)) {
            return dataItem[this.totalField];
        }
        else if (!isPresent(dataItem) && isPresent(this.totalRootNodes)) {
            return this.totalRootNodes;
        }
        else {
            return loadedNodesCount;
        }
    }
    getInitalPageSize() {
        return this.pageSize;
    }
};
LoadMoreDirective.ɵfac = function LoadMoreDirective_Factory(t) { return new (t || LoadMoreDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent)); };
LoadMoreDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LoadMoreDirective, selectors: [["", "kendoTreeViewLoadMore", ""]], inputs: { loadMoreNodes: ["kendoTreeViewLoadMore", "loadMoreNodes"], pageSize: "pageSize", totalRootNodes: "totalRootNodes", totalField: "totalField" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input('kendoTreeViewLoadMore'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], LoadMoreDirective.prototype, "loadMoreNodes", null);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LoadMoreDirective.prototype, "pageSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LoadMoreDirective.prototype, "totalRootNodes", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LoadMoreDirective.prototype, "totalField", void 0);
LoadMoreDirective = __decorate([ __metadata("design:paramtypes", [TreeViewComponent])
], LoadMoreDirective);

const COMPONENT_DIRECTIVES$1 = [
    TreeViewComponent,
    TreeViewGroupComponent,
    TreeViewItemDirective,
    TreeViewItemContentDirective,
    NodeTemplateDirective,
    CheckDirective,
    DisableDirective,
    ExpandDirective,
    SelectDirective,
    HierarchyBindingDirective,
    LoadingIndicatorDirective,
    FlatDataBindingDirective,
    DragAndDropDirective,
    DragClueTemplateDirective,
    DragClueComponent,
    DropHintTemplateDirective,
    DropHintComponent,
    DragAndDropEditingDirective,
    LoadMoreDirective,
    LoadMoreButtonTemplateDirective
];
/**
 * @hidden
 */
let SharedModule = class SharedModule {
};
SharedModule.ɵfac = function SharedModule_Factory(t) { return new (t || SharedModule)(); };
SharedModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: SharedModule });
SharedModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            CheckBoxModule,
            InputsModule
        ]] });

const EXPORTS = [
    TreeViewComponent,
    NodeTemplateDirective,
    CheckDirective,
    DisableDirective,
    ExpandDirective,
    SelectDirective,
    HierarchyBindingDirective,
    FlatDataBindingDirective,
    DragAndDropDirective,
    DragClueTemplateDirective,
    DropHintTemplateDirective,
    DragAndDropEditingDirective,
    LoadMoreDirective,
    LoadMoreButtonTemplateDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the TreeView component.
 */
let TreeViewModule = class TreeViewModule {
};
TreeViewModule.ɵfac = function TreeViewModule_Factory(t) { return new (t || TreeViewModule)(); };
TreeViewModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: TreeViewModule });
TreeViewModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[SharedModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExpandStateService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IndexBuilderService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LoadingNotificationService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NodeChildrenService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NodeTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewNodeTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LoadMoreButtonTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewLoadMoreButtonTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DataBoundComponent, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExpandableComponent, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SelectionService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeViewLookupService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeViewComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.Default,
                exportAs: 'kendoTreeView',
                providers: providers,
                selector: 'kendo-treeview',
                template: `
        <span
            class="k-treeview-filter"
            *ngIf="filterable"
        >
            <kendo-textbox
                [size]="size"
                [value]="filter"
                [clearButton]="true"
                (valueChange)="filterChange.emit($event)"
                [placeholder]="filterInputPlaceholder"
            >
                <ng-template kendoTextBoxPrefixTemplate>
                    <span class="k-input-icon k-icon k-i-search"></span>
                </ng-template>
            </kendo-textbox>
        </span>
        <ul class="k-treeview-lines"
            kendoTreeViewGroup
            role="group"
            [size]="size"
            [loadOnDemand]="loadOnDemand"
            [checkboxes]="checkboxes"
            [expandIcons]="expandIcons"
            [selectable]="selectable"
            [touchActions]="touchActions"
            [children]="children"
            [hasChildren]="hasChildren"
            [isChecked]="isChecked"
            [isDisabled]="isDisabled"
            [isExpanded]="isExpanded"
            [isSelected]="isSelected"
            [isVisible]="isVisible"
            [nodeTemplateRef]="nodeTemplateRef?.templateRef"
            [loadMoreButtonTemplateRef]="loadMoreButtonTemplateRef?.templateRef"
            [textField]="textField"
            [nodes]="fetchNodes"
            [loadMoreService]="loadMoreService"
            [trackBy]="trackBy"
        >
        </ul>
        <ng-container #assetsContainer></ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ExpandStateService }, { type: NavigationService }, { type: NodeChildrenService }, { type: SelectionService }, { type: TreeViewLookupService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: DataChangeNotificationService }, { type: ɵngcc1.LocalizationService }]; }, { classNames: [{
            type: HostBinding,
            args: ["class.k-treeview"]
        }], role: [{
            type: HostBinding,
            args: ["attr.role"]
        }], filterInputPlaceholder: [{
            type: Input
        }], childrenLoaded: [{
            type: Output
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], nodeDragStart: [{
            type: Output
        }], nodeDrag: [{
            type: Output
        }], filterStateChange: [{
            type: Output
        }], nodeDrop: [{
            type: Output
        }], nodeDragEnd: [{
            type: Output
        }], addItem: [{
            type: Output
        }], removeItem: [{
            type: Output
        }], checkedChange: [{
            type: Output
        }], selectionChange: [{
            type: Output
        }], filterChange: [{
            type: Output
        }], nodeClick: [{
            type: Output
        }], nodeDblClick: [{
            type: Output
        }], trackBy: [{
            type: Input
        }], isDisabled: [{
            type: Input
        }], isVisible: [{
            type: Input
        }], navigable: [{
            type: Input
        }], children: [{
            type: Input
        }], loadOnDemand: [{
            type: Input
        }], filterable: [{
            type: Input
        }], filter: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ["attr.dir"]
        }], animate: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['@.disabled']
        }], nodeTemplateRef: [{
            type: Input,
            args: ['nodeTemplate']
        }], loadMoreButtonTemplateRef: [{
            type: Input,
            args: ['loadMoreButtonTemplate']
        }], nodes: [{
            type: Input
        }], hasChildren: [{
            type: Input
        }], isChecked: [{
            type: Input
        }], isExpanded: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], size: [{
            type: Input
        }], assetsContainer: [{
            type: ViewChild,
            args: ['assetsContainer', { read: ViewContainerRef, static: true }]
        }], nodeTemplateQuery: [{
            type: ContentChild,
            args: [NodeTemplateDirective, { static: false }]
        }], loadMoreButtonTemplateQuery: [{
            type: ContentChild,
            args: [LoadMoreButtonTemplateDirective, { static: false }]
        }], textField: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeViewGroupComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('toggle', [
                        transition('void => *', [
                            style({ height: 0 }),
                            animate('0.1s ease-in', style({ height: "*" }))
                        ]),
                        transition('* => void', [
                            style({ height: "*" }),
                            animate('0.1s ease-in', style({ height: 0 }))
                        ])
                    ])
                ],
                selector: '[kendoTreeViewGroup]',
                template: `
        <li
            *ngFor="let node of data; let index = index; trackBy: trackBy"
            class="k-treeview-item"
            [class.k-display-none]="!isVisible(node, nodeIndex(index))"
            kendoTreeViewItem
            [attr.aria-setsize]="totalNodesCount"
            [dataItem]="node"
            [index]="nodeIndex(index)"
            [parentDataItem]="parentDataItem"
            [parentIndex]="parentIndex"
            [loadOnDemand]="loadOnDemand"
            [checkable]="checkboxes"
            [isChecked]="isChecked(node, nodeIndex(index))"
            [isDisabled]="disabled || isDisabled(node, nodeIndex(index))"
            [isVisible]="isVisible(node, nodeIndex(index))"
            [expandable]="expandIcons && hasChildren(node)"
            [isExpanded]="isExpanded(node, nodeIndex(index))"
            [selectable]="selectable"
            [isSelected]="isSelected(node, nodeIndex(index))"
            [attr.data-treeindex]="nodeIndex(index)"
        >
            <div class="k-treeview-mid">
                <span
                    class="k-treeview-toggle"
                    [kendoTreeViewLoading]="nodeIndex(index)"
                    (click)="expandNode(nodeIndex(index), node, !isExpanded(node, nodeIndex(index)))"
                    *ngIf="expandIcons && hasChildren(node)"
                >
                    <span
                        class="k-icon"
                        [class.k-i-collapse]="isExpanded(node, nodeIndex(index))"
                        [class.k-i-expand]="!isExpanded(node, nodeIndex(index))"
                    >
                    </span>
                </span>
                <kendo-checkbox
                    *ngIf="checkboxes"
                    [size]="size"
                    [node]="node"
                    [index]="nodeIndex(index)"
                    [isChecked]="isChecked"
                    (checkStateChange)="checkNode(nodeIndex(index))"
                    tabindex="-1"
                ></kendo-checkbox>
                <span kendoTreeViewItemContent
                    [attr.data-treeindex]="nodeIndex(index)"
                    [dataItem]="node"
                    [index]="nodeIndex(index)"
                    [initialSelection]="isSelected(node, nodeIndex(index))"
                    [isSelected]="isSelected"
                    class="k-treeview-leaf"
                    [style.touch-action]="touchActions ? '' : 'none'"
                >
                    <span class="k-treeview-leaf-text">
                        <ng-container [ngSwitch]="hasTemplate">
                            <ng-container *ngSwitchCase="true">
                                <ng-template
                                    [ngTemplateOutlet]="nodeTemplateRef"
                                    [ngTemplateOutletContext]="{
                                        $implicit: node,
                                        index: nodeIndex(index)
                                    }"
                                >
                                </ng-template>
                            </ng-container>
                            <ng-container *ngSwitchDefault>
                                {{nodeText(node)}}
                            </ng-container>
                        </ng-container>
                    </span>
                </span>
            </div>
            <ul
                *ngIf="isExpanded(node, nodeIndex(index)) && hasChildren(node)"
                kendoTreeViewGroup
                role="group"
                [nodes]="fetchChildren"
                [loadOnDemand]="loadOnDemand"
                [checkboxes]="checkboxes"
                [expandIcons]="expandIcons"
                [selectable]="selectable"
                [touchActions]="touchActions"
                [children]="children"
                [hasChildren]="hasChildren"
                [isChecked]="isChecked"
                [isDisabled]="isDisabled"
                [disabled]="disabled || isDisabled(node, nodeIndex(index))"
                [isExpanded]="isExpanded"
                [isSelected]="isSelected"
                [isVisible]="isVisible"
                [nodeTemplateRef]="nodeTemplateRef"
                [loadMoreButtonTemplateRef]="loadMoreButtonTemplateRef"
                [parentIndex]="nodeIndex(index)"
                [parentDataItem]="node"
                [textField]="nextFields"
                [loadMoreService]="loadMoreService"
                [@toggle]="true"
                [trackBy]="trackBy"
            >
            </ul>
        </li>
        <li
            *ngIf="initialNodesLoaded && moreNodesAvailable"
            class="k-treeview-item"
            [class.k-treeview-load-more-checkboxes-container]="checkboxes"
            kendoTreeViewItem
            role="button"
            [selectable]="false"
            [checkable]="false"
            [expandable]="false"
            [index]="loadMoreButtonIndex"
            [parentDataItem]="parentDataItem"
            [parentIndex]="parentIndex"
            [attr.data-treeindex]="loadMoreButtonIndex"
        >
            <div class="k-treeview-mid">
                <span
                    *ngIf="loadingMoreNodes"
                    class="k-icon k-i-loading k-i-expand"
                >
                </span>
                <span
                    class="k-treeview-leaf k-treeview-load-more-button"
                    [attr.data-treeindex]="loadMoreButtonIndex"
                    kendoTreeViewItemContent
                    [index]="loadMoreButtonIndex"
                >
                    <span class="k-treeview-leaf-text">
                        <ng-template
                            *ngIf="loadMoreButtonTemplateRef"
                            [ngTemplateOutlet]="loadMoreButtonTemplateRef"
                            [ngTemplateOutletContext]="{
                                index: loadMoreButtonIndex
                            }"
                        >
                        </ng-template>
                        <ng-container *ngIf="!loadMoreButtonTemplateRef">
                            Load more
                        </ng-container>
                    </span>
                </span>
            </div>
        </li>
    `
            }]
    }], function () { return [{ type: ExpandStateService }, { type: LoadingNotificationService }, { type: IndexBuilderService }, { type: TreeViewLookupService }, { type: NavigationService }, { type: NodeChildrenService }, { type: DataChangeNotificationService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { kGroupClass: [{
            type: HostBinding,
            args: ["class.k-treeview-group"]
        }], role: [{
            type: HostBinding,
            args: ["attr.role"]
        }], loadOnDemand: [{
            type: Input
        }], textField: [{
            type: Input
        }], size: [{
            type: Input
        }], isChecked: [{
            type: Input
        }], isDisabled: [{
            type: Input
        }], isExpanded: [{
            type: Input
        }], isVisible: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], children: [{
            type: Input
        }], hasChildren: [{
            type: Input
        }], checkboxes: [{
            type: Input
        }], expandIcons: [{
            type: Input
        }], disabled: [{
            type: Input
        }], selectable: [{
            type: Input
        }], touchActions: [{
            type: Input
        }], trackBy: [{
            type: Input
        }], nodes: [{
            type: Input
        }], parentDataItem: [{
            type: Input
        }], parentIndex: [{
            type: Input
        }], nodeTemplateRef: [{
            type: Input
        }], loadMoreButtonTemplateRef: [{
            type: Input
        }], loadMoreService: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CheckDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewCheckable]' }]
    }], function () { return [{ type: TreeViewComponent }, { type: ɵngcc0.NgZone }]; }, { checkedKeysChange: [{
            type: Output
        }], isChecked: [{
            type: Input
        }], checkKey: [{
            type: Input,
            args: ["checkBy"]
        }], checkedKeys: [{
            type: Input
        }], checkable: [{
            type: Input,
            args: ['kendoTreeViewCheckable']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DisableDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewDisable]' }]
    }], function () { return [{ type: TreeViewComponent }, { type: ɵngcc0.ChangeDetectorRef }]; }, { disabledKeys: [{
            type: Input
        }], isDisabled: [{
            type: Input
        }], disableKey: [{
            type: Input,
            args: ["kendoTreeViewDisable"]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExpandDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewExpandable]' }]
    }], function () { return [{ type: ExpandableComponent }]; }, { expandOnFilter: [{
            type: Input
        }], expandedKeysChange: [{
            type: Output
        }], isExpanded: [{
            type: Input
        }], expandKey: [{
            type: Input,
            args: ["expandBy"]
        }], expandedKeys: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SelectDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewSelectable]' }]
    }], function () { return [{ type: TreeViewComponent }]; }, { selectedKeysChange: [{
            type: Output
        }], isSelected: [{
            type: Input
        }], getAriaMultiselectable: [{
            type: HostBinding,
            args: ['attr.aria-multiselectable']
        }], selectKey: [{
            type: Input,
            args: ['selectBy']
        }], selection: [{
            type: Input,
            args: ['kendoTreeViewSelectable']
        }], selectedKeys: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragClueComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-treeview-drag-clue',
                template: `
        <ng-container *ngIf="!template">
            <span class="k-icon {{statusIconClass}} k-drag-status"></span>
            <span>{{text}}</span>
        </ng-container>

        <ng-template
            *ngIf="template"
            [ngTemplateOutlet]="template"
            [ngTemplateOutletContext]="{
                text: text,
                action: action,
                sourceItem: sourceItem,
                destinationItem: destinationItem
            }"
        >
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-header']
        }, {
            type: HostBinding,
            args: ['class.k-drag-clue']
        }], posistionStyle: [{
            type: HostBinding,
            args: ['style.position']
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragClueService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropHintComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-treeview-drop-hint',
                template: `
        <div
            *ngIf="!template"
            class="k-drop-hint k-drop-hint-h"
        >
            <div class='k-drop-hint-start'></div>
            <div class='k-drop-hint-line'></div>
        </div>

        <ng-template
            *ngIf="template"
            [ngTemplateOutlet]="template"
            [ngTemplateOutletContext]="{
                action: action,
                sourceItem: sourceItem,
                destinationItem: destinationItem
            }"
        >
        <ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-drop-hint-container']
        }], position: [{
            type: HostBinding,
            args: ['style.position']
        }], pointerEvents: [{
            type: HostBinding,
            args: ['style.pointer-events']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropHintService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragClueTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewDragClueTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropHintTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewDropHintTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragAndDropDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewDragAndDrop]',
                providers: [
                    DragClueService,
                    DropHintService
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: TreeViewComponent }, { type: DragClueService }, { type: DropHintService }]; }, { allowCopy: [{
            type: Input
        }], dropZoneTreeViews: [{
            type: Input
        }], startDragAfter: [{
            type: Input
        }], autoScroll: [{
            type: Input
        }], userSelectStyle: [{
            type: HostBinding,
            args: ['style.user-select']
        }, {
            type: HostBinding,
            args: ['style.-ms-user-select']
        }, {
            type: HostBinding,
            args: ['style.-moz-user-select']
        }, {
            type: HostBinding,
            args: ['style.-webkit-user-select']
        }], dragClueTemplate: [{
            type: ContentChild,
            args: [DragClueTemplateDirective, { static: false }]
        }], dropHintTemplate: [{
            type: ContentChild,
            args: [DropHintTemplateDirective, { static: false }]
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HierarchyBindingDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewHierarchyBinding]' }]
    }], function () { return [{ type: DataBoundComponent }, { type: DragAndDropDirective, decorators: [{
                type: Optional
            }, {
                type: Host
            }] }]; }, { loadOnDemand: [{
            type: Input
        }], childrenField: [{
            type: Input
        }], nodes: [{
            type: Input
        }], isVisible: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LoadingIndicatorDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewLoading]' }]
    }], function () { return [{ type: ExpandStateService }, { type: LoadingNotificationService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { loading: [{
            type: HostBinding,
            args: ["class.k-i-loading"]
        }], index: [{
            type: Input,
            args: ["kendoTreeViewLoading"]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FlatDataBindingDirective, [{
        type: Directive,
        args: [{ selector: "[kendoTreeViewFlatDataBinding]" }]
    }], function () { return [{ type: DataBoundComponent }]; }, { loadOnDemand: [{
            type: Input
        }], nodes: [{
            type: Input
        }], isVisible: [{
            type: Input
        }], parentIdField: [{
            type: Input
        }], idField: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeViewItemDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewItem]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ExpandStateService }, { type: NavigationService }, { type: SelectionService }, { type: TreeViewLookupService }, { type: ɵngcc0.Renderer2 }, { type: IndexBuilderService }]; }, { role: [{
            type: Input
        }], loadOnDemand: [{
            type: Input
        }], isDisabled: [{
            type: Input
        }], isVisible: [{
            type: Input
        }], isChecked: [{
            type: Input
        }], isExpanded: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], dataItem: [{
            type: Input
        }], index: [{
            type: Input
        }], parentDataItem: [{
            type: Input
        }], parentIndex: [{
            type: Input
        }], checkable: [{
            type: Input
        }], selectable: [{
            type: Input
        }], expandable: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeViewItemContentDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewItemContent]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NavigationService }, { type: SelectionService }, { type: ɵngcc0.Renderer2 }]; }, { initialSelection: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], dataItem: [{
            type: Input
        }], index: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CheckBoxComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-checkbox',
                template: `
        <input
            type="checkbox"
            [class]="checkBoxClasses"
            [id]="id"
            [checked]="checked"
            [indeterminate]="indeterminate"
            [tabindex]="tabindex"
            (change)="handleChange($event)"
        />
        <label
            class="k-checkbox-label"
            tabindex="-1"
            [for]="id"
        >{{labelText}}</label>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { id: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], size: [{
            type: Input
        }], checkStateChange: [{
            type: Output
        }], classWrapper: [{
            type: HostBinding,
            args: ['class.k-checkbox-wrapper']
        }], isChecked: [{
            type: Input
        }], node: [{
            type: Input
        }], index: [{
            type: Input
        }], labelText: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CheckBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES],
                exports: [COMPONENT_DIRECTIVES]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CheckBoxModule, { declarations: [CheckBoxComponent], exports: [CheckBoxComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragAndDropEditingDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewDragAndDropEditing]'
            }]
    }], function () { return [{ type: TreeViewComponent }]; }, { editService: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LoadMoreDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewLoadMore]'
            }]
    }], function () { return [{ type: TreeViewComponent }]; }, { loadMoreNodes: [{
            type: Input,
            args: ['kendoTreeViewLoadMore']
        }], pageSize: [{
            type: Input
        }], totalRootNodes: [{
            type: Input
        }], totalField: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SharedModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES$1],
                exports: [COMPONENT_DIRECTIVES$1],
                imports: [
                    CommonModule,
                    CheckBoxModule,
                    InputsModule
                ],
                entryComponents: [
                    DragClueComponent,
                    DropHintComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedModule, { declarations: function () { return [TreeViewComponent, TreeViewGroupComponent, TreeViewItemDirective, TreeViewItemContentDirective, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, LoadingIndicatorDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DragClueComponent, DropHintTemplateDirective, DropHintComponent, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective]; }, imports: function () { return [CommonModule, CheckBoxModule, InputsModule]; }, exports: function () { return [TreeViewComponent, TreeViewGroupComponent, TreeViewItemDirective, TreeViewItemContentDirective, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, LoadingIndicatorDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DragClueComponent, DropHintTemplateDirective, DropHintComponent, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeViewModule, [{
        type: NgModule,
        args: [{
                exports: [EXPORTS],
                imports: [SharedModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TreeViewModule, { imports: [SharedModule], exports: [TreeViewComponent, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DropHintTemplateDirective, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective] }); })();


/**
 * Generated bundle index. Do not edit.
 */

export { CheckBoxComponent, CheckBoxModule, DataChangeNotificationService, DragClueComponent, DragClueService, DropHintComponent, DropHintService, DragAndDropAssetService, PreventableEvent, ExpandStateService, FilteringBase, IndexBuilderService, LoadingIndicatorDirective, LoadingNotificationService, NavigationService, NodeChildrenService, SelectionService, SharedModule, TreeViewGroupComponent, TreeViewItemContentDirective, TreeViewItemDirective, TreeViewLookupService, TreeViewComponent, TreeViewModule, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, DataBoundComponent, ExpandableComponent, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragAndDropEditingDirective, DropHintTemplateDirective, DragClueTemplateDirective, DropAction, DropPosition, TreeItemDropEvent, TreeItemDragStartEvent, TreeItemDragEvent, LoadMoreDirective, LoadMoreButtonTemplateDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FLQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0tBR3VCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttS0FHd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3TEFHK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2SkFBRTtBQUNGLGdDQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21LQUd3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lKQUFFO0FBQ0Ysb0NBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VMQUFFO0FBQ0YsOENBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnS0FHdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttS0FHd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MEpBR3FCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lLQUcwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0tBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBa0RHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FpS0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlhBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJTQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VYQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7MFFBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7cUdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0F1Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eUdBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VKQUFFO0FBQ0YsOEJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7cUdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0F5Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dUpBQUU7QUFDRiw4QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUtBQUU7QUFDRix3Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxS0FBRTtBQUNGLHdDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7ZUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBUUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxSkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21XQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7aUVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29YQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnaUJBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2lVQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FvQkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Z0VBTW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttTkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7K1VBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2NBZWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIxIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIEluamVjdGFibGUsIERpcmVjdGl2ZSwgT3B0aW9uYWwsIFRlbXBsYXRlUmVmLCBmb3J3YXJkUmVmLCBpc0Rldk1vZGUsIEhvc3RCaW5kaW5nLCBWaWV3Q2hpbGQsIFZpZXdDb250YWluZXJSZWYsIElucHV0LCBPdXRwdXQsIENvbnRlbnRDaGlsZCwgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgRWxlbWVudFJlZiwgQ2hhbmdlRGV0ZWN0b3JSZWYsIE5nWm9uZSwgUmVuZGVyZXIyLCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIEhvc3QsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc0RvY3VtZW50QXZhaWxhYmxlLCBLZXlzLCBhbnlDaGFuZ2VkLCBoYXNPYnNlcnZlcnMsIGlzQ2hhbmdlZCwgZ3VpZCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWwxMG4nO1xuaW1wb3J0IHsgU3ViamVjdCwgb2YsIEJlaGF2aW9yU3ViamVjdCwgU3Vic2NyaXB0aW9uLCBFTVBUWSwgbWVyZ2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHZhbGlkYXRlUGFja2FnZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1saWNlbnNpbmcnO1xuaW1wb3J0IHsgZ2V0dGVyLCBzZXR0ZXIgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tY29tbW9uJztcbmltcG9ydCB7IHRyaWdnZXIsIHRyYW5zaXRpb24sIHN0eWxlLCBhbmltYXRlIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBmaWx0ZXIsIGNhdGNoRXJyb3IsIHRhcCwgZmluYWxpemUsIHN3aXRjaE1hcCwgdGFrZSwgbWFwLCBkZWxheSwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCBEcmFnZ2FibGUgZnJvbSAnQHRlbGVyaWsva2VuZG8tZHJhZ2dhYmxlJztcbmltcG9ydCB7IElucHV0c01vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWlucHV0cyc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYWNrYWdlTWV0YWRhdGEgPSB7XG4gICAgbmFtZTogJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXRyZWV2aWV3JyxcbiAgICBwcm9kdWN0TmFtZTogJ0tlbmRvIFVJIGZvciBBbmd1bGFyJyxcbiAgICBwcm9kdWN0Q29kZXM6IFsnS0VORE9VSUFOR1VMQVInLCAnS0VORE9VSUNPTVBMRVRFJ10sXG4gICAgcHVibGlzaERhdGU6IDE2NDYyMTkyNTYsXG4gICAgdmVyc2lvbjogJycsXG4gICAgbGljZW5zaW5nRG9jc1VybDogJ2h0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvbXktbGljZW5zZS8/dXRtX21lZGl1bT1wcm9kdWN0JnV0bV9zb3VyY2U9a2VuZG9hbmd1bGFyJnV0bV9jYW1wYWlnbj1rZW5kby11aS1hbmd1bGFyLXB1cmNoYXNlLWxpY2Vuc2Uta2V5cy13YXJuaW5nJ1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERhdGFDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzQ2hpbGRyZW4gPSAoKSA9PiBmYWxzZTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0NoZWNrZWQgPSAoKSA9PiAnbm9uZSc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNEaXNhYmxlZCA9ICgpID0+IGZhbHNlO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzRXhwYW5kZWQgPSAoKSA9PiB0cnVlO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzU2VsZWN0ZWQgPSAoKSA9PiBmYWxzZTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1Zpc2libGUgPSAoKSA9PiB0cnVlO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHRyYWNrQnkgPSAoXywgaXRlbSkgPT4gaXRlbTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBFeHBhbmRTdGF0ZVNlcnZpY2UgPSBjbGFzcyBFeHBhbmRTdGF0ZVNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgZXhwYW5kKGluZGV4LCBkYXRhSXRlbSkge1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCh7IGRhdGFJdGVtLCBpbmRleCwgZXhwYW5kOiB0cnVlIH0pO1xuICAgIH1cbiAgICBjb2xsYXBzZShpbmRleCwgZGF0YUl0ZW0pIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoeyBkYXRhSXRlbSwgaW5kZXgsIGV4cGFuZDogZmFsc2UgfSk7XG4gICAgfVxufTtcbkV4cGFuZFN0YXRlU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgRXhwYW5kU3RhdGVTZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBJbmRleEJ1aWxkZXJTZXJ2aWNlID0gY2xhc3MgSW5kZXhCdWlsZGVyU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLklOREVYX1NFUEFSQVRPUiA9ICdfJztcbiAgICB9XG4gICAgbm9kZUluZGV4KGluZGV4ID0gJycsIHBhcmVudEluZGV4ID0gJycpIHtcbiAgICAgICAgcmV0dXJuIGAke3BhcmVudEluZGV4fSR7cGFyZW50SW5kZXggPyB0aGlzLklOREVYX1NFUEFSQVRPUiA6ICcnfSR7aW5kZXh9YDtcbiAgICB9XG4gICAgaW5kZXhGb3JMZXZlbChpbmRleCwgbGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4LnNwbGl0KHRoaXMuSU5ERVhfU0VQQVJBVE9SKS5zbGljZSgwLCBsZXZlbCkuam9pbih0aGlzLklOREVYX1NFUEFSQVRPUik7XG4gICAgfVxuICAgIGxhc3RMZXZlbEluZGV4KGluZGV4ID0gJycpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBpbmRleC5zcGxpdCh0aGlzLklOREVYX1NFUEFSQVRPUik7XG4gICAgICAgIGlmICghcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUludChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSwgMTApO1xuICAgIH1cbiAgICBsZXZlbChpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXguc3BsaXQodGhpcy5JTkRFWF9TRVBBUkFUT1IpLmxlbmd0aDtcbiAgICB9XG59O1xuSW5kZXhCdWlsZGVyU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgSW5kZXhCdWlsZGVyU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTG9hZGluZ05vdGlmaWNhdGlvblNlcnZpY2UgPSBjbGFzcyBMb2FkaW5nTm90aWZpY2F0aW9uU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICBub3RpZnlMb2FkZWQoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoaW5kZXgpO1xuICAgIH1cbn07XG5Mb2FkaW5nTm90aWZpY2F0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgTG9hZGluZ05vdGlmaWNhdGlvblNlcnZpY2UpO1xuXG5jb25zdCBmb2N1c2FibGVSZWdleCA9IC9eKD86YXxpbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC9pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG1hdGNoID0gKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlciA9IGVsZW1lbnQubWF0Y2hlcyB8fCBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVyLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0V2l0aE1hdGNoID0gKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50O1xuICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGlmIChtYXRjaChwYXJlbnQsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudCB8fCBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNQcmVzZW50ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzQmxhbmsgPSAodmFsdWUpID0+IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNBcnJheSA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNOdWxsT3JFbXB0eVN0cmluZyA9ICh2YWx1ZSkgPT4gaXNCbGFuayh2YWx1ZSkgfHwgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0Jvb2xlYW4gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3ROb2RlID0gKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9ICdsaS5rLXRyZWV2aWV3LWl0ZW0nO1xuICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jbG9zZXN0KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RXaXRoTWF0Y2goZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH1cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNGb2N1c2FibGUgPSAoZWxlbWVudCkgPT4ge1xuICAgIGlmIChlbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgICAgICBjb25zdCBza2lwVGFiID0gdGFiSW5kZXggPT09ICctMSc7XG4gICAgICAgIGxldCBmb2N1c2FibGUgPSB0YWJJbmRleCAhPT0gbnVsbCAmJiAhc2tpcFRhYjtcbiAgICAgICAgaWYgKGZvY3VzYWJsZVJlZ2V4LnRlc3QodGFnTmFtZSkpIHtcbiAgICAgICAgICAgIGZvY3VzYWJsZSA9ICFlbGVtZW50LmRpc2FibGVkICYmICFza2lwVGFiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb2N1c2FibGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNDb250ZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBzY29wZVNlbGVjdG9yID0gJy5rLXRyZWV2aWV3LWxlYWY6bm90KC5rLXRyZWV2aWV3LWxvYWQtbW9yZS1idXR0b24pLC5rLXRyZWV2aWV3LWl0ZW0sLmstdHJlZXZpZXcnO1xuICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG4gICAgd2hpbGUgKG5vZGUgJiYgIW1hdGNoKG5vZGUsIHNjb3BlU2VsZWN0b3IpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlKSB7XG4gICAgICAgIHJldHVybiBtYXRjaChub2RlLCAnLmstdHJlZXZpZXctbGVhZjpub3QoLmstdHJlZXZpZXctbG9hZC1tb3JlLWJ1dHRvbiknKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmV0dXJucyB0aGUgbmVzdGVkIC5rLXRyZWV2aWV3LWxlYWY6bm90KC5rLXRyZWV2aWV3LWxvYWQtbW9yZS1idXR0b24pIGVsZW1lbnQuXG4gKiBJZiB0aGUgcGFzc2VkIHBhcmVudCBpdGVtIGlzIGl0c2VsZiBhIGNvbnRlbnQgbm9kZSwgaXQgaXMgcmV0dXJuZWQuXG4gKi9cbmNvbnN0IGdldENvbnRlbnRFbGVtZW50ID0gKHBhcmVudCkgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdG9yID0gJy5rLXRyZWV2aWV3LWxlYWY6bm90KC5rLXRyZWV2aWV3LWxvYWQtbW9yZS1idXR0b24pJztcbiAgICBpZiAobWF0Y2gocGFyZW50LCBzZWxlY3RvcikpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNMb2FkTW9yZUJ1dHRvbiA9IChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIGlzUHJlc2VudChjbG9zZXN0V2l0aE1hdGNoKGVsZW1lbnQsICcuay10cmVldmlldy1sZWFmLmstdHJlZXZpZXctbG9hZC1tb3JlLWJ1dHRvbicpKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY2xvc2VzdCA9IChub2RlLCBwcmVkaWNhdGUpID0+IHtcbiAgICB3aGlsZSAobm9kZSAmJiAhcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNQYXJlbnQgPSAoZWxlbWVudCwgY29udGFpbmVyKSA9PiB7XG4gICAgcmV0dXJuIEJvb2xlYW4oY2xvc2VzdChlbGVtZW50LCAobm9kZSkgPT4gbm9kZSA9PT0gY29udGFpbmVyKSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZvY3VzYWJsZU5vZGUgPSAoZWxlbWVudCkgPT4gZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpW3RhYmluZGV4PVwiMFwiXScpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG5vZGVJZCA9IChub2RlKSA9PiBub2RlID8gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHJlZWluZGV4JykgOiAnJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub2RlSW5kZXggPSAoaXRlbSkgPT4gKGl0ZW0gfHwge30pLmluZGV4O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRhdGFJdGVtc0VxdWFsID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudChmaXJzdCkgJiYgIWlzUHJlc2VudChzZWNvbmQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaXNQcmVzZW50KGZpcnN0KSAmJiBpc1ByZXNlbnQoc2Vjb25kKSAmJiBmaXJzdC5pdGVtLmRhdGFJdGVtID09PSBzZWNvbmQuaXRlbS5kYXRhSXRlbTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2V0RGF0YUl0ZW0gPSAobG9va3VwKSA9PiB7XG4gICAgaWYgKCFpc1ByZXNlbnQobG9va3VwKSkge1xuICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgIH1cbiAgICByZXR1cm4gbG9va3VwLml0ZW0uZGF0YUl0ZW07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzQXJyYXlXaXRoQXRMZWFzdE9uZUl0ZW0gPSB2ID0+IHYgJiYgQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCAhPT0gMDtcbi8qKlxuICogQGhpZGRlblxuICogQSByZWN1cnNpdmUgdHJlZS1maWx0ZXJpbmcgYWxnb3JpdGhtIHRoYXQgcmV0dXJuczpcbiAqIC0gYWxsIGNoaWxkIG5vZGVzIG9mIG1hdGNoaW5nIG5vZGVzXG4gKiAtIGEgY2hhaW4gcGFyZW50IG5vZGVzIGZyb20gdGhlIG1hdGNoIHRvIHRoZSByb290IG5vZGVcbiAqL1xuY29uc3QgZmlsdGVyVHJlZSA9IChpdGVtcywgdGVybSwgeyBvcGVyYXRvciwgaWdub3JlQ2FzZSwgbW9kZSB9LCB0ZXh0RmllbGQsIGRlcHRoID0gMCkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gdHlwZW9mIHRleHRGaWVsZCA9PT0gXCJzdHJpbmdcIiA/IHRleHRGaWVsZCA6IHRleHRGaWVsZFtkZXB0aF07XG4gICAgaXRlbXMuZm9yRWFjaCgod3JhcHBlcikgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaGVyID0gdHlwZW9mIG9wZXJhdG9yID09PSBcInN0cmluZ1wiID8gbWF0Y2hCeUZpZWxkQW5kQ2FzZShmaWVsZCwgb3BlcmF0b3IsIGlnbm9yZUNhc2UpIDogb3BlcmF0b3I7XG4gICAgICAgIGNvbnN0IGlzTWF0Y2ggPSBtYXRjaGVyKHdyYXBwZXIuZGF0YUl0ZW0sIHRlcm0pO1xuICAgICAgICB3cmFwcGVyLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgICAgICB3cmFwcGVyLnZpc2libGUgPSBpc01hdGNoO1xuICAgICAgICB3cmFwcGVyLmNvbnRhaW5zTWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICAgICAgc2V0UGFyZW50Q2hhaW4od3JhcHBlci5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwcGVyLmNoaWxkcmVuICYmIHdyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwic3RyaWN0XCIgfHwgIWlzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJUcmVlKHdyYXBwZXIuY2hpbGRyZW4sIHRlcm0sIHsgb3BlcmF0b3IsIGlnbm9yZUNhc2UsIG1vZGUgfSwgdGV4dEZpZWxkLCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFrZUFsbFZpc2libGUod3JhcHBlci5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5jb25zdCBzZXRQYXJlbnRDaGFpbiA9IChub2RlKSA9PiB7XG4gICAgaWYgKCFpc1ByZXNlbnQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBub2RlLmNvbnRhaW5zTWF0Y2hlcyA9IHRydWU7XG4gICAgbm9kZS52aXNpYmxlID0gdHJ1ZTtcbiAgICBpZiAoaXNQcmVzZW50KG5vZGUucGFyZW50KSAmJiAhbm9kZS5wYXJlbnQuY29udGFpbnNNYXRjaGVzKSB7XG4gICAgICAgIHNldFBhcmVudENoYWluKG5vZGUucGFyZW50KTtcbiAgICB9XG59O1xuY29uc3QgbWFrZUFsbFZpc2libGUgPSAobm9kZXMpID0+IHtcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBub2RlLnZpc2libGUgPSB0cnVlO1xuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgbWFrZUFsbFZpc2libGUobm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5jb25zdCDJtTIgPSAoYSwgYikgPT4gYS5pbmRleE9mKGIpID49IDAsIMm1MyA9IChhLCBiKSA9PiBhLmluZGV4T2YoYikgPT09IC0xLCDJtTQgPSAoYSwgYikgPT4gYS5sYXN0SW5kZXhPZihiLCAwKSA9PT0gMCwgybU1ID0gKGEsIGIpID0+IGEubGFzdEluZGV4T2YoYiwgMCkgPT09IC0xLCDJtTYgPSAoYSwgYikgPT4gYS5pbmRleE9mKGIsIGEubGVuZ3RoIC0gYi5sZW5ndGgpID49IDAsIMm1NyA9IChhLCBiKSA9PiBhLmluZGV4T2YoYiwgYS5sZW5ndGggLSBiLmxlbmd0aCkgPCAwO1xuY29uc3Qgb3BlcmF0b3JzID0ge1xuICAgIGNvbnRhaW5zOiDJtTIsXG4gICAgZG9lc25vdGNvbnRhaW46IMm1MyxcbiAgICBzdGFydHN3aXRoOiDJtTQsXG4gICAgZG9lc25vdHN0YXJ0d2l0aDogybU1LFxuICAgIGVuZHN3aXRoOiDJtTYsXG4gICAgZG9lc25vdGVuZHdpdGg6IMm1N1xufTtcbmNvbnN0IG1hdGNoQnlDYXNlID0gKG1hdGNoZXIsIGlnbm9yZUNhc2UpID0+IChhLCBiKSA9PiB7XG4gICAgaWYgKGlnbm9yZUNhc2UpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIoYS50b0xvd2VyQ2FzZSgpLCBiLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcihhLCBiKTtcbn07XG5jb25zdCBtYXRjaEJ5RmllbGRBbmRDYXNlID0gKGZpZWxkLCBvcGVyYXRvciwgaWdub3JlQ2FzZSkgPT4gKGRhdGFJdGVtLCB0ZXJtKSA9PiBtYXRjaEJ5Q2FzZShvcGVyYXRvcnNbb3BlcmF0b3JdLCBpZ25vcmVDYXNlKShnZXR0ZXIoZmllbGQpKGRhdGFJdGVtKSwgdGVybSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgYnVpbGRUcmVlSW5kZXggPSAocGFyZW50SW5kZXgsIGl0ZW1JbmRleCkgPT4ge1xuICAgIHJldHVybiBbcGFyZW50SW5kZXgsIGl0ZW1JbmRleF0uZmlsdGVyKHBhcnQgPT4gaXNQcmVzZW50KHBhcnQpKS5qb2luKCdfJyk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGJ1aWxkVHJlZUl0ZW0gPSAoZGF0YUl0ZW0sIGN1cnJlbnRMZXZlbEluZGV4LCBwYXJlbnRJbmRleCkgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KGRhdGFJdGVtKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YUl0ZW0sXG4gICAgICAgIGluZGV4OiBidWlsZFRyZWVJbmRleChwYXJlbnRJbmRleCwgY3VycmVudExldmVsSW5kZXgpXG4gICAgfTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBSZXRyaWV2ZXMgYWxsIGRlc2NlbmRhbnQgbm9kZXMnIGxvb2t1cHMgd2hpY2ggYXJlIGN1cnJlbnRseSByZWdpc3RlcmVkIGluIHRoZSBwcm92aWRlZCBsb29rdXAgaXRlbSBhcyBhIGZsYXQgYXJyYXkuXG4gKi9cbmNvbnN0IGZldGNoTG9hZGVkRGVzY2VuZGFudHMgPSAobG9va3VwLCBmaWx0ZXJFeHByZXNzaW9uKSA9PiB7XG4gICAgaWYgKCFpc1ByZXNlbnQobG9va3VwKSB8fCBsb29rdXAuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGRlc2NlbmRhbnRzID0gbG9va3VwLmNoaWxkcmVuO1xuICAgIGlmIChpc1ByZXNlbnQoZmlsdGVyRXhwcmVzc2lvbikpIHtcbiAgICAgICAgZGVzY2VuZGFudHMgPSBkZXNjZW5kYW50cy5maWx0ZXIoZmlsdGVyRXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGRlc2NlbmRhbnRzLmZvckVhY2goY2hpbGQgPT4gZGVzY2VuZGFudHMgPSBkZXNjZW5kYW50cy5jb25jYXQoZmV0Y2hMb2FkZWREZXNjZW5kYW50cyhjaGlsZCwgZmlsdGVyRXhwcmVzc2lvbikpKTtcbiAgICByZXR1cm4gZGVzY2VuZGFudHM7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogQ29tcGFyZXMgdHdvIFNlZXRzIHRvIGRldGVybWluZSB3aGV0aGVyIGFsbCB1bmlxdWUgZWxlbWVudHMgaW4gb25lLCBhcmUgcHJlc2VudCBpbiB0aGUgb3RoZXIuXG4gKiBJbXBvcnRhbnQ6XG4gKiAgLSBpdCBkaXNyZWdhcmRzIHRoZSBlbGVtZW50IG9yZGVyXG4gKi9cbmNvbnN0IHNhbWVWYWx1ZXMgPSAoYXMsIGJzKSA9PiB7XG4gICAgaWYgKGFzLnNpemUgIT09IGJzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcykuZXZlcnkodiA9PiBicy5oYXModikpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICogUmV0dXJucyB0aGUgc2l6ZSBjbGFzcyBiYXNlZCBvbiB0aGUgY29tcG9uZW50IGFuZCBzaXplIGlucHV0LlxuICovXG5jb25zdCBnZXRTaXplQ2xhc3MgPSAoY29tcG9uZW50LCBzaXplKSA9PiB7XG4gICAgY29uc3QgU0laRV9DTEFTU0VTID0ge1xuICAgICAgICAnc21hbGwnOiBgay0ke2NvbXBvbmVudH0tc21gLFxuICAgICAgICAnbWVkaXVtJzogYGstJHtjb21wb25lbnR9LW1kYCxcbiAgICAgICAgJ2xhcmdlJzogYGstJHtjb21wb25lbnR9LWxnYFxuICAgIH07XG4gICAgcmV0dXJuIFNJWkVfQ0xBU1NFU1tzaXplXTtcbn07XG5cbmNvbnN0IHNhZmUgPSBub2RlID0+IChub2RlIHx8IHt9KTtcbmNvbnN0IHNhZmVDaGlsZHJlbiA9IG5vZGUgPT4gKHNhZmUobm9kZSkuY2hpbGRyZW4gfHwgW10pO1xuY29uc3QgbGFzdFZpc2libGVOb2RlID0gKG5vZGVzKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSB8fCBub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzQ291bnQgPSBub2Rlcy5sZW5ndGg7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gbm9kZXNDb3VudCAtIDE7XG4gICAgZm9yIChsZXQgaW5kZXggPSBsYXN0SW5kZXg7IGluZGV4ID49IDA7IGluZGV4IC09IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2luZGV4XTtcbiAgICAgICAgaWYgKG5vZGUudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE5hdmlnYXRpb25Nb2RlbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaWIgPSBuZXcgSW5kZXhCdWlsZGVyU2VydmljZSgpO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuICAgIGZpcnN0VmlzaWJsZU5vZGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ub2RlcyB8fCBbXSkuZmluZChub2RlID0+IG5vZGUudmlzaWJsZSk7XG4gICAgfVxuICAgIGxhc3RWaXNpYmxlTm9kZSgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBsYXN0VmlzaWJsZU5vZGUodGhpcy5ub2Rlcyk7XG4gICAgICAgIHdoaWxlIChpc1ByZXNlbnQobm9kZSkgJiYgc2FmZUNoaWxkcmVuKG5vZGUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2FmZUNoaWxkcmVuKG5vZGUpO1xuICAgICAgICAgICAgY29uc3QgbGFzdFZpc2libGVDaGlsZCA9IGxhc3RWaXNpYmxlTm9kZShjaGlsZHJlbik7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChsYXN0VmlzaWJsZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IGxhc3RWaXNpYmxlQ2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGNsb3Nlc3ROb2RlKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHsgcHJldiB9ID0gc2FmZSh0aGlzLmZpbmROb2RlKGluZGV4KSk7XG4gICAgICAgIGNvbnN0IHNpYmxpbmcgPSBwcmV2IHx8IHRoaXMuZmlyc3RWaXNpYmxlTm9kZSgpO1xuICAgICAgICByZXR1cm4gc2FmZShzaWJsaW5nKS5pbmRleCA9PT0gaW5kZXggPyB0aGlzLnZpc2libGVTaWJsaW5nKHNpYmxpbmcsIDEpIDogc2libGluZztcbiAgICB9XG4gICAgZmlyc3RGb2N1c2FibGVOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5maW5kKChub2RlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIW5vZGUuZGlzYWJsZWQgJiYgbm9kZS52aXNpYmxlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluZE5vZGUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZChpbmRleCwgdGhpcy5ub2Rlcyk7XG4gICAgfVxuICAgIGZpbmRQYXJlbnQoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgcGFyZW50TGV2ZWwgPSB0aGlzLmliLmxldmVsKGluZGV4KSAtIDE7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmROb2RlKHRoaXMuaWIuaW5kZXhGb3JMZXZlbChpbmRleCwgcGFyZW50TGV2ZWwpKTtcbiAgICB9XG4gICAgZmluZFZpc2libGVDaGlsZChpbmRleCkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5maW5kTm9kZShpbmRleCk7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2FmZUNoaWxkcmVuKG5vZGUpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4uZmluZCgoY2hpbGQpID0+IGNoaWxkLnZpc2libGUpO1xuICAgIH1cbiAgICBmaW5kVmlzaWJsZVByZXYoaXRlbSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW0uaW5kZXg7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZmluZFBhcmVudChpbmRleCk7XG4gICAgICAgIGNvbnN0IGxldmVsSW5kZXggPSB0aGlzLmliLmxhc3RMZXZlbEluZGV4KGluZGV4KTtcbiAgICAgICAgY29uc3QgcHJldk5vZGVzID0gdGhpcy5jb250YWluZXIocGFyZW50KS5zbGljZSgwLCBsZXZlbEluZGV4KTtcbiAgICAgICAgY29uc3QgcHJldk5vZGVzSGlkZGVuID0gcHJldk5vZGVzLmV2ZXJ5KG5vZGUgPT4gIW5vZGUudmlzaWJsZSk7XG4gICAgICAgIGlmIChsZXZlbEluZGV4ID09PSAwIHx8IHByZXZOb2Rlc0hpZGRlbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHRoaXMuZmluZE5vZGUoaW5kZXgpO1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMudmlzaWJsZVNpYmxpbmcoY3VycmVudE5vZGUsIC0xKTtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY29udGFpbmVyKHByZXYpO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgY2hpbGRyZW4uc29tZShub2RlID0+IG5vZGUudmlzaWJsZSkpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbGFzdFZpc2libGVOb2RlKGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY29udGFpbmVyKHByZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgIH1cbiAgICBmaW5kVmlzaWJsZU5leHQoaXRlbSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY29udGFpbmVyKGl0ZW0pO1xuICAgICAgICBjb25zdCBoYXNWaXNpYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbi5zb21lKGNoaWxkID0+IGNoaWxkLnZpc2libGUpO1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8ICFoYXNWaXNpYmxlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2libGVTaWJsaW5nKGl0ZW0sIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLnZpc2libGUpO1xuICAgIH1cbiAgICByZWdpc3Rlckl0ZW0oaWQsIGluZGV4LCBkaXNhYmxlZCwgbG9hZE1vcmVCdXR0b24gPSBmYWxzZSwgdmlzaWJsZSA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmliLmxldmVsKGluZGV4KTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5maW5kUGFyZW50KGluZGV4KTtcbiAgICAgICAgaWYgKHBhcmVudCB8fCBsZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgaWQsIGNoaWxkcmVuLCBpbmRleCwgcGFyZW50LCBkaXNhYmxlZCwgbG9hZE1vcmVCdXR0b24sIHZpc2libGUgfTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KG5vZGUsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5yZWdpc3Rlckl0ZW0oaWQsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmZpbmQoaW5kZXgsIHRoaXMubm9kZXMpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pZCAhPT0gaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY29udGFpbmVyKG5vZGUucGFyZW50KTtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkcmVuLmluZGV4T2Yobm9kZSksIDEpO1xuICAgIH1cbiAgICBjaGlsZExldmVsKG5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4gaXNQcmVzZW50KG5vZGUpKTtcbiAgICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pYi5sZXZlbChjaGlsZHJlblswXS5pbmRleCk7XG4gICAgfVxuICAgIGNvbnRhaW5lcihub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5jaGlsZHJlbiA6IHRoaXMubm9kZXM7XG4gICAgfVxuICAgIGZpbmQoaW5kZXgsIG5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTGV2ZWwgPSB0aGlzLmNoaWxkTGV2ZWwobm9kZXMpO1xuICAgICAgICBjb25zdCBpbmRleFRvTWF0Y2ggPSB0aGlzLmliLmluZGV4Rm9yTGV2ZWwoaW5kZXgsIGNoaWxkTGV2ZWwpO1xuICAgICAgICBjb25zdCBpc0xlYWYgPSBjaGlsZExldmVsID09PSB0aGlzLmliLmxldmVsKGluZGV4KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzLmZpbmQobiA9PiBuICYmIG4uaW5kZXggPT09IGluZGV4VG9NYXRjaCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTGVhZiA/IG5vZGUgOiB0aGlzLmZpbmQoaW5kZXgsIG5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpbnNlcnQobm9kZSwgcGFyZW50KSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5jb250YWluZXIocGFyZW50KTtcbiAgICAgICAgbm9kZXMuc3BsaWNlKHRoaXMuaWIubGFzdExldmVsSW5kZXgobm9kZS5pbmRleCksIDAsIG5vZGUpO1xuICAgIH1cbiAgICB2aXNpYmxlU2libGluZyhub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZpbmRQYXJlbnQobm9kZS5pbmRleCk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKHBhcmVudCk7XG4gICAgICAgIGxldCBuZXh0SXRlbUluZGV4ID0gY29udGFpbmVyLmluZGV4T2Yobm9kZSkgKyBvZmZzZXQ7XG4gICAgICAgIGxldCBuZXh0SXRlbSA9IGNvbnRhaW5lcltuZXh0SXRlbUluZGV4XTtcbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudChuZXh0SXRlbSkpIHtcbiAgICAgICAgICAgIGlmIChuZXh0SXRlbS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRJdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEl0ZW1JbmRleCArPSBvZmZzZXQ7XG4gICAgICAgICAgICBuZXh0SXRlbSA9IGNvbnRhaW5lcltuZXh0SXRlbUluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlU2libGluZyhwYXJlbnQsIG9mZnNldCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IE5hdmlnYXRpb25TZXJ2aWNlID0gY2xhc3MgTmF2aWdhdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5leHBhbmRzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5tb3ZlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuY2hlY2tzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5sb2FkTW9yZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMubmF2aWdhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0ge1xuICAgICAgICAgICAgW0tleXMuQXJyb3dVcF06ICgpID0+IHRoaXMuYWN0aXZhdGUodGhpcy5tb2RlbC5maW5kVmlzaWJsZVByZXYodGhpcy5mb2N1c2FibGVJdGVtKSwgdHJ1ZSksXG4gICAgICAgICAgICBbS2V5cy5BcnJvd0Rvd25dOiAoKSA9PiB0aGlzLmFjdGl2YXRlKHRoaXMubW9kZWwuZmluZFZpc2libGVOZXh0KHRoaXMuZm9jdXNhYmxlSXRlbSksIHRydWUpLFxuICAgICAgICAgICAgW0tleXMuQXJyb3dMZWZ0XTogKCkgPT4gIXRoaXMuaXNMb2FkTW9yZUJ1dHRvbiAmJiAodGhpcy5leHBhbmQoe1xuICAgICAgICAgICAgICAgIGV4cGFuZDogdGhpcy5sb2NhbGl6YXRpb24ucnRsLFxuICAgICAgICAgICAgICAgIGludGVyY2VwdDogdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gdGhpcy5tb3ZlVG9GaXJzdFZpc2libGVDaGlsZCA6IHRoaXMubW92ZVRvUGFyZW50XG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBbS2V5cy5BcnJvd1JpZ2h0XTogKCkgPT4gIXRoaXMuaXNMb2FkTW9yZUJ1dHRvbiAmJiAodGhpcy5leHBhbmQoe1xuICAgICAgICAgICAgICAgIGV4cGFuZDogIXRoaXMubG9jYWxpemF0aW9uLnJ0bCxcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHQ6IHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/IHRoaXMubW92ZVRvUGFyZW50IDogdGhpcy5tb3ZlVG9GaXJzdFZpc2libGVDaGlsZFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgW0tleXMuSG9tZV06ICgpID0+IHRoaXMuYWN0aXZhdGUodGhpcy5tb2RlbC5maXJzdFZpc2libGVOb2RlKCksIHRydWUpLFxuICAgICAgICAgICAgW0tleXMuRW5kXTogKCkgPT4gdGhpcy5hY3RpdmF0ZSh0aGlzLm1vZGVsLmxhc3RWaXNpYmxlTm9kZSgpLCB0cnVlKSxcbiAgICAgICAgICAgIFtLZXlzLkVudGVyXTogKCkgPT4gdGhpcy5oYW5kbGVFbnRlcigpLFxuICAgICAgICAgICAgW0tleXMuU3BhY2VdOiAoKSA9PiB0aGlzLmhhbmRsZVNwYWNlKClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbW9kZWwgPSBuZXcgTmF2aWdhdGlvbk1vZGVsKCk7XG4gICAgICAgIHRoaXMubW92ZVRvRmlyc3RWaXNpYmxlQ2hpbGQgPSB0aGlzLm1vdmVUb0ZpcnN0VmlzaWJsZUNoaWxkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZVRvUGFyZW50ID0gdGhpcy5tb3ZlVG9QYXJlbnQuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1vZGVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gICAgfVxuICAgIHNldCBtb2RlbChtb2RlbCkge1xuICAgICAgICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBub2RlSW5kZXgodGhpcy5hY3RpdmVJdGVtKSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgaXNBY3RpdmVFeHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlSXRlbSAmJiB0aGlzLmFjdGl2ZUl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0IGlzTG9hZE1vcmVCdXR0b24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUl0ZW0gJiYgdGhpcy5hY3RpdmVJdGVtLmxvYWRNb3JlQnV0dG9uO1xuICAgIH1cbiAgICBnZXQgZm9jdXNhYmxlSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlSXRlbSB8fCB0aGlzLm1vZGVsLmZpcnN0Rm9jdXNhYmxlTm9kZSgpO1xuICAgIH1cbiAgICBhY3RpdmF0ZShpdGVtLCBzaG91bGRTY3JvbGwgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMubmF2aWdhYmxlIHx8ICFpdGVtIHx8IHRoaXMuaXNBY3RpdmUobm9kZUluZGV4KGl0ZW0pKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gaXRlbSB8fCB0aGlzLmFjdGl2ZUl0ZW07XG4gICAgICAgIHRoaXMuc2hvdWxkU2Nyb2xsID0gc2hvdWxkU2Nyb2xsO1xuICAgICAgICB0aGlzLm5vdGlmeU1vdmUoKTtcbiAgICB9XG4gICAgYWN0aXZhdGVQYXJlbnQoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSh0aGlzLm1vZGVsLmZpbmRQYXJlbnQoaW5kZXgpKTtcbiAgICB9XG4gICAgYWN0aXZhdGVJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoIWluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSh0aGlzLm1vZGVsLmZpbmROb2RlKGluZGV4KSk7XG4gICAgfVxuICAgIGFjdGl2YXRlQ2xvc2VzdChpbmRleCkge1xuICAgICAgICBpZiAoIWluZGV4IHx8IG5vZGVJbmRleCh0aGlzLmZvY3VzYWJsZUl0ZW0pICE9PSBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IHRoaXMubW9kZWwuY2xvc2VzdE5vZGUoaW5kZXgpO1xuICAgICAgICB0aGlzLm5vdGlmeU1vdmUoKTtcbiAgICB9XG4gICAgYWN0aXZhdGVGb2N1c2FibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0gPSB0aGlzLm1vZGVsLmZpcnN0VmlzaWJsZU5vZGUoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlNb3ZlKCk7XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5uYXZpZ2FibGUgfHwgIXRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub3RpZnlNb3ZlKCk7XG4gICAgfVxuICAgIGNoZWNrSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrcy5uZXh0KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZChpbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0cy5uZXh0KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub3RpZnlMb2FkTW9yZShpbmRleCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRNb3JlLm5leHQoaW5kZXgpO1xuICAgIH1cbiAgICBpc0FjdGl2ZShpbmRleCkge1xuICAgICAgICBpZiAoIWluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGb2N1c2VkICYmIHRoaXMuYWN0aXZlSW5kZXggPT09IGluZGV4O1xuICAgIH1cbiAgICBpc0ZvY3VzYWJsZShpbmRleCkge1xuICAgICAgICByZXR1cm4gbm9kZUluZGV4KHRoaXMuZm9jdXNhYmxlSXRlbSkgPT09IGluZGV4O1xuICAgIH1cbiAgICBpc0Rpc2FibGVkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZpbmROb2RlKGluZGV4KS5kaXNhYmxlZDtcbiAgICB9XG4gICAgcmVnaXN0ZXJJdGVtKGlkLCBpbmRleCwgZGlzYWJsZWQsIGxvYWRNb3JlQnV0dG9uID0gZmFsc2UsIHZpc2libGUgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1BdEluZGV4ID0gdGhpcy5tb2RlbC5maW5kTm9kZShpbmRleCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoaXRlbUF0SW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnVucmVnaXN0ZXJJdGVtKGl0ZW1BdEluZGV4LmlkLCBpdGVtQXRJbmRleC5pbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLnJlZ2lzdGVySXRlbShpZCwgaW5kZXgsIGRpc2FibGVkLCBsb2FkTW9yZUJ1dHRvbiwgdmlzaWJsZSk7XG4gICAgfVxuICAgIHVucmVnaXN0ZXJJdGVtKGlkLCBpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZShpbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVQYXJlbnQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwudW5yZWdpc3Rlckl0ZW0oaWQsIGluZGV4KTtcbiAgICB9XG4gICAgbW92ZShlKSB7XG4gICAgICAgIGlmICghdGhpcy5uYXZpZ2FibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb3ZlQWN0aW9uID0gdGhpcy5hY3Rpb25zW2Uua2V5Q29kZV07XG4gICAgICAgIGlmICghbW92ZUFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vdmVBY3Rpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBleHBhbmQoeyBleHBhbmQsIGludGVyY2VwdCB9KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbm9kZUluZGV4KHRoaXMuYWN0aXZlSXRlbSk7XG4gICAgICAgIGlmICghaW5kZXggfHwgaW50ZXJjZXB0KGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5RXhwYW5kKGV4cGFuZCk7XG4gICAgfVxuICAgIG1vdmVUb1BhcmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVFeHBhbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZhdGUodGhpcy5tb2RlbC5maW5kUGFyZW50KG5vZGVJbmRleCh0aGlzLmFjdGl2ZUl0ZW0pKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlVG9GaXJzdFZpc2libGVDaGlsZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlRXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2YXRlKHRoaXMubW9kZWwuZmluZFZpc2libGVDaGlsZChub2RlSW5kZXgodGhpcy5hY3RpdmVJdGVtKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbm90aWZ5RXhwYW5kKGV4cGFuZCkge1xuICAgICAgICB0aGlzLmV4cGFuZHMubmV4dCh0aGlzLm5hdmlnYXRpb25TdGF0ZShleHBhbmQpKTtcbiAgICB9XG4gICAgbm90aWZ5TW92ZSgpIHtcbiAgICAgICAgdGhpcy5tb3Zlcy5uZXh0KHRoaXMubmF2aWdhdGlvblN0YXRlKCkpO1xuICAgIH1cbiAgICBuYXZpZ2F0aW9uU3RhdGUoZXhwYW5kID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuICh7IGV4cGFuZCwgaW5kZXg6IHRoaXMuYWN0aXZlSW5kZXgsIGlzRm9jdXNlZDogdGhpcy5pc0ZvY3VzZWQsIHNob3VsZFNjcm9sbDogdGhpcy5zaG91bGRTY3JvbGwgfSk7XG4gICAgfVxuICAgIGhhbmRsZUVudGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMubmF2aWdhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkTW9yZUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkTW9yZSh0aGlzLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0SW5kZXgodGhpcy5hY3RpdmVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlU3BhY2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5uYXZpZ2FibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0xvYWRNb3JlQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRNb3JlKHRoaXMuYWN0aXZlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja0luZGV4KHRoaXMuYWN0aXZlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbk5hdmlnYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0aW9uU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTm9kZUNoaWxkcmVuU2VydmljZSA9IGNsYXNzIE5vZGVDaGlsZHJlblNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgY2hpbGRyZW5Mb2FkZWQoaXRlbSwgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoeyBpdGVtLCBjaGlsZHJlbiB9KTtcbiAgICB9XG59O1xuTm9kZUNoaWxkcmVuU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgTm9kZUNoaWxkcmVuU2VydmljZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGVtcGxhdGUgZm9yIHRoZSBUcmVlVmlldyBub2RlcyAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgbm9kZXRlbXBsYXRlX3RyZWV2aWV3ICV9KSkuXG4gKiBUaGUgdGVtcGxhdGUgaGVscHMgdG8gY3VzdG9taXplIHRoZSBjb250ZW50IG9mIHRoZSBub2Rlcy4gVG8gZGVmaW5lIHRoZSBub2RlIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YFxuICogdGFnIHdpdGggdGhlIGBrZW5kb1RyZWVWaWV3Tm9kZVRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIGEgYDxrZW5kby10cmVldmlldz5gIHRhZy5cbiAqXG4gKlxuICogVGhlIG5vZGUgZGF0YSBpdGVtIGFuZCBpdHMgaGllcmFyY2hpY2FsIGluZGV4IGFyZSBhdmFpbGFibGUgYXMgY29udGV4dCB2YXJpYWJsZXM6XG4gKlxuICogLSBgbGV0LWRhdGFJdGVtYCAoYGFueWApIC0gYXZhaWxhYmxlIGFzIGltcGxpY2l0IGNvbnRleHQgdmFyaWFibGVcbiAqIC0gYGxldC1pbmRleD1cImluZGV4XCJgIChgc3RyaW5nYClcbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKlxuICogIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgIDxrZW5kby10cmVldmlld1xuICogICAgICAgICAgW25vZGVzXT1cImRhdGFcIlxuICogICAgICAgICAga2VuZG9UcmVlVmlld0V4cGFuZGFibGVcbiAqXG4gKiAgICAgICAgICBrZW5kb1RyZWVWaWV3SGllcmFyY2h5QmluZGluZ1xuICogICAgICAgICAgY2hpbGRyZW5GaWVsZD1cIml0ZW1zXCI+XG4gKiAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVHJlZVZpZXdOb2RlVGVtcGxhdGUgbGV0LWRhdGFJdGVtIGxldC1pbmRleD1cImluZGV4XCI+XG4gKiAgICAgICAgICA8c3BhbiBbc3R5bGUuZm9udFdlaWdodF09XCJkYXRhSXRlbS5pdGVtcyA/ICdib2xkZXInOiAnbm9ybWFsJyBcIj57eyBpbmRleCB9fToge3sgZGF0YUl0ZW0udGV4dCB9fTwvc3Bhbj5cbiAqICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICA8L2tlbmRvLXRyZWV2aWV3PlxuICogICAgYFxuICogIH0pXG4gKiAgZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFtcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICB0ZXh0OiBcIkluYm94XCIsXG4gKiAgICAgICAgICAgICAgaXRlbXM6IFt7IHRleHQ6IFwiUmVhZCBNYWlsXCIgfV1cbiAqICAgICAgICAgIH0sXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgdGV4dDogXCJEcmFmdHNcIlxuICogICAgICAgICAgfSxcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICB0ZXh0OiBcIlNlYXJjaCBGb2xkZXJzXCIsXG4gKiAgICAgICAgICAgICAgaXRlbXM6IFtcbiAqICAgICAgICAgICAgICAgICAgeyB0ZXh0OiBcIkNhdGVnb3JpemVkIE1haWxcIiB9LFxuICogICAgICAgICAgICAgICAgICB7IHRleHQ6IFwiTGFyZ2UgTWFpbFwiIH0sXG4gKiAgICAgICAgICAgICAgICAgIHsgdGV4dDogXCJVbnJlYWQgTWFpbFwifVxuICogICAgICAgICAgICAgIF1cbiAqICAgICAgICAgIH0sXG4gKiAgICAgICAgICB7IHRleHQ6IFwiU2V0dGluZ3NcIiB9XG4gKiAgICAgIF07XG4gKiAgfVxuICpcbiAqIGBgYFxuICovXG5sZXQgTm9kZVRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgTm9kZVRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbk5vZGVUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdOb2RlVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBOb2RlVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHRlbXBsYXRlIGZvciB0aGUgVHJlZVZpZXcgbG9hZCBtb3JlIGJ1dHRvbnMuXG4gKiBUbyBkZWZpbmUgYSBidXR0b24gdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gXG4gKiB0YWcgd2l0aCB0aGUgYGtlbmRvVHJlZVZpZXdMb2FkTW9yZUJ1dHRvblRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIGEgYDxrZW5kby10cmVldmlldz5gIHRhZ1xuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBsb2FkbW9yZWJ1dHRvbl90cmVldmlldyAlfSN0b2MtYnV0dG9uLXRlbXBsYXRlKSkuXG4gKlxuICogVGhlIGhpZXJhcmNoaWNhbCBpbmRleCBvZiB0aGUgbG9hZCBtb3JlIGJ1dHRvbiBub2RlIGlzIGF2YWlsYWJsZSBhcyBhIGNvbnRleHQgdmFyaWFibGU6XG4gKlxuICogLSBgbGV0LWluZGV4PVwiaW5kZXhcImAgKGBzdHJpbmdgKVxuICovXG5sZXQgTG9hZE1vcmVCdXR0b25UZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIExvYWRNb3JlQnV0dG9uVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuTG9hZE1vcmVCdXR0b25UZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdMb2FkTW9yZUJ1dHRvblRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgTG9hZE1vcmVCdXR0b25UZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqIEFuIGluamVjdGlvbiB0b2tlbiB1c2VkIGJ5IHRoZSBkYXRhIGJpbmRpbmcgZGlyZWN0aXZlcyB0byBpbnRlcmZhY2Ugd2l0aFxuICogdGhlIFRyZWVWaWV3IG9yIHRoZSBEcm9wRG93blRyZWUgY29tcG9uZW50cy5cbiAqL1xubGV0IERhdGFCb3VuZENvbXBvbmVudCA9IGNsYXNzIERhdGFCb3VuZENvbXBvbmVudCB7XG59O1xuRGF0YUJvdW5kQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBEYXRhQm91bmRDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBBbiBpbmplY3Rpb24gdG9rZW4gdXNlZCBieSB0aGUgZXhwYW5kLWRpcmVjdGl2ZSB0byBpbnRlcmZhY2Ugd2l0aFxuICogdGhlIFRyZWVWaWV3IG9yIHRoZSBEcm9wRG93blRyZWUgY29tcG9uZW50cy5cbiAqL1xubGV0IEV4cGFuZGFibGVDb21wb25lbnQgPSBjbGFzcyBFeHBhbmRhYmxlQ29tcG9uZW50IHtcbn07XG5FeHBhbmRhYmxlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBFeHBhbmRhYmxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTZWxlY3Rpb25TZXJ2aWNlID0gY2xhc3MgU2VsZWN0aW9uU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICBpc0ZpcnN0U2VsZWN0ZWQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RJbmRleCA9PT0gaW5kZXg7XG4gICAgfVxuICAgIHNldEZpcnN0U2VsZWN0ZWQoaW5kZXgsIHNlbGVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0SW5kZXggPT09IGluZGV4ICYmIHNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5maXJzdEluZGV4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5maXJzdEluZGV4ICYmIHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3QoaW5kZXgsIGRhdGFJdGVtKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5uZXh0KHsgZGF0YUl0ZW0sIGluZGV4IH0pO1xuICAgIH1cbn07XG5TZWxlY3Rpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBTZWxlY3Rpb25TZXJ2aWNlKTtcblxuY29uc3QgSU5ERVhfUkVHRVggPSAvXFxkKyQvO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBUcmVlVmlld0xvb2t1cFNlcnZpY2UgPSBjbGFzcyBUcmVlVmlld0xvb2t1cFNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm1hcC5jbGVhcigpO1xuICAgIH1cbiAgICByZWdpc3Rlckl0ZW0oaXRlbSwgcGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMb29rdXAgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLml0ZW0obm9kZUluZGV4KHBhcmVudCkpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFwLnNldChpdGVtLmluZGV4LCBjdXJyZW50TG9va3VwKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDaGlsZHJlbihpbmRleCwgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbShpbmRleCk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0uY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgdW5yZWdpc3Rlckl0ZW0oaW5kZXgsIGRhdGFJdGVtKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLml0ZW0oaW5kZXgpO1xuICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50Lml0ZW0uZGF0YUl0ZW0gPT09IGRhdGFJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQucGFyZW50ICYmIGN1cnJlbnQucGFyZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5wYXJlbnQuY2hpbGRyZW4gPSBjdXJyZW50LnBhcmVudC5jaGlsZHJlbi5maWx0ZXIoaXRlbSA9PiBpdGVtLmRhdGFJdGVtICE9PSBkYXRhSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZUl0ZW0oaW5kZXgsIGl0ZW0sIHBhcmVudCkge1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVucmVnaXN0ZXJJdGVtKGluZGV4LCBpdGVtLmRhdGFJdGVtKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlckl0ZW0oaXRlbSwgcGFyZW50KTtcbiAgICAgICAgdGhpcy5hZGRUb1BhcmVudChpdGVtLCBwYXJlbnQpO1xuICAgIH1cbiAgICBpdGVtTG9va3VwKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW0oaW5kZXgpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5tYXBDaGlsZHJlbihpdGVtLmNoaWxkcmVuKSxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0uaXRlbSxcbiAgICAgICAgICAgIHBhcmVudDogaXRlbS5wYXJlbnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaGFzSXRlbShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGluZGV4KTtcbiAgICB9XG4gICAgaXRlbShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGluZGV4KSB8fCBudWxsO1xuICAgIH1cbiAgICBhZGRUb1BhcmVudChpdGVtLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SXRlbSA9IHRoaXMuaXRlbShwYXJlbnQuaW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChJTkRFWF9SRUdFWC5leGVjKGl0ZW0uaW5kZXgpWzBdLCAxMCk7XG4gICAgICAgICAgICBwYXJlbnRJdGVtLmNoaWxkcmVuID0gcGFyZW50SXRlbS5jaGlsZHJlbiB8fCBbXTtcbiAgICAgICAgICAgIHBhcmVudEl0ZW0uY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXBDaGlsZHJlbihjaGlsZHJlbiA9IFtdKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5tYXAoYyA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGl0ZW0sIHBhcmVudCwgY2hpbGRyZW4gfSA9IHRoaXMuaXRlbShjLmluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHRoaXMubWFwQ2hpbGRyZW4oY2hpbGRyZW4pLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgcGFyZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuVHJlZVZpZXdMb29rdXBTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBUcmVlVmlld0xvb2t1cFNlcnZpY2UpO1xuXG5jb25zdCBMT0FEX01PUkVfRE9DX0xJTksgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvdHJlZXZpZXcvbG9hZC1tb3JlLWJ1dHRvbi8nO1xuY29uc3QgcHJvdmlkZXJzID0gW1xuICAgIEV4cGFuZFN0YXRlU2VydmljZSxcbiAgICBJbmRleEJ1aWxkZXJTZXJ2aWNlLFxuICAgIFRyZWVWaWV3TG9va3VwU2VydmljZSxcbiAgICBMb2FkaW5nTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICBOb2RlQ2hpbGRyZW5TZXJ2aWNlLFxuICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIFNlbGVjdGlvblNlcnZpY2UsXG4gICAgRGF0YUNoYW5nZU5vdGlmaWNhdGlvblNlcnZpY2UsXG4gICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICB7XG4gICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLnRyZWV2aWV3J1xuICAgIH0sXG4gICAge1xuICAgICAgICBwcm92aWRlOiBEYXRhQm91bmRDb21wb25lbnQsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRyZWVWaWV3Q29tcG9uZW50KVxuICAgIH0sXG4gICAge1xuICAgICAgICBwcm92aWRlOiBFeHBhbmRhYmxlQ29tcG9uZW50LFxuICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUcmVlVmlld0NvbXBvbmVudClcbiAgICB9XG5dO1xuLyogdHNsaW50OmRpc2FibGU6bWVtYmVyLW9yZGVyaW5nICovXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBUcmVlVmlldyBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfdHJlZXZpZXcgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiB7JSBtZXRhIGhlaWdodDo0NTAgJX1cbiAqIHslIGVtYmVkX2ZpbGUgZ2V0LXN0YXJ0ZWQvYXBwLmNvbXBvbmVudC50cyBwcmV2aWV3ICV9XG4gKiB7JSBlbWJlZF9maWxlIGdldC1zdGFydGVkL2FwcC5tb2R1bGUudHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL21haW4udHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqL1xubGV0IFRyZWVWaWV3Q29tcG9uZW50ID0gY2xhc3MgVHJlZVZpZXdDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNoYW5nZURldGVjdG9yUmVmLCBleHBhbmRTZXJ2aWNlLCBuYXZpZ2F0aW9uU2VydmljZSwgbm9kZUNoaWxkcmVuU2VydmljZSwgc2VsZWN0aW9uU2VydmljZSwgdHJlZVZpZXdMb29rdXBTZXJ2aWNlLCBuZ1pvbmUsIHJlbmRlcmVyLCBkYXRhQ2hhbmdlTm90aWZpY2F0aW9uLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZiA9IGNoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICB0aGlzLmV4cGFuZFNlcnZpY2UgPSBleHBhbmRTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlID0gbmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubm9kZUNoaWxkcmVuU2VydmljZSA9IG5vZGVDaGlsZHJlblNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZSA9IHNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMudHJlZVZpZXdMb29rdXBTZXJ2aWNlID0gdHJlZVZpZXdMb29rdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VOb3RpZmljYXRpb24gPSBkYXRhQ2hhbmdlTm90aWZpY2F0aW9uO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5jbGFzc05hbWVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb2xlID0gJ3RyZWUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhpbnQgd2hpY2ggaXMgZGlzcGxheWVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBlbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVySW5wdXRQbGFjZWhvbGRlciA9IFwiXCI7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuZmV0Y2hOb2RlcyA9ICgpID0+IHRoaXMuZGF0YTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGNoaWxkcmVuIG9mIHRoZSBleHBhbmRlZCBub2RlIGFyZSBsb2FkZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkcmVuTG9hZGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBibHVycyB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGZvY3VzZXMgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgZXhwYW5kcyBhIFRyZWVWaWV3IG5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY29sbGFwc2VzIGEgVHJlZVZpZXcgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBqdXN0IGJlZm9yZSB0aGUgZHJhZ2dpbmcgb2YgdGhlIG5vZGUgc3RhcnRzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLXNldHVwKSkuIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuXG4gICAgICAgICAqIElmIHlvdSBwcmV2ZW50IHRoZSBldmVudCBkZWZhdWx0LCBubyBkcmFnIGhpbnQgd2lsbCBiZSBjcmVhdGVkIGFuZCB0aGUgc3Vic2VxdWVudCBkcmFnLXJlbGF0ZWQgZXZlbnRzIHdpbGwgbm90IGJlIGZpcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub2RlRHJhZ1N0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhbiBpdGVtIGlzIGJlaW5nIGRyYWdnZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2Mtc2V0dXApKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZURyYWcgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIHRoZSBidWlsdC1pbiBmaWx0ZXJpbmcgbWVjaGFuaXNtIGluIHRoZSBkYXRhLWJpbmRpbmcgZGlyZWN0aXZlcyB1cGRhdGVzIHRoZSBub2RlJ3MgdmlzaWJpbGl0eS5cbiAgICAgICAgICogVXNlZCBmb3IgdGhlIGJ1aWx0LWluIGF1dG8tZXhwYW5kIGZ1bmN0aW9uYWxpdGllcyBvZiB0aGUgY29tcG9uZW50IGFuZCBhdmFpbGFibGUgZm9yIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlclN0YXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgb24gdGhlIHRhcmdldCBUcmVlVmlldyB3aGVuIGEgZHJhZ2dlZCBpdGVtIGlzIGRyb3BwZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2Mtc2V0dXApKS5cbiAgICAgICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IHByZXZlbnQgdGhlIGV2ZW50IGRlZmF1bHQgKGBldmVudC5wcmV2ZW50RGVmdWFsdCgpYCkgb3IgaW52YWxpZGF0ZSBpdHMgc3RhdGUgKGBldmVudC5zZXRWYWxpZChmYWxzZSlgKSxcbiAgICAgICAgICogdGhlIGBhZGRJdGVtYCBhbmQgYHJlbW92ZUl0ZW1gIGV2ZW50cyB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJvdGggb3BlcmF0aW9ucyBjYW5jZWwgdGhlIGRlZmF1bHQgZHJvcCBvcGVyYXRpb24sIGJ1dCB0aGUgaW5kaWNhdGlvbiB0byB0aGUgdXNlciBpcyBkaWZmZXJlbnQuIGBldmVudC5zZXRWYWxpZChmYWxzZSlgIGluZGljYXRlcyB0aGF0IHRoZSBvcGVyYXRpb24gd2FzXG4gICAgICAgICAqIHVuc3VjY2Vzc2Z1bCBieSBhbmltYXRpbmcgdGhlIGRyYWcgY2x1ZSB0byBpdHMgb3JpZ2luYWwgcG9zaXRpb24uIGBldmVudC5wcmV2ZW50RGVmYXVsdCgpYCBzaW1wbHkgcmVtb3ZlcyB0aGUgY2x1ZSwgYXMgaWYgaXQgaGFzIGJlZW4gZHJvcHBlZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAqIEFzIGEgZ2VuZXJhbCBydWxlLCB1c2UgYHByZXZlbnREZWZhdWx0YCB0byBtYW51YWxseSBoYW5kbGUgdGhlIGFkZCBhbmQgcmVtb3ZlIG9wZXJhdGlvbnMsIGFuZCBgc2V0VmFsaWQoZmFsc2UpYCB0byBpbmRpY2F0ZSB0aGUgb3BlcmF0aW9uIHdhcyB1bnN1Y2Nlc3NmdWwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vZGVEcm9wID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgb24gdGhlIHNvdXJjZSBUcmVlVmlldyBhZnRlciB0aGUgZHJhZ2dlZCBpdGVtIGhhcyBiZWVuIGRyb3BwZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2Mtc2V0dXApKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZURyYWdFbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBhZnRlciBhIGRyYWdnZWQgaXRlbSBpcyBkcm9wcGVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLXNldHVwKSkuXG4gICAgICAgICAqIENhbGxlZCBvbiB0aGUgVHJlZVZpZXcgd2hlcmUgdGhlIGl0ZW0gaXMgZHJvcHBlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkSXRlbSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGFmdGVyIGEgZHJhZ2dlZCBpdGVtIGlzIGRyb3BwZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2Mtc2V0dXApKS5cbiAgICAgICAgICogQ2FsbGVkIG9uIHRoZSBUcmVlVmlldyBmcm9tIHdoZXJlIHRoZSBpdGVtIGlzIGRyYWdnZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBUcmVlVmlldyBub2RlIGNoZWNrYm94XG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2hlY2tib3hlc190cmVldmlldyAlfSN0b2MtbW9kaWZ5aW5nLXRoZS1jaGVja2VkLXN0YXRlKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBUcmVlVmlldyBub2RlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2VsZWN0aW9uX3RyZWV2aWV3ICV9I3RvYy1tb2RpZnlpbmctdGhlLXNlbGVjdGlvbikpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgYnVpbHQtaW4gZmlsdGVyIGlucHV0IGVsZW1lbnQgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgYSBUcmVlVmlldyBub2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub2RlQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGRvdWJsZSBjbGlja3MgYSBUcmVlVmlldyBub2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub2RlRGJsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBob3cgdG8gdHJhY2sgbm9kZSBjaGFuZ2VzLlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgVHJlZVZpZXcgdHJhY2tzIHRoZSBub2RlcyBieSBkYXRhIGl0ZW0gb2JqZWN0IHJlZmVyZW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogIEBDb21wb25lbnQoe1xuICAgICAgICAgKiAgICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgICAgICAgICA8a2VuZG8tdHJlZXZpZXdcbiAgICAgICAgICogICAgICAgICAgICAgIFtub2Rlc109XCJkYXRhXCJcbiAgICAgICAgICogICAgICAgICAgICAgIHRleHRGaWVsZD1cInRleHRcIlxuICAgICAgICAgKiAgICAgICAgICAgICAgW3RyYWNrQnldPVwidHJhY2tCeVwiXG4gICAgICAgICAqICAgICAgICAgID5cbiAgICAgICAgICogICAgICAgICAgPC9rZW5kby10cmVldmlldz5cbiAgICAgICAgICogICAgICBgXG4gICAgICAgICAqICB9KVxuICAgICAgICAgKiAgZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgICAgcHVibGljIGRhdGE6IGFueVtdID0gW1xuICAgICAgICAgKiAgICAgICAgICB7IHRleHQ6IFwiRnVybml0dXJlXCIgfSxcbiAgICAgICAgICogICAgICAgICAgeyB0ZXh0OiBcIkRlY29yXCIgfVxuICAgICAgICAgKiAgICAgIF07XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgcHVibGljIHRyYWNrQnkoaW5kZXg6IG51bWJlciwgaXRlbTogYW55KTogYW55IHtcbiAgICAgICAgICogICAgICAgICAgcmV0dXJuIGl0ZW0udGV4dDtcbiAgICAgICAgICogICAgICB9XG4gICAgICAgICAqICB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFja0J5ID0gdHJhY2tCeTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiBhIHNwZWNpZmljIG5vZGUgaXMgZGlzYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzRGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayB3aGljaCBkZXRlcm1pbmVzIHdoZXRoZXIgYSBUcmVlVmlldyBub2RlIHNob3VsZCBiZSByZW5kZXJlZCBhcyBoaWRkZW4uIFRoZSB1dGlsaXR5IC5rLWRpc3BsYXktbm9uZSBjbGFzcyBpcyB1c2VkIHRvIGhpZGUgdGhlIG5vZGVzLlxuICAgICAgICAgKiBVc2VmdWwgZm9yIGN1c3RvbSBmaWx0ZXJpbmcgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBpc1Zpc2libGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIFRyZWVWaWV3IGtleWJvYXJkIG5hdmlnYWJsZSBpcyBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYXZpZ2FibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmdW5jdGlvbiB3aGljaCBwcm92aWRlcyB0aGUgY2hpbGQgbm9kZXMgZm9yIGEgZ2l2ZW4gcGFyZW50IG5vZGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkYXRhYmluZGluZ190cmVldmlldyAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9ICgpID0+IG9mKFtdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjaGlsZCBub2RlcyB3aWxsIGJlIGZldGNoZWQgb24gbm9kZSBleHBhbmQgb3Igd2lsbCBiZSBpbml0aWFsbHkgcHJlZmV0Y2hlZC5cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb2FkT25EZW1hbmQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVycyB0aGUgYnVpbHQtaW4gaW5wdXQgZWxlbWVudCBmb3IgZmlsdGVyaW5nIHRoZSBUcmVlVmlldy5cbiAgICAgICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBlbWl0cyB0aGUgYGZpbHRlckNoYW5nZWAgZXZlbnQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIFtmaWx0ZXIgdGhlIFRyZWVWaWV3IG1hbnVhbGx5XSh7JSBzbHVnIGZpbHRlcmluZ190cmVldmlldyAlfSN0b2MtbWFudWFsLWZpbHRlcmluZykuXG4gICAgICAgICAqIEEgYnVpbHQtaW4gZmlsdGVyaW5nIGltcGxlbWVudGF0aW9uIGlzIGF2YWlsYWJsZSB0byB1c2Ugd2l0aCB0aGUgW2BrZW5kb1RyZWVWaWV3SGllcmFyY2h5QmluZGluZ2BdKHslIHNsdWcgYXBpX3RyZWV2aWV3X2hpZXJhcmNoeWJpbmRpbmdkaXJlY3RpdmUgJX0pIGFuZCBbYGtlbmRvVHJlZVZpZXdGbGF0RGF0YUJpbmRpbmdgXSh7JSBzbHVnIGFwaV90cmVldmlld19mbGF0ZGF0YWJpbmRpbmdkaXJlY3RpdmUgJX0pIGRpcmVjdGl2ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYW4gaW5pdGlhbCB2YWx1ZSBvZiB0aGUgYnVpbHQtaW4gaW5wdXQgZWxlbWVudCB1c2VkIGZvciBmaWx0ZXJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlciA9ICcnO1xuICAgICAgICB0aGlzLmNoZWNrYm94ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leHBhbmRJY29ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBCZWhhdmlvclN1YmplY3QoW10pO1xuICAgICAgICB0aGlzLl9hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuZG9tU3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBnZXQgZGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb250ZW50IGFuaW1hdGlvbiBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIHNldCBhbmltYXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGFuaW1hdGUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fYW5pbWF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogRGVmaW5lcyB0aGUgdGVtcGxhdGUgZm9yIGVhY2ggbm9kZS5cbiAgICAgKiBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgbmVzdGVkIHRlbXBsYXRlcyBpbiB0aGUgVHJlZVZpZXcgdGFnLlxuICAgICAqL1xuICAgIHNldCBub2RlVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZVRlbXBsYXRlUmVmID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBub2RlVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlVGVtcGxhdGVSZWYgfHwgdGhpcy5ub2RlVGVtcGxhdGVRdWVyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogRGVmaW5lcyB0aGUgdGVtcGxhdGUgZm9yIGVhY2ggbG9hZC1tb3JlIGJ1dHRvbi5cbiAgICAgKiBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgbmVzdGVkIHRlbXBsYXRlcyBpbiB0aGUgVHJlZVZpZXcgdGFnLlxuICAgICAqL1xuICAgIHNldCBsb2FkTW9yZUJ1dHRvblRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuX2xvYWRNb3JlQnV0dG9uVGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0IGxvYWRNb3JlQnV0dG9uVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkTW9yZUJ1dHRvblRlbXBsYXRlUmVmIHx8IHRoaXMubG9hZE1vcmVCdXR0b25UZW1wbGF0ZVF1ZXJ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbm9kZXMgd2hpY2ggd2lsbCBiZSBkaXNwbGF5ZWQgYnkgdGhlIFRyZWVWaWV3XG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkYXRhYmluZGluZ190cmVldmlldyAlfSkpLlxuICAgICAqL1xuICAgIHNldCBub2Rlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGEubmV4dCh2YWx1ZSB8fCBbXSk7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZU5vdGlmaWNhdGlvbi5ub3RpZnkoKTtcbiAgICB9XG4gICAgZ2V0IG5vZGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgYSBzcGVjaWZpYyBub2RlIGhhcyBjaGlsZCBub2Rlc1xuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0YWJpbmRpbmdfdHJlZXZpZXcgJX0pKS5cbiAgICAgKi9cbiAgICBnZXQgaGFzQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNDaGlsZHJlbiB8fCBoYXNDaGlsZHJlbjtcbiAgICB9XG4gICAgc2V0IGhhc0NoaWxkcmVuKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2hhc0NoaWxkcmVuID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuZXhwYW5kSWNvbnMgPSBCb29sZWFuKHRoaXMuX2lzRXhwYW5kZWQgJiYgdGhpcy5faGFzQ2hpbGRyZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgYSBzcGVjaWZpYyBub2RlIGlzIGNoZWNrZWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNoZWNrYm94ZXNfdHJlZXZpZXcgJX0jdG9jLW1vZGlmeWluZy10aGUtY2hlY2tlZC1zdGF0ZSkpLlxuICAgICAqL1xuICAgIGdldCBpc0NoZWNrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NoZWNrZWQgfHwgaXNDaGVja2VkO1xuICAgIH1cbiAgICBzZXQgaXNDaGVja2VkKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2lzQ2hlY2tlZCA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmNoZWNrYm94ZXMgPSBCb29sZWFuKHRoaXMuX2lzQ2hlY2tlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiBhIHNwZWNpZmljIG5vZGUgaXMgZXhwYW5kZWQuXG4gICAgICovXG4gICAgZ2V0IGlzRXhwYW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0V4cGFuZGVkIHx8IGlzRXhwYW5kZWQ7XG4gICAgfVxuICAgIHNldCBpc0V4cGFuZGVkKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2lzRXhwYW5kZWQgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHBhbmRJY29ucyA9IEJvb2xlYW4odGhpcy5faXNFeHBhbmRlZCAmJiB0aGlzLl9oYXNDaGlsZHJlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiBhIHNwZWNpZmljIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNlbGVjdGlvbl90cmVldmlldyAlfSN0b2MtbW9kaWZ5aW5nLXRoZS1zZWxlY3Rpb24pKS5cbiAgICAgKi9cbiAgICBnZXQgaXNTZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQgfHwgaXNTZWxlY3RlZDtcbiAgICB9XG4gICAgc2V0IGlzU2VsZWN0ZWQoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSBCb29sZWFuKHRoaXMuX2lzU2VsZWN0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGAnc21hbGwnYFxuICAgICAqICogYCdtZWRpdW0nYCAoZGVmYXVsdClcbiAgICAgKiAqIGAnbGFyZ2UnYFxuICAgICAqICogYG51bGxgXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgc2l6ZShzaXplKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGdldFNpemVDbGFzcygndHJlZXZpZXcnLCB0aGlzLnNpemUpKTtcbiAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGdldFNpemVDbGFzcygndHJlZXZpZXcnLCBzaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLm5hdmlnYWJsZSA9IEJvb2xlYW4odGhpcy5uYXZpZ2FibGUpO1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgcmVhY3QgdG8gY2hhbmdlcy5sb2FkT25EZW1hbmQgYXMgd2VsbCAtIHNob3VsZCBwcmVsb2FkIHRoZSBkYXRhIG9yIGNsZWFyIHRoZSBhbHJlYWR5IGNhY2hlZCBpdGVtc1xuICAgICAgICBpZiAoYW55Q2hhbmdlZChbJ25vZGVzJywgJ2NoaWxkcmVuJywgJ2hhc0NoaWxkcmVuJywgJ2xvYWRPbkRlbWFuZCddLCBjaGFuZ2VzLCBmYWxzZSkgJiYgIXRoaXMubG9hZE9uRGVtYW5kKSB7XG4gICAgICAgICAgICB0aGlzLnByZWxvYWRDaGlsZE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmRvbVN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWJzY3JpcHRpb24gPT4gc3Vic2NyaXB0aW9uKCkpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLm5vZGVDaGlsZHJlblNlcnZpY2VcbiAgICAgICAgICAgIC5jaGFuZ2VzXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh4KSA9PiB0aGlzLmNoaWxkcmVuTG9hZGVkLmVtaXQoeCkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmV4cGFuZFNlcnZpY2UuY2hhbmdlc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgoeyBpbmRleCwgZGF0YUl0ZW0sIGV4cGFuZCB9KSA9PiBleHBhbmRcbiAgICAgICAgICAgID8gdGhpcy5leHBhbmQuZW1pdCh7IGluZGV4LCBkYXRhSXRlbSB9KVxuICAgICAgICAgICAgOiB0aGlzLmNvbGxhcHNlLmVtaXQoeyBpbmRleCwgZGF0YUl0ZW0gfSkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmNoZWNrc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgoeCkgPT4gdGhpcy5jaGVja2VkQ2hhbmdlLmVtaXQodGhpcy50cmVlVmlld0xvb2t1cFNlcnZpY2UuaXRlbUxvb2t1cCh4KSkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnNlbGVjdGlvblNlcnZpY2UuY2hhbmdlc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgoeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLnNlbGVjdGlvbkNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaERvbUhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBnZXRTaXplQ2xhc3MoJ3RyZWV2aWV3JywgdGhpcy5zaXplKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIGZvY3VzZWQgVHJlZVZpZXcgaXRlbS5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGZvY3VzYWJsZU5vZGUodGhpcy5lbGVtZW50KTtcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBmaXJzdCBmb2N1c2FibGUgaXRlbSBpbiB0aGUgVHJlZVZpZXcgY29tcG9uZW50IGlmIG5vIGhpZXJhcmNoaWNhbCBpbmRleCBpcyBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAgICAgKlxuICAgICAqICBAQ29tcG9uZW50KHtcbiAgICAgKiAgICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiAgICAgIHRlbXBsYXRlOiBgXG4gICAgICogICAgICA8YnV0dG9uIChjbGljayk9XCJ0cmVldmlldy5mb2N1cygnMScpXCI+Rm9jdXNlcyB0aGUgc2Vjb25kIG5vZGU8L2J1dHRvbj5cbiAgICAgKiAgICAgIDxrZW5kby10cmVldmlld1xuICAgICAqICAgICAgICAgICN0cmVldmlld1xuICAgICAqICAgICAgICAgIFtub2Rlc109XCJkYXRhXCJcbiAgICAgKiAgICAgICAgICB0ZXh0RmllbGQ9XCJ0ZXh0XCJcbiAgICAgKiAgICAgID5cbiAgICAgKiAgICAgIDwva2VuZG8tdHJlZXZpZXc+XG4gICAgICogIGBcbiAgICAgKiAgfSlcbiAgICAgKiAgZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICAgICBwdWJsaWMgZGF0YTogYW55W10gPSBbXG4gICAgICogICAgICAgICAgeyB0ZXh0OiBcIkZ1cm5pdHVyZVwiIH0sXG4gICAgICogICAgICAgICAgeyB0ZXh0OiBcIkRlY29yXCIgfVxuICAgICAqICAgICAgXTtcbiAgICAgKiAgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvY3VzKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGZvY3VzSW5kZXggPSBpbmRleCB8fCBub2RlSW5kZXgodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5mb2N1c2FibGVJdGVtKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hY3RpdmF0ZUluZGV4KGZvY3VzSW5kZXgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBmb2N1c2FibGVOb2RlKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHRhcmdldC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaW5kZXgsIHJldHVybnMgdGhlIFRyZWVJdGVtTG9va3VwIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIG5vZGUuXG4gICAgICogQHJldHVybnMge1RyZWVJdGVtTG9va3VwfSAtIFRoZSBpdGVtIHRoYXQgd2FzIHNlYXJjaGVkIChsb29rZWQgdXApLlxuICAgICAqL1xuICAgIGl0ZW1Mb29rdXAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZVZpZXdMb29rdXBTZXJ2aWNlLml0ZW1Mb29rdXAoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgW2BjaGlsZHJlbmBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1jaGlsZHJlbikgZnVuY3Rpb24gZm9yIGV2ZXJ5IGV4cGFuZGVkIG5vZGUsXG4gICAgICogY2F1c2luZyBhbGwgcmVuZGVyZWQgY2hpbGQgbm9kZXMgdG8gYmUgZmV0Y2hlZCBhZ2Fpbi5cbiAgICAgKi9cbiAgICByZWJpbmRDaGlsZHJlbigpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlTm90aWZpY2F0aW9uLm5vdGlmeSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgYGV4cGFuZGAgZXZlbnQgZm9yIHRoZSBwcm92aWRlZCBub2RlIGFuZCBkaXNwbGF5cyBpdCdzIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgICAqL1xuICAgIGV4cGFuZE5vZGUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZChpbmRleCwgaXRlbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIHRoZSBgY29sbGFwc2VgIGV2ZW50IGZvciB0aGUgcHJvdmlkZWQgbm9kZS5cbiAgICAgKi9cbiAgICBjb2xsYXBzZU5vZGUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlLmNvbGxhcHNlKGluZGV4LCBpdGVtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBwYWdlIHNpemUgb2YgdGhlIGNoZWNrZWQgZGF0YSBpdGVtIGNoaWxkcmVuIGNvbGxlY3Rpb25cbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGxvYWRtb3JlYnV0dG9uX3RyZWV2aWV3ICV9I3RvYy1tYW5hZ2luZy1wYWdlLXNpemVzKSkuXG4gICAgICpcbiAgICAgKiA+IFNpbmNlIHRoZSByb290IG5vZGVzIGNvbGxlY3Rpb24gaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgcGFyZW50IGRhdGEgaXRlbSwgcGFzcyBgbnVsbGAgYXMgYGRhdGFJdGVtYCBwYXJhbSB0byBnZXQgaXRzIHBhZ2Ugc2l6ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhSXRlbSB7YW55fSAtIFRoZSBwYXJlbnQgZGF0YSBpdGVtIG9mIHRoZSB0YXJnZXRlZCBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIHBhZ2Ugc2l6ZSBvZiB0aGUgY2hlY2tlZCBkYXRhIGl0ZW0gY2hpbGRyZW4gY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXROb2RlUGFnZVNpemUoZGF0YUl0ZW0pIHtcbiAgICAgICAgdGhpcy52ZXJpZnlMb2FkTW9yZVNlcnZpY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZE1vcmVTZXJ2aWNlLmdldEdyb3VwU2l6ZShkYXRhSXRlbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBhZ2Ugc2l6ZSBvZiB0aGUgdGFyZ2V0ZWQgZGF0YSBpdGVtIGNoaWxkcmVuIGNvbGxlY3Rpb25cbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGxvYWRtb3JlYnV0dG9uX3RyZWV2aWV3ICV9I3RvYy1tYW5hZ2luZy1wYWdlLXNpemVzKSkuXG4gICAgICpcbiAgICAgKiA+IFNpbmNlIHRoZSByb290IG5vZGVzIGNvbGxlY3Rpb24gaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgcGFyZW50IGRhdGEgaXRlbSwgcGFzcyBgbnVsbGAgYXMgYGRhdGFJdGVtYCBwYXJhbSB0byB0YXJnZXQgaXRzIHBhZ2Ugc2l6ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhSXRlbSB7YW55fSAtIFRoZSBwYXJlbnQgZGF0YSBpdGVtIG9mIHRoZSB0YXJnZXRlZCBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBwYWdlU2l6ZSB7bnVtYmVyfSAtIFRoZSBuZXcgcGFnZSBzaXplLlxuICAgICAqL1xuICAgIHNldE5vZGVQYWdlU2l6ZShkYXRhSXRlbSwgcGFnZVNpemUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlMb2FkTW9yZVNlcnZpY2UoKTtcbiAgICAgICAgdGhpcy5sb2FkTW9yZVNlcnZpY2Uuc2V0R3JvdXBTaXplKGRhdGFJdGVtLCBwYWdlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIENsZWFycyB0aGUgY3VycmVudCBUcmVlVmlld0xvb2t1cFNlcnZpY2Ugbm9kZSBtYXAgYW5kIHJlLXJlZ2lzdGVycyBhbGwgbm9kZXMgYW5ldy5cbiAgICAgKiBDaGlsZCBub2RlcyBhcmUgYWNxdWlyZWQgdGhyb3VnaCB0aGUgcHJvdmlkZWQgYGNoaWxkcmVuYCBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBwcmVsb2FkQ2hpbGROb2RlcygpIHtcbiAgICAgICAgdGhpcy50cmVlVmlld0xvb2t1cFNlcnZpY2UucmVzZXQoKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlckxvb2t1cEl0ZW1zKHRoaXMubm9kZXMpO1xuICAgIH1cbiAgICBhdHRhY2hEb21IYW5kbGVycygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLmNsaWNrSGFuZGxlciA9IHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9tU3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdjb250ZXh0bWVudScsIHRoaXMuY2xpY2tIYW5kbGVyKSwgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXIpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnZGJsY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlciksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdmb2N1c2luJywgdGhpcy5mb2N1c0hhbmRsZXIuYmluZCh0aGlzKSksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdmb2N1c291dCcsIHRoaXMuYmx1ckhhbmRsZXIuYmluZCh0aGlzKSksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlci5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIGZvY3VzSGFuZGxlcihlKSB7XG4gICAgICAgIGxldCBmb2N1c0l0ZW07XG4gICAgICAgIGlmIChtYXRjaChlLnRhcmdldCwgJy5rLXRyZWV2aWV3LWl0ZW0nKSkge1xuICAgICAgICAgICAgZm9jdXNJdGVtID0gZS50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzRm9jdXNhYmxlKGUudGFyZ2V0KSkgeyAvLyB3aXRoIGNvbXBsaW1lbnRzIHRvIElFXG4gICAgICAgICAgICBmb2N1c0l0ZW0gPSBjbG9zZXN0Tm9kZShlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvY3VzSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hY3RpdmF0ZUluZGV4KG5vZGVJZChlLnRhcmdldCkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlICYmIGhhc09ic2VydmVycyh0aGlzLm9uRm9jdXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJsdXJIYW5kbGVyKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUgJiYgbWF0Y2goZS50YXJnZXQsICcuay10cmVldmlldy1pdGVtJykgJiZcbiAgICAgICAgICAgICghZS5yZWxhdGVkVGFyZ2V0IHx8ICFtYXRjaChlLnJlbGF0ZWRUYXJnZXQsICcuay10cmVldmlldy1pdGVtJykgfHwgIWhhc1BhcmVudChlLnJlbGF0ZWRUYXJnZXQsIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSkpIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uQmx1cikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xpY2tIYW5kbGVyKGUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIGlmICgoZS50eXBlID09PSAnY29udGV4dG1lbnUnICYmICFoYXNPYnNlcnZlcnModGhpcy5ub2RlQ2xpY2spKSB8fFxuICAgICAgICAgICAgKGUudHlwZSA9PT0gJ2NsaWNrJyAmJiAhaGFzT2JzZXJ2ZXJzKHRoaXMubm9kZUNsaWNrKSAmJiAhaGFzT2JzZXJ2ZXJzKHRoaXMuc2VsZWN0aW9uQ2hhbmdlKSAmJiAhaXNMb2FkTW9yZUJ1dHRvbih0YXJnZXQpKSB8fFxuICAgICAgICAgICAgKGUudHlwZSA9PT0gJ2RibGNsaWNrJyAmJiAhaGFzT2JzZXJ2ZXJzKHRoaXMubm9kZURibENsaWNrKSkgfHwgaXNGb2N1c2FibGUodGFyZ2V0KSB8fFxuICAgICAgICAgICAgKCFpc0NvbnRlbnQodGFyZ2V0KSAmJiAhaXNMb2FkTW9yZUJ1dHRvbih0YXJnZXQpKSB8fCAhaGFzUGFyZW50KHRhcmdldCwgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSBub2RlSWQoY2xvc2VzdE5vZGUodGFyZ2V0KSk7XG4gICAgICAgIC8vIHRoZSBkaXNhYmxlZCBjaGVjayBpcyBwcm9iYWJseSBub3QgbmVlZGVkIGR1ZSB0byB0aGUgay1kaXNhYmxlZCBzdHlsZXNcbiAgICAgICAgaWYgKCFpbmRleCB8fCB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmlzRGlzYWJsZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIHJlY29yZCB0aGlzIHZhbHVlIGJlZm9yZSBlbWl0dGluZyBzZWxlY3Rpb25DaGFuZ2UgKGB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdEluZGV4YCksIGFzIHRoZSB0cmVldmlldyBzdGF0ZSBtYXkgYmUgY2hhbmdlZCBvbiBpdHMgZW1pc3Npb25cbiAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IHRoaXMudHJlZVZpZXdMb29rdXBTZXJ2aWNlLml0ZW1Mb29rdXAoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRNb3JlQnV0dG9uID0gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5tb2RlbC5maW5kTm9kZShpbmRleCkubG9hZE1vcmVCdXR0b247XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRNb3JlQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2Uubm90aWZ5TG9hZE1vcmUoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbWl0dGVyID0gZS50eXBlID09PSAnZGJsY2xpY2snID8gdGhpcy5ub2RlRGJsQ2xpY2sgOiB0aGlzLm5vZGVDbGljaztcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCh7XG4gICAgICAgICAgICAgICAgaXRlbTogbG9va3VwLml0ZW0sXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAga2V5ZG93bkhhbmRsZXIoZSkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSAmJiB0aGlzLm5hdmlnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLm1vdmUoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnlMb2FkTW9yZVNlcnZpY2UoKSB7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSAmJiAhaXNQcmVzZW50KHRoaXMubG9hZE1vcmVTZXJ2aWNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUbyB1c2UgdGhlIFRyZWVWaWV3IHBhZ2luZyBmdW5jdGlvbmFsaXR5LCB5b3UgbmVlZCB0byBhc3NpZ24gdGhlIFxcYGtlbmRvVHJlZVZpZXdMb2FkTW9yZVxcYCBkaXJlY3RpdmUuIFNlZSAke0xPQURfTU9SRV9ET0NfTElOS30uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJMb29rdXBJdGVtcyhkYXRhLCBwYXJlbnRJdGVtID0gbnVsbCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChkYXRhKSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudEluZGV4ID0gbm9kZUluZGV4KHBhcmVudEl0ZW0pO1xuICAgICAgICBjb25zdCB0cmVlSXRlbXMgPSBkYXRhLm1hcCgobm9kZSwgaW5kZXgpID0+IGJ1aWxkVHJlZUl0ZW0obm9kZSwgaW5kZXgsIHBhcmVudEluZGV4KSk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50SXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZVZpZXdMb29rdXBTZXJ2aWNlLnJlZ2lzdGVyQ2hpbGRyZW4ocGFyZW50SW5kZXgsIHRyZWVJdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJlZUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyZWVWaWV3TG9va3VwU2VydmljZS5yZWdpc3Rlckl0ZW0oaXRlbSwgcGFyZW50SXRlbSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbihpdGVtLmRhdGFJdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4oaXRlbS5kYXRhSXRlbSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZShjaGlsZHJlbiA9PiB0aGlzLnJlZ2lzdGVyTG9va3VwSXRlbXMoY2hpbGRyZW4sIGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay10cmVldmlld1wiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjbGFzc05hbWVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImF0dHIucm9sZVwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcInJvbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiYXR0ci5kaXJcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnYXNzZXRzQ29udGFpbmVyJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmLCBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpZXdDb250YWluZXJSZWYpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYXNzZXRzQ29udGFpbmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVySW5wdXRQbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBIb3N0QmluZGluZygnQC5kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImNoaWxkcmVuTG9hZGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2JsdXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIm9uQmx1clwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCdmb2N1cycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwib25Gb2N1c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBhbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sbGFwc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwibm9kZURyYWdTdGFydFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJub2RlRHJhZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJTdGF0ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJub2RlRHJvcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJub2RlRHJhZ0VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhZGRJdGVtXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcInJlbW92ZUl0ZW1cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hlY2tlZENoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3Rpb25DaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVDbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJub2RlRGJsQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChOb2RlVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTm9kZVRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVUZW1wbGF0ZVF1ZXJ5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnbm9kZVRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE5vZGVUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOb2RlVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChMb2FkTW9yZUJ1dHRvblRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIExvYWRNb3JlQnV0dG9uVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwibG9hZE1vcmVCdXR0b25UZW1wbGF0ZVF1ZXJ5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnbG9hZE1vcmVCdXR0b25UZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBMb2FkTW9yZUJ1dHRvblRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvYWRNb3JlQnV0dG9uVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImxvYWRNb3JlQnV0dG9uVGVtcGxhdGVSZWZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmFja0J5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwibm9kZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGV4dEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGdW5jdGlvbl0pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaGFzQ2hpbGRyZW5cIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGdW5jdGlvbl0pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNDaGVja2VkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNEaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRnVuY3Rpb25dKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImlzRXhwYW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGdW5jdGlvbl0pXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNTZWxlY3RlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImlzVmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2FibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImxvYWRPbkRlbWFuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUcmVlVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIFRyZWVWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaXplXCIsIG51bGwpO1xuVHJlZVZpZXdDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9UcmVlVmlldycsXG4gICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWV2aWV3JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW5cbiAgICAgICAgICAgIGNsYXNzPVwiay10cmVldmlldy1maWx0ZXJcIlxuICAgICAgICAgICAgKm5nSWY9XCJmaWx0ZXJhYmxlXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGtlbmRvLXRleHRib3hcbiAgICAgICAgICAgICAgICBbc2l6ZV09XCJzaXplXCJcbiAgICAgICAgICAgICAgICBbdmFsdWVdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgICAgICBbY2xlYXJCdXR0b25dPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImZpbHRlckNoYW5nZS5lbWl0KCRldmVudClcIlxuICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJmaWx0ZXJJbnB1dFBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UZXh0Qm94UHJlZml4VGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pbnB1dC1pY29uIGstaWNvbiBrLWktc2VhcmNoXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L2tlbmRvLXRleHRib3g+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPHVsIGNsYXNzPVwiay10cmVldmlldy1saW5lc1wiXG4gICAgICAgICAgICBrZW5kb1RyZWVWaWV3R3JvdXBcbiAgICAgICAgICAgIHJvbGU9XCJncm91cFwiXG4gICAgICAgICAgICBbc2l6ZV09XCJzaXplXCJcbiAgICAgICAgICAgIFtsb2FkT25EZW1hbmRdPVwibG9hZE9uRGVtYW5kXCJcbiAgICAgICAgICAgIFtjaGVja2JveGVzXT1cImNoZWNrYm94ZXNcIlxuICAgICAgICAgICAgW2V4cGFuZEljb25zXT1cImV4cGFuZEljb25zXCJcbiAgICAgICAgICAgIFtzZWxlY3RhYmxlXT1cInNlbGVjdGFibGVcIlxuICAgICAgICAgICAgW3RvdWNoQWN0aW9uc109XCJ0b3VjaEFjdGlvbnNcIlxuICAgICAgICAgICAgW2NoaWxkcmVuXT1cImNoaWxkcmVuXCJcbiAgICAgICAgICAgIFtoYXNDaGlsZHJlbl09XCJoYXNDaGlsZHJlblwiXG4gICAgICAgICAgICBbaXNDaGVja2VkXT1cImlzQ2hlY2tlZFwiXG4gICAgICAgICAgICBbaXNEaXNhYmxlZF09XCJpc0Rpc2FibGVkXCJcbiAgICAgICAgICAgIFtpc0V4cGFuZGVkXT1cImlzRXhwYW5kZWRcIlxuICAgICAgICAgICAgW2lzU2VsZWN0ZWRdPVwiaXNTZWxlY3RlZFwiXG4gICAgICAgICAgICBbaXNWaXNpYmxlXT1cImlzVmlzaWJsZVwiXG4gICAgICAgICAgICBbbm9kZVRlbXBsYXRlUmVmXT1cIm5vZGVUZW1wbGF0ZVJlZj8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW2xvYWRNb3JlQnV0dG9uVGVtcGxhdGVSZWZdPVwibG9hZE1vcmVCdXR0b25UZW1wbGF0ZVJlZj8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW3RleHRGaWVsZF09XCJ0ZXh0RmllbGRcIlxuICAgICAgICAgICAgW25vZGVzXT1cImZldGNoTm9kZXNcIlxuICAgICAgICAgICAgW2xvYWRNb3JlU2VydmljZV09XCJsb2FkTW9yZVNlcnZpY2VcIlxuICAgICAgICAgICAgW3RyYWNrQnldPVwidHJhY2tCeVwiXG4gICAgICAgID5cbiAgICAgICAgPC91bD5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAjYXNzZXRzQ29udGFpbmVyPjwvbmctY29udGFpbmVyPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBFeHBhbmRTdGF0ZVNlcnZpY2UsXG4gICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBOb2RlQ2hpbGRyZW5TZXJ2aWNlLFxuICAgICAgICBTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBUcmVlVmlld0xvb2t1cFNlcnZpY2UsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBEYXRhQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBUcmVlVmlld0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVHJlZVZpZXdHcm91cENvbXBvbmVudCA9IGNsYXNzIFRyZWVWaWV3R3JvdXBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGV4cGFuZFNlcnZpY2UsIGxvYWRpbmdTZXJ2aWNlLCBpbmRleEJ1aWxkZXIsIHRyZWVWaWV3TG9va3VwU2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2UsIG5vZGVDaGlsZHJlblNlcnZpY2UsIGRhdGFDaGFuZ2VOb3RpZmljYXRpb24sIGNoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kU2VydmljZSA9IGV4cGFuZFNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9hZGluZ1NlcnZpY2UgPSBsb2FkaW5nU2VydmljZTtcbiAgICAgICAgdGhpcy5pbmRleEJ1aWxkZXIgPSBpbmRleEJ1aWxkZXI7XG4gICAgICAgIHRoaXMudHJlZVZpZXdMb29rdXBTZXJ2aWNlID0gdHJlZVZpZXdMb29rdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlID0gbmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubm9kZUNoaWxkcmVuU2VydmljZSA9IG5vZGVDaGlsZHJlblNlcnZpY2U7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZU5vdGlmaWNhdGlvbiA9IGRhdGFDaGFuZ2VOb3RpZmljYXRpb247XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYgPSBjaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgdGhpcy5rR3JvdXBDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMucm9sZSA9ICdncm91cCc7XG4gICAgICAgIHRoaXMubG9hZE9uRGVtYW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50ZXh0RmllbGQgPSBcIlwiO1xuICAgICAgICB0aGlzLnNpemUgPSAnbWVkaXVtJztcbiAgICAgICAgdGhpcy5pbml0aWFsTm9kZXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nTW9yZU5vZGVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5zaW5nbGVSZWNvcmRTdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLmlzQ2hlY2tlZCA9ICgpID0+ICdub25lJztcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gKCkgPT4gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9ICgpID0+IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9ICgpID0+IHRydWU7XG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9ICgpID0+IGZhbHNlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gKCkgPT4gb2YoW10pO1xuICAgICAgICB0aGlzLmhhc0NoaWxkcmVuID0gKCkgPT4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBtb3JlTm9kZXNBdmFpbGFibGUoKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMubG9hZE1vcmVTZXJ2aWNlKSB8fCB0aGlzLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZVNpemUgPCB0aGlzLnRvdGFsTm9kZXNDb3VudDtcbiAgICB9XG4gICAgZ2V0IHBhZ2VTaXplKCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLmxvYWRNb3JlU2VydmljZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRNb3JlU2VydmljZS5nZXRHcm91cFNpemUodGhpcy5wYXJlbnREYXRhSXRlbSk7XG4gICAgfVxuICAgIHNldCBwYWdlU2l6ZShwYWdlU2l6ZSkge1xuICAgICAgICB0aGlzLmxvYWRNb3JlU2VydmljZS5zZXRHcm91cFNpemUodGhpcy5wYXJlbnREYXRhSXRlbSwgcGFnZVNpemUpO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBhZ2VTaXplKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFNpemVWYWx1ZSA9IHRoaXMucGFnZVNpemUgPiAwID8gdGhpcy5wYWdlU2l6ZSA6IDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5zbGljZSgwLCBub3JtYWxpemVkU2l6ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG4gICAgc2V0IGRhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckxvYWRlZE5vZGVzKHRoaXMuZGF0YSk7XG4gICAgfVxuICAgIGdldCBsb2FkTW9yZUJ1dHRvbkluZGV4KCkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZE1vcmVTZXJ2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlSW5kZXgodGhpcy5kYXRhLmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBmb3IgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgICovXG4gICAgZ2V0IHRvdGFsTm9kZXNDb3VudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRNb3JlU2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZE1vcmVTZXJ2aWNlLmdldFRvdGFsTm9kZXNDb3VudCh0aGlzLnBhcmVudERhdGFJdGVtLCB0aGlzLl9kYXRhLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldCBoYXNUZW1wbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm5vZGVUZW1wbGF0ZVJlZik7XG4gICAgfVxuICAgIGV4cGFuZE5vZGUoaW5kZXgsIGRhdGFJdGVtLCBleHBhbmQpIHtcbiAgICAgICAgaWYgKGV4cGFuZCkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZChpbmRleCwgZGF0YUl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlLmNvbGxhcHNlKGluZGV4LCBkYXRhSXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tOb2RlKGluZGV4KSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuY2hlY2tJbmRleChpbmRleCk7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuYWN0aXZhdGVJbmRleChpbmRleCk7XG4gICAgfVxuICAgIG5vZGVJbmRleChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleEJ1aWxkZXIubm9kZUluZGV4KGluZGV4LnRvU3RyaW5nKCksIHRoaXMucGFyZW50SW5kZXgpO1xuICAgIH1cbiAgICBub2RlVGV4dChkYXRhSXRlbSkge1xuICAgICAgICBjb25zdCB0ZXh0RmllbGQgPSBpc0FycmF5KHRoaXMudGV4dEZpZWxkKSA/IHRoaXMudGV4dEZpZWxkWzBdIDogdGhpcy50ZXh0RmllbGQ7XG4gICAgICAgIHJldHVybiBnZXR0ZXIodGV4dEZpZWxkKShkYXRhSXRlbSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubm9kZXNTdWJzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxvYWRNb3JlTm9kZXNTdWJzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRNb3JlTm9kZXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpbmdsZVJlY29yZFN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9Ob2Rlc0NoYW5nZSgpO1xuICAgICAgICB0aGlzLnNpbmdsZVJlY29yZFN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuZGF0YUNoYW5nZU5vdGlmaWNhdGlvblxuICAgICAgICAgICAgLmNoYW5nZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5zdWJzY3JpYmVUb05vZGVzQ2hhbmdlLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zaW5nbGVSZWNvcmRTdWJzY3JpcHRpb25zLmFkZCh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmxvYWRNb3JlXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoaW5kZXggPT4gaW5kZXggPT09IHRoaXMubG9hZE1vcmVCdXR0b25JbmRleCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMubG9hZE1vcmVOb2Rlcy5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMucGFyZW50SW5kZXggJiYgdGhpcy5sb2FkT25EZW1hbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUNoaWxkcmVuKHRoaXMubWFwVG9UcmVlSXRlbSh0aGlzLmRhdGEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmZXRjaENoaWxkcmVuKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuKG5vZGUpXG4gICAgICAgICAgICAucGlwZShjYXRjaEVycm9yKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1NlcnZpY2Uubm90aWZ5TG9hZGVkKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgfSksIHRhcCgoKSA9PiB0aGlzLmxvYWRpbmdTZXJ2aWNlLm5vdGlmeUxvYWRlZChpbmRleCkpKTtcbiAgICB9XG4gICAgZ2V0IG5leHRGaWVsZHMoKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHRoaXMudGV4dEZpZWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dEZpZWxkLmxlbmd0aCA+IDEgPyB0aGlzLnRleHRGaWVsZC5zbGljZSgxKSA6IHRoaXMudGV4dEZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGhpcy50ZXh0RmllbGRdO1xuICAgIH1cbiAgICBsb2FkTW9yZU5vZGVzKCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubG9hZE1vcmVTZXJ2aWNlLmxvYWRNb3JlTm9kZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoTW9yZU5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRNb3JlTG9jYWxOb2RlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvYWRNb3JlTG9jYWxOb2RlcygpIHtcbiAgICAgICAgY29uc3QgaW5pdGlhbExvYWRNb3JlQnV0dG9uSW5kZXggPSB0aGlzLmxvYWRNb3JlQnV0dG9uSW5kZXg7XG4gICAgICAgIHRoaXMucGFnZVNpemUgKz0gdGhpcy5sb2FkTW9yZVNlcnZpY2UuZ2V0SW5pdGlhbFBhZ2VTaXplKHRoaXMucGFyZW50RGF0YUl0ZW0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTG9hZGVkTm9kZXModGhpcy5kYXRhKTtcbiAgICAgICAgLy8gZm9yY2VzIHRoZSBuZXcgaXRlbXMgdG8gYmUgcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGZvY3VzIGlzIGNoYW5nZWRcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMucmVzZWxlY3RJdGVtQXQoaW5pdGlhbExvYWRNb3JlQnV0dG9uSW5kZXgpO1xuICAgIH1cbiAgICBmZXRjaE1vcmVOb2RlcygpIHtcbiAgICAgICAgaWYgKHRoaXMubG9hZGluZ01vcmVOb2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGluZ01vcmVOb2RlcyA9IHRydWU7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5sb2FkTW9yZU5vZGVzU3Vic2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkTW9yZU5vZGVzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkTW9yZU5vZGVzU3Vic2NyaXB0aW9uID0gdGhpcy5sb2FkTW9yZVNlcnZpY2VcbiAgICAgICAgICAgIC5sb2FkTW9yZU5vZGVzKHtcbiAgICAgICAgICAgIGRhdGFJdGVtOiB0aGlzLnBhcmVudERhdGFJdGVtLFxuICAgICAgICAgICAgc2tpcDogdGhpcy5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHRha2U6IHRoaXMubG9hZE1vcmVTZXJ2aWNlLmdldEluaXRpYWxQYWdlU2l6ZSh0aGlzLnBhcmVudERhdGFJdGVtKVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnBpcGUoZmluYWxpemUoKCkgPT4gdGhpcy5sb2FkaW5nTW9yZU5vZGVzID0gZmFsc2UpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShpdGVtcyA9PiB7XG4gICAgICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGl0ZW1zKSAmJiBpdGVtcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxMb2FkTW9yZUJ1dHRvbkluZGV4ID0gdGhpcy5sb2FkTW9yZUJ1dHRvbkluZGV4O1xuICAgICAgICAgICAgdGhpcy5wYWdlU2l6ZSArPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuY29uY2F0KGl0ZW1zKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmlzQWN0aXZlKGluaXRpYWxMb2FkTW9yZUJ1dHRvbkluZGV4KSkge1xuICAgICAgICAgICAgICAgIC8vIGZvcmNlcyB0aGUgbmV3IGl0ZW1zIHRvIGJlIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBmb2N1cyBpcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNlbGVjdEl0ZW1BdChpbml0aWFsTG9hZE1vcmVCdXR0b25JbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXROb2RlQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy50cmVlVmlld0xvb2t1cFNlcnZpY2UucmVnaXN0ZXJDaGlsZHJlbih0aGlzLnBhcmVudEluZGV4LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIG1hcFRvVHJlZUl0ZW0oZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoKGRhdGFJdGVtLCBpZHgpID0+ICh7IGRhdGFJdGVtLCBpbmRleDogdGhpcy5ub2RlSW5kZXgoaWR4KSB9KSk7XG4gICAgfVxuICAgIGVtaXRDaGlsZHJlbkxvYWRlZChjaGlsZHJlbikge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZ25vcmVzIHRoZSByZWdpc3RlcmVkIGxvYWQtbW9yZSBidXR0b25cbiAgICAgICAgY29uc3QgY29udGVudENoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGl0ZW0gPT4gaXRlbS5kYXRhSXRlbSk7XG4gICAgICAgIHRoaXMubm9kZUNoaWxkcmVuU2VydmljZS5jaGlsZHJlbkxvYWRlZCh7IGRhdGFJdGVtOiB0aGlzLnBhcmVudERhdGFJdGVtLCBpbmRleDogdGhpcy5wYXJlbnRJbmRleCB9LCBjb250ZW50Q2hpbGRyZW4pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUb05vZGVzQ2hhbmdlKCkge1xuICAgICAgICBpZiAodGhpcy5ub2Rlc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZXNTdWJzY3JpcHRpb24gPSB0aGlzLm5vZGVzKHRoaXMucGFyZW50RGF0YUl0ZW0sIHRoaXMucGFyZW50SW5kZXgpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGRhdGEgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vZGVzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc2VsZWN0SXRlbUF0KGluZGV4KSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgb2xkIGluZGV4IGlzIGNsZWFyZWQgZmlyc3RcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5kZWFjdGl2YXRlKCk7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuYWN0aXZhdGVJbmRleChpbmRleCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyTG9hZGVkTm9kZXMobm9kZXMgPSBbXSkge1xuICAgICAgICBjb25zdCBtYXBwZWRDaGlsZHJlbiA9IHRoaXMubWFwVG9UcmVlSXRlbShub2Rlcyk7XG4gICAgICAgIGlmICh0aGlzLmxvYWRPbkRlbWFuZCkge1xuICAgICAgICAgICAgdGhpcy5zZXROb2RlQ2hpbGRyZW4obWFwcGVkQ2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdENoaWxkcmVuTG9hZGVkKG1hcHBlZENoaWxkcmVuKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoXCJjbGFzcy5rLXRyZWV2aWV3LWdyb3VwXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwia0dyb3VwQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiYXR0ci5yb2xlXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hlY2tib3hlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImV4cGFuZEljb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwidG91Y2hBY3Rpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwibG9hZE9uRGVtYW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcInRyYWNrQnlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9kZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwicGFyZW50RGF0YUl0ZW1cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcInBhcmVudEluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVUZW1wbGF0ZVJlZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsb2FkTW9yZUJ1dHRvblRlbXBsYXRlUmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsb2FkTW9yZVNlcnZpY2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNDaGVja2VkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImlzRGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNFeHBhbmRlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc1Zpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVHJlZVZpZXdHcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNTZWxlY3RlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYXNDaGlsZHJlblwiLCB2b2lkIDApO1xuVHJlZVZpZXdHcm91cENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgIHRyaWdnZXIoJ3RvZ2dsZScsIFtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlKHsgaGVpZ2h0OiAwIH0pLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlKCcwLjFzIGVhc2UtaW4nLCBzdHlsZSh7IGhlaWdodDogXCIqXCIgfSkpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSh7IGhlaWdodDogXCIqXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoJzAuMXMgZWFzZS1pbicsIHN0eWxlKHsgaGVpZ2h0OiAwIH0pKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3R3JvdXBdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGxpXG4gICAgICAgICAgICAqbmdGb3I9XCJsZXQgbm9kZSBvZiBkYXRhOyBsZXQgaW5kZXggPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeVwiXG4gICAgICAgICAgICBjbGFzcz1cImstdHJlZXZpZXctaXRlbVwiXG4gICAgICAgICAgICBbY2xhc3Muay1kaXNwbGF5LW5vbmVdPVwiIWlzVmlzaWJsZShub2RlLCBub2RlSW5kZXgoaW5kZXgpKVwiXG4gICAgICAgICAgICBrZW5kb1RyZWVWaWV3SXRlbVxuICAgICAgICAgICAgW2F0dHIuYXJpYS1zZXRzaXplXT1cInRvdGFsTm9kZXNDb3VudFwiXG4gICAgICAgICAgICBbZGF0YUl0ZW1dPVwibm9kZVwiXG4gICAgICAgICAgICBbaW5kZXhdPVwibm9kZUluZGV4KGluZGV4KVwiXG4gICAgICAgICAgICBbcGFyZW50RGF0YUl0ZW1dPVwicGFyZW50RGF0YUl0ZW1cIlxuICAgICAgICAgICAgW3BhcmVudEluZGV4XT1cInBhcmVudEluZGV4XCJcbiAgICAgICAgICAgIFtsb2FkT25EZW1hbmRdPVwibG9hZE9uRGVtYW5kXCJcbiAgICAgICAgICAgIFtjaGVja2FibGVdPVwiY2hlY2tib3hlc1wiXG4gICAgICAgICAgICBbaXNDaGVja2VkXT1cImlzQ2hlY2tlZChub2RlLCBub2RlSW5kZXgoaW5kZXgpKVwiXG4gICAgICAgICAgICBbaXNEaXNhYmxlZF09XCJkaXNhYmxlZCB8fCBpc0Rpc2FibGVkKG5vZGUsIG5vZGVJbmRleChpbmRleCkpXCJcbiAgICAgICAgICAgIFtpc1Zpc2libGVdPVwiaXNWaXNpYmxlKG5vZGUsIG5vZGVJbmRleChpbmRleCkpXCJcbiAgICAgICAgICAgIFtleHBhbmRhYmxlXT1cImV4cGFuZEljb25zICYmIGhhc0NoaWxkcmVuKG5vZGUpXCJcbiAgICAgICAgICAgIFtpc0V4cGFuZGVkXT1cImlzRXhwYW5kZWQobm9kZSwgbm9kZUluZGV4KGluZGV4KSlcIlxuICAgICAgICAgICAgW3NlbGVjdGFibGVdPVwic2VsZWN0YWJsZVwiXG4gICAgICAgICAgICBbaXNTZWxlY3RlZF09XCJpc1NlbGVjdGVkKG5vZGUsIG5vZGVJbmRleChpbmRleCkpXCJcbiAgICAgICAgICAgIFthdHRyLmRhdGEtdHJlZWluZGV4XT1cIm5vZGVJbmRleChpbmRleClcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay10cmVldmlldy1taWRcIj5cbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstdHJlZXZpZXctdG9nZ2xlXCJcbiAgICAgICAgICAgICAgICAgICAgW2tlbmRvVHJlZVZpZXdMb2FkaW5nXT1cIm5vZGVJbmRleChpbmRleClcIlxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiZXhwYW5kTm9kZShub2RlSW5kZXgoaW5kZXgpLCBub2RlLCAhaXNFeHBhbmRlZChub2RlLCBub2RlSW5kZXgoaW5kZXgpKSlcIlxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImV4cGFuZEljb25zICYmIGhhc0NoaWxkcmVuKG5vZGUpXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstaWNvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1pLWNvbGxhcHNlXT1cImlzRXhwYW5kZWQobm9kZSwgbm9kZUluZGV4KGluZGV4KSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstaS1leHBhbmRdPVwiIWlzRXhwYW5kZWQobm9kZSwgbm9kZUluZGV4KGluZGV4KSlcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGtlbmRvLWNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiY2hlY2tib3hlc1wiXG4gICAgICAgICAgICAgICAgICAgIFtzaXplXT1cInNpemVcIlxuICAgICAgICAgICAgICAgICAgICBbbm9kZV09XCJub2RlXCJcbiAgICAgICAgICAgICAgICAgICAgW2luZGV4XT1cIm5vZGVJbmRleChpbmRleClcIlxuICAgICAgICAgICAgICAgICAgICBbaXNDaGVja2VkXT1cImlzQ2hlY2tlZFwiXG4gICAgICAgICAgICAgICAgICAgIChjaGVja1N0YXRlQ2hhbmdlKT1cImNoZWNrTm9kZShub2RlSW5kZXgoaW5kZXgpKVwiXG4gICAgICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgID48L2tlbmRvLWNoZWNrYm94PlxuICAgICAgICAgICAgICAgIDxzcGFuIGtlbmRvVHJlZVZpZXdJdGVtQ29udGVudFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLXRyZWVpbmRleF09XCJub2RlSW5kZXgoaW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgICAgW2RhdGFJdGVtXT1cIm5vZGVcIlxuICAgICAgICAgICAgICAgICAgICBbaW5kZXhdPVwibm9kZUluZGV4KGluZGV4KVwiXG4gICAgICAgICAgICAgICAgICAgIFtpbml0aWFsU2VsZWN0aW9uXT1cImlzU2VsZWN0ZWQobm9kZSwgbm9kZUluZGV4KGluZGV4KSlcIlxuICAgICAgICAgICAgICAgICAgICBbaXNTZWxlY3RlZF09XCJpc1NlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLXRyZWV2aWV3LWxlYWZcIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUudG91Y2gtYWN0aW9uXT1cInRvdWNoQWN0aW9ucyA/ICcnIDogJ25vbmUnXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay10cmVldmlldy1sZWFmLXRleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nU3dpdGNoXT1cImhhc1RlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdTd2l0Y2hDYXNlPVwidHJ1ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm5vZGVUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbXBsaWNpdDogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogbm9kZUluZGV4KGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1N3aXRjaERlZmF1bHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7bm9kZVRleHQobm9kZSl9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDx1bFxuICAgICAgICAgICAgICAgICpuZ0lmPVwiaXNFeHBhbmRlZChub2RlLCBub2RlSW5kZXgoaW5kZXgpKSAmJiBoYXNDaGlsZHJlbihub2RlKVwiXG4gICAgICAgICAgICAgICAga2VuZG9UcmVlVmlld0dyb3VwXG4gICAgICAgICAgICAgICAgcm9sZT1cImdyb3VwXCJcbiAgICAgICAgICAgICAgICBbbm9kZXNdPVwiZmV0Y2hDaGlsZHJlblwiXG4gICAgICAgICAgICAgICAgW2xvYWRPbkRlbWFuZF09XCJsb2FkT25EZW1hbmRcIlxuICAgICAgICAgICAgICAgIFtjaGVja2JveGVzXT1cImNoZWNrYm94ZXNcIlxuICAgICAgICAgICAgICAgIFtleHBhbmRJY29uc109XCJleHBhbmRJY29uc1wiXG4gICAgICAgICAgICAgICAgW3NlbGVjdGFibGVdPVwic2VsZWN0YWJsZVwiXG4gICAgICAgICAgICAgICAgW3RvdWNoQWN0aW9uc109XCJ0b3VjaEFjdGlvbnNcIlxuICAgICAgICAgICAgICAgIFtjaGlsZHJlbl09XCJjaGlsZHJlblwiXG4gICAgICAgICAgICAgICAgW2hhc0NoaWxkcmVuXT1cImhhc0NoaWxkcmVuXCJcbiAgICAgICAgICAgICAgICBbaXNDaGVja2VkXT1cImlzQ2hlY2tlZFwiXG4gICAgICAgICAgICAgICAgW2lzRGlzYWJsZWRdPVwiaXNEaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkIHx8IGlzRGlzYWJsZWQobm9kZSwgbm9kZUluZGV4KGluZGV4KSlcIlxuICAgICAgICAgICAgICAgIFtpc0V4cGFuZGVkXT1cImlzRXhwYW5kZWRcIlxuICAgICAgICAgICAgICAgIFtpc1NlbGVjdGVkXT1cImlzU2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgIFtpc1Zpc2libGVdPVwiaXNWaXNpYmxlXCJcbiAgICAgICAgICAgICAgICBbbm9kZVRlbXBsYXRlUmVmXT1cIm5vZGVUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgW2xvYWRNb3JlQnV0dG9uVGVtcGxhdGVSZWZdPVwibG9hZE1vcmVCdXR0b25UZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgW3BhcmVudEluZGV4XT1cIm5vZGVJbmRleChpbmRleClcIlxuICAgICAgICAgICAgICAgIFtwYXJlbnREYXRhSXRlbV09XCJub2RlXCJcbiAgICAgICAgICAgICAgICBbdGV4dEZpZWxkXT1cIm5leHRGaWVsZHNcIlxuICAgICAgICAgICAgICAgIFtsb2FkTW9yZVNlcnZpY2VdPVwibG9hZE1vcmVTZXJ2aWNlXCJcbiAgICAgICAgICAgICAgICBbQHRvZ2dsZV09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBbdHJhY2tCeV09XCJ0cmFja0J5XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvbGk+XG4gICAgICAgIDxsaVxuICAgICAgICAgICAgKm5nSWY9XCJpbml0aWFsTm9kZXNMb2FkZWQgJiYgbW9yZU5vZGVzQXZhaWxhYmxlXCJcbiAgICAgICAgICAgIGNsYXNzPVwiay10cmVldmlldy1pdGVtXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLXRyZWV2aWV3LWxvYWQtbW9yZS1jaGVja2JveGVzLWNvbnRhaW5lcl09XCJjaGVja2JveGVzXCJcbiAgICAgICAgICAgIGtlbmRvVHJlZVZpZXdJdGVtXG4gICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIFtzZWxlY3RhYmxlXT1cImZhbHNlXCJcbiAgICAgICAgICAgIFtjaGVja2FibGVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgW2V4cGFuZGFibGVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgW2luZGV4XT1cImxvYWRNb3JlQnV0dG9uSW5kZXhcIlxuICAgICAgICAgICAgW3BhcmVudERhdGFJdGVtXT1cInBhcmVudERhdGFJdGVtXCJcbiAgICAgICAgICAgIFtwYXJlbnRJbmRleF09XCJwYXJlbnRJbmRleFwiXG4gICAgICAgICAgICBbYXR0ci5kYXRhLXRyZWVpbmRleF09XCJsb2FkTW9yZUJ1dHRvbkluZGV4XCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstdHJlZXZpZXctbWlkXCI+XG4gICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJsb2FkaW5nTW9yZU5vZGVzXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWljb24gay1pLWxvYWRpbmcgay1pLWV4cGFuZFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstdHJlZXZpZXctbGVhZiBrLXRyZWV2aWV3LWxvYWQtbW9yZS1idXR0b25cIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLXRyZWVpbmRleF09XCJsb2FkTW9yZUJ1dHRvbkluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAga2VuZG9UcmVlVmlld0l0ZW1Db250ZW50XG4gICAgICAgICAgICAgICAgICAgIFtpbmRleF09XCJsb2FkTW9yZUJ1dHRvbkluZGV4XCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay10cmVldmlldy1sZWFmLXRleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwibG9hZE1vcmVCdXR0b25UZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwibG9hZE1vcmVCdXR0b25UZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGxvYWRNb3JlQnV0dG9uSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWxvYWRNb3JlQnV0dG9uVGVtcGxhdGVSZWZcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2FkIG1vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbGk+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRXhwYW5kU3RhdGVTZXJ2aWNlLFxuICAgICAgICBMb2FkaW5nTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICAgICAgSW5kZXhCdWlsZGVyU2VydmljZSxcbiAgICAgICAgVHJlZVZpZXdMb29rdXBTZXJ2aWNlLFxuICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgTm9kZUNoaWxkcmVuU2VydmljZSxcbiAgICAgICAgRGF0YUNoYW5nZU5vdGlmaWNhdGlvblNlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmXSlcbl0sIFRyZWVWaWV3R3JvdXBDb21wb25lbnQpO1xuXG5jb25zdCBpbmRleENoZWNrZWQgPSAoa2V5cywgaW5kZXgpID0+IGtleXMuZmlsdGVyKGsgPT4gayA9PT0gaW5kZXgpLmxlbmd0aCA+IDA7XG5jb25zdCBtYXRjaEtleSA9IGluZGV4ID0+IGsgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gaykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFrLnNwbGl0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGsuc3BsaXQoJ18nKS5yZWR1Y2UoKHsga2V5LCByZXN1bHQgfSwgcGFydCkgPT4ge1xuICAgICAgICBrZXkgKz0gcGFydDtcbiAgICAgICAgaWYgKGluZGV4ID09PSBrZXkgfHwgcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgKz0gXCJfXCI7XG4gICAgICAgIHJldHVybiB7IGtleSwgcmVzdWx0OiBmYWxzZSB9O1xuICAgIH0sIHsga2V5OiBcIlwiLCByZXN1bHQ6IGZhbHNlIH0pLnJlc3VsdDtcbn07XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIG1hbmFnZXMgdGhlIGluLW1lbW9yeSBjaGVja2VkIHN0YXRlIG9mIHRoZSBUcmVlVmlldyBub2RlXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNoZWNrYm94ZXNfdHJlZXZpZXcgJX0pKS5cbiAqL1xubGV0IENoZWNrRGlyZWN0aXZlID0gY2xhc3MgQ2hlY2tEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRyZWVWaWV3LCB6b25lKSB7XG4gICAgICAgIHRoaXMudHJlZVZpZXcgPSB0cmVlVmlldztcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGBjaGVja2VkS2V5c2AgY29sbGVjdGlvbiB3YXMgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tlZEtleXNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5jaGVja0FjdGlvbnMgPSB7XG4gICAgICAgICAgICAnbXVsdGlwbGUnOiAoZSkgPT4gdGhpcy5jaGVja011bHRpcGxlKGUpLFxuICAgICAgICAgICAgJ3NpbmdsZSc6IChlKSA9PiB0aGlzLmNoZWNrU2luZ2xlKGUpXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZsZWN0ZXMgdGhlIGludGVybmFsIGBjaGVja2VkS2V5c2Agc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudHJlZVZpZXcuY2hlY2tlZENoYW5nZVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZSkgPT4gdGhpcy5jaGVjayhlKSkpO1xuICAgICAgICBsZXQgZXhwYW5kZWRJdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudHJlZVZpZXcuY2hpbGRyZW5Mb2FkZWRcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLm9wdGlvbnMuY2hlY2tDaGlsZHJlbiAmJiB0aGlzLnRyZWVWaWV3LmxvYWRPbkRlbWFuZCksIHRhcChpdGVtID0+IGV4cGFuZGVkSXRlbXMucHVzaChpdGVtKSksIHN3aXRjaE1hcCgoKSA9PiB0aGlzLnpvbmUub25TdGFibGUucGlwZSh0YWtlKDEpKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuYWRkQ2hlY2tlZEl0ZW1zQ2hpbGRyZW4oZXhwYW5kZWRJdGVtcykpKTtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc0NoZWNrZWQgPSB0aGlzLmlzSXRlbUNoZWNrZWQuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBpc0NoZWNrZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc0NoZWNrZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgY2hlY2tDaGlsZHJlbjogdHJ1ZSxcbiAgICAgICAgICAgIGNoZWNrUGFyZW50czogdHJ1ZSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBtb2RlOiBcIm11bHRpcGxlXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5jaGVja2FibGUpIHx8IHR5cGVvZiB0aGlzLmNoZWNrYWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja1NldHRpbmdzID0gaXNCb29sZWFuKHRoaXMuY2hlY2thYmxlKVxuICAgICAgICAgICAgPyB7IGVuYWJsZWQ6IHRoaXMuY2hlY2thYmxlIH1cbiAgICAgICAgICAgIDogdGhpcy5jaGVja2FibGU7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBjaGVja1NldHRpbmdzKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5jaGVja2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZVZpZXcuY2hlY2tib3hlcyA9IHRoaXMub3B0aW9ucy5lbmFibGVkO1xuICAgICAgICAgICAgdGhpcy50b2dnbGVDaGVja09uQ2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdjaGVja2VkS2V5cycsIGNoYW5nZXMsIGZhbHNlKSAmJiBjaGFuZ2VzLmNoZWNrZWRLZXlzLmN1cnJlbnRWYWx1ZSAhPT0gdGhpcy5sYXN0Q2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFNldChjaGFuZ2VzLmNoZWNrZWRLZXlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2xpY2soKTtcbiAgICB9XG4gICAgaXNJdGVtQ2hlY2tlZChkYXRhSXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0luZGV4Q2hlY2tlZChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzS2V5ID0gdGhpcy5zdGF0ZS5oYXModGhpcy5pdGVtS2V5KHsgZGF0YUl0ZW0sIGluZGV4IH0pKTtcbiAgICAgICAgcmV0dXJuIGhhc0tleSA/ICdjaGVja2VkJyA6ICdub25lJztcbiAgICB9XG4gICAgaXNJbmRleENoZWNrZWQoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZEtleXMgPSBBcnJheS5mcm9tKHRoaXMuc3RhdGUpLmZpbHRlcihtYXRjaEtleShpbmRleCkpO1xuICAgICAgICBpZiAoaW5kZXhDaGVja2VkKGNoZWNrZWRLZXlzLCBpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnY2hlY2tlZCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBtb2RlLCBjaGVja1BhcmVudHMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG1vZGUgPT09ICdtdWx0aXBsZScgJiYgY2hlY2tQYXJlbnRzICYmIGNoZWNrZWRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICdpbmRldGVybWluYXRlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgIH1cbiAgICBpdGVtS2V5KGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5jaGVja0tleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jaGVja0tleSA9PT0gXCJzdHJpbmdcIiAmJiBpc1ByZXNlbnQoaXRlbS5kYXRhSXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRhdGFJdGVtW3RoaXMuY2hlY2tLZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jaGVja0tleSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja0tleShpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVjayhlKSB7XG4gICAgICAgIGNvbnN0IHsgZW5hYmxlZCwgbW9kZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBwZXJmb3JtU2VsZWN0aW9uID0gdGhpcy5jaGVja0FjdGlvbnNbbW9kZV0gfHwgbm9vcDtcbiAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGVyZm9ybVNlbGVjdGlvbihlKTtcbiAgICB9XG4gICAgY2hlY2tTaW5nbGUobm9kZSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLml0ZW1LZXkobm9kZS5pdGVtKTtcbiAgICAgICAgY29uc3QgaGFzS2V5ID0gdGhpcy5zdGF0ZS5oYXMoa2V5KTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jbGVhcigpO1xuICAgICAgICBpZiAoIWhhc0tleSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgICBjaGVja011bHRpcGxlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja05vZGUobm9kZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2hlY2tQYXJlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUGFyZW50cyhub2RlLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICB9XG4gICAgdG9nZ2xlQ2hlY2tPbkNsaWNrKCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2xpY2soKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jaGVja09uQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuY2xpY2tTdWJzY3JpcHRpb24gPSB0aGlzLnRyZWVWaWV3Lm5vZGVDbGljay5zdWJzY3JpYmUoYXJncyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29rdXAgPSB0aGlzLnRyZWVWaWV3Lml0ZW1Mb29rdXAoYXJncy5pdGVtLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVjayhsb29rdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWNrU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmNsaWNrU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja05vZGUobm9kZSkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChub2RlLml0ZW0uZGF0YUl0ZW0pIHx8IHRoaXMudHJlZVZpZXcuaXNEaXNhYmxlZChub2RlLml0ZW0uZGF0YUl0ZW0sIG5vZGUuaXRlbS5pbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50S2V5ID0gdGhpcy5pdGVtS2V5KG5vZGUuaXRlbSk7XG4gICAgICAgIGlmICghaXNQcmVzZW50KGN1cnJlbnRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVuZGluZ0NoZWNrID0gW2N1cnJlbnRLZXldO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNoZWNrQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NlbmRhbnRzID0gZmV0Y2hMb2FkZWREZXNjZW5kYW50cyhub2RlLCAoeyBpdGVtIH0pID0+IHRoaXMudHJlZVZpZXcuaXNWaXNpYmxlKGl0ZW0uZGF0YUl0ZW0sIGl0ZW0uaW5kZXgpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMudHJlZVZpZXcuaXNEaXNhYmxlZChpdGVtLmRhdGFJdGVtLCBpdGVtLmluZGV4KSlcbiAgICAgICAgICAgICAgICAubWFwKCh7IGl0ZW0gfSkgPT4gdGhpcy5pdGVtS2V5KGl0ZW0pKTtcbiAgICAgICAgICAgIHBlbmRpbmdDaGVjay5wdXNoKC4uLmRlc2NlbmRhbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG91bGRDaGVjayA9ICF0aGlzLnN0YXRlLmhhcyhjdXJyZW50S2V5KTtcbiAgICAgICAgcGVuZGluZ0NoZWNrLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRDaGVjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hlY2tQYXJlbnRzKHBhcmVudCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSB0aGlzLml0ZW1LZXkoY3VycmVudFBhcmVudC5pdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuLmV2ZXJ5KGl0ZW0gPT4gdGhpcy5zdGF0ZS5oYXModGhpcy5pdGVtS2V5KGl0ZW0pKSk7XG4gICAgICAgICAgICBpZiAoYWxsQ2hpbGRyZW5TZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuYWRkKHBhcmVudEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRlbGV0ZShwYXJlbnRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlKTtcbiAgICAgICAgdGhpcy5jaGVja2VkS2V5c0NoYW5nZS5lbWl0KHRoaXMubGFzdENoYW5nZSk7XG4gICAgfVxuICAgIGFkZENoZWNrZWRJdGVtc0NoaWxkcmVuKGxvb2t1cHMpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQobG9va3VwcykgfHwgbG9va3Vwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0aWFsbHlDaGVja2VkSXRlbXNDb3VudCA9IHRoaXMuc3RhdGUuc2l6ZTtcbiAgICAgICAgbG9va3Vwcy5mb3JFYWNoKGxvb2t1cCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtS2V5ID0gdGhpcy5pdGVtS2V5KGxvb2t1cC5pdGVtKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5oYXMoaXRlbUtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb29rdXAuY2hpbGRyZW4uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgYm90aCB0aGUgcGFyZW50IGl0ZW0gYW5kIGVhY2ggY2hpbGQgbm9kZSBpcyBlbmFibGVkXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRyZWVWaWV3LmlzRGlzYWJsZWQobG9va3VwLml0ZW0uZGF0YUl0ZW0sIGxvb2t1cC5pdGVtLmluZGV4KSAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy50cmVlVmlldy5pc0Rpc2FibGVkKGl0ZW0uZGF0YUl0ZW0sIGl0ZW0uaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuYWRkKHRoaXMuaXRlbUtleShpdGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYXNOZXdseUNoZWNrZWRJdGVtcyA9IGluaXRpYWxseUNoZWNrZWRJdGVtc0NvdW50ICE9PSB0aGlzLnN0YXRlLnNpemU7XG4gICAgICAgIGlmIChoYXNOZXdseUNoZWNrZWRJdGVtcykge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLm5vdGlmeSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGdW5jdGlvbl0pXG5dLCBDaGVja0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNDaGVja2VkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoXCJjaGVja0J5XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGVja0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2hlY2tLZXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgQ2hlY2tEaXJlY3RpdmUucHJvdG90eXBlLCBcImNoZWNrZWRLZXlzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgna2VuZG9UcmVlVmlld0NoZWNrYWJsZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGVja0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2hlY2thYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hlY2tEaXJlY3RpdmUucHJvdG90eXBlLCBcImNoZWNrZWRLZXlzQ2hhbmdlXCIsIHZvaWQgMCk7XG5DaGVja0RpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdDaGVja2FibGVdJyB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RyZWVWaWV3Q29tcG9uZW50LFxuICAgICAgICBOZ1pvbmVdKVxuXSwgQ2hlY2tEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIG1hbmFnZXMgdGhlIGRpc2FibGVkIGluLW1lbW9yeSBzdGF0ZSBvZiB0aGUgVHJlZVZpZXcgbm9kZVxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZHN0YXRlX3RyZWV2aWV3ICV9KSkuXG4gKi9cbmxldCBEaXNhYmxlRGlyZWN0aXZlID0gY2xhc3MgRGlzYWJsZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodHJlZVZpZXcsIGNkcikge1xuICAgICAgICB0aGlzLnRyZWVWaWV3ID0gdHJlZVZpZXc7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgY29sbGVjdGlvbiB0aGF0IHdpbGwgc3RvcmUgdGhlIGRpc2FibGVkIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWVWaWV3LmlzRGlzYWJsZWQgPSAoZGF0YUl0ZW0sIGluZGV4KSA9PiAodGhpcy5kaXNhYmxlZEtleXMuaW5kZXhPZih0aGlzLml0ZW1LZXkoeyBkYXRhSXRlbSwgaW5kZXggfSkpID4gLTEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGlzRGlzYWJsZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc0Rpc2FibGVkID0gdmFsdWU7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGRpc2FibGVkS2V5cyB9ID0gY2hhbmdlcztcbiAgICAgICAgaWYgKGRpc2FibGVkS2V5cyAmJiAhZGlzYWJsZWRLZXlzLmZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpdGVtS2V5KGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXNhYmxlS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5kYXRhSXRlbVt0aGlzLmRpc2FibGVLZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXNhYmxlS2V5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVLZXkoZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRnVuY3Rpb25dKVxuXSwgRGlzYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNEaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KFwia2VuZG9UcmVlVmlld0Rpc2FibGVcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERpc2FibGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImRpc2FibGVLZXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgRGlzYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRLZXlzXCIsIHZvaWQgMCk7XG5EaXNhYmxlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0Rpc2FibGVdJyB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RyZWVWaWV3Q29tcG9uZW50LFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBEaXNhYmxlRGlyZWN0aXZlKTtcblxuY29uc3QgREVGQVVMVF9GSUxURVJfRVhQQU5EX1NFVFRJTkdTID0ge1xuICAgIG1heEF1dG9FeHBhbmRSZXN1bHRzOiAtMSxcbiAgICBleHBhbmRNYXRjaGVzOiBmYWxzZSxcbiAgICBleHBhbmRlZE9uQ2xlYXI6IFwibm9uZVwiXG59O1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBtYW5hZ2VzIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgVHJlZVZpZXcuXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGV4cGFuZGVkc3RhdGVfdHJlZXZpZXcgJX0pKS5cbiAqL1xubGV0IEV4cGFuZERpcmVjdGl2ZSA9IGNsYXNzIEV4cGFuZERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gYXV0by1leHBhbmQgdGhlIG5vZGVzIGxlYWRpbmcgZnJvbSB0aGUgcm9vdCBub2RlIHRvIGVhY2ggZmlsdGVyIHJlc3VsdC5cbiAgICAgICAgICogVG8gZmluZS10dW5lIHRoaXMgYmVoYXZpb3IsIHBhc3MgYSBbYEZpbHRlckV4cGFuZFNldHRpbmdzYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfZmlsdGVyZXhwYW5kc2V0dGluZ3MgJX0pIG9iamVjdCB0byB0aGlzIGlucHV0LlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmRPbkZpbHRlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYGV4cGFuZGVkS2V5c2AgY29sbGVjdGlvbiB3YXMgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWRLZXlzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZsZWN0ZXMgdGhlIGludGVybmFsIGBleHBhbmRlZEtleXNgIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV4cGFuZGVkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5pc0ZpbHRlcmVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWxscyBhcnJheSB3aXRoIHRoZSBjb3JyZWN0IGV4cGFuZCBrZXlzIGFjY29yZGluZyB0byB3cmFwcGVyIG1ldGFkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVFeHBhbmRlZE5vZGVzID0gKGNvbGxlY3Rpb24sIG5vZGUsIGF1dG9FeHBhbmRNYXRjaGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250YWluc01hdGNoZXMgfHwgbm9kZS5pc01hdGNoICYmIGF1dG9FeHBhbmRNYXRjaGVzICYmIGlzQXJyYXlXaXRoQXRMZWFzdE9uZUl0ZW0obm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2godGhpcy5pdGVtS2V5KHsgZGF0YUl0ZW06IG5vZGUuZGF0YUl0ZW0sIGluZGV4OiBub2RlLmluZGV4IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5V2l0aEF0TGVhc3RPbmVJdGVtKG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHBhbmRlZE5vZGVzKGNvbGxlY3Rpb24sIGNoaWxkLCBhdXRvRXhwYW5kTWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWxscyBhcnJheSB3aXRoIHRoZSBleHBhbmQga2V5IG9mIGV2ZXJ5IG5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEV2ZXJ5RXhwYW5kS2V5ID0gKGNvbGxlY3Rpb24sIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5V2l0aEF0TGVhc3RPbmVJdGVtKG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKHRoaXMuaXRlbUtleSh7IGRhdGFJdGVtOiBub2RlLmRhdGFJdGVtLCBpbmRleDogbm9kZS5pbmRleCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNBcnJheVdpdGhBdExlYXN0T25lSXRlbShub2RlLmNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RXZlcnlFeHBhbmRLZXkoY29sbGVjdGlvbiwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKG1lcmdlKHRoaXMuY29tcG9uZW50LmV4cGFuZC5waXBlKG1hcChlID0+IChPYmplY3QuYXNzaWduKHsgZXhwYW5kOiB0cnVlIH0sIGUpKSkpLCB0aGlzLmNvbXBvbmVudC5jb2xsYXBzZS5waXBlKG1hcChlID0+IChPYmplY3QuYXNzaWduKHsgZXhwYW5kOiBmYWxzZSB9LCBlKSkpKSkuc3Vic2NyaWJlKHRoaXMudG9nZ2xlRXhwYW5kLmJpbmQodGhpcykpKTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmZpbHRlclN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuY29tcG9uZW50LmZpbHRlclN0YXRlQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUF1dG9FeHBhbmQuYmluZCh0aGlzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmlzRXhwYW5kZWQgPSAoZGF0YUl0ZW0sIGluZGV4KSA9PiB0aGlzLnN0YXRlLmhhcyh0aGlzLml0ZW1LZXkoeyBkYXRhSXRlbSwgaW5kZXggfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGlzRXhwYW5kZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuaXNFeHBhbmRlZCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZmlsdGVyRXhwYW5kU2V0dGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gaXNCb29sZWFuKHRoaXMuZXhwYW5kT25GaWx0ZXIpID8geyBlbmFibGVkOiB0aGlzLmV4cGFuZE9uRmlsdGVyIH0gOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmV4cGFuZE9uRmlsdGVyLCB7IGVuYWJsZWQ6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0ZJTFRFUl9FWFBBTkRfU0VUVElOR1MsIHNldHRpbmdzKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdleHBhbmRlZEtleXMnLCBjaGFuZ2VzLCBmYWxzZSkgJiYgY2hhbmdlcy5leHBhbmRlZEtleXMuY3VycmVudFZhbHVlICE9PSB0aGlzLmxhc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgU2V0KGNoYW5nZXMuZXhwYW5kZWRLZXlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaXRlbUtleShlKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZEtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmV4cGFuZEtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmRhdGFJdGVtW3RoaXMuZXhwYW5kS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5leHBhbmRLZXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZEtleShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5pbmRleDtcbiAgICB9XG4gICAgdG9nZ2xlRXhwYW5kKHsgaW5kZXgsIGRhdGFJdGVtLCBleHBhbmQgfSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLml0ZW1LZXkoeyBpbmRleCwgZGF0YUl0ZW0gfSk7XG4gICAgICAgIGNvbnN0IGlzRXhwYW5kZWQgPSB0aGlzLnN0YXRlLmhhcyhrZXkpO1xuICAgICAgICBsZXQgbm90aWZ5ID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0V4cGFuZGVkICYmICFleHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBub3RpZnkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0V4cGFuZGVkICYmIGV4cGFuZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5hZGQoa2V5KTtcbiAgICAgICAgICAgIG5vdGlmeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVBdXRvRXhwYW5kKHsgbm9kZXMsIG1hdGNoQ291bnQsIHRlcm0gfSkge1xuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyRXhwYW5kU2V0dGluZ3MuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbWF4QXV0b0V4cGFuZFJlc3VsdHMsIGV4cGFuZE1hdGNoZXM6IGF1dG9FeHBhbmRNYXRjaGVzLCBleHBhbmRlZE9uQ2xlYXIgfSA9IHRoaXMuZmlsdGVyRXhwYW5kU2V0dGluZ3M7XG4gICAgICAgIGlmICghdGhpcy5pc0ZpbHRlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRXhwYW5kZWRLZXlzID0gbmV3IFNldCh0aGlzLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGl0aW5nRmlsdGVyZWRTdGF0ZSA9IHRoaXMuaXNGaWx0ZXJlZCAmJiAhdGVybTtcbiAgICAgICAgY29uc3QgbWF4RXhjZWVkZWQgPSBtYXhBdXRvRXhwYW5kUmVzdWx0cyAhPT0gLTEgJiYgbWF0Y2hDb3VudCA+IG1heEF1dG9FeHBhbmRSZXN1bHRzO1xuICAgICAgICBjb25zdCBleGl0QXV0b0V4cGFuZGVkU3RhdGUgPSBleGl0aW5nRmlsdGVyZWRTdGF0ZSB8fCBtYXhFeGNlZWRlZDtcbiAgICAgICAgaWYgKGV4aXRBdXRvRXhwYW5kZWRTdGF0ZSkge1xuICAgICAgICAgICAgc3dpdGNoIChleHBhbmRlZE9uQ2xlYXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5pdGlhbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2FtZVZhbHVlcyh0aGlzLnN0YXRlLCB0aGlzLm9yaWdpbmFsRXhwYW5kZWRLZXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMub3JpZ2luYWxFeHBhbmRlZEtleXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiYWxsXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBTZXQobm9kZXMucmVkdWNlKChhY2MsIHJvb3ROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEV2ZXJ5RXhwYW5kS2V5KGFjYywgcm9vdE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICAgICAgfSwgW10pKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmNoYW5nZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnNpemUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc0ZpbHRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kaWNlc1RvRXhwYW5kID0gbmV3IFNldChub2Rlcy5yZWR1Y2UoKGFjYywgcm9vdE5vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRXhwYW5kZWROb2RlcyhhY2MsIHJvb3ROb2RlLCBhdXRvRXhwYW5kTWF0Y2hlcyk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSkpO1xuICAgICAgICBpZiAoIXNhbWVWYWx1ZXModGhpcy5zdGF0ZSwgaW5kaWNlc1RvRXhwYW5kKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGluZGljZXNUb0V4cGFuZDtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ZpbHRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbm90aWZ5KCkge1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSBBcnJheS5mcm9tKHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLmV4cGFuZGVkS2V5c0NoYW5nZS5lbWl0KHRoaXMubGFzdENoYW5nZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Z1bmN0aW9uXSlcbl0sIEV4cGFuZERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNFeHBhbmRlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KFwiZXhwYW5kQnlcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEV4cGFuZERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXhwYW5kS2V5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBFeHBhbmREaXJlY3RpdmUucHJvdG90eXBlLCBcImV4cGFuZE9uRmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRXhwYW5kRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJleHBhbmRlZEtleXNDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgRXhwYW5kRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJleHBhbmRlZEtleXNcIiwgdm9pZCAwKTtcbkV4cGFuZERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdFeHBhbmRhYmxlXScgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFeHBhbmRhYmxlQ29tcG9uZW50XSlcbl0sIEV4cGFuZERpcmVjdGl2ZSk7XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbWFuYWdlcyB0aGUgaW4tbWVtb3J5IHNlbGVjdGlvbiBzdGF0ZSBvZiB0aGUgVHJlZVZpZXcgbm9kZVxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzZWxlY3Rpb25fdHJlZXZpZXcgJX0pKS5cbiAqL1xubGV0IFNlbGVjdERpcmVjdGl2ZSA9IGNsYXNzIFNlbGVjdERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodHJlZVZpZXcpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldyA9IHRyZWVWaWV3O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYHNlbGVjdGVkS2V5c2AgY29sbGVjdGlvbiB3YXMgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0QWN0aW9ucyA9IHtcbiAgICAgICAgICAgICdtdWx0aXBsZSc6IChlKSA9PiB0aGlzLnNlbGVjdE11bHRpcGxlKGUpLFxuICAgICAgICAgICAgJ3NpbmdsZSc6IChlKSA9PiB0aGlzLnNlbGVjdFNpbmdsZShlKVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmbGVjdGVzIHRoZSBpbnRlcm5hbCBgc2VsZWN0ZWRLZXlzYCBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy50cmVlVmlldy5zZWxlY3Rpb25DaGFuZ2Uuc3Vic2NyaWJlKHRoaXMuc2VsZWN0LmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc1NlbGVjdGVkID0gKGRhdGFJdGVtLCBpbmRleCkgPT4gKHRoaXMuc3RhdGUuaGFzKHRoaXMuaXRlbUtleSh7IGRhdGFJdGVtLCBpbmRleCB9KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGlzU2VsZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc1NlbGVjdGVkID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBnZXRBcmlhTXVsdGlzZWxlY3RhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1vZGUgPT09ICdtdWx0aXBsZSc7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBtb2RlOiAnc2luZ2xlJ1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnNlbGVjdGlvbikgfHwgdHlwZW9mIHRoaXMuc2VsZWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblNldHRpbmdzID0gaXNCb29sZWFuKHRoaXMuc2VsZWN0aW9uKSA/IHsgZW5hYmxlZDogdGhpcy5zZWxlY3Rpb24gfSA6IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgc2VsZWN0aW9uU2V0dGluZ3MpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ3NlbGVjdGVkS2V5cycsIGNoYW5nZXMsIGZhbHNlKSAmJiBjaGFuZ2VzLnNlbGVjdGVkS2V5cy5jdXJyZW50VmFsdWUgIT09IHRoaXMubGFzdENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBTZXQoY2hhbmdlcy5zZWxlY3RlZEtleXMuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGl0ZW1LZXkoZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2VsZWN0S2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGUuZGF0YUl0ZW1bdGhpcy5zZWxlY3RLZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zZWxlY3RLZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdEtleShlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3QoZSkge1xuICAgICAgICBjb25zdCB7IGVuYWJsZWQsIG1vZGUgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgcGVyZm9ybVNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0QWN0aW9uc1ttb2RlXSB8fCBub29wO1xuICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwZXJmb3JtU2VsZWN0aW9uKGUpO1xuICAgIH1cbiAgICBzZWxlY3RTaW5nbGUobm9kZSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLml0ZW1LZXkobm9kZSk7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5hZGQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0TXVsdGlwbGUobm9kZSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLml0ZW1LZXkobm9kZSk7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSB0aGlzLnN0YXRlLmhhcyhrZXkpO1xuICAgICAgICBpZiAoIWlzUHJlc2VudChrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgfVxuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEtleXNDaGFuZ2UuZW1pdCh0aGlzLmxhc3RDaGFuZ2UpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtGdW5jdGlvbl0pXG5dLCBTZWxlY3REaXJlY3RpdmUucHJvdG90eXBlLCBcImlzU2VsZWN0ZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnc2VsZWN0QnknKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VsZWN0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzZWxlY3RLZXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdrZW5kb1RyZWVWaWV3U2VsZWN0YWJsZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZWxlY3REaXJlY3RpdmUucHJvdG90eXBlLCBcInNlbGVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBTZWxlY3REaXJlY3RpdmUucHJvdG90eXBlLCBcInNlbGVjdGVkS2V5c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFNlbGVjdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2VsZWN0ZWRLZXlzQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLW11bHRpc2VsZWN0YWJsZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBTZWxlY3REaXJlY3RpdmUucHJvdG90eXBlLCBcImdldEFyaWFNdWx0aXNlbGVjdGFibGVcIiwgbnVsbCk7XG5TZWxlY3REaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3U2VsZWN0YWJsZV0nIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVHJlZVZpZXdDb21wb25lbnRdKVxuXSwgU2VsZWN0RGlyZWN0aXZlKTtcblxuLyoqXG4gKiBEZXNjcmliZXMgdGhlIGF0dGVtcHRlZCBkcm9wIGFjdGlvbiBkdXJpbmcgZHJhZ2dpbmcuXG4gKiBQYXNzZWQgYXMgYGFjdGlvbmAgdmFsdWUgdG8gdGhlIFtga2VuZG9UcmVlVmlld0RyYWdDbHVlVGVtcGxhdGVgXSh7JSBzbHVnIGFwaV90cmVldmlld19kcmFnY2x1ZXRlbXBsYXRlZGlyZWN0aXZlICV9KSBkaXJlY3RpdmUuXG4gKiBCeSBkZWZhdWx0LCB0aGlzIHZhbHVlIGRlZmluZXMgdGhlIHJlbmRlcmVkIGljb24gaW4gdGhlIGRyYWcgY2x1ZS5cbiAqL1xudmFyIERyb3BBY3Rpb247XG4oZnVuY3Rpb24gKERyb3BBY3Rpb24pIHtcbiAgICBEcm9wQWN0aW9uW0Ryb3BBY3Rpb25bXCJBZGRcIl0gPSAwXSA9IFwiQWRkXCI7XG4gICAgRHJvcEFjdGlvbltEcm9wQWN0aW9uW1wiSW5zZXJ0VG9wXCJdID0gMV0gPSBcIkluc2VydFRvcFwiO1xuICAgIERyb3BBY3Rpb25bRHJvcEFjdGlvbltcIkluc2VydEJvdHRvbVwiXSA9IDJdID0gXCJJbnNlcnRCb3R0b21cIjtcbiAgICBEcm9wQWN0aW9uW0Ryb3BBY3Rpb25bXCJJbnNlcnRNaWRkbGVcIl0gPSAzXSA9IFwiSW5zZXJ0TWlkZGxlXCI7XG4gICAgRHJvcEFjdGlvbltEcm9wQWN0aW9uW1wiSW52YWxpZFwiXSA9IDRdID0gXCJJbnZhbGlkXCI7XG59KShEcm9wQWN0aW9uIHx8IChEcm9wQWN0aW9uID0ge30pKTtcblxuLyoqXG4gKiBEZXNjcmliZXMgd2hlcmUgdGhlIGRyYWdnZWQgaXRlbSBpcyBkcm9wcGVkIHJlbGF0aXZlIHRvIHRoZSBkcm9wIHRhcmdldCBpdGVtLlxuICovXG52YXIgRHJvcFBvc2l0aW9uO1xuKGZ1bmN0aW9uIChEcm9wUG9zaXRpb24pIHtcbiAgICBEcm9wUG9zaXRpb25bRHJvcFBvc2l0aW9uW1wiT3ZlclwiXSA9IDBdID0gXCJPdmVyXCI7XG4gICAgRHJvcFBvc2l0aW9uW0Ryb3BQb3NpdGlvbltcIkJlZm9yZVwiXSA9IDFdID0gXCJCZWZvcmVcIjtcbiAgICBEcm9wUG9zaXRpb25bRHJvcFBvc2l0aW9uW1wiQWZ0ZXJcIl0gPSAyXSA9IFwiQWZ0ZXJcIjtcbn0pKERyb3BQb3NpdGlvbiB8fCAoRHJvcFBvc2l0aW9uID0ge30pKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBTY3JvbGxEaXJlY3Rpb247XG4oZnVuY3Rpb24gKFNjcm9sbERpcmVjdGlvbikge1xuICAgIFNjcm9sbERpcmVjdGlvbltTY3JvbGxEaXJlY3Rpb25bXCJVcFwiXSA9IC0xXSA9IFwiVXBcIjtcbiAgICBTY3JvbGxEaXJlY3Rpb25bU2Nyb2xsRGlyZWN0aW9uW1wiRG93blwiXSA9IDFdID0gXCJEb3duXCI7XG59KShTY3JvbGxEaXJlY3Rpb24gfHwgKFNjcm9sbERpcmVjdGlvbiA9IHt9KSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3NlcyB0aGUgYnVpbHQtaW4gYmVoYXZpb3IgdGhhdCBmb2xsb3dzIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgcHJldmVudGVkIGJ5IGFueSBvZiBpdHMgc3Vic2NyaWJlcnMsIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBkZWZhdWx0IGFjdGlvbiB3YXMgcHJldmVudGVkLiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgVHJlZVZpZXcgW2Bub2RlRHJvcGBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1ub2RlZHJvcCkgZXZlbnQuXG4gKi9cbmNsYXNzIFRyZWVJdGVtRHJvcEV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxpemVyLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVmFsaWQgPSB0cnVlO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGluaXRpYWxpemVyKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIGlmIHRoZSBkcm9wIGFjdGlvbiBzaG91bGQgYmUgbWFya2VkIGFzIHZhbGlkLlxuICAgICAqIElmIHNldCB0byBgZmFsc2VgLCB0aGUgW2BhZGRJdGVtYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLWFkZGl0ZW0pIGFuZFxuICAgICAqIFtgcmVtb3ZlSXRlbWBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1yZW1vdmVpdGVtKSBldmVudHMgd2lsbCBub3QgYmUgZmlyZWQgYW5kIHRoZSBkcmFnIGNsdWVcbiAgICAgKiB3aWxsIGJlIGFuaW1hdGVkIGJhY2sgdG8gdGhlIHNvdXJjZSBpdGVtIHRvIGluZGljYXRlIHRoZSBhY3Rpb24gaXMgbWFya2VkIGFzIGludmFsaWQuXG4gICAgICovXG4gICAgc2V0VmFsaWQoaXNWYWxpZCkge1xuICAgICAgICB0aGlzLmlzVmFsaWQgPSBpc1ZhbGlkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBUcmVlVmlldyBbYG5vZGVEcmFnU3RhcnRgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyYWdzdGFydCkgZXZlbnQuXG4gKi9cbmNsYXNzIFRyZWVJdGVtRHJhZ1N0YXJ0RXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbml0aWFsaXplcik7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIFRyZWVWaWV3IFtgbm9kZURyYWdgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyYWcpIGFuZFxuICogW2Bub2RlRHJhZ0VuZGBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1ub2RlZHJhZ2VuZCkgZXZlbnRzLlxuICovXG5jbGFzcyBUcmVlSXRlbURyYWdFdmVudCB7XG59XG5cbmNvbnN0IMm1MCQzID0gKCkgPT4ge1xuICAgIGlmICghKGlzRG9jdW1lbnRBdmFpbGFibGUoKSAmJiBpc1ByZXNlbnQoZG9jdW1lbnQuYm9keSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdG9wID0gMTA7XG4gICAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBwYXJlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJtYXRyaXgoMTAsIDAsIDAsIDEwLCAwLCAwKVwiO1xuICAgIHBhcmVudC5pbm5lckhUTUwgPSBgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBmaXhlZDsgdG9wOiAke3RvcH1weDtcIj5jaGlsZDwvZGl2PmA7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwYXJlbnQpO1xuICAgIGNvbnN0IGlzRGlmZmVyZW50ID0gcGFyZW50LmNoaWxkcmVuWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAhPT0gdG9wO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocGFyZW50KTtcbiAgICByZXR1cm4gaXNEaWZmZXJlbnQ7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgcmVsYXRpdmUgc3RhY2tpbmcgY29udGV4dC5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4L1RoZV9zdGFja2luZ19jb250ZXh0XG4gKi9cbmNvbnN0IGhhc1JlbGF0aXZlU3RhY2tpbmdDb250ZXh0ID0gbWVtb2l6ZSjJtTAkMyk7XG4vKipcbiAqIFN0b3JlcyB0aGUgcmVzdWx0IG9mIHRoZSBwYXNzZWQgZnVuY3Rpb24ncyBmaXJzdCBpbnZva2F0aW9uIGFuZCByZXR1cm5zIGl0IGluc3RlYWQgb2YgaW52b2tpbmcgaXQgYWdhaW4gYWZ0ZXJ3YXJkcy5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBHZXRzIHRoZSBvZmZzZXQgb2YgdGhlIHBhcmVudCBlbGVtZW50IGlmIHRoZSBsYXR0ZXIgaGFzIHRoZSBgdHJhbnNmb3JtYCBDU1MgcHJvcCBhcHBsaWVkLlxuICogVHJhbnNmb3JtZWQgcGFyZW50cyBjcmVhdGUgbmV3IHN0YWNraW5nIGNvbnRleHQgYW5kIHRoZSBgZml4ZWRgIGNoaWxkcmVuIG11c3QgYmUgcG9zaXRpb24gYmFzZWQgb24gdGhlIHRyYW5zZm9ybWVkIHBhcmVudC5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4L1RoZV9zdGFja2luZ19jb250ZXh0XG4gKlxuICogSWYgbm8gcGFyZW50IGNvbnRhaW5lciBpcyBgdHJhbnNmb3JtYC1lZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYHsgbGVmdDogMCwgdG9wOiAwIH1gO1xuICovXG5jb25zdCBnZXRDb250YWluZXJPZmZzZXQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGlmICghKGVsZW1lbnQgJiYgaGFzUmVsYXRpdmVTdGFja2luZ0NvbnRleHQoKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgfVxuICAgIGxldCBvZmZzZXRQYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgd2hpbGUgKG9mZnNldFBhcmVudCkge1xuICAgICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS50cmFuc2Zvcm0gIT09ICdub25lJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IG9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG9mZnNldFBhcmVudC5zY3JvbGxUb3BcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgdG9wOiAwIH07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldERyb3BBY3Rpb24gPSAoZHJvcFBvc2l0aW9uLCBkcm9wVGFyZ2V0KSA9PiB7XG4gICAgaWYgKCEoaXNQcmVzZW50KGRyb3BQb3NpdGlvbikgJiYgaXNQcmVzZW50KGRyb3BUYXJnZXQpKSkge1xuICAgICAgICByZXR1cm4gRHJvcEFjdGlvbi5JbnZhbGlkO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRyb3BQb3NpdGlvbikge1xuICAgICAgICBjYXNlIERyb3BQb3NpdGlvbi5PdmVyOlxuICAgICAgICAgICAgcmV0dXJuIERyb3BBY3Rpb24uQWRkO1xuICAgICAgICBjYXNlIERyb3BQb3NpdGlvbi5CZWZvcmU6XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGNsb3Nlc3ROb2RlKGRyb3BUYXJnZXQpLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpID8gRHJvcEFjdGlvbi5JbnNlcnRNaWRkbGUgOiBEcm9wQWN0aW9uLkluc2VydFRvcDtcbiAgICAgICAgY2FzZSBEcm9wUG9zaXRpb24uQWZ0ZXI6XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGNsb3Nlc3ROb2RlKGRyb3BUYXJnZXQpLm5leHRFbGVtZW50U2libGluZykgPyBEcm9wQWN0aW9uLkluc2VydE1pZGRsZSA6IERyb3BBY3Rpb24uSW5zZXJ0Qm90dG9tO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIERyb3BBY3Rpb24uSW52YWxpZDtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldERyb3BQb3NpdGlvbiA9IChkcmFnZ2VkSXRlbSwgdGFyZ2V0LCBjbGllbnRZLCB0YXJnZXRUcmVlVmlldywgY29udGFpbmVyT2Zmc2V0KSA9PiB7XG4gICAgaWYgKCEoaXNQcmVzZW50KGRyYWdnZWRJdGVtKSAmJiBpc1ByZXNlbnQodGFyZ2V0KSAmJiBpc1ByZXNlbnQodGFyZ2V0VHJlZVZpZXcpICYmIGlzUHJlc2VudChjb250YWluZXJPZmZzZXQpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHRoZSAuay10cmVldmlldy1taWQgZWxlbWVudCBzdGFydHMganVzdCBhZnRlciB0aGUgY2hlY2tib3gvZXhwYW5kIGFycm93IGFuZCBzdHJldGNoZXMgdGlsbCB0aGUgZW5kIG9mIHRoZSB0cmVldmlldyBvbiB0aGUgcmlnaHRcbiAgICBjb25zdCBpdGVtID0gY2xvc2VzdFdpdGhNYXRjaCh0YXJnZXQsICcuay10cmVldmlldy1taWQnKTtcbiAgICBpZiAoIWlzUHJlc2VudChpdGVtKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHRoZSBjb250ZW50IGVsZW1lbnQgKC5rLXRyZWV2aWV3LWxlYWY6bm90KC5rLXRyZWV2aWV3LWxvYWQtbW9yZS1idXR0b24pKSBob2xkcyBqdXN0IHRoZSB0cmVldmlldyBpdGVtIHRleHRcbiAgICBjb25zdCBjb250ZW50ID0gZ2V0Q29udGVudEVsZW1lbnQoaXRlbSk7XG4gICAgY29uc3QgdGFyZ2V0Q2hpbGRPZkRyYWdnZWRJdGVtID0gaGFzUGFyZW50KGl0ZW0sIGNsb3Nlc3ROb2RlKGRyYWdnZWRJdGVtKSk7XG4gICAgaWYgKCFpc1ByZXNlbnQoY29udGVudCkgfHwgKGNvbnRlbnQgPT09IGRyYWdnZWRJdGVtKSB8fCB0YXJnZXRDaGlsZE9mRHJhZ2dlZEl0ZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtVmlld1BvcnRDb29yZHMgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8qXG4gICAgICAgIGlmIHRoZSB1c2VyIGlzIGhvdmVyaW5nIGEgdHJlZXZpZXcgaXRlbSwgc3BsaXQgdGhlIGl0ZW0gaGVpZ2h0IGludG8gZm91ciBwYXJ0czpcbiAgICAgICAgICAgIC0gZHJvcHBpbmcgaW50byB0aGUgdG9wIHF1YXJ0ZXIgc2hvdWxkIGluc2VydCB0aGUgZHJhZ2dlZCBpdGVtIGJlZm9yZSB0aGUgZHJvcCB0YXJnZXRcbiAgICAgICAgICAgIC0gZHJvcHBpbmcgaW50byB0aGUgYm90dG9tIHF1YXJ0ZXIgc2hvdWxkIGluc2VydCB0aGUgZHJhZ2dlZCBpdGVtIGFmdGVyIHRoZSBkcm9wIHRhcmdldFxuICAgICAgICAgICAgLSBkcm9wcGluZyBpbnRvIHRoZSBzZWNvbmQgb3IgdGhpcmQgcXVhcnRlciBzaG91bGQgYWRkIHRoZSBpdGVtIGFzIGNoaWxkIG5vZGUgb2YgdGhlIGRyb3AgdGFyZ2V0XG5cbiAgICAgICAgaWYgdGhlIHVzZXIgaXMgTk9UIGhvdmVyaW5nIGEgdHJlZXZpZXcgaXRlbSAoaGUncyBkcmFnZ2luZyBzb21ld2hlcmUgb24gdGhlIHJpZ2h0KSwgc3BsaXQgdGhlIGl0ZW0gaGVpZ2h0IHRvIGp1c3QgdHdvIHBhcnRzOlxuICAgICAgICAgICAgLSBkcm9wcGluZyBzaG91bGQgaW5zZXJ0IGJlZm9yZSBvciBhZnRlclxuICAgICovXG4gICAgY29uc3QgaXRlbURpdmlzaW9uSGVpZ2h0ID0gaXRlbVZpZXdQb3J0Q29vcmRzLmhlaWdodCAvIChpc0NvbnRlbnQodGFyZ2V0KSA/IDQgOiAyKTtcbiAgICAvLyBjbGVhciBhbnkgcG9zc2libGUgY29udGFpbmVyIG9mZnNldCBjcmVhdGVkIGJ5IHBhcmVudCBlbGVtZW50cyB3aXRoIGB0cmFuc2Zvcm1gIGNzcyBwcm9wZXJ0eSBzZXRcbiAgICBjb25zdCBwb2ludGVyUG9zaXRpb24gPSBjbGllbnRZIC0gY29udGFpbmVyT2Zmc2V0LnRvcDtcbiAgICBjb25zdCBpdGVtVG9wID0gaXRlbVZpZXdQb3J0Q29vcmRzLnRvcCAtIGNvbnRhaW5lck9mZnNldC50b3A7XG4gICAgaWYgKHBvaW50ZXJQb3NpdGlvbiA8IGl0ZW1Ub3AgKyBpdGVtRGl2aXNpb25IZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIERyb3BQb3NpdGlvbi5CZWZvcmU7XG4gICAgfVxuICAgIGlmIChwb2ludGVyUG9zaXRpb24gPj0gaXRlbVRvcCArIGl0ZW1WaWV3UG9ydENvb3Jkcy5oZWlnaHQgLSBpdGVtRGl2aXNpb25IZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIERyb3BQb3NpdGlvbi5BZnRlcjtcbiAgICB9XG4gICAgcmV0dXJuIERyb3BQb3NpdGlvbi5PdmVyO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0cmVlSXRlbUZyb21FdmVudFRhcmdldCA9ICh0cmVlVmlldywgZHJvcFRhcmdldCkgPT4ge1xuICAgIGlmICghKGlzUHJlc2VudCh0cmVlVmlldykgJiYgaXNQcmVzZW50KGRyb3BUYXJnZXQpKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IGNsb3Nlc3ROb2RlKGRyb3BUYXJnZXQpO1xuICAgIGNvbnN0IGluZGV4ID0gbm9kZUlkKG5vZGUpO1xuICAgIGNvbnN0IGxvb2t1cCA9IHRyZWVWaWV3Lml0ZW1Mb29rdXAoaW5kZXgpO1xuICAgIGlmICghKGlzUHJlc2VudChsb29rdXApICYmIGlzUHJlc2VudChsb29rdXAuaXRlbS5kYXRhSXRlbSkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbG9va3VwO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIEVtaXRzIGBjb2xsYXBzZWAgb24gdGhlIHNwZWNpZmllZCBUcmVlVmlldyBub2RlIGlmIHRoZSBsYXR0ZXIgaXMgbGVmdCBlbXB0eSBhZnRlciBpdHMgbGFzdCBjaGlsZCBub2RlIHdhcyBkcmFnZ2VkIG91dC5cbiAqL1xuY29uc3QgY29sbGFwc2VFbXB0eVBhcmVudCA9IChwYXJlbnQsIHBhcmVudE5vZGVzLCB0cmVldmlldykgPT4ge1xuICAgIGlmIChpc1ByZXNlbnQocGFyZW50KSAmJiBwYXJlbnROb2Rlcy5sZW5ndGggPT09IDAgJiYgdHJlZXZpZXcuaXNFeHBhbmRlZChwYXJlbnQuaXRlbS5kYXRhSXRlbSwgcGFyZW50Lml0ZW0uaW5kZXgpKSB7XG4gICAgICAgIHRyZWV2aWV3LmNvbGxhcHNlTm9kZShwYXJlbnQuaXRlbS5kYXRhSXRlbSwgcGFyZW50Lml0ZW0uaW5kZXgpO1xuICAgIH1cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBFeHBhbmRzIHRoZSBub2RlIGlmIGl0J3MgZHJvcHBlZCBpbnRvIGFuZCBpdCdzIG5vdCB5ZXQgZXhwYW5kZWQuXG4gKi9cbmNvbnN0IGV4cGFuZERyb3BUYXJnZXQgPSAoZHJvcFRhcmdldCwgdHJlZVZpZXcpID0+IHtcbiAgICBpZiAoIXRyZWVWaWV3LmlzRXhwYW5kZWQoZHJvcFRhcmdldC5pdGVtLmRhdGFJdGVtLCBkcm9wVGFyZ2V0Lml0ZW0uaW5kZXgpKSB7XG4gICAgICAgIHRyZWVWaWV3LmV4cGFuZE5vZGUoZHJvcFRhcmdldC5pdGVtLmRhdGFJdGVtLCBkcm9wVGFyZ2V0Lml0ZW0uaW5kZXgpO1xuICAgIH1cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBFeHRyYWN0cyB0aGUgZXZlbnQgdGFyZ2V0IGZyb20gdGhlIHZpZXdwb3J0IGNvb3Jkcy4gUmVxdWlyZWQgZm9yIHRvdWNoIGRldmljZXNcbiAqIHdoZXJlIHRoZSBgZXZlbnQudGFyZ2V0YCBvZiBhIGBwb2ludGVybW92ZWAgZXZlbnQgaXMgYWx3YXlzIHRoZSBpbml0aWFsbHkgZHJhZ2dlZCBpdGVtLlxuICovXG5jb25zdCBnZXREcm9wVGFyZ2V0ID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCEoaXNEb2N1bWVudEF2YWlsYWJsZSgpICYmIGlzUHJlc2VudChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KSkpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogQ2hlY2tzIGlmIHRoZSBvcmlnaW5hbCBpbmRleCBpcyBiZWZvcmUgdGhlIG5ldyBvbmUgYW5kIGNvcnJlY3RzIHRoZSBuZXcgb25lIGJ5IGRlY3JlbWVudGluZyB0aGUgaW5kZXggZm9yIHRoZSBsZXZlbCwgd2hlcmUgdGhlIG9yaWdpbmFsIGl0ZW0gc3Rvb2QuXG4gKi9cbmNvbnN0IHVwZGF0ZU1vdmVkSXRlbUluZGV4ID0gKG5ld0luZGV4LCBvcmlnaW5hbEluZGV4KSA9PiB7XG4gICAgY29uc3QgbW92ZWRJdGVtTmV3SW5kZXhQYXJ0cyA9IG5ld0luZGV4LnNwbGl0KCdfJyk7XG4gICAgY29uc3Qgb3JpZ2luYWxJdGVtSW5kZXhQYXJ0cyA9IG9yaWdpbmFsSW5kZXguc3BsaXQoJ18nKTtcbiAgICAvLyBpZiB0aGUgb3JpZ2luYWwgaXRlbSB3YXMgbW92ZWQgZnJvbSBhIGRlZXBlciBsZXZlbCwgdGhlcmUncyBubyBuZWVkIGZvciBpbmRleCBjb3JyZWN0aW9uXG4gICAgLy8gZS5nLiA0XzBfMSBpcyBtb3ZlZCB0byA1XzAgPT4gcmVtb3ZpbmcgNF8wXzEgd2lsbCBub3QgY2F1c2UgNV8wIHRvIGJlIG1vdmVkXG4gICAgaWYgKG1vdmVkSXRlbU5ld0luZGV4UGFydHMubGVuZ3RoIDwgb3JpZ2luYWxJdGVtSW5kZXhQYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ld0luZGV4O1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiB0aGUgcGFyZW50IGl0ZW0gcGF0aHMgYXJlIHRoZSBzYW1lIC0gaW5kZXggY29ycmVjdGlvbiBpcyBub3QgcmVxdWlyZWQgd2hlbiB0aGUgb3JpZ2luYWwgaXRlbSBwYXRoIGRpZmZlcnMgZnJvbSB0aGUgcGF0aCBvZiB0aGUgbW92ZWQgaXRlbSAtIHRoZXkgYmVsb25nIHRvIGRpZmZlcmVudCBoaWVyYXJjaGllc1xuICAgIC8vIGUuZy4gNF8xIGlzIG1vdmVkIHRvIDVfMSAtIHRoZSBwYXJlbnQgaXRlbSBwYXRocyBhcmUgZGlmZmVyZW4gKDQgY29tcGFyZWQgdG8gNSkgPT4gcmVtb3ZpbmcgNF8xIHdpbGwgbm90IGNhdXNlIDVfMSB0byBiZSBtb3ZlZFxuICAgIC8vIGUuZyA0XzEgaXMgbW92ZWQgdG8gNF8zIC0gdGhlIHBhcmVudCBwYXRocyBhcmUgdGhlIHNhbWUgKGJvdGggNCkgPT4gcmVtb3ZpbmcgNF8xIHdpbGwgY2F1c2UgNF8zIHRvIGJlIG1vdmVkXG4gICAgY29uc3Qgb3JpZ2luYWxJdGVtUGFyZW50UGF0aExlbmd0aCA9IG9yaWdpbmFsSXRlbUluZGV4UGFydHMubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBvcmlnaW5hbEl0ZW1QYXJlbnRQYXRoID0gb3JpZ2luYWxJdGVtSW5kZXhQYXJ0cy5zbGljZSgwLCBvcmlnaW5hbEl0ZW1QYXJlbnRQYXRoTGVuZ3RoKS5qb2luKCdfJyk7XG4gICAgY29uc3QgbW92ZWRJdGVtUGFyZW50UGF0aCA9IG1vdmVkSXRlbU5ld0luZGV4UGFydHMuc2xpY2UoMCwgb3JpZ2luYWxJdGVtUGFyZW50UGF0aExlbmd0aCkuam9pbignXycpO1xuICAgIC8vIGNoZWNrIGlmIHRoZSB0aGUgaW5kZXggb2YgdGhlIGxldmVsIHdoZXJlIHRoZSBvcmlnaW5hbCBpdGVtIGlzIHRha2VuIGZyb20gaXMgZ3JlYXRlciB0aGFuIHRoZSBvbmUgb2YgdGhlIG1vdmVkIGl0ZW1cbiAgICAvLyBlLmcuIDRfNSBpcyBtb3ZlZCB0byA0XzEgKGNvbWFwcmUgNSBhbmQgMSkgPT4gcmVtb3ZpbmcgNF81IHdpbGwgbm90IGNhdXNlIDRfMSB0byBiZSBtb3ZlZFxuICAgIC8vIGUuZy4gNF8xIGlzIG1vdmVkIHRvIDRfNSAoY29tYXByZSAxIGFuZCA1KSA9PiByZW1vdmluZyA0XzEgd2lsbCBjYXVzZSA0XzUgdG8gYmUgbW92ZWRcbiAgICBjb25zdCBvcmlnaW5hbEl0ZW1JbmRleExldmVsID0gb3JpZ2luYWxJdGVtSW5kZXhQYXJ0cy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IG9yaWdpbmFsSXRlbUxldmVsSW5kZXggPSBOdW1iZXIob3JpZ2luYWxJdGVtSW5kZXhQYXJ0c1tvcmlnaW5hbEl0ZW1JbmRleExldmVsXSk7XG4gICAgY29uc3QgbW92ZWRJdGVtTGV2ZWxJbmRleCA9IE51bWJlcihtb3ZlZEl0ZW1OZXdJbmRleFBhcnRzW29yaWdpbmFsSXRlbUluZGV4TGV2ZWxdKTtcbiAgICBpZiAoKG9yaWdpbmFsSXRlbVBhcmVudFBhdGggPT09IG1vdmVkSXRlbVBhcmVudFBhdGgpICYmIChtb3ZlZEl0ZW1MZXZlbEluZGV4ID4gb3JpZ2luYWxJdGVtTGV2ZWxJbmRleCkpIHtcbiAgICAgICAgLy8gaWYgdGhlIHJlbW92ZWQgaXRlbSBjYXVzZXMgdGhlIGRyb3BwZWQgaXRlbSB0byBiZSBtb3ZlZCBhIHBvc2l0aW9uIHVwIC0gZGVjcmVtZW50IHRoZSBpbmRleCBhdCB0aGF0IGxldmVsXG4gICAgICAgIG1vdmVkSXRlbU5ld0luZGV4UGFydHNbb3JpZ2luYWxJdGVtSW5kZXhMZXZlbF0gPSBTdHJpbmcobW92ZWRJdGVtTGV2ZWxJbmRleCAtIDEpO1xuICAgICAgICByZXR1cm4gbW92ZWRJdGVtTmV3SW5kZXhQYXJ0cy5qb2luKCdfJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdJbmRleDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgU0NST0xMQkFSX1JFR19FWFAgPSBuZXcgUmVnRXhwKCcoYXV0b3xzY3JvbGwpJyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBSZXRyaXZlcyB0aGUgZmlyc3Qgc2Nyb2xsYWJsZSBlbGVtZW50IHN0YXJ0aW5nIHRoZSBzZWFyY2ggZnJvbSB0aGUgcHJvdmlkZWQgb25lLCB0cmF2ZXJzaW5nIHRvIHRoZSB0b3Agb2YgdGhlIERPTSB0cmVlLlxuICovXG5jb25zdCBnZXRTY3JvbGxhYmxlQ29udGFpbmVyID0gKG5vZGUpID0+IHtcbiAgICB3aGlsZSAoaXNQcmVzZW50KG5vZGUpICYmIG5vZGUubm9kZU5hbWUgIT09ICdIVE1MJykge1xuICAgICAgICBjb25zdCBoYXNPdmVyZmxvdyA9IG5vZGUuc2Nyb2xsSGVpZ2h0ID4gbm9kZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGhhc1Njcm9sbGJhciA9IFNDUk9MTEJBUl9SRUdfRVhQLnRlc3QoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vdmVyZmxvd1kpO1xuICAgICAgICBpZiAoaGFzT3ZlcmZsb3cgJiYgaGFzU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBDaGVja3MgaWYgdGhlIHRvcCBvZiB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IGlzIHJlYWNoZWQuXG4gKiBGbG9vcnMgdGhlIHNjcm9sbFRvcCB2YWx1ZS5cbiAqL1xuY29uc3QgaXNUb3BSZWFjaGVkID0gKGVsZW1lbnQpID0+IE1hdGguZmxvb3IoZWxlbWVudC5zY3JvbGxUb3ApIDw9IDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBDaGVja3MgaWYgdGhlIGJvdHRvbSBvZiB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IGlzIHJlYWNoZWQuXG4gKiBDZWlscyB0aGUgc2Nyb2xsVG9wIHZhbHVlLlxuICovXG5jb25zdCBpc0JvdHRvbVJlYWNoZWQgPSAoZWxlbWVudCkgPT4gTWF0aC5jZWlsKGVsZW1lbnQuc2Nyb2xsVG9wKSA+PSBlbGVtZW50LnNjcm9sbEhlaWdodCAtIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogU2Nyb2xscyB0aGUgZWxlbWVudCBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uIGJ5IHRoZSBwcm92aWRlZCBzdGVwLlxuICpcbiAqIElmIHRoZSB0YXJnZXRlZCBzY3JvbGwgaW5jcmVtZW50YXRpb24gZG9lc24ndCB5aWVsZCBhbnkgcmVzdWx0IGR1ZSB0byBkZXZpY2UgcGl4ZWwgcmF0aW8gaXNzdWVzIChodHRwczovL2dpdGh1Yi5jb20vZGltaXRhci1wZWNoZXYvUmVuZGVyaW5nSW5kZXBlbmRlbnRTY3JvbGxPZmZzZXRzI3JlYWRtZSksXG4gKiBpbmNyZW1lbnRzIHRoZSBzdGVwIHdpdGggMXB4IGFuZCBhZ2FpbiBhdHRlbXB0cyB0byBjaGFuZ2UgdGhlIHNjcm9sbFRvcCBvZiB0aGUgZWxlbWVudCwgdW50aWwgdGhlIGNvbnRlbnQgaXMgYWN0dWFsbHkgc2Nyb2xsZWQuXG4gKlxuICogQ3V0cyB0aGUgb3BlcmF0aW9uIHNob3J0IGFmdGVyIDIwIHVuc3VjY2Vzc2Z1bCBhdHRlbXB0cyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzIGluIHBvc3NpYmxlIGNvcm5lci1jYXNlIHNjZW5hcmlvcy5cbiAqL1xuY29uc3Qgc2Nyb2xsRWxlbWVudEJ5ID0gKGVsZW1lbnQsIHN0ZXAsIGRpcmVjdGlvbikgPT4ge1xuICAgIGlmICghKGlzUHJlc2VudChlbGVtZW50KSAmJiBpc0RvY3VtZW50QXZhaWxhYmxlKCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbFNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIGxldCBjdXJyZW50U3RlcCA9IHN0ZXA7XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuICAgIHdoaWxlIChpbml0aWFsU2Nyb2xsVG9wID09PSBlbGVtZW50LnNjcm9sbFRvcCAmJlxuICAgICAgICAhKGRpcmVjdGlvbiA9PT0gU2Nyb2xsRGlyZWN0aW9uLlVwICYmIGlzVG9wUmVhY2hlZChlbGVtZW50KSkgJiZcbiAgICAgICAgIShkaXJlY3Rpb24gPT09IFNjcm9sbERpcmVjdGlvbi5Eb3duICYmIGlzQm90dG9tUmVhY2hlZChlbGVtZW50KSkgJiZcbiAgICAgICAgaXRlcmF0aW9ucyA8IDIwIC8vIGFzIHRoZSBidWxnYXJpYW4gc2F5aW5nIGdvZXMgLSB0byB0aWVzIG91ciB1bmRlcnBhbnRzXG4gICAgKSB7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wICs9IChjdXJyZW50U3RlcCAqIGRpcmVjdGlvbik7XG4gICAgICAgIGN1cnJlbnRTdGVwICs9IDE7XG4gICAgICAgIGl0ZXJhdGlvbnMgKz0gMTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY29weVBhZ2VTaXplID0gKHRyZWV2aWV3LCBzb3VyY2UsIHRhcmdldCkgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KHRyZWV2aWV3LmxvYWRNb3JlU2VydmljZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VHcm91cFNpemUgPSB0cmVldmlldy5nZXROb2RlUGFnZVNpemUoc291cmNlKTtcbiAgICB0cmVldmlldy5zZXROb2RlUGFnZVNpemUodGFyZ2V0LCBzb3VyY2VHcm91cFNpemUpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpbmNyZW1lbnRQYWdlU2l6ZSA9ICh0cmVldmlldywgZGF0YUl0ZW0pID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudCh0cmVldmlldy5sb2FkTW9yZVNlcnZpY2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFBhZ2VTaXplID0gdHJlZXZpZXcuZ2V0Tm9kZVBhZ2VTaXplKGRhdGFJdGVtKTtcbiAgICB0cmVldmlldy5zZXROb2RlUGFnZVNpemUoZGF0YUl0ZW0sIGN1cnJlbnRQYWdlU2l6ZSArIDEpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkZWNyZW1lbnRQYWdlU2l6ZSA9ICh0cmVldmlldywgZGF0YUl0ZW0pID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudCh0cmVldmlldy5sb2FkTW9yZVNlcnZpY2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFBhZ2VTaXplID0gdHJlZXZpZXcuZ2V0Tm9kZVBhZ2VTaXplKGRhdGFJdGVtKTtcbiAgICB0cmVldmlldy5zZXROb2RlUGFnZVNpemUoZGF0YUl0ZW0sIGN1cnJlbnRQYWdlU2l6ZSAtIDEpO1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEhpZXJhcmNoeUVkaXRpbmdTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihoaWVyYXJjaHlCaW5kaW5nKSB7XG4gICAgICAgIHRoaXMuaGllcmFyY2h5QmluZGluZyA9IGhpZXJhcmNoeUJpbmRpbmc7XG4gICAgfVxuICAgIGFkZCh7IHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSwgZHJvcFBvc2l0aW9uLCBzb3VyY2VUcmVlLCBkZXN0aW5hdGlvblRyZWUgfSkge1xuICAgICAgICAvLyBzaGFsbG93IGNsb25lIHRoZSBpdGVtIGFzIG5vdCB0byBtaXN0YWtlIGl0IGZvciBpdHMgJ29sZGVyJyB2ZXJzaW9uIHdoZW4gdGhlIHJlbW92ZSBoYW5kbGVyIGtpY2tzIGluIHRvIHNwbGljZSB0aGUgaXRlbSBhdCBpdHMgb2xkIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGNsb25lZFNvdXJjZURhdGFJdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RGF0YUl0ZW0oc291cmNlSXRlbSkpO1xuICAgICAgICBpZiAoZHJvcFBvc2l0aW9uID09PSBEcm9wUG9zaXRpb24uT3Zlcikge1xuICAgICAgICAgICAgLy8gZXhwYW5kIHRoZSBpdGVtIHRoYXQgd2FzIGRyb3BwZWQgaW50b1xuICAgICAgICAgICAgZXhwYW5kRHJvcFRhcmdldChkZXN0aW5hdGlvbkl0ZW0sIGRlc3RpbmF0aW9uVHJlZSk7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbkZvcihnZXREYXRhSXRlbShkZXN0aW5hdGlvbkl0ZW0pKTtcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgbW92ZWQgbm9kZSBqdXN0IGJlZm9yZSB0aGUgbG9hZCBtb3JlIGJ1dHRvbiBpZiBsb2FkIG1vcmUgaXMgZW5hYmxlZFxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSBpc1ByZXNlbnQoZGVzdGluYXRpb25UcmVlLmxvYWRNb3JlU2VydmljZSkgP1xuICAgICAgICAgICAgICAgIE1hdGgubWluKGRlc3RpbmF0aW9uVHJlZS5sb2FkTW9yZVNlcnZpY2UuZ2V0R3JvdXBTaXplKGdldERhdGFJdGVtKGRlc3RpbmF0aW9uSXRlbSkpLCBkZXN0aW5hdGlvbkNoaWxkcmVuLmxlbmd0aCkgOiAvLyB0aGUgcGFnZSBzaXplIG1pZ2h0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgYWN0dWFsIGNoaWxkcmVuIGFycmF5IGxlbmd0aFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZGVzdGluYXRpb25DaGlsZHJlbi5zcGxpY2UodGFyZ2V0SW5kZXgsIDAsIGNsb25lZFNvdXJjZURhdGFJdGVtKTtcbiAgICAgICAgICAgIHNldHRlcih0aGlzLmhpZXJhcmNoeUJpbmRpbmcuY2hpbGRyZW5GaWVsZCkoZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtKSwgZGVzdGluYXRpb25DaGlsZHJlbik7XG4gICAgICAgICAgICB0aGlzLm1vdmVkSXRlbU5ld0luZGV4ID0gYnVpbGRUcmVlSW5kZXgoZGVzdGluYXRpb25JdGVtLml0ZW0uaW5kZXgsIHRhcmdldEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uUGFyZW50Tm9kZXMgPSB0aGlzLmdldFBhcmVudE5vZGVzKGRlc3RpbmF0aW9uSXRlbSwgZGVzdGluYXRpb25UcmVlKTtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0SW5kZXggPSBkcm9wUG9zaXRpb24gPT09IERyb3BQb3NpdGlvbi5BZnRlciA/IDEgOiAwO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSBkZXN0aW5hdGlvblBhcmVudE5vZGVzLmluZGV4T2YoZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtKSkgKyBzaGlmdEluZGV4O1xuICAgICAgICAgICAgZGVzdGluYXRpb25QYXJlbnROb2Rlcy5zcGxpY2UodGFyZ2V0SW5kZXgsIDAsIGNsb25lZFNvdXJjZURhdGFJdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEluZGV4ID0gZGVzdGluYXRpb25JdGVtLnBhcmVudCA/IGRlc3RpbmF0aW9uSXRlbS5wYXJlbnQuaXRlbS5pbmRleCA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1vdmVkSXRlbU5ld0luZGV4ID0gYnVpbGRUcmVlSW5kZXgocGFyZW50SW5kZXgsIHRhcmdldEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIHBhcmVudCBwYWdlIHNpemUgPT4gYW4gaXRlbSBpcyBtb3ZlZCBpbnRvIGl0XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRQYXJlbnQgPSBkcm9wUG9zaXRpb24gPT09IERyb3BQb3NpdGlvbi5PdmVyID8gZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtKSA6IGdldERhdGFJdGVtKGRlc3RpbmF0aW9uSXRlbS5wYXJlbnQpO1xuICAgICAgICBpbmNyZW1lbnRQYWdlU2l6ZShkZXN0aW5hdGlvblRyZWUsIHVwZGF0ZWRQYXJlbnQpO1xuICAgICAgICAvLyB0aGUgcGFnZSBzaXplcyBhcmUgc3RvcmVkIGJ5IGRhdGEtaXRlbSByZWZlcmVuY2UgPT4gY29weSB0aGUgb2xkIGl0ZW0gcmVmIHBhZ2Ugc2l6ZSB0byB0aGUgbmV3IGl0ZW0gcmVmZXJlbmNlXG4gICAgICAgIGNvcHlQYWdlU2l6ZShkZXN0aW5hdGlvblRyZWUsIGdldERhdGFJdGVtKHNvdXJjZUl0ZW0pLCBjbG9uZWRTb3VyY2VEYXRhSXRlbSk7XG4gICAgICAgIC8vIHRoZSBzb3VyY2UgdHJlZSBub2RlcyBhcmUgcmVsb2FkZWQgb24gYHJlbW92ZUl0ZW1gIC0gcmVsb2FkIHRoZSBkZXN0aW5hdGlvbiB0cmVlIG5vZGVzIGlmIHRoZSBzb3J1Y2UgYW5kIHRoZSBkZXN0aW5hdGlvbiB0cmVlIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgIT09IGRlc3RpbmF0aW9uVHJlZSAmJiAhZGVzdGluYXRpb25UcmVlLmxvYWRPbkRlbWFuZCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25UcmVlLnByZWxvYWRDaGlsZE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gdHJlZXMgYXJlIHRoZSBzYW1lLCBmb2N1c2luZyB0aGUgbW92ZWQgaXRlbSBoZXJlIHdpbGwgbm90IGhhdmUgdGhlIGRlc2lyZWQgZWZmZWN0XG4gICAgICAgIC8vIGFzIHRoZSBgcmVtb3ZlYCBoYW5kbGVyIGhhcyBub3QgeWV0IGtpY2tlZC1pbiB0byByZW1vdmUgdGhlIGl0ZW0gZnJvbSBpdHMgb2xkIHBvc2l0aW9uXG4gICAgICAgIGlmIChzb3VyY2VUcmVlICE9PSBkZXN0aW5hdGlvblRyZWUpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGUgZm9jdXMgdGFyZ2V0IGlzIHJlbmRlcmVkIGFuZCByZWdpc3RlcmVkXG4gICAgICAgICAgICBkZXN0aW5hdGlvblRyZWUuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgZGVzdGluYXRpb25UcmVlLmZvY3VzKHRoaXMubW92ZWRJdGVtTmV3SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSh7IHNvdXJjZUl0ZW0sIHNvdXJjZVRyZWUsIGRlc3RpbmF0aW9uVHJlZSB9KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVBhcmVudE5vZGVzID0gdGhpcy5nZXRQYXJlbnROb2Rlcyhzb3VyY2VJdGVtLCBzb3VyY2VUcmVlKTtcbiAgICAgICAgY29uc3Qgc291cmNlSXRlbUluZGV4ID0gc291cmNlUGFyZW50Tm9kZXMuaW5kZXhPZihnZXREYXRhSXRlbShzb3VyY2VJdGVtKSk7XG4gICAgICAgIHNvdXJjZVBhcmVudE5vZGVzLnNwbGljZShzb3VyY2VJdGVtSW5kZXgsIDEpO1xuICAgICAgICAvLyBlbWl0IGNvbGxhcHNlIGZvciB0aGUgcGFyZW50IG5vZGUgaWYgaXRzIGxhc3QgY2hpbGQgbm9kZSB3YXMgc3BsaWNlZFxuICAgICAgICBjb2xsYXBzZUVtcHR5UGFyZW50KHNvdXJjZUl0ZW0ucGFyZW50LCBzb3VyY2VQYXJlbnROb2Rlcywgc291cmNlVHJlZSk7XG4gICAgICAgIC8vIGRlY3JlbWVudCBzb3VyY2UgaXRlbSBwYXJlbnQgcGFnZSBzaXplID0+IGFuIGl0ZW0gaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGl0XG4gICAgICAgIGRlY3JlbWVudFBhZ2VTaXplKHNvdXJjZVRyZWUsIGdldERhdGFJdGVtKHNvdXJjZUl0ZW0ucGFyZW50KSk7XG4gICAgICAgIC8vIHJlbG9hZCB0aGUgdHJlZXZpZXcgbm9kZXNcbiAgICAgICAgaWYgKCFzb3VyY2VUcmVlLmxvYWRPbkRlbWFuZCkge1xuICAgICAgICAgICAgc291cmNlVHJlZS5wcmVsb2FkQ2hpbGROb2RlcygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIHRyZWVzIGFyZSBkaWZmZXJlbnQgd2Ugd2FudCB0byBmb2N1cyBvbmx5IHRoZSBtb3ZlZCBpdGVtIGluIHRoZSBkZXN0aW5hdGlvbiB0cmVlXG4gICAgICAgIGlmIChzb3VyY2VUcmVlID09PSBkZXN0aW5hdGlvblRyZWUpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGUgZm9jdXMgdGFyZ2V0IGlzIHJlbmRlcmVkIGFuZCByZWdpc3RlcmVkXG4gICAgICAgICAgICBkZXN0aW5hdGlvblRyZWUuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHNvdXJjZSBpdGVtIGlzIHJlbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgcG9zaXRpb24sIHRoZSBjYW5kaWRhdGUgaW5kZXggbWlnaHQgaGF2ZSB0byBiZSBjb3JyZWN0ZWRcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdXBkYXRlTW92ZWRJdGVtSW5kZXgodGhpcy5tb3ZlZEl0ZW1OZXdJbmRleCwgc291cmNlSXRlbS5pdGVtLmluZGV4KTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uVHJlZS5mb2N1cyhpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UGFyZW50Tm9kZXMobm9kZSwgdHJlZVZpZXcpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChub2RlLnBhcmVudCkgP1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbkZvcihnZXREYXRhSXRlbShub2RlLnBhcmVudCkpIDpcbiAgICAgICAgICAgIHRyZWVWaWV3Lm5vZGVzO1xuICAgIH1cbiAgICBjaGlsZHJlbkZvcihkYXRhSXRlbSkge1xuICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMuaGllcmFyY2h5QmluZGluZy5jaGlsZHJlbkZpZWxkKShkYXRhSXRlbSkgfHwgW107XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERyYWdDbHVlQ29tcG9uZW50ID0gY2xhc3MgRHJhZ0NsdWVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNkcikge1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIHRoaXMucG9zaXN0aW9uU3R5bGUgPSAnZml4ZWQnO1xuICAgIH1cbiAgICBnZXQgc3RhdHVzSWNvbkNsYXNzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIERyb3BBY3Rpb24uQWRkOiByZXR1cm4gJ2staS1wbHVzJztcbiAgICAgICAgICAgIGNhc2UgRHJvcEFjdGlvbi5JbnNlcnRUb3A6IHJldHVybiAnay1pLWluc2VydC11cCc7XG4gICAgICAgICAgICBjYXNlIERyb3BBY3Rpb24uSW5zZXJ0Qm90dG9tOiByZXR1cm4gJ2staS1pbnNlcnQtZG93bic7XG4gICAgICAgICAgICBjYXNlIERyb3BBY3Rpb24uSW5zZXJ0TWlkZGxlOiByZXR1cm4gJ2staS1pbnNlcnQtbWlkZGxlJztcbiAgICAgICAgICAgIGNhc2UgRHJvcEFjdGlvbi5JbnZhbGlkOlxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuICdrLWktY2FuY2VsJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBleHBvc2VkIGFzIGEgcHVibGljIG1ldGhvZCB0aGF0IGNhbiBiZSBjYWxsZWQgZnJvbSBvdXRzaWRlIGFzIHRoZSBjb21wb25lbnQgdXNlcyBgT25QdXNoYCBzdHJhdGVneVxuICAgIGRldGVjdENoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstaGVhZGVyJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZHJhZy1jbHVlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEcmFnQ2x1ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5wb3NpdGlvbicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEcmFnQ2x1ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicG9zaXN0aW9uU3R5bGVcIiwgdm9pZCAwKTtcbkRyYWdDbHVlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZXZpZXctZHJhZy1jbHVlJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiF0ZW1wbGF0ZVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24ge3tzdGF0dXNJY29uQ2xhc3N9fSBrLWRyYWctc3RhdHVzXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4+e3t0ZXh0fX08L3NwYW4+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgKm5nSWY9XCJ0ZW1wbGF0ZVwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJ0ZW1wbGF0ZVwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgc291cmNlSXRlbTogc291cmNlSXRlbSxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkl0ZW06IGRlc3RpbmF0aW9uSXRlbVxuICAgICAgICAgICAgfVwiXG4gICAgICAgID5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBEcmFnQ2x1ZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEcmFnQW5kRHJvcEFzc2V0U2VydmljZSB7XG4gICAgZ2V0IGNvbXBvbmVudFJlZigpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5fY29tcG9uZW50UmVmKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYGluaXRhbGl6ZWAgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIG90aGVyIHNlcnZpY2UgbWV0aG9kcy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50UmVmO1xuICAgIH1cbiAgICBzZXQgY29tcG9uZW50UmVmKGNvbXBvbmVudFJlZikge1xuICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYgPSBjb21wb25lbnRSZWY7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRSZWYubG9jYXRpb24ubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuX2NvbXBvbmVudFJlZikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmID0gbnVsbDtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIG1vdmUobGVmdCwgdG9wLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7bGVmdCArIG9mZnNldH1weGA7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSBgJHt0b3AgKyBvZmZzZXR9cHhgO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IENMVUVfT0ZGU0VUID0gMTA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUkVUVVJOX0FOSU1BVElPTl9EVVJBVElPTiA9IDIwMDtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRHJhZ0NsdWVTZXJ2aWNlID0gY2xhc3MgRHJhZ0NsdWVTZXJ2aWNlIGV4dGVuZHMgRHJhZ0FuZERyb3BBc3NldFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZShjb250YWluZXIsIHRlbXBsYXRlKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fY29tcG9uZW50UmVmKSkge1xuICAgICAgICAgICAgdGhpcy5uZ09uRGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsdWVDb21wb25lbnRGYWN0b3J5ID0gdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoRHJhZ0NsdWVDb21wb25lbnQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZiA9IGNvbnRhaW5lci5jcmVhdGVDb21wb25lbnQoY2x1ZUNvbXBvbmVudEZhY3RvcnkpO1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYuaW5zdGFuY2UudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxSZXR1cm5BbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5jYW5jZWxTY3JvbGwoKTtcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcbiAgICB9XG4gICAgbW92ZShsZWZ0LCB0b3ApIHtcbiAgICAgICAgc3VwZXIubW92ZShsZWZ0LCB0b3AsIENMVUVfT0ZGU0VUKTtcbiAgICB9XG4gICAgYW5pbWF0ZURyYWdDbHVlVG9FbGVtZW50UG9zaXRpb24odGFyZ2V0KSB7XG4gICAgICAgIGlmICghKGlzUHJlc2VudCh0YXJnZXQpICYmIGlzUHJlc2VudCh0aGlzLmVsZW1lbnQuYW5pbWF0ZSkpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50Vmlld1BvcnRDb29yZHMgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGNsdWVFbGVtZW50Vmlld1BvcnRDb29yZHMgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMucmV0dXJuQW5pbWF0aW9uID0gdGhpcy5lbGVtZW50LmFuaW1hdGUoW1xuICAgICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwgMCknIH0sXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3RhcmdldEVsZW1lbnRWaWV3UG9ydENvb3Jkcy5sZWZ0IC0gY2x1ZUVsZW1lbnRWaWV3UG9ydENvb3Jkcy5sZWZ0fXB4LCAke3RhcmdldEVsZW1lbnRWaWV3UG9ydENvb3Jkcy50b3AgLSBjbHVlRWxlbWVudFZpZXdQb3J0Q29vcmRzLnRvcH1weClgIH1cbiAgICAgICAgXSwgUkVUVVJOX0FOSU1BVElPTl9EVVJBVElPTik7XG4gICAgICAgIHRoaXMucmV0dXJuQW5pbWF0aW9uLm9uZmluaXNoID0gKCkgPT4gdGhpcy5oaWRlKCk7XG4gICAgfVxuICAgIGNhbmNlbFJldHVybkFuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5yZXR1cm5BbmltYXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXR1cm5BbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIHRoaXMucmV0dXJuQW5pbWF0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlRHJhZ0NsdWVEYXRhKGFjdGlvbiwgc291cmNlSXRlbSwgZGVzdGluYXRpb25JdGVtKSB7XG4gICAgICAgIGNvbnN0IGRyYWdDbHVlID0gdGhpcy5jb21wb25lbnRSZWYuaW5zdGFuY2U7XG4gICAgICAgIGlmIChhY3Rpb24gPT09IGRyYWdDbHVlLmFjdGlvbiAmJiBkYXRhSXRlbXNFcXVhbChzb3VyY2VJdGVtLCBkcmFnQ2x1ZS5zb3VyY2VJdGVtKSAmJiBkYXRhSXRlbXNFcXVhbChkZXN0aW5hdGlvbkl0ZW0sIGRyYWdDbHVlLmRlc3RpbmF0aW9uSXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkcmFnQ2x1ZS5hY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIGRyYWdDbHVlLnNvdXJjZUl0ZW0gPSBzb3VyY2VJdGVtO1xuICAgICAgICBkcmFnQ2x1ZS5kZXN0aW5hdGlvbkl0ZW0gPSBkZXN0aW5hdGlvbkl0ZW07XG4gICAgICAgIGRyYWdDbHVlLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgdXBkYXRlVGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0ID09PSB0aGlzLmNvbXBvbmVudFJlZi5pbnN0YW5jZS50ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYuaW5zdGFuY2UudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmluc3RhbmNlLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgdGhlIGZpcnN0IHNjcm9sbGFibGUgcGFyZW50IHRvIHNjcm9sbCB1cHdhcmRzIG9yIGRvd253YXJkcy5cbiAgICAgKiBVc2VzIHNldEludGVydmFsLCBzbyBzaG91bGQgYmUgY2FsbGVkIG91dHNpZGUgdGhlIGFuZ3VsYXIgem9uZS5cbiAgICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldyh7IHN0ZXAsIGludGVydmFsIH0pIHtcbiAgICAgICAgdGhpcy5jYW5jZWxTY3JvbGwoKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZUNvbnRhaW5lciA9IGdldFNjcm9sbGFibGVDb250YWluZXIodGhpcy5lbGVtZW50KTtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoc2Nyb2xsYWJsZUNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXJSZWN0ID0gc2Nyb2xsYWJsZUNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgY2x1ZVJlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8vIGlmIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGlzIGFib3ZlIHRoZSBjdXJyZW50IHZpZXdwb3J0LCBmYWxsLWJhY2sgdG8gMFxuICAgICAgICBjb25zdCBmaXJzdFZpc2libGVDbGllbnRUb3BQYXJ0ID0gTWF0aC5tYXgoY29udGFpbmVyUmVjdC50b3AsIDApO1xuICAgICAgICAvLyBzdGFydCBzY3JvbGxpbmcgdXAgd2hlbiB0aGUgZmlyc3QgdmlzaWJsZSBpdGVtIGlzIGRyYWdnZWQgb3ZlclxuICAgICAgICBjb25zdCB0b3BMaW1pdCA9IGZpcnN0VmlzaWJsZUNsaWVudFRvcFBhcnQgKyBjbHVlUmVjdC5oZWlnaHQ7XG4gICAgICAgIC8vIGlmIHRoZSBlbmQgb2YgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGlzIGJlbmVhdGggdGhlIGN1cnJlbnQgdmlld3BvcnQsIGZhbGwtYmFjayB0byBpdHMgY2xpZW50IGhlaWdodFxuICAgICAgICAvLyBhZGQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB2aWV3cG9ydCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb250YWluZXIgdG8gZW5zdXJlIHNjcm9sbGluZyBib3R0b20gYmVnaW5zIHdoZW4gdGhlIGFjdHVhbCBlbmQgb2YgdGhlIGNvbnRhaW5lciBpcyByZWFjaGVkXG4gICAgICAgIGNvbnN0IGJvdHRvbUxpbWl0ID0gZmlyc3RWaXNpYmxlQ2xpZW50VG9wUGFydCArIE1hdGgubWluKGNvbnRhaW5lclJlY3QuYm90dG9tLCBzY3JvbGxhYmxlQ29udGFpbmVyLmNsaWVudEhlaWdodCk7XG4gICAgICAgIGlmIChjbHVlUmVjdC50b3AgPCB0b3BMaW1pdCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHNjcm9sbEVsZW1lbnRCeShzY3JvbGxhYmxlQ29udGFpbmVyLCBzdGVwLCBTY3JvbGxEaXJlY3Rpb24uVXApLCBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2x1ZVJlY3QuYm90dG9tID4gYm90dG9tTGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiBzY3JvbGxFbGVtZW50Qnkoc2Nyb2xsYWJsZUNvbnRhaW5lciwgc3RlcCwgU2Nyb2xsRGlyZWN0aW9uLkRvd24pLCBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBvdXQgdGhlIG9uLWdvaW5nIHNjcm9sbCBhbmltYXRpb24sIGlmIHByZXNlbnQuXG4gICAgICovXG4gICAgY2FuY2VsU2Nyb2xsKCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc2Nyb2xsSW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc2Nyb2xsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuRHJhZ0NsdWVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXSlcbl0sIERyYWdDbHVlU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRHJvcEhpbnRDb21wb25lbnQgPSBjbGFzcyBEcm9wSGludENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZiA9IGNoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICB0aGlzLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgfVxuICAgIC8vIGV4cG9zZWQgYXMgYSBwdWJsaWMgbWV0aG9kIHRoYXQgY2FuIGJlIGNhbGxlZCBmcm9tIG91dHNpZGUgYXMgdGhlIGNvbXBvbmVudCB1c2VzIGBPblB1c2hgIHN0cmF0ZWd5XG4gICAgZGV0ZWN0Q2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWRyb3AtaGludC1jb250YWluZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyb3BIaW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0Q2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5wb3NpdGlvbicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEcm9wSGludENvbXBvbmVudC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5wb2ludGVyLWV2ZW50cycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEcm9wSGludENvbXBvbmVudC5wcm90b3R5cGUsIFwicG9pbnRlckV2ZW50c1wiLCB2b2lkIDApO1xuRHJvcEhpbnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVldmlldy1kcm9wLWhpbnQnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICAqbmdJZj1cIiF0ZW1wbGF0ZVwiXG4gICAgICAgICAgICBjbGFzcz1cImstZHJvcC1oaW50IGstZHJvcC1oaW50LWhcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPSdrLWRyb3AtaGludC1zdGFydCc+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPSdrLWRyb3AtaGludC1saW5lJz48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAqbmdJZj1cInRlbXBsYXRlXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRlbXBsYXRlXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgc291cmNlSXRlbTogc291cmNlSXRlbSxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkl0ZW06IGRlc3RpbmF0aW9uSXRlbVxuICAgICAgICAgICAgfVwiXG4gICAgICAgID5cbiAgICAgICAgPG5nLXRlbXBsYXRlPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NoYW5nZURldGVjdG9yUmVmXSlcbl0sIERyb3BIaW50Q29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBEcm9wSGludFNlcnZpY2UgPSBjbGFzcyBEcm9wSGludFNlcnZpY2UgZXh0ZW5kcyBEcmFnQW5kRHJvcEFzc2V0U2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gY29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgIH1cbiAgICBpbml0aWFsaXplKGNvbnRhaW5lciwgdGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9jb21wb25lbnRSZWYpKSB7XG4gICAgICAgICAgICB0aGlzLm5nT25EZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGludENvbXBvbmVudEZhY3RvcnkgPSB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShEcm9wSGludENvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmID0gY29udGFpbmVyLmNyZWF0ZUNvbXBvbmVudChoaW50Q29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZi5pbnN0YW5jZS50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIHVwZGF0ZURyb3BIaW50RGF0YShhY3Rpb24sIHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSkge1xuICAgICAgICBjb25zdCBkcm9wSGludCA9IHRoaXMuY29tcG9uZW50UmVmLmluc3RhbmNlO1xuICAgICAgICBpZiAoYWN0aW9uID09PSBkcm9wSGludC5hY3Rpb24gJiYgZGF0YUl0ZW1zRXF1YWwoc291cmNlSXRlbSwgZHJvcEhpbnQuc291cmNlSXRlbSkgJiYgZGF0YUl0ZW1zRXF1YWwoZGVzdGluYXRpb25JdGVtLCBkcm9wSGludC5kZXN0aW5hdGlvbkl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZHJvcEhpbnQuYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICBkcm9wSGludC5zb3VyY2VJdGVtID0gc291cmNlSXRlbTtcbiAgICAgICAgZHJvcEhpbnQuZGVzdGluYXRpb25JdGVtID0gZGVzdGluYXRpb25JdGVtO1xuICAgICAgICBkcm9wSGludC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxufTtcbkRyb3BIaW50U2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcl0pXG5dLCBEcm9wSGludFNlcnZpY2UpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHRlbXBsYXRlIGZvciB0aGUgVHJlZVZpZXcgZHJhZyBjbHVlIHdoZW4gYW4gaXRlbSBpcyBkcmFnZ2VkLiBUbyBkZWZpbmUgdGhlIGNsdWUgdGVtcGxhdGUsXG4gKiBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvVHJlZVZpZXdEcmFnQ2x1ZVRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIGEgYDxrZW5kby10cmVldmlldz5gIHRhZ1xuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2MtdGVtcGxhdGVzKSkuXG4gKlxuICpcbiAqIFRoZSB0ZXh0LCBhdHRlbXB0ZWQgZHJvcCBhY3Rpb24sIHNvdXJjZSBpdGVtIGFuZCBkZXN0aW5hdGlvbiBpdGVtIGFyZSBhdmFpbGFibGUgYXMgY29udGV4dCB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlOlxuICpcbiAqXG4gKiAtIGBsZXQtdGV4dD1cInRleHRcImAgKGBzdHJpbmdgKVxuICogLSBgbGV0LWFjdGlvbj1cImFjdGlvblwiYCAoW2BEcm9wQWN0aW9uYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfZHJvcGFjdGlvbiAlfSkpXG4gKiAtIGBsZXQtc291cmNlSXRlbT1cInNvdXJjZUl0ZW1cImAgKFtgVHJlZUl0ZW1Mb29rdXBgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVlaXRlbWxvb2t1cCAlfSkpXG4gKiAtIGBsZXQtZGVzdGluYXRpb25JdGVtPVwiZGVzdGluYXRpb25JdGVtXCJgIChbYFRyZWVJdGVtTG9va3VwYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZWl0ZW1sb29rdXAgJX0pKVxuICovXG5sZXQgRHJhZ0NsdWVUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIERyYWdDbHVlVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuRHJhZ0NsdWVUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdEcmFnQ2x1ZVRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgRHJhZ0NsdWVUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGVtcGxhdGUgZm9yIHRoZSBUcmVlVmlldyBkcm9wIGhpbnQgd2hlbiBhbiBpdGVtIGlzIGRyYWdnZWQuIFRvIGRlZmluZSB0aGUgaGludCB0ZW1wbGF0ZSxcbiAqIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9UcmVlVmlld0Ryb3BIaW50VGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYSBgPGtlbmRvLXRyZWV2aWV3PmAgdGFnXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy10ZW1wbGF0ZXMpKS5cbiAqXG4gKiBUaGUgYXR0ZW1wdGVkIGRyb3AgYWN0aW9uLCBzb3VyY2UgaXRlbSBhbmQgZGVzdGluYXRpb24gaXRlbSBhcmUgYXZhaWxhYmxlIGFzIGNvbnRleHQgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZTpcbiAqXG4gKiAtIGBsZXQtYWN0aW9uPVwiYWN0aW9uXCJgIChbYERyb3BBY3Rpb25gXSh7JSBzbHVnIGFwaV90cmVldmlld19kcm9wYWN0aW9uICV9KSlcbiAqIC0gYGxldC1zb3VyY2VJdGVtPVwic291cmNlSXRlbVwiYCAoW2BUcmVlSXRlbUxvb2t1cGBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWVpdGVtbG9va3VwICV9KSlcbiAqIC0gYGxldC1kZXN0aW5hdGlvbkl0ZW09XCJkZXN0aW5hdGlvbkl0ZW1cImAgKFtgVHJlZUl0ZW1Mb29rdXBgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVlaXRlbWxvb2t1cCAlfSkpXG4gKi9cbmxldCBEcm9wSGludFRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgRHJvcEhpbnRUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5Ecm9wSGludFRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0Ryb3BIaW50VGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBEcm9wSGludFRlbXBsYXRlRGlyZWN0aXZlKTtcblxuY29uc3QgREVGQVVMVF9TQ1JPTExfU0VUVElOR1MgPSB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBzdGVwOiAxLFxuICAgIGludGVydmFsOiAxXG59O1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBlbmFibGVzIHRoZSBkcmFnZ2luZyBhbmQgZHJvcHBpbmcgaXRlbXMgaW5zaWRlIHRoZSBjdXJyZW50IFRyZWVWaWV3IG9yIGJldHdlZW4gbXVsdGlwbGUgbGlua2VkIFRyZWVWaWV3IGNvbXBvbmVudCBpbnN0YW5jZXNcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0pKS5cbiAqXG4gKiBUcmlnZ2VycyB0aGUgW2Bub2RlRHJhZ1N0YXJ0YF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLW5vZGVkcmFnc3RhcnQpLFxuICogW2Bub2RlRHJhZ2BdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1ub2RlZHJhZyksXG4gKiBbYG5vZGVEcm9wYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLW5vZGVkcm9wKSxcbiAqIFtgbm9kZURyYWdFbmRgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyYWdlbmQpLFxuICogW2BhZGRJdGVtYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLWFkZGl0ZW0pIGFuZFxuICogW2ByZW1vdmVJdGVtYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLXJlbW92ZWl0ZW0pXG4gKiBldmVudHMgd2hlbiB0aGUgY29ycmVzcG9uZGluZyBhY3Rpb25zIG9jY3VyIG9uIHRoZSByZXNwZWN0aXZlIFRyZWVWaWV3IGluc3RhbmNlLlxuICovXG5sZXQgRHJhZ0FuZERyb3BEaXJlY3RpdmUgPSBjbGFzcyBEcmFnQW5kRHJvcERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgem9uZSwgdHJlZXZpZXcsIGRyYWdDbHVlU2VydmljZSwgZHJvcEhpbnRTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMudHJlZXZpZXcgPSB0cmVldmlldztcbiAgICAgICAgdGhpcy5kcmFnQ2x1ZVNlcnZpY2UgPSBkcmFnQ2x1ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuZHJvcEhpbnRTZXJ2aWNlID0gZHJvcEhpbnRTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGByZW1vdmVJdGVtYCBldmVudCB3aWxsIGJlIGZpcmVkIGFmdGVyIGFuIGl0ZW0gaXMgZHJvcHBlZCB3aGVuIHRoZSBgY3RybGAga2V5IGlzIHByZXNzZWQuXG4gICAgICAgICAqIElmIGVuYWJsZWQsIHRoZSBgcmVtb3ZlSXRlbWAgZXZlbnQgd2lsbCBub3QgYmUgZmlyZWQgb24gdGhlIHNvdXJjZSBUcmVlVmlld1xuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy1tdWx0aXBsZS10cmVldmlld3MpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsb3dDb3B5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZlcyB0aGUgVHJlZVZpZXdDb21wb25lbnQgaW5zdGFuY2VzIGludG8gd2hpY2ggZHJhZ2dlZCBpdGVtcyBmcm9tIHRoZSBjdXJyZW50IFRyZWVWaWV3Q29tcG9uZW50IGNhbiBiZSBkcm9wcGVkXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLW11bHRpcGxlLXRyZWV2aWV3cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcm9wWm9uZVRyZWVWaWV3cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBkaXN0YW5jZSBpbiBwaXhlbHMgZnJvbSB0aGUgaW5pdGlhbCBpdGVtIHBvaW50ZXJkb3duIGV2ZW50LCBiZWZvcmUgdGhlIGRyYWdnaW5nIGlzIGluaXRpYXRlZC5cbiAgICAgICAgICogVGhlIGBub2RlRHJhZ1N0YXJ0YCBhbmQgYWxsIGNvbnNlcXVlbnQgVHJlZVZpZXcgZHJhZyBldmVudHMgd2lsbCBub3QgYmUgZmlyZWQgdW50aWwgdGhlIGFjdHVhbCBkcmFnZ2luZyBiZWdpbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IDVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnREcmFnQWZ0ZXIgPSA1O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbGxzIHRoZSBhdXRvLXNjcm9sbGluZyBiZWhhdmlvciBkdXJpbmcgZHJhZy1hbmQtZHJvcCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy1hdXRvLXNjcm9sbGluZykpLlxuICAgICAgICAgKiBFbmJhbGVkIGJ5IGRlZmF1bHQuIFRvIHR1cm4gdGhlIGF1dG8tc2Nyb2xsaW5nIG9mZiwgc2V0IHRoaXMgcHJvcCB0byBgZmFsc2VgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgc2Nyb2xsaW5nIHdpbGwgYmUgcGVyZm9ybWVkIGJ5IDEgcGl4ZWwgYXQgZXZlcnkgMSBtaWxsaXNlY29uZCwgd2hlbiB0aGUgZHJhZ2dlZCBpdGVtIHJlYWNoZXMgdGhlIHRvcCBvciB0aGUgYm90dG9tIG9mIHRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lci5cbiAgICAgICAgICogVGhlIGBzdGVwYCBhbmQgYGludGVydmFsYCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwcm92aWRpbmcgYSBgRHJhZ0FuZERyb3BTY3JvbGxTZXR0aW5nc2Agb2JqZWN0IHRvIHRoaXMgcHJvcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlclNlbGVjdFN0eWxlID0gJ25vbmUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzY3JpYmVzIHRoZSBvZmZzZXQgb2YgdGhlIHBhcmVudCBlbGVtZW50IGlmIHRoZSBsYXR0ZXIgaGFzIHRoZSBgdHJhbnNmb3JtYCBDU1MgcHJvcCBhcHBsaWVkLlxuICAgICAgICAgKiBUcmFuc2Zvcm1lZCBwYXJlbnRzIGNyZWF0ZSBuZXcgc3RhY2tpbmcgY29udGV4dCBhbmQgdGhlIGZpeGVkIGNoaWxkcmVuIG11c3QgYmUgcG9zaXRpb24gYmFzZWQgb24gdGhlIHRyYW5zZm9ybWVkIHBhcmVudC5cbiAgICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgvVGhlX3N0YWNraW5nX2NvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGFpbmVyT2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgICAgdGhpcy50cmVldmlldy50b3VjaEFjdGlvbnMgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHNjcm9sbFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCB1c2VyUHJvdmlkZWRTZXR0aW5ncyA9IHR5cGVvZiB0aGlzLmF1dG9TY3JvbGwgPT09ICdib29sZWFuJyA/XG4gICAgICAgICAgICB7IGVuYWJsZWQ6IHRoaXMuYXV0b1Njcm9sbCB9IDpcbiAgICAgICAgICAgIHRoaXMuYXV0b1Njcm9sbDtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0NST0xMX1NFVFRJTkdTLCB1c2VyUHJvdmlkZWRTZXR0aW5ncyk7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy5pbml0YWxpemVEcmFnZ2FibGUoKTtcbiAgICAgICAgdGhpcy5kcmFnQ2x1ZVNlcnZpY2UuaW5pdGlhbGl6ZSh0aGlzLnRyZWV2aWV3LmFzc2V0c0NvbnRhaW5lciwgdGhpcy5kcmFnQ2x1ZVRlbXBsYXRlICYmIHRoaXMuZHJhZ0NsdWVUZW1wbGF0ZS50ZW1wbGF0ZVJlZik7XG4gICAgICAgIHRoaXMuZHJvcEhpbnRTZXJ2aWNlLmluaXRpYWxpemUodGhpcy50cmVldmlldy5hc3NldHNDb250YWluZXIsIHRoaXMuZHJvcEhpbnRUZW1wbGF0ZSAmJiB0aGlzLmRyb3BIaW50VGVtcGxhdGUudGVtcGxhdGVSZWYpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlUHJlc3MoeyBvcmlnaW5hbEV2ZW50IH0pIHtcbiAgICAgICAgaWYgKCFpc0NvbnRlbnQob3JpZ2luYWxFdmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RvcmUgdGhlIGRyYWcgdGFyZ2V0IG9uIHByZXNzLCBzaG93IGl0IG9ubHkgd2hlbiBpdCdzIGFjdHVhbGx5IGRyYWdnZWRcbiAgICAgICAgdGhpcy5kcmFnZ2VkSXRlbSA9IGNsb3Nlc3RXaXRoTWF0Y2gob3JpZ2luYWxFdmVudC50YXJnZXQsICcuay10cmVldmlldy1sZWFmJyk7XG4gICAgICAgIC8vIHJlY29yZCB0aGUgY3VycmVudCBwb2ludGVyIGRvd24gY29vcmRzIC0gY29wYXJlZCB0byB0aGUgYHN0YXJ0RHJhZ0FmdGVyYCB2YWx1ZSB0byBjYWxjdWxhdGUgd2hldGhlciB0byBpbml0aWF0ZSBkcmFnZ2luZ1xuICAgICAgICB0aGlzLnBlbmRpbmdEcmFnU3RhcnRFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVEcmFnKHsgb3JpZ2luYWxFdmVudCwgY2xpZW50WCwgY2xpZW50WSB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZEluaXRpYXRlRHJhZ1N0YXJ0KHsgY2xpZW50WCwgY2xpZW50WSB9KSkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWF0ZURyYWdTdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuZHJhZ2dlZEl0ZW0pIHx8IGlzUHJlc2VudCh0aGlzLnBlbmRpbmdEcmFnU3RhcnRFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcm9wVGFyZ2V0ID0gZ2V0RHJvcFRhcmdldChvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLnRyZWV2aWV3Lm5vZGVEcmFnKSkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLm5vdGlmeURyYWcob3JpZ2luYWxFdmVudCwgZHJvcFRhcmdldCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFRyZWVWaWV3ID0gdGhpcy5nZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KTtcbiAgICAgICAgY29uc3QgZHJvcFBvc2l0aW9uID0gZ2V0RHJvcFBvc2l0aW9uKHRoaXMuZHJhZ2dlZEl0ZW0sIGRyb3BUYXJnZXQsIGNsaWVudFksIHRhcmdldFRyZWVWaWV3LCB0aGlzLmNvbnRhaW5lck9mZnNldCk7XG4gICAgICAgIGNvbnN0IGRyb3BIaW50QW5jaG9yID0gY2xvc2VzdFdpdGhNYXRjaChkcm9wVGFyZ2V0LCAnLmstdHJlZXZpZXctbWlkJyk7XG4gICAgICAgIGNvbnN0IGRyb3BBY3Rpb24gPSBnZXREcm9wQWN0aW9uKGRyb3BQb3NpdGlvbiwgZHJvcFRhcmdldCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUl0ZW0gPSB0cmVlSXRlbUZyb21FdmVudFRhcmdldCh0aGlzLnRyZWV2aWV3LCB0aGlzLmRyYWdnZWRJdGVtKTtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25JdGVtID0gdHJlZUl0ZW1Gcm9tRXZlbnRUYXJnZXQodGFyZ2V0VHJlZVZpZXcsIGRyb3BUYXJnZXQpO1xuICAgICAgICB0aGlzLnVwZGF0ZURyb3BIaW50U3RhdGUoZHJvcFBvc2l0aW9uLCBkcm9wSGludEFuY2hvciwgZHJvcEFjdGlvbiwgc291cmNlSXRlbSwgZGVzdGluYXRpb25JdGVtKTtcbiAgICAgICAgdGhpcy51cGRhdGVEcmFnQ2x1ZVN0YXRlKGRyb3BBY3Rpb24sIGNsaWVudFgsIGNsaWVudFksIHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSk7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFNldHRpbmdzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLnNjcm9sbEludG9WaWV3KHRoaXMuc2Nyb2xsU2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVSZWxlYXNlKHsgb3JpZ2luYWxFdmVudCwgY2xpZW50WSB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFNldHRpbmdzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLmNhbmNlbFNjcm9sbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuZHJhZ2dlZEl0ZW0pIHx8IGlzUHJlc2VudCh0aGlzLnBlbmRpbmdEcmFnU3RhcnRFdmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RyYWdTdGFydEV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZEl0ZW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyb3BUYXJnZXQgPSBnZXREcm9wVGFyZ2V0KG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICBjb25zdCBzb3VyY2VUcmVlID0gdGhpcy50cmVldmlldztcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25UcmVlID0gdGhpcy5nZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KTtcbiAgICAgICAgY29uc3QgZHJvcFBvc2l0aW9uID0gZ2V0RHJvcFBvc2l0aW9uKHRoaXMuZHJhZ2dlZEl0ZW0sIGRyb3BUYXJnZXQsIGNsaWVudFksIHRoaXMuZ2V0VGFyZ2V0VHJlZVZpZXcoZHJvcFRhcmdldCksIHRoaXMuY29udGFpbmVyT2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc291cmNlSXRlbSA9IHRyZWVJdGVtRnJvbUV2ZW50VGFyZ2V0KHNvdXJjZVRyZWUsIHRoaXMuZHJhZ2dlZEl0ZW0pO1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkl0ZW0gPSB0cmVlSXRlbUZyb21FdmVudFRhcmdldChkZXN0aW5hdGlvblRyZWUsIGRyb3BUYXJnZXQpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KGRlc3RpbmF0aW9uSXRlbSkgJiYgaXNQcmVzZW50KGRyb3BQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5ub3RpZnlEcm9wKHsgc291cmNlSXRlbSwgZGVzdGluYXRpb25JdGVtLCBkcm9wUG9zaXRpb24sIHNvdXJjZVRyZWUsIGRlc3RpbmF0aW9uVHJlZSB9LCBvcmlnaW5hbEV2ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS5hbmltYXRlRHJhZ0NsdWVUb0VsZW1lbnRQb3NpdGlvbih0aGlzLmRyYWdnZWRJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMudHJlZXZpZXcubm9kZURyYWdFbmQpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHRoaXMubm90aWZ5RHJhZ0VuZCh7IHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSwgb3JpZ2luYWxFdmVudCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcm9wSGludFNlcnZpY2UuaGlkZSgpO1xuICAgICAgICB0aGlzLmRyYWdnZWRJdGVtID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlRHJvcEhpbnRTdGF0ZShkcm9wUG9zaXRpb24sIGRyb3BIaW50QW5jaG9yLCBkcm9wQWN0aW9uLCBzb3VyY2VJdGVtLCBkZXN0aW5hdGlvbkl0ZW0pIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoZHJvcEhpbnRBbmNob3IpIHx8IGRyb3BQb3NpdGlvbiA9PT0gRHJvcFBvc2l0aW9uLk92ZXIgfHwgIWlzUHJlc2VudChkcm9wUG9zaXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmRyb3BIaW50U2VydmljZS5oaWRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yVmlld1BvcnRDb29yZHMgPSBkcm9wSGludEFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgaW5zZXJ0QmVmb3JlID0gZHJvcFBvc2l0aW9uID09PSBEcm9wUG9zaXRpb24uQmVmb3JlO1xuICAgICAgICBjb25zdCB0b3AgPSBpbnNlcnRCZWZvcmUgPyBhbmNob3JWaWV3UG9ydENvb3Jkcy50b3AgOiAoYW5jaG9yVmlld1BvcnRDb29yZHMudG9wICsgYW5jaG9yVmlld1BvcnRDb29yZHMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kcm9wSGludFNlcnZpY2UudXBkYXRlRHJvcEhpbnREYXRhKGRyb3BBY3Rpb24sIHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSk7XG4gICAgICAgIC8vIGNsZWFyIGFueSBwb3NzaWJsZSBjb250YWluZXIgb2Zmc2V0IGNyZWF0ZWQgYnkgcGFyZW50IGVsZW1lbnRzIHdpdGggYHRyYW5zZm9ybWAgY3NzIHByb3BlcnR5IHNldFxuICAgICAgICB0aGlzLmRyb3BIaW50U2VydmljZS5tb3ZlKGFuY2hvclZpZXdQb3J0Q29vcmRzLmxlZnQgLSB0aGlzLmNvbnRhaW5lck9mZnNldC5sZWZ0LCB0b3AgLSB0aGlzLmNvbnRhaW5lck9mZnNldC50b3ApO1xuICAgICAgICB0aGlzLmRyb3BIaW50U2VydmljZS5zaG93KCk7XG4gICAgfVxuICAgIHVwZGF0ZURyYWdDbHVlU3RhdGUoZHJvcEFjdGlvbiwgY2xpZW50WCwgY2xpZW50WSwgc291cmNlSXRlbSwgZGVzdGluYXRpb25JdGVtKSB7XG4gICAgICAgIC8vIGNsZWFyIGFueSBwb3NzaWJsZSBjb250YWluZXIgb2Zmc2V0IGNyZWF0ZWQgYnkgcGFyZW50IGVsZW1lbnRzIHdpdGggYHRyYW5zZm9ybWAgY3NzIHByb3BlcnR5IHNldFxuICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS5tb3ZlKGNsaWVudFggLSB0aGlzLmNvbnRhaW5lck9mZnNldC5sZWZ0LCBjbGllbnRZIC0gdGhpcy5jb250YWluZXJPZmZzZXQudG9wKTtcbiAgICAgICAgdGhpcy5kcmFnQ2x1ZVNlcnZpY2UudXBkYXRlRHJhZ0NsdWVEYXRhKGRyb3BBY3Rpb24sIHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSk7XG4gICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLnNob3coKTtcbiAgICB9XG4gICAgaW5pdGFsaXplRHJhZ2dhYmxlKCkge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoe1xuICAgICAgICAgICAgcHJlc3M6IHRoaXMuaGFuZGxlUHJlc3MuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRyYWc6IHRoaXMuaGFuZGxlRHJhZy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVsZWFzZTogdGhpcy5oYW5kbGVSZWxlYXNlLmJpbmQodGhpcylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLmRyYWdnYWJsZS5iaW5kVG8odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpKTtcbiAgICB9XG4gICAgbm90aWZ5RHJhZ1N0YXJ0KG9yaWdpbmFsRXZlbnQsIGRyb3BUYXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlSXRlbSA9IHRyZWVJdGVtRnJvbUV2ZW50VGFyZ2V0KHRoaXMudHJlZXZpZXcsIGRyb3BUYXJnZXQpO1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBUcmVlSXRlbURyYWdTdGFydEV2ZW50KHsgc291cmNlSXRlbSwgb3JpZ2luYWxFdmVudCB9KTtcbiAgICAgICAgdGhpcy50cmVldmlldy5ub2RlRHJhZ1N0YXJ0LmVtaXQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIG5vdGlmeURyYWcob3JpZ2luYWxFdmVudCwgZHJvcFRhcmdldCkge1xuICAgICAgICBjb25zdCBkcmFnRXZlbnQgPSB7XG4gICAgICAgICAgICBzb3VyY2VJdGVtOiB0cmVlSXRlbUZyb21FdmVudFRhcmdldCh0aGlzLnRyZWV2aWV3LCB0aGlzLmRyYWdnZWRJdGVtKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uSXRlbTogdHJlZUl0ZW1Gcm9tRXZlbnRUYXJnZXQodGhpcy5nZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KSwgZHJvcFRhcmdldCksXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJlZXZpZXcubm9kZURyYWcuZW1pdChkcmFnRXZlbnQpO1xuICAgIH1cbiAgICBub3RpZnlEcm9wKGFyZ3MsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgVHJlZUl0ZW1Ecm9wRXZlbnQoYXJncywgb3JpZ2luYWxFdmVudCk7XG4gICAgICAgIGFyZ3MuZGVzdGluYXRpb25UcmVlLm5vZGVEcm9wLmVtaXQoZXZlbnQpO1xuICAgICAgICAvLyBkaXNhYmxlIHRoZSBhbmltYXRpb25zIG9uIGRyb3AgYW5kIHJlc3RvcmUgdGhlbSBhZnRlcndhcmRzIChpZiB0aGV5IHdlcmUgaW5pdGlhbGx5IHR1cm5lZCBvbilcbiAgICAgICAgdGhpcy5kaXNhYmxlQW5pbWF0aW9uc0Zvck5leHRUaWNrKGFyZ3MuZGVzdGluYXRpb25UcmVlKTtcbiAgICAgICAgaWYgKGFyZ3Muc291cmNlVHJlZSAhPT0gYXJncy5kZXN0aW5hdGlvblRyZWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUFuaW1hdGlvbnNGb3JOZXh0VGljayhhcmdzLnNvdXJjZVRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgZXZlbnQuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnQ2x1ZVNlcnZpY2UuaGlkZSgpO1xuICAgICAgICAgICAgLy8gb3JkZXIgbWF0dGVycyBpbiBhIGZsYXQgZGF0YSBiaW5kaW5nIHNjZW5hcmlvIChmaXJzdCBhZGQsIHRoZW4gcmVtb3ZlKVxuICAgICAgICAgICAgYXJncy5kZXN0aW5hdGlvblRyZWUuYWRkSXRlbS5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCEob3JpZ2luYWxFdmVudC5jdHJsS2V5ICYmIHRoaXMuYWxsb3dDb3B5KSkge1xuICAgICAgICAgICAgICAgIGFyZ3Muc291cmNlVHJlZS5yZW1vdmVJdGVtLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIC8vIGRpcmVjdGx5IGhpZGUgdGhlIGNsdWUgaWYgdGhlIGRlZmF1bHQgaXMgcHJldmVudGVkXG4gICAgICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWV2ZW50LmlzVmFsaWQpIHtcbiAgICAgICAgICAgIC8vIGFuaW1hdGUgdGhlIGNsdWUgYmFjayB0byB0aGUgc291cmNlIGl0ZW0gcG9zaXRpb24gaWYgbWFya2VkIGFzIGludmFsaWRcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLmFuaW1hdGVEcmFnQ2x1ZVRvRWxlbWVudFBvc2l0aW9uKHRoaXMuZHJhZ2dlZEl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeURyYWdFbmQoZHJhZ0VuZEV2ZW50KSB7XG4gICAgICAgIHRoaXMudHJlZXZpZXcubm9kZURyYWdFbmQuZW1pdChkcmFnRW5kRXZlbnQpO1xuICAgIH1cbiAgICBnZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRyZWVWaWV3VGFnTmFtZSA9IHRoaXMudHJlZXZpZXcuZWxlbWVudC5uYXRpdmVFbGVtZW50LnRhZ05hbWU7XG4gICAgICAgIGNvbnN0IHRhcmdldFRyZWVWaWV3ID0gY2xvc2VzdFdpdGhNYXRjaChkcm9wVGFyZ2V0LCB0cmVlVmlld1RhZ05hbWUpO1xuICAgICAgICByZXR1cm4gW3RoaXMudHJlZXZpZXcsIC4uLnRoaXMuZHJvcFpvbmVUcmVlVmlld3NdLmZpbmQodHJlZVZpZXcgPT4gaXNQcmVzZW50KHRyZWVWaWV3KSAmJiB0cmVlVmlldy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgPT09IHRhcmdldFRyZWVWaWV3KTtcbiAgICB9XG4gICAgZGlzYWJsZUFuaW1hdGlvbnNGb3JOZXh0VGljayh0cmVlVmlldykge1xuICAgICAgICAvLyB0aGUgdHJlZVZpZXcuYW5pbWF0ZSBnZXR0ZXIgcmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgYW5pbWF0aW9ucyBhcmUgdHVybmVkIG9mZlxuICAgICAgICAvLyBjb25mdXNpbmcsIGJ1dCBzZWVtcyBvbiBwdXJwb3NlICh0aGUgYGFuaW1hdGVgIHByb3Agc2V0cyB0aGUgdmFsdWUgb2YgdGhlIEAuZGlzYWJsZWQgaG9zdC1ib3VuZCBhdHRyaWJ1dGUpXG4gICAgICAgIGlmICh0cmVlVmlldy5hbmltYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJlZVZpZXcuYW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gc2V0VGltZW91dCgoKSA9PiB0cmVlVmlldy5hbmltYXRlID0gdHJ1ZSkpO1xuICAgIH1cbiAgICBzaG91bGRJbml0aWF0ZURyYWdTdGFydChjdXJyZW50UG9pbnRlckNvb3Jkcykge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnBlbmRpbmdEcmFnU3RhcnRFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXN0YW5jZUZyb21Qb2ludGVyRG93biA9IE1hdGguc3FydChNYXRoLnBvdygodGhpcy5wZW5kaW5nRHJhZ1N0YXJ0RXZlbnQuY2xpZW50WCAtIGN1cnJlbnRQb2ludGVyQ29vcmRzLmNsaWVudFgpLCAyKSArXG4gICAgICAgICAgICBNYXRoLnBvdygodGhpcy5wZW5kaW5nRHJhZ1N0YXJ0RXZlbnQuY2xpZW50WSAtIGN1cnJlbnRQb2ludGVyQ29vcmRzLmNsaWVudFkpLCAyKSk7XG4gICAgICAgIHJldHVybiBkaXN0YW5jZUZyb21Qb2ludGVyRG93biA+PSB0aGlzLnN0YXJ0RHJhZ0FmdGVyO1xuICAgIH1cbiAgICBpbml0aWF0ZURyYWdTdGFydCgpIHtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLnRyZWV2aWV3Lm5vZGVEcmFnU3RhcnQpKSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5ub3RpZnlEcmFnU3RhcnQodGhpcy5wZW5kaW5nRHJhZ1N0YXJ0RXZlbnQsIGdldERyb3BUYXJnZXQodGhpcy5wZW5kaW5nRHJhZ1N0YXJ0RXZlbnQpKSk7XG4gICAgICAgICAgICBpZiAoZHJhZ1N0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEcmFnU3RhcnRFdmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2VkSXRlbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLmNhbmNlbFJldHVybkFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS51cGRhdGVUZXh0KHRoaXMuZHJhZ2dlZEl0ZW0uaW5uZXJUZXh0KTtcbiAgICAgICAgdGhpcy5jb250YWluZXJPZmZzZXQgPSBnZXRDb250YWluZXJPZmZzZXQodGhpcy5kcmFnZ2VkSXRlbSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0RyYWdTdGFydEV2ZW50ID0gbnVsbDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyYWdBbmREcm9wRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGxvd0NvcHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgRHJhZ0FuZERyb3BEaXJlY3RpdmUucHJvdG90eXBlLCBcImRyb3Bab25lVHJlZVZpZXdzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEcmFnQW5kRHJvcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3RhcnREcmFnQWZ0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERyYWdBbmREcm9wRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhdXRvU2Nyb2xsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoRHJhZ0NsdWVUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRHJhZ0FuZERyb3BEaXJlY3RpdmUucHJvdG90eXBlLCBcImRyYWdDbHVlVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChEcm9wSGludFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERyb3BIaW50VGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBEcmFnQW5kRHJvcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZHJvcEhpbnRUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLnVzZXItc2VsZWN0JyksXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLi1tcy11c2VyLXNlbGVjdCcpLFxuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS4tbW96LXVzZXItc2VsZWN0JyksXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLi13ZWJraXQtdXNlci1zZWxlY3QnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRHJhZ0FuZERyb3BEaXJlY3RpdmUucHJvdG90eXBlLCBcInVzZXJTZWxlY3RTdHlsZVwiLCB2b2lkIDApO1xuRHJhZ0FuZERyb3BEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3RHJhZ0FuZERyb3BdJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBEcmFnQ2x1ZVNlcnZpY2UsXG4gICAgICAgICAgICBEcm9wSGludFNlcnZpY2VcbiAgICAgICAgXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgTmdab25lLFxuICAgICAgICBUcmVlVmlld0NvbXBvbmVudCxcbiAgICAgICAgRHJhZ0NsdWVTZXJ2aWNlLFxuICAgICAgICBEcm9wSGludFNlcnZpY2VdKVxuXSwgRHJhZ0FuZERyb3BEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgREVGQVVMVF9GSUxURVJfU0VUVElOR1MgPSB7XG4gICAgb3BlcmF0b3I6ICdjb250YWlucycsXG4gICAgaWdub3JlQ2FzZTogdHJ1ZSxcbiAgICBtb2RlOiBcImxlbmllbnRcIlxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEZpbHRlcmluZ0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy52aXNpYmxlTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNldHRpbmdzID0gREVGQVVMVF9GSUxURVJfU0VUVElOR1M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzZXR0aW5ncyB3aGljaCBhcmUgYXBwbGllZCB3aGVuIHBlcmZvcm1pbmcgYSBmaWx0ZXIgb24gdGhlIGNvbXBvbmVudCdzIGRhdGEuXG4gICAgICovXG4gICAgc2V0IGZpbHRlclNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9GSUxURVJfU0VUVElOR1MsIHNldHRpbmdzKTtcbiAgICB9XG4gICAgZ2V0IGZpbHRlclNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyU2V0dGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBmaWx0ZXIgYW5kIGNoYW5nZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGNvbXBvbmVudCdzIG5vZGVzIGFjY29yZGluZ2x5LlxuICAgICAqL1xuICAgIHNldCBmaWx0ZXIodGVybSkge1xuICAgICAgICB0aGlzLmhhbmRsZUZpbHRlckNoYW5nZSh0ZXJtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUZpbHRlckNoYW5nZSh0ZXJtKSB7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldE5vZGVzVmlzaWJpbGl0eSh0aGlzLmZpbHRlckRhdGEpO1xuICAgICAgICBpZiAodGVybSkge1xuICAgICAgICAgICAgZmlsdGVyVHJlZSh0aGlzLmZpbHRlckRhdGEsIHRlcm0sIHRoaXMuZmlsdGVyU2V0dGluZ3MsIHRoaXMuY29tcG9uZW50LnRleHRGaWVsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmxlTm9kZXModGhpcy5maWx0ZXJEYXRhKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmNvbXBvbmVudC5maWx0ZXJTdGF0ZUNoYW5nZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmZpbHRlclN0YXRlQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgICAgIG5vZGVzOiB0aGlzLmZpbHRlckRhdGEsXG4gICAgICAgICAgICAgICAgbWF0Y2hDb3VudDogdGhpcy52aXNpYmxlTm9kZXMuc2l6ZSxcbiAgICAgICAgICAgICAgICB0ZXJtLFxuICAgICAgICAgICAgICAgIGZpbHRlclNldHRpbmdzOiB0aGlzLmZpbHRlclNldHRpbmdzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVWaXNpYmxlTm9kZXMoaXRlbXMpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgod3JhcHBlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZU5vZGVzLmFkZCh3cmFwcGVyLmRhdGFJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3cmFwcGVyLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaXNpYmxlTm9kZXMod3JhcHBlci5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNldE5vZGVzVmlzaWJpbGl0eShpdGVtcykge1xuICAgICAgICB0aGlzLnZpc2libGVOb2Rlcy5jbGVhcigpO1xuICAgICAgICBpdGVtcy5mb3JFYWNoKCh3cmFwcGVyKSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVyLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Tm9kZXNWaXNpYmlsaXR5KHdyYXBwZXIuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIEZpbHRlcmluZ0Jhc2UucHJvdG90eXBlLCBcImZpbHRlclNldHRpbmdzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBGaWx0ZXJpbmdCYXNlLnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgbnVsbCk7XG5cbmNvbnN0IGluZGV4QnVpbGRlciA9IG5ldyBJbmRleEJ1aWxkZXJTZXJ2aWNlKCk7XG5jb25zdCBtYXBUb1dyYXBwZXJzID0gKGN1cnJlbnRMZXZlbE5vZGVzLCBjaGlsZHJlbkZpZWxkLCBwYXJlbnQgPSBudWxsLCBwYXJlbnRJbmRleCA9ICcnKSA9PiB7XG4gICAgaWYgKCFpc0FycmF5V2l0aEF0TGVhc3RPbmVJdGVtKGN1cnJlbnRMZXZlbE5vZGVzKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50TGV2ZWxOb2Rlcy5tYXAoKG5vZGUsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGluZGV4QnVpbGRlci5ub2RlSW5kZXgoaWR4LnRvU3RyaW5nKCksIHBhcmVudEluZGV4KTtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHtcbiAgICAgICAgICAgIGRhdGFJdGVtOiBub2RlLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHdyYXBwZXIuY2hpbGRyZW4gPSBtYXBUb1dyYXBwZXJzKGdldHRlcihjaGlsZHJlbkZpZWxkKShub2RlKSwgY2hpbGRyZW5GaWVsZCwgd3JhcHBlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9KTtcbn07XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgcmV0cmlldmFsIG9mIGNoaWxkIG5vZGVzLlxuICovXG5sZXQgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSA9IGNsYXNzIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUgZXh0ZW5kcyBGaWx0ZXJpbmdCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIGRyYWdBbmREcm9wRGlyZWN0aXZlKSB7XG4gICAgICAgIHN1cGVyKGNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmRyYWdBbmREcm9wRGlyZWN0aXZlID0gZHJhZ0FuZERyb3BEaXJlY3RpdmU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvYWRPbkRlbWFuZCA9IHRydWU7XG4gICAgICAgIHRoaXMub3JpZ2luYWxEYXRhID0gW107XG4gICAgICAgIGNvbnN0IHNob3VsZEZpbHRlciA9ICFpc1ByZXNlbnQodGhpcy5kcmFnQW5kRHJvcERpcmVjdGl2ZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmlzVmlzaWJsZSA9IHNob3VsZEZpbHRlciA/IChub2RlKSA9PiB0aGlzLnZpc2libGVOb2Rlcy5oYXMobm9kZSkgOiBpc1Zpc2libGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCBuYW1lIHdoaWNoIGhvbGRzIHRoZSBkYXRhIGl0ZW1zIG9mIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2V0IGNoaWxkcmVuRmllbGQodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2NoaWxkcmVuRmllbGQnIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGlsZHJlbkZpZWxkID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBub2RlcyB3aGljaCB3aWxsIGJlIGRpc3BsYXllZCBieSB0aGUgVHJlZVZpZXcuXG4gICAgICovXG4gICAgc2V0IG5vZGVzKHZhbHVlcykge1xuICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IHZhbHVlcyB8fCBbXTtcbiAgICAgICAgdGhpcy5maWx0ZXJEYXRhID0gbWFwVG9XcmFwcGVycyh2YWx1ZXMsIHRoaXMuY2hpbGRyZW5GaWVsZCkgfHwgW107XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJsZU5vZGVzKHRoaXMuZmlsdGVyRGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBBIGNhbGxiYWNrIHdoaWNoIGRldGVybWluZXMgd2hldGhlciBhIFRyZWVWaWV3IG5vZGUgc2hvdWxkIGJlIHJlbmRlcmVkIGFzIGhpZGRlbi5cbiAgICAgKi9cbiAgICBzZXQgaXNWaXNpYmxlKGZuKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmlzVmlzaWJsZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQgbmFtZSB3aGljaCBob2xkcyB0aGUgZGF0YSBpdGVtcyBvZiB0aGUgY2hpbGQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGdldCBjaGlsZHJlbkZpZWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5GaWVsZDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jaGlsZHJlbkZpZWxkKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuY2hpbGRyZW4gPSBpdGVtID0+IG9mKGdldHRlcih0aGlzLmNoaWxkcmVuRmllbGQpKGl0ZW0pKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lmhhc0NoaWxkcmVuID0gaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXR0ZXIodGhpcy5jaGlsZHJlbkZpZWxkKShpdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmVkaXRTZXJ2aWNlID0gbmV3IEhpZXJhcmNoeUVkaXRpbmdTZXJ2aWNlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuZmlsdGVyQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUZpbHRlckNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUZpbHRlckNoYW5nZSh0aGlzLmNvbXBvbmVudC5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRPbkRlbWFuZCAmJiBpc1ByZXNlbnQodGhpcy5jb21wb25lbnQucHJlbG9hZENoaWxkTm9kZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHJlbG9hZENoaWxkTm9kZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ2NoaWxkcmVuRmllbGQnLCBjaGFuZ2VzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSB0aGlzLm9yaWdpbmFsRGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaG91bGQgcmVhY3QgdG8gY2hhbmdlcy5sb2FkT25EZW1hbmQgYXMgd2VsbCAtIHNob3VsZCBwcmVsb2FkIHRoZSBkYXRhIG9yIGNsZWFyIHRoZSBhbHJlYWR5IGNhY2hlZCBpdGVtc1xuICAgICAgICBpZiAoYW55Q2hhbmdlZChbJ25vZGVzJywgJ2xvYWRPbkRlbWFuZCddLCBjaGFuZ2VzKSAmJiAhdGhpcy5sb2FkT25EZW1hbmQgJiYgaXNQcmVzZW50KHRoaXMuY29tcG9uZW50LnByZWxvYWRDaGlsZE5vZGVzKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHJlbG9hZENoaWxkTm9kZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUucHJvdG90eXBlLCBcImNoaWxkcmVuRmllbGRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJub2Rlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Z1bmN0aW9uXSlcbl0sIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUucHJvdG90eXBlLCBcImlzVmlzaWJsZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2FkT25EZW1hbmRcIiwgdm9pZCAwKTtcbkhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3SGllcmFyY2h5QmluZGluZ10nIH0pLFxuICAgIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMSwgSG9zdCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGFCb3VuZENvbXBvbmVudCxcbiAgICAgICAgRHJhZ0FuZERyb3BEaXJlY3RpdmVdKVxuXSwgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTG9hZGluZ0luZGljYXRvckRpcmVjdGl2ZSA9IGNsYXNzIExvYWRpbmdJbmRpY2F0b3JEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGV4cGFuZFNlcnZpY2UsIGxvYWRpbmdTZXJ2aWNlLCBjZCkge1xuICAgICAgICB0aGlzLmV4cGFuZFNlcnZpY2UgPSBleHBhbmRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvYWRpbmdTZXJ2aWNlID0gbG9hZGluZ1NlcnZpY2U7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbG9hZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRpbmc7XG4gICAgfVxuICAgIHNldCBsb2FkaW5nKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IGxvYWRpbmdOb3RpZmljYXRpb25zID0gdGhpcy5sb2FkaW5nU2VydmljZVxuICAgICAgICAgICAgLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcihpbmRleCA9PiBpbmRleCA9PT0gdGhpcy5pbmRleCkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuZXhwYW5kU2VydmljZVxuICAgICAgICAgICAgLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoeyBpbmRleCB9KSA9PiBpbmRleCA9PT0gdGhpcy5pbmRleCksIHRhcCgoeyBleHBhbmQgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFleHBhbmQgJiYgdGhpcy5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBmaWx0ZXIoKHsgZXhwYW5kIH0pID0+IGV4cGFuZCksIHN3aXRjaE1hcCh4ID0+IG9mKHgpLnBpcGUoZGVsYXkoMTAwKSwgdGFrZVVudGlsKGxvYWRpbmdOb3RpZmljYXRpb25zKSkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmxvYWRpbmcgPSB0cnVlKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24uYWRkKGxvYWRpbmdOb3RpZmljYXRpb25zLnN1YnNjcmliZSgoKSA9PiB0aGlzLmxvYWRpbmcgPSBmYWxzZSkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1pLWxvYWRpbmdcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBMb2FkaW5nSW5kaWNhdG9yRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2FkaW5nXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoXCJrZW5kb1RyZWVWaWV3TG9hZGluZ1wiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTG9hZGluZ0luZGljYXRvckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaW5kZXhcIiwgdm9pZCAwKTtcbkxvYWRpbmdJbmRpY2F0b3JEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3TG9hZGluZ10nIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRXhwYW5kU3RhdGVTZXJ2aWNlLFxuICAgICAgICBMb2FkaW5nTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgTG9hZGluZ0luZGljYXRvckRpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICogUGVyZm9ybXMgdGhlIHJpZ2h0LXRvLWxlZnQgZnVuY3Rpb24gY29tcG9zaXRpb24uIEZ1bmN0aW9ucyBtdXN0IGhhdmUgYSB1bmFyeS5cbiAqL1xuY29uc3QgY29tcG9zZSA9ICguLi5hcmdzKSA9PiAoZGF0YSkgPT4gYXJncy5yZWR1Y2VSaWdodCgoYWNjLCBjdXJyKSA9PiBjdXJyKGFjYyksIGRhdGEpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmxhdEVkaXRpbmdTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihmbGF0QmluZGluZykge1xuICAgICAgICB0aGlzLmZsYXRCaW5kaW5nID0gZmxhdEJpbmRpbmc7XG4gICAgfVxuICAgIGFkZCh7IHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSwgZHJvcFBvc2l0aW9uLCBzb3VyY2VUcmVlLCBkZXN0aW5hdGlvblRyZWUgfSkge1xuICAgICAgICAvLyBzaGFsbG93IGNsb25lIHRoZSBpdGVtIGFzIG5vdCB0byBtaXN0YWtlIGl0IGZvciBpdHMgJ29sZGVyJyB2ZXJzaW9uIHdoZW4gdGhlIHJlbW92ZSBoYW5kbGVyIGtpY2tzIGluIHRvIHNwbGljZSB0aGUgaXRlbSBhdCBpdHMgb2xkIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGNsb25lZFNvdXJjZURhdGFJdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RGF0YUl0ZW0oc291cmNlSXRlbSkpO1xuICAgICAgICBpZiAoZHJvcFBvc2l0aW9uID09PSBEcm9wUG9zaXRpb24uT3Zlcikge1xuICAgICAgICAgICAgLy8gZXhwYW5kIHRoZSBpdGVtIHRoYXQgd2FzIGRyb3BwZWQgaW50b1xuICAgICAgICAgICAgZXhwYW5kRHJvcFRhcmdldChkZXN0aW5hdGlvbkl0ZW0sIGRlc3RpbmF0aW9uVHJlZSk7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkl0ZW1JZCA9IGdldHRlcih0aGlzLmZsYXRCaW5kaW5nLmlkRmllbGQpKGdldERhdGFJdGVtKGRlc3RpbmF0aW9uSXRlbSkpO1xuICAgICAgICAgICAgc2V0dGVyKHRoaXMuZmxhdEJpbmRpbmcucGFyZW50SWRGaWVsZCkoY2xvbmVkU291cmNlRGF0YUl0ZW0sIGRlc3RpbmF0aW9uSXRlbUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZE5vZGVJbmRleCA9IHRoaXMuZ2V0TGFzdFZpc2libGVDaGlsZE5vZGVJbmRleChkZXN0aW5hdGlvblRyZWUsIHRoaXMuZmxhdEJpbmRpbmcub3JpZ2luYWxEYXRhLCBnZXREYXRhSXRlbShkZXN0aW5hdGlvbkl0ZW0pKTtcbiAgICAgICAgICAgIC8vIGluc2VydCBhZnRlciB0aGUgbGFzdCB2aXNpYmxlIGNoaWxkXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGxhc3RDaGlsZE5vZGVJbmRleCArIDE7XG4gICAgICAgICAgICB0aGlzLmZsYXRCaW5kaW5nLm9yaWdpbmFsRGF0YS5zcGxpY2UodGFyZ2V0SW5kZXgsIDAsIGNsb25lZFNvdXJjZURhdGFJdGVtKTtcbiAgICAgICAgICAgIC8vIHJlYmluZCB0aGUgdHJlZXZpZXcgZGF0YSBiZWZvcmUgc2VhcmNoaW5nIGZvciB0aGUgZm9jdXMgdGFyZ2V0IGluZGV4XG4gICAgICAgICAgICB0aGlzLnJlYmluZERhdGEoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzVGFyZ2V0ID0gdGhpcy5mZXRjaENoaWxkTm9kZXMoZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtKSwgZGVzdGluYXRpb25UcmVlKS5pbmRleE9mKGNsb25lZFNvdXJjZURhdGFJdGVtKTtcbiAgICAgICAgICAgIHRoaXMubW92ZWRJdGVtTmV3SW5kZXggPSBidWlsZFRyZWVJbmRleChkZXN0aW5hdGlvbkl0ZW0uaXRlbS5pbmRleCwgZm9jdXNUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRJbmRleCA9IGRyb3BQb3NpdGlvbiA9PT0gRHJvcFBvc2l0aW9uLkFmdGVyID8gMSA6IDA7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuZmxhdEJpbmRpbmcub3JpZ2luYWxEYXRhLmluZGV4T2YoZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtKSkgKyBzaGlmdEluZGV4O1xuICAgICAgICAgICAgdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGEuc3BsaWNlKHRhcmdldEluZGV4LCAwLCBjbG9uZWRTb3VyY2VEYXRhSXRlbSk7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkl0ZW1QYXJlbnRJZCA9IGdldHRlcih0aGlzLmZsYXRCaW5kaW5nLnBhcmVudElkRmllbGQpKGdldERhdGFJdGVtKGRlc3RpbmF0aW9uSXRlbSkpO1xuICAgICAgICAgICAgc2V0dGVyKHRoaXMuZmxhdEJpbmRpbmcucGFyZW50SWRGaWVsZCkoY2xvbmVkU291cmNlRGF0YUl0ZW0sIGRlc3RpbmF0aW9uSXRlbVBhcmVudElkKTtcbiAgICAgICAgICAgIC8vIHJlYmluZCB0aGUgdHJlZXZpZXcgZGF0YSBiZWZvcmUgc2VhcmNoaW5nIGZvciB0aGUgZm9jdXMgdGFyZ2V0IGluZGV4XG4gICAgICAgICAgICB0aGlzLnJlYmluZERhdGEoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEluZGV4ID0gZGVzdGluYXRpb25JdGVtLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25JdGVtLnBhcmVudC5pdGVtLmluZGV4IDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Q29udGFpbmVyID0gZGVzdGluYXRpb25JdGVtLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgdGhpcy5mZXRjaENoaWxkTm9kZXMoZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtLnBhcmVudCksIGRlc3RpbmF0aW9uVHJlZSkgOlxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uVHJlZS5ub2RlcztcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzVGFyZ2V0ID0gcGFyZW50Q29udGFpbmVyLmluZGV4T2YoY2xvbmVkU291cmNlRGF0YUl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5tb3ZlZEl0ZW1OZXdJbmRleCA9IGJ1aWxkVHJlZUluZGV4KHBhcmVudEluZGV4LCBmb2N1c1RhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgIT09IGRlc3RpbmF0aW9uVHJlZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZE5vZGVzKGNsb25lZFNvdXJjZURhdGFJdGVtLCBzb3VyY2VUcmVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIHBhcmVudCBwYWdlIHNpemUgPT4gYW4gaXRlbSBpcyBtb3ZlZCBpbnRvIGl0XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRQYXJlbnQgPSBkcm9wUG9zaXRpb24gPT09IERyb3BQb3NpdGlvbi5PdmVyID8gZ2V0RGF0YUl0ZW0oZGVzdGluYXRpb25JdGVtKSA6IGdldERhdGFJdGVtKGRlc3RpbmF0aW9uSXRlbS5wYXJlbnQpO1xuICAgICAgICBpbmNyZW1lbnRQYWdlU2l6ZShkZXN0aW5hdGlvblRyZWUsIHVwZGF0ZWRQYXJlbnQpO1xuICAgICAgICAvLyB0aGUgcGFnZSBzaXplcyBhcmUgc3RvcmVkIGJ5IGRhdGEtaXRlbSByZWZlcmVuY2UgPT4gY29weSB0aGUgb2xkIGl0ZW0gcmVmIHBhZ2Ugc2l6ZSB0byB0aGUgbmV3IGl0ZW0gcmVmZXJlbmNlXG4gICAgICAgIGNvcHlQYWdlU2l6ZShkZXN0aW5hdGlvblRyZWUsIGdldERhdGFJdGVtKHNvdXJjZUl0ZW0pLCBjbG9uZWRTb3VyY2VEYXRhSXRlbSk7XG4gICAgICAgIC8vIHRoZSBzb3VyY2UgdHJlZSBub2RlcyBhcmUgcmVsb2FkZWQgb24gYHJlbW92ZUl0ZW1gIC0gcmVsb2FkIHRoZSBkZXN0aW5hdGlvbiB0cmVlIG5vZGVzIGlmIHRoZSBzb3J1Y2UgYW5kIHRoZSBkZXN0aW5hdGlvbiB0cmVlIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgIT09IGRlc3RpbmF0aW9uVHJlZSAmJiAhZGVzdGluYXRpb25UcmVlLmxvYWRPbkRlbWFuZCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25UcmVlLnByZWxvYWRDaGlsZE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gdHJlZXMgYXJlIHRoZSBzYW1lLCBmb2N1c2luZyB0aGUgbW92ZWQgaXRlbSBoZXJlIHdpbGwgbm90IGhhdmUgdGhlIGRlc2lyZWQgZWZmZWN0XG4gICAgICAgIC8vIGFzIHRoZSBgcmVtb3ZlYCBoYW5kbGVyIGhhcyBub3QgeWV0IGtpY2tlZC1pbiB0byByZW1vdmUgdGhlIGl0ZW0gZnJvbSBpdHMgb2xkIHBvc2l0aW9uXG4gICAgICAgIGlmIChzb3VyY2VUcmVlICE9PSBkZXN0aW5hdGlvblRyZWUpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGUgZm9jdXMgdGFyZ2V0IGlzIHJlbmRlcmVkIGFuZCByZWdpc3RlcmVkXG4gICAgICAgICAgICBkZXN0aW5hdGlvblRyZWUuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgZGVzdGluYXRpb25UcmVlLmZvY3VzKHRoaXMubW92ZWRJdGVtTmV3SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSh7IHNvdXJjZUl0ZW0sIHNvdXJjZVRyZWUsIGRlc3RpbmF0aW9uVHJlZSB9KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZURhdGFJdGVtID0gZ2V0RGF0YUl0ZW0oc291cmNlSXRlbSk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUl0ZW1JbmRleCA9IHRoaXMuZmxhdEJpbmRpbmcub3JpZ2luYWxEYXRhLmluZGV4T2Yoc291cmNlRGF0YUl0ZW0pO1xuICAgICAgICB0aGlzLmZsYXRCaW5kaW5nLm9yaWdpbmFsRGF0YS5zcGxpY2Uoc291cmNlSXRlbUluZGV4LCAxKTtcbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgIT09IGRlc3RpbmF0aW9uVHJlZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZE5vZGVzKHNvdXJjZURhdGFJdGVtLCBzb3VyY2VUcmVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYmluZERhdGEoKTtcbiAgICAgICAgLy8gZW1pdCBjb2xsYXBzZSBmb3IgdGhlIHBhcmVudCBub2RlIGlmIGl0cyBsYXN0IGNoaWxkIG5vZGUgd2FzIHNwbGljZWRcbiAgICAgICAgY29uc3QgcGFyZW50Q2hpbGRyZW4gPSBzb3VyY2VJdGVtLnBhcmVudCA/IHNvdXJjZUl0ZW0ucGFyZW50LmNoaWxkcmVuIDogW107XG4gICAgICAgIGNvbGxhcHNlRW1wdHlQYXJlbnQoc291cmNlSXRlbS5wYXJlbnQsIHBhcmVudENoaWxkcmVuLCBzb3VyY2VUcmVlKTtcbiAgICAgICAgLy8gZGVjcmVtZW50IHNvdXJjZSBpdGVtIHBhcmVudCBwYWdlIHNpemUgPT4gYW4gaXRlbSBoYXMgYmVlbiByZW1vdmVkIGZyb20gaXRcbiAgICAgICAgZGVjcmVtZW50UGFnZVNpemUoc291cmNlVHJlZSwgZ2V0RGF0YUl0ZW0oc291cmNlSXRlbS5wYXJlbnQpKTtcbiAgICAgICAgLy8gcmVsb2FkIHRoZSB0cmVldmlldyBub2Rlc1xuICAgICAgICBpZiAoIXNvdXJjZVRyZWUubG9hZE9uRGVtYW5kKSB7XG4gICAgICAgICAgICBzb3VyY2VUcmVlLnByZWxvYWRDaGlsZE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gdHJlZXMgYXJlIGRpZmZlcmVudCB3ZSB3YW50IHRvIGZvY3VzIG9ubHkgdGhlIG1vdmVkIGl0ZW0gaW4gdGhlIGRlc3RpbmF0aW9uIHRyZWVcbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgPT09IGRlc3RpbmF0aW9uVHJlZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBmb2N1cyB0YXJnZXQgaXMgcmVuZGVyZWQgYW5kIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uVHJlZS5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICAvLyBhZnRlciB0aGUgc291cmNlIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwb3NpdGlvbiwgdGhlIGNhbmRpZGF0ZSBpbmRleCBtaWdodCBoYXZlIHRvIGJlIGNvcnJlY3RlZFxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB1cGRhdGVNb3ZlZEl0ZW1JbmRleCh0aGlzLm1vdmVkSXRlbU5ld0luZGV4LCBzb3VyY2VJdGVtLml0ZW0uaW5kZXgpO1xuICAgICAgICAgICAgZGVzdGluYXRpb25UcmVlLmZvY3VzKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRDaGlsZE5vZGVzKGRhdGFJdGVtLCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgaXRlbUNoaWxkcmVuID0gdGhpcy5mZXRjaEFsbERlc2NlbmRhbnROb2RlcyhkYXRhSXRlbSwgc291cmNlKTtcbiAgICAgICAgdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGEucHVzaCguLi5pdGVtQ2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZE5vZGVzKGRhdGFJdGVtLCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgc291cmNlQ2hpbGRyZW4gPSB0aGlzLmZldGNoQWxsRGVzY2VuZGFudE5vZGVzKGRhdGFJdGVtLCBzb3VyY2UpO1xuICAgICAgICBzb3VyY2VDaGlsZHJlbi5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZsYXRCaW5kaW5nLm9yaWdpbmFsRGF0YS5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWxsRGVzY2VuZGFudE5vZGVzKG5vZGUsIHRyZWV2aWV3KSB7XG4gICAgICAgIGxldCBub2RlcyA9IHRoaXMuZmV0Y2hDaGlsZE5vZGVzKG5vZGUsIHRyZWV2aWV3KTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGVzID0gbm9kZXMuY29uY2F0KHRoaXMuZmV0Y2hBbGxEZXNjZW5kYW50Tm9kZXMobm9kZSwgdHJlZXZpZXcpIHx8IFtdKSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgZmV0Y2hDaGlsZE5vZGVzKG5vZGUsIHRyZWV2aWV3KSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgICB0cmVldmlld1xuICAgICAgICAgICAgLmNoaWxkcmVuKG5vZGUpXG4gICAgICAgICAgICAucGlwZSh0YWtlKDEpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShjaGlsZHJlbiA9PiBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZHJlbiB8fCBbXSkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGdldExhc3RWaXNpYmxlQ2hpbGROb2RlSW5kZXgodHJlZXZpZXcsIGRhdGEsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodHJlZXZpZXcubG9hZE1vcmVTZXJ2aWNlKSB8fCAhdHJlZXZpZXcuaGFzQ2hpbGRyZW4obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlTm9kZXNDb3VudCA9IHRyZWV2aWV3LmxvYWRNb3JlU2VydmljZS5nZXRHcm91cFNpemUobm9kZSk7XG4gICAgICAgIGNvbnN0IHZpc2libGVDaGlsZHJlbiA9IHRoaXMuZmV0Y2hDaGlsZE5vZGVzKG5vZGUsIHRyZWV2aWV3KS5zbGljZSgwLCB2aXNpYmxlTm9kZXNDb3VudCk7XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlID0gdmlzaWJsZUNoaWxkcmVuW3Zpc2libGVDaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgbGFzdE5vZGVJbmRleCA9IGRhdGEuaW5kZXhPZihsYXN0Tm9kZSk7XG4gICAgICAgIHJldHVybiBsYXN0Tm9kZUluZGV4O1xuICAgIH1cbiAgICByZWJpbmREYXRhKCkge1xuICAgICAgICB0aGlzLmZsYXRCaW5kaW5nLm5vZGVzID0gdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGE7XG4gICAgfVxufVxuXG5jb25zdCBmaW5kQ2hpbGRyZW4gPSAocHJvcCwgbm9kZXMsIHZhbHVlKSA9PiBub2Rlcy5maWx0ZXIoKHgpID0+IHByb3AoeCkgPT09IHZhbHVlKTtcbmNvbnN0IGluZGV4QnVpbGRlciQxID0gbmV3IEluZGV4QnVpbGRlclNlcnZpY2UoKTtcbmNvbnN0IG1hcFRvVHJlZSA9IChjdXJyZW50TGV2ZWxOb2RlcywgYWxsTm9kZXMsIHBhcmVudElkRmllbGQsIGlkRmllbGQsIHBhcmVudCA9IG51bGwsIHBhcmVudEluZGV4ID0gJycpID0+IHtcbiAgICBpZiAoIWlzQXJyYXlXaXRoQXRMZWFzdE9uZUl0ZW0oY3VycmVudExldmVsTm9kZXMpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRMZXZlbE5vZGVzLm1hcCgobm9kZSwgaWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhCdWlsZGVyJDEubm9kZUluZGV4KGlkeC50b1N0cmluZygpLCBwYXJlbnRJbmRleCk7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB7XG4gICAgICAgICAgICBkYXRhSXRlbTogbm9kZSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB3cmFwcGVyLmNoaWxkcmVuID0gbWFwVG9UcmVlKGZpbmRDaGlsZHJlbihnZXR0ZXIocGFyZW50SWRGaWVsZCksIGFsbE5vZGVzIHx8IFtdLCBnZXR0ZXIoaWRGaWVsZCkobm9kZSkpLCBhbGxOb2RlcywgcGFyZW50SWRGaWVsZCwgaWRGaWVsZCwgd3JhcHBlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9KTtcbn07XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgcmV0cmlldmFsIG9mIHRoZSBjaGlsZCBub2Rlcy5cbiAqL1xubGV0IEZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZSA9IGNsYXNzIEZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZSBleHRlbmRzIEZpbHRlcmluZ0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuICAgICAgICBzdXBlcihjb21wb25lbnQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZE9uRGVtYW5kID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZ2luYWxEYXRhID0gW107XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmlzVmlzaWJsZSA9IChub2RlKSA9PiB0aGlzLnZpc2libGVOb2Rlcy5oYXMobm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBub2RlcyB3aGljaCB3aWxsIGJlIGRpc3BsYXllZCBieSB0aGUgVHJlZVZpZXcuXG4gICAgICovXG4gICAgc2V0IG5vZGVzKHZhbHVlcykge1xuICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IHZhbHVlcyB8fCBbXTtcbiAgICAgICAgaWYgKCFpc051bGxPckVtcHR5U3RyaW5nKHRoaXMucGFyZW50SWRGaWVsZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSBnZXR0ZXIodGhpcy5wYXJlbnRJZEZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lm5vZGVzID0gdGhpcy5vcmlnaW5hbERhdGEuZmlsdGVyKGNvbXBvc2UoaXNCbGFuaywgcHJvcCkpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJEYXRhID0gbWFwVG9UcmVlKHRoaXMuY29tcG9uZW50Lm5vZGVzLCB0aGlzLm9yaWdpbmFsRGF0YSwgdGhpcy5wYXJlbnRJZEZpZWxkLCB0aGlzLmlkRmllbGQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaXNpYmxlTm9kZXModGhpcy5maWx0ZXJEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lm5vZGVzID0gdGhpcy5vcmlnaW5hbERhdGEuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEEgY2FsbGJhY2sgd2hpY2ggZGV0ZXJtaW5lcyB3aGV0aGVyIGEgVHJlZVZpZXcgbm9kZSBzaG91bGQgYmUgcmVuZGVyZWQgYXMgaGlkZGVuLlxuICAgICAqL1xuICAgIHNldCBpc1Zpc2libGUoZm4pIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuaXNWaXNpYmxlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBhcmVudElkRmllbGQpICYmIGlzUHJlc2VudCh0aGlzLmlkRmllbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBmZXRjaENoaWxkcmVuID0gKG5vZGUpID0+IGZpbmRDaGlsZHJlbihnZXR0ZXIodGhpcy5wYXJlbnRJZEZpZWxkKSwgdGhpcy5vcmlnaW5hbERhdGEgfHwgW10sIGdldHRlcih0aGlzLmlkRmllbGQpKG5vZGUpKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lmhhc0NoaWxkcmVuID0gKG5vZGUpID0+IGZldGNoQ2hpbGRyZW4obm9kZSkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmNoaWxkcmVuID0gKG5vZGUpID0+IG9mKGZldGNoQ2hpbGRyZW4obm9kZSkpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuZWRpdFNlcnZpY2UgPSBuZXcgRmxhdEVkaXRpbmdTZXJ2aWNlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuZmlsdGVyQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUZpbHRlckNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUZpbHRlckNoYW5nZSh0aGlzLmNvbXBvbmVudC5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRPbkRlbWFuZCAmJiBpc1ByZXNlbnQodGhpcy5jb21wb25lbnQucHJlbG9hZENoaWxkTm9kZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHJlbG9hZENoaWxkTm9kZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdwYXJlbnRJZEZpZWxkJywgY2hhbmdlcywgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gdGhpcy5vcmlnaW5hbERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdWxkIHJlYWN0IHRvIGNoYW5nZXMubG9hZE9uRGVtYW5kIGFzIHdlbGwgLSBzaG91bGQgcHJlbG9hZCB0aGUgZGF0YSBvciBjbGVhciB0aGUgYWxyZWFkeSBjYWNoZWQgaXRlbXNcbiAgICAgICAgaWYgKGFueUNoYW5nZWQoWydub2RlcycsICdsb2FkT25EZW1hbmQnXSwgY2hhbmdlcykgJiYgIXRoaXMubG9hZE9uRGVtYW5kICYmIGlzUHJlc2VudCh0aGlzLmNvbXBvbmVudC5wcmVsb2FkQ2hpbGROb2RlcykpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnByZWxvYWRDaGlsZE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJub2Rlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGFyZW50SWRGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpZEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2FkT25EZW1hbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Z1bmN0aW9uXSlcbl0sIEZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNWaXNpYmxlXCIsIG51bGwpO1xuRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6IFwiW2tlbmRvVHJlZVZpZXdGbGF0RGF0YUJpbmRpbmddXCIgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRhQm91bmRDb21wb25lbnRdKVxuXSwgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlKTtcblxuY29uc3QgYnVpbGRJdGVtID0gKGluZGV4LCBkYXRhSXRlbSkgPT4gKHsgZGF0YUl0ZW0sIGluZGV4IH0pO1xubGV0IGlkID0gMDtcbmNvbnN0IFRSRUVfSVRFTV9ST0xFID0gJ3RyZWVpdGVtJztcbmNvbnN0IEJVVFRPTl9ST0xFID0gJ2J1dHRvbic7XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBtYW5hZ2VzIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgVHJlZVZpZXcuXG4gKi9cbmxldCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUgPSBjbGFzcyBUcmVlVmlld0l0ZW1EaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGV4cGFuZFNlcnZpY2UsIG5hdmlnYXRpb25TZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlLCBsb29rdXBTZXJ2aWNlLCByZW5kZXJlciwgaWIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlID0gZXhwYW5kU2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvb2t1cFNlcnZpY2UgPSBsb29rdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuaWIgPSBpYjtcbiAgICAgICAgdGhpcy5yb2xlID0gVFJFRV9JVEVNX1JPTEU7XG4gICAgICAgIHRoaXMubG9hZE9uRGVtYW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcmlhQ2hlY2tlZCA9ICdmYWxzZSc7XG4gICAgICAgIHRoaXMuaWQgPSBpZCsrO1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHNldCBpc0NoZWNrZWQoY2hlY2tlZCkge1xuICAgICAgICBpZiAoY2hlY2tlZCA9PT0gJ2NoZWNrZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmFyaWFDaGVja2VkID0gJ3RydWUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoZWNrZWQgPT09ICdpbmRldGVybWluYXRlJykge1xuICAgICAgICAgICAgdGhpcy5hcmlhQ2hlY2tlZCA9ICdtaXhlZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFyaWFDaGVja2VkID0gJ2ZhbHNlJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNFeHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRXhwYW5kZWQgfHwgZmFsc2U7XG4gICAgfVxuICAgIHNldCBpc0V4cGFuZGVkKGlzRXhwYW5kZWQpIHtcbiAgICAgICAgdGhpcy5faXNFeHBhbmRlZCA9IGlzRXhwYW5kZWQ7XG4gICAgfVxuICAgIGdldCBpc1NlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZCB8fCBmYWxzZTtcbiAgICB9XG4gICAgc2V0IGlzU2VsZWN0ZWQoaXNTZWxlY3RlZCkge1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gaXNTZWxlY3RlZDtcbiAgICB9XG4gICAgZ2V0IGlzQnV0dG9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb2xlID09PSBCVVRUT05fUk9MRTtcbiAgICB9XG4gICAgZ2V0IHRyZWVJdGVtKCkge1xuICAgICAgICByZXR1cm4gYnVpbGRJdGVtKHRoaXMuaW5kZXgsIHRoaXMuZGF0YUl0ZW0pO1xuICAgIH1cbiAgICBnZXQgcGFyZW50VHJlZUl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudERhdGFJdGVtID8gYnVpbGRJdGVtKHRoaXMucGFyZW50SW5kZXgsIHRoaXMucGFyZW50RGF0YUl0ZW0pIDogbnVsbDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRPbkRlbWFuZCAmJiAhdGhpcy5pc0J1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5sb29rdXBTZXJ2aWNlLnJlZ2lzdGVySXRlbSh0aGlzLnRyZWVJdGVtLCB0aGlzLnBhcmVudFRyZWVJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyTmF2aWdhdGlvbkl0ZW0oKTtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCB0aGlzLnJvbGUpO1xuICAgICAgICB0aGlzLnNldEFyaWFBdHRyaWJ1dGVzKCk7XG4gICAgICAgIHRoaXMuc2V0RGlzYWJsZWRDbGFzcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRhYkluZGV4KCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgeyBpbmRleCwgaXNEaXNhYmxlZCB9ID0gY2hhbmdlcztcbiAgICAgICAgaWYgKGFueUNoYW5nZWQoWydpbmRleCcsICdjaGVja2FibGUnLCAnaXNDaGVja2VkJywgJ2V4cGFuZGFibGUnLCAnaXNFeHBhbmRlZCcsICdzZWxlY3RhYmxlJywgJ2lzU2VsZWN0ZWQnXSwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXJpYUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXREaXNhYmxlZENsYXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9hZE9uRGVtYW5kICYmICF0aGlzLmlzQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVMb29rdXBJdGVtKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZU5hdmlnYXRpb25JdGVtKGluZGV4KTtcbiAgICAgICAgaWYgKGFueUNoYW5nZWQoWydpc0Rpc2FibGVkJywgJ2lzVmlzaWJsZSddLCBjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVOb2RlQXZhaWxhYmlsaXR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UudW5yZWdpc3Rlckl0ZW0odGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmxvYWRPbkRlbWFuZCAmJiAhdGhpcy5pc0J1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5sb29rdXBTZXJ2aWNlLnVucmVnaXN0ZXJJdGVtKHRoaXMuaW5kZXgsIHRoaXMuZGF0YUl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5yZWR1Y2UoKGxpc3QsIGNhbGxiYWNrKSA9PiAoY2FsbGJhY2sudW5zdWJzY3JpYmUoKSwgbGlzdCksIFtdKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLm1vdmVzXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgobmF2U3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRhYkluZGV4KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0l0ZW0obmF2U3RhdGUuc2hvdWxkU2Nyb2xsKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5leHBhbmRzXG4gICAgICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCh7IGluZGV4IH0pID0+IGluZGV4ID09PSB0aGlzLmluZGV4ICYmICF0aGlzLmlzRGlzYWJsZWQpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHsgZXhwYW5kIH0pID0+IHRoaXMuZXhwYW5kKGV4cGFuZCkpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJlZ2lzdGVyTmF2aWdhdGlvbkl0ZW0oKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UucmVnaXN0ZXJJdGVtKHRoaXMuaWQsIHRoaXMuaW5kZXgsIHRoaXMuaXNEaXNhYmxlZCwgdGhpcy5pc0J1dHRvbiwgdGhpcy5pc1Zpc2libGUpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlSXRlbSgpO1xuICAgIH1cbiAgICBhY3RpdmF0ZUl0ZW0oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYXZpZ2F0aW9uU2VydmljZSA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblNlcnZpY2UgPSB0aGlzLnNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgc2VsZWN0aW9uU2VydmljZS5zZXRGaXJzdFNlbGVjdGVkKGluZGV4LCB0aGlzLmlzU2VsZWN0ZWQpO1xuICAgICAgICBpZiAoIW5hdmlnYXRpb25TZXJ2aWNlLmlzQWN0aXZlKGluZGV4KSAmJiBzZWxlY3Rpb25TZXJ2aWNlLmlzRmlyc3RTZWxlY3RlZChpbmRleCkpIHtcbiAgICAgICAgICAgIG5hdmlnYXRpb25TZXJ2aWNlLmFjdGl2YXRlSW5kZXgoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cGFuZChzaG91bGRFeHBhbmQpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlW3Nob3VsZEV4cGFuZCA/ICdleHBhbmQnIDogJ2NvbGxhcHNlJ10odGhpcy5pbmRleCwgdGhpcy5kYXRhSXRlbSk7XG4gICAgfVxuICAgIGlzRm9jdXNhYmxlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNEaXNhYmxlZCAmJiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmlzRm9jdXNhYmxlKHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICBmb2N1c0l0ZW0oc2Nyb2xsSW50b1ZpZXcgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkICYmIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuaXNBY3RpdmUodGhpcy5pbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKHsgcHJldmVudFNjcm9sbDogIXNjcm9sbEludG9WaWV3IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmVMb29rdXBJdGVtKGNoYW5nZXMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGRhdGFJdGVtLCBpbmRleCwgcGFyZW50RGF0YUl0ZW0sIHBhcmVudEluZGV4IH0gPSBjaGFuZ2VzO1xuICAgICAgICBpZiAoKGluZGV4ICYmIGluZGV4LmZpcnN0Q2hhbmdlKSB8fCAvL3NraXAgZmlyc3QgY2hhbmdlXG4gICAgICAgICAgICAoIWRhdGFJdGVtICYmICFpbmRleCAmJiAhcGFyZW50RGF0YUl0ZW0gJiYgIXBhcmVudEluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZEluZGV4ID0gKGluZGV4IHx8IHt9KS5wcmV2aW91c1ZhbHVlIHx8IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMubG9va3VwU2VydmljZS5yZXBsYWNlSXRlbShvbGRJbmRleCwgdGhpcy50cmVlSXRlbSwgdGhpcy5wYXJlbnRUcmVlSXRlbSk7XG4gICAgfVxuICAgIG1vdmVOYXZpZ2F0aW9uSXRlbShpbmRleENoYW5nZSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFZhbHVlLCBmaXJzdENoYW5nZSwgcHJldmlvdXNWYWx1ZSB9ID0gaW5kZXhDaGFuZ2U7XG4gICAgICAgIGlmICghZmlyc3RDaGFuZ2UgJiYgaXNQcmVzZW50KGN1cnJlbnRWYWx1ZSkgJiYgaXNQcmVzZW50KHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnVucmVnaXN0ZXJJdGVtKHRoaXMuaWQsIHByZXZpb3VzVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5yZWdpc3Rlckl0ZW0odGhpcy5pZCwgY3VycmVudFZhbHVlLCB0aGlzLmlzRGlzYWJsZWQsIHRoaXMuaXNCdXR0b24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZU5vZGVBdmFpbGFiaWxpdHkoKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICBpZiAodGhpcy5pc0Rpc2FibGVkIHx8ICF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgc2VydmljZS5hY3RpdmF0ZUNsb3Nlc3QodGhpcy5pbmRleCk7IC8vIGFjdGl2YXRlIGJlZm9yZSB1bnJlZ2lzdGVyIHRoZSBpdGVtXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJ2aWNlLmFjdGl2YXRlRm9jdXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VydmljZS51bnJlZ2lzdGVySXRlbSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgICAgICAgc2VydmljZS5yZWdpc3Rlckl0ZW0odGhpcy5pZCwgdGhpcy5pbmRleCwgdGhpcy5pc0Rpc2FibGVkLCB0aGlzLmlzQnV0dG9uLCB0aGlzLmlzVmlzaWJsZSk7XG4gICAgfVxuICAgIHNldEFyaWFBdHRyaWJ1dGVzKCkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1sZXZlbCcsIHRoaXMuaWIubGV2ZWwodGhpcy5pbmRleCkudG9TdHJpbmcoKSk7XG4gICAgICAgIC8vIGRvbid0IHJlbmRlciBhdHRyaWJ1dGVzIHdoZW4gdGhlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIGRvZXNuJ3QgYWxsb3cgdGhlIHNwZWNpZmllZCBzdGF0ZVxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRoaXMuZXhwYW5kYWJsZSA/IHRoaXMuaXNFeHBhbmRlZC50b1N0cmluZygpIDogbnVsbCk7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdGhpcy5zZWxlY3RhYmxlID8gdGhpcy5pc1NlbGVjdGVkLnRvU3RyaW5nKCkgOiBudWxsKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsIHRoaXMuY2hlY2thYmxlID8gdGhpcy5hcmlhQ2hlY2tlZCA6IG51bGwpO1xuICAgIH1cbiAgICBzZXREaXNhYmxlZENsYXNzKCkge1xuICAgICAgICB0aGlzLnNldENsYXNzKCdrLWRpc2FibGVkJywgdGhpcy5pc0Rpc2FibGVkKTtcbiAgICB9XG4gICAgc2V0Q2xhc3MoY2xhc3NOYW1lLCB0b2dnbGUpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gdG9nZ2xlID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyc7XG4gICAgICAgIHRoaXMucmVuZGVyZXJbYWN0aW9uXSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgdXBkYXRlVGFiSW5kZXgoKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIHRoaXMuaXNGb2N1c2FibGUoKSA/ICcwJyA6ICctMScpO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgYXR0cik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGF0dHIsIHZhbHVlKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVHJlZVZpZXdJdGVtRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkYXRhSXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJlZVZpZXdJdGVtRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVHJlZVZpZXdJdGVtRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXJlbnREYXRhSXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJlZVZpZXdJdGVtRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXJlbnRJbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJlZVZpZXdJdGVtRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJyb2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdJdGVtRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2FkT25EZW1hbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvdG90eXBlLCBcImNoZWNrYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3SXRlbURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2VsZWN0YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWVWaWV3SXRlbURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXhwYW5kYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvdG90eXBlLCBcImlzQ2hlY2tlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvdG90eXBlLCBcImlzRGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvdG90eXBlLCBcImlzVmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIFRyZWVWaWV3SXRlbURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNFeHBhbmRlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvdG90eXBlLCBcImlzU2VsZWN0ZWRcIiwgbnVsbCk7XG5UcmVlVmlld0l0ZW1EaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3SXRlbV0nIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgRXhwYW5kU3RhdGVTZXJ2aWNlLFxuICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgU2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgVHJlZVZpZXdMb29rdXBTZXJ2aWNlLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIEluZGV4QnVpbGRlclNlcnZpY2VdKVxuXSwgVHJlZVZpZXdJdGVtRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbWFuYWdlcyB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgdGhlIFRyZWVWaWV3LlxuICovXG5sZXQgVHJlZVZpZXdJdGVtQ29udGVudERpcmVjdGl2ZSA9IGNsYXNzIFRyZWVWaWV3SXRlbUNvbnRlbnREaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5hdmlnYXRpb25TZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlID0gbmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZSA9IHNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5pbml0aWFsU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IGlzU2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLm1vdmVzXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMudXBkYXRlRm9jdXNDbGFzcy5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5zZWxlY3RzXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKGluZGV4KSA9PiBpbmRleCA9PT0gdGhpcy5pbmRleCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChpbmRleCkgPT4gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdChpbmRleCwgdGhpcy5kYXRhSXRlbSkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnNlbGVjdGlvblNlcnZpY2UuY2hhbmdlc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkNsYXNzKHRoaXMuaXNTZWxlY3RlZCh0aGlzLmRhdGFJdGVtLCB0aGlzLmluZGV4KSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5pbml0aWFsU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkNsYXNzKHRoaXMuaW5pdGlhbFNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMuaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9jdXNDbGFzcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdXBkYXRlRm9jdXNDbGFzcygpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5pc0FjdGl2ZSh0aGlzLmluZGV4KSwgJ2stZm9jdXMnKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0aW9uQ2xhc3Moc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoc2VsZWN0ZWQsICdrLXNlbGVjdGVkJyk7XG4gICAgfVxuICAgIHJlbmRlcihhZGRDbGFzcywgY2xhc3NOYW1lKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IGFkZENsYXNzID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyc7XG4gICAgICAgIHRoaXMucmVuZGVyZXJbYWN0aW9uXSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVHJlZVZpZXdJdGVtQ29udGVudERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGF0YUl0ZW1cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRyZWVWaWV3SXRlbUNvbnRlbnREaXJlY3RpdmUucHJvdG90eXBlLCBcImluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVHJlZVZpZXdJdGVtQ29udGVudERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaW5pdGlhbFNlbGVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUcmVlVmlld0l0ZW1Db250ZW50RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpc1NlbGVjdGVkXCIsIHZvaWQgMCk7XG5UcmVlVmlld0l0ZW1Db250ZW50RGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0l0ZW1Db250ZW50XScgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgU2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgUmVuZGVyZXIyXSlcbl0sIFRyZWVWaWV3SXRlbUNvbnRlbnREaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBSZXByZXNlbnRzIHRoZSBDaGVja0JveCBjb21wb25lbnQgb2YgdGhlIEtlbmRvIFVJIFRyZWVWaWV3IGZvciBBbmd1bGFyLlxuICpcbiAqL1xubGV0IENoZWNrQm94Q29tcG9uZW50ID0gY2xhc3MgQ2hlY2tCb3hDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHJlbmRlcmVyLCBjaGFuZ2VEZXRlY3Rvcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgW2BpZGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvaWQpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gYF8ke2d1aWQoKX1gO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBbYHRhYmluZGV4YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy90YWJpbmRleCkgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFiaW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBzaXplIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpemUgPSAnbWVkaXVtJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2hhbmdlcyB0aGUgY2hlY2sgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tTdGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jaGVja1N0YXRlID0gJ25vbmUnO1xuICAgIH1cbiAgICAvL1hYWDogaW1wbGVtZW50IENvbXBvbmVudFZhbHVlQWNjZXNzb3JcbiAgICAvL1hYWDogZm9jdXMvYmx1ciBtZXRob2RzXG4gICAgZ2V0IGNsYXNzV3JhcHBlcigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tTdGF0ZSA9PT0gJ2luZGV0ZXJtaW5hdGUnO1xuICAgIH1cbiAgICBnZXQgY2hlY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tTdGF0ZSA9PT0gJ2NoZWNrZWQnO1xuICAgIH1cbiAgICBnZXQgY2hlY2tCb3hDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gYGstY2hlY2tib3ggJHt0aGlzLnNpemUgPyBnZXRTaXplQ2xhc3MoJ2NoZWNrYm94JywgdGhpcy5zaXplKSA6ICcnfSBrLXJvdW5kZWQtbWRgO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIFwidGFiaW5kZXhcIik7XG4gICAgfVxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgdGhpcy5jaGVja1N0YXRlID0gdGhpcy5pc0NoZWNrZWQodGhpcy5ub2RlLCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKGUpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBlLnRhcmdldC5jaGVja2VkID8gJ2NoZWNrZWQnIDogJ25vbmUnO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIFZpZXcgU3RhdGUgc28gdGhhdCBBbmd1bGFyIHVwZGF0ZXMgdGhlIGlucHV0IGlmIHRoZSBpc0NoZWNrZWQgdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgICAgdGhpcy5jaGVja1N0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB0aGlzLmNoZWNrU3RhdGVDaGFuZ2UuZW1pdChzdGF0ZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWNoZWNrYm94LXdyYXBwZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ2hlY2tCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImNsYXNzV3JhcHBlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENoZWNrQm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hlY2tCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImlzQ2hlY2tlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hlY2tCb3hDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENoZWNrQm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2hlY2tCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVGV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2hlY2tCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDaGVja0JveENvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoZWNrQm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjaGVja1N0YXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5DaGVja0JveENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hlY2tib3gnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICBbY2xhc3NdPVwiY2hlY2tCb3hDbGFzc2VzXCJcbiAgICAgICAgICAgIFtpZF09XCJpZFwiXG4gICAgICAgICAgICBbY2hlY2tlZF09XCJjaGVja2VkXCJcbiAgICAgICAgICAgIFtpbmRldGVybWluYXRlXT1cImluZGV0ZXJtaW5hdGVcIlxuICAgICAgICAgICAgW3RhYmluZGV4XT1cInRhYmluZGV4XCJcbiAgICAgICAgICAgIChjaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAvPlxuICAgICAgICA8bGFiZWxcbiAgICAgICAgICAgIGNsYXNzPVwiay1jaGVja2JveC1sYWJlbFwiXG4gICAgICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgIFtmb3JdPVwiaWRcIlxuICAgICAgICA+e3tsYWJlbFRleHR9fTwvbGFiZWw+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBDaGVja0JveENvbXBvbmVudCk7XG5cbmNvbnN0IENPTVBPTkVOVF9ESVJFQ1RJVkVTID0gW1xuICAgIENoZWNrQm94Q29tcG9uZW50XG5dO1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KSBkZWZpbml0aW9uIGZvciB0aGUgQ2hlY2tCb3ggY29tcG9uZW50LlxuICovXG5sZXQgQ2hlY2tCb3hNb2R1bGUgPSBjbGFzcyBDaGVja0JveE1vZHVsZSB7XG59O1xuQ2hlY2tCb3hNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgZXhwb3J0czogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTXVxuICAgIH0pXG5dLCBDaGVja0JveE1vZHVsZSk7XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggZW5hYmxlcyB0aGUgdXBkYXRlIG9mIHRoZSBpbml0aWFsbHkgcHJvdmlkZWQgZGF0YSBhcnJheSBkdXJpbmcgZHJhZy1hbmQtZHJvcC5cbiAqXG4gKiBFaXRoZXIgdXNlIHRoaXMgZGlyZWN0aXZlIGluIGNvbWJpbmF0aW9uIHdpdGggb25lIG9mIHRoZSBkYXRhIGJpbmRpbmcgZGlyZWN0aXZlcyAoW2BrZW5kb1RyZWVWaWV3SGllcmFyY2h5QmluZGluZ2BdKHslIHNsdWcgYXBpX3RyZWV2aWV3X2hpZXJhcmNoeWJpbmRpbmdkaXJlY3RpdmUgJX0pXG4gKiBvciBbYGtlbmRvVHJlZVZpZXdGbGF0RGF0YUJpbmRpbmdgXSh7JSBzbHVnIGFwaV90cmVldmlld19mbGF0ZGF0YWJpbmRpbmdkaXJlY3RpdmUgJX0pKSB3aGljaCBzZXQgdGhlaXIgb3duIGVkaXQgaGFuZGxlcnMsIG9yIHByb3ZpZGVcbiAqIHlvdXIgb3duIFtgZWRpdFNlcnZpY2VgXSh7JSBzbHVnIGFwaV90cmVldmlld19lZGl0c2VydmljZSAlfSkgdG8gdGhpcyBkaXJlY3RpdmUuIFRoZSBsYXR0ZXIgc3Vic2NyaWJlcyB0byBhbmQgY2FsbHMgdGhlXG4gKiBbYGFkZEl0ZW1gXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2MtYWRkaXRlbSkgYW5kIFtgcmVtb3ZlSXRlbWBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1yZW1vdmVpdGVtKVxuICogaGFuZGxlcnMgd2hlbiB0aGUgY29ycmVzcG9uZGluZyBldmVudHMgYXJlIHRyaWdnZXJlZCBieSB0aGUgVHJlZVZpZXcgY29tcG9uZW50LlxuICovXG5sZXQgRHJhZ0FuZERyb3BFZGl0aW5nRGlyZWN0aXZlID0gY2xhc3MgRHJhZ0FuZERyb3BFZGl0aW5nRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVldmlldykge1xuICAgICAgICB0aGlzLnRyZWV2aWV3ID0gdHJlZXZpZXc7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnRyZWV2aWV3LmFkZEl0ZW0uc3Vic2NyaWJlKHRoaXMuaGFuZGxlQWRkLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnRyZWV2aWV3LnJlbW92ZUl0ZW0uc3Vic2NyaWJlKHRoaXMuaGFuZGxlUmVtb3ZlLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBoYW5kbGVycyBjYWxsZWQgb24gZHJhZy1hbmQtZHJvcCBbYGFkZEl0ZW1gXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2MtYWRkaXRlbSlcbiAgICAgKiBhbmQgW2ByZW1vdmVJdGVtYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLXJlbW92ZWl0ZW0pIGV2ZW50cy5cbiAgICAgKi9cbiAgICBzZXQgZWRpdFNlcnZpY2Uoc2VydmljZSkge1xuICAgICAgICB0aGlzLnRyZWV2aWV3LmVkaXRTZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBoYW5kbGVBZGQoYXJncykge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnRyZWV2aWV3LmVkaXRTZXJ2aWNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBgZWRpdFNlcnZpY2VgIHByb3ZpZGVkLiBFaXRoZXIgcHJvdmlkZSB5b3VyIG93biBpbXBsZW1lbnRhdGlvbiBvciB1c2UgdGhpcyBkaXJlY3RpdmUgaW4gY29tYmluYXRpb24gd2l0aCBvbmUgb2YgdGhlIGRhdGEgYmluZGluZyBkaXJlY3RpdmVzIChga2VuZG9UcmVlVmlld0hpZXJhcmNoeUJpbmRpbmdgIG9yIGBrZW5kb1RyZWVWaWV3RmxhdERhdGFCaW5kaW5nYCkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmVldmlldy5lZGl0U2VydmljZS5hZGQoYXJncyk7XG4gICAgfVxuICAgIGhhbmRsZVJlbW92ZShhcmdzKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMudHJlZXZpZXcuZWRpdFNlcnZpY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGBlZGl0U2VydmljZWAgcHJvdmlkZWQuIEVpdGhlciBwcm92aWRlIHlvdXIgb3duIGltcGxlbWVudGF0aW9uIG9yIHVzZSB0aGlzIGRpcmVjdGl2ZSBpbiBjb21iaW5hdGlvbiB3aXRoIG9uZSBvZiB0aGUgZGF0YSBiaW5kaW5nIGRpcmVjdGl2ZXMgKGBrZW5kb1RyZWVWaWV3SGllcmFyY2h5QmluZGluZ2Agb3IgYGtlbmRvVHJlZVZpZXdGbGF0RGF0YUJpbmRpbmdgKS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyZWV2aWV3LmVkaXRTZXJ2aWNlLnJlbW92ZShhcmdzKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBEcmFnQW5kRHJvcEVkaXRpbmdEaXJlY3RpdmUucHJvdG90eXBlLCBcImVkaXRTZXJ2aWNlXCIsIG51bGwpO1xuRHJhZ0FuZERyb3BFZGl0aW5nRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0RyYWdBbmREcm9wRWRpdGluZ10nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUcmVlVmlld0NvbXBvbmVudF0pXG5dLCBEcmFnQW5kRHJvcEVkaXRpbmdEaXJlY3RpdmUpO1xuXG5jb25zdCBMT0FEX01PUkVfRE9DX0xJTkskMSA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy90cmVldmlldy9sb2FkLW1vcmUtYnV0dG9uLyc7XG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgZW5hYmxlcyB0aGUgZGlzcGxheSBvZiBvbmx5IGEgbGltaXRlZCBhbW91bnQgb2Ygbm9kZXMgcGVyIGxldmVsXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGxvYWRtb3JlYnV0dG9uX3RyZWV2aWV3ICV9KSkuXG4gKi9cbmxldCBMb2FkTW9yZURpcmVjdGl2ZSA9IGNsYXNzIExvYWRNb3JlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVldmlldykge1xuICAgICAgICB0aGlzLnRyZWV2aWV3ID0gdHJlZXZpZXc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBwYWdlIHNpemUgb2YgZWFjaCBub2RlIG92ZXIgZXhwYW5kL2NvbGxhcHNlIGN5Y2xlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFnZVNpemVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBhcyBhbiBpZGVudGlmaWVyIGZvciB0aGUgcm9vdCBwYWdlIHNpemUgYXMgdGhlIHJvb3QgY29sbGVjdGlvbiBvZiBub2RlcyBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIGEgZGF0YSBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yb290TGV2ZWxJZCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy50cmVldmlldy5sb2FkTW9yZVNlcnZpY2UgPSB7XG4gICAgICAgICAgICBnZXRJbml0aWFsUGFnZVNpemU6IHRoaXMuZ2V0SW5pdGFsUGFnZVNpemUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldEdyb3VwU2l6ZTogdGhpcy5nZXRHcm91cFNpemUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHNldEdyb3VwU2l6ZTogdGhpcy5zZXRHcm91cFNpemUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldFRvdGFsTm9kZXNDb3VudDogdGhpcy5nZXRUb3RhbE5vZGVzQ291bnQuYmluZCh0aGlzKVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgbG9hZCBtb3JlIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgICAqIFByb3ZpZGluZyBhIGZ1bmN0aW9uIGlzIG9ubHkgcmVxdWlyZWQgd2hlbiBhZGRpdGlvbmFsIG5vZGVzIGFyZSBmZXRjaGVkIG9uIGRlbWFuZFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbG9hZG1vcmVidXR0b25fdHJlZXZpZXcgJX0jdG9jLXJlbW90ZS1kYXRhKSkuXG4gICAgICovXG4gICAgc2V0IGxvYWRNb3JlTm9kZXMobG9hZE1vcmVOb2Rlcykge1xuICAgICAgICBpZiAodHlwZW9mIGxvYWRNb3JlTm9kZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmVldmlldy5sb2FkTW9yZVNlcnZpY2UubG9hZE1vcmVOb2RlcyA9IGxvYWRNb3JlTm9kZXM7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLnZlcmlmeVNldHRpbmdzKCk7XG4gICAgfVxuICAgIHZlcmlmeVNldHRpbmdzKCkge1xuICAgICAgICBpZiAoIWlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5wYWdlU2l6ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG8gdXNlIHRoZSBUcmVlVmlldyBcXGBrZW5kb1RyZWVWaWV3TG9hZE1vcmVcXGAgZGlyZWN0aXZlLCB5b3UgbmVlZCB0byBhc3NpZ24gYSBcXGBwYWdlU2l6ZVxcYCB2YWx1ZS4gU2VlICR7TE9BRF9NT1JFX0RPQ19MSU5LJDF9LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvYWRNb3JlTm9kZXMgPSB0aGlzLnRyZWV2aWV3LmxvYWRNb3JlU2VydmljZS5sb2FkTW9yZU5vZGVzO1xuICAgICAgICBpZiAoaXNQcmVzZW50KGxvYWRNb3JlTm9kZXMpICYmIHR5cGVvZiBsb2FkTW9yZU5vZGVzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwYXNzZWQgdmFsdWUgdG8gdGhlIFxcYGtlbmRvVHJlZVZpZXdMb2FkTW9yZVxcYCBkaXJlY3RpdmUgbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0cmlldmVzIGFkZGl0aW9uYWwgbm9kZXMuIFNlZSAke0xPQURfTU9SRV9ET0NfTElOSyQxfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVzZW50KGxvYWRNb3JlTm9kZXMpICYmICFpc1ByZXNlbnQodGhpcy50b3RhbEZpZWxkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaGVuIGEgZnVuY3Rpb24gdG8gZmV0Y2ggYWRkaXRpb25hbCBub2RlcyBpcyBwcm92aWRlZCB0byB0aGUgXFxga2VuZG9UcmVlVmlld0xvYWRNb3JlXFxgIGRpcmVjdGl2ZSwgdGhlIFxcYHRvdGFsRmllbGRcXGAgYW5kIFxcYHRvdGFsUm9vdE5vZGVzXFxgIHZhbHVlcyBtdXN0IGFsc28gYmUgcHJvdmlkZWQuIFNlZSAke0xPQURfTU9SRV9ET0NfTElOSyQxfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRHcm91cFNpemUoZGF0YUl0ZW0pIHtcbiAgICAgICAgY29uc3QgaXRlbUtleSA9IGRhdGFJdGVtIHx8IHRoaXMucm9vdExldmVsSWQ7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VTaXplcy5oYXMoaXRlbUtleSkgPyB0aGlzLnBhZ2VTaXplcy5nZXQoaXRlbUtleSkgOiB0aGlzLnBhZ2VTaXplO1xuICAgIH1cbiAgICBzZXRHcm91cFNpemUoZGF0YUl0ZW0sIHBhZ2VTaXplKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1LZXkgPSBkYXRhSXRlbSB8fCB0aGlzLnJvb3RMZXZlbElkO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkU2l6ZVZhbHVlID0gcGFnZVNpemUgPiAwID8gcGFnZVNpemUgOiAwO1xuICAgICAgICB0aGlzLnBhZ2VTaXplcy5zZXQoaXRlbUtleSwgbm9ybWFsaXplZFNpemVWYWx1ZSk7XG4gICAgfVxuICAgIGdldFRvdGFsTm9kZXNDb3VudChkYXRhSXRlbSwgbG9hZGVkTm9kZXNDb3VudCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGRhdGFJdGVtKSAmJiBpc1ByZXNlbnQodGhpcy50b3RhbEZpZWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFJdGVtW3RoaXMudG90YWxGaWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzUHJlc2VudChkYXRhSXRlbSkgJiYgaXNQcmVzZW50KHRoaXMudG90YWxSb290Tm9kZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbFJvb3ROb2RlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZWROb2Rlc0NvdW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEluaXRhbFBhZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlU2l6ZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2tlbmRvVHJlZVZpZXdMb2FkTW9yZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIExvYWRNb3JlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsb2FkTW9yZU5vZGVzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTG9hZE1vcmVEaXJlY3RpdmUucHJvdG90eXBlLCBcInBhZ2VTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBMb2FkTW9yZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG90YWxSb290Tm9kZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIExvYWRNb3JlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b3RhbEZpZWxkXCIsIHZvaWQgMCk7XG5Mb2FkTW9yZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdMb2FkTW9yZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUcmVlVmlld0NvbXBvbmVudF0pXG5dLCBMb2FkTW9yZURpcmVjdGl2ZSk7XG5cbmNvbnN0IENPTVBPTkVOVF9ESVJFQ1RJVkVTJDEgPSBbXG4gICAgVHJlZVZpZXdDb21wb25lbnQsXG4gICAgVHJlZVZpZXdHcm91cENvbXBvbmVudCxcbiAgICBUcmVlVmlld0l0ZW1EaXJlY3RpdmUsXG4gICAgVHJlZVZpZXdJdGVtQ29udGVudERpcmVjdGl2ZSxcbiAgICBOb2RlVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgQ2hlY2tEaXJlY3RpdmUsXG4gICAgRGlzYWJsZURpcmVjdGl2ZSxcbiAgICBFeHBhbmREaXJlY3RpdmUsXG4gICAgU2VsZWN0RGlyZWN0aXZlLFxuICAgIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUsXG4gICAgTG9hZGluZ0luZGljYXRvckRpcmVjdGl2ZSxcbiAgICBGbGF0RGF0YUJpbmRpbmdEaXJlY3RpdmUsXG4gICAgRHJhZ0FuZERyb3BEaXJlY3RpdmUsXG4gICAgRHJhZ0NsdWVUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBEcmFnQ2x1ZUNvbXBvbmVudCxcbiAgICBEcm9wSGludFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIERyb3BIaW50Q29tcG9uZW50LFxuICAgIERyYWdBbmREcm9wRWRpdGluZ0RpcmVjdGl2ZSxcbiAgICBMb2FkTW9yZURpcmVjdGl2ZSxcbiAgICBMb2FkTW9yZUJ1dHRvblRlbXBsYXRlRGlyZWN0aXZlXG5dO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTaGFyZWRNb2R1bGUgPSBjbGFzcyBTaGFyZWRNb2R1bGUge1xufTtcblNoYXJlZE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NUE9ORU5UX0RJUkVDVElWRVMkMV0sXG4gICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFUyQxXSxcbiAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgQ2hlY2tCb3hNb2R1bGUsXG4gICAgICAgICAgICBJbnB1dHNNb2R1bGVcbiAgICAgICAgXSxcbiAgICAgICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgICAgICBEcmFnQ2x1ZUNvbXBvbmVudCxcbiAgICAgICAgICAgIERyb3BIaW50Q29tcG9uZW50XG4gICAgICAgIF1cbiAgICB9KVxuXSwgU2hhcmVkTW9kdWxlKTtcblxuY29uc3QgRVhQT1JUUyA9IFtcbiAgICBUcmVlVmlld0NvbXBvbmVudCxcbiAgICBOb2RlVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgQ2hlY2tEaXJlY3RpdmUsXG4gICAgRGlzYWJsZURpcmVjdGl2ZSxcbiAgICBFeHBhbmREaXJlY3RpdmUsXG4gICAgU2VsZWN0RGlyZWN0aXZlLFxuICAgIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUsXG4gICAgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLFxuICAgIERyYWdBbmREcm9wRGlyZWN0aXZlLFxuICAgIERyYWdDbHVlVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRHJvcEhpbnRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBEcmFnQW5kRHJvcEVkaXRpbmdEaXJlY3RpdmUsXG4gICAgTG9hZE1vcmVEaXJlY3RpdmUsXG4gICAgTG9hZE1vcmVCdXR0b25UZW1wbGF0ZURpcmVjdGl2ZVxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KSBkZWZpbml0aW9uIGZvciB0aGUgVHJlZVZpZXcgY29tcG9uZW50LlxuICovXG5sZXQgVHJlZVZpZXdNb2R1bGUgPSBjbGFzcyBUcmVlVmlld01vZHVsZSB7XG59O1xuVHJlZVZpZXdNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGV4cG9ydHM6IFtFWFBPUlRTXSxcbiAgICAgICAgaW1wb3J0czogW1NoYXJlZE1vZHVsZV1cbiAgICB9KVxuXSwgVHJlZVZpZXdNb2R1bGUpO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IENoZWNrQm94Q29tcG9uZW50LCBDaGVja0JveE1vZHVsZSwgRGF0YUNoYW5nZU5vdGlmaWNhdGlvblNlcnZpY2UsIERyYWdDbHVlQ29tcG9uZW50LCBEcmFnQ2x1ZVNlcnZpY2UsIERyb3BIaW50Q29tcG9uZW50LCBEcm9wSGludFNlcnZpY2UsIERyYWdBbmREcm9wQXNzZXRTZXJ2aWNlLCBQcmV2ZW50YWJsZUV2ZW50LCBFeHBhbmRTdGF0ZVNlcnZpY2UsIEZpbHRlcmluZ0Jhc2UsIEluZGV4QnVpbGRlclNlcnZpY2UsIExvYWRpbmdJbmRpY2F0b3JEaXJlY3RpdmUsIExvYWRpbmdOb3RpZmljYXRpb25TZXJ2aWNlLCBOYXZpZ2F0aW9uU2VydmljZSwgTm9kZUNoaWxkcmVuU2VydmljZSwgU2VsZWN0aW9uU2VydmljZSwgU2hhcmVkTW9kdWxlLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LCBUcmVlVmlld0l0ZW1Db250ZW50RGlyZWN0aXZlLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUsIFRyZWVWaWV3TG9va3VwU2VydmljZSwgVHJlZVZpZXdDb21wb25lbnQsIFRyZWVWaWV3TW9kdWxlLCBOb2RlVGVtcGxhdGVEaXJlY3RpdmUsIENoZWNrRGlyZWN0aXZlLCBEaXNhYmxlRGlyZWN0aXZlLCBFeHBhbmREaXJlY3RpdmUsIFNlbGVjdERpcmVjdGl2ZSwgRGF0YUJvdW5kQ29tcG9uZW50LCBFeHBhbmRhYmxlQ29tcG9uZW50LCBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLCBGbGF0RGF0YUJpbmRpbmdEaXJlY3RpdmUsIERyYWdBbmREcm9wRGlyZWN0aXZlLCBEcmFnQW5kRHJvcEVkaXRpbmdEaXJlY3RpdmUsIERyb3BIaW50VGVtcGxhdGVEaXJlY3RpdmUsIERyYWdDbHVlVGVtcGxhdGVEaXJlY3RpdmUsIERyb3BBY3Rpb24sIERyb3BQb3NpdGlvbiwgVHJlZUl0ZW1Ecm9wRXZlbnQsIFRyZWVJdGVtRHJhZ1N0YXJ0RXZlbnQsIFRyZWVJdGVtRHJhZ0V2ZW50LCBMb2FkTW9yZURpcmVjdGl2ZSwgTG9hZE1vcmVCdXR0b25UZW1wbGF0ZURpcmVjdGl2ZSB9O1xuIl19