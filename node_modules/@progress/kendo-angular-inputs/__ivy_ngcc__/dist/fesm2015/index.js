/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __param, __metadata } from 'tslib';
import { isDevMode, Directive, Optional, TemplateRef, EventEmitter, Input, Output, HostBinding, ViewChild, ElementRef, ContentChild, Component, forwardRef, Injector, Renderer2, NgZone, ChangeDetectorRef, Inject, Injectable, HostListener, ViewChildren, QueryList, NgModule, ViewContainerRef, ContentChildren } from '@angular/core';
import { NgControl, NG_VALUE_ACCESSOR, NG_VALIDATORS, RadioControlValueAccessor } from '@angular/forms';
import { Subscription, fromEvent, interval, merge, BehaviorSubject, Subject } from 'rxjs';
import { take, filter, concatMap, startWith, takeUntil, skip, debounceTime, throttleTime } from 'rxjs/operators';
import { LocalizationService, L10N_PREFIX, RTL, ComponentMessages, MessageService } from '@progress/kendo-angular-l10n';
import { Keys, guid, hasObservers, anyChanged, isDocumentAvailable, KendoInput, isChanged, DraggableModule, EventsModule, ResizeSensorModule, PreventableEvent, closest } from '@progress/kendo-angular-common';
import { validatePackage } from '@progress/kendo-licensing';
import { browser, mobileOS, detectDesktopBrowser, detectMobileOS } from '@progress/kendo-common';
import { IntlService } from '@progress/kendo-angular-intl';
import { CommonModule } from '@angular/common';
import { PopupService, PopupModule } from '@progress/kendo-angular-popup';
import { Color, parseColor, namedColors } from '@progress/kendo-drawing';

/**
 * @hidden
 *
 * Checks if the value is `null` or `undefined`. Falsy values like '', 0, false, NaN, etc. are regarded as present.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@progress/kendo-angular-common';
import * as ɵngcc3 from '@angular/common';
import * as ɵngcc4 from '@progress/kendo-angular-intl';
import * as ɵngcc5 from '@progress/kendo-angular-popup';

const _c0 = ["wrap"];
const _c1 = ["track"];
const _c2 = ["sliderSelection"];
const _c3 = ["ticks"];
const _c4 = ["draghandle"];
const _c5 = ["decreaseButton"];
const _c6 = ["increaseButton"];
function SliderComponent_button_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 14, 15);
    ɵngcc0.ɵɵelement(2, "span", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r1.decrementMessage);
    ɵngcc0.ɵɵattribute("tabindex", -1);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("k-i-arrow-w", !ctx_r1.vertical)("k-i-arrow-s", ctx_r1.vertical);
} }
function SliderComponent_ul_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", 17, 18);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tickTitle", ctx_r2.title)("vertical", ctx_r2.vertical)("step", ctx_r2.smallStep)("largeStep", ctx_r2.largeStep)("min", ctx_r2.min)("max", ctx_r2.max)("labelTemplate", ctx_r2.labelTemplate == null ? null : ctx_r2.labelTemplate.templateRef);
    ɵngcc0.ɵɵattribute("aria-hidden", true);
} }
function SliderComponent_button_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 19, 20);
    ɵngcc0.ɵɵlistener("click", function SliderComponent_button_12_Template_button_click_0_listener($event) { return $event.preventDefault(); });
    ɵngcc0.ɵɵelement(2, "span", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r6.incrementMessage);
    ɵngcc0.ɵɵattribute("tabindex", -1)("aria-label", ctx_r6.currentValue);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("k-i-arrow-e", !ctx_r6.vertical)("k-i-arrow-n", ctx_r6.vertical);
} }
const _c13 = function (a0, a1) { return { click: a0, keydown: a1 }; };
const _c14 = ["draghandleStart"];
const _c15 = ["draghandleEnd"];
function RangeSliderComponent_ul_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", 13, 14);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tickTitle", ctx_r1.title)("vertical", ctx_r1.vertical)("step", ctx_r1.smallStep)("largeStep", ctx_r1.largeStep)("min", ctx_r1.min)("max", ctx_r1.max)("labelTemplate", ctx_r1.labelTemplate == null ? null : ctx_r1.labelTemplate.templateRef);
    ɵngcc0.ɵɵattribute("aria-hidden", true);
} }
const _c20 = ["thumb"];
const _c25 = function (a0, a1, a2) { return { keydown: a0, focus: a1, blur: a2 }; };
const _c26 = ["numericInput"];
const _c31 = function (a0, a1) { return { mouseup: a0, mouseleave: a1 }; };
const _c32 = function (a0) { return { mousedown: a0 }; };
function NumericTextBoxComponent_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 4)(1, "button", 5);
    ɵngcc0.ɵɵelement(2, "span", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "button", 7);
    ɵngcc0.ɵɵelement(4, "span", 8);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(13, _c31, ctx_r1.releaseArrow, ctx_r1.releaseArrow));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.ArrowDirection.Up);
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(16, _c32, ctx_r1.increasePress))("title", ctx_r1.incrementTitle);
    ɵngcc0.ɵɵattribute("aria-hidden", true)("aria-label", ctx_r1.incrementTitle);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.ArrowDirection.Down);
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(18, _c32, ctx_r1.decreasePress))("title", ctx_r1.decrementTitle);
    ɵngcc0.ɵɵattribute("aria-hidden", true)("aria-label", ctx_r1.decrementTitle);
} }
const _c33 = function (a0, a1, a2, a3, a4, a5, a6) { return { mousedown: a0, dragenter: a1, keydown: a2, input: a3, focus: a4, blur: a5, paste: a6 }; };
const _c34 = ["input"];
const _c35 = function (a0, a1, a2, a3, a4) { return { focus: a0, blur: a1, click: a2, dragstart: a3, drop: a4 }; };
const _c36 = ["tickElement"];
const _c37 = ["kendoSliderTicks", ""];
function SliderTicksComponent_li_0_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵelementContainer(1, 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r5.labelTemplate || _r1)("ngTemplateOutletContext", tick_r3);
} }
function SliderTicksComponent_li_0_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1, "\u00A0");
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SliderTicksComponent_li_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 2, 3);
    ɵngcc0.ɵɵelementContainerStart(2, 4);
    ɵngcc0.ɵɵtemplate(3, SliderTicksComponent_li_0_span_3_Template, 2, 2, "span", 5);
    ɵngcc0.ɵɵtemplate(4, SliderTicksComponent_li_0_ng_container_4_Template, 2, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r3 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵpropertyInterpolate("title", ctx_r0.tickTitle(tick_r3.value));
    ɵngcc0.ɵɵproperty("ngClass", tick_r3.classes);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngSwitch", tick_r3.large);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", false);
} }
function SliderTicksComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const value_r8 = ctx.value;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.tickTitle(value_r8), " ");
} }
function TextBoxComponent_2_ng_template_0_Template(rf, ctx) { }
function TextBoxComponent_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TextBoxComponent_2_ng_template_0_Template, 0, 0, "ng-template", 8);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.prefixTemplate == null ? null : ctx_r0.prefixTemplate.templateRef);
} }
function TextBoxComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵlistener("click", function TextBoxComponent_span_5_Template_span_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.clearValue(); })("mousedown", function TextBoxComponent_span_5_Template_span_mousedown_0_listener($event) { return $event.preventDefault(); })("keydown.enter", function TextBoxComponent_span_5_Template_span_keydown_enter_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.clearValue($event); })("keydown.space", function TextBoxComponent_span_5_Template_span_keydown_space_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.clearValue($event); });
    ɵngcc0.ɵɵelement(1, "span", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tabindex", ctx_r2.tabIndex)("title", ctx_r2.clearTitle());
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.clearTitle());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r2.clearButtonClasses);
} }
function TextBoxComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r3.errorIconClasses);
} }
function TextBoxComponent_span_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r4.successIconClasses);
} }
function TextBoxComponent_9_ng_template_0_Template(rf, ctx) { }
function TextBoxComponent_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TextBoxComponent_9_ng_template_0_Template, 0, 0, "ng-template", 8);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r5.suffixTemplate == null ? null : ctx_r5.suffixTemplate.templateRef);
} }
const _c40 = function (a0, a1, a2) { return { focus: a0, blur: a1, input: a2 }; };
const _c41 = [[["kendo-textarea-suffix"]]];
const _c42 = ["kendo-textarea-suffix"];
const _c43 = ["*"];
const _c44 = ["opacityInput"];
const _c45 = ["hexInput"];
const _c46 = ["blueInput"];
const _c47 = ["toggleFormatButton"];
function ColorInputComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 0)(1, "input", 6, 7);
    ɵngcc0.ɵɵlistener("blur", function ColorInputComponent_div_4_Template_input_blur_1_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.handleHexInputBlur(); })("input", function ColorInputComponent_div_4_Template_input_input_1_listener() { ɵngcc0.ɵɵrestoreView(_r5); const _r3 = ɵngcc0.ɵɵreference(2); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.handleHexValueChange(_r3.value); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "label", 8);
    ɵngcc0.ɵɵtext(4, "HEX");
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r1.focusableId)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly)("value", ctx_r1.hex || "");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("for", ctx_r1.focusableId);
} }
function ColorInputComponent_ng_container_5_div_16_Template(rf, ctx) { if (rf & 1) {
    const _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 0)(1, "kendo-numerictextbox", 13, 14);
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_div_16_Template_kendo_numerictextbox_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r13 = ɵngcc0.ɵɵnextContext(2); return ctx_r13.rgba.a = $event; })("blur", function ColorInputComponent_ng_container_5_div_16_Template_kendo_numerictextbox_blur_1_listener() { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.handleRgbaInputBlur(); })("valueChange", function ColorInputComponent_ng_container_5_div_16_Template_kendo_numerictextbox_valueChange_1_listener() { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r16 = ɵngcc0.ɵɵnextContext(2); return ctx_r16.handleRgbaValueChange(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "label", 8);
    ɵngcc0.ɵɵtext(5, "A");
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const _r12 = ɵngcc0.ɵɵreference(3);
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("disabled", ctx_r10.disabled)("readonly", ctx_r10.readonly)("min", 0)("max", 1)("value", ctx_r10.rgba.a)("autoCorrect", true)("spinners", false)("step", 0.01)("format", "n2")("decimals", 2);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("for", _r12.focusableId);
} }
function ColorInputComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    const _r18 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 0)(2, "kendo-numerictextbox", 9, 10);
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r17 = ɵngcc0.ɵɵnextContext(); return ctx_r17.rgba.r = $event; })("blur", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_blur_2_listener() { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r19 = ɵngcc0.ɵɵnextContext(); return ctx_r19.handleRgbaInputBlur(); })("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_2_listener() { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r20 = ɵngcc0.ɵɵnextContext(); return ctx_r20.handleRgbaValueChange(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "label", 8);
    ɵngcc0.ɵɵtext(5, "R");
    ɵngcc0.ɵɵelementEnd()();
    ɵngcc0.ɵɵelementStart(6, "div", 0)(7, "kendo-numerictextbox", 9, 11);
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.rgba.g = $event; })("blur", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_blur_7_listener() { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r22 = ɵngcc0.ɵɵnextContext(); return ctx_r22.handleRgbaInputBlur(); })("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_7_listener() { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r23 = ɵngcc0.ɵɵnextContext(); return ctx_r23.handleRgbaValueChange(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "label", 8);
    ɵngcc0.ɵɵtext(10, "G");
    ɵngcc0.ɵɵelementEnd()();
    ɵngcc0.ɵɵelementStart(11, "div", 0)(12, "kendo-numerictextbox", 9, 12);
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r24 = ɵngcc0.ɵɵnextContext(); return ctx_r24.rgba.b = $event; })("blur", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_blur_12_listener() { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r25 = ɵngcc0.ɵɵnextContext(); return ctx_r25.handleRgbaInputBlur(); })("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_12_listener() { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r26 = ɵngcc0.ɵɵnextContext(); return ctx_r26.handleRgbaValueChange(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(14, "label", 8);
    ɵngcc0.ɵɵtext(15, "B");
    ɵngcc0.ɵɵelementEnd()();
    ɵngcc0.ɵɵtemplate(16, ColorInputComponent_ng_container_5_div_16_Template, 6, 11, "div", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r7 = ɵngcc0.ɵɵreference(3);
    const _r8 = ɵngcc0.ɵɵreference(8);
    const _r9 = ɵngcc0.ɵɵreference(13);
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("disabled", ctx_r2.disabled)("readonly", ctx_r2.readonly)("min", 0)("max", 255)("value", ctx_r2.rgba.r)("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("for", _r7.focusableId);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("disabled", ctx_r2.disabled)("readonly", ctx_r2.readonly)("min", 0)("max", 255)("value", ctx_r2.rgba.g)("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("for", _r8.focusableId);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("disabled", ctx_r2.disabled)("readonly", ctx_r2.readonly)("min", 0)("max", 255)("value", ctx_r2.rgba.b)("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("for", _r9.focusableId);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.opacity);
} }
const _c48 = ["gradientDragHandle"];
const _c49 = ["inputs"];
const _c50 = ["alphaSlider"];
const _c51 = ["gradientWrapper"];
const _c52 = ["hsvRectangle"];
function ColorGradientComponent__svg_svg_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 15);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    const _r1 = ɵngcc0.ɵɵreference(5);
    ɵngcc0.ɵɵproperty("wrapper", _r1 ? _r1 : undefined)("hsva", ctx_r3.hsva)("backgroundColor", ctx_r3.contrastTool);
} }
function ColorGradientComponent_span_10_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 16);
    ɵngcc0.ɵɵlistener("click", function ColorGradientComponent_span_10_Template_span_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.reset(); })("keydown.enter", function ColorGradientComponent_span_10_Template_span_keydown_enter_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.reset(); })("keydown.space", function ColorGradientComponent_span_10_Template_span_keydown_space_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.reset(); });
    ɵngcc0.ɵɵelement(1, "span", 17);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r4.clearButtonTitle)("title", ctx_r4.clearButtonTitle);
} }
const _c71 = function (a0) { return { "k-align-self-end": a0 }; };
function ColorGradientComponent_kendo_slider_12_Template(rf, ctx) { if (rf & 1) {
    const _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-slider", 18, 19);
    ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_kendo_slider_12_Template_kendo_slider_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.handleAlphaSliderChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(12, _c71, ctx_r5.clearButton))("dragHandleTitle", ctx_r5.opacitySliderTitle)("disabled", ctx_r5.disabled)("readonly", ctx_r5.readonly)("showButtons", false)("tickPlacement", "none")("vertical", true)("min", 0)("max", 100)("smallStep", 1)("largeStep", 10)("value", ctx_r5.alphaSliderValue);
} }
function ColorGradientComponent_div_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 20);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", ctx_r7.value)("ratio", ctx_r7.contrastTool);
} }
const _c74 = function (a0, a1, a2, a3) { return { backgroundColor: a0, width: a1, height: a2, minWidth: a3 }; };
function ColorPaletteComponent_tr_4_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 5);
    ɵngcc0.ɵɵlistener("click", function ColorPaletteComponent_tr_4_td_1_Template_td_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r7); const color_r4 = restoredCtx.$implicit; const colIndex_r5 = restoredCtx.index; const rowIndex_r2 = ɵngcc0.ɵɵnextContext().index; const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.handleCellSelection(color_r4, { row: rowIndex_r2, col: colIndex_r5 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const color_r4 = ctx.$implicit;
    const colIndex_r5 = ctx.index;
    const rowIndex_r2 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-state-selected", (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.row) === rowIndex_r2 && (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.col) === colIndex_r5)("k-state-focus", ctx_r3.focusInComponent && (ctx_r3.focusedCell == null ? null : ctx_r3.focusedCell.row) === rowIndex_r2 && (ctx_r3.focusedCell == null ? null : ctx_r3.focusedCell.col) === colIndex_r5);
    ɵngcc0.ɵɵproperty("id", "k-" + rowIndex_r2 + "-" + colIndex_r5 + "-" + ctx_r3.uniqueId)("ngStyle", ɵngcc0.ɵɵpureFunction4(9, _c74, color_r4, ctx_r3.tileLayout.width + "px", ctx_r3.tileLayout.height + "px", ctx_r3.tileLayout.width + "px"));
    ɵngcc0.ɵɵattribute("aria-selected", (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.row) === rowIndex_r2 && (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.col) === colIndex_r5)("aria-label", color_r4)("value", color_r4);
} }
function ColorPaletteComponent_tr_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, ColorPaletteComponent_tr_4_td_1_Template, 1, 14, "td", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const row_r1 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", row_r1);
} }
const _c75 = ["clearButton"];
const _c76 = ["viewButtons"];
const _c77 = ["kendoFlatColorPickerHeader", ""];
function FlatColorPickerHeaderComponent_div_1_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 7, 8);
    ɵngcc0.ɵɵlistener("click", function FlatColorPickerHeaderComponent_div_1_button_1_Template_button_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r7); const view_r4 = restoredCtx.$implicit; const ctx_r6 = ɵngcc0.ɵɵnextContext(2); return ctx_r6.onViewButtonClick(view_r4); });
    ɵngcc0.ɵɵelement(2, "span", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const view_r4 = ctx.$implicit;
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r3.activeView === view_r4 ? "k-state-selected" : "");
    ɵngcc0.ɵɵattribute("title", ctx_r3.getText(view_r4 === "gradient" ? "gradientView" : "paletteView"))("aria-label", ctx_r3.getText(view_r4 === "gradient" ? "gradientView" : "paletteView"))("aria-pressed", ctx_r3.activeView === view_r4);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r3.getViewButtonIcon(view_r4));
} }
function FlatColorPickerHeaderComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵtemplate(1, FlatColorPickerHeaderComponent_div_1_button_1_Template, 3, 5, "button", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.views);
} }
function FlatColorPickerHeaderComponent_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 10, 11);
    ɵngcc0.ɵɵlistener("click", function FlatColorPickerHeaderComponent_button_4_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.clearButtonClick.emit(); });
    ɵngcc0.ɵɵelement(2, "span", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.getText("clearButton"))("title", ctx_r1.getText("clearButton"));
} }
function FlatColorPickerHeaderComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵelement(1, "span", 14);
    ɵngcc0.ɵɵelementStart(2, "span", 15);
    ɵngcc0.ɵɵlistener("click", function FlatColorPickerHeaderComponent_div_5_Template_span_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.valuePaneClick.emit($event); });
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("background-color", ctx_r2.selection);
    ɵngcc0.ɵɵattribute("title", ctx_r2.getText("previewColor"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("background-color", ctx_r2.value);
    ɵngcc0.ɵɵattribute("title", ctx_r2.getText("revertSelection"));
} }
const _c78 = ["last"];
const _c79 = ["kendoFlatColorPickerActionButtons", ""];
const _c80 = ["header"];
const _c81 = ["gradient"];
const _c82 = ["palette"];
const _c83 = ["footer"];
function FlatColorPickerComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 6, 7);
    ɵngcc0.ɵɵlistener("clearButtonClick", function FlatColorPickerComponent_div_1_Template_div_clearButtonClick_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.onClearButtonClick(); })("viewChange", function FlatColorPickerComponent_div_1_Template_div_viewChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.onViewChange($event); })("valuePaneClick", function FlatColorPickerComponent_div_1_Template_div_valuePaneClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.resetSelection($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("clearButton", ctx_r0.clearButton)("activeView", ctx_r0.activeView)("views", ctx_r0.views)("value", ctx_r0.value)("selection", ctx_r0.selection)("preview", ctx_r0.preview);
} }
function FlatColorPickerComponent_kendo_colorgradient_3_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-colorgradient", 8, 9);
    ɵngcc0.ɵɵlistener("valueChange", function FlatColorPickerComponent_kendo_colorgradient_3_Template_kendo_colorgradient_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.handleValueChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tabindex", null)("value", ctx_r1.selection)("format", ctx_r1.format)("opacity", ctx_r1.gradientSettings.opacity)("delay", ctx_r1.gradientSettings.delay)("contrastTool", ctx_r1.gradientSettings.contrastTool)("readonly", ctx_r1.readonly);
} }
function FlatColorPickerComponent_kendo_colorpalette_4_Template(rf, ctx) { if (rf & 1) {
    const _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-colorpalette", 10, 11);
    ɵngcc0.ɵɵlistener("valueChange", function FlatColorPickerComponent_kendo_colorpalette_4_Template_kendo_colorpalette_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.handleValueChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("palette", ctx_r2.paletteSettings.palette)("columns", ctx_r2.paletteSettings.columns)("tileSize", ctx_r2.paletteSettings.tileSize)("format", ctx_r2.format)("value", ctx_r2.selection);
} }
function FlatColorPickerComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    const _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 12, 13);
    ɵngcc0.ɵɵlistener("actionButtonClick", function FlatColorPickerComponent_div_5_Template_div_actionButtonClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.onAction($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", "k-justify-content-" + ctx_r3.actionsLayout);
} }
const _c114 = ["container"];
const _c115 = ["activeColor"];
const _c116 = ["popupTemplate"];
const _c117 = ["flatColorPicker"];
function ColorPickerComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.iconStyles);
} }
function ColorPickerComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-flatcolorpicker", 11, 12);
    ɵngcc0.ɵɵlistener("cancel", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_cancel_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.handleCancelEvent($event); })("focusout", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_focusout_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.handlePopupBlur($event); })("valueChange", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.handleValueChange($event); })("keydown", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.handlePopupKeyDown($event); })("activeViewChange", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_activeViewChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.activeViewChange.emit($event); })("actionButtonClick", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_actionButtonClick_0_listener() { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.togglePopup(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", ctx_r3.value)("format", ctx_r3.format)("views", ctx_r3.views)("activeView", ctx_r3.activeView)("actionsLayout", ctx_r3.actionsLayout)("preview", ctx_r3.preview)("gradientSettings", ctx_r3.gradientSettings)("paletteSettings", ctx_r3.paletteSettings)("clearButton", ctx_r3.clearButton);
} }
const _c150 = function (a0, a1) { return { "k-icon-color-preview": a0, "k-no-color": a1 }; };
const _c151 = ["kendoContrastValidation", ""];
function ContrastValidationComponent_ng_container_2_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelement(2, "span", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.passMessage, " ");
} }
function ContrastValidationComponent_ng_container_2_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelement(2, "span", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.failMessage, " ");
} }
function ContrastValidationComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ContrastValidationComponent_ng_container_2_span_1_Template, 3, 1, "span", 1);
    ɵngcc0.ɵɵtemplate(2, ContrastValidationComponent_ng_container_2_span_2_Template, 3, 1, "span", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.pass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.pass);
} }
const _c152 = ["kendoContrastTool", ""];
function ContrastComponent_ng_container_3_span_1_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 8);
} }
function ContrastComponent_ng_container_3_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵelement(1, "span", 8);
    ɵngcc0.ɵɵtemplate(2, ContrastComponent_ng_container_3_span_1_span_2_Template, 1, 0, "span", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.satisfiesAAACondition);
} }
function ContrastComponent_ng_container_3_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 10);
    ɵngcc0.ɵɵelement(1, "span", 11);
    ɵngcc0.ɵɵelementEnd();
} }
function ContrastComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ContrastComponent_ng_container_3_span_1_Template, 3, 1, "span", 5);
    ɵngcc0.ɵɵtemplate(2, ContrastComponent_ng_container_3_span_2_Template, 2, 0, "span", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.satisfiesAACondition);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.satisfiesAACondition);
} }
const _c153 = ["kendoColorContrastSvg", ""];
function ColorContrastSvgComponent__svg_path_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "path", 1);
} if (rf & 2) {
    const path_r1 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("d", path_r1);
} }
function FormFieldComponent_ng_content_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "hasHints"]);
} }
function FormFieldComponent_ng_content_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "hasErrors"]);
} }
const _c154 = [[["label"], ["kendo-label"]], "*", [["kendo-formhint"]], [["kendo-formerror"]]];
const _c155 = ["label, kendo-label", "*", "kendo-formhint", "kendo-formerror"];
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const areSame = (value1, value2) => value1 === value2 || (value1 === null && value2 === undefined) || (value1 === undefined && value2 === null);
/**
 * @hidden
 */
const requiresZoneOnBlur = (ngControl) => ngControl &&
    (!ngControl.touched || (ngControl.control && ngControl.control.updateOn === 'blur'));
/**
 * @hidden
 *
 * Fits the contender number into the specified bounds. If the number is NaN or null, the min is returned.
 *
 * @param contender Represents the number you want to fit into specified bounds.
 * @param min The inclusive lower bound number.
 * @param max The inclusive upper bound number.
 */
const fitIntoBounds = (contender, min, max) => {
    if (!isPresent(contender) || isNaN(contender)) {
        return min;
    }
    return contender <= min ? min : contender >= max ? max : contender;
};
const SIZES = {
    small: 'sm',
    medium: 'md',
    large: 'lg'
};
const ROUNDNESS = {
    small: 'sm',
    medium: 'md',
    large: 'lg',
    full: 'full'
};
/**
 * @hidden
 *
 * Returns the styling classes to be added and removed
 */
const getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {
    switch (stylingOption) {
        case 'size':
            return {
                toRemove: `k-${componentType}-${SIZES[previousValue]}`,
                toAdd: newValue ? `k-${componentType}-${SIZES[newValue]}` : null
            };
        case 'rounded':
            return {
                toRemove: `k-rounded-${ROUNDNESS[previousValue]}`,
                toAdd: newValue ? `k-rounded-${ROUNDNESS[newValue]}` : null
            };
        case 'fillMode':
            return {
                toRemove: `k-${componentType}-${previousValue}`,
                toAdd: newValue ? `k-${componentType}-${newValue}` : null
            };
        default:
            break;
    }
};

/**
 * @hidden
 */
const MAX_PRECISION = 20;
/**
 * @hidden
 */
const limitPrecision = (precision) => Math.min(precision, MAX_PRECISION);
/**
 * @hidden
 */
const fractionLength = (value) => {
    return (String(value).split('.')[1] || "").length;
};
const maxFractionLength = (value1, value2) => {
    return Math.max(fractionLength(value1), fractionLength(value2));
};
/**
 * @hidden
 */
const toFixedPrecision = (value, precision) => {
    const maxPrecision = limitPrecision(precision);
    return parseFloat(value.toFixed(maxPrecision));
};
/**
 * @hidden
 */
const add = (value1, value2) => {
    const maxPrecision = maxFractionLength(value1, value2);
    return toFixedPrecision(value1 + value2, maxPrecision);
};
/**
 * @hidden
 */
const subtract = (value1, value2) => {
    return add(value1, -value2);
};
/**
 * @hidden
 */
const multiply = (value1, value2) => {
    const maxPrecision = fractionLength(value1) + fractionLength(value2);
    return toFixedPrecision(value1 * value2, maxPrecision);
};
/**
 * @hidden
 */
const divide = (dividend, divisor) => {
    if (divisor === 0) {
        return NaN;
    }
    const power = maxFractionLength(dividend, divisor);
    const correctionValue = Math.pow(10, power);
    return ((correctionValue * dividend) / (correctionValue * divisor));
};
/**
 * @hidden
 */
const remainder = (dividend, divisor) => {
    return Math.abs(subtract(dividend, multiply(divisor, Math.floor(divide(dividend, divisor)))));
};

/**
 * @hidden
 */
const calculateFixedTrackSize = ({ max, min, smallStep, fixedTickWidth }) => ((max - min) / smallStep) * fixedTickWidth;
/**
 * @hidden
 */
const calculateTicksCount = (min = 0, max = 0, smallStep = 1) => {
    if (smallStep <= 0) {
        throw new Error('Invalid argument: smallStep must be a positive number');
    }
    const adjustedRange = Math.abs(subtract(max, min));
    const adjustedRatio = Math.floor(divide(adjustedRange, smallStep));
    const result = add(adjustedRatio, 1);
    return result;
};
/**
 * @hidden
 */
const calculateValueFromTick = (index, { max, min, smallStep, reverse, vertical }) => {
    const value = add(min, multiply(index, smallStep));
    return vertical || reverse ? Math.abs(subtract(value, max)) : value;
};
/**
 * @hidden
 */
const calculateHandlePosition = ({ trackWidth, min, max, reverse, value }) => {
    const step = trackWidth / Math.abs(max - min);
    let pos = isPresent(value) ? step * (value - min) : min;
    if (reverse) {
        pos = trackWidth - pos;
    }
    return Math.floor(pos);
};
/**
 * @hidden
 */
const decreaseValueToStep = (value, { max, min, smallStep, largeStep }, large = false) => {
    const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
    const stepValue = subtract(value, min);
    let result;
    const stepRemainder = remainder(stepValue, step);
    if (stepRemainder === 0) {
        result = subtract(stepValue, step);
    }
    else {
        result = subtract(stepValue, stepRemainder);
    }
    return limitValue(add(result, min), min, max);
};
/**
 * @hidden
 */
const increaseValueToStep = (value, { max, min, smallStep, largeStep }, large = false) => {
    const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
    const stepValue = subtract(value, min);
    const stepRemainder = remainder(stepValue, step);
    const result = add(subtract(stepValue, stepRemainder), step);
    return limitValue(add(result, min), min, max);
};
/**
 * @hidden
 */
const isStartHandle = (dragHandle) => dragHandle.id.indexOf('k-start-handle') > -1;
/**
 * @hidden
 */
const snapValue = (value, options) => {
    const { smallStep, min, max } = options;
    const limited = limitValue(value, min, max);
    if (value !== limited) {
        return limited;
    }
    const left = decreaseValueToStep(value, options);
    const right = increaseValueToStep(value, options);
    if ((value - min) % smallStep === 0) {
        return value;
    }
    if (right - value <= (right - left) / 2) {
        return right;
    }
    return left;
};
/**
 * @hidden
 */
const trimValue = (max, min, value) => {
    if (value > max) {
        return max;
    }
    if (value < min) {
        return min;
    }
    return value;
};
/**
 * @hidden
 */
const trimValueRange = (max, min, value) => {
    return value ? [trimValue(max, min, value[0]), trimValue(max, min, value[1])] : [min, min];
};
/**
 * @hidden
 */
const identity = (value) => value;
/**
 * @hidden
 */
const isSameRange = (value1, value2) => areSame(value1[0], value2[0]) && areSame(value1[1], value2[1]);
/**
 * @hidden
 */
const elementOffset = (element) => {
    const box = element.getBoundingClientRect();
    const documentElement = document.documentElement;
    return {
        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),
        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0)
    };
};
/**
 * @hidden
 */
const limitValue = (value, min, max) => {
    return Math.max(Math.min(value, max), min);
};
/**
 * @hidden
 */
const eventValue = (eventArgs, scaleElement, options) => {
    const { min, max, vertical, rtl } = options;
    const trackOffset = elementOffset(scaleElement);
    const offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;
    const scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);
    const offsetValue = offset * scale;
    let value = rtl || vertical ? max - offsetValue : min + offsetValue;
    const stepFractionLength = fractionLength(options.smallStep);
    value = toFixedPrecision(value, stepFractionLength + 1);
    return snapValue(value, options);
};
/**
 * @hidden
 */
const isButton = (element) => {
    return element.className.indexOf('k-button-increase') >= 0 || element.className.indexOf('k-button-decrease') >= 0;
};
/**
 * @hidden
 */
const increment = (options) => {
    return increaseValueToStep(options.value, options);
};
/**
 * @hidden
 */
const decrement = (options) => {
    return decreaseValueToStep(options.value, options);
};
/**
 * @hidden
 */
const incrementLarge = (options) => {
    return increaseValueToStep(options.value, options, true);
};
/**
 * @hidden
 */
const decrementLarge = (options) => {
    return decreaseValueToStep(options.value, options, true);
};
/**
 * @hidden
 */
const validateValue = (value) => {
    if (isDevMode && value && value[0] > value[1]) {
        throw new Error('[RangeSlider] The start value should not be greater than the end value.');
    }
};

/**
 * @hidden
 */
class SliderModelBase {
    constructor(props, wrapper, track, renderer) {
        this.props = props;
        this.wrapper = wrapper;
        this.track = track;
        this.renderer = renderer;
        this.props = props;
        this.wrapper = wrapper;
        this.track = track;
        this.tickSizes = this.getTickSizes();
    }
    resizeTrack() {
        const orientation = this.props.vertical ? 'height' : 'width';
        const altOrientation = this.props.vertical ? 'width' : 'height';
        const trackWidth = this.trackWidth();
        this.track.parentElement.style[orientation] = `${trackWidth}px`;
        this.track.parentElement.style[altOrientation] = '';
    }
    resizeTicks(ticksContainer, ticks) {
        const dimension = this.props.vertical ? "height" : "width";
        [...ticks].map((tick, index) => tick.style[dimension] = `${this.tickSizes[index]}px`);
        if (this.props.vertical) {
            this.adjustPadding(ticksContainer);
        }
    }
    resizeWrapper() {
        const dimension = this.props.vertical ? "height" : "width";
        const fixedTrackWidth = calculateFixedTrackSize(this.props);
        const wrapperParentEl = this.wrapper.parentElement;
        if (fixedTrackWidth) {
            wrapperParentEl.style[dimension] = "auto";
        }
    }
    trackWidth() {
        if (this.props.fixedTickWidth) {
            return calculateFixedTrackSize(this.props);
        }
        return this.elementSize(this.track.parentElement);
    }
    getTickSizes() {
        const { min, max, smallStep } = this.props;
        const count = calculateTicksCount(min, max, smallStep);
        const trackSize = this.trackWidth();
        const distStep = trackSize / subtract(max, min);
        const result = [];
        let usedSpace = 0;
        let endPoint = 0;
        for (let i = 0; i < count; i++) {
            if (i === 0 || i === count - 1) {
                endPoint += (smallStep / 2) * distStep;
            }
            else {
                endPoint += smallStep * distStep;
            }
            // ensure that the sum of the tick sizes does not exceed the track width
            endPoint = +endPoint.toFixed(2) - 0.01;
            const size = Math.round(endPoint - usedSpace);
            result.push(size);
            usedSpace += size;
        }
        if (usedSpace >= trackSize) {
            result[result.length - 1] -= 1;
        }
        return result;
    }
    adjustPadding(ticksContainer) {
        const totalTickSize = this.tickSizes.reduce((prev, curr) => prev + curr, 0);
        const trackWidth = this.trackWidth();
        const reminder = trackWidth - totalTickSize;
        if (reminder !== 0) {
            const padding = reminder + this.elementOffset(this.track);
            ticksContainer.style.paddingTop = `${padding}px`;
        }
    }
    elementOffset(element) {
        const { vertical } = this.props;
        const style = getComputedStyle(element);
        return parseInt(vertical ? style.bottom : style.left, 10);
    }
    elementSize(element) {
        const { vertical } = this.props;
        return vertical ? element.clientHeight : element.clientWidth;
    }
}

/**
 * @hidden
 */
class SliderModel extends SliderModelBase {
    positionHandle(dragHandle) {
        const { max, min, reverse, vertical } = this.props;
        const position = vertical ? 'bottom' : 'left';
        const trackWidth = this.trackWidth();
        const value = trimValue(max, min, this.props.value);
        this.handlePosition = calculateHandlePosition({
            min,
            max,
            reverse,
            value,
            trackWidth
        });
        this.renderer.setStyle(dragHandle, position, `${this.handlePosition}px`);
    }
    positionSelection(selection) {
        const { reverse, vertical } = this.props;
        const dimension = vertical ? 'height' : 'width';
        let size = this.handlePosition;
        if (reverse) {
            size = this.trackWidth() - size;
        }
        this.renderer.setStyle(selection, dimension, `${size}px`);
    }
}

const UNTOUCHED = 'ng-untouched';
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClass = (element, className) => Boolean(toClassList(element.className).find((name) => name === className));
/**
 * @hidden
 */
function invokeElementMethod(element, name, ...args) {
    if (element && element.nativeElement) {
        return element.nativeElement[name].apply(element.nativeElement, args);
    }
}
/**
 * @hidden
 */
const isUntouched = (element) => element && element.nativeElement && hasClass(element.nativeElement, UNTOUCHED);
/**
 * @hidden
 */
const containsFocus = (hostElement, contender) => hostElement && contender && (hostElement === contender || hostElement.contains(contender));
/**
 * @hidden
 */
const closest$1 = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-inputs',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1648211916,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * Represents the template for the labels of the Slider.
 * To define the labels template, nest an `<ng-template>` tag with the `kendoSliderLabelTemplate` directive inside
 * the `<kendo-slider>` tag. The template context is passed to the `label` value.
 *
 * @example
 * ```ts-no-run
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-slider [largeStep]="2">
 *           <ng-template kendoSliderLabelTemplate let-value="value">
 *             <b>{{value}}</b>
 *           </ng-template>
 *         </kendo-slider>
 *     `
 * })
 *
 * class AppComponent {
 * }
 *
 * ```
 */
let LabelTemplateDirective = class LabelTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
LabelTemplateDirective.ɵfac = function LabelTemplateDirective_Factory(t) { return new (t || LabelTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
LabelTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LabelTemplateDirective, selectors: [["", "kendoSliderLabelTemplate", ""]] });
LabelTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], LabelTemplateDirective);

/**
 * @hidden
 */
class SliderBase {
    constructor(localizationService, injector, renderer, ngZone, changeDetector, hostElement) {
        this.localizationService = localizationService;
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title
         * for each tick is its Slider value. If you use a callback function, the function accepts an argument
         * that holds the value of the component and returns a string with the new title.
         */
        this.title = identity;
        /**
         * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).
         *
         * The available options are:
         * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.
         * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.
         * * `both`&mdash; (Default) The tick marks are located on both sides of the track.
         * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.
         */
        this.tickPlacement = 'both';
        /**
         * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical
         * ([see example]({% slug orientation_slider %})).
         */
        this.vertical = false;
        /**
         * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * The attribute accepts both integers and floating-point numbers.
         */
        this.min = 0;
        /**
         * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * The attribute accepts both integers and floating-point numbers.
         */
        this.max = 10;
        /**
         * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * Accepts positive values only. Can be an integer or a floating-point number.
         */
        this.smallStep = 1;
        /**
         * Specifies that every n<sup>th</sup> tick will be large and will have a label
         * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).
         * Accepts positive integer values only.
         */
        this.largeStep = null;
        /**
         * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})).
         */
        this.disabled = false;
        /**
         * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).
         */
        this.readonly = false;
        /**
         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the component.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the component is blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        this.sliderClass = true;
        this.widgetClass = true;
        this.subscriptions = new Subscription();
        /**
         * @hidden
         */
        this.ifEnabled = (callback, event) => {
            if (!this.isDisabled) {
                callback.call(this, event);
            }
        };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    get horizontalClass() {
        return !this.vertical;
    }
    get verticalClass() {
        return this.vertical;
    }
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.changeDetector.markForCheck();
        this.disabled = isDisabled;
    }
    ngOnInit() {
        this.subscriptions.add(this.localizationService
            .changes
            .subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
            this.sizeComponent();
        }));
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
    }
    /**
     * @hidden
     */
    get isDisabled() {
        return this.disabled || this.readonly;
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    get reverse() {
        return this.localizationService.rtl && !this.vertical;
    }
    get keyBinding() {
        const reverse = this.reverse;
        return {
            [Keys.ArrowLeft]: reverse ? increment : decrement,
            [Keys.ArrowRight]: reverse ? decrement : increment,
            [Keys.ArrowDown]: decrement,
            [Keys.ArrowUp]: increment,
            [Keys.PageUp]: incrementLarge,
            [Keys.PageDown]: decrementLarge,
            [Keys.Home]: ({ min }) => min,
            [Keys.End]: ({ max }) => max
        };
    }
    resetStyles(elements) {
        elements.forEach(el => {
            if (el) {
                if (this.vertical) {
                    this.renderer.removeStyle(el, 'width');
                    this.renderer.removeStyle(el, 'left');
                    this.renderer.removeStyle(el, 'right');
                }
                else {
                    this.renderer.removeStyle(el, 'height');
                    this.renderer.removeStyle(el, 'bottom');
                }
                this.renderer.removeStyle(el, 'padding-top');
            }
        });
    }
}
SliderBase.ɵfac = function SliderBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SliderBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SliderBase, contentQueries: function SliderBase_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LabelTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);
    } }, viewQuery: function SliderBase_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 7);
        ɵngcc0.ɵɵviewQuery(_c1, 7);
        ɵngcc0.ɵɵviewQuery(_c2, 7);
        ɵngcc0.ɵɵviewQuery(_c3, 5, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c3, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.track = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sliderSelection = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticks = _t.first);
    } }, hostVars: 11, hostBindings: function SliderBase_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-slider", ctx.sliderClass)("k-widget", ctx.widgetClass)("k-slider-horizontal", ctx.horizontalClass)("k-slider-vertical", ctx.verticalClass)("k-state-disabled", ctx.disabledClass);
    } }, inputs: { title: "title", tickPlacement: "tickPlacement", vertical: "vertical", min: "min", max: "max", smallStep: "smallStep", largeStep: "largeStep", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", fixedTickWidth: "fixedTickWidth" }, outputs: { onFocus: "focus", onBlur: "blur", valueChange: "valueChange" } });
__decorate([
    Input(),
    __metadata("design:type", Function)
], SliderBase.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderBase.prototype, "tickPlacement", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderBase.prototype, "vertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "smallStep", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "largeStep", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "fixedTickWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderBase.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderBase.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "tabindex", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], SliderBase.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], SliderBase.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], SliderBase.prototype, "valueChange", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], SliderBase.prototype, "direction", void 0);
__decorate([
    HostBinding('class.k-slider-horizontal'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SliderBase.prototype, "horizontalClass", null);
__decorate([
    HostBinding('class.k-slider-vertical'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SliderBase.prototype, "verticalClass", null);
__decorate([
    HostBinding('class.k-slider'),
    __metadata("design:type", Boolean)
], SliderBase.prototype, "sliderClass", void 0);
__decorate([
    HostBinding('class.k-widget'),
    __metadata("design:type", Boolean)
], SliderBase.prototype, "widgetClass", void 0);
__decorate([
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SliderBase.prototype, "disabledClass", null);
__decorate([
    ViewChild('wrap', { static: true }),
    __metadata("design:type", ElementRef)
], SliderBase.prototype, "wrapper", void 0);
__decorate([
    ViewChild('track', { static: true }),
    __metadata("design:type", ElementRef)
], SliderBase.prototype, "track", void 0);
__decorate([
    ViewChild('sliderSelection', { static: true }),
    __metadata("design:type", ElementRef)
], SliderBase.prototype, "sliderSelection", void 0);
__decorate([
    ViewChild('ticks', { read: ElementRef, static: false }),
    __metadata("design:type", ElementRef)
], SliderBase.prototype, "ticksContainer", void 0);
__decorate([
    ViewChild('ticks', { static: false }),
    __metadata("design:type", Object)
], SliderBase.prototype, "ticks", void 0);
__decorate([
    ContentChild(LabelTemplateDirective, { static: false }),
    __metadata("design:type", LabelTemplateDirective)
], SliderBase.prototype, "labelTemplate", void 0);

var SliderComponent_1;
const PRESSED = 'k-pressed';
/**
 * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).
 */
let SliderComponent = SliderComponent_1 = class SliderComponent extends SliderBase {
    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {
        super(localization, injector, renderer, ngZone, changeDetector, hostElement);
        this.localization = localization;
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines if the animation will be played on value change.
         * Regardless of this setting, no animation will be played during the initial rendering.
         */
        this.animate = true;
        /**
         * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).
         * When `showButtons` is set to `false`, the buttons are not displayed.
         */
        this.showButtons = true;
        /**
         * The current value of the Slider when it is initially displayed.
         * The component can use either NgModel or the `value` binding but not both of them at the same time.
         */
        this.value = this.min;
        this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        this.onWrapClick = (args) => {
            const target = args.target;
            if (!this.isDisabled && !(isButton(target) || isButton(target.parentNode))) {
                const value = eventValue(args, this.track.nativeElement, this.getProps());
                this.changeValue(value);
            }
            invokeElementMethod(this.draghandle, 'focus');
        };
        /**
         * @hidden
         */
        this.onKeyDown = (e) => {
            const options = this.getProps();
            const { max, min } = options;
            const handler = this.keyBinding[e.keyCode];
            if (this.isDisabled || !handler) {
                return;
            }
            const value = handler(options);
            this.changeValue(trimValue(max, min, value));
            e.preventDefault();
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.decreaseValue = () => {
            this.changeValue(decreaseValueToStep(this.value, this.getProps()));
        };
        this.increaseValue = () => {
            this.changeValue(increaseValueToStep(this.value, this.getProps()));
        };
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    if (!this.focusChangedProgrammatically) {
                        this.onBlur.emit();
                    }
                });
            }
        };
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * @hidden
     */
    get currentValue() {
        return isPresent(this.value) ? this.value.toString() : '';
    }
    /**
     * Focuses the Slider.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="slider.focus()">Focus</button>
     *  <kendo-slider #slider></kendo-slider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.disabled) {
            this.focusChangedProgrammatically = true;
            invokeElementMethod(this.draghandle, 'focus');
            this.focusChangedProgrammatically = false;
        }
    }
    /**
     * Blurs the Slider.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        invokeElementMethod(this.draghandle, 'blur');
        this.handleBlur();
        this.focusChangedProgrammatically = false;
    }
    ngOnChanges(changes) {
        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {
            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                this.sizeComponent(false);
            });
        }
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.showButtons) {
            this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());
            this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());
        }
        this.sizeComponent(false);
        if (this.ticks) {
            this.ticks.tickElements
                .changes
                .subscribe(() => this.sizeComponent(false));
        }
        this.attachElementEventHandlers();
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get incrementMessage() {
        return this.incrementTitle || this.localizationService.get('increment');
    }
    /**
     * @hidden
     */
    get decrementMessage() {
        return this.decrementTitle || this.localizationService.get('decrement');
    }
    /**
     * @hidden
     */
    get dragHandleMessage() {
        return this.dragHandleTitle || this.localizationService.get('dragHandle');
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (args.originalEvent) {
            args.originalEvent.preventDefault();
        }
        this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        this.dragging = true;
        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));
    }
    /**
     * @hidden
     */
    onHandleRelease() {
        this.dragging = false; //needed for animation
        this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');
    }
    //ngModel binding
    /**
     * @hidden
     */
    writeValue(value) {
        this.changeDetector.markForCheck();
        this.value = value;
        this.sizeComponent(this.animate);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    changeValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.sizeComponent(this.animate);
                this.changeDetector.markForCheck();
            });
        }
    }
    /**
     * @hidden
     */
    sizeComponent(animate) {
        if (!isDocumentAvailable()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const track = this.track.nativeElement;
        const selectionEl = this.sliderSelection.nativeElement;
        const dragHandleEl = this.draghandle.nativeElement;
        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;
        if (!animate) {
            this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');
        }
        this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);
        const props = this.getProps();
        const model = new SliderModel(props, wrapper, track, this.renderer);
        model.resizeTrack();
        if (this.ticks) { //for case when tickPlacement: none
            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));
        }
        model.positionHandle(dragHandleEl);
        model.positionSelection(selectionEl);
        if (!animate) {
            this.hostElement.nativeElement.getBoundingClientRect();
            this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');
        }
        if (this.fixedTickWidth) {
            model.resizeWrapper();
        }
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            this.isFocused = value;
        }
    }
    set dragging(value) {
        if (this.isDragged !== value && this.sliderSelection && this.draghandle) {
            const sliderSelection = this.sliderSelection.nativeElement;
            const draghandle = this.draghandle.nativeElement;
            if (value) {
                this.renderer.addClass(sliderSelection, PRESSED);
                this.renderer.addClass(draghandle, PRESSED);
            }
            else {
                this.renderer.removeClass(sliderSelection, PRESSED);
                this.renderer.removeClass(draghandle, PRESSED);
            }
            this.isDragged = value;
        }
    }
    setValueChangeInterval(element, callback) {
        this.ngZone.runOutsideAngular(() => {
            const mousedown = fromEvent(element, 'mousedown');
            const mouseup = fromEvent(element, 'mouseup');
            const mouseout = fromEvent(element, 'mouseout');
            const subscription = mousedown.pipe(filter((e) => e.button === 0 && !this.isDisabled), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout))))).subscribe(() => {
                if (!this.isFocused) {
                    invokeElementMethod(this.draghandle, 'focus');
                }
                callback();
            });
            this.subscriptions.add(subscription);
        });
    }
    getProps() {
        return {
            buttons: this.showButtons,
            disabled: this.disabled,
            fixedTickWidth: this.fixedTickWidth,
            largeStep: this.largeStep,
            max: this.max,
            min: this.min,
            readonly: this.readonly,
            reverse: this.reverse,
            rtl: this.localizationService.rtl,
            smallStep: this.smallStep,
            value: trimValue(this.max, this.min, this.value),
            vertical: this.vertical
        };
    }
    attachElementEventHandlers() {
        const hostElement = this.hostElement.nativeElement;
        let tabbing = false;
        let cursorInsideWrapper = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        if (!this.focusChangedProgrammatically) {
                            this.onFocus.emit();
                        }
                        this.focused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    if (args.relatedTarget !== this.draghandle.nativeElement) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    }
};
SliderComponent.ɵfac = function SliderComponent_Factory(t) { return new (t || SliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
SliderComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SliderComponent, selectors: [["kendo-slider"]], viewQuery: function SliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, 7);
        ɵngcc0.ɵɵviewQuery(_c5, 5);
        ɵngcc0.ɵɵviewQuery(_c6, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.draghandle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.decreaseButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.increaseButton = _t.first);
    } }, inputs: { focusableId: "focusableId", animate: "animate", showButtons: "showButtons", value: "value", tabIndex: "tabIndex", dragHandleTitle: "dragHandleTitle", incrementTitle: "incrementTitle", decrementTitle: "decrementTitle" }, exportAs: ["kendoSlider"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.slider' },
            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent_1) },
            { provide: KendoInput, useExisting: forwardRef(() => SliderComponent_1) }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 14, vars: 25, consts: function () { let i18n_7; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the **Increase** button of the Slider.
         * @meaning kendo.slider.increment
         */
        const MSG_EXTERNAL_8302125540024939132$$DIST_FESM2015_INDEX_JS_8 = goog.getMsg("increment");
        i18n_7 = MSG_EXTERNAL_8302125540024939132$$DIST_FESM2015_INDEX_JS_8;
    }
    else {
        i18n_7 = $localize `:kendo.slider.increment|The title of the **Increase** button of the Slider.␟0fa71630d40c425b9c366afd7f6c3cecc5bef59d␟8302125540024939132:increment`;
    } let i18n_9; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the **Decrease** button of the Slider.
         * @meaning kendo.slider.decrement
         */
        const MSG_EXTERNAL_652458644240352212$$DIST_FESM2015_INDEX_JS_10 = goog.getMsg("decrement");
        i18n_9 = MSG_EXTERNAL_652458644240352212$$DIST_FESM2015_INDEX_JS_10;
    }
    else {
        i18n_9 = $localize `:kendo.slider.decrement|The title of the **Decrease** button of the Slider.␟042c26f68d78afd6834ea46a5f7533850fe8c800␟652458644240352212:decrement`;
    } let i18n_11; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the drag handle of the Slider.
         * @meaning kendo.slider.dragHandle
         */
        const MSG_EXTERNAL_9117416417579607469$$DIST_FESM2015_INDEX_JS_12 = goog.getMsg("Drag");
        i18n_11 = MSG_EXTERNAL_9117416417579607469$$DIST_FESM2015_INDEX_JS_12;
    }
    else {
        i18n_11 = $localize `:kendo.slider.dragHandle|The title of the drag handle of the Slider.␟481eb98e9cd8ef8e8b22051796441901e883763d␟9117416417579607469:Drag`;
    } return [["kendoSliderLocalizedMessages", "", "increment", i18n_7, "decrement", i18n_9, "dragHandle", i18n_11], [1, "k-slider-wrap", 3, "kendoEventsOutsideAngular"], ["wrap", ""], ["type", "button", "class", "k-button-decrease k-button k-button-md k-rounded-full k-button-rectangle k-button-solid k-button-solid-base k-icon-button", "role", "presentation", 3, "title", 4, "ngIf"], [1, "k-slider-track-wrap"], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate", 4, "ngIf"], [1, "k-slider-track"], ["track", ""], [1, "k-slider-selection"], ["sliderSelection", ""], ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", 3, "title", "id", "kendoPress", "kendoDrag", "kendoRelease"], ["draghandle", ""], ["type", "button", "class", "k-button-increase k-button k-button-md k-rounded-full k-button-rectangle k-button-solid k-button-solid-base k-icon-button", "role", "presentation", 3, "title", "click", 4, "ngIf"], [3, "resize"], ["type", "button", "role", "presentation", 1, "k-button-decrease", "k-button", "k-button-md", "k-rounded-full", "k-button-rectangle", "k-button-solid", "k-button-solid-base", "k-icon-button", 3, "title"], ["decreaseButton", ""], [1, "k-button-icon", "k-icon"], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate"], ["ticks", ""], ["type", "button", "role", "presentation", 1, "k-button-increase", "k-button", "k-button-md", "k-rounded-full", "k-button-rectangle", "k-button-solid", "k-button-solid-base", "k-icon-button", 3, "title", "click"], ["increaseButton", ""]]; }, template: function SliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(3, SliderComponent_button_3_Template, 3, 6, "button", 3);
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtemplate(5, SliderComponent_ul_5_Template, 2, 8, "ul", 5);
        ɵngcc0.ɵɵelementStart(6, "div", 6, 7);
        ɵngcc0.ɵɵelement(8, "div", 8, 9);
        ɵngcc0.ɵɵelementStart(10, "a", 10, 11);
        ɵngcc0.ɵɵlistener("kendoPress", function SliderComponent_Template_a_kendoPress_10_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); })("kendoDrag", function SliderComponent_Template_a_kendoDrag_10_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); })("kendoRelease", function SliderComponent_Template_a_kendoRelease_10_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd()()();
        ɵngcc0.ɵɵtemplate(12, SliderComponent_button_12_Template, 3, 7, "button", 12);
        ɵngcc0.ɵɵelementStart(13, "kendo-resize-sensor", 13);
        ɵngcc0.ɵɵlistener("resize", function SliderComponent_Template_kendo_resize_sensor_resize_13_listener() { return ctx.sizeComponent(false); });
        ɵngcc0.ɵɵelementEnd()();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("k-slider-buttons", ctx.showButtons)("k-slider-topleft", ctx.tickPlacement === "before")("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(22, _c13, ctx.onWrapClick, ctx.onKeyDown));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showButtons);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵproperty("title", ctx.dragHandleMessage)("id", ctx.focusableId);
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.currentValue)("aria-valuetext", ctx.currentValue)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal")("tabindex", ctx.disabled ? "-1" : ctx.tabIndex);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showButtons);
    } }, directives: function () { return [LocalizedSliderMessagesDirective, ɵngcc2.EventsOutsideAngularDirective, ɵngcc3.NgIf, SliderTicksComponent, ɵngcc2.DraggableDirective, ɵngcc2.ResizeSensorComponent]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderComponent.prototype, "dragHandleTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderComponent.prototype, "incrementTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderComponent.prototype, "animate", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderComponent.prototype, "decrementTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderComponent.prototype, "showButtons", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], SliderComponent.prototype, "tabIndex", null);
__decorate([
    ViewChild('draghandle', { static: true }),
    __metadata("design:type", ElementRef)
], SliderComponent.prototype, "draghandle", void 0);
__decorate([
    ViewChild('decreaseButton', { static: false }),
    __metadata("design:type", ElementRef)
], SliderComponent.prototype, "decreaseButton", void 0);
__decorate([
    ViewChild('increaseButton', { static: false }),
    __metadata("design:type", ElementRef)
], SliderComponent.prototype, "increaseButton", void 0);
SliderComponent = SliderComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        Injector,
        Renderer2,
        NgZone,
        ChangeDetectorRef,
        ElementRef])
], SliderComponent);

/**
 * @hidden
 */
class RangeSliderModel extends SliderModelBase {
    positionHandle(dragHandle) {
        if (!dragHandle.id) {
            return;
        }
        const { max, min, reverse, vertical } = this.props;
        const position = vertical ? 'bottom' : 'left';
        const trackWidth = this.trackWidth();
        const value = isStartHandle(dragHandle) ? trimValueRange(max, min, this.props.value)[0]
            : trimValueRange(max, min, this.props.value)[1];
        if (isStartHandle(dragHandle)) {
            this.startHandlePosition = calculateHandlePosition({
                min,
                max,
                reverse,
                value,
                trackWidth
            });
            this.renderer.setStyle(dragHandle, position, `${this.startHandlePosition}px`);
        }
        else {
            this.endHandlePosition = calculateHandlePosition({
                min,
                max,
                reverse,
                value,
                trackWidth
            });
            this.renderer.setStyle(dragHandle, position, `${this.endHandlePosition}px`);
        }
    }
    positionSelection(dragHandle, selection) {
        const { reverse, vertical } = this.props;
        const dimension = vertical ? 'height' : 'width';
        const position = vertical ? 'bottom' : reverse ? 'right' : 'left';
        const size = Math.abs(this.endHandlePosition - this.startHandlePosition);
        const currentSelectionPosition = vertical ? dragHandle.style.bottom : dragHandle.style.left;
        this.renderer.setStyle(selection, dimension, `${size}px`);
        this.renderer.setStyle(selection, position, reverse ? this.trackWidth() - parseFloat(currentSelectionPosition) + 'px'
            : parseFloat(currentSelectionPosition) + 'px');
    }
}

var RangeSliderComponent_1;
const PRESSED$1 = 'k-pressed';
/**
 * Represents the [Kendo UI RangeSlider component for Angular]({% slug overview_rangeslider %}).
 */
let RangeSliderComponent = RangeSliderComponent_1 = class RangeSliderComponent extends SliderBase {
    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {
        super(localization, injector, renderer, ngZone, changeDetector, hostElement);
        this.localization = localization;
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.startHandleId = `k-start-handle-${guid()}`;
        /**
         * @hidden
         */
        this.endHandleId = `k-end-handle-${guid()}`;
        /**
         * @hidden
         */
        this.focusableId = this.startHandleId;
        this.handleZIndex = 0;
        this.activeHandle = 'startHandle';
        this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        this.onWrapClick = (args) => {
            if (!this.isDisabled) {
                this.value = this.value || [this.min, this.min];
                const trackValue = eventValue(args, this.track.nativeElement, this.getProps());
                let newRangeValue;
                const [startValue, endValue] = newRangeValue = this.value;
                if (trackValue <= startValue) {
                    newRangeValue = [trackValue, endValue];
                    this.activeHandle = 'startHandle';
                }
                else if (startValue < trackValue && trackValue < endValue) {
                    if (trackValue < (startValue + endValue) / 2) {
                        newRangeValue = [trackValue, endValue];
                        this.activeHandle = 'startHandle';
                    }
                    else {
                        newRangeValue = [startValue, trackValue];
                        this.activeHandle = 'endHandle';
                    }
                }
                else if (trackValue >= endValue) {
                    newRangeValue = [startValue, trackValue];
                    this.activeHandle = 'endHandle';
                }
                const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;
                invokeElementMethod(activeHandle, 'focus');
                this.changeValue(newRangeValue);
            }
        };
        /**
         * @hidden
         */
        this.onKeyDown = (e) => {
            this.value = this.value || [this.min, this.min];
            const options = this.getProps();
            const { max, min } = options;
            const handler = this.keyBinding[e.keyCode];
            if (this.isDisabled || !handler) {
                return;
            }
            this.renderer.setStyle(e.target, 'zIndex', ++this.handleZIndex);
            const startHandleIsActive = isStartHandle(e.target);
            const value = handler(Object.assign({}, options, { value: startHandleIsActive ? this.value[0] : this.value[1] }));
            if (startHandleIsActive) {
                if (value > this.value[1]) {
                    this.value[1] = value;
                }
            }
            else {
                if (value < this.value[0]) {
                    this.value[0] = value;
                }
            }
            const trimmedValue = trimValue(max, min, value);
            const newValue = startHandleIsActive ? [trimmedValue, this.value[1]]
                : [this.value[0], trimmedValue];
            this.changeValue(newValue);
            e.preventDefault();
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    if (!this.focusChangedProgrammatically) {
                        this.onBlur.emit();
                    }
                });
            }
        };
    }
    /**
     * Focuses the RangeSlider.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *     <div>
     *         <button class="k-button" (click)="slider.focus()">Focus</button>
     *     </div>
     *     <kendo-rangeslider #slider></kendo-rangeslider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        this.focusChangedProgrammatically = true;
        invokeElementMethod(this.draghandleStart, 'focus');
        this.focusChangedProgrammatically = false;
    }
    /**
     * Blurs the RangeSlider.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;
        invokeElementMethod(activeHandle, 'blur');
        this.handleBlur();
        this.focusChangedProgrammatically = false;
    }
    ngOnInit() {
        if (!this.value) {
            this.value = [this.min, this.max];
        }
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {
            if (changes.value && changes.value.currentValue) {
                validateValue(changes.value.currentValue);
            }
            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                this.sizeComponent();
            });
        }
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.sizeComponent();
        if (this.ticks) {
            this.ticks.tickElements
                .changes
                .subscribe(() => this.sizeComponent());
        }
        this.attachElementEventHandlers();
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     */
    get valueText() {
        return this.value ? `${this.value[0]} - ${this.value[1]}` : '';
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (args.originalEvent) {
            args.originalEvent.preventDefault();
        }
        const target = args.originalEvent.target;
        this.draggedHandle = target;
        this.renderer.setStyle(target, 'zIndex', ++this.handleZIndex);
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        this.value = this.value || [this.min, this.min];
        const target = args.originalEvent.target;
        const lastCoords = this.draggedHandle.getBoundingClientRect();
        this.lastHandlePosition = { x: lastCoords.left, y: lastCoords.top };
        this.dragging = { value: true, target };
        const mousePos = {
            x: (args.pageX - 0.5) - (lastCoords.width / 2),
            y: (args.pageY - (lastCoords.width / 2))
        };
        const left = mousePos.x < this.lastHandlePosition.x;
        const right = mousePos.x > this.lastHandlePosition.x;
        const up = mousePos.y > this.lastHandlePosition.y;
        const moveStartHandle = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), this.value[1]]);
        const moveEndHandle = () => this.changeValue([this.value[0], eventValue(args, this.track.nativeElement, this.getProps())]);
        const moveBothHandles = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), eventValue(args, this.track.nativeElement, this.getProps())]);
        const activeStartHandle = isStartHandle(this.draggedHandle);
        const vertical = this.vertical;
        const horizontal = !vertical;
        const forward = (vertical && up) || (this.reverse ? horizontal && right : horizontal && left);
        const incorrectValueState = this.value[0] > this.value[1];
        if (this.value[0] === this.value[1] || incorrectValueState) {
            if (forward) {
                activeStartHandle ? moveStartHandle() : moveBothHandles();
            }
            else {
                activeStartHandle ? moveBothHandles() : moveEndHandle();
            }
        }
        else {
            activeStartHandle ? moveStartHandle() : moveEndHandle();
        }
    }
    /**
     * @hidden
     */
    onHandleRelease(args) {
        this.dragging = { value: false, target: args.originalEvent.target }; //needed for animation
        this.draggedHandle = undefined;
    }
    //ngModel binding
    /**
     * @hidden
     */
    writeValue(value) {
        validateValue(value);
        this.value = value;
        this.sizeComponent();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    changeValue(value) {
        if (!this.value || !isSameRange(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                if (this.value) {
                    this.valueChange.emit(value);
                }
                this.sizeComponent();
            });
        }
    }
    /**
     * @hidden
     */
    sizeComponent() {
        if (!isDocumentAvailable()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const track = this.track.nativeElement;
        const selectionEl = this.sliderSelection.nativeElement;
        const dragHandleStartEl = this.draghandleStart.nativeElement;
        const dragHandleEndEl = this.draghandleEnd.nativeElement;
        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;
        this.resetStyles([track, selectionEl, dragHandleStartEl, dragHandleEndEl, ticks, this.hostElement.nativeElement]);
        const props = this.getProps();
        const model = new RangeSliderModel(props, wrapper, track, this.renderer);
        model.resizeTrack();
        if (this.ticks) { //for case when tickPlacement: none
            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));
        }
        model.positionHandle(dragHandleStartEl);
        model.positionHandle(dragHandleEndEl);
        model.positionSelection(dragHandleStartEl, selectionEl);
        if (this.fixedTickWidth) {
            model.resizeWrapper();
        }
    }
    /**
     * @hidden
     */
    get isDisabled() {
        return this.disabled || this.readonly;
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            this.isFocused = value;
        }
    }
    set dragging(data) {
        if (this.isDragged !== data.value && this.sliderSelection && this.draghandleStart && this.draghandleEnd) {
            const sliderSelection = this.sliderSelection.nativeElement;
            const draghandle = data.target;
            if (data.value) {
                this.renderer.addClass(sliderSelection, PRESSED$1);
                this.renderer.addClass(draghandle, PRESSED$1);
            }
            else {
                this.renderer.removeClass(sliderSelection, PRESSED$1);
                this.renderer.removeClass(draghandle, PRESSED$1);
            }
            this.isDragged = data.value;
        }
    }
    getProps() {
        return {
            disabled: this.disabled,
            fixedTickWidth: this.fixedTickWidth,
            largeStep: this.largeStep,
            max: this.max,
            min: this.min,
            readonly: this.readonly,
            reverse: this.reverse,
            rtl: this.localizationService.rtl,
            smallStep: this.smallStep,
            value: trimValueRange(this.max, this.min, this.value),
            vertical: this.vertical,
            buttons: false
        };
    }
    attachElementEventHandlers() {
        const hostElement = this.hostElement.nativeElement;
        let tabbing = false;
        let cursorInsideWrapper = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        if (!this.focusChangedProgrammatically) {
                            this.onFocus.emit();
                        }
                        this.focused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    if (args.relatedTarget !== this.draghandleStart.nativeElement && args.relatedTarget !== this.draghandleEnd.nativeElement) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    }
};
RangeSliderComponent.ɵfac = function RangeSliderComponent_Factory(t) { return new (t || RangeSliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
RangeSliderComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: RangeSliderComponent, selectors: [["kendo-rangeslider"]], viewQuery: function RangeSliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c14, 7);
        ɵngcc0.ɵɵviewQuery(_c15, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.draghandleStart = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.draghandleEnd = _t.first);
    } }, inputs: { value: "value" }, exportAs: ["kendoRangeSlider"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.rangeslider' },
            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => RangeSliderComponent_1) },
            { provide: KendoInput, useExisting: forwardRef(() => RangeSliderComponent_1) }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 14, vars: 33, consts: function () { let i18n_16; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the **Start** drag handle of the Slider.
         * @meaning kendo.rangeslider.dragHandleStart
         */
        const MSG_EXTERNAL_1512034289801794423$$DIST_FESM2015_INDEX_JS_17 = goog.getMsg("Drag");
        i18n_16 = MSG_EXTERNAL_1512034289801794423$$DIST_FESM2015_INDEX_JS_17;
    }
    else {
        i18n_16 = $localize `:kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider.␟4487c64285c2d8cdb336be783b6cb9304ce86007␟1512034289801794423:Drag`;
    } let i18n_18; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the **End** drag handle of the Slider.
         * @meaning kendo.rangeslider.dragHandleEnd
         */
        const MSG_EXTERNAL_6915505327582510906$$DIST_FESM2015_INDEX_JS_19 = goog.getMsg("Drag");
        i18n_18 = MSG_EXTERNAL_6915505327582510906$$DIST_FESM2015_INDEX_JS_19;
    }
    else {
        i18n_18 = $localize `:kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider.␟d6af522570cc1aff06104cee4b7780d6835e01d1␟6915505327582510906:Drag`;
    } return [["kendoSliderLocalizedMessages", "", "dragHandleStart", i18n_16, "dragHandleEnd", i18n_18], [1, "k-slider-wrap", 3, "kendoEventsOutsideAngular"], ["wrap", ""], [1, "k-slider-track-wrap"], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate", 4, "ngIf"], [1, "k-slider-track"], ["track", ""], [1, "k-slider-selection"], ["sliderSelection", ""], ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", 3, "id", "title", "kendoPress", "kendoDrag", "kendoRelease"], ["draghandleStart", ""], ["draghandleEnd", ""], [3, "resize"], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate"], ["ticks", ""]]; }, template: function RangeSliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2)(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, RangeSliderComponent_ul_4_Template, 2, 8, "ul", 4);
        ɵngcc0.ɵɵelementStart(5, "div", 5, 6);
        ɵngcc0.ɵɵelement(7, "div", 7, 8);
        ɵngcc0.ɵɵelementStart(9, "a", 9, 10);
        ɵngcc0.ɵɵlistener("kendoPress", function RangeSliderComponent_Template_a_kendoPress_9_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); })("kendoDrag", function RangeSliderComponent_Template_a_kendoDrag_9_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); })("kendoRelease", function RangeSliderComponent_Template_a_kendoRelease_9_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "a", 9, 11);
        ɵngcc0.ɵɵlistener("kendoPress", function RangeSliderComponent_Template_a_kendoPress_11_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); })("kendoDrag", function RangeSliderComponent_Template_a_kendoDrag_11_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); })("kendoRelease", function RangeSliderComponent_Template_a_kendoRelease_11_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd()()();
        ɵngcc0.ɵɵelementStart(13, "kendo-resize-sensor", 12);
        ɵngcc0.ɵɵlistener("resize", function RangeSliderComponent_Template_kendo_resize_sensor_resize_13_listener() { return ctx.sizeComponent(); });
        ɵngcc0.ɵɵelementEnd()();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("k-slider-topleft", ctx.tickPlacement === "before")("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(30, _c13, ctx.onWrapClick, ctx.onKeyDown));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵproperty("id", ctx.startHandleId)("title", ctx.textFor("dragHandleStart"));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[0] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵproperty("id", ctx.endHandleId)("title", ctx.textFor("dragHandleEnd"));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[1] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
    } }, directives: function () { return [LocalizedRangeSliderMessagesDirective, ɵngcc2.EventsOutsideAngularDirective, ɵngcc3.NgIf, SliderTicksComponent, ɵngcc2.DraggableDirective, ɵngcc2.ResizeSensorComponent]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], RangeSliderComponent.prototype, "value", void 0);
__decorate([
    ViewChild('draghandleStart', { static: true }),
    __metadata("design:type", ElementRef)
], RangeSliderComponent.prototype, "draghandleStart", void 0);
__decorate([
    ViewChild('draghandleEnd', { static: true }),
    __metadata("design:type", ElementRef)
], RangeSliderComponent.prototype, "draghandleEnd", void 0);
RangeSliderComponent = RangeSliderComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        Injector,
        Renderer2,
        NgZone,
        ChangeDetectorRef,
        ElementRef])
], RangeSliderComponent);

var SwitchComponent_1;
const FOCUSED = 'k-focus';
/**
 * Represents the [Kendo UI Switch component for Angular]({% slug overview_switch %}).
 */
let SwitchComponent = SwitchComponent_1 = class SwitchComponent {
    constructor(renderer, hostElement, localizationService, injector, changeDetector, ngZone) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.localizationService = localizationService;
        this.injector = injector;
        this.changeDetector = changeDetector;
        this.ngZone = ngZone;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines whether the Switch is disabled ([see example]({% slug disabled_switch %})).
         */
        this.disabled = false;
        /**
         * Determines whether the Switch is in its read-only state ([see example]({% slug readonly_switch %})).
         */
        this.readonly = false;
        /**
         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Switch.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the `input` element.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the `input` element gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.initialized = false;
        this.hostClickSubscription = new Subscription;
        this._checked = false;
        this._size = 'medium';
        this._trackRounded = 'full';
        this._thumbRounded = 'full';
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        /**
         * @hidden
         */
        this.handleFocus = () => {
            if (this.isFocused) {
                return;
            }
            this.focused = true;
            if (hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = (event) => {
            const relatedTarget = event && event.relatedTarget;
            if (this.hostElement.nativeElement.contains(relatedTarget)) {
                return;
            }
            this.changeDetector.markForCheck();
            this.focused = false;
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.onBlur.emit();
                });
            }
        };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
        this.keyDownHandler = this.keyDownHandler.bind(this);
        this.clickHandler = this.clickHandler.bind(this);
    }
    /**
     * Sets the value of the Switch when it is initially displayed.
     */
    set checked(value) {
        this.setHostClasses(value);
        this._checked = value;
    }
    get checked() {
        return this._checked;
    }
    /**
     * Specifies the width and height of the Switch.
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set size(size) {
        this.handleClasses(size, 'size');
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * Specifies the border radius of the Switch thumb.
     *
     * The possible values are:
     * * `'full'` (default)
     * * `'small'`
     * * `'medium'`
     * * `'large'`
     * * `null`
     */
    set thumbRounded(thumbRounded) {
        this.handleThumbClasses(thumbRounded);
        this._thumbRounded = thumbRounded;
    }
    get thumbRounded() {
        return this._thumbRounded;
    }
    /**
     * Specifies the border radius of the Switch track.
     *
     * The possible values are:
     * * `'full'` (default)
     * * `'small'`
     * * `'medium'`
     * * `'large'`
     * * `null`
     */
    set trackRounded(trackRounded) {
        this.handleTrackClasses(trackRounded);
        this._trackRounded = trackRounded;
    }
    get trackRounded() {
        return this._trackRounded;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    get ieClass() {
        return browser && browser.msie;
    }
    get ariaDisabled() {
        return this.disabled ? true : undefined;
    }
    get ariaReadonly() {
        return this.readonly;
    }
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get onLabelMessage() {
        return this.onLabel || this.localizationService.get('on');
    }
    /**
     * @hidden
     */
    get offLabelMessage() {
        return this.offLabel || this.localizationService.get('off');
    }
    get isEnabled() {
        return !this.disabled && !this.readonly;
    }
    ngOnInit() {
        if (this.hostElement) {
            const wrapper = this.hostElement.nativeElement;
            this.renderer.removeAttribute(wrapper, "tabindex");
        }
        this.localizationChangeSubscription = this.localizationService
            .changes
            .pipe(skip(1))
            .subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.control = this.injector.get(NgControl, null);
        this.ngZone.onStable.pipe(take(1)).subscribe(() => this.initialized = true);
    }
    ngAfterViewInit() {
        const wrapper = this.hostElement.nativeElement;
        this.attachHostClickHandler();
        if (!this.checked && !wrapper.classList.contains('k-switch-off')) {
            this.renderer.addClass(wrapper, 'k-switch-off');
        }
        this.handleClasses(this.size, 'size');
        this.handleTrackClasses(this.trackRounded);
        this.handleThumbClasses(this.thumbRounded);
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
        if (this.hostClickSubscription) {
            this.hostClickSubscription.unsubscribe();
        }
    }
    /**
     * Focuses the Switch.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="switch.focus()">Focus</button>
     *  <kendo-switch #switch></kendo-switch>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.track) {
            return;
        }
        this.track.nativeElement.focus();
    }
    /**
     * Blurs the Switch.
     */
    blur() {
        if (!this.track) {
            return;
        }
        this.track.nativeElement.blur();
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.changeDetector.markForCheck();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.checked = value === null ? false : value;
        this.changeDetector.markForCheck();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    keyDownHandler(e) {
        const keyCode = e.keyCode;
        if (this.isEnabled && (keyCode === Keys.Space || keyCode === Keys.Enter)) {
            this.changeValue(!this.checked);
            e.preventDefault();
        }
    }
    /**
     * @hidden
     */
    clickHandler() {
        if (this.isEnabled) {
            this.changeValue(!this.checked);
        }
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    changeValue(value) {
        if (this.checked !== value) {
            this.ngZone.run(() => {
                this.checked = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            const wrapper = this.hostElement.nativeElement;
            if (value) {
                this.renderer.addClass(wrapper, FOCUSED);
            }
            else {
                this.renderer.removeClass(wrapper, FOCUSED);
            }
            this.isFocused = value;
        }
    }
    attachHostClickHandler() {
        this.ngZone.runOutsideAngular(() => {
            this.hostClickSubscription.add(this.renderer.listen(this.hostElement.nativeElement, 'click', this.clickHandler));
        });
    }
    setHostClasses(value) {
        const wrapper = this.hostElement.nativeElement;
        if (value) {
            this.renderer.removeClass(wrapper, 'k-switch-off');
            this.renderer.addClass(wrapper, 'k-switch-on');
        }
        else {
            this.renderer.removeClass(wrapper, 'k-switch-on');
            this.renderer.addClass(wrapper, 'k-switch-off');
        }
    }
    handleClasses(value, input) {
        const elem = this.hostElement.nativeElement;
        const classes = getStylingClasses('switch', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
    handleTrackClasses(value) {
        const elem = this.hostElement.nativeElement;
        const track = this.track.nativeElement;
        const classes = getStylingClasses('switch', 'rounded', this.trackRounded, value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
            this.renderer.removeClass(track, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
            this.renderer.addClass(track, classes.toAdd);
        }
    }
    handleThumbClasses(value) {
        const thumb = this.thumb.nativeElement;
        const classes = getStylingClasses('switch', 'rounded', this.thumbRounded, value);
        if (classes.toRemove) {
            this.renderer.removeClass(thumb, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(thumb, classes.toAdd);
        }
    }
};
SwitchComponent.ɵfac = function SwitchComponent_Factory(t) { return new (t || SwitchComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
SwitchComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SwitchComponent, selectors: [["kendo-switch"]], viewQuery: function SwitchComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, 7);
        ɵngcc0.ɵɵviewQuery(_c20, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.track = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumb = _t.first);
    } }, hostVars: 9, hostBindings: function SwitchComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("aria-disabled", ctx.ariaDisabled)("aria-readonly", ctx.ariaReadonly);
        ɵngcc0.ɵɵclassProp("k-switch", ctx.hostClasses)("k-ie", ctx.ieClass)("k-disabled", ctx.disabledClass);
    } }, inputs: { focusableId: "focusableId", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", checked: "checked", size: "size", thumbRounded: "thumbRounded", trackRounded: "trackRounded", tabIndex: "tabIndex", onLabel: "onLabel", offLabel: "offLabel" }, outputs: { onFocus: "focus", onBlur: "blur", valueChange: "valueChange" }, exportAs: ["kendoSwitch"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.switch' },
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => SwitchComponent_1) /* tslint:disable-line */
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => SwitchComponent_1)
            }
        ])], decls: 10, vars: 21, consts: function () { let i18n_21; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The **On** label of the Switch.
         * @meaning kendo.switch.on
         */
        const MSG_EXTERNAL_818154782831456441$$DIST_FESM2015_INDEX_JS_22 = goog.getMsg("ON");
        i18n_21 = MSG_EXTERNAL_818154782831456441$$DIST_FESM2015_INDEX_JS_22;
    }
    else {
        i18n_21 = $localize `:kendo.switch.on|The **On** label of the Switch.␟155f0a38198ffbf0429c5dbf9765e74f246a8617␟818154782831456441:ON`;
    } let i18n_23; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The **Off** label of the Switch.
         * @meaning kendo.switch.off
         */
        const MSG_EXTERNAL_759820891948194060$$DIST_FESM2015_INDEX_JS_24 = goog.getMsg("OFF");
        i18n_23 = MSG_EXTERNAL_759820891948194060$$DIST_FESM2015_INDEX_JS_24;
    }
    else {
        i18n_23 = $localize `:kendo.switch.off|The **Off** label of the Switch.␟79df1a6d2b35c32b2948e3cee56dd3ffe28127bc␟759820891948194060:OFF`;
    } return [["kendoSwitchLocalizedMessages", "", "on", i18n_21, "off", i18n_23], ["role", "switch", 1, "k-switch-track", 3, "id", "kendoEventsOutsideAngular"], ["track", ""], [1, "k-switch-label-on"], [1, "k-switch-label-off"], ["tabindex", "-1", 1, "k-switch-thumb-wrap", 3, "kendoEventsOutsideAngular"], [1, "k-switch-thumb"], ["thumb", ""]]; }, template: function SwitchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1, 2)(3, "span", 3);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "span", 4);
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵelementEnd()();
        ɵngcc0.ɵɵelementStart(7, "span", 5);
        ɵngcc0.ɵɵelement(8, "span", 6, 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("transition-duration", ctx.initialized ? "200ms" : "0ms");
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(13, _c25, ctx.keyDownHandler, ctx.handleFocus, ctx.handleBlur));
        ɵngcc0.ɵɵattribute("aria-checked", ctx.checked)("tabindex", ctx.disabled ? undefined : ctx.tabIndex);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("aria-hidden", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.onLabelMessage);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-hidden", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.offLabelMessage);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("transition-duration", ctx.initialized ? "200ms" : "0ms");
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(17, _c25, ctx.keyDownHandler, ctx.handleFocus, ctx.handleBlur));
    } }, directives: function () { return [LocalizedSwitchMessagesDirective, ɵngcc2.EventsOutsideAngularDirective]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], SwitchComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SwitchComponent.prototype, "onLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SwitchComponent.prototype, "offLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], SwitchComponent.prototype, "checked", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SwitchComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SwitchComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SwitchComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], SwitchComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], SwitchComponent.prototype, "thumbRounded", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], SwitchComponent.prototype, "trackRounded", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], SwitchComponent.prototype, "tabIndex", null);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], SwitchComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], SwitchComponent.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], SwitchComponent.prototype, "valueChange", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], SwitchComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('class.k-ie'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SwitchComponent.prototype, "ieClass", null);
__decorate([
    HostBinding('attr.aria-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SwitchComponent.prototype, "ariaDisabled", null);
__decorate([
    HostBinding('attr.aria-readonly'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SwitchComponent.prototype, "ariaReadonly", null);
__decorate([
    HostBinding('class.k-switch'),
    __metadata("design:type", Boolean)
], SwitchComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SwitchComponent.prototype, "disabledClass", null);
__decorate([
    ViewChild('track', { static: true }),
    __metadata("design:type", Object)
], SwitchComponent.prototype, "track", void 0);
__decorate([
    ViewChild('thumb', { static: true }),
    __metadata("design:type", Object)
], SwitchComponent.prototype, "thumb", void 0);
SwitchComponent = SwitchComponent_1 = __decorate([ __metadata("design:paramtypes", [Renderer2,
        ElementRef,
        LocalizationService,
        Injector,
        ChangeDetectorRef,
        NgZone])
], SwitchComponent);

var TextBoxDirective_1;
/**
 * Represents the [Kendo UI TextBox directive]({% slug overview_textbox %}) for the Inputs components for Angular.
 * Used to style the textbox of any `input` element.
 *
 * @example
 * ```ts-no-run
 * <input kendoTextBox />
 * <input kendoTextBox type="email" />
 * <input kendoTextBox type="password" />
 * ```
 */
let TextBoxDirective = TextBoxDirective_1 = class TextBoxDirective {
    constructor(renderer, inputElement, ngZone) {
        this.renderer = renderer;
        this.inputElement = inputElement;
        this.ngZone = ngZone;
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.onFocus = new EventEmitter();
        /**
         * @hidden
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.onValueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillStart = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillEnd = new EventEmitter();
        this.listeners = [];
    }
    /**
     * @hidden
     */
    set value(text) {
        if (!this.inputElement) {
            return;
        }
        this.inputElement.nativeElement.value = (text === undefined || text === null) ? '' : text;
        this.onValueChange.emit();
    }
    /**
     * @hidden
     */
    get value() {
        return this.inputElement.nativeElement.value;
    }
    get id() {
        return this.inputElement.nativeElement.id;
    }
    set id(id) {
        this.renderer.setAttribute(this.inputElement.nativeElement, 'id', id);
    }
    ngAfterViewInit() {
        const input = this.inputElement.nativeElement;
        this.listeners = [
            this.renderer.listen(input, 'focus', () => this.onFocus.emit()),
            this.renderer.listen(input, 'blur', () => this.onBlur.emit())
        ];
        this.ngZone.runOutsideAngular(() => {
            this.renderer.listen(input, 'animationstart', (e) => {
                if (e.animationName === 'autoFillStart') {
                    this.autoFillStart.emit();
                }
                else if (e.animationName === 'autoFillEnd') {
                    this.autoFillEnd.emit();
                }
            });
        });
    }
    ngOnDestroy() {
        this.listeners.forEach(listener => listener());
    }
};
TextBoxDirective.ɵfac = function TextBoxDirective_Factory(t) { return new (t || TextBoxDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
TextBoxDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TextBoxDirective, selectors: [["input", "kendoTextBox", ""]], hostVars: 10, hostBindings: function TextBoxDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-textbox", ctx.hostClasses)("k-input", ctx.hostClasses)("k-input-md", ctx.hostClasses)("k-rounded-md", ctx.hostClasses)("k-input-solid", ctx.hostClasses);
    } }, inputs: { value: "value" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: KendoInput,
                useExisting: forwardRef(() => TextBoxDirective_1)
            }])] });
__decorate([
    HostBinding('class.k-textbox'),
    HostBinding('class.k-input'),
    HostBinding('class.k-input-md'),
    HostBinding('class.k-rounded-md'),
    HostBinding('class.k-input-solid'),
    __metadata("design:type", Boolean)
], TextBoxDirective.prototype, "hostClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TextBoxDirective.prototype, "value", null);
TextBoxDirective = TextBoxDirective_1 = __decorate([ __metadata("design:paramtypes", [Renderer2,
        ElementRef,
        NgZone])
], TextBoxDirective);

var TextAreaDirective_1;
/**
 * Represents the [Kendo UI TextArea directive for the Inputs components for Angular]({% slug overview_textarea %}).
 * Provides floating labels to `textarea` elements.
 *
 * @example
 * ```ts-no-run
 * <textarea kendoTextArea></textarea>
 * ```
 */
let TextAreaDirective = TextAreaDirective_1 = class TextAreaDirective {
    constructor(renderer, element, zone, changeDetector, injector, rtl) {
        this.renderer = renderer;
        this.element = element;
        this.zone = zone;
        this.changeDetector = changeDetector;
        this.injector = injector;
        this.elementClasses = true;
        this.autofillClass = true;
        /**
         * Fires each time the textarea value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Specifies if the `textarea` element will resize its height automatically
         * ([see example]({% slug overview_textarea %}#toc-auto-resizing)).
         *
         * @default false
         */
        this.autoSize = false;
        /**
         * @hidden
         */
        this.onFocus = new EventEmitter();
        /**
         * @hidden
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.onValueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillStart = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillEnd = new EventEmitter();
        this.listeners = [];
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.direction = rtl ? 'rtl' : 'ltr';
    }
    get id() {
        return this.element.nativeElement.id;
    }
    set id(id) {
        this.renderer.setAttribute(this.element.nativeElement, 'id', id);
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.elementValue = value;
        this.resize();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.setElementProperty('disabled', isDisabled);
    }
    ngOnInit() {
        const element = this.element.nativeElement;
        this.zone.runOutsideAngular(() => {
            this.listeners = [
                this.renderer.listen(element, 'focus', this.handleFocus.bind(this)),
                this.renderer.listen(element, 'blur', this.handleBlur.bind(this)),
                this.renderer.listen(element, 'animationstart', (e) => {
                    if (e.animationName === 'autoFillStart') {
                        this.autoFillStart.emit();
                    }
                    else if (e.animationName === 'autoFillEnd') {
                        this.autoFillEnd.emit();
                    }
                })
            ];
            if (isDocumentAvailable() && this.autoSize) {
                this.resizeSubscription = fromEvent(window, 'resize')
                    .pipe((debounceTime(50)))
                    .subscribe(() => this.resize());
            }
            this.inputSubscription = fromEvent(element, 'input')
                .subscribe(this.handleInput.bind(this));
        });
        this.control = this.injector.get(NgControl, null);
    }
    ngOnChanges(changes) {
        const element = this.element.nativeElement;
        if (changes.value) {
            this.elementValue = this.value;
        }
        if (changes.autoSize) {
            if (this.autoSize) {
                this.initialHeight = element.offsetHeight;
                this.renderer.setStyle(element, 'resize', 'none');
            }
            else {
                this.renderer.setStyle(element, 'overflow-y', 'auto');
                this.renderer.setStyle(element, 'resize', 'both');
                element.style.height = `${this.initialHeight}px`;
            }
        }
        this.zone.onStable.pipe(take(1)).subscribe(() => this.resize());
    }
    ngOnDestroy() {
        this.listeners.forEach(listener => listener());
        if (this.inputSubscription) {
            this.inputSubscription.unsubscribe();
        }
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    get elementValue() {
        if (this.element) {
            return this.element.nativeElement.value;
        }
        return '';
    }
    set elementValue(value) {
        this.setElementProperty('value', (value === undefined || value === null) ? '' : value);
    }
    setElementProperty(name, value) {
        if (this.element) {
            this.renderer.setProperty(this.element.nativeElement, name, value);
        }
    }
    resize() {
        if (!this.autoSize) {
            return;
        }
        const element = this.element.nativeElement;
        this.renderer.setStyle(element, 'overflow-y', 'hidden');
        element.style.height = `${this.initialHeight}px`;
        const scrollHeight = element.scrollHeight;
        if (scrollHeight > this.initialHeight) {
            element.style.height = `${scrollHeight}px`;
        }
    }
    handleInput() {
        const value = this.elementValue;
        this.value = value;
        if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {
            this.zone.run(() => {
                this.ngChange(value);
                this.onValueChange.emit(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
        this.resize();
    }
    handleFocus() {
        if (hasObservers(this.onFocus)) {
            this.zone.run(() => {
                this.onFocus.emit();
            });
        }
    }
    handleBlur() {
        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
            this.zone.run(() => {
                this.ngTouched();
                this.onBlur.emit();
                this.changeDetector.markForCheck();
            });
        }
    }
};
TextAreaDirective.ɵfac = function TextAreaDirective_Factory(t) { return new (t || TextAreaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(RTL, 8)); };
TextAreaDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TextAreaDirective, selectors: [["textarea", "kendoTextArea", ""]], hostVars: 13, hostBindings: function TextAreaDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-textarea", ctx.elementClasses)("k-input", ctx.elementClasses)("k-input-md", ctx.elementClasses)("k-rounded-md", ctx.elementClasses)("k-input-solid", ctx.elementClasses)("k-autofill", ctx.autofillClass);
    } }, inputs: { autoSize: "autoSize", value: "value" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => TextAreaDirective_1),
                multi: true
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => TextAreaDirective_1)
            }]), ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    HostBinding('class.k-textarea'),
    HostBinding('class.k-input'),
    HostBinding('class.k-input-md'),
    HostBinding('class.k-rounded-md'),
    HostBinding('class.k-input-solid'),
    __metadata("design:type", Boolean)
], TextAreaDirective.prototype, "elementClasses", void 0);
__decorate([
    HostBinding('class.k-autofill'),
    __metadata("design:type", Boolean)
], TextAreaDirective.prototype, "autofillClass", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], TextAreaDirective.prototype, "direction", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextAreaDirective.prototype, "valueChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextAreaDirective.prototype, "autoSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextAreaDirective.prototype, "value", void 0);
TextAreaDirective = TextAreaDirective_1 = __decorate([ __param(5, Optional()), __param(5, Inject(RTL)),
    __metadata("design:paramtypes", [Renderer2,
        ElementRef,
        NgZone,
        ChangeDetectorRef,
        Injector, Boolean])
], TextAreaDirective);

/**
 * @hidden
 */
const createMaxValidator = (maxValue) => {
    return (c) => {
        if (!isPresent(maxValue) || !isPresent(c.value) || c.value <= maxValue) {
            return null;
        }
        return {
            maxError: {
                maxValue: maxValue,
                value: c.value
            }
        };
    };
};

/**
 * @hidden
 */
const createMinValidator = (minValue) => {
    return (c) => {
        if (!isPresent(minValue) || !isPresent(c.value) || c.value >= minValue) {
            return null;
        }
        return {
            minError: {
                minValue: minValue,
                value: c.value
            }
        };
    };
};

/**
 * @hidden
 */
const MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-min';
/**
 * @hidden
 */
const MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-max';
/**
 * @hidden
 */
const POINT = ".";
/**
 * @hidden
 */
const INITIAL_SPIN_DELAY = 500;
/**
 * @hidden
 */
const SPIN_DELAY = 50;
/**
 * @hidden
 */
const EXPONENT_REGEX = /[eE][\-+]?([0-9]+)/;

/**
 * @hidden
 */
const numericRegex = (options) => {
    const { autoCorrect, decimals, min } = options;
    let separator = options.separator;
    if (separator === POINT) {
        separator = '\\' + separator;
    }
    const signPattern = autoCorrect && min !== null && min >= 0 ? '' : '-?';
    let numberPattern;
    if (decimals === 0) {
        numberPattern = '\\d*';
    }
    else {
        numberPattern = `(?:(?:\\d+(${separator}\\d*)?)|(?:${separator}\\d*))?`;
    }
    return new RegExp(`^${signPattern}${numberPattern}$`);
};
/**
 * @hidden
 */
const decimalPart = (value) => {
    return value >= 0 ? Math.floor(value) : Math.ceil(value);
};
/**
 * @hidden
 */
const noop = (_) => { }; // tslint:disable-line:no-empty
/**
 * @hidden
 */
const defined = (value) => {
    return typeof value !== 'undefined';
};
/**
 * @hidden
 */
const isNumber = (value) => {
    return !isNaN(value) && value !== null;
};
/**
 * @hidden
 */
function pad(value, digits) {
    const count = digits - String(value).length;
    let result = value;
    if (count > 0) {
        const padString = new Array(count + 1).join("0");
        result = parseFloat(value + padString);
    }
    return result;
}
/**
 * @hidden
 */
const getDeltaFromMouseWheel = (e) => {
    let delta = 0;
    if (e.wheelDelta) {
        delta = e.wheelDelta / 120;
        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
    }
    else if (e.detail) {
        delta = Math.round(-e.detail / 3);
    }
    return delta;
};
/**
 * @hidden
 */
const getCaretPosition = (element) => element.selectionStart;
/**
 * @hidden
 */
const extractSignificantNumericChars = (formattedString, separator) => {
    const significantCharacters = `${separator}0123456789-`;
    return formattedString.split('').reduce((acc, curr) => significantCharacters.includes(curr) ? ++acc : acc, 0);
};
/**
 * @hidden
 */
const isRightClick = (event) => {
    const isRightClickIE = event.button && event.button === 2;
    const isRightClickOther = event.which && event.which === 3;
    return isRightClickIE || isRightClickOther;
};

/**
 * @hidden
 */
var ArrowDirection;
(function (ArrowDirection) {
    ArrowDirection[ArrowDirection["Down"] = -1] = "Down";
    ArrowDirection[ArrowDirection["None"] = 0] = "None";
    ArrowDirection[ArrowDirection["Up"] = 1] = "Up";
})(ArrowDirection || (ArrowDirection = {}));

var NumericTextBoxComponent_1;
const PARSABLE_OPTIONS = ['min', 'max', 'step', 'decimals'];
const PARSABLE_DEFAULTS = {
    decimals: null,
    max: null,
    min: null,
    step: 1
};
const FOCUSED$1 = 'k-focus';
/**
 * Represents the [Kendo UI NumericTextBox component for Angular]({% slug overview_numerictextbox %}).
 */
let NumericTextBoxComponent = NumericTextBoxComponent_1 = class NumericTextBoxComponent {
    constructor(intl, renderer, localizationService, injector, ngZone, changeDetector, hostElement) {
        this.intl = intl;
        this.renderer = renderer;
        this.localizationService = localizationService;
        this.injector = injector;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines whether the NumericTextBox is disabled ([see example]({% slug disabled_numerictextbox %})).
         */
        this.disabled = false;
        /**
         * Determines whether the NumericTextBox is in its read-only state ([see example]({% slug readonly_numerictextbox %})).
         */
        this.readonly = false;
        /**
         * Sets the title of the `input` element of the NumericTextBox.
         */
        this.title = '';
        /**
         * Specifies whether the value will be auto-corrected based on the minimum and maximum values
         * ([see example]({% slug precision_numerictextbox %})).
         */
        this.autoCorrect = false;
        /**
         * Specifies the number of decimals that the user can enter when the input is focused
         * ([see example]({% slug precision_numerictextbox %})).
         */
        this.decimals = null;
        /**
         * Specifies the value that is used to increment or decrement the component value
         * ([see example]({% slug predefinedsteps_numerictextbox %})).
         */
        this.step = 1;
        /**
         * Specifies whether the **Up** and **Down** spin buttons will be rendered
         * ([see example]({% slug spinbuttons_numerictextbox %})).
         */
        this.spinners = true;
        /**
         * Determines whether the built-in minimum or maximum validators are enforced when a form is validated.
         *
         * > The 4.2.0 Angular version introduces the `min` and `max` validation directives. As a result, even if you set `rangeValidation`
         * to `false`, the built-in Angular validators will be executed.
         */
        this.rangeValidation = true;
        /**
         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Determines whether the value of the NumericTextBox will be changed via scrolling. Defaults to `true`.
         *
         * @default true
         */
        this.changeValueOnScroll = true;
        /**
         * Determines whether the whole value will be selected when the NumericTextBox is clicked. Defaults to `true`.
         */
        this.selectOnFocus = true;
        /**
         * Specifies the value of the NumericTextBox
         * ([see example]({% slug formats_numerictextbox %})).
         */
        this.value = null;
        /**
         * Fires each time the user selects a new value ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user focuses the `input` element ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the `input` element gets blurred ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.ArrowDirection = ArrowDirection;
        /**
         * @hidden
         */
        this.arrowDirection = ArrowDirection.None;
        this.hostClasses = true;
        this.inputValue = '';
        this.minValidateFn = noop;
        this.maxValidateFn = noop;
        this._format = "n2";
        this.isPasted = false;
        this.mouseDown = false;
        this._size = 'medium';
        this._rounded = 'medium';
        this._fillMode = 'solid';
        this.ngChange = noop;
        this.ngTouched = noop;
        this.ngValidatorChange = noop;
        this.domEvents = [];
        /**
         * @hidden
         */
        this.increasePress = (e) => {
            this.arrowPress(ArrowDirection.Up, e);
        };
        /**
         * @hidden
         */
        this.decreasePress = (e) => {
            this.arrowPress(ArrowDirection.Down, e);
        };
        /**
         * @hidden
         */
        this.releaseArrow = () => {
            clearTimeout(this.spinTimeout);
            if (this.arrowDirection !== ArrowDirection.None) {
                this.arrowDirection = ArrowDirection.None;
                this.changeDetector.detectChanges();
            }
        };
        /**
         * @hidden
         */
        this.handlePaste = () => {
            this.isPasted = true;
        };
        /**
         * @hidden
         */
        this.handleInput = () => {
            const input = this.numericInput.nativeElement;
            let { selectionStart, selectionEnd, value: inputValue } = input;
            if (this.pressedKey === Keys.NumpadDecimal) {
                inputValue = this.replaceNumpadDotValue();
            }
            if (this.isPasted) {
                inputValue = this.formatInputValue(this.intl.parseNumber(inputValue));
            }
            if (!this.isValid(inputValue)) {
                input.value = this.inputValue;
                this.setSelection(selectionStart - 1, selectionEnd - 1);
                return;
            }
            const parsedValue = this.intl.parseNumber(inputValue);
            let value = this.restrictDecimals(parsedValue);
            if (this.autoCorrect) {
                const limited = this.limitInputValue(value);
                value = limited.value;
                selectionStart = limited.selectionStart;
                selectionEnd = limited.selectionEnd;
            }
            if (parsedValue !== value || this.hasTrailingZeros(inputValue) || !this.focused) {
                this.setInputValue(value);
                this.setSelection(selectionStart, selectionEnd);
            }
            else {
                this.inputValue = inputValue;
            }
            if (this.isPasted) {
                input.value = this.inputValue;
            }
            this.updateValue(value);
            this.previousSelection = null;
            this.isPasted = false;
        };
        /**
         * @hidden
         */
        this.handleDragEnter = () => {
            if (!this.focused && !this.isDisabled) {
                this.setInputValue(this.value, true);
            }
        };
        /**
         * @hidden
         */
        this.handleMouseDown = () => {
            this.mouseDown = true;
        };
        /**
         * @hidden
         */
        this.handleFocus = () => {
            if (!this.focused) {
                this.focused = true;
                if (!this.isDisabled) {
                    const shouldSelectAll = this.selectOnFocus || !this.mouseDown;
                    this.ngZone.runOutsideAngular(() => {
                        setTimeout(() => {
                            if (shouldSelectAll) {
                                this.selectAll();
                            }
                            else {
                                this.selectCaret();
                            }
                        }, 0);
                    });
                }
            }
            this.mouseDown = false;
            if (hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            //blur is thrown before input when dragging the input text in IE
            if (this.inputValue !== this.elementValue) {
                this.handleInput();
            }
            this.setInputValue();
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.onBlur.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleKeyDown = (e) => {
            if (this.isDisabled) {
                return;
            }
            let step;
            if (e.keyCode === Keys.ArrowDown) {
                step = -1;
            }
            else if (e.keyCode === Keys.ArrowUp) {
                step = 1;
            }
            if (step && this.step) {
                e.preventDefault();
                this.addStep(step);
            }
            const input = this.numericInput.nativeElement;
            this.previousSelection = {
                end: input.selectionEnd,
                start: input.selectionStart
            };
            this.pressedKey = e.keyCode;
        };
        /**
         * @hidden
         */
        this.handleWheel = (e) => {
            if (this.focused && !this.isDisabled && this.changeValueOnScroll) {
                e.preventDefault();
                const delta = getDeltaFromMouseWheel(e);
                this.addStep(delta);
            }
        };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    /**
     * Specifies the number format which is used when the NumericTextBox is not focused
     * ([see example]({% slug formats_numerictextbox %})).
     * If `format` is set to `null` or `undefined`, the default format will be used.
     */
    get format() {
        const format = this._format;
        return format !== null && format !== undefined ? format : 'n2';
    }
    set format(value) {
        this._format = value;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * The size property specifies padding of the NumericTextBox internal input element
     * ([see example]({% slug appearance_numerictextbox %}#toc-size)).
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set size(size) {
        this.handleClasses(size, 'size');
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * The rounded property specifies the border radius of the NumericTextBox
     * ([see example]({% slug appearance_numerictextbox %}#toc-rounded)).
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set rounded(rounded) {
        this.handleClasses(rounded, 'rounded');
        this._rounded = rounded;
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * The fillMode property specifies the background and border styles of the NumericTextBox
     * ([see example]({% slug appearance_numerictextbox %}#toc-fillMode)).
     * The possible values are:
     * * `'flat'`
     * * `'solid'` (default)
     * * `'outline'`
     * * `null`
     */
    set fillMode(fillMode) {
        this.handleClasses(fillMode, 'fillMode');
        this._fillMode = fillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    get disableClass() {
        return this.disabled;
    }
    ngOnInit() {
        this.subscriptions = this.localizationService
            .changes
            .subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
        this.ngZone.runOutsideAngular(() => {
            this.domEvents.push(this.renderer.listen(this.hostElement.nativeElement, 'mousewheel', this.handleWheel.bind(this)));
            this.domEvents.push(this.renderer.listen(this.hostElement.nativeElement, 'DOMMouseScroll', this.handleWheel.bind(this)));
        });
    }
    ngAfterViewInit() {
        const stylingInputs = ['size', 'rounded', 'fillMode'];
        stylingInputs.forEach(input => {
            this.handleClasses(this[input], input);
        });
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (anyChanged(PARSABLE_OPTIONS, changes, false)) {
            this.parseOptions(PARSABLE_OPTIONS.filter(option => changes[option]));
        }
        this.verifySettings();
        if (anyChanged(['min', 'max', 'rangeValidation'], changes, false)) {
            this.minValidateFn = this.rangeValidation ? createMinValidator(this.min) : noop;
            this.maxValidateFn = this.rangeValidation ? createMaxValidator(this.max) : noop;
            this.ngValidatorChange();
        }
        if (anyChanged(['autoCorrect', 'decimals', 'min'], changes)) {
            delete this.numericRegex;
        }
        if (anyChanged(['value', 'format'], changes, false)) {
            this.verifyValue(this.value);
            this.value = this.restrictModelValue(this.value);
            if (!this.focused || (this.intl.parseNumber(this.elementValue) !== this.value)) {
                this.setInputValue();
            }
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        clearTimeout(this.spinTimeout);
        this.domEvents.forEach(unbindHandler => unbindHandler());
    }
    /**
     * @hidden
     */
    validate(control) {
        return this.minValidateFn(control) || this.maxValidateFn(control);
    }
    /**
     * @hidden
     */
    registerOnValidatorChange(fn) {
        this.ngValidatorChange = fn;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.verifyValue(value);
        let restrictedValue = this.restrictModelValue(value);
        this.value = restrictedValue;
        this.setInputValue();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.changeDetector.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * Focuses the NumericTextBox.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="numerictextbox.focus()">Focus NumericTextBox</button>
     *  <kendo-numerictextbox #numerictextbox></kendo-numerictextbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        invokeElementMethod(this.numericInput, 'focus');
    }
    /**
     * Blurs the NumericTextBox.
     */
    blur() {
        invokeElementMethod(this.numericInput, 'blur');
    }
    /**
     * Notifies the `NumericTextBoxComponent` that the input value should be changed.
     * Can be used to update the input after setting the component properties directly.
     */
    notifyValueChange() {
        this.setInputValue();
    }
    /**
     * @hidden
     */
    get incrementTitle() {
        return this.localizationService.get('increment');
    }
    /**
     * @hidden
     */
    get decrementTitle() {
        return this.localizationService.get('decrement');
    }
    get decimalSeparator() {
        const numberSymbols = this.intl.numberSymbols();
        return numberSymbols.decimal;
    }
    get elementValue() {
        return this.numericInput.nativeElement.value;
    }
    set elementValue(value) {
        this.renderer.setProperty(this.numericInput.nativeElement, 'value', value);
    }
    get focused() {
        return this.isFocused;
    }
    get hasDecimals() {
        return this.decimals !== null && this.decimals >= 0;
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            const wrap = this.hostElement.nativeElement;
            if (value) {
                this.renderer.addClass(wrap, FOCUSED$1);
            }
            else {
                this.renderer.removeClass(wrap, FOCUSED$1);
            }
            this.isFocused = value;
        }
    }
    get isDisabled() {
        return this.disabled || this.readonly;
    }
    arrowPress(direction, e) {
        e.preventDefault();
        if (this.isDisabled || isRightClick(e)) {
            return;
        }
        if (!mobileOS) {
            this.focused = true;
            this.focus();
        }
        if (this.arrowDirection !== direction) {
            this.arrowDirection = direction;
            this.changeDetector.detectChanges();
        }
        if (this.step) {
            this.spin(direction, INITIAL_SPIN_DELAY);
        }
        else {
            this.setInputValue();
        }
    }
    updateValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
    }
    replaceNumpadDotValue() {
        let value = this.inputValue || "";
        if (this.previousSelection) {
            const input = this.numericInput.nativeElement;
            const { selectionStart, selectionEnd } = input;
            const { start, end } = this.previousSelection;
            input.value = value = value.substring(0, start) + this.decimalSeparator + value.substring(end);
            this.setSelection(selectionStart, selectionEnd);
        }
        return value;
    }
    isValid(value) {
        if (!this.numericRegex) {
            this.numericRegex = numericRegex({
                autoCorrect: this.autoCorrect,
                decimals: this.decimals,
                min: this.min,
                separator: this.decimalSeparator
            });
        }
        return this.numericRegex.test(value);
    }
    spin(step, timeout) {
        clearTimeout(this.spinTimeout);
        this.spinTimeout = window.setTimeout(() => {
            this.spin(step, SPIN_DELAY);
        }, timeout);
        this.addStep(step);
    }
    addStep(step) {
        let value = add(this.value || 0, this.step * step);
        value = this.limitValue(value);
        value = this.restrictDecimals(value);
        this.setInputValue(value);
        this.updateValue(value);
    }
    setSelection(start, end) {
        if (this.focused) {
            invokeElementMethod(this.numericInput, 'setSelectionRange', start, end);
        }
    }
    limitValue(value) {
        let result = value;
        if (!this.isInRange(value)) {
            if (isNumber(this.max) && value > this.max) {
                result = this.max;
            }
            if (isNumber(this.min) && value < this.min) {
                result = this.min;
            }
        }
        return result;
    }
    limitInputValue(value) {
        let { selectionStart, selectionEnd, value: enteredValue } = this.numericInput.nativeElement;
        let limitedValue = value;
        let selectToEnd = false;
        if (!this.isInRange(value)) {
            const lengthChange = enteredValue.length - String(this.inputValue).length;
            const { min, max } = this;
            const hasMax = isNumber(max);
            const hasMin = isNumber(min);
            let padLimit, replaceNext;
            let correctedValue = value;
            if (selectionStart === 0 && this.inputValue.substr(1) === enteredValue) {
                return {
                    selectionEnd: selectionEnd,
                    selectionStart: selectionStart,
                    value: null
                };
            }
            if (hasMax && value > max) {
                if (value > 0) {
                    replaceNext = true;
                }
                else {
                    padLimit = max;
                }
            }
            else if (hasMin && value < min) {
                if (value > 0) {
                    padLimit = min;
                }
                else {
                    replaceNext = true;
                }
            }
            if (padLimit) {
                const paddedValue = this.tryPadValue(value, padLimit);
                if (paddedValue && decimalPart(value) !== decimalPart(padLimit)) {
                    correctedValue = paddedValue;
                    selectToEnd = true;
                }
            }
            else if (replaceNext) {
                if (this.inputValue && selectionStart !== enteredValue.length) {
                    correctedValue = parseFloat(enteredValue.substr(0, selectionStart) +
                        enteredValue.substr(selectionStart + lengthChange));
                }
            }
            limitedValue = this.limitValue(correctedValue);
            selectToEnd = (selectToEnd || limitedValue !== correctedValue) && this.previousSelection &&
                (this.previousSelection.end - this.previousSelection.start + lengthChange) > 0;
        }
        return {
            selectionEnd: selectToEnd ? String(limitedValue).length : selectionEnd,
            selectionStart: selectionStart,
            value: limitedValue
        };
    }
    tryPadValue(value, limit) {
        const limitLength = String(Math.floor(limit)).length;
        const zeroPadded = pad(value, limitLength);
        const zeroPaddedNext = pad(value, limitLength + 1);
        let result;
        if (this.isInRange(zeroPadded)) {
            result = zeroPadded;
        }
        else if (this.isInRange(zeroPaddedNext)) {
            result = zeroPaddedNext;
        }
        return result;
    }
    isInRange(value) {
        return !isNumber(value) || ((!isNumber(this.min) || this.min <= value) && (!isNumber(this.max) || value <= this.max));
    }
    restrictModelValue(value) {
        let result = this.restrictDecimals(value, true);
        if (this.autoCorrect && this.limitValue(result) !== result) {
            result = null;
        }
        return result;
    }
    restrictDecimals(value, round) {
        let result = value;
        if (value && this.hasDecimals) {
            const decimals = this.decimals;
            const stringValue = String(value);
            if (round || EXPONENT_REGEX.test(stringValue)) {
                result = toFixedPrecision(value, decimals);
            }
            else {
                const parts = stringValue.split(POINT);
                let fraction = parts[1];
                if (fraction && fraction.length > decimals) {
                    fraction = fraction.substr(0, decimals);
                    result = parseFloat(`${parts[0]}${POINT}${fraction}`);
                }
            }
        }
        return result;
    }
    formatInputValue(value) {
        let stringValue = String(value);
        const exponentMatch = EXPONENT_REGEX.exec(stringValue);
        if (exponentMatch) {
            stringValue = value.toFixed(limitPrecision(parseInt(exponentMatch[1], 10)));
        }
        return stringValue.replace(POINT, this.decimalSeparator);
    }
    formatValue(value, focused) {
        let formattedValue;
        if (value === null || !defined(value) || value === '') {
            formattedValue = '';
        }
        else if (focused && !this.readonly) {
            formattedValue = this.formatInputValue(value);
        }
        else {
            formattedValue = this.intl.formatNumber(value, this.format);
        }
        return formattedValue;
    }
    setInputValue(value = this.value, focused = this.focused) {
        const formattedValue = this.formatValue(value, focused);
        this.elementValue = formattedValue;
        this.inputValue = formattedValue;
    }
    verifySettings() {
        if (!isDevMode()) {
            return;
        }
        if (this.min !== null && this.max !== null && this.min > this.max) {
            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);
        }
    }
    verifyValue(value) {
        if (isDevMode() && value && typeof value !== 'number') {
            throw new Error(`The NumericTextBox component requires value of type Number and ${JSON.stringify(value)} was set.`);
        }
    }
    parseOptions(options) {
        for (let idx = 0; idx < options.length; idx++) {
            const name = options[idx];
            const value = this[name];
            if (typeof value === 'string') {
                const parsed = parseFloat(value);
                const valid = !isNaN(parsed);
                if (isDevMode() && !valid && value !== '') {
                    throw new Error('The NumericTextBox component requires value of type Number or a String representing ' +
                        `a number for the ${name} property and ${JSON.stringify(value)} was set.`);
                }
                this[name] = valid ? parsed : PARSABLE_DEFAULTS[name];
            }
        }
    }
    intlChange() {
        delete this.numericRegex;
        if (this.numericInput && (!this.focused || !this.isValid(this.elementValue))) {
            this.setInputValue();
        }
    }
    hasTrailingZeros(inputValue) {
        if (this.hasDecimals && this.focused) {
            const fraction = inputValue.split(this.decimalSeparator)[1];
            return fraction && fraction.length > this.decimals && fraction.lastIndexOf('0') === fraction.length - 1;
        }
    }
    selectAll() {
        this.setInputValue();
        this.setSelection(0, this.inputValue.length);
    }
    selectCaret() {
        const caretPosition = getCaretPosition(this.numericInput.nativeElement);
        const formattedValue = this.elementValue;
        const partialValue = formattedValue.substring(0, caretPosition);
        this.setInputValue();
        if (partialValue.length) {
            const significantCharsInFormattedValue = extractSignificantNumericChars(partialValue, this.decimalSeparator);
            const adjustedSignificantChars = this.adjustSignificantChars(formattedValue, significantCharsInFormattedValue);
            this.setSelection(adjustedSignificantChars, adjustedSignificantChars);
        }
        else {
            this.setSelection(0, 0);
        }
    }
    numberOfLeadingZeroes(formattedValue) {
        const separatorIndex = formattedValue.indexOf(this.decimalSeparator);
        const matchedLeadingZeroes = formattedValue.match(/^[^1-9]*?(0+)/);
        if (matchedLeadingZeroes) {
            const lengthOfMatch = matchedLeadingZeroes[0].length;
            const lengthOfLeadingZeroesMatch = matchedLeadingZeroes[1].length;
            return lengthOfMatch === separatorIndex ? lengthOfLeadingZeroesMatch - 1 : lengthOfLeadingZeroesMatch;
        }
        return 0;
    }
    adjustSignificantChars(formattedValue, significantChars) {
        const leadingZeroes = this.numberOfLeadingZeroes(formattedValue);
        if (leadingZeroes > 0) {
            return Math.max(0, significantChars - leadingZeroes);
        }
        return significantChars;
    }
    handleClasses(value, input) {
        const elem = this.hostElement.nativeElement;
        const classes = getStylingClasses('input', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
};
NumericTextBoxComponent.ɵfac = function NumericTextBoxComponent_Factory(t) { return new (t || NumericTextBoxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NumericTextBoxComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NumericTextBoxComponent, selectors: [["kendo-numerictextbox"]], viewQuery: function NumericTextBoxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c26, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.numericInput = _t.first);
    } }, hostVars: 7, hostBindings: function NumericTextBoxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-input", ctx.hostClasses)("k-numerictextbox", ctx.hostClasses)("k-disabled", ctx.disableClass);
    } }, inputs: { focusableId: "focusableId", disabled: "disabled", readonly: "readonly", title: "title", autoCorrect: "autoCorrect", decimals: "decimals", step: "step", spinners: "spinners", rangeValidation: "rangeValidation", tabindex: "tabindex", changeValueOnScroll: "changeValueOnScroll", selectOnFocus: "selectOnFocus", value: "value", format: "format", tabIndex: "tabIndex", size: "size", rounded: "rounded", fillMode: "fillMode", max: "max", min: "min", placeholder: "placeholder", maxlength: "maxlength" }, outputs: { valueChange: "valueChange", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendoNumericTextBox"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.numerictextbox' },
            { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NumericTextBoxComponent_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => NumericTextBoxComponent_1), multi: true },
            { provide: KendoInput, useExisting: forwardRef(() => NumericTextBoxComponent_1) }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 20, consts: function () { let i18n_27; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the **Increment** button in the NumericTextBox
         * @meaning kendo.numerictextbox.increment
         */
        const MSG_EXTERNAL_4467784268438010275$$DIST_FESM2015_INDEX_JS_28 = goog.getMsg("Increase value");
        i18n_27 = MSG_EXTERNAL_4467784268438010275$$DIST_FESM2015_INDEX_JS_28;
    }
    else {
        i18n_27 = $localize `:kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox␟0fc68540ffa04fdc246cf6cf8a1fed085f8b19a5␟4467784268438010275:Increase value`;
    } let i18n_29; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the **Decrement** button in the NumericTextBox
         * @meaning kendo.numerictextbox.decrement
         */
        const MSG_EXTERNAL_3960022057994897997$$DIST_FESM2015_INDEX_JS_30 = goog.getMsg("Decrease value");
        i18n_29 = MSG_EXTERNAL_3960022057994897997$$DIST_FESM2015_INDEX_JS_30;
    }
    else {
        i18n_29 = $localize `:kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox␟df4751834075bf970c77d0da2c960b4e19a6b0dd␟3960022057994897997:Decrease value`;
    } return [["kendoNumericTextBoxLocalizedMessages", "", "increment", i18n_27, "decrement", i18n_29], ["role", "spinbutton", "autocomplete", "off", "autocorrect", "off", 1, "k-input-inner", 3, "id", "tabindex", "disabled", "readonly", "kendoEventsOutsideAngular"], ["numericInput", ""], ["class", "k-input-spinner k-spin-button", 3, "kendoEventsOutsideAngular", 4, "ngIf"], [1, "k-input-spinner", "k-spin-button", 3, "kendoEventsOutsideAngular"], ["type", "button", "tabindex", "-1", 1, "k-spinner-increase", "k-button", "k-icon-button", "k-button-solid", "k-button-solid-base", 3, "kendoEventsOutsideAngular", "title"], [1, "k-button-icon", "k-icon", "k-i-arrow-n"], ["type", "button", "tabindex", "-1", 1, "k-spinner-decrease", "k-button", "k-icon-button", "k-button-solid", "k-button-solid-base", 3, "kendoEventsOutsideAngular", "title"], [1, "k-button-icon", "k-icon", "k-i-arrow-s"]]; }, template: function NumericTextBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelement(1, "input", 1, 2);
        ɵngcc0.ɵɵtemplate(3, NumericTextBoxComponent_span_3_Template, 5, 20, "span", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("tabindex", ctx.tabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction7(12, _c33, ctx.handleMouseDown, ctx.handleDragEnter, ctx.handleKeyDown, ctx.handleInput, ctx.handleFocus, ctx.handleBlur, ctx.handlePaste));
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value)("title", ctx.title)("placeholder", ctx.placeholder)("maxLength", ctx.maxlength);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.spinners);
    } }, directives: function () { return [LocalizedNumericTextBoxMessagesDirective, ɵngcc2.EventsOutsideAngularDirective, ɵngcc3.NgIf]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericTextBoxComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericTextBoxComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "autoCorrect", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NumericTextBoxComponent.prototype, "format", null);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "decimals", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericTextBoxComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "spinners", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "rangeValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], NumericTextBoxComponent.prototype, "tabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "changeValueOnScroll", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "selectOnFocus", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "maxlength", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NumericTextBoxComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NumericTextBoxComponent.prototype, "rounded", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NumericTextBoxComponent.prototype, "fillMode", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], NumericTextBoxComponent.prototype, "valueChange", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], NumericTextBoxComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], NumericTextBoxComponent.prototype, "onBlur", void 0);
__decorate([
    ViewChild('numericInput', { static: true }),
    __metadata("design:type", ElementRef)
], NumericTextBoxComponent.prototype, "numericInput", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], NumericTextBoxComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NumericTextBoxComponent.prototype, "disableClass", null);
__decorate([
    HostBinding('class.k-input'),
    HostBinding('class.k-numerictextbox'),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "hostClasses", void 0);
NumericTextBoxComponent = NumericTextBoxComponent_1 = __decorate([ __metadata("design:paramtypes", [IntlService,
        Renderer2,
        LocalizationService,
        Injector,
        NgZone,
        ChangeDetectorRef,
        ElementRef])
], NumericTextBoxComponent);

/**
 * @hidden
 */
class NumericTextBoxMessages extends ComponentMessages {
}
NumericTextBoxMessages.ɵfac = /*@__PURE__*/ function () { let ɵNumericTextBoxMessages_BaseFactory; return function NumericTextBoxMessages_Factory(t) { return (ɵNumericTextBoxMessages_BaseFactory || (ɵNumericTextBoxMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NumericTextBoxMessages)))(t || NumericTextBoxMessages); }; }();
NumericTextBoxMessages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NumericTextBoxMessages, inputs: { decrement: "decrement", increment: "increment" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericTextBoxMessages.prototype, "decrement", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericTextBoxMessages.prototype, "increment", void 0);

var NumericTextBoxCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let NumericTextBoxCustomMessagesComponent = NumericTextBoxCustomMessagesComponent_1 = class NumericTextBoxCustomMessagesComponent extends NumericTextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
NumericTextBoxCustomMessagesComponent.ɵfac = function NumericTextBoxCustomMessagesComponent_Factory(t) { return new (t || NumericTextBoxCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
NumericTextBoxCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NumericTextBoxCustomMessagesComponent, selectors: [["kendo-numerictextbox-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NumericTextBoxMessages,
                useExisting: forwardRef(() => NumericTextBoxCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NumericTextBoxCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
NumericTextBoxCustomMessagesComponent = NumericTextBoxCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], NumericTextBoxCustomMessagesComponent);

/**
 * @hidden
 */
var ResultType;
(function (ResultType) {
    ResultType[ResultType["Literal"] = 0] = "Literal";
    ResultType[ResultType["Mask"] = 1] = "Mask";
    ResultType[ResultType["Undefined"] = 2] = "Undefined";
})(ResultType || (ResultType = {}));
/**
 * @hidden
 */
class Result {
    constructor(value, rest, type = ResultType.Undefined) {
        this.value = value;
        this.rest = rest;
        this.type = type;
    }
    //map :: Functor f => f a ~> (a -> b) -> f b
    map(fn) {
        return new Result(fn(this.value), this.rest);
    }
    //chain :: Chain m => m a ~> (a -> m b) -> m b
    chain(fn) {
        return fn(this.value, this.rest);
    }
    fold(s, _ /*we don't need it*/) {
        return s(this.value, this.rest);
    }
    concat(r) {
        return this.map((vs, _) => r.chain((v, __) => vs.concat([v])));
    }
    toString() {
        return `Result({ value: '${this.value}', rest: ${this.rest} })`;
    }
}

/**
 * @hidden
 */
class Stream {
    constructor(input = [], control = []) {
        this.input = input;
        this.control = control;
        this.inputCursor = 0;
        this.controlCursor = 0;
    }
    eof() {
        return this.inputCursor >= this.input.length;
    }
    // Get the first value from the input.
    next() {
        return {
            char: this.input[this.inputCursor++],
            control: this.control[this.controlCursor++]
        };
    }
    peek() {
        return {
            char: this.input[this.inputCursor],
            control: this.control[this.controlCursor]
        };
    }
    eat_input() {
        this.inputCursor++;
    }
    eat_control() {
        this.controlCursor++;
    }
    eat() {
        this.inputCursor++;
        this.controlCursor++;
    }
}

const toArray = (value) => (value || '').split('');
const ESCAPE_CHARACTER = '\\';
/**
 * @hidden
 */
class Parser {
    constructor(parse) {
        this.parse = parse;
    }
    run(input, control = '') {
        if (input instanceof Stream) {
            return this.parse(input);
        }
        else {
            return this.parse(new Stream(toArray(input), toArray(control)));
        }
    }
    //map :: Functor f => f a ~> (a -> b) -> f b
    map(f) {
        return new Parser(stream => this.parse(stream).map(f));
    }
    //chain :: Chain m => m a ~> (a -> m b) -> m b
    chain(f) {
        return new Parser(stream => this.parse(stream).chain((v, s) => f(v).run(s)));
    }
    isLiteral(c) {
        return this.run(c).type === ResultType.Literal;
    }
}
/**
 * @hidden
 */
const mask = ({ prompt, promptPlaceholder }) => rule => new Parser(stream => {
    while (!stream.eof()) {
        const { char, control } = stream.peek();
        if (char === control && control === prompt) {
            stream.eat();
            return new Result(prompt, stream, ResultType.Mask);
        }
        if (rule.test(char)) {
            stream.eat();
            return new Result(char, stream, ResultType.Mask);
        }
        if (char === promptPlaceholder) {
            stream.eat();
            return new Result(prompt, stream, ResultType.Mask);
        }
        stream.eat_input();
    }
    stream.eat();
    return new Result(prompt, stream, ResultType.Mask);
});
/**
 * @hidden
 */
const literal = _token => new Parser(stream => {
    //    let {char, control} = stream.peek();
    let char = stream.peek().char;
    if (char === _token) {
        stream.eat();
        return new Result(_token, stream, ResultType.Literal);
    }
    //    if (control === _token) {
    //        while (!stream.eof() && char !== _token) {
    //            stream.eat_input();
    //            char = stream.peek().char;
    //        }
    //    }
    //
    //    if (control !== undefined) {
    //        stream.eat();
    //    }
    return new Result(_token, stream, ResultType.Literal);
});
/**
 * @hidden
 */
const unmask = prompt => rule => new Parser(stream => {
    while (!stream.eof()) {
        const { char, control } = stream.peek();
        if (char === prompt && control === prompt) {
            stream.eat();
            return new Result(char, stream);
        }
        if (rule.test(char)) {
            stream.eat();
            return new Result(char, stream);
        }
        stream.eat_input();
    }
    stream.eat();
    return new Result('', stream);
});
/**
 * @hidden
 */
const unliteral = _token => new Parser(stream => {
    if (stream.eof()) {
        return new Result('', stream);
    }
    const { char } = stream.peek();
    if (char === _token) {
        stream.eat();
    }
    return new Result(_token, stream);
});
/**
 * @hidden
 */
const token = (rules, creator) => new Parser(stream => {
    let { char } = stream.next();
    const rule = rules[char];
    if (char === ESCAPE_CHARACTER) {
        char = stream.next().char;
        return new Result(creator.literal(char), stream);
    }
    if (!rule) {
        return new Result(creator.literal(char), stream);
    }
    return new Result(creator.mask(rule), stream);
});
/**
 * @hidden
 */
const rawMask = ({ prompt, promptPlaceholder }) => new Parser(stream => {
    let { char } = stream.next();
    if (char === prompt) {
        return new Result(promptPlaceholder, stream);
    }
    return new Result(char, stream);
});
/**
 * @hidden
 */
const rawLiteral = includeLiterals => new Parser(stream => {
    let { char } = stream.next();
    if (includeLiterals) {
        return new Result(char, stream);
    }
    return new Result('', stream);
});

/**
 * @hidden
 */
const always = value => new Parser(stream => new Result(value, stream));
/**
 * @hidden
 */
const append = (p1, p2) => p1.chain(vs => p2.map(v => vs.concat([v])));
/**
 * @hidden
 */
const sequence = list => list.reduce((acc, parser) => append(acc, parser), always([]));
/**
 * @hidden
 */
const greedy = parser => new Parser(stream => {
    let result = new Result([], stream);
    while (!stream.eof()) {
        result = result.concat(parser.run(stream));
    }
    return result;
});

/**
 * @hidden
 */
let MaskingService = class MaskingService {
    /**
     * @hidden
     */
    constructor() {
        this.rules = {};
        this.prompt = "_";
        this.mask = "";
        this.promptPlaceholder = " ";
        this.includeLiterals = false;
        this.maskTokens = [];
        this.unmaskTokens = [];
        this.rawTokens = [];
        this.validationTokens = [];
    }
    update({ mask: mask$$1 = '', prompt = '', promptPlaceholder = ' ', rules = {}, includeLiterals = false }) {
        this.mask = mask$$1;
        this.prompt = prompt;
        this.promptPlaceholder = promptPlaceholder;
        this.rules = rules;
        this.includeLiterals = includeLiterals;
        this.tokenize();
    }
    validationValue(maskedValue = '') {
        let value = maskedValue;
        sequence(this.validationTokens)
            .run(maskedValue)
            .fold(unmasked => {
            value = unmasked.join('');
        });
        return value;
    }
    rawValue(maskedValue = '') {
        let value = maskedValue;
        if (!this.rawTokens.length) {
            return value;
        }
        sequence(this.rawTokens)
            .run(maskedValue)
            .fold(unmasked => {
            value = unmasked.join('');
        });
        return value;
    }
    /**
     * @hidden
     */
    maskRaw(rawValue = '') {
        let value = rawValue;
        if (!this.maskTokens.length) {
            return value;
        }
        sequence(this.maskTokens)
            .run(rawValue)
            .fold(masked => {
            value = masked.join('');
        });
        return value;
    }
    maskInput(input, control, splitPoint) {
        if (input.length < control.length) {
            return this.maskRemoved(input, control, splitPoint);
        }
        return this.maskInserted(input, control, splitPoint);
    }
    maskInRange(pasted, oldValue, start, end) {
        let value = '';
        let selection = end;
        const beforeChange = oldValue.split('').slice(0, start);
        const afterChange = oldValue.split('').slice(end);
        sequence(this.maskTokens.slice(start, end))
            .run(pasted)
            .fold(masked => {
            value = beforeChange
                .concat(masked)
                .concat(afterChange)
                .join('');
        });
        return {
            selection,
            value
        };
    }
    maskRemoved(input, control, splitPoint) {
        let value = '';
        let selection = splitPoint;
        const unchanged = input.split('').slice(splitPoint);
        const changed = input.split('').slice(0, splitPoint).join('');
        const take$$1 = this.maskTokens.length - (input.length - splitPoint);
        sequence(this.maskTokens.slice(0, take$$1))
            .run(changed, control)
            .fold(masked => {
            selection = this.adjustPosition(masked, selection);
            value = masked.concat(unchanged).join('');
        });
        return {
            selection,
            value
        };
    }
    adjustPosition(input, selection) {
        const caretChar = input[selection];
        const isLiteral = this.maskTokens[selection].isLiteral(caretChar);
        if (!isLiteral && caretChar !== this.prompt) {
            return selection + 1;
        }
        return selection;
    }
    maskInserted(input, control, splitPoint) {
        let value = '';
        let selection = splitPoint;
        const changed = input.slice(0, splitPoint);
        sequence(this.unmaskTokens)
            .run(changed, control)
            .chain(unmasked => {
            selection = unmasked.join('').length;
            const unchanged = control.slice(selection);
            return sequence(this.maskTokens)
                .run(unmasked.join('') + unchanged, control);
        })
            .fold(masked => {
            value = masked.join('');
        });
        return {
            selection,
            value
        };
    }
    get maskTokenCreator() {
        const { prompt, promptPlaceholder } = this;
        return {
            literal: rule => literal(rule),
            mask: rule => mask({ prompt, promptPlaceholder })(rule)
        };
    }
    get unmaskTokenCreator() {
        return {
            literal: rule => unliteral(rule),
            mask: rule => unmask(this.prompt)(rule)
        };
    }
    get rawTokenCreator() {
        const { prompt, promptPlaceholder, includeLiterals } = this;
        return {
            literal: _ => rawLiteral(includeLiterals),
            mask: _ => rawMask({ prompt, promptPlaceholder })
        };
    }
    get validationTokenCreator() {
        const { prompt } = this;
        return {
            literal: _ => rawLiteral(false),
            mask: _ => rawMask({ prompt, promptPlaceholder: '' })
        };
    }
    tokenize() {
        greedy(token(this.rules, this.maskTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.maskTokens = tokens;
        });
        greedy(token(this.rules, this.unmaskTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.unmaskTokens = tokens;
        });
        greedy(token(this.rules, this.rawTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.rawTokens = tokens;
        });
        greedy(token(this.rules, this.validationTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.validationTokens = tokens;
        });
    }
};
MaskingService.ɵfac = function MaskingService_Factory(t) { return new (t || MaskingService)(); };
MaskingService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MaskingService, factory: function (t) { return MaskingService.ɵfac(t); } });

var MaskedTextBoxComponent_1;
const resolvedPromise = Promise.resolve(null);
const FOCUSED$2 = 'k-focus';
/**
 * Represents the [Kendo UI MaskedTextBox component for Angular]({% slug overview_maskedtextbox %}).
 *
 * @example
 * ```ts-no-run
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *      <kendo-maskedtextbox
 *          [mask]="mask"
 *          [value]="value">
 *      </kendo-maskedtextbox>
 *     `
 * })
 *
 * class AppComponent {
 *  public value: string = "9580128055807792";
 *  public mask: string = "0000-0000-0000-0000";
 * }
 * ```
 */
let MaskedTextBoxComponent = MaskedTextBoxComponent_1 = class MaskedTextBoxComponent {
    constructor(service, renderer, hostElement, ngZone, injector, changeDetector, rtl) {
        this.service = service;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.ngZone = ngZone;
        this.injector = injector;
        this.changeDetector = changeDetector;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})).
         */
        this.disabled = false;
        /**
         * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).
         */
        this.readonly = false;
        /**
         * Represents a prompt character for the masked value.
         * @default `_`
         */
        this.prompt = '_';
        /**
         * Indicates a character which represents an empty position in the raw value.
         * @default ' '
         */
        this.promptPlaceholder = ' ';
        /**
         * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).
         * @default false
         */
        this.includeLiterals = false;
        /**
         * Specifies if the mask should be shown on focus for empty value.
         */
        this.maskOnFocus = false;
        /**
         * Determines whether the built-in mask validator is enforced when a form is validated
         * ([see example]({% slug validation_maskedtextbox %})).
         * @default true
         */
        this.maskValidation = true;
        /**
         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the `input` element.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-maskedtextbox (focus)="handleFocus()"></kendo-maskedtextbox>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log("Component is focused");
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the `input` element gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-maskedtextbox (blur)="handleBlur()"></kendo-maskedtextbox>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log("Component is blurred");
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the value changes.
         */
        this.valueChange = new EventEmitter();
        this.hostClasses = true;
        this.focusClick = false;
        this.defaultRules = {
            "#": /[\d\s\+\-]/,
            "&": /[\S]/,
            "0": /[\d]/,
            "9": /[\d\s]/,
            "?": /[a-zA-Z\s]/,
            "A": /[a-zA-Z0-9]/,
            "C": /./,
            "L": /[a-zA-Z]/,
            "a": /[a-zA-Z0-9\s]/
        };
        this.isPasted = false;
        this.selection = [0, 0];
        this._size = 'medium';
        this._rounded = 'medium';
        this._fillMode = 'solid';
        /**
         * @hidden
         */
        this.handleFocus = () => {
            this.focused = true;
            if (this.maskOnFocus && this.emptyMask) {
                this.updateInput(this.service.maskRaw(this.value));
                this.ngZone.runOutsideAngular(() => {
                    setTimeout(() => { this.setSelection(0, 0); }, 0);
                });
            }
            if (hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleClick = () => {
            if (this.focused && !this.focusClick) {
                this.focusClick = true;
                const { selectionStart, selectionEnd } = this.input.nativeElement;
                if (selectionStart === selectionEnd) {
                    this.setFocusSelection();
                }
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            this.focusClick = false;
            if (this.maskOnFocus && this.emptyMask) {
                this.updateInput(this.maskedValue);
            }
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.onTouched();
                    this.onBlur.emit();
                });
            }
        };
        this.onChange = (_) => { };
        this.onTouched = () => { };
        validatePackage(packageMetadata);
        this.direction = rtl ? 'rtl' : 'ltr';
        this.updateService();
    }
    /**
     * The size property specifies the padding of the MaskedTextBox internal input element
     * ([see example]({% slug appearance_maskedtextbox %}#toc-size)).
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set size(size) {
        this.handleClasses(size, 'size');
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * The rounded property specifies the border radius of the MaskedTextBox
     * ([see example]({% slug appearance_maskedtextbox %}#toc-rounded)).
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set rounded(rounded) {
        this.handleClasses(rounded, 'rounded');
        this._rounded = rounded;
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * The fillMode property specifies the background and border styles of the MaskedTexBox
     * ([see example]({% slug appearance_maskedtextbox %}#toc-fillMode)).
     * The possible values are:
     * * `flat`
     * * `solid` (default)
     * * `outline`
     * * `null`
     */
    set fillMode(fillMode) {
        this.handleClasses(fillMode, 'fillMode');
        this._fillMode = fillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).
     */
    set rules(value) {
        this._rules = Object.assign({}, this.defaultRules, value);
    }
    get rules() {
        return this._rules || this.defaultRules;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    get hostDisabledClass() {
        return this.disabled;
    }
    ngOnInit() {
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
    }
    ngAfterViewInit() {
        const stylingInputs = ['size', 'rounded', 'fillMode'];
        stylingInputs.forEach(input => {
            this.handleClasses(this[input], input);
        });
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the MaskedTextBox is empty.
     */
    isEmpty() {
        if (this.input) {
            return !Boolean(this.input.nativeElement.value);
        }
    }
    /**
     * @hidden
     */
    handleDragDrop() {
        return false;
    }
    /**
     * Focuses the MaskedTextBox.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="maskedinput.focus()">Focus the input</button>
     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.input) {
            return;
        }
        this.input.nativeElement.focus();
        this.setFocusSelection();
    }
    /**
     * Blurs the MaskedTextBox.
     */
    blur() {
        if (!this.input) {
            return;
        }
        this.input.nativeElement.blur();
    }
    /**
     * @hidden
     */
    pasteHandler(e) {
        const { selectionStart, selectionEnd } = e.target;
        if (selectionEnd === selectionStart) {
            return;
        }
        this.isPasted = true;
        this.selection = [selectionStart, selectionEnd];
    }
    /**
     * @hidden
     */
    inputHandler(e) {
        const value = e.target.value;
        const [start, end] = this.selection;
        if (!this.mask) {
            this.updateValueWithEvents(value);
            this.isPasted = false;
            return;
        }
        let result;
        if (this.isPasted) {
            this.isPasted = false;
            const rightPart = this.maskedValue.length - end;
            const to = value.length - rightPart;
            result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);
        }
        else {
            result = this.service.maskInput(value, this.maskedValue || '', e.target.selectionStart);
        }
        this.updateInput(result.value, result.selection);
        this.updateValueWithEvents(result.value);
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (changes.value) {
            this.value = this.normalizeValue();
        }
        if (!this.mask) {
            this.updateInput(this.value);
            return;
        }
        const next = this.extractChanges(changes);
        this.updateService(next);
        const maskedValue = this.service.maskRaw(this.value);
        this.updateInput(maskedValue, null, true);
        if (changes.includeLiterals || isChanged('promptPlaceholder', changes)) {
            resolvedPromise.then(() => {
                this.updateValueWithEvents(this.maskedValue);
            });
        }
    }
    /**
     * @hidden
     * Writes a new value to the element.
     */
    writeValue(value) {
        this.value = this.normalizeValue(value);
        this.updateInput(this.service.maskRaw(this.value));
        if (this.includeLiterals) {
            this.updateValue(this.maskedValue);
        }
    }
    /**
     * @hidden
     * Sets the function that will be called when a `change` event is triggered.
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @hidden
     * Sets the function that will be called when a `touch` event is triggered.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.changeDetector.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    validate(_) {
        if (this.maskValidation === false || !this.mask) {
            return null;
        }
        if (!this.service.validationValue(this.maskedValue)) {
            return null;
        }
        if (this.maskedValue.indexOf(this.prompt) !== -1) {
            return {
                patternError: {
                    mask: this.mask,
                    maskedValue: this.maskedValue,
                    value: this.value
                }
            };
        }
        return null;
    }
    /**
     * @hidden
     */
    updateValueWithEvents(maskedValue) {
        this.updateValue(maskedValue);
        if (hasObservers(this.valueChange)) {
            this.valueChange.emit(this.value);
        }
    }
    updateValue(value) {
        if (this.mask && !this.service.validationValue(value) && !this.includeLiterals) {
            this.value = '';
        }
        else {
            this.value = this.service.rawValue(value);
        }
        this.onChange(this.value);
    }
    updateInput(maskedValue = '', selection, isFromOnChanges) {
        if (isFromOnChanges && maskedValue === this.maskedValue) {
            return;
        }
        this.maskedValue = maskedValue;
        const value = this.maskOnFocus && !this.focused && this.emptyMask ? '' : maskedValue;
        this.renderer.setProperty(this.input.nativeElement, "value", value);
        if (selection !== undefined) {
            this.setSelection(selection, selection);
        }
    }
    extractChanges(changes) {
        return Object.keys(changes).filter(key => key !== 'rules').reduce((obj, key) => {
            obj[key] = changes[key].currentValue;
            return obj;
        }, {}); // tslint:disable-line:align
    }
    updateService(extra) {
        const config = Object.assign({
            includeLiterals: this.includeLiterals,
            mask: this.mask,
            prompt: this.prompt,
            promptPlaceholder: this.promptPlaceholder,
            rules: this.rules
        }, extra); // tslint:disable-line:align
        this.service.update(config);
    }
    setSelection(start = this.selection[0], end = this.selection[1]) {
        if (this.focused) {
            invokeElementMethod(this.input, 'setSelectionRange', start, end);
        }
    }
    get emptyMask() {
        return this.service.maskRaw() === this.maskedValue;
    }
    setFocusSelection() {
        const selectionStart = this.input.nativeElement.selectionStart;
        const index = this.maskedValue ? this.maskedValue.indexOf(this.prompt) : 0;
        if (index >= 0 && index < selectionStart) {
            this.selection = [index, index];
            this.setSelection();
        }
    }
    get focused() {
        return this.isFocused;
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            const element = this.hostElement.nativeElement;
            if (value) {
                this.renderer.addClass(element, FOCUSED$2);
            }
            else {
                this.renderer.removeClass(element, FOCUSED$2);
            }
            this.isFocused = value;
        }
    }
    normalizeValue(value = this.value) {
        const present = isPresent(value);
        if (present && typeof value !== 'string') {
            if (isDevMode()) {
                throw new Error('The MaskedTextBox component supports only string values.');
            }
            return String(value);
        }
        return present ? value : '';
    }
    handleClasses(value, input) {
        const elem = this.hostElement.nativeElement;
        const classes = getStylingClasses('input', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
};
MaskedTextBoxComponent.ɵfac = function MaskedTextBoxComponent_Factory(t) { return new (t || MaskedTextBoxComponent)(ɵngcc0.ɵɵdirectiveInject(MaskingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(RTL, 8)); };
MaskedTextBoxComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MaskedTextBoxComponent, selectors: [["kendo-maskedtextbox"]], viewQuery: function MaskedTextBoxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c34, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 7, hostBindings: function MaskedTextBoxComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("paste", function MaskedTextBoxComponent_paste_HostBindingHandler($event) { return ctx.pasteHandler($event); })("input", function MaskedTextBoxComponent_input_HostBindingHandler($event) { return ctx.inputHandler($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-input", ctx.hostClasses)("k-maskedtextbox", ctx.hostClasses)("k-disabled", ctx.hostDisabledClass);
    } }, inputs: { focusableId: "focusableId", disabled: "disabled", readonly: "readonly", prompt: "prompt", promptPlaceholder: "promptPlaceholder", includeLiterals: "includeLiterals", maskOnFocus: "maskOnFocus", maskValidation: "maskValidation", tabindex: "tabindex", size: "size", rounded: "rounded", fillMode: "fillMode", rules: "rules", tabIndex: "tabIndex", value: "value", title: "title", mask: "mask" }, outputs: { onFocus: "focus", onBlur: "blur", valueChange: "valueChange" }, exportAs: ["kendoMaskedTextBox"], features: [ɵngcc0.ɵɵProvidersFeature([
            MaskingService,
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */
            },
            {
                multi: true,
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => MaskedTextBoxComponent_1)
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 12, consts: [["type", "text", "autocomplete", "off", "autocorrect", "off", "autocapitalize", "off", "spellcheck", "false", 1, "k-input-inner", 3, "id", "tabindex", "disabled", "readonly", "kendoEventsOutsideAngular"], ["input", ""]], template: function MaskedTextBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "input", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("tabindex", ctx.tabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction5(6, _c35, ctx.handleFocus, ctx.handleBlur, ctx.handleClick, ctx.handleDragDrop, ctx.handleDragDrop));
        ɵngcc0.ɵɵattribute("title", ctx.title);
    } }, directives: [ɵngcc2.EventsOutsideAngularDirective], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MaskedTextBoxComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MaskedTextBoxComponent.prototype, "rounded", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MaskedTextBoxComponent.prototype, "fillMode", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "mask", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MaskedTextBoxComponent.prototype, "rules", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "prompt", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "promptPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "includeLiterals", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "maskOnFocus", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "maskValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], MaskedTextBoxComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], MaskedTextBoxComponent.prototype, "tabIndex", null);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], MaskedTextBoxComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], MaskedTextBoxComponent.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MaskedTextBoxComponent.prototype, "valueChange", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('class.k-input'),
    HostBinding('class.k-maskedtextbox'),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], MaskedTextBoxComponent.prototype, "hostDisabledClass", null);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], MaskedTextBoxComponent.prototype, "input", void 0);
__decorate([
    HostListener('paste', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], MaskedTextBoxComponent.prototype, "pasteHandler", null);
__decorate([
    HostListener('input', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], MaskedTextBoxComponent.prototype, "inputHandler", null);
MaskedTextBoxComponent = MaskedTextBoxComponent_1 = __decorate([ __param(6, Optional()), __param(6, Inject(RTL)),
    __metadata("design:paramtypes", [MaskingService,
        Renderer2,
        ElementRef,
        NgZone,
        Injector,
        ChangeDetectorRef, Boolean])
], MaskedTextBoxComponent);

/**
 * @hidden
 */
class SliderTick {
    constructor(value) {
        this.value = value;
        this.classes = {
            'k-tick': true
        };
    }
}
/**
 * @hidden
 */
let SliderTicksComponent = class SliderTicksComponent {
    /**
     * @hidden
     */
    constructor() {
        this.wrapperClasses = 'k-reset k-slider-items';
        this.ticks = [];
    }
    ngOnChanges(_) {
        this.createTicks();
    }
    createTicks() {
        const count = calculateTicksCount(this.min, this.max, this.step);
        const largeStep = this.largeStep;
        const tickValueProps = {
            max: this.max,
            min: this.min,
            smallStep: this.step
        };
        let result = [];
        for (let i = 0; i < count; i++) {
            result.push(new SliderTick(calculateValueFromTick(i, tickValueProps)));
            if (largeStep && i % largeStep === 0) {
                result[i].large = true;
                result[i].classes['k-tick-large'] = true;
            }
        }
        if (result.length > 0) {
            Object.assign(result[0].classes, this.endTickClasses(true));
            Object.assign(result[result.length - 1].classes, this.endTickClasses(false));
        }
        this.ticks = result;
    }
    endTickClasses(first) {
        return {
            'k-first': (first && !this.vertical) || (!first && this.vertical),
            'k-last': (!first && !this.vertical) || (first && this.vertical)
        };
    }
};
SliderTicksComponent.ɵfac = function SliderTicksComponent_Factory(t) { return new (t || SliderTicksComponent)(); };
SliderTicksComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SliderTicksComponent, selectors: [["", "kendoSliderTicks", ""]], viewQuery: function SliderTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c36, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tickElements = _t);
    } }, hostVars: 2, hostBindings: function SliderTicksComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.wrapperClasses);
    } }, inputs: { tickTitle: "tickTitle", vertical: "vertical", step: "step", largeStep: "largeStep", min: "min", max: "max", labelTemplate: "labelTemplate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c37, decls: 3, vars: 1, consts: [["role", "presentation", 3, "ngClass", "title", 4, "ngFor", "ngForOf"], ["defaultLabel", ""], ["role", "presentation", 3, "ngClass", "title"], ["tickElement", ""], [3, "ngSwitch"], ["class", "k-label", 4, "ngSwitchCase"], [4, "ngSwitchCase"], [1, "k-label"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function SliderTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SliderTicksComponent_li_0_Template, 5, 5, "li", 0);
        ɵngcc0.ɵɵtemplate(1, SliderTicksComponent_ng_template_1_Template, 1, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
    } }, directives: [ɵngcc3.NgForOf, ɵngcc3.NgClass, ɵngcc3.NgSwitch, ɵngcc3.NgSwitchCase, ɵngcc3.NgTemplateOutlet], encapsulation: 2 });
__decorate([
    HostBinding('class'),
    __metadata("design:type", String)
], SliderTicksComponent.prototype, "wrapperClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SliderTicksComponent.prototype, "tickTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderTicksComponent.prototype, "vertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderTicksComponent.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderTicksComponent.prototype, "largeStep", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderTicksComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderTicksComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], SliderTicksComponent.prototype, "labelTemplate", void 0);
__decorate([
    ViewChildren('tickElement'),
    __metadata("design:type", QueryList)
], SliderTicksComponent.prototype, "tickElements", void 0);

/**
 * @hidden
 */
let SlidersCommonModule = class SlidersCommonModule {
};
SlidersCommonModule.ɵfac = function SlidersCommonModule_Factory(t) { return new (t || SlidersCommonModule)(); };
SlidersCommonModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: SlidersCommonModule });
SlidersCommonModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, DraggableModule, EventsModule, ResizeSensorModule], DraggableModule,
        EventsModule,
        ResizeSensorModule] });

/**
 * @hidden
 */
class SliderMessages extends ComponentMessages {
}
SliderMessages.ɵfac = /*@__PURE__*/ function () { let ɵSliderMessages_BaseFactory; return function SliderMessages_Factory(t) { return (ɵSliderMessages_BaseFactory || (ɵSliderMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(SliderMessages)))(t || SliderMessages); }; }();
SliderMessages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SliderMessages, inputs: { decrement: "decrement", increment: "increment", dragHandle: "dragHandle" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderMessages.prototype, "decrement", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderMessages.prototype, "increment", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderMessages.prototype, "dragHandle", void 0);

var LocalizedSliderMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedSliderMessagesDirective = LocalizedSliderMessagesDirective_1 = class LocalizedSliderMessagesDirective extends SliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
LocalizedSliderMessagesDirective.ɵfac = function LocalizedSliderMessagesDirective_Factory(t) { return new (t || LocalizedSliderMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedSliderMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LocalizedSliderMessagesDirective, selectors: [["", "kendoSliderLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: SliderMessages,
                useExisting: forwardRef(() => LocalizedSliderMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
LocalizedSliderMessagesDirective = LocalizedSliderMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LocalizedSliderMessagesDirective);

var SliderCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let SliderCustomMessagesComponent = SliderCustomMessagesComponent_1 = class SliderCustomMessagesComponent extends SliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
SliderCustomMessagesComponent.ɵfac = function SliderCustomMessagesComponent_Factory(t) { return new (t || SliderCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
SliderCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SliderCustomMessagesComponent, selectors: [["kendo-slider-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: SliderMessages,
                useExisting: forwardRef(() => SliderCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SliderCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
SliderCustomMessagesComponent = SliderCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], SliderCustomMessagesComponent);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Slider component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Inputs module
 * import { SliderModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, SliderModule], // import Slider module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let SliderModule = class SliderModule {
};
SliderModule.ɵfac = function SliderModule_Factory(t) { return new (t || SliderModule)(); };
SliderModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: SliderModule });
SliderModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, SlidersCommonModule]] });

/**
 * @hidden
 */
class RangeSliderMessages extends ComponentMessages {
}
RangeSliderMessages.ɵfac = /*@__PURE__*/ function () { let ɵRangeSliderMessages_BaseFactory; return function RangeSliderMessages_Factory(t) { return (ɵRangeSliderMessages_BaseFactory || (ɵRangeSliderMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(RangeSliderMessages)))(t || RangeSliderMessages); }; }();
RangeSliderMessages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: RangeSliderMessages, inputs: { dragHandleStart: "dragHandleStart", dragHandleEnd: "dragHandleEnd" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], RangeSliderMessages.prototype, "dragHandleStart", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RangeSliderMessages.prototype, "dragHandleEnd", void 0);

var LocalizedRangeSliderMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedRangeSliderMessagesDirective = LocalizedRangeSliderMessagesDirective_1 = class LocalizedRangeSliderMessagesDirective extends RangeSliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
LocalizedRangeSliderMessagesDirective.ɵfac = function LocalizedRangeSliderMessagesDirective_Factory(t) { return new (t || LocalizedRangeSliderMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedRangeSliderMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LocalizedRangeSliderMessagesDirective, selectors: [["", "kendoSliderLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: RangeSliderMessages,
                useExisting: forwardRef(() => LocalizedRangeSliderMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
LocalizedRangeSliderMessagesDirective = LocalizedRangeSliderMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LocalizedRangeSliderMessagesDirective);

var RangeSliderCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let RangeSliderCustomMessagesComponent = RangeSliderCustomMessagesComponent_1 = class RangeSliderCustomMessagesComponent extends RangeSliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
RangeSliderCustomMessagesComponent.ɵfac = function RangeSliderCustomMessagesComponent_Factory(t) { return new (t || RangeSliderCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
RangeSliderCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: RangeSliderCustomMessagesComponent, selectors: [["kendo-rangeslider-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: RangeSliderMessages,
                useExisting: forwardRef(() => RangeSliderCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function RangeSliderCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
RangeSliderCustomMessagesComponent = RangeSliderCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], RangeSliderCustomMessagesComponent);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the RangeSlider component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Inputs module
 * import { RangeSliderModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, RangeSliderModule], // import RangeSlider module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let RangeSliderModule = class RangeSliderModule {
};
RangeSliderModule.ɵfac = function RangeSliderModule_Factory(t) { return new (t || RangeSliderModule)(); };
RangeSliderModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: RangeSliderModule });
RangeSliderModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, SlidersCommonModule]] });

/**
 * @hidden
 */
class Messages extends ComponentMessages {
}
Messages.ɵfac = /*@__PURE__*/ function () { let ɵMessages_BaseFactory; return function Messages_Factory(t) { return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages)))(t || Messages); }; }();
Messages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: Messages, inputs: { on: "on", off: "off" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "on", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "off", void 0);

var LocalizedSwitchMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedSwitchMessagesDirective = LocalizedSwitchMessagesDirective_1 = class LocalizedSwitchMessagesDirective extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
};
LocalizedSwitchMessagesDirective.ɵfac = function LocalizedSwitchMessagesDirective_Factory(t) { return new (t || LocalizedSwitchMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedSwitchMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LocalizedSwitchMessagesDirective, selectors: [["", "kendoSwitchLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedSwitchMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
LocalizedSwitchMessagesDirective = LocalizedSwitchMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LocalizedSwitchMessagesDirective);

var SwitchCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let SwitchCustomMessagesComponent = SwitchCustomMessagesComponent_1 = class SwitchCustomMessagesComponent extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
SwitchCustomMessagesComponent.ɵfac = function SwitchCustomMessagesComponent_Factory(t) { return new (t || SwitchCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
SwitchCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SwitchCustomMessagesComponent, selectors: [["kendo-switch-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => SwitchCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SwitchCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
SwitchCustomMessagesComponent = SwitchCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], SwitchCustomMessagesComponent);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Switch component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Switch module
 * import { SwitchModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, SwitchModule], // import Switch module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let SwitchModule = class SwitchModule {
};
SwitchModule.ɵfac = function SwitchModule_Factory(t) { return new (t || SwitchModule)(); };
SwitchModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: SwitchModule });
SwitchModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, EventsModule, ResizeSensorModule]] });

var LocalizedNumericTextBoxMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedNumericTextBoxMessagesDirective = LocalizedNumericTextBoxMessagesDirective_1 = class LocalizedNumericTextBoxMessagesDirective extends NumericTextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
LocalizedNumericTextBoxMessagesDirective.ɵfac = function LocalizedNumericTextBoxMessagesDirective_Factory(t) { return new (t || LocalizedNumericTextBoxMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedNumericTextBoxMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LocalizedNumericTextBoxMessagesDirective, selectors: [["", "kendoNumericTextBoxLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NumericTextBoxMessages,
                useExisting: forwardRef(() => LocalizedNumericTextBoxMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
LocalizedNumericTextBoxMessagesDirective = LocalizedNumericTextBoxMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LocalizedNumericTextBoxMessagesDirective);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the NumericTextBox component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the NumericTextBox module
 * import { NumericTextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, NumericTextBoxModule], // import NumericTextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let NumericTextBoxModule = class NumericTextBoxModule {
};
NumericTextBoxModule.ɵfac = function NumericTextBoxModule_Factory(t) { return new (t || NumericTextBoxModule)(); };
NumericTextBoxModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NumericTextBoxModule });
NumericTextBoxModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, EventsModule]] });

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the MaskedTextBox component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the MaskedTextBox module
 * import { MaskedTextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, MaskedTextBoxModule], // import MaskedTextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let MaskedTextBoxModule = class MaskedTextBoxModule {
};
MaskedTextBoxModule.ɵfac = function MaskedTextBoxModule_Factory(t) { return new (t || MaskedTextBoxModule)(); };
MaskedTextBoxModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MaskedTextBoxModule });
MaskedTextBoxModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, EventsModule]] });

/**
 * @hidden
 *
 * Returns true if the used browser is Safari.
 */
const isSafari = (userAgent) => {
    const desktopBrowser = detectDesktopBrowser(userAgent);
    const mobileOS$$1 = detectMobileOS(userAgent);
    return (desktopBrowser && desktopBrowser.safari) || (mobileOS$$1 && mobileOS$$1.browser === 'mobilesafari');
};
/**
 * @hidden
 *
 * Checks if input is Japanese IME
 */
const isJapanese = (input) => {
    const japaneseRegex = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
    return japaneseRegex.test(input);
};

/**
 * Specifies the adornments in the suffix container ([see examples]({% slug adornments_textbox %}#toc-suffixadornments)).
 * ```ts-no-run
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-textbox>
 *    <ng-template kendoTextBoxSuffixTemplate>
 *        <button kendoButton look="clear" icon="image"></button>
 *    </ng-template>
 *  </kendo-textbox>
 * `
 * })
 * class AppComponent {}
 * ```
 */
let TextBoxSuffixTemplateDirective = class TextBoxSuffixTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
TextBoxSuffixTemplateDirective.ɵfac = function TextBoxSuffixTemplateDirective_Factory(t) { return new (t || TextBoxSuffixTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
TextBoxSuffixTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TextBoxSuffixTemplateDirective, selectors: [["", "kendoTextBoxSuffixTemplate", ""]] });
TextBoxSuffixTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], TextBoxSuffixTemplateDirective);

/**
 * Specifies the adornments in the prefix container ([see examples]({% slug adornments_textbox %}#toc-prefixadornments)).
 * @example
 * ```ts-no-run
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-textbox>
 *    <ng-template kendoTextBoxPrefixTemplate>
 *        <button kendoButton look="clear" icon="image"></button>
 *    </ng-template>
 *  </kendo-textbox>
 * `
 * })
 * class AppComponent {}
 * ```
 */
let TextBoxPrefixTemplateDirective = class TextBoxPrefixTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
TextBoxPrefixTemplateDirective.ɵfac = function TextBoxPrefixTemplateDirective_Factory(t) { return new (t || TextBoxPrefixTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
TextBoxPrefixTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TextBoxPrefixTemplateDirective, selectors: [["", "kendoTextBoxPrefixTemplate", ""]] });
TextBoxPrefixTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], TextBoxPrefixTemplateDirective);

var TextBoxComponent_1;
const FOCUSED$3 = 'k-focus';
let TextBoxComponent = TextBoxComponent_1 = class TextBoxComponent {
    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.injector = injector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Sets the `title` attribute of the `input` element of the TextBox.
         */
        this.title = '';
        /**
         * Sets the disabled state of the component.
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         *
         * @default false
         */
        this.readonly = false;
        /**
         * Specifies the `tabindex` of the TextBox.
         *
         * @default 0
         */
        this.tabindex = 0;
        /**
         * Provides a value for the TextBox.
         */
        this.value = null;
        /**
         * Determines whether the whole value will be selected when the TextBox is clicked. Defaults to `false`.
         *
         * @default false
         */
        this.selectOnFocus = false;
        /**
         * Specifies when the Success icon will be shown ([see example]({% slug validation_textbox %})).
         *
         * The possible values are:
         *
         * `boolean`&mdash;The Success icon is displayed, if the condition given by the developer is met.
         *
         * `initial`&mdash;The Success icon will be displayed when the component state is neither `invalid` nor `touched` or `dirty`.
         *
         * @default false
         */
        this.showSuccessIcon = false;
        /**
         * Specifies when the Error icon will be shown ([see example]({% slug validation_textbox %})).
         *
         * The possible values are:
         *
         * * `initial`&mdash;The Error icon will be displayed when the component state is
         * `invalid` and `touched` or `dirty`.
         * * `boolean`&mdash;The Error icon is displayed, if the condition given by the developer is met.
         *
         * @default false
         */
        this.showErrorIcon = false;
        /**
         * Specifies whether a Clear button will be rendered.
         *
         * @default false
         */
        this.clearButton = false;
        /**
         * Fires each time the value is changed&mdash;
         * when the component is blurred or the value is cleared through the **Clear** button
         * ([see example]({% slug overview_textbox %}#toc-events)).
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user focuses the `input` element.
         */
        this.inputFocus = new EventEmitter();
        /**
         * Fires each time the `input` element gets blurred.
         */
        this.inputBlur = new EventEmitter();
        /**
         * Fires each time the user focuses the TextBox component.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textbox (focus)="handleFocus()"></kendo-textbox>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log('Component is isFocused');
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the TextBox component gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textbox (blur)="handleBlur()"></kendo-textbox>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log('Component is blurred');
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter();
        this.hostClasses = true;
        this._isFocused = false;
        this.focusChangedProgrammatically = false;
        this._size = 'medium';
        this._rounded = 'medium';
        this._fillMode = 'solid';
        /**
         * @hidden
         */
        this.handleInputFocus = () => {
            if (!this.disabled) {
                if (this.selectOnFocus && this.value) {
                    this.ngZone.run(() => {
                        setTimeout(() => { this.selectAll(); });
                    });
                }
                if (hasObservers(this.onFocus)) {
                    if (!this.isFocused) {
                        this.ngZone.run(() => {
                            this.onFocus.emit();
                        });
                    }
                }
                if (hasObservers(this.inputFocus)) {
                    if (!this.focusChangedProgrammatically || (this.focusChangedProgrammatically && this.clearButtonClicked)) {
                        this.ngZone.run(() => {
                            this.inputFocus.emit();
                        });
                    }
                }
                this.ngZone.run(() => {
                    this.isFocused = true;
                });
            }
        };
        /**
         * @hidden
         */
        this.handleInputBlur = () => {
            this.changeDetector.markForCheck();
            if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.inputBlur.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleInput = (ev) => {
            const target = ev.target;
            const isBrowserSafari = isSafari(navigator.userAgent);
            const incomingValue = isBrowserSafari && isJapanese(target.value) ? ev.data : target.value;
            const [caretStart, caretEnd] = [target.selectionStart, target.selectionEnd];
            this.updateValue(incomingValue);
            if (isBrowserSafari) {
                target.setSelectionRange(caretStart, caretEnd);
            }
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    /**
     * The size property specifies the padding of the TextBox internal input element
     * ([see example]({% slug appearance_textbox %}#toc-size)).
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set size(size) {
        this.handleClasses(size, 'size');
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * The rounded property specifies the border radius of the TextBox
     * ([see example]({% slug appearance_textbox %}#toc-rounded)).
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `'full'`
     * * `null`
     */
    set rounded(rounded) {
        this.handleClasses(rounded, 'rounded');
        this._rounded = rounded;
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * The fillMode property specifies the background and border styles of the TextBox
     * ([see example]({% slug appearance_textbox %}#toc-fillMode)).
     *
     * The possible values are:
     * * `'flat'`
     * * `'solid'` (default)
     * * `'outline'`
     * * `null`
     */
    set fillMode(fillMode) {
        this.handleClasses(fillMode, 'fillMode');
        this._fillMode = fillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    get disabledClass() {
        return this.disabled;
    }
    ngOnInit() {
        this.control = this.injector.get(NgControl, null);
        this.checkClearButton();
        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    ngAfterViewInit() {
        const hostElement = this.hostElement.nativeElement;
        let cursorInsideWrapper = false;
        let tabbing = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        this.onFocus.emit();
                        this.isFocused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    const closestTextbox = closest$1(args.relatedTarget, (element) => element === this.hostElement.nativeElement);
                    if (!closestTextbox) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper && !this.clearButtonClicked) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
        const stylingInputs = ['size', 'rounded', 'fillMode'];
        stylingInputs.forEach(input => {
            this.handleClasses(this[input], input);
        });
    }
    ngOnChanges(changes) {
        if (changes.disabled || changes.readonly || changes.value) {
            this.checkClearButton();
        }
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    /**
     * Focuses the TextBox.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="input.focus()">Focus the input</button>
     *  <kendo-textbox #input></kendo-textbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.input) {
            return;
        }
        this.focusChangedProgrammatically = true;
        this.isFocused = true;
        this.input.nativeElement.focus();
        this.focusChangedProgrammatically = false;
    }
    /**
     * Blurs the TextBox.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');
        if (isFocusedElement) {
            isFocusedElement.blur();
        }
        this.isFocused = false;
        this.focusChangedProgrammatically = false;
    }
    /**
     * @hidden
     */
    clearTitle() {
        return this.localizationService.get('clear');
    }
    /**
     * @hidden
     */
    checkClearButton() {
        this.showClearButton =
            !this.disabled &&
                !this.readonly &&
                this.clearButton &&
                !!this.value;
    }
    /**
     * @hidden
     */
    clearValue(ev) {
        if (ev) {
            ev.preventDefault();
        }
        this.clearButtonClicked = true;
        this.input.nativeElement.value = '';
        this.input.nativeElement.focus();
        this.updateValue('');
        this.checkClearButton();
        this.clearButtonClicked = false;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        this.checkClearButton();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.changeDetector.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    showErrorsInitial() {
        if (!this.control) {
            return false;
        }
        const { invalid, dirty, touched } = this.control;
        return invalid && (dirty || touched);
    }
    /**
     * @hidden
     */
    showSuccessInitial() {
        if (!this.control) {
            return false;
        }
        const { valid, dirty, touched } = this.control;
        return valid && (dirty || touched);
    }
    /**
     * @hidden
     */
    get successIconClasses() {
        return this.successIcon
            ? `${this.successIcon}`
            : `k-input-validation-icon k-icon k-i-check`;
    }
    /**
     * @hidden
     */
    get errorIconClasses() {
        return this.errorIcon
            ? `${this.errorIcon}`
            : `k-input-validation-icon k-icon k-i-warning`;
    }
    /**
     * @hidden
     */
    get clearButtonClasses() {
        return this.clearButtonIcon
            ? this.clearButtonIcon
            : `k-icon k-i-x`;
    }
    /**
     * @hidden
     */
    get hasErrors() {
        return this.showErrorIcon === 'initial'
            ? this.showErrorsInitial()
            : this.showErrorIcon;
    }
    /**
     * @hidden
     */
    get isSuccessful() {
        return this.showSuccessIcon === 'initial'
            ? this.showSuccessInitial()
            : this.showSuccessIcon;
    }
    setSelection(start, end) {
        if (this.isFocused) {
            invokeElementMethod(this.input, 'setSelectionRange', start, end);
        }
    }
    selectAll() {
        if (this.value) {
            this.setSelection(0, this.value.length);
        }
    }
    updateValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.checkClearButton();
                this.changeDetector.markForCheck();
            });
        }
    }
    get isFocused() {
        return this._isFocused;
    }
    set isFocused(value) {
        if (this._isFocused !== value && this.hostElement) {
            const element = this.hostElement.nativeElement;
            if (value && !this.disabled) {
                this.renderer.addClass(element, FOCUSED$3);
            }
            else {
                this.renderer.removeClass(element, FOCUSED$3);
            }
            this._isFocused = value;
        }
    }
    handleBlur() {
        this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically) {
                this.onBlur.emit();
            }
            this.isFocused = false;
        });
    }
    handleClasses(value, input) {
        const elem = this.hostElement.nativeElement;
        const classes = getStylingClasses('input', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
};
TextBoxComponent.ɵfac = function TextBoxComponent_Factory(t) { return new (t || TextBoxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
TextBoxComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TextBoxComponent, selectors: [["kendo-textbox"]], contentQueries: function TextBoxComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TextBoxSuffixTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TextBoxPrefixTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
    } }, viewQuery: function TextBoxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c34, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 7, hostBindings: function TextBoxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-textbox", ctx.hostClasses)("k-input", ctx.hostClasses)("k-disabled", ctx.disabledClass);
    } }, inputs: { focusableId: "focusableId", title: "title", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", value: "value", selectOnFocus: "selectOnFocus", showSuccessIcon: "showSuccessIcon", showErrorIcon: "showErrorIcon", clearButton: "clearButton", size: "size", rounded: "rounded", fillMode: "fillMode", tabIndex: "tabIndex", successIcon: "successIcon", errorIcon: "errorIcon", clearButtonIcon: "clearButtonIcon", placeholder: "placeholder", maxlength: "maxlength" }, outputs: { valueChange: "valueChange", inputFocus: "inputFocus", inputBlur: "inputBlur", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendoTextBox"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.textbox' },
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => TextBoxComponent_1),
                multi: true
            },
            { provide: KendoInput, useExisting: forwardRef(() => TextBoxComponent_1) }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 10, vars: 18, consts: function () { let i18n_38; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the **Clear** button in the TextBox.
         * @meaning kendo.textbox.clear
         */
        const MSG_EXTERNAL_2651889799249671820$$DIST_FESM2015_INDEX_JS_39 = goog.getMsg("Clear");
        i18n_38 = MSG_EXTERNAL_2651889799249671820$$DIST_FESM2015_INDEX_JS_39;
    }
    else {
        i18n_38 = $localize `:kendo.textbox.clear|The title for the **Clear** button in the TextBox.␟e6edd360fd0d3c873c0d94a3aecd3c407d31da5a␟2651889799249671820:Clear`;
    } return [["kendoTextBoxLocalizedMessages", "", "clear", i18n_38], [1, "k-input-prefix"], [4, "ngIf"], [1, "k-input-inner", 3, "id", "disabled", "readonly", "value", "kendoEventsOutsideAngular"], ["input", ""], ["role", "button", "class", "k-clear-value", 3, "tabindex", "title", "click", "mousedown", "keydown.enter", "keydown.space", 4, "ngIf"], [3, "ngClass", 4, "ngIf"], [1, "k-input-suffix"], [3, "ngTemplateOutlet"], ["role", "button", 1, "k-clear-value", 3, "tabindex", "title", "click", "mousedown", "keydown.enter", "keydown.space"], [3, "ngClass"]]; }, template: function TextBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵtemplate(2, TextBoxComponent_2_Template, 1, 1, null, 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "input", 3, 4);
        ɵngcc0.ɵɵtemplate(5, TextBoxComponent_span_5_Template, 2, 4, "span", 5);
        ɵngcc0.ɵɵtemplate(6, TextBoxComponent_span_6_Template, 1, 1, "span", 6);
        ɵngcc0.ɵɵtemplate(7, TextBoxComponent_span_7_Template, 1, 1, "span", 6);
        ɵngcc0.ɵɵelementStart(8, "span", 7);
        ɵngcc0.ɵɵtemplate(9, TextBoxComponent_9_Template, 1, 1, null, 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("disabled", ctx.disabled)("readonly", ctx.readonly)("value", ctx.value)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(14, _c40, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("placeholder", ctx.placeholder)("title", ctx.title)("maxlength", ctx.maxlength);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showClearButton);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasErrors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isSuccessful);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.suffixTemplate);
    } }, directives: function () { return [LocalizedTextBoxMessagesDirective, ɵngcc3.NgIf, ɵngcc3.NgTemplateOutlet, ɵngcc2.EventsOutsideAngularDirective, ɵngcc3.NgClass]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextBoxComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextBoxComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextBoxComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextBoxComponent.prototype, "selectOnFocus", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TextBoxComponent.prototype, "showSuccessIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TextBoxComponent.prototype, "showErrorIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextBoxComponent.prototype, "clearButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "successIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "errorIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "clearButtonIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TextBoxComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TextBoxComponent.prototype, "rounded", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TextBoxComponent.prototype, "fillMode", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], TextBoxComponent.prototype, "tabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextBoxComponent.prototype, "maxlength", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextBoxComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextBoxComponent.prototype, "inputFocus", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextBoxComponent.prototype, "inputBlur", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], TextBoxComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], TextBoxComponent.prototype, "onBlur", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], TextBoxComponent.prototype, "input", void 0);
__decorate([
    ContentChild(TextBoxSuffixTemplateDirective, { static: false }),
    __metadata("design:type", TextBoxSuffixTemplateDirective)
], TextBoxComponent.prototype, "suffixTemplate", void 0);
__decorate([
    ContentChild(TextBoxPrefixTemplateDirective, { static: false }),
    __metadata("design:type", TextBoxPrefixTemplateDirective)
], TextBoxComponent.prototype, "prefixTemplate", void 0);
__decorate([
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextBoxComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('class.k-textbox'),
    HostBinding('class.k-input'),
    __metadata("design:type", Boolean)
], TextBoxComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "direction", void 0);
TextBoxComponent = TextBoxComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        NgZone,
        ChangeDetectorRef,
        Renderer2,
        Injector,
        ElementRef])
], TextBoxComponent);

/**
 * @hidden
 */
class TextBoxMessages extends ComponentMessages {
}
TextBoxMessages.ɵfac = /*@__PURE__*/ function () { let ɵTextBoxMessages_BaseFactory; return function TextBoxMessages_Factory(t) { return (ɵTextBoxMessages_BaseFactory || (ɵTextBoxMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TextBoxMessages)))(t || TextBoxMessages); }; }();
TextBoxMessages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TextBoxMessages, inputs: { clear: "clear" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxMessages.prototype, "clear", void 0);

var TextBoxCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let TextBoxCustomMessagesComponent = TextBoxCustomMessagesComponent_1 = class TextBoxCustomMessagesComponent extends TextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
TextBoxCustomMessagesComponent.ɵfac = function TextBoxCustomMessagesComponent_Factory(t) { return new (t || TextBoxCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
TextBoxCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TextBoxCustomMessagesComponent, selectors: [["kendo-textbox-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TextBoxMessages,
                useExisting: forwardRef(() => TextBoxCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function TextBoxCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
TextBoxCustomMessagesComponent = TextBoxCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], TextBoxCustomMessagesComponent);

var LocalizedTextBoxMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedTextBoxMessagesDirective = LocalizedTextBoxMessagesDirective_1 = class LocalizedTextBoxMessagesDirective extends TextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
LocalizedTextBoxMessagesDirective.ɵfac = function LocalizedTextBoxMessagesDirective_Factory(t) { return new (t || LocalizedTextBoxMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedTextBoxMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LocalizedTextBoxMessagesDirective, selectors: [["", "kendoTextBoxLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TextBoxMessages,
                useExisting: forwardRef(() => LocalizedTextBoxMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
LocalizedTextBoxMessagesDirective = LocalizedTextBoxMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LocalizedTextBoxMessagesDirective);

/**
 * Specifies a separator in the content of components like the TextArea and the TextBox. ([see examples]({% slug adornments_textbox %}#toc-separator)).
 * @example
 * ```ts-no-run
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-textbox>
 *    <ng-template kendoTextBoxSuffixTemplate>
 *        <kendo-input-separator></kendo-input-separator>
 *        <button kendoButton look="clear" icon="image"></button>
 *    </ng-template>
 *  </kendo-textbox>
 * `
 * })
 * class AppComponent {}
 * ```
 */
let InputSeparatorComponent = class InputSeparatorComponent {
    /**
     * Specifies a separator in the content of components like the TextArea and the TextBox. ([see examples]({% slug adornments_textbox %}#toc-separator)).
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-textbox>
     *    <ng-template kendoTextBoxSuffixTemplate>
     *        <kendo-input-separator></kendo-input-separator>
     *        <button kendoButton look="clear" icon="image"></button>
     *    </ng-template>
     *  </kendo-textbox>
     * `
     * })
     * class AppComponent {}
     * ```
     */
    constructor() {
        this.hostClass = true;
    }
};
InputSeparatorComponent.ɵfac = function InputSeparatorComponent_Factory(t) { return new (t || InputSeparatorComponent)(); };
InputSeparatorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: InputSeparatorComponent, selectors: [["kendo-input-separator"], ["kendo-textbox-separator"]], hostVars: 2, hostBindings: function InputSeparatorComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-input-separator", ctx.hostClass);
    } }, decls: 0, vars: 0, template: function InputSeparatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-input-separator'),
    __metadata("design:type", Boolean)
], InputSeparatorComponent.prototype, "hostClass", void 0);

/**
 * @hidden
 */
const SHARED_DIRECTIVES = [
    InputSeparatorComponent,
    TextAreaDirective
];
/**
 * @hidden
 */
let SharedModule = class SharedModule {
};
SharedModule.ɵfac = function SharedModule_Factory(t) { return new (t || SharedModule)(); };
SharedModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: SharedModule });
SharedModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TextBox directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the TextBox module
 * import { TextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, TextBoxModule], // import TextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let TextBoxModule = class TextBoxModule {
};
TextBoxModule.ɵfac = function TextBoxModule_Factory(t) { return new (t || TextBoxModule)(); };
TextBoxModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: TextBoxModule });
TextBoxModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, EventsModule, SharedModule], EventsModule] });

/**
 * @hidden
 */
class TextFieldsBase {
    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.injector = injector;
        this.hostElement = hostElement;
        /**
         * Sets the `title` attribute of the internal textarea input element of the component.
         */
        this.title = '';
        /**
         * Sets the disabled state of the TextArea component.
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the TextArea component.
         *
         * @default false
         */
        this.readonly = false;
        /**
         * Provides a value for the TextArea component.
         */
        this.value = null;
        /**
         * Determines whether the whole value will be selected when the TextArea is clicked. Defaults to `false`.
         *
         * @default false
         */
        this.selectOnFocus = false;
        /**
         * Fires each time the user focuses the internal textarea element of the component.
         * This event is useful when you need to distinguish between focusing the textarea element and focusing one of its adornments.
         */
        this.inputFocus = new EventEmitter();
        /**
         * Fires each time the internal textarea element gets blurred.
         * This event is useful when adornments are used, in order to distinguish between blurring the textarea element and blurring the whole TextArea component.
         */
        this.inputBlur = new EventEmitter();
        this.subscriptions = new Subscription();
        this._isFocused = false;
        this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        this.handleInputBlur = () => {
            this.changeDetector.markForCheck();
            if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.inputBlur.emit();
                });
            }
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
    }
    get disabledClass() {
        return this.disabled;
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.changeDetector.markForCheck();
        this.disabled = isDisabled;
    }
}
TextFieldsBase.ɵfac = function TextFieldsBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
TextFieldsBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TextFieldsBase, viewQuery: function TextFieldsBase_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c34, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 3, hostBindings: function TextFieldsBase_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-disabled", ctx.disabledClass);
    } }, inputs: { title: "title", disabled: "disabled", readonly: "readonly", value: "value", selectOnFocus: "selectOnFocus", placeholder: "placeholder" }, outputs: { inputFocus: "inputFocus", inputBlur: "inputBlur" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], TextFieldsBase.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextFieldsBase.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextFieldsBase.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextFieldsBase.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextFieldsBase.prototype, "selectOnFocus", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextFieldsBase.prototype, "placeholder", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextFieldsBase.prototype, "inputFocus", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextFieldsBase.prototype, "inputBlur", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], TextFieldsBase.prototype, "input", void 0);
__decorate([
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextFieldsBase.prototype, "disabledClass", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], TextFieldsBase.prototype, "direction", void 0);

var TextAreaComponent_1;
const resizeClasses = {
    'vertical': 'k-resize-vertical',
    'horizontal': 'k-resize-horizontal',
    'both': 'k-resize-both',
    'none': 'k-resize-none',
    'auto': 'k-resize-none'
};
const FOCUSED$4 = 'k-focus';
/**
 * Represents the [Kendo UI TextArea component for Angular]({% slug overview_textarea %}).
 */
let TextAreaComponent = TextAreaComponent_1 = class TextAreaComponent extends TextFieldsBase {
    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
        super(localizationService, ngZone, changeDetector, renderer, injector, hostElement);
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.injector = injector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        this.hostClasses = true;
        /**
         * Specifies the flow direction of the TextArea sections. This property is useful when adornments are used, in order to specify
         * their position in relation to the textarea element.
         *
         * The possible values are:
         * * `vertical`(Default) &mdash;TextArea sections are placed from top to bottom.
         * * `horizontal`&mdash;TextArea sections are placed from left to right in `ltr`, and from right to left in `rtl` mode.
         */
        this.flow = 'vertical';
        /**
         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Configures the resize behavior of the TextArea.
         *
         * The possible values are:
         * * `vertical`(Default)&mdash;The TextArea component can be resized only vertically.
         * * `horizontal`&mdash;The TextArea component can be resized only horizontally.
         * * `both`&mdash;The TextArea component can be resized in both (horizontal and vertical) directions.
         * * `auto`&mdash;Specifies whether the TextArea component will adjust its height automatically, based on the content.
         * * `none`&mdash;The TextArea cannot be resized.
         *
         */
        this.resizable = 'vertical';
        /**
         * Fires each time the user focuses the TextArea component.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textarea (focus)="handleFocus()"></kendo-textarea>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log('Component is focused');
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the TextArea component gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textarea (blur)="handleBlur()"></kendo-textarea>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log('Component is blurred');
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires each time the value is changed or the component is blurred
         * ([see example]({% slug overview_textarea %}#toc-events)).
         * When the component value is changed programmatically or via its form control binding, the valueChange event is not emitted.
         */
        this.valueChange = new EventEmitter();
        this._size = 'medium';
        this._rounded = 'medium';
        this._fillMode = 'solid';
        /**
         * @hidden
         */
        this.handleInput = (ev) => {
            let incomingValue = ev.target.value;
            this.updateValue(incomingValue);
            this.resize();
        };
        /**
         * @hidden
         */
        this.handleInputFocus = () => {
            if (!this.disabled) {
                if (this.selectOnFocus && this.value) {
                    this.ngZone.run(() => {
                        setTimeout(() => { this.selectAll(); });
                    });
                }
                if (hasObservers(this.onFocus)) {
                    if (!this.isFocused) {
                        this.ngZone.run(() => {
                            this.onFocus.emit();
                        });
                    }
                }
                if (hasObservers(this.inputFocus)) {
                    if (!this.focusChangedProgrammatically) {
                        this.ngZone.run(() => {
                            this.inputFocus.emit();
                        });
                    }
                }
                this.ngZone.run(() => {
                    this.isFocused = true;
                });
            }
        };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    get flowCol() {
        return this.flow === 'vertical';
    }
    get flowRow() {
        return this.flow === 'horizontal';
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * The size property specifies the padding of the internal textarea element
     * ([see example]({% slug appearance_textarea %}#toc-size)).
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set size(size) {
        this.handleClasses(size, 'size');
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * The rounded property specifies the border radius of the TextArea
     * ([see example]({% slug appearance_textarea %}#toc-rounded)).
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set rounded(rounded) {
        this.handleClasses(rounded, 'rounded');
        this._rounded = rounded;
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * The fillMode property specifies the background and border styles of the TextArea
     * ([see example]({% slug appearance_textarea %}#toc-fillMode)).
     *
     * The possible values are:
     * * `'flat'`
     * * `'solid'` (default)
     * * `'outline'`
     * * `null`
     */
    set fillMode(fillMode) {
        this.handleClasses(fillMode, 'fillMode');
        this._fillMode = fillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    ngAfterViewInit() {
        const hostElement = this.hostElement.nativeElement;
        let cursorInsideWrapper = false;
        let tabbing = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        this.onFocus.emit();
                        this.isFocused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    const closestTextbox = closest$1(args.relatedTarget, (element) => element === this.hostElement.nativeElement);
                    if (!closestTextbox) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
            this.handleFlow();
        });
        const stylingInputs = ['size', 'rounded', 'fillMode'];
        stylingInputs.forEach(input => {
            this.handleClasses(this[input], input);
        });
    }
    ngOnInit() {
        this.control = this.injector.get(NgControl, null);
        if (isDocumentAvailable() && this.resizable === 'auto') {
            this.resizeSubscription = fromEvent(window, 'resize')
                .pipe((debounceTime(50)))
                .subscribe(() => this.resize());
        }
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    ngOnChanges(changes) {
        const hostElement = this.hostElement.nativeElement;
        const element = this.input.nativeElement;
        if (changes.flow) {
            this.handleFlow();
        }
        if (changes.resizable) {
            if (this.resizable === 'auto') {
                this.renderer.removeClass(element, '\!k-overflow-y-auto');
                this.initialHeight = element.offsetHeight;
            }
            else {
                this.renderer.addClass(element, '\!k-overflow-y-auto');
                element.style.height = `${this.initialHeight}px`;
            }
        }
        if (changes.cols) {
            if (isPresent(changes.cols.currentValue)) {
                this.renderer.setStyle(hostElement, 'width', 'auto');
            }
            else {
                this.renderer.removeStyle(hostElement, 'width');
            }
        }
    }
    ngAfterViewChecked() {
        this.resize();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    updateValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get resizableClass() {
        return resizeClasses[this.resizable];
    }
    /**
     * Focuses the TextArea component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="textarea.focus()">Focus the textarea</button>
     *  <kendo-textarea #textarea></kendo-textarea>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.input) {
            return;
        }
        this.focusChangedProgrammatically = true;
        this.isFocused = true;
        this.input.nativeElement.focus();
        this.focusChangedProgrammatically = false;
    }
    /**
     * Blurs the TextArea component.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');
        if (isFocusedElement) {
            isFocusedElement.blur();
        }
        this.isFocused = false;
        this.focusChangedProgrammatically = false;
    }
    resize() {
        if (this.resizable !== 'auto') {
            return;
        }
        const element = this.input.nativeElement;
        this.renderer.setStyle(element, 'height', `${this.initialHeight}px`);
        const scrollHeight = element.scrollHeight;
        if (scrollHeight > this.initialHeight) {
            element.style.height = `${scrollHeight}px`;
        }
    }
    get isFocused() {
        return this._isFocused;
    }
    set isFocused(value) {
        if (this._isFocused !== value && this.hostElement) {
            const element = this.hostElement.nativeElement;
            if (value && !this.disabled) {
                this.renderer.addClass(element, FOCUSED$4);
            }
            else {
                this.renderer.removeClass(element, FOCUSED$4);
            }
            this._isFocused = value;
        }
    }
    handleBlur() {
        this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically) {
                this.onBlur.emit();
            }
            this.isFocused = false;
        });
    }
    setSelection(start, end) {
        if (this.isFocused) {
            invokeElementMethod(this.input, 'setSelectionRange', start, end);
        }
    }
    selectAll() {
        if (this.value) {
            this.setSelection(0, this.value.length);
        }
    }
    handleClasses(value, input) {
        const elem = this.hostElement.nativeElement;
        const classes = getStylingClasses('input', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
    handleFlow() {
        const isVertical = this.flow === 'vertical';
        const hostElement = this.hostElement.nativeElement;
        const element = this.input.nativeElement;
        const suffix = hostElement.children[1];
        this.renderer[isVertical ? 'addClass' : 'removeClass'](element, '\!k-flex-none');
        if (suffix) {
            this.renderer[isVertical ? 'removeClass' : 'addClass'](suffix, '\!k-align-items-start');
        }
    }
};
TextAreaComponent.ɵfac = function TextAreaComponent_Factory(t) { return new (t || TextAreaComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
TextAreaComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TextAreaComponent, selectors: [["kendo-textarea"]], hostVars: 8, hostBindings: function TextAreaComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-textarea", ctx.hostClasses)("k-input", ctx.hostClasses)("!k-flex-col", ctx.flowCol)("!k-flex-row", ctx.flowRow);
    } }, inputs: { focusableId: "focusableId", flow: "flow", tabindex: "tabindex", resizable: "resizable", tabIndex: "tabIndex", size: "size", rounded: "rounded", fillMode: "fillMode", rows: "rows", cols: "cols", maxlength: "maxlength" }, outputs: { onFocus: "focus", onBlur: "blur", valueChange: "valueChange" }, exportAs: ["kendoTextArea"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.textarea' },
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => TextAreaComponent_1),
                multi: true
            },
            { provide: KendoInput, useExisting: forwardRef(() => TextAreaComponent_1) }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c42, decls: 4, vars: 19, consts: [[1, "k-input-inner", 3, "ngClass", "id", "value", "disabled", "readonly", "kendoEventsOutsideAngular"], ["input", ""]], template: function TextAreaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c41);
        ɵngcc0.ɵɵelementStart(0, "textarea", 0, 1);
        ɵngcc0.ɵɵtext(2, "            ");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.resizableClass)("id", ctx.focusableId)("value", ctx.value)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(15, _c40, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));
        ɵngcc0.ɵɵattribute("aria-multiline", true)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("placeholder", ctx.placeholder)("rows", ctx.rows)("cols", ctx.cols)("tabindex", ctx.tabIndex)("title", ctx.title)("maxlength", ctx.maxlength);
    } }, directives: [ɵngcc3.NgClass, ɵngcc2.EventsOutsideAngularDirective], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], TextAreaComponent.prototype, "focusableId", void 0);
__decorate([
    HostBinding('class.k-textarea'),
    HostBinding('class.k-input'),
    __metadata("design:type", Boolean)
], TextAreaComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.\!k-flex-col'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextAreaComponent.prototype, "flowCol", null);
__decorate([
    HostBinding('class.\!k-flex-row'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextAreaComponent.prototype, "flowRow", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextAreaComponent.prototype, "flow", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextAreaComponent.prototype, "rows", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextAreaComponent.prototype, "cols", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextAreaComponent.prototype, "maxlength", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextAreaComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], TextAreaComponent.prototype, "tabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextAreaComponent.prototype, "resizable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TextAreaComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TextAreaComponent.prototype, "rounded", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TextAreaComponent.prototype, "fillMode", null);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], TextAreaComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], TextAreaComponent.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextAreaComponent.prototype, "valueChange", void 0);
TextAreaComponent = TextAreaComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        NgZone,
        ChangeDetectorRef,
        Renderer2,
        Injector,
        ElementRef])
], TextAreaComponent);

/**
 * Specifies the adornments in the suffix container ([see example]({% slug textarea_adornments %})).
 * ```ts-no-run
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-textarea>
 *    <kendo-textarea-suffix>
 *        <button kendoButton look="clear" icon="image"></button>
 *    </kendo-textarea-suffix>
 *  </kendo-textarea>
 * `
 * })
 * class AppComponent {}
 * ```
 */
let TextAreaSuffixComponent = class TextAreaSuffixComponent {
    /**
     * Specifies the adornments in the suffix container ([see example]({% slug textarea_adornments %})).
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-textarea>
     *    <kendo-textarea-suffix>
     *        <button kendoButton look="clear" icon="image"></button>
     *    </kendo-textarea-suffix>
     *  </kendo-textarea>
     * `
     * })
     * class AppComponent {}
     * ```
     */
    constructor() {
        this.hostClass = true;
    }
};
TextAreaSuffixComponent.ɵfac = function TextAreaSuffixComponent_Factory(t) { return new (t || TextAreaSuffixComponent)(); };
TextAreaSuffixComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TextAreaSuffixComponent, selectors: [["kendo-textarea-suffix"]], hostVars: 2, hostBindings: function TextAreaSuffixComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-input-suffix", ctx.hostClass);
    } }, exportAs: ["kendoTextAreaSuffix"], ngContentSelectors: _c43, decls: 1, vars: 0, template: function TextAreaSuffixComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-input-suffix'),
    __metadata("design:type", Boolean)
], TextAreaSuffixComponent.prototype, "hostClass", void 0);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TextArea component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the TextArea module
 * import { TextAreaModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, TextAreaModule], // import TextArea module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let TextAreaModule = class TextAreaModule {
};
TextAreaModule.ɵfac = function TextAreaModule_Factory(t) { return new (t || TextAreaModule)(); };
TextAreaModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: TextAreaModule });
TextAreaModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, EventsModule, SharedModule], EventsModule] });

/**
 * @hidden
 */
let ColorPickerLocalizationService = class ColorPickerLocalizationService extends LocalizationService {
    constructor(prefix, messageService, _rtl) {
        super(prefix, messageService, _rtl);
    }
};
ColorPickerLocalizationService.ɵfac = function ColorPickerLocalizationService_Factory(t) { return new (t || ColorPickerLocalizationService)(ɵngcc0.ɵɵinject(L10N_PREFIX), ɵngcc0.ɵɵinject(ɵngcc1.MessageService, 8), ɵngcc0.ɵɵinject(RTL, 8)); };
ColorPickerLocalizationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ColorPickerLocalizationService, factory: function (t) { return ColorPickerLocalizationService.ɵfac(t); } });
ColorPickerLocalizationService = __decorate([
    __param(0, Inject(L10N_PREFIX)),
    __param(1, Optional()),
    __param(2, Optional()), __param(2, Inject(RTL)),
    __metadata("design:paramtypes", [String, MessageService, Boolean])
], ColorPickerLocalizationService);

/**
 * @hidden
 */
let FlatColorPickerLocalizationService = class FlatColorPickerLocalizationService extends LocalizationService {
    constructor(prefix, messageService, _rtl, colorPickerLocalization) {
        super(prefix, messageService, _rtl);
        this.colorPickerLocalization = colorPickerLocalization;
    }
    get(shortKey) {
        if (this.colorPickerLocalization) {
            return this.colorPickerLocalization.get(shortKey);
        }
        return super.get(shortKey);
    }
};
FlatColorPickerLocalizationService.ɵfac = function FlatColorPickerLocalizationService_Factory(t) { return new (t || FlatColorPickerLocalizationService)(ɵngcc0.ɵɵinject(L10N_PREFIX), ɵngcc0.ɵɵinject(ɵngcc1.MessageService, 8), ɵngcc0.ɵɵinject(RTL, 8), ɵngcc0.ɵɵinject(ColorPickerLocalizationService, 8)); };
FlatColorPickerLocalizationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: FlatColorPickerLocalizationService, factory: function (t) { return FlatColorPickerLocalizationService.ɵfac(t); } });
FlatColorPickerLocalizationService = __decorate([
    __param(0, Inject(L10N_PREFIX)),
    __param(1, Optional()),
    __param(2, Optional()), __param(2, Inject(RTL)),
    __param(3, Optional()), __param(3, Inject(ColorPickerLocalizationService)),
    __metadata("design:paramtypes", [String, MessageService, Boolean, ColorPickerLocalizationService])
], FlatColorPickerLocalizationService);

/**
 * @hidden
 */
const DEFAULT_OUTPUT_FORMAT = 'rgba';
/**
 * @hidden
 */
const DEFAULT_GRADIENT_BACKGROUND_COLOR = 'rgba(255, 0, 0, 1)';
/**
 * @hidden
 */
const DRAGHANDLE_MOVE_SPEED = 5;
/**
 * @hidden
 */
const AAA_RATIO = 7.0;
/**
 * @hidden
 */
const AA_RATIO = 4.5;
/**
 * @hidden
 */
const DEFAULT_PRESET = 'office';
/**
 * @hidden
 */
const DEFAULT_ACCESSIBLE_PRESET = 'accessible';
/**
 * @hidden
 */
const STEP_COUNT = 16;

// tslint:disable:max-line-length
/**
 * @hidden
 */
const PALETTEPRESETS = {
    basic: {
        colors: '000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7',
        columns: 10
    },
    office: {
        colors: 'ffffff, 000000, e6e6e6, 435569, 4371c4, ed7e32, a5a4a5, febf04, 5a9bd5, 71ae48, f2f2f3, 7f7f7f, d1cece, d5dde3, dae1f4, fce5d4, deeded, fff2cc, deeaf6, e1efd9, d7d8d8, 585959, aeabab, adbaca, b4c5e7, f6caac, dbdbdb, ffe498, bcd6ee, c5e0b2, bfbfc0, 3f3f3f, 767070, 8595b1, 8fabdb, f5b183, c9c8c9, fed965, 9bc4e5, a8d08d, a5a5a6, 262625, 393939, 334050, 2e5496, c45a11, 7b7b7a, bf9000, 2f75b5, 548235, 7f7f7f, 0b0c0c, 161616, 222a34, 203764, 843d0b, 525252, 7f6000, 1d4d79, 375623',
        columns: 10
    },
    apex: {
        colors: 'ffffff, 000000, c9c2d1, 69676d, ceb966, 9cb084, 6bb1c9, 6585cf, 7e6bc9, a379bb, f2f2f2, 7f7f7f, f4f2f5, e0e0e2, f5f1e0, ebefe6, e1eff4, e0e6f5, e5e1f4, ece4f1, d8d8d8, 595959, e9e6ec, c2c1c5, ebe3c1, d7dfcd, c3dfe9, c1ceeb, cbc3e9, dac9e3, bfbfbf, 3f3f3f, dedae3, a4a3a8, e1d5a3, c3cfb5, a6d0de, a2b5e2, b1a6de, c7aed6, a5a5a5, 262626, 9688a5, 4e4d51, ae9638, 758c5a, 3d8da9, 365bb0, 533da9, 7d4d99, 7f7f7f, 0c0c0c, 635672, 343336, 746425, 4e5d3c, 295e70, 243c75, 372970, 533366',
        columns: 10
    },
    austin: {
        colors: 'ffffff, 000000, caf278, 3e3d2d, 94c600, 71685a, ff6700, 909465, 956b43, fea022, f2f2f2, 7f7f7f, f4fce4, dddcd0, efffc0, e3e1dc, ffe0cb, e8e9df, ece1d6, feecd2, d8d8d8, 595959, e9f9c9, bbb9a1, dfff82, c8c3ba, ffc299, d2d4c0, dac3ad, fed9a6, bfbfbf, 3f3f3f, dff7ae, ada598, cfff43, ada598, ffa365, bcbfa1, c8a585, fec67a, a5a5a5, 262626, a9ea25, 2e2d21, 6f9400, 544e43, bf4d00, 6c6f4b, 6f5032, d77b00, 7f7f7f, 0c0c0c, 74a50f, 1f1e16, 4a6300, 38342d, 7f3300, 484a32, 4a3521, 8f5200',
        columns: 10
    },
    clarity: {
        colors: 'ffffff, 292934, f3f2dc, d2533c, 93a299, ad8f67, 726056, 4c5a6a, 808da0, 79463d, f2f2f2, e7e7ec, e7e5b9, f6dcd8, e9ecea, eee8e0, e4dedb, d8dde3, e5e8ec, e9d6d3, d8d8d8, c4c4d1, d5d185, edbab1, d3d9d6, ded2c2, c9beb8, b2bcc8, ccd1d9, d3aea7, bfbfbf, 8a8aa3, aca73b, e4978a, bec7c1, cdbba3, af9e94, 8c9bac, b2bac6, bd857c, a5a5a5, 56566e, 56531d, a43925, 6b7c72, 866b48, 554840, 39434f, 5c697b, 5a342d, 7f7f7f, 3b3b4b, 22210b, 6d2619, 47534c, 594730, 39302b, 262d35, 3d4652, 3c231e',
        columns: 10
    },
    slipstream: {
        colors: 'ffffff, 000000, b4dcfa, 212745, 4e67c8, 5eccf3, a7ea52, 5dceaf, ff8021, f14124, f2f2f2, 7f7f7f, 8bc9f7, c7cce4, dbe0f4, def4fc, edfadc, def5ef, ffe5d2, fcd9d3, d8d8d8, 595959, 4facf3, 909aca, b8c2e9, beeafa, dbf6b9, beebdf, ffcca6, f9b3a7, bfbfbf, 3f3f3f, 0d78c9, 5967af, 94a3de, 9ee0f7, caf297, 9de1cf, ffb279, f68d7b, a5a5a5, 262626, 063c64, 181d33, 31479f, 11b2eb, 81d319, 34ac8b, d85c00, c3260c, 7f7f7f, 0c0c0c, 021828, 101322, 202f6a, 0b769c, 568c11, 22725c, 903d00, 821908',
        columns: 10
    },
    metro: {
        colors: 'ffffff, 000000, d6ecff, 4e5b6f, 7fd13b, ea157a, feb80a, 00addc, 738ac8, 1ab39f, f2f2f2, 7f7f7f, a7d6ff, d9dde4, e5f5d7, fad0e4, fef0cd, c5f2ff, e2e7f4, c9f7f1, d8d8d8, 595959, 60b5ff, b3bcca, cbecb0, f6a1c9, fee29c, 8be6ff, c7d0e9, 94efe3, bfbfbf, 3f3f3f, 007dea, 8d9baf, b2e389, f272af, fed46b, 51d9ff, aab8de, 5fe7d5, a5a5a5, 262626, 003e75, 3a4453, 5ea226, af0f5b, c58c00, 0081a5, 425ea9, 138677, 7f7f7f, 0c0c0c, 00192e, 272d37, 3f6c19, 750a3d, 835d00, 00566e, 2c3f71, 0c594f',
        columns: 10
    },
    flow: {
        colors: 'ffffff, 000000, dbf5f9, 04617b, 0f6fc6, 009dd9, 0bd0d9, 10cf9b, 7cca62, a5c249, f2f2f2, 7f7f7f, b2e9f2, b4ecfc, c7e2fa, c4eeff, c9fafc, c9faed, e4f4df, edf2da, d8d8d8, 595959, 76d9e8, 6adafa, 90c6f6, 89deff, 93f5f9, 94f6db, cae9c0, dbe6b6, bfbfbf, 3f3f3f, 21b2c8, 20c8f7, 59a9f2, 4fceff, 5df0f6, 5ff2ca, b0dfa0, c9da91, a5a5a5, 262626, 105964, 02485c, 0b5394, 0075a2, 089ca2, 0b9b74, 54a838, 7e9532, 7f7f7f, 0c0c0c, 062328, 01303d, 073763, 004e6c, 05686c, 07674d, 387025, 546321',
        columns: 10
    },
    hardcover: {
        colors: 'ffffff, 000000, ece9c6, 895d1d, 873624, d6862d, d0be40, 877f6c, 972109, aeb795, f2f2f2, 7f7f7f, e1dca5, f2e0c6, f0d0c9, f6e6d5, f5f2d8, e7e5e1, fbc7bc, eef0e9, d8d8d8, 595959, d0c974, e6c28d, e2a293, eeceaa, ece5b2, cfccc3, f78f7a, dee2d4, bfbfbf, 3f3f3f, a29a36, daa454, d4735e, e6b681, e2d88c, b7b2a5, f35838, ced3bf, a5a5a5, 262626, 514d1b, 664515, 65281a, a2641f, a39428, 655f50, 711806, 879464, 7f7f7f, 0c0c0c, 201e0a, 442e0e, 431b11, 6c4315, 6d621a, 433f35, 4b1004, 5a6243',
        columns: 10
    },
    trek: {
        colors: 'ffffff, 000000, fbeec9, 4e3b30, f0a22e, a5644e, b58b80, c3986d, a19574, c17529, f2f2f2, 7f7f7f, f7e09e, e1d6cf, fcecd5, eddfda, f0e7e5, f3eae1, ece9e3, f5e3d1, d8d8d8, 595959, f3cc5f, c4ad9f, f9d9ab, dcc0b6, e1d0cc, e7d5c4, d9d4c7, ebc7a3, bfbfbf, 3f3f3f, d29f0f, a78470, f6c781, cba092, d2b9b2, dbc1a7, c6bfab, e1ac76, a5a5a5, 262626, 694f07, 3a2c24, c87d0e, 7b4b3a, 926255, a17242, 7b7153, 90571e, 7f7f7f, 0c0c0c, 2a1f03, 271d18, 855309, 523226, 614138, 6b4c2c, 524b37, 603a14',
        columns: 10
    },
    verve: {
        colors: 'ffffff, 000000, d2d2d2, 666666, ff388c, e40059, 9c007f, 68007f, 005bd3, 00349e, f2f2f2, 7f7f7f, bdbdbd, e0e0e0, ffd7e8, ffc6dc, ffb8f1, f1b2ff, c3dcff, b8cfff, d8d8d8, 595959, 9d9d9d, c1c1c1, ffafd1, ff8eba, ff71e4, e365ff, 87baff, 72a0ff, bfbfbf, 3f3f3f, 696969, a3a3a3, ff87ba, ff5597, ff2ad7, d519ff, 4b98ff, 2b71ff, a5a5a5, 262626, 343434, 4c4c4c, e90062, ab0042, 75005f, 4e005f, 00449e, 002676, 7f7f7f, 0c0c0c, 151515, 333333, 9b0041, 72002c, 4e003f, 34003f, 002d69, 00194f',
        columns: 10
    },
    monochrome: {
        colors: '000000, 1a1a1a, 333333, 4d4d4d, 666666, 808080, 999999, b3b3b3, cccccc, e6e6e6, f2f2f2, ffffff',
        columns: 12
    },
    accessible: {
        colors: 'black, grey, darkred, red, darkorange, gold, green, blue, darkblue, purple, white, darkgrey, saddlebrown, pink, orange, yellow, lightgreen, lightskyblue, lightblue, mediumpurple',
        columns: 10
    }
};

/**
 * @hidden
 */
let FlatColorPickerService = class FlatColorPickerService {
    getPaletteSettings(settings, format) {
        const defaultPreset = (format !== 'name') ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;
        const settingsPalette = settings.palette;
        const presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ?
            PALETTEPRESETS[settingsPalette].columns :
            undefined;
        return {
            palette: settingsPalette || defaultPreset,
            tileSize: settings.tileSize || 24,
            columns: settings.columns || presetColumns || 10
        };
    }
    paletteTileLayout(tileSize) {
        if (typeof tileSize === 'number') {
            return { width: tileSize, height: tileSize };
        }
        return {
            width: tileSize.width ? tileSize.width : tileSize.height,
            height: tileSize.height ? tileSize.height : tileSize.width
        };
    }
};
FlatColorPickerService.ɵfac = function FlatColorPickerService_Factory(t) { return new (t || FlatColorPickerService)(); };
FlatColorPickerService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: FlatColorPickerService, factory: function (t) { return FlatColorPickerService.ɵfac(t); } });

/**
 * Arguments for the `cancel` event of the ColorPicker and FlatColorPicker components.
 */
class ColorPickerCancelEvent extends PreventableEvent {
    constructor(originalEvent) {
        super();
        this.originalEvent = originalEvent;
    }
}

/**
 * Arguments for the `close` event of the ColorPicker component.
 */
class ColorPickerCloseEvent extends PreventableEvent {
}

/**
 * Arguments for the `open` event of the ColorPicker component.
 */
class ColorPickerOpenEvent extends PreventableEvent {
}

/**
 * Fires each time the left side of the ColorPicker wrapper is clicked.
 * The event is triggered regardless of whether a ColorPicker icon is set or not.
 *
 * Provides information about the current active color and gives the option to prevent the opening of the popup.
 *
 * @example
 *
 * ```ts-no-run
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *       <kendo-colorpicker
 *           [icon]="'edit-tools'"
 *           [value]="'#900'"
 *           (activeColorClick)="handleActiveColorClick($event)"
 *       >
 *       </kendo-colorpicker>
 *   `
 * })
 * class AppComponent {
 *     public handleActiveColorClick(event: ActiveColorClickEvent): void {
 *         event.preventOpen();
 *
 *         console.log('Open prevented:', event.isOpenPrevented());
 *         console.log('Current color:', event.color);
 *     }
 *  }
 * ```
 */
class ActiveColorClickEvent {
    /**
     * @hidden
     * @param color Represents the current value of the ColorPicker.
     */
    constructor(color) {
        this.color = color;
        this.openPrevented = false;
    }
    /**
     * Prevents the opening of the popup.
     */
    preventOpen() {
        this.openPrevented = true;
    }
    /**
     * Returns `true` if the popup opening is prevented by any of its subscribers.
     *
     * @returns - Returns `true` if the open action was prevented. Otherwise, returns `false`.
     */
    isOpenPrevented() {
        return this.openPrevented;
    }
}

/**
 * @hidden
 *
 * Returns the hex or rgba string representation of the color.
 */
const parseColor$1 = (value, format, opacityEnabled = false, safe = true) => {
    const allowedFormats = ['hex', 'rgba', 'name'];
    if (allowedFormats.indexOf(format) === -1) {
        throw new Error(`Unsupported color output format '${format}'. The available options are 'hex', 'rgba' or 'name'.`);
    }
    if (!isPresent(value)) {
        return;
    }
    if (format === 'name') {
        return nameFormat(value, safe);
    }
    const parsedColor = parseColor(value.trim(), safe);
    if (!isPresent(parsedColor)) {
        return;
    }
    const parsedColorResult = format === 'hex' ? getHexValue(parsedColor, opacityEnabled) : parsedColor.toCssRgba();
    return parsedColorResult;
};
/**
 * @hidden
 *
 * Returns an HSV object representation of the color string.
 */
const getHSV = (value, safe = true) => {
    const parsed = parseColor(value, safe);
    if (!isPresent(parsed)) {
        return {};
    }
    return parsed.toHSV();
};
/**
 * @hidden
 *
 * Returns an RGBA object representation of the color string.
 */
const getRGBA = (value, safe = true) => {
    const parsed = parseColor(value, safe);
    if (!isPresent(parsed)) {
        return {};
    }
    return parsed.toBytes();
};
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color.
 */
const getColorFromHSV = (hsva, format = 'rgba', opacityEnabled = false) => {
    const hue = fitIntoBounds(hsva.h, 0, 359.9);
    const saturation = fitIntoBounds(hsva.s, 0, 1);
    const value = fitIntoBounds(hsva.v, 0, 1);
    const alpha = fitIntoBounds(hsva.a, 0, 1);
    const color = Color.fromHSV(hue, saturation, value, alpha);
    return format === 'hex' ? getHexValue(color, opacityEnabled) : color.toCssRgba();
};
/**
 * @hidden
 *
 * Returns the HEX value.
 */
const getHexValue = (color, opacity) => {
    return opacity && color.a < 1 ? color.toCss({ alpha: true }) : color.toCss();
};
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color based on the `hue`, assuming the `value`, `saturation` and `alpha` have value of `1`.
 */
const getColorFromHue = (hue) => {
    return getColorFromHSV({ h: hue, s: 1, v: 1, a: 1 });
};
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color.
 */
const getColorFromRGBA = (rgba) => {
    const red = fitIntoBounds(rgba.r, 0, 255);
    const green = fitIntoBounds(rgba.g, 0, 255);
    const blue = fitIntoBounds(rgba.b, 0, 255);
    const alpha = fitIntoBounds(rgba.a, 0, 1);
    return Color.fromBytes(red, green, blue, alpha).toCssRgba();
};
/**
 *
 * @hidden
 */
function nameFormat(value, safe) {
    value = value.toLowerCase().trim();
    if (isPresent(namedColors[value])) {
        return value;
    }
    if (parseColor(value, safe)) {
        value = parseColor(value, safe).toHex();
    }
    const key = Object.keys(namedColors).find(key => namedColors[key] === value);
    if (!key && !safe) {
        throw new Error(`The provided color ${value} is not supported for 'format="name"' property.To display ${value} color, the component 'format' property should be set to 'hex' or 'rgba' `);
    }
    return key;
}
/**
 * @hidden
 *
 * Returns the RGB object representation of the color based on the background color.
 */
const getRGBFromRGBA = (foregroundColor, backgroundColor) => {
    const r1 = fitIntoBounds(foregroundColor.r, 0, 255);
    const g1 = fitIntoBounds(foregroundColor.g, 0, 255);
    const b1 = fitIntoBounds(foregroundColor.b, 0, 255);
    const a1 = fitIntoBounds(foregroundColor.a, 0, 1);
    const r2 = fitIntoBounds(backgroundColor.r, 0, 255);
    const g2 = fitIntoBounds(backgroundColor.g, 0, 255);
    const b2 = fitIntoBounds(backgroundColor.b, 0, 255);
    return {
        r: Math.round(((1 - a1) * r2) + (a1 * r1)),
        g: Math.round(((1 - a1) * g2) + (a1 * g1)),
        b: Math.round(((1 - a1) * b2) + (a1 * b1))
    };
};
/**
 * @hidden
 *
 * Returns the relative luminance.
 */
const getLuminance = (rgb) => {
    let a = [rgb.r, rgb.g, rgb.b].map(function (v) {
        v /= 255;
        return v <= 0.03928
            ? v / 12.92
            : Math.pow((v + 0.055) / 1.055, 2.4);
    });
    return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
};
/**
 * @hidden
 *
 * Returns the color contrast.
 */
const getContrast = (luminance1, luminance2) => {
    const brightest = Math.max(luminance1, luminance2);
    const darkest = Math.min(luminance1, luminance2);
    return (brightest + 0.05)
        / (darkest + 0.05);
};
/**
 * @hidden
 *
 * Returns the color contrast from two RGBA colors.
 */
const getContrastFromTwoRGBAs = (a, b) => {
    return getContrast(getLuminance(getRGBFromRGBA(a, b)), getLuminance(getRGBFromRGBA(b, { r: 0, g: 0, b: 0, a: 1 })));
};

/**
 * @hidden
 */
const bezierCommand = (controlPointCalc) => (point, i, a) => {
    // start control point
    const [cpsX, cpsY] = controlPointCalc(a[i - 1], a[i - 2], point);
    // end control point
    const [cpeX, cpeY] = controlPointCalc(point, a[i - 1], a[i + 1], true);
    return `C ${cpsX},${cpsY} ${cpeX},${cpeY} ${point[0]},${point[1]}`;
};
/**
 * @hidden
 */
const controlPoint = (lineCalc) => (current, previous, next, reverse) => {
    // when 'current' is the first or last point of the array
    // 'previous' and 'next' are undefined
    // replace with 'current'
    const p = previous || current;
    const n = next || current;
    const smooth = 0.1;
    // properties of the line between previous and next
    const l = lineCalc(p, n);
    // If is end-control-point, add PI to the angle to go backward
    const angle = l.angle + (reverse ? Math.PI : 0);
    const length = l.length * smooth;
    // The control point position is relative to the current point
    const x = current[0] + Math.cos(angle) * length;
    const y = current[1] + Math.sin(angle) * length;
    return [x, y];
};
/**
 * @hidden
 */
const line = (pointA, pointB) => {
    const lengthX = pointB[0] - pointA[0];
    const lengthY = pointB[1] - pointA[1];
    return {
        length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),
        angle: Math.atan2(lengthY, lengthX)
    };
};
/**
 * @hidden
 *
 * Render the svg <path> element.
 *
 * @param points (array) Represents the points coordinates as an array of tuples.
 * @param command (function) The command that is used (bezierCommand, lineCommand).
 *      @param point (array) [x,y] Represents the current point coordinates.
 *      @param i (integer) Represents the index of 'point' in the array 'a'.
 *      @param a (array) Represents the complete array of points coordinates.
 *      @output (string) a svg path command.
 * @output (string) a Svg <path> element
 */
const svgPath = (points, command) => {
    if (points.length === 0) {
        return '';
    }
    // build the d attributes by looping over the points
    const d = points.reduce((acc, point, i, a) => i === 0 ?
        // if first point
        `M ${point[0]},${point[1]}` :
        // else
        `${acc} ${command(point, i, a)}`, '');
    return d;
};

/**
 * @hidden
 */
let ColorGradientLocalizationService = class ColorGradientLocalizationService extends LocalizationService {
    constructor(prefix, messageService, _rtl, flatColorPickerLocalization) {
        super(prefix, messageService, _rtl);
        this.flatColorPickerLocalization = flatColorPickerLocalization;
    }
    get(shortKey) {
        if (this.flatColorPickerLocalization) {
            return this.flatColorPickerLocalization.get(shortKey);
        }
        return super.get(shortKey);
    }
};
ColorGradientLocalizationService.ɵfac = function ColorGradientLocalizationService_Factory(t) { return new (t || ColorGradientLocalizationService)(ɵngcc0.ɵɵinject(L10N_PREFIX), ɵngcc0.ɵɵinject(ɵngcc1.MessageService, 8), ɵngcc0.ɵɵinject(RTL, 8), ɵngcc0.ɵɵinject(FlatColorPickerLocalizationService, 8)); };
ColorGradientLocalizationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ColorGradientLocalizationService, factory: function (t) { return ColorGradientLocalizationService.ɵfac(t); } });
ColorGradientLocalizationService = __decorate([
    __param(0, Inject(L10N_PREFIX)),
    __param(1, Optional()),
    __param(2, Optional()), __param(2, Inject(RTL)),
    __param(3, Optional()), __param(3, Inject(FlatColorPickerLocalizationService)),
    __metadata("design:paramtypes", [String, MessageService, Boolean, FlatColorPickerLocalizationService])
], ColorGradientLocalizationService);

/**
 * @hidden
 */
let ColorInputComponent = class ColorInputComponent {
    constructor(host, renderer, localizationService) {
        this.host = host;
        this.renderer = renderer;
        this.localizationService = localizationService;
        /**
         * The id of the hex input.
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Sets whether the alpha slider will be shown.
         */
        this.opacity = true;
        /**
         * Sets the disabled state of the ColorInput.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorInput.
         */
        this.readonly = false;
        /**
         * Emits a parsed rgba string color.
         */
        this.valueChange = new EventEmitter();
        this.colorInputClass = true;
        /**
         * The rgba inputs values.
         */
        this.rgba = {};
        this.subscriptions = new Subscription();
    }
    /**
     * Indicates whether any of the inputs are focused.
     */
    get isFocused() {
        if (!(isDocumentAvailable() && isPresent(this.host))) {
            return false;
        }
        const activeElement = document.activeElement;
        return this.host.nativeElement.contains(activeElement);
    }
    /**
     * Indicates whether any of the rgba inputs have value.
     */
    get rgbaInputValid() {
        return Object.keys(this.rgba).every(key => isPresent(this.rgba[key]));
    }
    ngAfterViewInit() {
        this.initDomEvents();
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        if (isPresent(changes.value) && !this.isFocused) {
            this.hex = parseColor$1(this.value, 'hex', this.opacity);
            this.rgba = getRGBA(this.value);
            this.rgba.a = parseColor$1(this.value, 'rgba', this.opacity) ? this.rgba.a : 1;
        }
    }
    get formatButtonTitle() {
        return this.localizationService.get('formatButton');
    }
    handleRgbaValueChange() {
        const color = getColorFromRGBA(this.rgba);
        if (!this.rgbaInputValid || color === this.value) {
            return;
        }
        this.value = color;
        this.rgba = getRGBA(this.value);
        this.hex = parseColor$1(color, 'hex', this.opacity);
        this.valueChange.emit(color);
    }
    handleHexValueChange(hex) {
        this.hex = hex;
        const color = parseColor$1(hex, 'rgba', this.opacity);
        if (!isPresent(color) || color === this.value) {
            return;
        }
        this.value = color;
        this.rgba = getRGBA(color);
        this.valueChange.emit(color);
    }
    handleRgbaInputBlur() {
        if (!this.rgbaInputValid) {
            this.rgba = getRGBA(this.value);
        }
    }
    handleHexInputBlur() {
        this.hex = parseColor$1(this.value, 'hex', this.opacity);
    }
    toggleFormatView() {
        this.formatView = this.formatView === 'hex' ? 'rgba' : 'hex';
    }
    initDomEvents() {
        if (!this.host) {
            return;
        }
        this.subscriptions.add(this.renderer.listen(this.toggleFormatButton.nativeElement, 'click', () => this.toggleFormatView()));
    }
};
ColorInputComponent.ɵfac = function ColorInputComponent_Factory(t) { return new (t || ColorInputComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
ColorInputComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColorInputComponent, selectors: [["kendo-colorinput"]], viewQuery: function ColorInputComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c44, 5);
        ɵngcc0.ɵɵviewQuery(_c45, 5, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c46, 5, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c47, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.opacityInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hexInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.blueInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleFormatButton = _t.first);
    } }, hostVars: 4, hostBindings: function ColorInputComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-colorgradient-inputs", ctx.colorInputClass)("k-hstack", ctx.colorInputClass);
    } }, inputs: { focusableId: "focusableId", opacity: "opacity", disabled: "disabled", readonly: "readonly", value: "value", formatView: "formatView" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 6, vars: 4, consts: [[1, "k-vstack"], ["type", "button", 1, "k-colorgradient-toggle-mode", "k-button", "k-button-md", "k-button-flat", "k-button-flat-base", "k-icon-button"], ["toggleFormatButton", ""], [1, "k-button-icon", "k-icon", "k-i-arrows-kpi"], ["class", "k-vstack", 4, "ngIf"], [4, "ngIf"], [1, "k-input", "k-textbox", "k-input-solid", "k-input-md", "k-rounded-md", "k-hex-value", 3, "id", "disabled", "readonly", "value", "blur", "input"], ["hexInput", ""], [1, "k-colorgradient-input-label", 3, "for"], [3, "disabled", "readonly", "min", "max", "value", "autoCorrect", "spinners", "format", "decimals", "valueChange", "blur"], ["red", ""], ["green", ""], ["blue", ""], [3, "disabled", "readonly", "min", "max", "value", "autoCorrect", "spinners", "step", "format", "decimals", "valueChange", "blur"], ["opacityInput", "", "alpha", ""]], template: function ColorInputComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0)(1, "button", 1, 2);
        ɵngcc0.ɵɵelement(3, "span", 3);
        ɵngcc0.ɵɵelementEnd()();
        ɵngcc0.ɵɵtemplate(4, ColorInputComponent_div_4_Template, 5, 5, "div", 4);
        ɵngcc0.ɵɵtemplate(5, ColorInputComponent_ng_container_5_Template, 17, 31, "ng-container", 5);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-label", ctx.formatButtonTitle)("title", ctx.formatButtonTitle);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.formatView === "hex");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.formatView === "rgba");
    } }, directives: [ɵngcc3.NgIf, NumericTextBoxComponent], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorInputComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorInputComponent.prototype, "formatView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorInputComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorInputComponent.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorInputComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorInputComponent.prototype, "readonly", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorInputComponent.prototype, "valueChange", void 0);
__decorate([
    HostBinding('class.k-colorgradient-inputs'),
    HostBinding('class.k-hstack'),
    __metadata("design:type", Boolean)
], ColorInputComponent.prototype, "colorInputClass", void 0);
__decorate([
    ViewChild('opacityInput', { static: false }),
    __metadata("design:type", NumericTextBoxComponent)
], ColorInputComponent.prototype, "opacityInput", void 0);
__decorate([
    ViewChild('hexInput', { read: ElementRef, static: false }),
    __metadata("design:type", ElementRef)
], ColorInputComponent.prototype, "hexInput", void 0);
__decorate([
    ViewChild('blueInput', { read: ElementRef, static: false }),
    __metadata("design:type", ElementRef)
], ColorInputComponent.prototype, "blueInput", void 0);
__decorate([
    ViewChild('toggleFormatButton', { static: false }),
    __metadata("design:type", ElementRef)
], ColorInputComponent.prototype, "toggleFormatButton", void 0);
ColorInputComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        LocalizationService])
], ColorInputComponent);

var ColorGradientComponent_1;
let serial = 0;
/**
 * The ColorGradient component enables smooth color transitions and provides options for selecting specific colors over the drag handle.
 * The ColorGradient is independently used by `kendo-colorpicker` and can be directly added to the page.
 */
let ColorGradientComponent = ColorGradientComponent_1 = class ColorGradientComponent {
    constructor(host, ngZone, renderer, cdr, localizationService) {
        this.host = host;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.localizationService = localizationService;
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.id = `k-colorgradient-${serial++}`;
        /**
         * Defines whether the alpha slider will be displayed.
         *
         * @default true
         */
        this.opacity = true;
        /**
         * Sets the disabled state of the ColorGradient.
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorGradient.
         *
         * @default false
         */
        this.readonly = false;
        /**
         * Specifies whether the ColorGradient should display a 'Clear color' button.
         *
         * @default false
         */
        this.clearButton = false;
        /**
         * Determines the delay time (in milliseconds) before the value is changed on handle drag. A value of 0 indicates no delay.
         *
         * @default 0
         */
        this.delay = 0;
        /**
         * Specifies the output format of the ColorGradientComponent.
         * The input value may be in a different format, but it will be parsed into the output `format`
         * after the component processes it.
         *
         * The supported values are:
         * * (Default) `rgba`
         * * `hex`
         */
        this.format = DEFAULT_OUTPUT_FORMAT;
        /**
         * Fires each time the user selects a new color.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.backgroundColor = DEFAULT_GRADIENT_BACKGROUND_COLOR;
        /**
         * @hidden
         *
         * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.
         * The values are initially set in `ngOnInit` or in `ngOnChanges` and are
         * updated on moving the drag handle or the sliders.
         */
        this.hsva = new BehaviorSubject({});
        this._tabindex = 0;
        this.listeners = [];
        this.hueSliderTouched = false;
        this.alphaSliderTouched = false;
        this.updateValues = new Subject();
        this.notifyNgChanged = () => { };
        this.notifyNgTouched = () => { };
        validatePackage(packageMetadata);
        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    get readonlyAttribute() {
        return this.readonly;
    }
    get disabledClass() {
        return this.disabled;
    }
    get gradientId() {
        return this.id;
    }
    get hostTabindex() {
        return this.tabindex;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor$1(value, this.format, this.opacity);
    }
    get value() {
        return this._value;
    }
    /**
     * Enables the color contrast tool. Accepts the background color that will be compared to the selected value.
     * The tool will calculate the contrast ratio between the two colors.
     */
    set contrastTool(value) {
        this._contrastTool = parseColor$1(value, this.format, this.opacity);
    }
    get contrastTool() {
        return this._contrastTool;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     *
     * @default 0
     */
    set tabindex(value) {
        if (isPresent(value)) {
            const tabindex = Number(value);
            this._tabindex = !isNaN(tabindex) ? tabindex : 0;
        }
        else {
            // Allows removal of the tabindex attribute
            this._tabindex = value;
        }
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * Indicates whether the ColorGradient or any of its content is focused.
     */
    get isFocused() {
        if (!(isDocumentAvailable() && isPresent(this.host))) {
            return false;
        }
        return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);
    }
    /**
     * @hidden
     */
    get alphaSliderValue() {
        // setting the initial value to undefined to force the slider to recalculate the height of the slider track on the next cdr run
        if (!(isPresent(this.hsva.value) && isPresent(this.hsva.value.a))) {
            return;
        }
        return this.hsva.value.a * 100;
    }
    get gradientRect() {
        return this.gradientWrapper.nativeElement.getBoundingClientRect();
    }
    /**
     * @hidden
     */
    get contrastToolVisible() {
        return this.contrastTool && this.contrastTool.length > 0;
    }
    ngAfterViewInit() {
        this.updateUI();
        this.cdr.detectChanges();
        this.addEventListeners();
        this.subscribeChanges();
    }
    ngOnChanges(changes) {
        if (isChanged('value', changes) && !this.isFocused) {
            this.updateUI();
        }
        if (isChanged('delay', changes)) {
            this.unsubscribeChanges();
            this.subscribeChanges();
        }
    }
    ngOnDestroy() {
        this.listeners.forEach(removeListener => removeListener());
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
        this.unsubscribeChanges();
    }
    /**
     * Focuses the component.
     */
    focus() {
        if (this.disabled) {
            return;
        }
        this.gradientDragHandle.nativeElement.focus();
    }
    /**
     * @hidden
     */
    reset() {
        this.handleValueChange(undefined);
        this.updateUI();
        this.host.nativeElement.focus();
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (this.disabled || this.readonly || !isPresent(args.originalEvent)) {
            return;
        }
        this.focus();
        args.originalEvent.preventDefault();
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');
        this.changePosition(args);
    }
    /**
     * @hidden
     */
    onHandleRelease() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');
        this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));
    }
    /**
     * @hidden
     */
    onKeyboardAction(args) {
        if (this.disabled || this.readonly) {
            return;
        }
        if (args.key && args.key.indexOf('Arrow') !== -1) {
            args.preventDefault();
            const dragHandleElement = this.gradientDragHandle.nativeElement;
            this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');
            let keyboardMoveX = 0;
            let keyboardMoveY = 0;
            switch (args.key) {
                case 'ArrowRight':
                    keyboardMoveX = DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowLeft':
                    keyboardMoveX = -DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowUp':
                    keyboardMoveY = -DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowDown':
                    keyboardMoveY = DRAGHANDLE_MOVE_SPEED;
                    break;
                default: break;
            }
            const newY = parseInt(dragHandleElement.style.top, 10) + keyboardMoveY;
            const newX = parseInt(dragHandleElement.style.left, 10) + keyboardMoveX;
            this.renderer.setStyle(dragHandleElement, 'top', `${newY}px`);
            this.renderer.setStyle(dragHandleElement, 'left', `${newX}px`);
            this.ngZone.run(() => this.moveDragHandle(newX, newY));
        }
    }
    /**
     * @hidden
     */
    changePosition(position) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.gradientDragHandle.nativeElement.focus();
        const gradientRect = this.gradientRect;
        const newX = position.clientX - gradientRect.left;
        const newY = position.clientY - gradientRect.top;
        this.ngZone.run(() => this.moveDragHandle(newX, newY));
    }
    /**
     * @hidden
     */
    handleHueSliderChange(hue) {
        const hsva = this.hsva.value;
        hsva.h = hue;
        this.hsva.next(hsva);
        this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));
        this.backgroundColor = getColorFromHue(hue);
        this.setBackgroundColor(this.backgroundColor);
        this.setAlphaSliderBackground(this.backgroundColor);
        this.hueSliderTouched = true;
    }
    /**
     * @hidden
     */
    handleAlphaSliderChange(alpha) {
        const hsva = this.hsva.value;
        hsva.a = alpha / 100;
        this.hsva.next(hsva);
        this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));
        this.alphaSliderTouched = true;
    }
    /**
     * @hidden
     */
    handleInputsValueChange(color) {
        const parsed = parseColor$1(color, this.format, this.opacity);
        if (this.value !== parsed) {
            this.handleValueChange(parsed);
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        if (isPresent(this.gradientWrapper)) {
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    get colorGradientHandleTitle() {
        return this.localizationService.get('colorGradientHandle');
    }
    /**
     * @hidden
     */
    get colorGradientHandleAriaLabel() {
        const parsed = parseColor$1(this.value, this.format, this.opacity);
        return `${this.value ? parsed : this.localizationService.get('colorGradientHandle')}`;
    }
    /**
     * @hidden
     */
    get hueSliderTitle() {
        return this.localizationService.get('hueSliderHandle');
    }
    /**
     * @hidden
     */
    get opacitySliderTitle() {
        return this.localizationService.get('opacitySliderHandle');
    }
    /**
     * @hidden
     */
    get clearButtonTitle() {
        return this.localizationService.get('clearButton');
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    moveDragHandle(positionX, positionY) {
        const gradientRect = this.gradientRect;
        const gradientRectWidth = gradientRect.width;
        const gradientRectHeight = gradientRect.height;
        const top = fitIntoBounds(positionY, 0, gradientRectHeight);
        const left = fitIntoBounds(positionX, 0, gradientRectWidth);
        this.setDragHandleElementPosition(top, left);
        const hsva = this.hsva.value;
        hsva.s = left / gradientRectWidth;
        hsva.v = 1 - top / gradientRectHeight;
        this.hsva.next(hsva);
        this.updateValues.next(getColorFromHSV(this.hsva.value, this.format, this.opacity));
        this.setAlphaSliderBackground(getColorFromHSV(Object.assign({}, this.hsva.value, { a: 1 }), this.format, this.opacity));
    }
    handleValueChange(color) {
        if (this.value === color) {
            return;
        }
        this.value = color;
        this.valueChange.emit(color);
        this.notifyNgChanged(color);
        this.setHostElementAriaLabel();
    }
    setDragHandleElementPosition(top, left) {
        const dragHandle = this.gradientDragHandle.nativeElement;
        this.renderer.setStyle(dragHandle, 'top', `${top}px`);
        this.renderer.setStyle(dragHandle, 'left', `${left}px`);
    }
    setAlphaSliderBackground(backgroundColor) {
        if (!isPresent(this.alphaSlider)) {
            return;
        }
        const sliderTrack = this.alphaSlider.track.nativeElement;
        this.renderer.setStyle(sliderTrack, 'background', `linear-gradient(to top, transparent, ${backgroundColor})`);
    }
    setHostElementAriaLabel() {
        const parsed = parseColor$1(this.value, this.format, this.opacity);
        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorGradientNoColor')}`);
    }
    setBackgroundColor(color) {
        this.renderer.setStyle(this.hsvRectangle.nativeElement, 'background', color);
    }
    updateUI() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.hueSliderTouched || this.alphaSliderTouched) {
            this.hueSliderTouched = false;
            this.alphaSliderTouched = false;
            return;
        }
        this.hsva.next(this.value ? getHSV(this.value) : { h: 0, s: 0, v: 1, a: 1 });
        const gradientRect = this.gradientRect;
        const top = (1 - this.hsva.value.v) * gradientRect.height;
        const left = this.hsva.value.s * gradientRect.width;
        this.setDragHandleElementPosition(top, left);
        this.backgroundColor = getColorFromHue(this.hsva.value.h);
        this.setBackgroundColor(this.backgroundColor);
        this.setAlphaSliderBackground(this.backgroundColor);
        this.setHostElementAriaLabel();
    }
    addEventListeners() {
        this.ngZone.runOutsideAngular(() => {
            const focusOutListener = this.renderer.listen(this.host.nativeElement, 'focusout', (event) => {
                if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {
                    this.ngZone.run(() => this.notifyNgTouched());
                }
            });
            const keydownListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keydown', (event) => {
                this.onKeyboardAction(event);
            });
            const keyupListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keyup', () => {
                this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');
                if (!this.readonly && !this.disabled) {
                    this.ngZone.run(() => this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity)));
                }
            });
            const dragHandleFocusInListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusin', () => {
                this.renderer.addClass(this.gradientDragHandle.nativeElement, 'k-state-focus');
            });
            const dragHandleFocusOutListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusout', () => {
                this.renderer.removeClass(this.gradientDragHandle.nativeElement, 'k-state-focus');
            });
            this.listeners.push(focusOutListener, keydownListener, keyupListener, dragHandleFocusInListener, dragHandleFocusOutListener);
        });
    }
    subscribeChanges() {
        this.changeRequestsSubscription = this.updateValues.pipe(throttleTime(this.delay)).subscribe(value => {
            this.handleValueChange(value);
        });
    }
    unsubscribeChanges() {
        if (this.changeRequestsSubscription) {
            this.changeRequestsSubscription.unsubscribe();
        }
    }
};
ColorGradientComponent.ɵfac = function ColorGradientComponent_Factory(t) { return new (t || ColorGradientComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
ColorGradientComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColorGradientComponent, selectors: [["kendo-colorgradient"]], viewQuery: function ColorGradientComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c48, 5, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c49, 5);
        ɵngcc0.ɵɵviewQuery(_c50, 5);
        ɵngcc0.ɵɵviewQuery(_c51, 5);
        ɵngcc0.ɵɵviewQuery(_c52, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.gradientDragHandle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputs = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.alphaSlider = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.gradientWrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hsvRectangle = _t.first);
    } }, hostVars: 8, hostBindings: function ColorGradientComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("aria-readonly", ctx.readonlyAttribute)("id", ctx.gradientId)("tabindex", ctx.hostTabindex);
        ɵngcc0.ɵɵclassProp("k-colorgradient", ctx.hostClasses)("k-state-disabled", ctx.disabledClass);
    } }, inputs: { id: "id", opacity: "opacity", disabled: "disabled", readonly: "readonly", clearButton: "clearButton", delay: "delay", format: "format", value: "value", contrastTool: "contrastTool", tabindex: "tabindex" }, outputs: { valueChange: "valueChange" }, exportAs: ["kendoColorGradient"], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorGradientComponent_1)
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorGradientComponent_1)
            },
            ColorGradientLocalizationService,
            {
                provide: LocalizationService,
                useExisting: ColorGradientLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorgradient'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 16, vars: 28, consts: function () { let i18n_53; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The aria-label applied to the ColorGradient component when the value is empty.
         * @meaning kendo.colorgradient.colorGradientNoColor
         */
        const MSG_EXTERNAL_3796155240301823948$$DIST_FESM2015_INDEX_JS_54 = goog.getMsg("Colorgradient no color chosen");
        i18n_53 = MSG_EXTERNAL_3796155240301823948$$DIST_FESM2015_INDEX_JS_54;
    }
    else {
        i18n_53 = $localize `:kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.␟136a6a537523c480df0e58c17cc6d4c2dda8e626␟3796155240301823948:Colorgradient no color chosen`;
    } let i18n_55; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the gradient color drag handle chooser.
         * @meaning kendo.colorgradient.colorGradientHandle
         */
        const MSG_EXTERNAL_8537406358423916512$$DIST_FESM2015_INDEX_JS_56 = goog.getMsg("Choose color");
        i18n_55 = MSG_EXTERNAL_8537406358423916512$$DIST_FESM2015_INDEX_JS_56;
    }
    else {
        i18n_55 = $localize `:kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser.␟462ab46551fd64dca63ba38254e46a52aeb05205␟8537406358423916512:Choose color`;
    } let i18n_57; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the clear button.
         * @meaning kendo.colorgradient.clearButton
         */
        const MSG_EXTERNAL_7605097752673642325$$DIST_FESM2015_INDEX_JS_58 = goog.getMsg("Clear value");
        i18n_57 = MSG_EXTERNAL_7605097752673642325$$DIST_FESM2015_INDEX_JS_58;
    }
    else {
        i18n_57 = $localize `:kendo.colorgradient.clearButton|The title for the clear button.␟6dc40c4a4ff302d1fe29e7bf9eadf1440b4654cf␟7605097752673642325:Clear value`;
    } let i18n_59; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the hue slider handle.
         * @meaning kendo.colorgradient.hueSliderHandle
         */
        const MSG_EXTERNAL_8568799441668530127$$DIST_FESM2015_INDEX_JS_60 = goog.getMsg("Set hue");
        i18n_59 = MSG_EXTERNAL_8568799441668530127$$DIST_FESM2015_INDEX_JS_60;
    }
    else {
        i18n_59 = $localize `:kendo.colorgradient.hueSliderHandle|The title for the hue slider handle.␟22a98afddf46223dce8a3e122f4fe84ca76488b9␟8568799441668530127:Set hue`;
    } let i18n_61; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the opacity slider handle.
         * @meaning kendo.colorgradient.opacitySliderHandle
         */
        const MSG_EXTERNAL_2665102430468067218$$DIST_FESM2015_INDEX_JS_62 = goog.getMsg("Set opacity");
        i18n_61 = MSG_EXTERNAL_2665102430468067218$$DIST_FESM2015_INDEX_JS_62;
    }
    else {
        i18n_61 = $localize `:kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle.␟ad3087c7bf139a41bf6a7fc454f4e857492c9d22␟2665102430468067218:Set opacity`;
    } let i18n_63; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The pass message for the contrast tool.
         * @meaning kendo.colorgradient.passContrast
         */
        const MSG_EXTERNAL_200461871469242251$$DIST_FESM2015_INDEX_JS_64 = goog.getMsg("Pass");
        i18n_63 = MSG_EXTERNAL_200461871469242251$$DIST_FESM2015_INDEX_JS_64;
    }
    else {
        i18n_63 = $localize `:kendo.colorgradient.passContrast|The pass message for the contrast tool.␟ec167f04d318f2b1f1edbca6318a74fddf436c76␟200461871469242251:Pass`;
    } let i18n_65; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The fail message for the contrast tool.
         * @meaning kendo.colorgradient.failContrast
         */
        const MSG_EXTERNAL_2780397365913372676$$DIST_FESM2015_INDEX_JS_66 = goog.getMsg("Fail");
        i18n_65 = MSG_EXTERNAL_2780397365913372676$$DIST_FESM2015_INDEX_JS_66;
    }
    else {
        i18n_65 = $localize `:kendo.colorgradient.failContrast|The fail message for the contrast tool.␟79015428999551ebe50f69bb5a1ebd31de4c3bdf␟2780397365913372676:Fail`;
    } let i18n_67; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The contrast ratio message for the contrast tool.
         * @meaning kendo.colorgradient.contrastRatio
         */
        const MSG_EXTERNAL_713630549826115578$$DIST_FESM2015_INDEX_JS_68 = goog.getMsg("Contrast ratio");
        i18n_67 = MSG_EXTERNAL_713630549826115578$$DIST_FESM2015_INDEX_JS_68;
    }
    else {
        i18n_67 = $localize `:kendo.colorgradient.contrastRatio|The contrast ratio message for the contrast tool.␟408650dd85473f406520edd1d60c8df0c475a8fa␟713630549826115578:Contrast ratio`;
    } let i18n_69; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the input format toggle button.
         * @meaning kendo.colorgradient.formatButton
         */
        const MSG_EXTERNAL_4435805267169453054$$DIST_FESM2015_INDEX_JS_70 = goog.getMsg("Change color format");
        i18n_69 = MSG_EXTERNAL_4435805267169453054$$DIST_FESM2015_INDEX_JS_70;
    }
    else {
        i18n_69 = $localize `:kendo.colorgradient.formatButton|The message for the input format toggle button.␟c4dcc7b94f17aace43f0ab2492e64d5dcc13a438␟4435805267169453054:Change color format`;
    } return [["kendoColorGradientLocalizedMessages", "", "colorGradientNoColor", i18n_53, "colorGradientHandle", i18n_55, "clearButton", i18n_57, "hueSliderHandle", i18n_59, "opacitySliderHandle", i18n_61, "passContrast", i18n_63, "failContrast", i18n_65, "contrastRatio", i18n_67, "formatButton", i18n_69], [1, "k-colorgradient-canvas", "k-hstack"], [1, "k-hsv-rectangle"], ["hsvRectangle", ""], ["kendoDraggable", "", 1, "k-hsv-gradient", 3, "click", "kendoPress", "kendoDrag", "kendoRelease"], ["gradientWrapper", ""], ["tabindex", "0", 1, "k-hsv-draghandle", "k-draghandle"], ["gradientDragHandle", ""], ["kendoColorContrastSvg", "", "class", "k-color-contrast-svg", "xmlns", "http://www.w3.org/2000/svg", 3, "wrapper", "hsva", "backgroundColor", 4, "ngIf"], ["class", "k-clear-color k-button k-button-md k-button-flat k-button-flat-base k-button-icon", "tabindex", "0", 3, "click", "keydown.enter", "keydown.space", 4, "ngIf"], [1, "k-hue-slider", "k-colorgradient-slider", 3, "ngClass", "dragHandleTitle", "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "value", "smallStep", "largeStep", "valueChange"], ["class", "k-alpha-slider k-colorgradient-slider", 3, "ngClass", "dragHandleTitle", "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange", 4, "ngIf"], [3, "opacity", "formatView", "value", "disabled", "readonly", "valueChange"], ["inputs", ""], ["class", "k-colorgradient-color-contrast k-vbox", "kendoContrastTool", "", 3, "value", "ratio", 4, "ngIf"], ["kendoColorContrastSvg", "", "xmlns", "http://www.w3.org/2000/svg", 1, "k-color-contrast-svg", 3, "wrapper", "hsva", "backgroundColor"], ["tabindex", "0", 1, "k-clear-color", "k-button", "k-button-md", "k-button-flat", "k-button-flat-base", "k-button-icon", 3, "click", "keydown.enter", "keydown.space"], [1, "k-icon", "k-i-reset-color"], [1, "k-alpha-slider", "k-colorgradient-slider", 3, "ngClass", "dragHandleTitle", "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange"], ["alphaSlider", ""], ["kendoContrastTool", "", 1, "k-colorgradient-color-contrast", "k-vbox", 3, "value", "ratio"]]; }, template: function ColorGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1)(2, "div", 2, 3)(4, "div", 4, 5);
        ɵngcc0.ɵɵlistener("click", function ColorGradientComponent_Template_div_click_4_listener($event) { return ctx.changePosition($event); })("kendoPress", function ColorGradientComponent_Template_div_kendoPress_4_listener($event) { return ctx.handleDragPress($event); })("kendoDrag", function ColorGradientComponent_Template_div_kendoDrag_4_listener($event) { return ctx.onHandleDrag($event); })("kendoRelease", function ColorGradientComponent_Template_div_kendoRelease_4_listener() { return ctx.onHandleRelease(); });
        ɵngcc0.ɵɵelement(6, "div", 6, 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, ColorGradientComponent__svg_svg_8_Template, 1, 3, "svg", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "div");
        ɵngcc0.ɵɵtemplate(10, ColorGradientComponent_span_10_Template, 2, 2, "span", 9);
        ɵngcc0.ɵɵelementStart(11, "kendo-slider", 10);
        ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_slider_valueChange_11_listener($event) { return ctx.handleHueSliderChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(12, ColorGradientComponent_kendo_slider_12_Template, 2, 14, "kendo-slider", 11);
        ɵngcc0.ɵɵelementEnd()();
        ɵngcc0.ɵɵelementStart(13, "kendo-colorinput", 12, 13);
        ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_colorinput_valueChange_13_listener($event) { return ctx.handleInputsValueChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(15, ColorGradientComponent_div_15_Template, 1, 2, "div", 14);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(5);
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵattribute("title", ctx.colorGradientHandleTitle)("aria-label", ctx.colorGradientHandleAriaLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.contrastToolVisible && _r1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMapInterpolate1("k-hsv-controls k-hstack ", ctx.clearButton ? "k-sliders-wrap-clearable" : "", "");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.clearButton);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(26, _c71, ctx.clearButton))("dragHandleTitle", ctx.hueSliderTitle)("disabled", ctx.disabled)("readonly", ctx.readonly)("showButtons", false)("tickPlacement", "none")("vertical", true)("min", 0)("max", 360)("value", ctx.hsva.value.h)("smallStep", 5)("largeStep", 10);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.opacity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("opacity", ctx.opacity)("formatView", ctx.format)("value", ctx.value)("disabled", ctx.disabled)("readonly", ctx.readonly);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.contrastToolVisible);
    } }, directives: function () { return [LocalizedColorPickerMessagesDirective, ɵngcc2.DraggableDirective, ɵngcc3.NgIf, ColorContrastSvgComponent, SliderComponent, ɵngcc3.NgClass, ColorInputComponent, ContrastComponent]; }, styles: [".k-clear-color[_ngcontent-%COMP%] {\n            position: absolute;\n            top: 0;\n            left: 50%;\n            transform: translateX(-50%);\n        }\n        .k-colorgradient-slider.k-align-self-end[_ngcontent-%COMP%] {\n            height: 140px;\n        }\n\n        .k-color-contrast-svg[_ngcontent-%COMP%] {\n            position: absolute;\n            overflow: visible;\n            pointer-events: none;\n            left: 0px;\n            top: 0px;\n        }"] });
__decorate([
    HostBinding('class.k-colorgradient'),
    __metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('attr.aria-readonly'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "readonlyAttribute", null);
__decorate([
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "gradientId", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], ColorGradientComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "hostTabindex", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorGradientComponent.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "clearButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ColorGradientComponent.prototype, "delay", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorGradientComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorGradientComponent.prototype, "contrastTool", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], ColorGradientComponent.prototype, "tabindex", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorGradientComponent.prototype, "format", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorGradientComponent.prototype, "valueChange", void 0);
__decorate([
    ViewChild('gradientDragHandle', { read: ElementRef, static: false }),
    __metadata("design:type", ElementRef)
], ColorGradientComponent.prototype, "gradientDragHandle", void 0);
__decorate([
    ViewChild('inputs', { static: false }),
    __metadata("design:type", ColorInputComponent)
], ColorGradientComponent.prototype, "inputs", void 0);
__decorate([
    ViewChild('alphaSlider', { static: false }),
    __metadata("design:type", SliderComponent)
], ColorGradientComponent.prototype, "alphaSlider", void 0);
__decorate([
    ViewChild('gradientWrapper', { static: false }),
    __metadata("design:type", ElementRef)
], ColorGradientComponent.prototype, "gradientWrapper", void 0);
__decorate([
    ViewChild('hsvRectangle', { static: false }),
    __metadata("design:type", ElementRef)
], ColorGradientComponent.prototype, "hsvRectangle", void 0);
ColorGradientComponent = ColorGradientComponent_1 = __decorate([ __metadata("design:paramtypes", [ElementRef,
        NgZone,
        Renderer2,
        ChangeDetectorRef,
        LocalizationService])
], ColorGradientComponent);

/**
 * @hidden
 */
let ColorPaletteLocalizationService = class ColorPaletteLocalizationService extends LocalizationService {
    constructor(prefix, messageService, _rtl, flatColorPickerLocalization) {
        super(prefix, messageService, _rtl);
        this.flatColorPickerLocalization = flatColorPickerLocalization;
    }
    get(shortKey) {
        if (this.flatColorPickerLocalization) {
            return this.flatColorPickerLocalization.get(shortKey);
        }
        return super.get(shortKey);
    }
};
ColorPaletteLocalizationService.ɵfac = function ColorPaletteLocalizationService_Factory(t) { return new (t || ColorPaletteLocalizationService)(ɵngcc0.ɵɵinject(L10N_PREFIX), ɵngcc0.ɵɵinject(ɵngcc1.MessageService, 8), ɵngcc0.ɵɵinject(RTL, 8), ɵngcc0.ɵɵinject(FlatColorPickerLocalizationService, 8)); };
ColorPaletteLocalizationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ColorPaletteLocalizationService, factory: function (t) { return ColorPaletteLocalizationService.ɵfac(t); } });
ColorPaletteLocalizationService = __decorate([
    __param(0, Inject(L10N_PREFIX)),
    __param(1, Optional()),
    __param(2, Optional()), __param(2, Inject(RTL)),
    __param(3, Optional()), __param(3, Inject(FlatColorPickerLocalizationService)),
    __metadata("design:paramtypes", [String, MessageService, Boolean, FlatColorPickerLocalizationService])
], ColorPaletteLocalizationService);

/**
 * @hidden
 */
let ColorPaletteService = class ColorPaletteService {
    /**
     * @hidden
     */
    constructor() {
        this.colorRows = [];
    }
    setColorMatrix(palette, columns) {
        this.colorRows = [];
        if (!(isPresent(palette) && palette.length)) {
            return;
        }
        columns = columns || palette.length;
        for (let start = 0; start < palette.length; start += columns) {
            const row = palette.slice(start, columns + start);
            this.colorRows.push(row);
        }
    }
    getCellCoordsFor(color) {
        if (!isPresent(color)) {
            return;
        }
        for (let row = 0; row < this.colorRows.length; row++) {
            for (let col = 0; col < this.colorRows[row].length; col++) {
                if (this.colorRows[row][col] === color) {
                    return { row, col };
                }
            }
        }
    }
    getColorAt(cellCoords) {
        if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {
            return;
        }
        return this.colorRows[cellCoords.row][cellCoords.col];
    }
    getNextCell(current, horizontalStep, verticalStep) {
        if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {
            return { row: 0, col: 0 };
        }
        const row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);
        const col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);
        return { row, col };
    }
    clampIndex(index, max) {
        const minArrayIndex = 0;
        if (index < minArrayIndex) {
            return minArrayIndex;
        }
        if (index > max) {
            return max;
        }
        return index;
    }
};
ColorPaletteService.ɵfac = function ColorPaletteService_Factory(t) { return new (t || ColorPaletteService)(); };
ColorPaletteService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ColorPaletteService, factory: function (t) { return ColorPaletteService.ɵfac(t); } });

var ColorPaletteComponent_1;
const DEFAULT_TILE_SIZE = 24;
const DEFAULT_COLUMNS_COUNT = 10;
const DEFAULT_PRESET$1 = 'office';
const DEFAULT_ACCESSIBLE_PRESET$1 = 'accessible';
let serial$1 = 0;
/**
 * The ColorPalette component provides a set of predefined palette presets and enables you to implement a custom color palette.
 * The ColorPalette is independently used by `kendo-colorpicker` and can be directly added to the page.
 */
let ColorPaletteComponent = ColorPaletteComponent_1 = class ColorPaletteComponent {
    constructor(host, service, cdr, renderer, localizationService, ngZone) {
        this.host = host;
        this.service = service;
        this.cdr = cdr;
        this.renderer = renderer;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        /**
         * @hidden
         */
        this.id = `k-colorpalette-${serial$1++}`;
        /**
         * Specifies the output format of the ColorPaletteComponent.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * The supported values are:
         * * (Default) `hex`
         * * `rgba`
         * * `name`
         */
        this.format = 'hex';
        /**
         * Sets the disabled state of the ColorPalette.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorPalette.
         */
        this.readonly = false;
        /**
         * Specifies the size of a color cell.
         *
         * The possible values are:
         * * (Default) `tileSize = 24`
         * * `{ width: number, height: number }`
         */
        this.tileSize = { width: DEFAULT_TILE_SIZE, height: DEFAULT_TILE_SIZE };
        /**
         * Fires each time the color selection is changed.
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires each time the value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user selects a cell with the mouse or presses `Enter`.
         *
         * @hidden
         */
        this.cellSelection = new EventEmitter();
        /**
         * @hidden
         */
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.uniqueId = guid();
        this._tabindex = 0;
        this.notifyNgTouched = () => { };
        this.notifyNgChanged = () => { };
        validatePackage(packageMetadata);
        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * @hidden
     */
    get paletteId() {
        return this.id;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor$1(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Specifies the number of columns that will be displayed.
     * Defaults to `10`.
     */
    set columns(value) {
        const minColumnsCount = 1;
        this._columns = value > minColumnsCount ? value : minColumnsCount;
    }
    get columns() {
        return this._columns;
    }
    /**
     * The color palette that will be displayed.
     *
     * The supported values are:
     * * The name of the predefined palette preset (for example, `office`, `basic`, and `apex`).
     * * A string with comma-separated colors.
     * * A string array.
     */
    set palette(value) {
        if (!isPresent(value)) {
            value = DEFAULT_PRESET$1;
        }
        if (typeof value === 'string' && isPresent(PALETTEPRESETS[value])) {
            this.columns = this.columns || PALETTEPRESETS[value].columns;
            value = PALETTEPRESETS[value].colors;
        }
        const colors = (typeof value === 'string') ? value.split(',') : value;
        this._palette = colors.map(color => parseColor$1(color, this.format, false, false));
    }
    get palette() {
        return this._palette;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * @hidden
     */
    get tileLayout() {
        if (typeof this.tileSize !== 'number') {
            return this.tileSize;
        }
        return { width: this.tileSize, height: this.tileSize };
    }
    /**
     * @hidden
     */
    get colorRows() {
        return this.service.colorRows;
    }
    /**
     * @hidden
     */
    get hostTabindex() { return this.tabindex; }
    /**
     * @hidden
     */
    get disabledClass() { return this.disabled; }
    /**
     * @hidden
     */
    get readonlyAttribute() { return this.readonly; }
    ngOnInit() {
        if (this.colorRows.length === 0) {
            const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;
            this.palette = this.palette || defaultPreset;
            this.setRows();
        }
    }
    ngAfterViewInit() {
        this.setHostElementAriaLabel();
        if (this.value) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                this.selectCell(this.value);
            });
        }
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        if (changes.palette || changes.columns) {
            this.setRows();
        }
        if (changes.palette || changes.value || changes.columns) {
            this.selectCell(this.value);
            this.setHostElementAriaLabel();
        }
    }
    /**
     * @hidden
     */
    handleKeydown(event) {
        const isRTL = this.direction === 'rtl';
        switch (event.keyCode) {
            case Keys.ArrowDown:
                this.handleCellNavigation(0, 1);
                break;
            case Keys.ArrowUp:
                this.handleCellNavigation(0, -1);
                break;
            case Keys.ArrowRight:
                this.handleCellNavigation(isRTL ? -1 : 1, 0);
                break;
            case Keys.ArrowLeft:
                this.handleCellNavigation(isRTL ? 1 : -1, 0);
                break;
            case Keys.Enter:
                this.handleEnter();
                break;
            default: return;
        }
        event.preventDefault();
    }
    /**
     * @hidden
     */
    handleHostBlur() {
        this.notifyNgTouched();
        this.handleCellFocusOnBlur();
    }
    /**
     * @hidden
     */
    handleCellSelection(value, focusedCell) {
        if (this.readonly) {
            return;
        }
        this.selectedCell = focusedCell;
        this.focusedCell = this.selectedCell;
        this.focusInComponent = true;
        const parsedColor = parseColor$1(value, this.format, false, false);
        this.cellSelection.emit(parsedColor);
        this.handleValueChange(parsedColor);
        if (this.selection !== parsedColor) {
            this.selection = parsedColor;
            this.selectionChange.emit(parsedColor);
        }
        if (focusedCell) {
            this.activeCellId = `k-${this.selectedCell.row}-${this.selectedCell.col}-${this.uniqueId}`;
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        this.selectCell(value);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    /**
     * Clears the color value of the ColorPalette.
     */
    reset() {
        this.focusedCell = null;
        if (isPresent(this.value)) {
            this.handleValueChange(undefined);
        }
        this.selectedCell = undefined;
    }
    handleValueChange(color) {
        if (this.value === color) {
            return;
        }
        this.value = color;
        this.valueChange.emit(color);
        this.notifyNgChanged(color);
        this.setHostElementAriaLabel();
    }
    handleCellFocusOnBlur() {
        this.focusInComponent = false;
        this.focusedCell = this.selectedCell;
    }
    selectCell(value) {
        this.selectedCell = this.service.getCellCoordsFor(value);
        this.focusedCell = this.selectedCell;
    }
    setRows() {
        if (!isPresent(this.palette)) {
            return;
        }
        this.columns = this.columns || DEFAULT_COLUMNS_COUNT;
        this.service.setColorMatrix(this.palette, this.columns);
    }
    handleCellNavigation(horizontalStep, verticalStep) {
        if (this.readonly) {
            return;
        }
        this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);
        this.focusInComponent = true;
    }
    setHostElementAriaLabel() {
        const parsed = parseColor$1(this.value, this.format);
        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorPaletteNoColor')}`);
    }
    handleEnter() {
        if (!isPresent(this.focusedCell)) {
            return;
        }
        const selectedColor = this.service.getColorAt(this.focusedCell);
        this.handleCellSelection(selectedColor, this.focusedCell);
    }
};
ColorPaletteComponent.ɵfac = function ColorPaletteComponent_Factory(t) { return new (t || ColorPaletteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ColorPaletteService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ColorPaletteComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColorPaletteComponent, selectors: [["kendo-colorpalette"]], hostVars: 9, hostBindings: function ColorPaletteComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function ColorPaletteComponent_keydown_HostBindingHandler($event) { return ctx.handleKeydown($event); })("blur", function ColorPaletteComponent_blur_HostBindingHandler() { return ctx.handleHostBlur(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("id", ctx.paletteId)("tabindex", ctx.hostTabindex)("aria-disabled", ctx.disabledClass)("aria-readonly", ctx.readonlyAttribute);
        ɵngcc0.ɵɵclassProp("k-colorpalette", ctx.hostClasses)("k-state-disabled", ctx.disabledClass);
    } }, inputs: { id: "id", format: "format", disabled: "disabled", readonly: "readonly", tileSize: "tileSize", value: "value", columns: "columns", palette: "palette", tabindex: "tabindex" }, outputs: { selectionChange: "selectionChange", valueChange: "valueChange", cellSelection: "cellSelection" }, exportAs: ["kendoColorPalette"], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorPaletteComponent_1) // tslint:disable-line:no-forward-ref
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorPaletteComponent_1)
            },
            ColorPaletteService,
            ColorPaletteLocalizationService,
            {
                provide: LocalizationService,
                useExisting: ColorPaletteLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorpalette'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 2, consts: function () { let i18n_72; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The aria-label applied to the ColorPalette component when the value is empty.
         * @meaning kendo.colorpalette.colorPaletteNoColor
         */
        const MSG_EXTERNAL_4885193165402402447$$DIST_FESM2015_INDEX_JS_73 = goog.getMsg("Colorpalette no color chosen");
        i18n_72 = MSG_EXTERNAL_4885193165402402447$$DIST_FESM2015_INDEX_JS_73;
    }
    else {
        i18n_72 = $localize `:kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.␟9828bb7d78de6289366052cdc37cf0bc74577313␟4885193165402402447:Colorpalette no color chosen`;
    } return [["kendoColorPaletteLocalizedMessages", "", "colorPaletteNoColor", i18n_72], ["role", "listbox", 1, "k-colorpalette-table-wrap"], [1, "k-colorpalette-table", "k-palette"], [4, "ngFor", "ngForOf"], ["role", "option", "class", "k-colorpalette-tile", 3, "k-state-selected", "k-state-focus", "id", "ngStyle", "click", 4, "ngFor", "ngForOf"], ["role", "option", 1, "k-colorpalette-tile", 3, "id", "ngStyle", "click"]]; }, template: function ColorPaletteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1)(2, "table", 2)(3, "tbody");
        ɵngcc0.ɵɵtemplate(4, ColorPaletteComponent_tr_4_Template, 2, 1, "tr", 3);
        ɵngcc0.ɵɵelementEnd()()();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeCellId);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.colorRows);
    } }, directives: function () { return [LocalizedColorPickerMessagesDirective, ɵngcc3.NgForOf, ɵngcc3.NgStyle]; }, encapsulation: 2 });
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], ColorPaletteComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "paletteId", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPaletteComponent.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPaletteComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorPaletteComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], ColorPaletteComponent.prototype, "columns", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ColorPaletteComponent.prototype, "palette", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], ColorPaletteComponent.prototype, "tabindex", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColorPaletteComponent.prototype, "tileSize", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "selectionChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "cellSelection", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "hostTabindex", null);
__decorate([
    HostBinding('class.k-colorpalette'),
    __metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('attr.aria-disabled'),
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('attr.aria-readonly'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "readonlyAttribute", null);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ColorPaletteComponent.prototype, "handleKeydown", null);
__decorate([
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ColorPaletteComponent.prototype, "handleHostBlur", null);
ColorPaletteComponent = ColorPaletteComponent_1 = __decorate([ __metadata("design:paramtypes", [ElementRef,
        ColorPaletteService,
        ChangeDetectorRef,
        Renderer2,
        LocalizationService,
        NgZone])
], ColorPaletteComponent);

/**
 * @hidden
 */
let FlatColorPickerHeaderComponent = class FlatColorPickerHeaderComponent {
    constructor(localizationService) {
        this.localizationService = localizationService;
        this.hostClasses = true;
        this.viewChange = new EventEmitter();
        this.valuePaneClick = new EventEmitter();
        this.clearButtonClick = new EventEmitter();
    }
    onViewButtonClick(view) {
        this.activeView = view;
        this.viewChange.emit(view);
    }
    get viewButtons() {
        return this.views && this.views.indexOf('gradient') >= 0 && this.views.indexOf('palette') >= 0;
    }
    getViewButtonIcon(view) {
        return view === 'gradient' ? 'k-i-color-canvas' : 'k-i-palette';
    }
    getText(text) {
        return this.localizationService.get(text);
    }
};
FlatColorPickerHeaderComponent.ɵfac = function FlatColorPickerHeaderComponent_Factory(t) { return new (t || FlatColorPickerHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
FlatColorPickerHeaderComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FlatColorPickerHeaderComponent, selectors: [["", "kendoFlatColorPickerHeader", ""]], viewQuery: function FlatColorPickerHeaderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c75, 5, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c76, 5, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.clearButtonElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewButtonsCollection = _t);
    } }, hostVars: 4, hostBindings: function FlatColorPickerHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-coloreditor-header", ctx.hostClasses)("k-hstack", ctx.hostClasses);
    } }, inputs: { activeView: "activeView", clearButton: "clearButton", views: "views", preview: "preview", value: "value", selection: "selection" }, outputs: { viewChange: "viewChange", valuePaneClick: "valuePaneClick", clearButtonClick: "clearButtonClick" }, attrs: _c77, decls: 6, vars: 3, consts: [[1, "k-coloreditor-header-actions", "k-hstack"], ["class", "k-button-group k-button-group-flat", 4, "ngIf"], [1, "k-spacer"], ["type", "button", "class", "k-button k-button-md k-button-flat k-button-flat-base k-icon-button k-coloreditor-reset", 3, "click", 4, "ngIf"], ["class", "k-coloreditor-preview k-vstack", 4, "ngIf"], [1, "k-button-group", "k-button-group-flat"], ["type", "button", "class", "k-button k-button-md k-button-flat k-button-flat-base k-icon-button", 3, "ngClass", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "k-button", "k-button-md", "k-button-flat", "k-button-flat-base", "k-icon-button", 3, "ngClass", "click"], ["viewButtons", ""], [1, "k-button-icon", "k-icon", 3, "ngClass"], ["type", "button", 1, "k-button", "k-button-md", "k-button-flat", "k-button-flat-base", "k-icon-button", "k-coloreditor-reset", 3, "click"], ["clearButton", ""], [1, "k-button-icon", "k-icon", "k-i-reset-color"], [1, "k-coloreditor-preview", "k-vstack"], [1, "k-coloreditor-preview-color", "k-color-preview"], [1, "k-coloreditor-current-color", "k-color-preview", 3, "click"]], template: function FlatColorPickerHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, FlatColorPickerHeaderComponent_div_1_Template, 2, 1, "div", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 0);
        ɵngcc0.ɵɵtemplate(4, FlatColorPickerHeaderComponent_button_4_Template, 3, 2, "button", 3);
        ɵngcc0.ɵɵtemplate(5, FlatColorPickerHeaderComponent_div_5_Template, 3, 6, "div", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.viewButtons);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.clearButton);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.preview);
    } }, directives: [ɵngcc3.NgIf, ɵngcc3.NgForOf, ɵngcc3.NgClass], encapsulation: 2 });
__decorate([
    HostBinding('class.k-coloreditor-header'),
    HostBinding('class.k-hstack'),
    __metadata("design:type", Boolean)
], FlatColorPickerHeaderComponent.prototype, "hostClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FlatColorPickerHeaderComponent.prototype, "clearButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatColorPickerHeaderComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], FlatColorPickerHeaderComponent.prototype, "views", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FlatColorPickerHeaderComponent.prototype, "preview", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatColorPickerHeaderComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatColorPickerHeaderComponent.prototype, "selection", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FlatColorPickerHeaderComponent.prototype, "viewChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FlatColorPickerHeaderComponent.prototype, "valuePaneClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FlatColorPickerHeaderComponent.prototype, "clearButtonClick", void 0);
__decorate([
    ViewChildren('viewButtons', { read: ElementRef }),
    __metadata("design:type", QueryList)
], FlatColorPickerHeaderComponent.prototype, "viewButtonsCollection", void 0);
__decorate([
    ViewChild('clearButton', { read: ElementRef, static: false }),
    __metadata("design:type", ElementRef)
], FlatColorPickerHeaderComponent.prototype, "clearButtonElement", void 0);
FlatColorPickerHeaderComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], FlatColorPickerHeaderComponent);

/**
 * @hidden
 */
let FlatColorPickerActionButtonsComponent = class FlatColorPickerActionButtonsComponent {
    constructor(localizationService) {
        this.localizationService = localizationService;
        this.hostClasses = true;
        this.actionButtonClick = new EventEmitter();
    }
    getText(text) {
        return this.localizationService.get(text);
    }
    onActionButtonClick(type, ev) {
        let args = {
            target: type,
            originalEvent: ev
        };
        this.actionButtonClick.emit(args);
    }
};
FlatColorPickerActionButtonsComponent.ɵfac = function FlatColorPickerActionButtonsComponent_Factory(t) { return new (t || FlatColorPickerActionButtonsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
FlatColorPickerActionButtonsComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FlatColorPickerActionButtonsComponent, selectors: [["", "kendoFlatColorPickerActionButtons", ""]], viewQuery: function FlatColorPickerActionButtonsComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c78, 5, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lastButton = _t.first);
    } }, hostVars: 6, hostBindings: function FlatColorPickerActionButtonsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-coloreditor-footer", ctx.hostClasses)("k-actions", ctx.hostClasses)("k-hstack", ctx.hostClasses);
    } }, outputs: { actionButtonClick: "actionButtonClick" }, attrs: _c79, decls: 5, vars: 4, consts: [["type", "button", 1, "k-coloreditor-cancel", "k-button", "k-button-md", "k-button-solid", "k-button-solid-base", 3, "click"], ["type", "button", 1, "k-coloreditor-apply", "k-button", "k-button-md", "k-button-solid", "k-button-solid-primary", 3, "click"], ["last", ""]], template: function FlatColorPickerActionButtonsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function FlatColorPickerActionButtonsComponent_Template_button_click_0_listener($event) { return ctx.onActionButtonClick("cancel", $event); });
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "button", 1, 2);
        ɵngcc0.ɵɵlistener("click", function FlatColorPickerActionButtonsComponent_Template_button_click_2_listener($event) { return ctx.onActionButtonClick("apply", $event); });
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("title", ctx.getText("cancelButton"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.getText("cancelButton"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("title", ctx.getText("applyButton"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.getText("applyButton"));
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-coloreditor-footer'),
    HostBinding('class.k-actions'),
    HostBinding('class.k-hstack'),
    __metadata("design:type", Boolean)
], FlatColorPickerActionButtonsComponent.prototype, "hostClasses", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FlatColorPickerActionButtonsComponent.prototype, "actionButtonClick", void 0);
__decorate([
    ViewChild('last', { read: ElementRef, static: false }),
    __metadata("design:type", ElementRef)
], FlatColorPickerActionButtonsComponent.prototype, "lastButton", void 0);
FlatColorPickerActionButtonsComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], FlatColorPickerActionButtonsComponent);

var FlatColorPickerComponent_1;
/**
 * Represents the [Kendo UI FlatColorPicker component for Angular]({% slug overview_flatcolorpicker %}).
 *
 * The FlatColorPicker is a powerful tool which allows the user to choose colors through palettes with predefined sets of colors and
 * through a gradient that renders an hsv canvas. It supports previewing the selected color, reverting it to its previous state or clearing it completely.
 */
let FlatColorPickerComponent = FlatColorPickerComponent_1 = class FlatColorPickerComponent {
    constructor(host, service, localizationService, cdr, renderer, ngZone) {
        this.host = host;
        this.service = service;
        this.localizationService = localizationService;
        this.cdr = cdr;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.hostClasses = true;
        /**
         * Sets the read-only state of the FlatColorPicker.
         *
         * @default false
         */
        this.readonly = false;
        /**
         * Sets the disabled state of the FlatColorPicker.
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Specifies the output format of the FlatColorPicker.
         *
         * If the input value is in a different format, it will be parsed into the specified output `format`.
         *
         * The supported values are:
         * * `rgba` (default)
         * * `hex`
         */
        this.format = 'rgba';
        /**
         * Specifies whether the FlatColorPicker should display a 'Clear color' button.
         *
         * @default true
         */
        this.clearButton = true;
        /**
         * Displays `Apply` and `Cancel` action buttons and a color preview pane.
         *
         * When enabled, the component value will not change immediately upon
         * color selection, but only after the `Apply` button is clicked.
         *
         * The `Cancel` button reverts the current selection to its
         * initial state i.e. to the current value.
         *
         * @default true
         */
        this.preview = true;
        /**
         * Configures the layout of the `Apply` and `Cancel` action buttons.
         * * `start`
         * * `center`
         * * `end` (default)
         * * `stretch`
         */
        this.actionsLayout = 'end';
        /**
         * Specifies the views that will be rendered. Default value is gradient and palette.
         */
        this.views = ['gradient', 'palette'];
        /**
         * Fires each time the component value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires when the user cancels the current color selection.
         *
         * The event is emitted on preview pane or on 'Cancel' button click.
         */
        this.cancel = new EventEmitter();
        /**
         * Fires each time the view is about to change.
         * Used to provide a two-way binding for the `activeView` property.
         */
        this.activeViewChange = new EventEmitter();
        /**
         * @hidden
         */
        this.actionButtonClick = new EventEmitter();
        this._tabindex = 0;
        this._gradientSettings = { opacity: true, delay: 0 };
        this._paletteSettings = {};
        this.subscriptions = new Subscription();
        this.notifyNgChanged = () => { };
        this.notifyNgTouched = () => { };
        validatePackage(packageMetadata);
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    get disabledClass() {
        return this.disabled;
    }
    get ariaReadonly() {
        return this.readonly;
    }
    get hostTabindex() {
        return this.tabindex;
    }
    /**
     * Specifies the initially selected color.
     */
    set value(value) {
        this._value = parseColor$1(value, this.format, this.gradientSettings.opacity);
    }
    get value() {
        return this._value;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     *
     * @default 0
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * Configures the gradient view.
     */
    set gradientSettings(value) {
        Object.assign(this._gradientSettings, value);
    }
    get gradientSettings() {
        return this._gradientSettings;
    }
    /**
     * Configures the palette view.
     */
    set paletteSettings(value) {
        Object.assign(this._paletteSettings, value);
    }
    get paletteSettings() {
        return this._paletteSettings;
    }
    ngOnInit() {
        this.selection = this.value;
        this._paletteSettings = this.service.getPaletteSettings(this._paletteSettings, this.format);
        this.setActiveView();
    }
    ngAfterViewInit() {
        this.setHostElementAriaLabel();
        this.initDomEvents();
        this.setSizingVariables();
    }
    ngOnChanges(changes) {
        if (isChanged('value', changes)) {
            this.selection = this.value;
            this.setHostElementAriaLabel();
        }
        if (isChanged('paletteSettings', changes)) {
            this.setSizingVariables();
        }
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    get headerHasContent() {
        return this.preview || this.views.length > 1 || this.clearButton;
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    /**
     * Focuses the wrapper of the FlatColorPicker.
     */
    focus() {
        if (this.disabled && this.focused) {
            return;
        }
        this.host.nativeElement.focus();
        this.focused = true;
    }
    /**
     * Blurs the wrapper of the FlatColorPicker.
     */
    blur() {
        if (!this.focused) {
            return;
        }
        this.notifyNgTouched();
        this.host.nativeElement.blur();
        this.focused = false;
    }
    /**
     * Clears the value of the FlatColorPicker.
     */
    reset() {
        if (!isPresent(this.value)) {
            return;
        }
        this.value = undefined;
        this.notifyNgChanged(undefined);
        this.setHostElementAriaLabel();
    }
    /**
     * @hidden
     */
    onViewChange(view) {
        if (this.activeView === view) {
            return;
        }
        this.activeView = view;
        this.activeViewChange.emit(view);
        if (this.activeView === 'gradient') {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.gradient.gradientDragHandle.nativeElement.focus();
                });
            });
        }
    }
    /**
     * @hidden
     */
    onClearButtonClick() {
        this.resetInnerComponentValue();
        this.host.nativeElement.focus();
    }
    /**
     * @hidden
     */
    handleValueChange(color) {
        this.preview ? this.changeCurrentValue(color) : this.setFlatColorPickerValue(color);
    }
    /**
     * @hidden
     */
    onAction(ev) {
        ev.target === 'apply' ? this.setFlatColorPickerValue(this.selection) : this.resetSelection(ev.originalEvent);
        this.actionButtonClick.emit();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    resetSelection(ev) {
        const eventArgs = new ColorPickerCancelEvent(ev);
        this.cancel.emit(eventArgs);
        if (!eventArgs.isDefaultPrevented()) {
            this.selection = this.value;
        }
        this.notifyNgTouched();
    }
    setHostElementAriaLabel() {
        const parsed = parseColor$1(this.value, this.format, this.gradientSettings.opacity);
        const ariaLabelValue = `${this.value ? parsed : this.localizationService.get('flatColorPickerNoColor')}`;
        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', ariaLabelValue);
    }
    setSizingVariables() {
        const paletteTileSize = this.service.paletteTileLayout(this.paletteSettings.tileSize);
        const value = `--kendo-color-preview-columns: ${this.paletteSettings.columns};
            --kendo-color-preview-width: ${paletteTileSize.width}px;
            --kendo-color-preview-height: ${paletteTileSize.height}px;`;
        this.host.nativeElement.querySelector('.k-coloreditor-views.k-vstack').setAttribute('style', value);
    }
    changeCurrentValue(color) {
        this.selection = color;
        this.notifyNgTouched();
    }
    resetInnerComponentValue() {
        this.selection = null;
        if (this.gradient) {
            this.gradient.reset();
            return;
        }
        this.palette.reset();
    }
    setFlatColorPickerValue(color) {
        if (this.value === color) {
            return;
        }
        this.value = color;
        this.valueChange.emit(color);
        this.notifyNgChanged(color);
        this.setHostElementAriaLabel();
    }
    setActiveView() {
        if (!isPresent(this.activeView)) {
            this.activeView = this.views[0];
            return;
        }
        if (isDevMode() && this.views.indexOf(this.activeView) === -1) {
            throw new Error("Invalid configuration: The current activeView is not present in the views collection");
        }
    }
    initDomEvents() {
        if (!this.host) {
            return;
        }
        let hostElement = this.host.nativeElement;
        this.ngZone.runOutsideAngular(() => {
            this.subscriptions.add(this.renderer.listen(hostElement, 'focus', () => {
                this.focused = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'blur', () => {
                this.focused = false;
                this.notifyNgTouched();
            }));
        });
    }
};
FlatColorPickerComponent.ɵfac = function FlatColorPickerComponent_Factory(t) { return new (t || FlatColorPickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(FlatColorPickerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
FlatColorPickerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FlatColorPickerComponent, selectors: [["kendo-flatcolorpicker"]], viewQuery: function FlatColorPickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c80, 5);
        ɵngcc0.ɵɵviewQuery(_c81, 5);
        ɵngcc0.ɵɵviewQuery(_c82, 5);
        ɵngcc0.ɵɵviewQuery(_c83, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.gradient = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.palette = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footer = _t.first);
    } }, hostVars: 10, hostBindings: function FlatColorPickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("aria-disabled", ctx.disabledClass)("aria-readonly", ctx.ariaReadonly)("tabindex", ctx.hostTabindex);
        ɵngcc0.ɵɵclassProp("k-flatcolorpicker", ctx.hostClasses)("k-coloreditor", ctx.hostClasses)("k-state-disabled", ctx.disabledClass);
    } }, inputs: { readonly: "readonly", disabled: "disabled", format: "format", clearButton: "clearButton", preview: "preview", actionsLayout: "actionsLayout", views: "views", value: "value", tabindex: "tabindex", gradientSettings: "gradientSettings", paletteSettings: "paletteSettings", activeView: "activeView" }, outputs: { valueChange: "valueChange", cancel: "cancel", activeViewChange: "activeViewChange", actionButtonClick: "actionButtonClick" }, exportAs: ["kendoFlatColorPicker"], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => FlatColorPickerComponent_1)
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => FlatColorPickerComponent_1)
            },
            FlatColorPickerService,
            FlatColorPickerLocalizationService,
            {
                provide: LocalizationService,
                useExisting: FlatColorPickerLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.flatcolorpicker'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 6, vars: 4, consts: function () { let i18n_84; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The aria-label applied to the FlatColorPicker component when the value is empty.
         * @meaning kendo.flatcolorpicker.flatColorPickerNoColor
         */
        const MSG_EXTERNAL_5587373573749332242$$DIST_FESM2015_INDEX_JS_85 = goog.getMsg("Flatcolorpicker no color chosen");
        i18n_84 = MSG_EXTERNAL_5587373573749332242$$DIST_FESM2015_INDEX_JS_85;
    }
    else {
        i18n_84 = $localize `:kendo.flatcolorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty.␟0f7452f62e10ab71bd427d5d9716b49ac61ab5cd␟5587373573749332242:Flatcolorpicker no color chosen`;
    } let i18n_86; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The aria-label applied to the ColorGradient component when the value is empty.
         * @meaning kendo.flatcolorpicker.colorGradientNoColor
         */
        const MSG_EXTERNAL_6087544506182000157$$DIST_FESM2015_INDEX_JS_87 = goog.getMsg("Colorgradient no color chosen");
        i18n_86 = MSG_EXTERNAL_6087544506182000157$$DIST_FESM2015_INDEX_JS_87;
    }
    else {
        i18n_86 = $localize `:kendo.flatcolorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.␟541a344c7dea04899f8657a5577fe5e766a1de78␟6087544506182000157:Colorgradient no color chosen`;
    } let i18n_88; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The aria-label applied to the ColorPalette component when the value is empty.
         * @meaning kendo.flatcolorpicker.colorPaletteNoColor
         */
        const MSG_EXTERNAL_5441368432797392985$$DIST_FESM2015_INDEX_JS_89 = goog.getMsg("Colorpalette no color chosen");
        i18n_88 = MSG_EXTERNAL_5441368432797392985$$DIST_FESM2015_INDEX_JS_89;
    }
    else {
        i18n_88 = $localize `:kendo.flatcolorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.␟5b0ef7b14a7b89fa83ac1959abe3245a9b05cc86␟5441368432797392985:Colorpalette no color chosen`;
    } let i18n_90; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the gradient color drag handle chooser.
         * @meaning kendo.flatcolorpicker.colorGradientHandle
         */
        const MSG_EXTERNAL_908566823276809035$$DIST_FESM2015_INDEX_JS_91 = goog.getMsg("Choose color");
        i18n_90 = MSG_EXTERNAL_908566823276809035$$DIST_FESM2015_INDEX_JS_91;
    }
    else {
        i18n_90 = $localize `:kendo.flatcolorpicker.colorGradientHandle|The title for the gradient color drag handle chooser.␟f88a7ad2af0d59dbdad7553ee6ad95a86fe20882␟908566823276809035:Choose color`;
    } let i18n_92; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the clear button.
         * @meaning kendo.flatcolorpicker.clearButton
         */
        const MSG_EXTERNAL_657623164139733574$$DIST_FESM2015_INDEX_JS_93 = goog.getMsg("Clear value");
        i18n_92 = MSG_EXTERNAL_657623164139733574$$DIST_FESM2015_INDEX_JS_93;
    }
    else {
        i18n_92 = $localize `:kendo.flatcolorpicker.clearButton|The title for the clear button.␟bd6cf8e193307efc693aee23dc4e2db9d789e10a␟657623164139733574:Clear value`;
    } let i18n_94; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the hue slider handle.
         * @meaning kendo.flatcolorpicker.hueSliderHandle
         */
        const MSG_EXTERNAL_2871570350756645741$$DIST_FESM2015_INDEX_JS_95 = goog.getMsg("Set hue");
        i18n_94 = MSG_EXTERNAL_2871570350756645741$$DIST_FESM2015_INDEX_JS_95;
    }
    else {
        i18n_94 = $localize `:kendo.flatcolorpicker.hueSliderHandle|The title for the hue slider handle.␟f7634baf3ab601a1285db7e51a6f6549e0ed4ba6␟2871570350756645741:Set hue`;
    } let i18n_96; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the opacity slider handle.
         * @meaning kendo.flatcolorpicker.opacitySliderHandle
         */
        const MSG_EXTERNAL_2815381853083847348$$DIST_FESM2015_INDEX_JS_97 = goog.getMsg("Set opacity");
        i18n_96 = MSG_EXTERNAL_2815381853083847348$$DIST_FESM2015_INDEX_JS_97;
    }
    else {
        i18n_96 = $localize `:kendo.flatcolorpicker.opacitySliderHandle|The title for the opacity slider handle.␟b74f0733a8409487e8605fc94804361b16e90f82␟2815381853083847348:Set opacity`;
    } let i18n_98; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The contrast ratio message for the contrast tool.
         * @meaning kendo.flatcolorpicker.contrastRatio
         */
        const MSG_EXTERNAL_4111165279880035613$$DIST_FESM2015_INDEX_JS_99 = goog.getMsg("Contrast ratio");
        i18n_98 = MSG_EXTERNAL_4111165279880035613$$DIST_FESM2015_INDEX_JS_99;
    }
    else {
        i18n_98 = $localize `:kendo.flatcolorpicker.contrastRatio|The contrast ratio message for the contrast tool.␟cf21eedf118e7cdf7acc1cc94c7ae5359b926b24␟4111165279880035613:Contrast ratio`;
    } let i18n_100; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the color preview pane.
         * @meaning kendo.flatcolorpicker.previewColor
         */
        const MSG_EXTERNAL_7520629536331583555$$DIST_FESM2015_INDEX_JS_101 = goog.getMsg("Color preview");
        i18n_100 = MSG_EXTERNAL_7520629536331583555$$DIST_FESM2015_INDEX_JS_101;
    }
    else {
        i18n_100 = $localize `:kendo.flatcolorpicker.previewColor|The message for the color preview pane.␟19edaabd407cee636a3e0a0101ac6ea4727c81e6␟7520629536331583555:Color preview`;
    } let i18n_102; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the selected color pane.
         * @meaning kendo.flatcolorpicker.revertSelection
         */
        const MSG_EXTERNAL_5917429966250498596$$DIST_FESM2015_INDEX_JS_103 = goog.getMsg("Revert selection");
        i18n_102 = MSG_EXTERNAL_5917429966250498596$$DIST_FESM2015_INDEX_JS_103;
    }
    else {
        i18n_102 = $localize `:kendo.flatcolorpicker.revertSelection|The message for the selected color pane.␟04eaa4e7591b21192b79a8587cb65842f217777b␟5917429966250498596:Revert selection`;
    } let i18n_104; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the gradient view button.
         * @meaning kendo.flatcolorpicker.gradientView
         */
        const MSG_EXTERNAL_2063234049296472476$$DIST_FESM2015_INDEX_JS_105 = goog.getMsg("Gradient view");
        i18n_104 = MSG_EXTERNAL_2063234049296472476$$DIST_FESM2015_INDEX_JS_105;
    }
    else {
        i18n_104 = $localize `:kendo.flatcolorpicker.gradientView|The message for the gradient view button.␟d89402928a43a6eb802dede7a3d3459047dc42a0␟2063234049296472476:Gradient view`;
    } let i18n_106; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the palette view button.
         * @meaning kendo.flatcolorpicker.paletteView
         */
        const MSG_EXTERNAL_2108885670379641868$$DIST_FESM2015_INDEX_JS_107 = goog.getMsg("Palette view");
        i18n_106 = MSG_EXTERNAL_2108885670379641868$$DIST_FESM2015_INDEX_JS_107;
    }
    else {
        i18n_106 = $localize `:kendo.flatcolorpicker.paletteView|The message for the palette view button.␟94caf0d97fdf686eae9abe143491bf5e70e71d84␟2108885670379641868:Palette view`;
    } let i18n_108; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the input format toggle button.
         * @meaning kendo.flatcolorpicker.formatButton
         */
        const MSG_EXTERNAL_4457740703438950411$$DIST_FESM2015_INDEX_JS_109 = goog.getMsg("Change color format");
        i18n_108 = MSG_EXTERNAL_4457740703438950411$$DIST_FESM2015_INDEX_JS_109;
    }
    else {
        i18n_108 = $localize `:kendo.flatcolorpicker.formatButton|The message for the input format toggle button.␟55f4d138df648aaa2e1e26af224f602c0b4995ab␟4457740703438950411:Change color format`;
    } let i18n_110; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the Apply action button.
         * @meaning kendo.flatcolorpicker.applyButton
         */
        const MSG_EXTERNAL_5677376399033528514$$DIST_FESM2015_INDEX_JS_111 = goog.getMsg("Apply");
        i18n_110 = MSG_EXTERNAL_5677376399033528514$$DIST_FESM2015_INDEX_JS_111;
    }
    else {
        i18n_110 = $localize `:kendo.flatcolorpicker.applyButton|The message for the Apply action button.␟4d2576cd3013f8807c8f42ceb4720cab04907182␟5677376399033528514:Apply`;
    } let i18n_112; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the Cancel action button.
         * @meaning kendo.flatcolorpicker.cancelButton
         */
        const MSG_EXTERNAL_8448158590311818541$$DIST_FESM2015_INDEX_JS_113 = goog.getMsg("Cancel");
        i18n_112 = MSG_EXTERNAL_8448158590311818541$$DIST_FESM2015_INDEX_JS_113;
    }
    else {
        i18n_112 = $localize `:kendo.flatcolorpicker.cancelButton|The message for the Cancel action button.␟db838008681129d988e81a81c94de01aed626ec1␟8448158590311818541:Cancel`;
    } return [["kendoFlatColorPickerLocalizedMessages", "", "flatColorPickerNoColor", i18n_84, "colorGradientNoColor", i18n_86, "colorPaletteNoColor", i18n_88, "colorGradientHandle", i18n_90, "clearButton", i18n_92, "hueSliderHandle", i18n_94, "opacitySliderHandle", i18n_96, "contrastRatio", i18n_98, "previewColor", i18n_100, "revertSelection", i18n_102, "gradientView", i18n_104, "paletteView", i18n_106, "formatButton", i18n_108, "applyButton", i18n_110, "cancelButton", i18n_112], ["kendoFlatColorPickerHeader", "", 3, "clearButton", "activeView", "views", "value", "selection", "preview", "clearButtonClick", "viewChange", "valuePaneClick", 4, "ngIf"], [1, "k-coloreditor-views", "k-vstack"], [3, "tabindex", "value", "format", "opacity", "delay", "contrastTool", "readonly", "valueChange", 4, "ngIf"], ["kendoFocusOnDomReady", "", 3, "palette", "columns", "tileSize", "format", "value", "valueChange", 4, "ngIf"], ["kendoFlatColorPickerActionButtons", "", 3, "ngClass", "actionButtonClick", 4, "ngIf"], ["kendoFlatColorPickerHeader", "", 3, "clearButton", "activeView", "views", "value", "selection", "preview", "clearButtonClick", "viewChange", "valuePaneClick"], ["header", ""], [3, "tabindex", "value", "format", "opacity", "delay", "contrastTool", "readonly", "valueChange"], ["gradient", ""], ["kendoFocusOnDomReady", "", 3, "palette", "columns", "tileSize", "format", "value", "valueChange"], ["palette", ""], ["kendoFlatColorPickerActionButtons", "", 3, "ngClass", "actionButtonClick"], ["footer", ""]]; }, template: function FlatColorPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵtemplate(1, FlatColorPickerComponent_div_1_Template, 2, 6, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, FlatColorPickerComponent_kendo_colorgradient_3_Template, 2, 7, "kendo-colorgradient", 3);
        ɵngcc0.ɵɵtemplate(4, FlatColorPickerComponent_kendo_colorpalette_4_Template, 2, 5, "kendo-colorpalette", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, FlatColorPickerComponent_div_5_Template, 2, 1, "div", 5);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.headerHasContent);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.activeView === "gradient");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.activeView === "palette");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.preview);
    } }, directives: function () { return [LocalizedColorPickerMessagesDirective, ɵngcc3.NgIf, FlatColorPickerHeaderComponent, ColorGradientComponent, ColorPaletteComponent, FocusOnDomReadyDirective, FlatColorPickerActionButtonsComponent, ɵngcc3.NgClass]; }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-flatcolorpicker'),
    HostBinding('class.k-coloreditor'),
    __metadata("design:type", Boolean)
], FlatColorPickerComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.k-state-disabled'),
    HostBinding('attr.aria-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FlatColorPickerComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('attr.aria-readonly'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FlatColorPickerComponent.prototype, "ariaReadonly", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], FlatColorPickerComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], FlatColorPickerComponent.prototype, "hostTabindex", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FlatColorPickerComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FlatColorPickerComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatColorPickerComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], FlatColorPickerComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], FlatColorPickerComponent.prototype, "tabindex", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FlatColorPickerComponent.prototype, "clearButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FlatColorPickerComponent.prototype, "preview", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatColorPickerComponent.prototype, "actionsLayout", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatColorPickerComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], FlatColorPickerComponent.prototype, "views", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], FlatColorPickerComponent.prototype, "gradientSettings", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], FlatColorPickerComponent.prototype, "paletteSettings", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FlatColorPickerComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FlatColorPickerComponent.prototype, "cancel", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FlatColorPickerComponent.prototype, "activeViewChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], FlatColorPickerComponent.prototype, "actionButtonClick", void 0);
__decorate([
    ViewChild('header', { static: false }),
    __metadata("design:type", FlatColorPickerHeaderComponent)
], FlatColorPickerComponent.prototype, "header", void 0);
__decorate([
    ViewChild('gradient', { static: false }),
    __metadata("design:type", ColorGradientComponent)
], FlatColorPickerComponent.prototype, "gradient", void 0);
__decorate([
    ViewChild('palette', { static: false }),
    __metadata("design:type", ColorPaletteComponent)
], FlatColorPickerComponent.prototype, "palette", void 0);
__decorate([
    ViewChild('footer', { static: false }),
    __metadata("design:type", FlatColorPickerActionButtonsComponent)
], FlatColorPickerComponent.prototype, "footer", void 0);
FlatColorPickerComponent = FlatColorPickerComponent_1 = __decorate([ __metadata("design:paramtypes", [ElementRef,
        FlatColorPickerService,
        LocalizationService,
        ChangeDetectorRef,
        Renderer2,
        NgZone])
], FlatColorPickerComponent);

var ColorPickerComponent_1;
const DOM_FOCUS_EVENTS = ['focus', 'blur'];
/**
 * Represents the [Kendo UI ColorPicker component for Angular]({% slug overview_colorpicker %}).
 *
 * The ColorPicker is a powerful tool for choosing colors from Gradient and Palette views
 * which are rendered in its popup. It supports previewing the selected color, reverting it to its previous state or clearing it completely.
 */
let ColorPickerComponent = ColorPickerComponent_1 = class ColorPickerComponent {
    constructor(host, popupService, cdr, localizationService, ngZone, renderer) {
        this.host = host;
        this.popupService = popupService;
        this.cdr = cdr;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.hostClasses = true;
        this.role = 'listbox';
        /**
         * Specifies the views that will be rendered in the popup.
         * By default both the gradient and palette views will be rendered.
         */
        this.views = ['gradient', 'palette'];
        /**
         * Sets the read-only state of the ColorPicker.
         *
         * @default false
         */
        this.readonly = false;
        /**
         * Sets the disabled state of the ColorPicker.
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Specifies the output format of the ColorPicker.
         *
         * If the input value is in a different format, it will be parsed into the specified output `format`.
         *
         * The supported values are:
         * * `rgba` (default)
         * * `hex`
         */
        this.format = 'rgba';
        /**
         * Specifies whether the ColorPicker should display a 'Clear color' button.
         *
         * @default true
         */
        this.clearButton = true;
        /**
         * Displays `Apply` and `Cancel` action buttons and color preview panes.
         *
         * When enabled, the component value will not change immediately upon
         * color selection, but only after the `Apply` button is clicked.
         *
         * The `Cancel` button reverts the current selection to its
         * previous state i.e. to the current value.
         *
         * @default false
         */
        this.preview = false;
        /**
         * Configures the layout of the `Apply` and `Cancel` action buttons.
         *
         * The possible values are:
         * * `start`
         * * `center`
         * * `end` (default)
         * * `stretch`
         */
        this.actionsLayout = 'end';
        /**
         * Fires each time the value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires each time ColorPicker is focused.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the ColorPicker is blurred.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires when the user cancels the current color selection.
         *
         * Fires on preview pane or 'Cancel' button click.
         */
        this.cancel = new EventEmitter();
        /**
         * Fires each time the left side of the ColorPicker wrapper is clicked.
         * The event is triggered regardless of whether a ColorPicker icon is set or not.
         *
         * The [ActiveColorClickEvent]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.
         */
        this.activeColorClick = new EventEmitter();
        /**
         * Fires each time the view is about to change.
         * Used to provide a two-way binding for the `activeView` property.
         */
        this.activeViewChange = new EventEmitter();
        /**
         * Indicates whether the ColorPicker wrapper is focused.
         */
        this.isFocused = false;
        this._tabindex = 0;
        this._popupSettings = { animate: true };
        this._paletteSettings = {};
        this._gradientSettings = { opacity: true, delay: 0 };
        this._size = 'medium';
        this._rounded = 'medium';
        this._fillMode = 'solid';
        this.subscriptions = new Subscription();
        this.notifyNgTouched = () => { };
        this.notifyNgChanged = () => { };
        this.domFocusListener = (event) => event.stopImmediatePropagation();
        validatePackage(packageMetadata);
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    get focusedClass() {
        return this.isFocused;
    }
    get disabledClass() {
        return this.disabled;
    }
    get ariaReadonly() {
        return this.readonly;
    }
    get ariaExpanded() {
        return this.isOpen;
    }
    get hostTabindex() {
        return this.tabindex;
    }
    /**
     * @hidden
     */
    set view(view) {
        this.views = [view];
    }
    get view() {
        return (this.views && this.views.length > 0) ? this.views[0] : null;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor$1(value, this.format, this.gradientSettings.opacity);
    }
    get value() {
        return this._value;
    }
    /**
     * Configures the popup of the ColorPicker.
     */
    set popupSettings(value) {
        this._popupSettings = Object.assign(this._popupSettings, value);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * Configures the palette that is displayed in the ColorPicker popup.
     */
    set paletteSettings(value) {
        this._paletteSettings = Object.assign(this._paletteSettings, value);
    }
    get paletteSettings() {
        return this._paletteSettings;
    }
    /**
     * Configures the gradient that is displayed in the ColorPicker popup.
     */
    set gradientSettings(value) {
        this._gradientSettings = Object.assign(this._gradientSettings, value);
    }
    get gradientSettings() {
        return this._gradientSettings;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     *
     * @default 0
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * The size property specifies the padding of the ColorPicker internal elements
     * ([see example]({% slug appearance_colorpicker %}#toc-size)).
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set size(size) {
        this.handleClasses(size, 'size');
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * The rounded property specifies the border radius of the ColorPicker
     * ([see example]({% slug appearance_colorpicker %}#toc-rounded)).
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `'full'`
     * * `null`
     */
    set rounded(rounded) {
        this.handleClasses(rounded, 'rounded');
        this._rounded = rounded;
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * The fillMode property specifies the background and border styles of the ColorPicker
     * ([see example]({% slug appearance_colorpicker %}#toc-fillMode)).
     *
     * The possible values are:
     * * `'flat'`
     * * `'solid'` (default)
     * * `'outline'`
     * * `null`
     */
    set fillMode(fillMode) {
        this.handleClasses(fillMode, 'fillMode');
        this._fillMode = fillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * Indicates whether the ColorPicker popup is open.
     */
    get isOpen() {
        return isPresent(this.popupRef);
    }
    /**
     * @hidden
     */
    get iconStyles() {
        if (this.iconClass) {
            return this.iconClass;
        }
        if (this.icon) {
            return `k-icon k-i-${this.icon}`;
        }
    }
    ngOnInit() {
        const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;
        const settingsPalette = this._paletteSettings.palette;
        const presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ?
            PALETTEPRESETS[settingsPalette].columns :
            undefined;
        this._paletteSettings = {
            palette: settingsPalette || defaultPreset,
            tileSize: this._paletteSettings.tileSize || 24,
            columns: this._paletteSettings.columns || presetColumns || 10
        };
    }
    ngAfterViewInit() {
        const stylingInputs = ['size', 'rounded', 'fillMode'];
        stylingInputs.forEach(input => {
            this.handleClasses(this[input], input);
        });
        this.setHostElementAriaLabel();
        this.handleHostId();
        this.initDomEvents();
    }
    ngOnChanges(changes) {
        if (changes.format && changes.format.currentValue === 'name') {
            this.activeView = 'palette';
        }
        if (this.activeView === 'gradient' && this.gradientSettings.opacity) {
            this.format = 'rgba';
            this.value = parseColor$1(this.value, this.format, this.gradientSettings.opacity);
        }
        if (isChanged('value', changes)) {
            this.setHostElementAriaLabel();
        }
    }
    ngOnDestroy() {
        this.closePopup();
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
        this.subscriptions.unsubscribe();
        this.handleDomEvents('remove', DOM_FOCUS_EVENTS);
    }
    /**
     * @hidden
     */
    handleCancelEvent(ev) {
        this.cancel.emit(ev);
    }
    /**
     * @hidden
     */
    togglePopup() {
        this.focus();
        this.toggleWithEvents(!this.isOpen);
    }
    /**
     * @hidden
     */
    handleWrapperClick(event) {
        if (this.disabled) {
            return;
        }
        this.focus();
        if (closest(event.target, (element) => element === this.activeColor.nativeElement)) {
            const event = new ActiveColorClickEvent(this.value);
            this.activeColorClick.emit(event);
            if (!event.isOpenPrevented() || this.isOpen) {
                this.toggleWithEvents(!this.isOpen);
            }
            return;
        }
        this.toggleWithEvents(!this.isOpen);
    }
    /**
     * Focuses the wrapper of the ColorPicker.
     */
    focus() {
        this.isFocused = true;
        this.host.nativeElement.focus();
    }
    /**
     * @hidden
     */
    handleWrapperFocus() {
        if (this.isFocused) {
            return;
        }
        this.ngZone.run(() => {
            this.focus();
            this.onFocus.emit();
        });
    }
    /**
     * Blurs the ColorPicker.
     */
    blur() {
        this.isFocused = false;
        this.host.nativeElement.blur();
        this.notifyNgTouched();
    }
    /**
     * @hidden
     */
    handleWrapperBlur() {
        if (this.isOpen) {
            return;
        }
        this.ngZone.run(() => {
            this.onBlur.emit();
            this.isFocused = false;
        });
    }
    /**
     * Clears the value of the ColorPicker.
     */
    reset() {
        if (!isPresent(this.value)) {
            return;
        }
        this._value = undefined;
        this.setHostElementAriaLabel();
        this.notifyNgChanged(undefined);
    }
    /**
     * Toggles the popup of the ColorPicker.
     * Does not trigger the `open` and `close` events of the component.
     *
     * @param open An optional parameter. Specifies whether the popup will be opened or closed.
     */
    toggle(open) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.cdr.markForCheck();
        this.closePopup();
        open = isPresent(open) ? open : !this.isOpen;
        if (open) {
            this.openPopup();
        }
    }
    /**
     * @hidden
     */
    handleValueChange(color) {
        const parsedColor = parseColor$1(color, this.format, this.gradientSettings.opacity);
        const valueChange = parsedColor !== this.value;
        if (valueChange) {
            this.value = parsedColor;
            this.valueChange.emit(parsedColor);
            this.setHostElementAriaLabel();
            this.notifyNgChanged(parsedColor);
        }
    }
    /**
     * @hidden
     */
    handlePopupBlur(event) {
        if (this.popupBlurInvalid(event)) {
            return;
        }
        this.isFocused = false;
        this.onBlur.emit();
        this.notifyNgTouched();
        this.toggleWithEvents(false);
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    handleWrapperKeyDown(event) {
        if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.Enter) {
            event.preventDefault();
            this.ngZone.run(() => {
                this.toggleWithEvents(true);
            });
        }
    }
    /**
     * @hidden
     */
    handlePopupKeyDown(event) {
        if (event.keyCode === Keys.Escape) {
            this.toggleWithEvents(false);
            this.host.nativeElement.focus();
        }
        if (event.keyCode === Keys.Tab) {
            const currentElement = event.shiftKey ? this.firstFocusableElement.nativeElement : this.lastFocusableElement.nativeElement;
            const nextElement = event.shiftKey ? this.lastFocusableElement.nativeElement : this.firstFocusableElement.nativeElement;
            if (event.target === currentElement) {
                event.preventDefault();
                nextElement.focus();
            }
        }
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    setHostElementAriaLabel() {
        const ariaLabelValue = `${this.value ? this.value : this.localizationService.get('colorPickerNoColor')}`;
        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', ariaLabelValue);
    }
    handleClasses(value, input) {
        const elem = this.host.nativeElement;
        const classes = getStylingClasses('picker', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
    popupBlurInvalid(ev) {
        const focusInFlatColorPickerElement = this.popupRef.popupElement.contains(ev.relatedTarget);
        const hostClicked = closest(ev.relatedTarget, (element) => element === this.host.nativeElement);
        return hostClicked || focusInFlatColorPickerElement;
    }
    toggleWithEvents(open) {
        const sameState = this.isOpen === open;
        if (this.disabled || this.readonly || sameState) {
            return;
        }
        let eventArgs;
        if (open) {
            eventArgs = new ColorPickerOpenEvent();
            this.open.emit(eventArgs);
        }
        else {
            eventArgs = new ColorPickerCloseEvent();
            this.close.emit(eventArgs);
        }
        if (!eventArgs.isDefaultPrevented()) {
            this.toggle(open);
        }
        if (open) {
            this.focusFirstElement();
        }
    }
    focusFirstElement() {
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            if (this.flatColorPicker) {
                const gradient = this.flatColorPicker.gradient;
                const elementToFocus = gradient ? gradient.gradientDragHandle :
                    this.flatColorPicker.palette.host;
                elementToFocus.nativeElement.focus();
            }
        });
    }
    openPopup() {
        const horizontalAlign = this.direction === "rtl" ? "right" : "left";
        const anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        const popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.activeColor,
            animate: this.popupSettings.animate,
            appendTo: this.popupSettings.appendTo,
            popupAlign: popupPosition,
            anchorAlign: anchorPosition,
            popupClass: 'k-colorpicker-popup',
            content: this.popupTemplate,
            positionMode: 'absolute'
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(() => {
            this.toggleWithEvents(false);
            if (!this.isOpen) {
                this.host.nativeElement.focus({
                    preventScroll: true
                });
            }
        });
    }
    closePopup() {
        if (!this.isOpen) {
            return;
        }
        this.popupRef.close();
        this.popupRef = null;
    }
    get firstFocusableElement() {
        if (!this.flatColorPicker.header || (this.views.length <= 1 && !this.flatColorPicker.clearButton)) {
            const gradient = this.flatColorPicker.gradient;
            return gradient ? gradient.gradientDragHandle : this.flatColorPicker.palette.host;
        }
        return this.views.length > 1 ? this.flatColorPicker.header.viewButtonsCollection.toArray()[0] : this.flatColorPicker.header.clearButtonElement;
    }
    get lastFocusableElement() {
        if (this.preview) {
            return this.flatColorPicker.footer.lastButton;
        }
        if (this.flatColorPicker.palette) {
            return this.flatColorPicker.palette.host;
        }
        const gradient = this.flatColorPicker.gradient;
        const inputs = gradient && gradient.inputs;
        if (gradient && inputs && inputs.formatView === 'hex') {
            return inputs.hexInput;
        }
        return this.gradientSettings.opacity ? inputs.opacityInput.numericInput : inputs.blueInput;
    }
    handleDomEvents(action, events) {
        const hostElement = this.host.nativeElement;
        events.forEach(ev => hostElement[`${action}EventListener`](ev, this.domFocusListener, true));
    }
    initDomEvents() {
        if (!this.host) {
            return;
        }
        let hostElement = this.host.nativeElement;
        this.ngZone.runOutsideAngular(() => {
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                this.handleWrapperFocus();
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (event) => {
                const closestPopup = this.popupRef ?
                    closest(event.relatedTarget, (element) => element === this.flatColorPicker.host.nativeElement) :
                    false;
                const closestWrapper = closest(event.relatedTarget, (element) => element === this.host.nativeElement);
                if (!closestPopup && !closestWrapper) {
                    this.handleWrapperBlur();
                }
            }));
            this.handleDomEvents('add', DOM_FOCUS_EVENTS);
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (event) => {
                this.handleWrapperKeyDown(event);
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'click', (event) => {
                this.ngZone.run(() => {
                    this.handleWrapperClick(event);
                });
            }));
        });
    }
    handleHostId() {
        const hostElement = this.host.nativeElement;
        const existingId = hostElement.getAttribute('id');
        if (existingId) {
            this.focusableId = existingId;
        }
        else {
            const id = `k-${guid()}`;
            hostElement.setAttribute('id', id);
            this.focusableId = id;
        }
    }
};
ColorPickerComponent.ɵfac = function ColorPickerComponent_Factory(t) { return new (t || ColorPickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ColorPickerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColorPickerComponent, selectors: [["kendo-colorpicker"]], viewQuery: function ColorPickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c114, 7, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c115, 7);
        ɵngcc0.ɵɵviewQuery(_c116, 7);
        ɵngcc0.ɵɵviewQuery(_c117, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.activeColor = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.flatColorPicker = _t.first);
    } }, hostVars: 16, hostBindings: function ColorPickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("dir", ctx.direction)("aria-disabled", ctx.disabledClass)("aria-readonly", ctx.ariaReadonly)("aria-expanded", ctx.ariaExpanded)("tabindex", ctx.hostTabindex);
        ɵngcc0.ɵɵclassProp("k-colorpicker", ctx.hostClasses)("k-icon-picker", ctx.hostClasses)("k-picker", ctx.hostClasses)("k-focus", ctx.focusedClass)("k-disabled", ctx.disabledClass);
    } }, inputs: { views: "views", readonly: "readonly", disabled: "disabled", format: "format", clearButton: "clearButton", preview: "preview", actionsLayout: "actionsLayout", view: "view", value: "value", popupSettings: "popupSettings", paletteSettings: "paletteSettings", gradientSettings: "gradientSettings", tabindex: "tabindex", size: "size", rounded: "rounded", fillMode: "fillMode", activeView: "activeView", icon: "icon", iconClass: "iconClass" }, outputs: { valueChange: "valueChange", open: "open", close: "close", onFocus: "focus", onBlur: "blur", cancel: "cancel", activeColorClick: "activeColorClick", activeViewChange: "activeViewChange" }, exportAs: ["kendoColorPicker"], features: [ɵngcc0.ɵɵProvidersFeature([{
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorPickerComponent_1)
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorPickerComponent_1)
            },
            ColorPickerLocalizationService,
            {
                provide: LocalizationService,
                useExisting: ColorPickerLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorpicker'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 12, vars: 7, consts: function () { let i18n_118; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The aria-label applied to the ColorPicker component when the value is empty.
         * @meaning kendo.colorpicker.colorPickerNoColor
         */
        const MSG_EXTERNAL_1340294849455907833$$DIST_FESM2015_INDEX_JS_119 = goog.getMsg("Colorpicker no color chosen");
        i18n_118 = MSG_EXTERNAL_1340294849455907833$$DIST_FESM2015_INDEX_JS_119;
    }
    else {
        i18n_118 = $localize `:kendo.colorpicker.colorPickerNoColor|The aria-label applied to the ColorPicker component when the value is empty.␟7c3447a392ec09d287cf7e50665618ab839ade9c␟1340294849455907833:Colorpicker no color chosen`;
    } let i18n_120; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The aria-label applied to the FlatColorPicker component when the value is empty.
         * @meaning kendo.colorpicker.flatColorPickerNoColor
         */
        const MSG_EXTERNAL_8623881855258235902$$DIST_FESM2015_INDEX_JS_121 = goog.getMsg("Flatcolorpicker no color chosen");
        i18n_120 = MSG_EXTERNAL_8623881855258235902$$DIST_FESM2015_INDEX_JS_121;
    }
    else {
        i18n_120 = $localize `:kendo.colorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty.␟61f9933a789c369354c4667e0d3a141e325ccde6␟8623881855258235902:Flatcolorpicker no color chosen`;
    } let i18n_122; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The aria-label applied to the ColorGradient component when the value is empty.
         * @meaning kendo.colorpicker.colorGradientNoColor
         */
        const MSG_EXTERNAL_6221387158064831532$$DIST_FESM2015_INDEX_JS_123 = goog.getMsg("Colorgradient no color chosen");
        i18n_122 = MSG_EXTERNAL_6221387158064831532$$DIST_FESM2015_INDEX_JS_123;
    }
    else {
        i18n_122 = $localize `:kendo.colorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.␟dbf775c5b891411f7520ad91edc53ed0f05dec7e␟6221387158064831532:Colorgradient no color chosen`;
    } let i18n_124; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The aria-label applied to the ColorPalette component when the value is empty.
         * @meaning kendo.colorpicker.colorPaletteNoColor
         */
        const MSG_EXTERNAL_5352972813211368132$$DIST_FESM2015_INDEX_JS_125 = goog.getMsg("Colorpalette no color chosen");
        i18n_124 = MSG_EXTERNAL_5352972813211368132$$DIST_FESM2015_INDEX_JS_125;
    }
    else {
        i18n_124 = $localize `:kendo.colorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.␟9270d89615ca09f37e9df55453be6d7e24e5eb09␟5352972813211368132:Colorpalette no color chosen`;
    } let i18n_126; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the gradient color drag handle chooser.
         * @meaning kendo.colorpicker.colorGradientHandle
         */
        const MSG_EXTERNAL_8067778471922495440$$DIST_FESM2015_INDEX_JS_127 = goog.getMsg("Choose color");
        i18n_126 = MSG_EXTERNAL_8067778471922495440$$DIST_FESM2015_INDEX_JS_127;
    }
    else {
        i18n_126 = $localize `:kendo.colorpicker.colorGradientHandle|The title for the gradient color drag handle chooser.␟8d537502a437254763c963398484bd362820af61␟8067778471922495440:Choose color`;
    } let i18n_128; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the clear button.
         * @meaning kendo.colorpicker.clearButton
         */
        const MSG_EXTERNAL_935472034136733879$$DIST_FESM2015_INDEX_JS_129 = goog.getMsg("Clear value");
        i18n_128 = MSG_EXTERNAL_935472034136733879$$DIST_FESM2015_INDEX_JS_129;
    }
    else {
        i18n_128 = $localize `:kendo.colorpicker.clearButton|The title for the clear button.␟aae9caf1dbc689cd51ace5c265cbf45552a580b6␟935472034136733879:Clear value`;
    } let i18n_130; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the hue slider handle.
         * @meaning kendo.colorpicker.hueSliderHandle
         */
        const MSG_EXTERNAL_1739045502529621844$$DIST_FESM2015_INDEX_JS_131 = goog.getMsg("Set hue");
        i18n_130 = MSG_EXTERNAL_1739045502529621844$$DIST_FESM2015_INDEX_JS_131;
    }
    else {
        i18n_130 = $localize `:kendo.colorpicker.hueSliderHandle|The title for the hue slider handle.␟7af8ad339d09d41bfa8fa5f4e44d16e326cafd54␟1739045502529621844:Set hue`;
    } let i18n_132; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title for the opacity slider handle.
         * @meaning kendo.colorpicker.opacitySliderHandle
         */
        const MSG_EXTERNAL_1818720388700598438$$DIST_FESM2015_INDEX_JS_133 = goog.getMsg("Set opacity");
        i18n_132 = MSG_EXTERNAL_1818720388700598438$$DIST_FESM2015_INDEX_JS_133;
    }
    else {
        i18n_132 = $localize `:kendo.colorpicker.opacitySliderHandle|The title for the opacity slider handle.␟21883ee2927bd4cde8071c9cbec41901a0bc4bd2␟1818720388700598438:Set opacity`;
    } let i18n_134; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The contrast ratio message for the contrast tool.
         * @meaning kendo.colorpicker.contrastRatio
         */
        const MSG_EXTERNAL_8969373292032928669$$DIST_FESM2015_INDEX_JS_135 = goog.getMsg("Contrast ratio");
        i18n_134 = MSG_EXTERNAL_8969373292032928669$$DIST_FESM2015_INDEX_JS_135;
    }
    else {
        i18n_134 = $localize `:kendo.colorpicker.contrastRatio|The contrast ratio message for the contrast tool.␟027baefc2ecbe8b12eda4768cd8f3c9ff30959bb␟8969373292032928669:Contrast ratio`;
    } let i18n_136; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the color preview pane.
         * @meaning kendo.colorpicker.previewColor
         */
        const MSG_EXTERNAL_8406287813424834207$$DIST_FESM2015_INDEX_JS_137 = goog.getMsg("Color preview");
        i18n_136 = MSG_EXTERNAL_8406287813424834207$$DIST_FESM2015_INDEX_JS_137;
    }
    else {
        i18n_136 = $localize `:kendo.colorpicker.previewColor|The message for the color preview pane.␟ff9d86ffb5fb4883b2eafcc7b0265750010e6a89␟8406287813424834207:Color preview`;
    } let i18n_138; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the selected color pane.
         * @meaning kendo.colorpicker.revertSelection
         */
        const MSG_EXTERNAL_1125923622405755722$$DIST_FESM2015_INDEX_JS_139 = goog.getMsg("Revert selection");
        i18n_138 = MSG_EXTERNAL_1125923622405755722$$DIST_FESM2015_INDEX_JS_139;
    }
    else {
        i18n_138 = $localize `:kendo.colorpicker.revertSelection|The message for the selected color pane.␟01f55ab6fd7df0660ed6d63d931a1a1d00e49462␟1125923622405755722:Revert selection`;
    } let i18n_140; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the gradient view button.
         * @meaning kendo.colorpicker.gradientView
         */
        const MSG_EXTERNAL_1444507009750003894$$DIST_FESM2015_INDEX_JS_141 = goog.getMsg("Gradient view");
        i18n_140 = MSG_EXTERNAL_1444507009750003894$$DIST_FESM2015_INDEX_JS_141;
    }
    else {
        i18n_140 = $localize `:kendo.colorpicker.gradientView|The message for the gradient view button.␟2cc4cf38fc047a802f03c26ad6fef9f4c91f5214␟1444507009750003894:Gradient view`;
    } let i18n_142; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the palette view button.
         * @meaning kendo.colorpicker.paletteView
         */
        const MSG_EXTERNAL_8652010593499539657$$DIST_FESM2015_INDEX_JS_143 = goog.getMsg("Palette view");
        i18n_142 = MSG_EXTERNAL_8652010593499539657$$DIST_FESM2015_INDEX_JS_143;
    }
    else {
        i18n_142 = $localize `:kendo.colorpicker.paletteView|The message for the palette view button.␟eb619ae6d7ce5082cc8e5c691d58af34e6fe94b2␟8652010593499539657:Palette view`;
    } let i18n_144; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the input format toggle button.
         * @meaning kendo.colorpicker.formatButton
         */
        const MSG_EXTERNAL_881261150447277777$$DIST_FESM2015_INDEX_JS_145 = goog.getMsg("Change color format");
        i18n_144 = MSG_EXTERNAL_881261150447277777$$DIST_FESM2015_INDEX_JS_145;
    }
    else {
        i18n_144 = $localize `:kendo.colorpicker.formatButton|The message for the input format toggle button.␟1fe33e253e9f8b4f78c55c986162f362885dc943␟881261150447277777:Change color format`;
    } let i18n_146; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the Apply action button.
         * @meaning kendo.colorpicker.applyButton
         */
        const MSG_EXTERNAL_4840607412933012087$$DIST_FESM2015_INDEX_JS_147 = goog.getMsg("Apply");
        i18n_146 = MSG_EXTERNAL_4840607412933012087$$DIST_FESM2015_INDEX_JS_147;
    }
    else {
        i18n_146 = $localize `:kendo.colorpicker.applyButton|The message for the Apply action button.␟3940d0414a97268cc9b6ee8d16f71911303fc0ab␟4840607412933012087:Apply`;
    } let i18n_148; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The message for the Cancel action button.
         * @meaning kendo.colorpicker.cancelButton
         */
        const MSG_EXTERNAL_7096794076383355871$$DIST_FESM2015_INDEX_JS_149 = goog.getMsg("Cancel");
        i18n_148 = MSG_EXTERNAL_7096794076383355871$$DIST_FESM2015_INDEX_JS_149;
    }
    else {
        i18n_148 = $localize `:kendo.colorpicker.cancelButton|The message for the Cancel action button.␟4e24d8f47748af7f728320c85d0585548987adfb␟7096794076383355871:Cancel`;
    } return [["kendoColorPickerLocalizedMessages", "", "colorPickerNoColor", i18n_118, "flatColorPickerNoColor", i18n_120, "colorGradientNoColor", i18n_122, "colorPaletteNoColor", i18n_124, "colorGradientHandle", i18n_126, "clearButton", i18n_128, "hueSliderHandle", i18n_130, "opacitySliderHandle", i18n_132, "contrastRatio", i18n_134, "previewColor", i18n_136, "revertSelection", i18n_138, "gradientView", i18n_140, "paletteView", i18n_142, "formatButton", i18n_144, "applyButton", i18n_146, "cancelButton", i18n_148], [1, "k-input-inner"], ["activeColor", ""], [1, "k-value-icon", "k-color-preview", 3, "ngClass"], ["class", "k-color-preview-icon k-icon", 3, "ngClass", 4, "ngIf"], [1, "k-color-preview-mask"], ["tabindex", "-1", "type", "button", 1, "k-input-button", "k-button", "k-button-md", "k-button-solid", "k-button-solid-base", "k-icon-button"], [1, "k-button-icon", "k-icon", "k-i-arrow-s"], ["popupTemplate", ""], ["container", ""], [1, "k-color-preview-icon", "k-icon", 3, "ngClass"], [3, "value", "format", "views", "activeView", "actionsLayout", "preview", "gradientSettings", "paletteSettings", "clearButton", "cancel", "focusout", "valueChange", "keydown", "activeViewChange", "actionButtonClick"], ["flatColorPicker", ""]]; }, template: function ColorPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1, 2)(3, "span", 3);
        ɵngcc0.ɵɵtemplate(4, ColorPickerComponent_span_4_Template, 1, 1, "span", 4);
        ɵngcc0.ɵɵelement(5, "span", 5);
        ɵngcc0.ɵɵelementEnd()();
        ɵngcc0.ɵɵelementStart(6, "button", 6);
        ɵngcc0.ɵɵelement(7, "span", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, ColorPickerComponent_ng_template_8_Template, 2, 9, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementContainer(10, null, 9);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(4, _c150, ctx.iconStyles, !ctx.value));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconClass || ctx.icon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("background-color", ctx.value);
    } }, directives: function () { return [LocalizedColorPickerMessagesDirective, ɵngcc3.NgClass, ɵngcc3.NgIf, FlatColorPickerComponent]; }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-colorpicker'),
    HostBinding('class.k-icon-picker'),
    HostBinding('class.k-picker'),
    __metadata("design:type", Boolean)
], ColorPickerComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.k-focus'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorPickerComponent.prototype, "focusedClass", null);
__decorate([
    HostBinding('attr.aria-disabled'),
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorPickerComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('attr.aria-readonly'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorPickerComponent.prototype, "ariaReadonly", null);
__decorate([
    HostBinding('attr.aria-expanded'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorPickerComponent.prototype, "ariaExpanded", null);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], ColorPickerComponent.prototype, "hostTabindex", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], ColorPickerComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String)
], ColorPickerComponent.prototype, "role", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ColorPickerComponent.prototype, "views", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorPickerComponent.prototype, "view", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorPickerComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorPickerComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorPickerComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ColorPickerComponent.prototype, "popupSettings", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ColorPickerComponent.prototype, "paletteSettings", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ColorPickerComponent.prototype, "gradientSettings", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerComponent.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColorPickerComponent.prototype, "iconClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorPickerComponent.prototype, "clearButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], ColorPickerComponent.prototype, "tabindex", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorPickerComponent.prototype, "preview", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerComponent.prototype, "actionsLayout", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorPickerComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorPickerComponent.prototype, "rounded", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorPickerComponent.prototype, "fillMode", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "close", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "cancel", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "activeColorClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "activeViewChange", void 0);
__decorate([
    ViewChild('container', { read: ViewContainerRef, static: true }),
    __metadata("design:type", ViewContainerRef)
], ColorPickerComponent.prototype, "container", void 0);
__decorate([
    ViewChild('activeColor', { static: true }),
    __metadata("design:type", ElementRef)
], ColorPickerComponent.prototype, "activeColor", void 0);
__decorate([
    ViewChild('popupTemplate', { static: true }),
    __metadata("design:type", TemplateRef)
], ColorPickerComponent.prototype, "popupTemplate", void 0);
__decorate([
    ViewChild('flatColorPicker', { static: false }),
    __metadata("design:type", FlatColorPickerComponent)
], ColorPickerComponent.prototype, "flatColorPicker", void 0);
ColorPickerComponent = ColorPickerComponent_1 = __decorate([ __metadata("design:paramtypes", [ElementRef,
        PopupService,
        ChangeDetectorRef,
        LocalizationService,
        NgZone,
        Renderer2])
], ColorPickerComponent);

/**
 * @hidden
 */
class ColorPickerMessages extends ComponentMessages {
}
ColorPickerMessages.ɵfac = /*@__PURE__*/ function () { let ɵColorPickerMessages_BaseFactory; return function ColorPickerMessages_Factory(t) { return (ɵColorPickerMessages_BaseFactory || (ɵColorPickerMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(ColorPickerMessages)))(t || ColorPickerMessages); }; }();
ColorPickerMessages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ColorPickerMessages, inputs: { colorPaletteNoColor: "colorPaletteNoColor", colorGradientNoColor: "colorGradientNoColor", flatColorPickerNoColor: "flatColorPickerNoColor", colorPickerNoColor: "colorPickerNoColor", colorGradientHandle: "colorGradientHandle", clearButton: "clearButton", hueSliderHandle: "hueSliderHandle", opacitySliderHandle: "opacitySliderHandle", hexInputPlaceholder: "hexInputPlaceholder", redInputPlaceholder: "redInputPlaceholder", greenInputPlaceholder: "greenInputPlaceholder", blueInputPlaceholder: "blueInputPlaceholder", alphaInputPlaceholder: "alphaInputPlaceholder", passContrast: "passContrast", failContrast: "failContrast", contrastRatio: "contrastRatio", previewColor: "previewColor", revertSelection: "revertSelection", gradientView: "gradientView", paletteView: "paletteView", formatButton: "formatButton", applyButton: "applyButton", cancelButton: "cancelButton" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "colorPaletteNoColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "colorGradientNoColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "flatColorPickerNoColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "colorPickerNoColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "colorGradientHandle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "clearButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "hueSliderHandle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "opacitySliderHandle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "hexInputPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "redInputPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "greenInputPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "blueInputPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "alphaInputPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "passContrast", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "failContrast", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "contrastRatio", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "previewColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "revertSelection", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "gradientView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "paletteView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "formatButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "applyButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "cancelButton", void 0);

var ColorPickerCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let ColorPickerCustomMessagesComponent = ColorPickerCustomMessagesComponent_1 = class ColorPickerCustomMessagesComponent extends ColorPickerMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
ColorPickerCustomMessagesComponent.ɵfac = function ColorPickerCustomMessagesComponent_Factory(t) { return new (t || ColorPickerCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
ColorPickerCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColorPickerCustomMessagesComponent, selectors: [["kendo-colorpicker-messages"], ["kendo-flatcolorpicker-messages"], ["kendo-colorgradient-messages"], ["kendo-colorpalette-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColorPickerMessages,
                useExisting: forwardRef(() => ColorPickerCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColorPickerCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
ColorPickerCustomMessagesComponent = ColorPickerCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], ColorPickerCustomMessagesComponent);

var LocalizedColorPickerMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedColorPickerMessagesDirective = LocalizedColorPickerMessagesDirective_1 = class LocalizedColorPickerMessagesDirective extends ColorPickerMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
LocalizedColorPickerMessagesDirective.ɵfac = function LocalizedColorPickerMessagesDirective_Factory(t) { return new (t || LocalizedColorPickerMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedColorPickerMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LocalizedColorPickerMessagesDirective, selectors: [["", "kendoColorPickerLocalizedMessages", ""], ["", "kendoFlatColorPickerLocalizedMessages", ""], ["", "kendoColorGradientLocalizedMessages", ""], ["", "kendoColorPaletteLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColorPickerMessages,
                useExisting: forwardRef(() => LocalizedColorPickerMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
LocalizedColorPickerMessagesDirective = LocalizedColorPickerMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LocalizedColorPickerMessagesDirective);

/**
 * @hidden
 */
let FocusOnDomReadyDirective = class FocusOnDomReadyDirective {
    constructor(host, ngZone) {
        this.host = host;
        this.ngZone = ngZone;
    }
    ngAfterContentInit() {
        this.focusOnNextTick();
    }
    focusOnNextTick() {
        this.ngZone.runOutsideAngular(() => setTimeout(() => this.host.nativeElement.focus()));
    }
};
FocusOnDomReadyDirective.ɵfac = function FocusOnDomReadyDirective_Factory(t) { return new (t || FocusOnDomReadyDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
FocusOnDomReadyDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FocusOnDomReadyDirective, selectors: [["", "kendoFocusOnDomReady", ""]] });
FocusOnDomReadyDirective = __decorate([ __metadata("design:paramtypes", [ElementRef,
        NgZone])
], FocusOnDomReadyDirective);

/**
 * @hidden
 */
let ContrastValidationComponent = class ContrastValidationComponent {
    constructor(localization) {
        this.localization = localization;
    }
    get passMessage() {
        return this.localization.get('passContrast');
    }
    get failMessage() {
        return this.localization.get('failContrast');
    }
    get contrastText() {
        let ratio = this.type === 'AA' ? AA_RATIO : AAA_RATIO;
        return `${this.type}: ${ratio.toFixed(1)}`;
    }
};
ContrastValidationComponent.ɵfac = function ContrastValidationComponent_Factory(t) { return new (t || ContrastValidationComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
ContrastValidationComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ContrastValidationComponent, selectors: [["", "kendoContrastValidation", ""]], inputs: { type: "type", pass: "pass", value: "value" }, attrs: _c151, decls: 3, vars: 2, consts: [[4, "ngIf"], ["class", "k-contrast-validation k-text-success", 4, "ngIf"], ["class", "k-contrast-validation k-text-error", 4, "ngIf"], [1, "k-contrast-validation", "k-text-success"], [1, "k-icon", "k-i-check"], [1, "k-contrast-validation", "k-text-error"], [1, "k-icon", "k-i-close"]], template: function ContrastValidationComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, ContrastValidationComponent_ng_container_2_Template, 3, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.contrastText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.value);
    } }, directives: [ɵngcc3.NgIf], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], ContrastValidationComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ContrastValidationComponent.prototype, "pass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ContrastValidationComponent.prototype, "value", void 0);
ContrastValidationComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], ContrastValidationComponent);

/**
 * @hidden
 */
let ContrastComponent = class ContrastComponent {
    constructor(localization) {
        this.localization = localization;
    }
    get formatedRatio() {
        return this.contrastRatio.toFixed(2);
    }
    get contrastRatioText() {
        return `${this.localization.get('contrastRatio')}: ${this.value ? this.formatedRatio : 'n/a'}`;
    }
    get satisfiesAACondition() {
        return this.contrastRatio >= AA_RATIO;
    }
    get satisfiesAAACondition() {
        return this.contrastRatio >= AAA_RATIO;
    }
    get contrastRatio() {
        let contrast = getContrastFromTwoRGBAs(getRGBA(this.value), getRGBA(this.ratio));
        return contrast;
    }
};
ContrastComponent.ɵfac = function ContrastComponent_Factory(t) { return new (t || ContrastComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
ContrastComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ContrastComponent, selectors: [["", "kendoContrastTool", ""]], inputs: { value: "value", ratio: "ratio" }, attrs: _c152, decls: 6, vars: 6, consts: [[1, "k-contrast-ratio"], [1, "k-contrast-ratio-text"], [4, "ngIf"], ["kendoContrastValidation", "", "type", "AA", 3, "value", "pass"], ["kendoContrastValidation", "", "type", "AAA", 3, "value", "pass"], ["class", "k-contrast-validation k-text-success", 4, "ngIf"], ["class", "k-contrast-validation k-text-error", 4, "ngIf"], [1, "k-contrast-validation", "k-text-success"], [1, "k-icon", "k-i-check"], ["class", "k-icon k-i-check", 4, "ngIf"], [1, "k-contrast-validation", "k-text-error"], [1, "k-icon", "k-i-close"]], template: function ContrastComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0)(1, "span", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ContrastComponent_ng_container_3_Template, 3, 2, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "div", 3)(5, "div", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.contrastRatioText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.value);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("value", ctx.value)("pass", ctx.satisfiesAACondition);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("value", ctx.value)("pass", ctx.satisfiesAAACondition);
    } }, directives: [ɵngcc3.NgIf, ContrastValidationComponent], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], ContrastComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ContrastComponent.prototype, "ratio", void 0);
ContrastComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], ContrastComponent);

/**
 * @hidden
 */
let ColorContrastSvgComponent = class ColorContrastSvgComponent {
    /**
     * @hidden
     */
    constructor() {
        this.hostClass = true;
    }
    ngAfterViewInit() {
        this.metrics = this.wrapper.getBoundingClientRect();
        this.oldA = this.hsva.value.a;
        this.oldH = this.hsva.value.h;
        this.hsva.subscribe((value) => {
            if (value.h !== this.oldH || value.a !== this.oldA) {
                this.oldH = value.h;
                this.oldA = value.a;
                this.setPaths();
            }
        });
    }
    ngOnChanges(changes) {
        if (isPresent(changes.backgroundColor) && this.metrics) {
            this.setPaths();
        }
    }
    setPaths() {
        const bezierCommandCalc = bezierCommand(controlPoint(line));
        this.paths = [svgPath(this.getPaths(AA_RATIO, STEP_COUNT), bezierCommandCalc),
            svgPath(this.getPaths(AA_RATIO, STEP_COUNT, true), bezierCommandCalc),
            svgPath(this.getPaths(AAA_RATIO, STEP_COUNT), bezierCommandCalc),
            svgPath(this.getPaths(AAA_RATIO, STEP_COUNT, true), bezierCommandCalc)];
    }
    findValue(contrast, saturation, low, high, comparer) {
        const mid = (low + high) / 2;
        const hsva = Object.assign({}, this.hsva.value, { s: saturation / this.metrics.width, v: 1 - mid / this.metrics.height });
        const currentContrast = getContrastFromTwoRGBAs(getRGBA(getColorFromHSV(hsva)), getRGBA(this.backgroundColor || ''));
        if (low + 0.5 > high) {
            if (currentContrast < contrast + 1 && currentContrast > contrast - 1) {
                return mid;
            }
            else {
                return null;
            }
        }
        if (comparer(currentContrast, contrast)) {
            return this.findValue(contrast, saturation, low, high - (high - low) / 2, comparer);
        }
        return this.findValue(contrast, saturation, low + (high - low) / 2, high, comparer);
    }
    getPaths(contrast, stepCount, reversed = false) {
        const points = [];
        for (let i = 0; i <= this.metrics.width; i += this.metrics.width / stepCount) {
            const value = this.findValue(contrast, i, 0, this.metrics.height, reversed ? ((a, b) => a < b) : ((a, b) => a > b));
            if (value !== null) {
                points.push([i, value]);
            }
        }
        return points;
    }
};
ColorContrastSvgComponent.ɵfac = function ColorContrastSvgComponent_Factory(t) { return new (t || ColorContrastSvgComponent)(); };
ColorContrastSvgComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColorContrastSvgComponent, selectors: [["", "kendoColorContrastSvg", ""]], hostVars: 2, hostBindings: function ColorContrastSvgComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-color-contrast-svg", ctx.hostClass);
    } }, inputs: { wrapper: "wrapper", hsva: "hsva", backgroundColor: "backgroundColor" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c153, decls: 1, vars: 1, consts: [["fill", "none", "stroke", "white", "stroke-width", "1", 4, "ngFor", "ngForOf"], ["fill", "none", "stroke", "white", "stroke-width", "1"]], template: function ColorContrastSvgComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ColorContrastSvgComponent__svg_path_0_Template, 1, 1, "path", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.paths);
    } }, directives: [ɵngcc3.NgForOf], encapsulation: 2 });
__decorate([
    HostBinding('class.k-color-contrast-svg'),
    __metadata("design:type", Boolean)
], ColorContrastSvgComponent.prototype, "hostClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColorContrastSvgComponent.prototype, "wrapper", void 0);
__decorate([
    Input(),
    __metadata("design:type", BehaviorSubject)
], ColorContrastSvgComponent.prototype, "hsva", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorContrastSvgComponent.prototype, "backgroundColor", void 0);

const PUBLIC_DIRECTIVES = [
    ColorPickerComponent,
    ColorPaletteComponent,
    ColorGradientComponent,
    FlatColorPickerComponent,
    LocalizedColorPickerMessagesDirective,
    ColorPickerCustomMessagesComponent
];
const INTERNAL_DIRECTIVES = [
    ColorInputComponent,
    FocusOnDomReadyDirective,
    ContrastComponent,
    ContrastValidationComponent,
    FlatColorPickerHeaderComponent,
    FlatColorPickerActionButtonsComponent,
    ColorContrastSvgComponent
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the ColorPicker.
 */
let ColorPickerModule = class ColorPickerModule {
};
ColorPickerModule.ɵfac = function ColorPickerModule_Factory(t) { return new (t || ColorPickerModule)(); };
ColorPickerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ColorPickerModule });
ColorPickerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            SliderModule,
            NumericTextBoxModule,
            CommonModule,
            PopupModule,
            DraggableModule
        ]] });

/**
 * Represents the directive that renders the [Kendo UI CheckBox]({% slug overview_checkbox %}) input component.
 * The directive is placed on input type="checkbox" elements.
 *
 * @example
 * ```ts-no-run
 * <input type="checkbox" kendoCheckBox />
 * ```
 */
let CheckBoxDirective = class CheckBoxDirective {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.kendoClass = true;
        this._size = 'medium';
        this._rounded = 'medium';
    }
    /**
     * The size property specifies the width and height of the CheckBox
     * ([see example]({% slug appearance_checkboxdirective %}#toc-size)).
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set size(size) {
        this.handleClasses(size, 'size');
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * The rounded property specifies the border radius of the CheckBox
     * ([see example]({% slug appearance_checkboxdirective %}#toc-rounded)).
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set rounded(rounded) {
        this.handleClasses(rounded, 'rounded');
        this._rounded = rounded;
    }
    get rounded() {
        return this._rounded;
    }
    ngAfterViewInit() {
        const stylingInputs = ['size', 'rounded'];
        stylingInputs.forEach(input => {
            this.handleClasses(this[input], input);
        });
    }
    handleClasses(value, input) {
        const elem = this.hostElement.nativeElement;
        const classes = getStylingClasses('checkbox', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
};
CheckBoxDirective.ɵfac = function CheckBoxDirective_Factory(t) { return new (t || CheckBoxDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
CheckBoxDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CheckBoxDirective, selectors: [["input", "kendoCheckBox", ""]], hostVars: 2, hostBindings: function CheckBoxDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-checkbox", ctx.kendoClass);
    } }, inputs: { size: "size", rounded: "rounded" } });
__decorate([
    HostBinding('class.k-checkbox'),
    __metadata("design:type", Boolean)
], CheckBoxDirective.prototype, "kendoClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], CheckBoxDirective.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], CheckBoxDirective.prototype, "rounded", null);
CheckBoxDirective = __decorate([ __metadata("design:paramtypes", [Renderer2,
        ElementRef])
], CheckBoxDirective);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the CheckBox directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the CheckBox module
 * import { CheckBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, CheckBoxModule], // import CheckBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let CheckBoxModule = class CheckBoxModule {
};
CheckBoxModule.ɵfac = function CheckBoxModule_Factory(t) { return new (t || CheckBoxModule)(); };
CheckBoxModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CheckBoxModule });
CheckBoxModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

/**
 * Represents the directive that renders the [Kendo UI RadioButton]({% slug overview_checkbox %}) input component.
 * The directive is placed on input type="radio" elements.
 *
 * @example
 * ```ts-no-run
 * <input type="radio" kendoRadioButton />
 * ```
 */
let RadioButtonDirective = class RadioButtonDirective {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.kendoClass = true;
        this._size = 'medium';
        validatePackage(packageMetadata);
    }
    /**
     * The size property specifies the width and height of the RadioButton
     * ([see example]({% slug appearance_radiobuttondirective %}#toc-size)).
     * The possible values are:
     * * `'small'`
     * * `'medium'` (default)
     * * `'large'`
     * * `null`
     */
    set size(size) {
        this.handleClasses(size, 'size');
        this._size = size;
    }
    get size() {
        return this._size;
    }
    ngAfterViewInit() {
        // kept in sync with other inputs for easier refactoring
        // to a common base class
        const stylingInputs = ['size'];
        stylingInputs.forEach(input => {
            this.handleClasses(this[input], input);
        });
    }
    handleClasses(value, input) {
        const elem = this.hostElement.nativeElement;
        const classes = getStylingClasses('radio', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
};
RadioButtonDirective.ɵfac = function RadioButtonDirective_Factory(t) { return new (t || RadioButtonDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
RadioButtonDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: RadioButtonDirective, selectors: [["input", "kendoRadioButton", ""]], hostVars: 2, hostBindings: function RadioButtonDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-radio", ctx.kendoClass);
    } }, inputs: { size: "size" } });
__decorate([
    HostBinding('class.k-radio'),
    __metadata("design:type", Boolean)
], RadioButtonDirective.prototype, "kendoClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RadioButtonDirective.prototype, "size", null);
RadioButtonDirective = __decorate([ __metadata("design:paramtypes", [Renderer2, ElementRef])
], RadioButtonDirective);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the RadioButton directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the RadioButton module
 * import { RadioButtonModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, RadioButtonModule], // import RadioButton module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let RadioButtonModule = class RadioButtonModule {
};
RadioButtonModule.ɵfac = function RadioButtonModule_Factory(t) { return new (t || RadioButtonModule)(); };
RadioButtonModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: RadioButtonModule });
RadioButtonModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

let serial$2 = 0;
/**
 * Represents an error message that will be shown underneath
 * a Kendo control or native HTML form-bound component after a validation.
 */
let ErrorComponent = class ErrorComponent {
    /**
     * Represents an error message that will be shown underneath
     * a Kendo control or native HTML form-bound component after a validation.
     */
    constructor() {
        this.hostClass = true;
        /**
         * Specifies the alignment of the Error message.
         *
         * The possible values are:
         * * (Default) `start`
         * * `end`
         */
        this.align = 'start';
        /**
         * @hidden
         */
        this.id = `kendo-error-${serial$2++}`;
        this.roleAttribute = 'alert';
    }
    get startClass() {
        return this.align === 'start';
    }
    get endClass() {
        return this.align === 'end';
    }
    get idAttribute() {
        return this.id;
    }
};
ErrorComponent.ɵfac = function ErrorComponent_Factory(t) { return new (t || ErrorComponent)(); };
ErrorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ErrorComponent, selectors: [["kendo-formerror"]], hostVars: 8, hostBindings: function ErrorComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.roleAttribute)("id", ctx.idAttribute);
        ɵngcc0.ɵɵclassProp("k-form-error", ctx.hostClass)("k-text-start", ctx.startClass)("k-text-end", ctx.endClass);
    } }, inputs: { align: "align" }, ngContentSelectors: _c43, decls: 1, vars: 0, template: function ErrorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.k-form-error'),
    __metadata("design:type", Boolean)
], ErrorComponent.prototype, "hostClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ErrorComponent.prototype, "align", void 0);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String)
], ErrorComponent.prototype, "roleAttribute", void 0);
__decorate([
    HostBinding('class.k-text-start'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ErrorComponent.prototype, "startClass", null);
__decorate([
    HostBinding('class.k-text-end'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ErrorComponent.prototype, "endClass", null);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ErrorComponent.prototype, "idAttribute", null);

let serial$3 = 0;
/**
 * Represents a hint message that will be shown underneath a form-bound component.
 */
let HintComponent = class HintComponent {
    /**
     * Represents a hint message that will be shown underneath a form-bound component.
     */
    constructor() {
        /**
         * Specifies the alignment of the Hint message.
         *
         * The possible values are:
         * * (Default) `start`
         * * `end`
         */
        this.align = 'start';
        /**
         * @hidden
         */
        this.id = `kendo-hint-${serial$3++}`;
        this.hostClass = true;
    }
    get startClass() {
        return this.align === 'start';
    }
    get endClass() {
        return this.align === 'end';
    }
    get idAttribute() {
        return this.id;
    }
};
HintComponent.ɵfac = function HintComponent_Factory(t) { return new (t || HintComponent)(); };
HintComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: HintComponent, selectors: [["kendo-formhint"]], hostVars: 7, hostBindings: function HintComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.idAttribute);
        ɵngcc0.ɵɵclassProp("k-form-hint", ctx.hostClass)("k-text-start", ctx.startClass)("k-text-end", ctx.endClass);
    } }, inputs: { align: "align" }, ngContentSelectors: _c43, decls: 1, vars: 0, template: function HintComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], HintComponent.prototype, "align", void 0);
__decorate([
    HostBinding('class.k-form-hint'),
    __metadata("design:type", Boolean)
], HintComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('class.k-text-start'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], HintComponent.prototype, "startClass", null);
__decorate([
    HostBinding('class.k-text-end'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], HintComponent.prototype, "endClass", null);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], HintComponent.prototype, "idAttribute", null);

/**
 * Specifies a container for form-bound controls (Kendo controls or native HTML controls).
 * Applies styling and behavior rules.
 */
let FormFieldComponent = class FormFieldComponent {
    constructor(renderer, localizationService, hostElement) {
        this.renderer = renderer;
        this.localizationService = localizationService;
        this.hostElement = hostElement;
        this.hostClass = true;
        /**
         *
         * Specifies when the Hint messages will be shown.
         *
         * The possible values are:
         *
         * * (Default) `initial`&mdash;Allows displaying hints when the form-bound component state is
         * `valid` or `untouched` and `pristine`.
         * * `always`&mdash;Allows full control over the visibility of the hints.
         *
         */
        this.showHints = 'initial';
        /**
         * Specifies the layout orientation of the form field.
         *
         * * The possible values are:
         *
         * * (Default) `vertical`
         * * `horizontal`
         */
        this.orientation = 'vertical';
        /**
         * Specifies when the Error messages will be shown.
         *
         * The possible values are:
         *
         * * (Default) `initial`&mdash;Allows displaying errors when the form-bound component state is
         * `invalid` and `touched` or `dirty`.
         * * `always`&mdash;Allows full control over the visibility of the errors.
         *
         */
        this.showErrors = 'initial';
        this.subscriptions = new Subscription();
        this.rtl = false;
        validatePackage(packageMetadata);
        this.subscriptions.add(this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        }));
    }
    get errorClass() {
        if (!this.control) {
            return false;
        }
        return this.control.invalid && (this.control.touched || this.control.dirty);
    }
    get disabledClass() {
        if (!this.control) {
            return false;
        }
        // radiobutton group
        if (this.isRadioControl(this.control)) {
            return false;
        }
        return this.disabledControl() ||
            this.disabledElement() ||
            this.disabledKendoInput();
    }
    set formControls(formControls) {
        this.validateFormControl(formControls);
        this.control = formControls.first;
    }
    /**
     * @hidden
     */
    get horizontal() {
        return this.orientation === 'horizontal';
    }
    /**
     * @hidden
     */
    get hasHints() {
        return this.showHints === 'always' ? true : this.showHintsInitial();
    }
    /**
     * @hidden
     */
    get hasErrors() {
        return this.showErrors === 'always' ? true : this.showErrorsInitial();
    }
    ngAfterViewInit() {
        this.setDescription();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    disabledKendoInput() {
        return this.kendoInput && this.kendoInput.disabled;
    }
    disabledControl() {
        return this.control.disabled;
    }
    disabledElement() {
        const elements = this.controlElementRefs.toArray();
        return elements.every(e => e.nativeElement.hasAttribute('disabled'));
    }
    validateFormControl(formControls) {
        if (isDevMode() && formControls.length !== 1 && !this.isControlGroup(formControls)) {
            throw new Error('The `kendo-formfield` component should contain ' +
                'only one control of type NgControl with a formControlName(https://angular.io/api/forms/FormControlName)' +
                'or an ngModel(https://angular.io/api/forms/NgModel) binding.');
        }
    }
    isControlGroup(formControls) {
        if (!formControls.length) {
            return false;
        }
        const name = formControls.first.name;
        return formControls.toArray().every(c => c.name === name && (this.isRadioControl(c)));
    }
    isRadioControl(control) {
        return control.valueAccessor instanceof RadioControlValueAccessor;
    }
    updateDescription() {
        const controls = this.findControlElements();
        if (!controls) {
            return;
        }
        controls.forEach((control) => {
            if (this.errorChildren.length > 0 || this.hintChildren.length > 0) {
                const ariaIds = this.generateDescriptionIds(control);
                this.renderer.setAttribute(control, 'aria-describedby', ariaIds);
            }
        });
    }
    findControlElements() {
        if (!this.controlElementRefs) {
            return;
        }
        // if the control is KendoInput and has focusableId - dropdowns, dateinputs
        if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {
            return [this.hostElement.nativeElement.querySelector(`#${this.kendoInput.focusableId}`)];
        }
        return this.controlElementRefs.map(el => el.nativeElement);
    }
    generateDescriptionIds(control) {
        const ids = new Set();
        if (control.hasAttribute('aria-describedby')) {
            const attributes = control.getAttribute('aria-describedby').split(' ');
            attributes.forEach((attr) => {
                if (attr.includes('kendo-hint-') || attr.includes('kendo-error-')) {
                    return;
                }
                ids.add(attr);
            });
        }
        this.hintChildren.forEach((hint) => {
            ids.add(hint.id);
        });
        this.errorChildren.forEach((error) => {
            ids.add(error.id);
        });
        return Array.from(ids).join(' ');
    }
    showHintsInitial() {
        if (!this.control) {
            return true;
        }
        const { valid, untouched, pristine } = this.control;
        return valid || (untouched && pristine);
    }
    showErrorsInitial() {
        if (!this.control) {
            return false;
        }
        const { invalid, dirty, touched } = this.control;
        return invalid && (dirty || touched);
    }
    setDescription() {
        this.updateDescription();
        this.subscriptions.add(this.errorChildren.changes.subscribe(() => this.updateDescription()));
        this.subscriptions.add(this.hintChildren.changes.subscribe(() => this.updateDescription()));
    }
};
FormFieldComponent.ɵfac = function FormFieldComponent_Factory(t) { return new (t || FormFieldComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FormFieldComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FormFieldComponent, selectors: [["kendo-formfield"]], contentQueries: function FormFieldComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, KendoInput, 7);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgControl, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgControl, 5, ElementRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ErrorComponent, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HintComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.formControls = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.controlElementRefs = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.errorChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hintChildren = _t);
    } }, hostVars: 7, hostBindings: function FormFieldComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-form-field", ctx.hostClass)("k-form-field-error", ctx.errorClass)("k-form-field-disabled", ctx.disabledClass);
    } }, inputs: { showHints: "showHints", orientation: "orientation", showErrors: "showErrors" }, features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.formfield'
            }
        ])], ngContentSelectors: _c155, decls: 5, vars: 4, consts: [[4, "ngIf"]], template: function FormFieldComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c154);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵtemplate(3, FormFieldComponent_ng_content_3_Template, 1, 0, "ng-content", 0);
        ɵngcc0.ɵɵtemplate(4, FormFieldComponent_ng_content_4_Template, 1, 0, "ng-content", 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("k-form-field-wrap", ctx.horizontal);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasHints);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasErrors);
    } }, directives: [ɵngcc3.NgIf], encapsulation: 2 });
__decorate([
    HostBinding('class.k-form-field'),
    __metadata("design:type", Boolean)
], FormFieldComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], FormFieldComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('class.k-form-field-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FormFieldComponent.prototype, "errorClass", null);
__decorate([
    HostBinding('class.k-form-field-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FormFieldComponent.prototype, "disabledClass", null);
__decorate([
    ContentChildren(NgControl, { descendants: true }),
    __metadata("design:type", QueryList),
    __metadata("design:paramtypes", [QueryList])
], FormFieldComponent.prototype, "formControls", null);
__decorate([
    ContentChildren(NgControl, { read: ElementRef, descendants: true }),
    __metadata("design:type", QueryList)
], FormFieldComponent.prototype, "controlElementRefs", void 0);
__decorate([
    ContentChild(KendoInput, { static: true }),
    __metadata("design:type", Object)
], FormFieldComponent.prototype, "kendoInput", void 0);
__decorate([
    ContentChildren(ErrorComponent, { descendants: true }),
    __metadata("design:type", QueryList)
], FormFieldComponent.prototype, "errorChildren", void 0);
__decorate([
    ContentChildren(HintComponent, { descendants: true }),
    __metadata("design:type", QueryList)
], FormFieldComponent.prototype, "hintChildren", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormFieldComponent.prototype, "showHints", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormFieldComponent.prototype, "orientation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormFieldComponent.prototype, "showErrors", void 0);
FormFieldComponent = __decorate([ __metadata("design:paramtypes", [Renderer2,
        LocalizationService,
        ElementRef])
], FormFieldComponent);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the FormField, Error and Hint components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the FormField module
 * import { FormFieldModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, FormFieldModule], // import FormField module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let FormFieldModule = class FormFieldModule {
};
FormFieldModule.ɵfac = function FormFieldModule_Factory(t) { return new (t || FormFieldModule)(); };
FormFieldModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: FormFieldModule });
FormFieldModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Inputs components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Inputs module
 * import { InputsModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, InputsModule], // import Inputs module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let InputsModule = class InputsModule {
};
InputsModule.ɵfac = function InputsModule_Factory(t) { return new (t || InputsModule)(); };
InputsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: InputsModule });
InputsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule], TextAreaModule, TextBoxModule, SliderModule, RangeSliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, ColorPickerModule, CheckBoxModule, RadioButtonModule, FormFieldModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LabelTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoSliderLabelTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSlider',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.slider' },
                    { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent_1) },
                    { provide: KendoInput, useExisting: forwardRef(() => SliderComponent_1) }
                ],
                selector: 'kendo-slider',
                template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-increment="kendo.slider.increment|The title of the **Increase** button of the Slider."
            increment="increment"
            i18n-decrement="kendo.slider.decrement|The title of the **Decrease** button of the Slider."
            decrement="decrement"
            i18n-dragHandle="kendo.slider.dragHandle|The title of the drag handle of the Slider."
            dragHandle="Drag"
        >
        <div class="k-slider-wrap" #wrap
            [class.k-slider-buttons]="showButtons"
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            [kendoEventsOutsideAngular]="{ click: onWrapClick, keydown: onKeyDown }"
            >
            <button *ngIf="showButtons" type="button" #decreaseButton
                class="k-button-decrease k-button k-button-md k-rounded-full k-button-rectangle k-button-solid k-button-solid-base k-icon-button"
                [title]="decrementMessage"
                [attr.tabindex]="-1"
                role="presentation">
                    <span class="k-button-icon k-icon"
                        [class.k-i-arrow-w]="!vertical"
                        [class.k-i-arrow-s]="vertical">
                    </span>
            </button>
            <div class="k-slider-track-wrap">
                <ul kendoSliderTicks
                    #ticks
                    *ngIf="tickPlacement !== 'none'"
                    [tickTitle]="title"
                    [vertical]="vertical"
                    [step]="smallStep"
                    [largeStep]="largeStep"
                    [min]="min"
                    [max]="max"
                    [labelTemplate]="labelTemplate?.templateRef"
                    [attr.aria-hidden]="true"
                >
                </ul>
                <div #track class="k-slider-track">
                    <div #sliderSelection class="k-slider-selection">
                    </div>
                    <a #draghandle
                        role="slider"
                        [attr.aria-valuemin]="min"
                        [attr.aria-valuemax]="max"
                        [attr.aria-valuenow]="currentValue"
                        [attr.aria-valuetext]="currentValue"
                        [attr.aria-disabled]="disabled ? true : undefined"
                        [attr.aria-readonly]="readonly ? true : undefined"
                        [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                        [style.touch-action]="isDisabled ? '' : 'none'"
                        class="k-draghandle"
                        [title]="dragHandleMessage"
                        [attr.tabindex]="disabled ? '-1' : tabIndex"
                        [id]="focusableId"
                        kendoDraggable
                        (kendoPress)="ifEnabled(handleDragPress, $event)"
                        (kendoDrag)="ifEnabled(onHandleDrag, $event)"
                        (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                    ></a>
                </div>
            </div>
            <button *ngIf="showButtons" type="button" #increaseButton
                class="k-button-increase k-button k-button-md k-rounded-full k-button-rectangle k-button-solid k-button-solid-base k-icon-button"
                [title]="incrementMessage"
                (click)="$event.preventDefault()"
                [attr.tabindex]="-1"
                [attr.aria-label]="currentValue"
                role="presentation">
                    <span class="k-button-icon k-icon"
                        [class.k-i-arrow-e]="!vertical"
                        [class.k-i-arrow-n]="vertical">
                    </span>
            </button>
            <kendo-resize-sensor (resize)="sizeComponent(false)"></kendo-resize-sensor>
        </div>
  `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.Injector }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { focusableId: [{
            type: Input
        }], animate: [{
            type: Input
        }], showButtons: [{
            type: Input
        }], value: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], dragHandleTitle: [{
            type: Input
        }], incrementTitle: [{
            type: Input
        }], decrementTitle: [{
            type: Input
        }], draghandle: [{
            type: ViewChild,
            args: ['draghandle', { static: true }]
        }], decreaseButton: [{
            type: ViewChild,
            args: ['decreaseButton', { static: false }]
        }], increaseButton: [{
            type: ViewChild,
            args: ['increaseButton', { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RangeSliderComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoRangeSlider',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.rangeslider' },
                    { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => RangeSliderComponent_1) },
                    { provide: KendoInput, useExisting: forwardRef(() => RangeSliderComponent_1) }
                ],
                selector: 'kendo-rangeslider',
                template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-dragHandleStart="kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider."
            dragHandleStart="Drag"
            i18n-dragHandleEnd="kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider."
            dragHandleEnd="Drag"
        >

        <div class="k-slider-wrap" #wrap
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            [kendoEventsOutsideAngular]="{ click: onWrapClick, keydown: onKeyDown }"
            >
            <div class="k-slider-track-wrap">
                <ul kendoSliderTicks
                    #ticks
                    *ngIf="tickPlacement !== 'none'"
                    [tickTitle]="title"
                    [vertical]="vertical"
                    [step]="smallStep"
                    [largeStep]="largeStep"
                    [min]="min"
                    [max]="max"
                    [labelTemplate]="labelTemplate?.templateRef"
                    [attr.aria-hidden]="true"
                >
                </ul>
                <div #track class="k-slider-track">
                    <div #sliderSelection class="k-slider-selection">
                    </div>
                    <a #draghandleStart
                        role="slider"
                        [id]="startHandleId"
                        [attr.tabindex]="disabled ? undefined : tabindex"
                        [attr.aria-valuemin]="min"
                        [attr.aria-valuemax]="max"
                        [attr.aria-valuenow]="value ? value[0] : null"
                        [attr.aria-valuetext]="valueText"
                        [attr.aria-disabled]="disabled ? true : undefined"
                        [attr.aria-readonly]="readonly ? true : undefined"
                        [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                        [style.touch-action]="isDisabled ? '' : 'none'"
                        class="k-draghandle"
                        [title]="textFor('dragHandleStart')"
                        kendoDraggable
                        (kendoPress)="ifEnabled(handleDragPress ,$event)"
                        (kendoDrag)="ifEnabled(onHandleDrag ,$event)"
                        (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                    ></a>
                    <a #draghandleEnd
                        role="slider"
                        [id]="endHandleId"
                        [attr.tabindex]="disabled ? undefined : tabindex"
                        [attr.aria-valuemin]="min"
                        [attr.aria-valuemax]="max"
                        [attr.aria-valuenow]="value ? value[1] : null"
                        [attr.aria-valuetext]="valueText"
                        [attr.aria-disabled]="disabled ? true : undefined"
                        [attr.aria-readonly]="readonly ? true : undefined"
                        [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                        [style.touch-action]="isDisabled ? '' : 'none'"
                        class="k-draghandle"
                        [title]="textFor('dragHandleEnd')"
                        kendoDraggable
                        (kendoPress)="ifEnabled(handleDragPress ,$event)"
                        (kendoDrag)="ifEnabled(onHandleDrag ,$event)"
                        (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                    ></a>
                </div>
            </div>
            <kendo-resize-sensor (resize)="sizeComponent()"></kendo-resize-sensor>
        </div>
  `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.Injector }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { value: [{
            type: Input
        }], draghandleStart: [{
            type: ViewChild,
            args: ['draghandleStart', { static: true }]
        }], draghandleEnd: [{
            type: ViewChild,
            args: ['draghandleEnd', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SwitchComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSwitch',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.switch' },
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => SwitchComponent_1) /* tslint:disable-line */
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => SwitchComponent_1)
                    }
                ],
                selector: 'kendo-switch',
                template: `
        <ng-container kendoSwitchLocalizedMessages
            i18n-on="kendo.switch.on|The **On** label of the Switch."
            on="ON"
            i18n-off="kendo.switch.off|The **Off** label of the Switch."
            off="OFF"
        >

        <span
            #track
            class="k-switch-track"
            [id]="focusableId"
            role="switch"
            [style.transitionDuration]="initialized ? '200ms' : '0ms'"
            [attr.aria-checked]="checked"
            [attr.tabindex]="(disabled ? undefined : tabIndex)"
            [kendoEventsOutsideAngular]="{ keydown: keyDownHandler, focus: handleFocus, blur: handleBlur }"
        >
            <span class="k-switch-label-on" [attr.aria-hidden]="true" >{{onLabelMessage}}</span>
            <span class="k-switch-label-off" [attr.aria-hidden]="true">{{offLabelMessage}}</span>
        </span>
        <span
            class="k-switch-thumb-wrap"
            tabindex="-1"
            [style.transitionDuration]="initialized ? '200ms' : '0ms'" [kendoEventsOutsideAngular]="{
                keydown: keyDownHandler,
                focus: handleFocus,
                blur: handleBlur
            }">
            <span #thumb class="k-switch-thumb"></span>
        </span>
  `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }]; }, { focusableId: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], valueChange: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-switch']
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], checked: [{
            type: Input
        }], size: [{
            type: Input
        }], thumbRounded: [{
            type: Input
        }], trackRounded: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], ieClass: [{
            type: HostBinding,
            args: ['class.k-ie']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], ariaReadonly: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-disabled']
        }], onLabel: [{
            type: Input
        }], offLabel: [{
            type: Input
        }], track: [{
            type: ViewChild,
            args: ['track', { static: true }]
        }], thumb: [{
            type: ViewChild,
            args: ['thumb', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextBoxDirective, [{
        type: Directive,
        args: [{
                selector: 'input[kendoTextBox]',
                providers: [{
                        provide: KendoInput,
                        useExisting: forwardRef(() => TextBoxDirective_1)
                    }]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-textbox']
        }, {
            type: HostBinding,
            args: ['class.k-input']
        }, {
            type: HostBinding,
            args: ['class.k-input-md']
        }, {
            type: HostBinding,
            args: ['class.k-rounded-md']
        }, {
            type: HostBinding,
            args: ['class.k-input-solid']
        }], value: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextAreaDirective, [{
        type: Directive,
        args: [{
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => TextAreaDirective_1),
                        multi: true
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(() => TextAreaDirective_1)
                    }],
                selector: 'textarea[kendoTextArea]'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Injector }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { elementClasses: [{
            type: HostBinding,
            args: ['class.k-textarea']
        }, {
            type: HostBinding,
            args: ['class.k-input']
        }, {
            type: HostBinding,
            args: ['class.k-input-md']
        }, {
            type: HostBinding,
            args: ['class.k-rounded-md']
        }, {
            type: HostBinding,
            args: ['class.k-input-solid']
        }], autofillClass: [{
            type: HostBinding,
            args: ['class.k-autofill']
        }], valueChange: [{
            type: Output
        }], autoSize: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], value: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NumericTextBoxComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoNumericTextBox',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.numerictextbox' },
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NumericTextBoxComponent_1), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => NumericTextBoxComponent_1), multi: true },
                    { provide: KendoInput, useExisting: forwardRef(() => NumericTextBoxComponent_1) }
                ],
                selector: 'kendo-numerictextbox',
                template: `
        <ng-container kendoNumericTextBoxLocalizedMessages
            i18n-increment="kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox"
            increment="Increase value"
            i18n-decrement="kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox"
            decrement="Decrease value"
        >
        </ng-container>
            <input
            role="spinbutton"
            class="k-input-inner"
            autocomplete="off"
            autocorrect="off"
            [id]="focusableId"
            [attr.aria-valuemin]="min"
            [attr.aria-valuemax]="max"
            [attr.aria-valuenow]="value"
            [attr.title]="title"
            [attr.placeholder]="placeholder"
            [attr.maxLength]="maxlength"
            [tabindex]="tabIndex"
            [disabled]="disabled"
            [readonly]="readonly"
            [kendoEventsOutsideAngular]="{
                mousedown: handleMouseDown,
                dragenter: handleDragEnter,
                keydown: handleKeyDown,
                input: handleInput,
                focus: handleFocus,
                blur: handleBlur,
                paste: handlePaste
            }"
            #numericInput />
            <span
                class="k-input-spinner k-spin-button" *ngIf="spinners"
                [kendoEventsOutsideAngular]="{ mouseup: releaseArrow, mouseleave: releaseArrow }"
            >
               <button
                    type="button"
                    [kendoEventsOutsideAngular]="{ mousedown: increasePress }"
                    [attr.aria-hidden]="true"
                    [attr.aria-label]="incrementTitle"
                    [title]="incrementTitle"
                    [class.k-active]="arrowDirection === ArrowDirection.Up"
                    class="k-spinner-increase k-button k-icon-button k-button-solid k-button-solid-base"
                    tabindex="-1"
                >
                    <span class="k-button-icon k-icon k-i-arrow-n"></span>
               </button>
               <button
                    type="button"
                    [kendoEventsOutsideAngular]="{ mousedown: decreasePress }"
                    [attr.aria-hidden]="true"
                    [attr.aria-label]="decrementTitle"
                    [title]="decrementTitle"
                    [class.k-active]="arrowDirection === ArrowDirection.Down"
                    class="k-spinner-decrease k-button k-icon-button k-button-solid k-button-solid-base"
                    tabindex="-1"
               >
                    <span class="k-button-icon k-icon k-i-arrow-s"></span>
               </button>
            </span>
      `
            }]
    }], function () { return [{ type: ɵngcc4.IntlService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.Injector }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { focusableId: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], title: [{
            type: Input
        }], autoCorrect: [{
            type: Input
        }], decimals: [{
            type: Input
        }], step: [{
            type: Input
        }], spinners: [{
            type: Input
        }], rangeValidation: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], changeValueOnScroll: [{
            type: Input
        }], selectOnFocus: [{
            type: Input
        }], value: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-input']
        }, {
            type: HostBinding,
            args: ['class.k-numerictextbox']
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], format: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], size: [{
            type: Input
        }], rounded: [{
            type: Input
        }], fillMode: [{
            type: Input
        }], disableClass: [{
            type: HostBinding,
            args: ['class.k-disabled']
        }], max: [{
            type: Input
        }], min: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], maxlength: [{
            type: Input
        }], numericInput: [{
            type: ViewChild,
            args: ['numericInput', { static: true }]
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NumericTextBoxCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: NumericTextBoxMessages,
                        useExisting: forwardRef(() => NumericTextBoxCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-numerictextbox-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MaskingService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MaskedTextBoxComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoMaskedTextBox',
                providers: [
                    MaskingService,
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */
                    },
                    {
                        multi: true,
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => MaskedTextBoxComponent_1)
                    }
                ],
                selector: 'kendo-maskedtextbox',
                template: `
        <input type="text"
            #input
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            class="k-input-inner"
            [id]="focusableId"
            [tabindex]="tabIndex"
            [attr.title]="title"
            [disabled]="disabled"
            [readonly]="readonly"
            [kendoEventsOutsideAngular]="{
                focus: handleFocus,
                blur: handleBlur,
                click: handleClick,
                dragstart: handleDragDrop,
                drop: handleDragDrop
            }"
        />
    `
            }]
    }], function () { return [{ type: MaskingService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ChangeDetectorRef }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { focusableId: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], prompt: [{
            type: Input
        }], promptPlaceholder: [{
            type: Input
        }], includeLiterals: [{
            type: Input
        }], maskOnFocus: [{
            type: Input
        }], maskValidation: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], valueChange: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-input']
        }, {
            type: HostBinding,
            args: ['class.k-maskedtextbox']
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], size: [{
            type: Input
        }], rounded: [{
            type: Input
        }], fillMode: [{
            type: Input
        }], rules: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], hostDisabledClass: [{
            type: HostBinding,
            args: ['class.k-disabled']
        }], 
    /**
     * @hidden
     */
    pasteHandler: [{
            type: HostListener,
            args: ['paste', ['$event']]
        }], 
    /**
     * @hidden
     */
    inputHandler: [{
            type: HostListener,
            args: ['input', ['$event']]
        }], value: [{
            type: Input
        }], title: [{
            type: Input
        }], mask: [{
            type: Input
        }], input: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderTicksComponent, [{
        type: Component,
        args: [{
                selector: '[kendoSliderTicks]',
                template: `
    <li #tickElement *ngFor="let tick of ticks;"
        [ngClass]="tick.classes"
        title="{{ tickTitle(tick.value) }}"
        role="presentation"
     >
         <ng-container [ngSwitch]="tick.large">
            <span class="k-label" *ngSwitchCase="true">
                <ng-container [ngTemplateOutlet]="labelTemplate || defaultLabel" [ngTemplateOutletContext]="tick">
                </ng-container>
            </span>
            <ng-container *ngSwitchCase="false">&nbsp;</ng-container>
         </ng-container>
     </li>

     <ng-template #defaultLabel let-value="value">
        {{ tickTitle(value) }}
     </ng-template>
  `
            }]
    }], function () { return []; }, { wrapperClasses: [{
            type: HostBinding,
            args: ['class']
        }], tickTitle: [{
            type: Input
        }], vertical: [{
            type: Input
        }], step: [{
            type: Input
        }], largeStep: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], labelTemplate: [{
            type: Input
        }], tickElements: [{
            type: ViewChildren,
            args: ['tickElement']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SlidersCommonModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SliderTicksComponent,
                    LabelTemplateDirective
                ],
                exports: [
                    LabelTemplateDirective,
                    SliderTicksComponent,
                    DraggableModule,
                    EventsModule,
                    ResizeSensorModule
                ],
                imports: [CommonModule, DraggableModule, EventsModule, ResizeSensorModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SlidersCommonModule, { declarations: function () { return [SliderTicksComponent, LabelTemplateDirective]; }, imports: function () { return [CommonModule, DraggableModule, EventsModule, ResizeSensorModule]; }, exports: function () { return [LabelTemplateDirective, SliderTicksComponent, DraggableModule,
        EventsModule,
        ResizeSensorModule]; } }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizedSliderMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: SliderMessages,
                        useExisting: forwardRef(() => LocalizedSliderMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoSliderLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: SliderMessages,
                        useExisting: forwardRef(() => SliderCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-slider-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SliderComponent,
                    SliderCustomMessagesComponent,
                    LocalizedSliderMessagesDirective
                ],
                exports: [
                    SliderComponent,
                    SliderCustomMessagesComponent,
                    LabelTemplateDirective,
                    LocalizedSliderMessagesDirective
                ],
                imports: [CommonModule, SlidersCommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SliderModule, { declarations: function () { return [SliderComponent, SliderCustomMessagesComponent, LocalizedSliderMessagesDirective]; }, imports: function () { return [CommonModule, SlidersCommonModule]; }, exports: function () { return [SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective, LocalizedSliderMessagesDirective]; } }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizedRangeSliderMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: RangeSliderMessages,
                        useExisting: forwardRef(() => LocalizedRangeSliderMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoSliderLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RangeSliderCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: RangeSliderMessages,
                        useExisting: forwardRef(() => RangeSliderCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-rangeslider-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RangeSliderModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    RangeSliderComponent,
                    RangeSliderCustomMessagesComponent,
                    LocalizedRangeSliderMessagesDirective
                ],
                exports: [
                    RangeSliderComponent,
                    RangeSliderCustomMessagesComponent,
                    LocalizedRangeSliderMessagesDirective,
                    LabelTemplateDirective
                ],
                imports: [CommonModule, SlidersCommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RangeSliderModule, { declarations: function () { return [RangeSliderComponent, RangeSliderCustomMessagesComponent, LocalizedRangeSliderMessagesDirective]; }, imports: function () { return [CommonModule, SlidersCommonModule]; }, exports: function () { return [RangeSliderComponent, RangeSliderCustomMessagesComponent, LocalizedRangeSliderMessagesDirective, LabelTemplateDirective]; } }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizedSwitchMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => LocalizedSwitchMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoSwitchLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SwitchCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => SwitchCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-switch-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SwitchModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SwitchComponent,
                    SwitchCustomMessagesComponent,
                    LocalizedSwitchMessagesDirective
                ],
                exports: [
                    SwitchComponent,
                    SwitchCustomMessagesComponent,
                    LocalizedSwitchMessagesDirective
                ],
                imports: [CommonModule, EventsModule, ResizeSensorModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SwitchModule, { declarations: function () { return [SwitchComponent, SwitchCustomMessagesComponent, LocalizedSwitchMessagesDirective]; }, imports: function () { return [CommonModule, EventsModule, ResizeSensorModule]; }, exports: function () { return [SwitchComponent, SwitchCustomMessagesComponent, LocalizedSwitchMessagesDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizedNumericTextBoxMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: NumericTextBoxMessages,
                        useExisting: forwardRef(() => LocalizedNumericTextBoxMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoNumericTextBoxLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NumericTextBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    LocalizedNumericTextBoxMessagesDirective,
                    NumericTextBoxComponent,
                    NumericTextBoxCustomMessagesComponent
                ],
                exports: [
                    NumericTextBoxComponent,
                    NumericTextBoxCustomMessagesComponent
                ],
                imports: [CommonModule, EventsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NumericTextBoxModule, { declarations: function () { return [LocalizedNumericTextBoxMessagesDirective, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent]; }, imports: function () { return [CommonModule, EventsModule]; }, exports: function () { return [NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MaskedTextBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [MaskedTextBoxComponent],
                exports: [MaskedTextBoxComponent],
                imports: [CommonModule, EventsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MaskedTextBoxModule, { declarations: function () { return [MaskedTextBoxComponent]; }, imports: function () { return [CommonModule, EventsModule]; }, exports: function () { return [MaskedTextBoxComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextBoxSuffixTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTextBoxSuffixTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextBoxPrefixTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTextBoxPrefixTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextBoxComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoTextBox',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.textbox' },
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => TextBoxComponent_1),
                        multi: true
                    },
                    { provide: KendoInput, useExisting: forwardRef(() => TextBoxComponent_1) }
                ],
                selector: 'kendo-textbox',
                template: `
        <ng-container kendoTextBoxLocalizedMessages
            i18n-clear="kendo.textbox.clear|The title for the **Clear** button in the TextBox."
            clear="Clear">
        </ng-container>
        <span class="k-input-prefix">
            <ng-template
                *ngIf="prefixTemplate"
                [ngTemplateOutlet]="prefixTemplate?.templateRef">
            </ng-template>
        </span>
        <input #input
            class="k-input-inner"
            [id]="focusableId"
            [disabled]="disabled"
            [readonly]="readonly"
            [attr.tabindex]="disabled ? undefined : tabindex"
            [value]="value"
            [attr.placeholder]="placeholder"
            [attr.title]="title"
            [attr.maxlength]="maxlength"
            [kendoEventsOutsideAngular]="{
                focus: handleInputFocus,
                blur: handleInputBlur,
                input: handleInput}"
        />
        <span
            role="button"
            class="k-clear-value"
            *ngIf="showClearButton"
            (click)="clearValue()"
            (mousedown)="$event.preventDefault()"
            [tabindex]="tabIndex"
            [attr.aria-label]="clearTitle()"
            [title]="clearTitle()"
            (keydown.enter)="clearValue($event)"
            (keydown.space)="clearValue($event)">
                <span [ngClass]="clearButtonClasses"></span>
        </span>
        <span *ngIf="hasErrors" [ngClass]="errorIconClasses"></span>
        <span *ngIf="isSuccessful" [ngClass]="successIconClasses"></span>
        <span class="k-input-suffix">
            <ng-template
                *ngIf="suffixTemplate"
                [ngTemplateOutlet]="suffixTemplate?.templateRef">
            </ng-template>
        </span>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ElementRef }]; }, { focusableId: [{
            type: Input
        }], title: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], value: [{
            type: Input
        }], selectOnFocus: [{
            type: Input
        }], showSuccessIcon: [{
            type: Input
        }], showErrorIcon: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], inputFocus: [{
            type: Output
        }], inputBlur: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-textbox']
        }, {
            type: HostBinding,
            args: ['class.k-input']
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], size: [{
            type: Input
        }], rounded: [{
            type: Input
        }], fillMode: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-disabled']
        }], successIcon: [{
            type: Input
        }], errorIcon: [{
            type: Input
        }], clearButtonIcon: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], maxlength: [{
            type: Input
        }], input: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }], suffixTemplate: [{
            type: ContentChild,
            args: [TextBoxSuffixTemplateDirective, { static: false }]
        }], prefixTemplate: [{
            type: ContentChild,
            args: [TextBoxPrefixTemplateDirective, { static: false }]
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextBoxCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: TextBoxMessages,
                        useExisting: forwardRef(() => TextBoxCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-textbox-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizedTextBoxMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: TextBoxMessages,
                        useExisting: forwardRef(() => LocalizedTextBoxMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoTextBoxLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InputSeparatorComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-input-separator, kendo-textbox-separator',
                template: ``
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-input-separator']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SharedModule, [{
        type: NgModule,
        args: [{
                declarations: [SHARED_DIRECTIVES],
                exports: [SHARED_DIRECTIVES]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedModule, { declarations: [InputSeparatorComponent, TextAreaDirective], exports: [InputSeparatorComponent, TextAreaDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    TextBoxDirective,
                    TextBoxComponent,
                    TextBoxSuffixTemplateDirective,
                    TextBoxPrefixTemplateDirective,
                    TextBoxCustomMessagesComponent,
                    LocalizedTextBoxMessagesDirective
                ],
                exports: [
                    TextBoxDirective,
                    TextBoxComponent,
                    TextBoxSuffixTemplateDirective,
                    TextBoxPrefixTemplateDirective,
                    EventsModule,
                    TextBoxCustomMessagesComponent,
                    LocalizedTextBoxMessagesDirective,
                    SHARED_DIRECTIVES
                ],
                imports: [CommonModule, EventsModule, SharedModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TextBoxModule, { declarations: function () { return [TextBoxDirective, TextBoxComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, LocalizedTextBoxMessagesDirective]; }, imports: function () { return [CommonModule, EventsModule, SharedModule]; }, exports: function () { return [TextBoxDirective, TextBoxComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, EventsModule, TextBoxCustomMessagesComponent, LocalizedTextBoxMessagesDirective, InputSeparatorComponent, TextAreaDirective]; } }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextAreaComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoTextArea',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.textarea' },
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => TextAreaComponent_1),
                        multi: true
                    },
                    { provide: KendoInput, useExisting: forwardRef(() => TextAreaComponent_1) }
                ],
                selector: 'kendo-textarea',
                template: `
        <textarea
            #input
            [attr.aria-multiline]="true"
            [attr.aria-disabled]="disabled ? true : undefined"
            [attr.aria-readonly]="readonly ? true : undefined"
            class="k-input-inner"
            [ngClass]="resizableClass"
            [id]="focusableId"
            [value]="value"
            [attr.placeholder]="placeholder"
            [disabled]="disabled"
            [readonly]="readonly"
            [attr.rows]="rows"
            [attr.cols]="cols"
            [attr.tabindex]="tabIndex"
            [attr.title]="title"
            [attr.maxlength]="maxlength"
            [kendoEventsOutsideAngular]="{
                focus: handleInputFocus,
                blur: handleInputBlur,
                input: handleInput}">
            </textarea>
            <ng-content select="kendo-textarea-suffix"></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ElementRef }]; }, { focusableId: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-textarea']
        }, {
            type: HostBinding,
            args: ['class.k-input']
        }], flow: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], resizable: [{
            type: Input
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], valueChange: [{
            type: Output
        }], flowCol: [{
            type: HostBinding,
            args: ['class.\!k-flex-col']
        }], flowRow: [{
            type: HostBinding,
            args: ['class.\!k-flex-row']
        }], tabIndex: [{
            type: Input
        }], size: [{
            type: Input
        }], rounded: [{
            type: Input
        }], fillMode: [{
            type: Input
        }], rows: [{
            type: Input
        }], cols: [{
            type: Input
        }], maxlength: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextAreaSuffixComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoTextAreaSuffix',
                selector: 'kendo-textarea-suffix',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-input-suffix']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextAreaModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    TextAreaComponent,
                    TextAreaSuffixComponent
                ],
                exports: [
                    TextAreaComponent,
                    EventsModule,
                    TextAreaSuffixComponent,
                    SHARED_DIRECTIVES
                ],
                imports: [CommonModule, EventsModule, SharedModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TextAreaModule, { declarations: function () { return [TextAreaComponent, TextAreaSuffixComponent]; }, imports: function () { return [CommonModule, EventsModule, SharedModule]; }, exports: function () { return [TextAreaComponent, EventsModule, TextAreaSuffixComponent, InputSeparatorComponent, TextAreaDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FlatColorPickerService, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColorInputComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-colorinput',
                template: `
        <div class="k-vstack">
            <button #toggleFormatButton
                class="k-colorgradient-toggle-mode k-button k-button-md k-button-flat k-button-flat-base k-icon-button"
                [attr.aria-label]="formatButtonTitle"
                [attr.title]="formatButtonTitle"
                type="button"
            >
                <span class="k-button-icon k-icon k-i-arrows-kpi"></span>
            </button>
        </div>
        <div *ngIf="formatView === 'hex'" class="k-vstack">
            <input
                #hexInput
                [id]="focusableId"
                class="k-input k-textbox k-input-solid k-input-md k-rounded-md k-hex-value"
                [disabled]="disabled"
                [readonly]="readonly"
                [value]="hex || ''"
                (blur)="handleHexInputBlur()"
                (input)="handleHexValueChange(hexInput.value)"
            />
            <label [for]="focusableId" class="k-colorgradient-input-label">HEX</label>
        </div>
        <ng-container *ngIf="formatView === 'rgba'">
            <div class="k-vstack">
                <kendo-numerictextbox
                    #red
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.r"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="red.focusableId" class="k-colorgradient-input-label">R</label>
            </div>
            <div class="k-vstack">
                <kendo-numerictextbox
                    #green
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.g"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="green.focusableId" class="k-colorgradient-input-label">G</label>
            </div>
            <div class="k-vstack">
                <kendo-numerictextbox
                    #blue
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.b"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="blue.focusableId" class="k-colorgradient-input-label">B</label>
            </div>
            <div class="k-vstack" *ngIf="opacity">
                <kendo-numerictextbox  #opacityInput
                    #alpha
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="1"
                    [(value)]="rgba.a"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [step]="0.01"
                    [format]="'n2'"
                    [decimals]="2"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="alpha.focusableId" class="k-colorgradient-input-label">A</label>
            </div>
        </ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }]; }, { focusableId: [{
            type: Input
        }], opacity: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], colorInputClass: [{
            type: HostBinding,
            args: ['class.k-colorgradient-inputs']
        }, {
            type: HostBinding,
            args: ['class.k-hstack']
        }], value: [{
            type: Input
        }], formatView: [{
            type: Input
        }], opacityInput: [{
            type: ViewChild,
            args: ['opacityInput', { static: false }]
        }], hexInput: [{
            type: ViewChild,
            args: ['hexInput', { read: ElementRef, static: false }]
        }], blueInput: [{
            type: ViewChild,
            args: ['blueInput', { read: ElementRef, static: false }]
        }], toggleFormatButton: [{
            type: ViewChild,
            args: ['toggleFormatButton', { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColorGradientComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoColorGradient',
                selector: 'kendo-colorgradient',
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorGradientComponent_1)
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => ColorGradientComponent_1)
                    },
                    ColorGradientLocalizationService,
                    {
                        provide: LocalizationService,
                        useExisting: ColorGradientLocalizationService
                    },
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.colorgradient'
                    }
                ],
                template: `
        <ng-container kendoColorGradientLocalizedMessages
            i18n-colorGradientNoColor="kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorGradientHandle="kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.colorgradient.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.colorgradient.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-passContrast="kendo.colorgradient.passContrast|The pass message for the contrast tool."
            passContrast="Pass"
            i18n-failContrast="kendo.colorgradient.failContrast|The fail message for the contrast tool."
            failContrast="Fail"
            i18n-contrastRatio="kendo.colorgradient.contrastRatio|The contrast ratio message for the contrast tool."
            contrastRatio="Contrast ratio"
            i18n-formatButton="kendo.colorgradient.formatButton|The message for the input format toggle button."
            formatButton="Change color format">
        </ng-container>
        <div class="k-colorgradient-canvas k-hstack">
            <div class="k-hsv-rectangle" #hsvRectangle>
                <div
                    #gradientWrapper
                    kendoDraggable
                    class="k-hsv-gradient"
                    (click)="changePosition($event)"
                    (kendoPress)="handleDragPress($event)"
                    (kendoDrag)="onHandleDrag($event)"
                    (kendoRelease)="onHandleRelease()">
                    <div
                        #gradientDragHandle
                        class="k-hsv-draghandle k-draghandle"
                        tabindex="0"
                        [attr.title]="colorGradientHandleTitle"
                        [attr.aria-label]="colorGradientHandleAriaLabel"
                    >
                    </div>
                </div>
                <svg kendoColorContrastSvg
                    *ngIf="contrastToolVisible && gradientWrapper"
                    class="k-color-contrast-svg"
                    xmlns="http://www.w3.org/2000/svg"
                    [wrapper]="gradientWrapper ? gradientWrapper : undefined"
                    [hsva]="hsva"
                    [backgroundColor]="contrastTool">
                </svg>
            </div>
            <div class="k-hsv-controls k-hstack {{ clearButton ? 'k-sliders-wrap-clearable' : '' }}">
                <span class="k-clear-color k-button k-button-md k-button-flat k-button-flat-base k-button-icon"
                    *ngIf="clearButton"
                    (click)="reset()"
                    (keydown.enter)="reset()"
                    (keydown.space)="reset()"
                    [attr.aria-label]="clearButtonTitle"
                    [attr.title]="clearButtonTitle"
                    tabindex="0">
                    <span class="k-icon k-i-reset-color"></span>
                </span>
                <kendo-slider
                    [ngClass]="{'k-align-self-end': clearButton}"
                    class="k-hue-slider k-colorgradient-slider"
                    [dragHandleTitle]="hueSliderTitle"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    [tickPlacement]="'none'"
                    [vertical]="true"
                    [min]="0"
                    [max]="360"
                    [value]="hsva.value.h"
                    [smallStep]="5"
                    [largeStep]="10"
                    (valueChange)="handleHueSliderChange($event)"
                >
                </kendo-slider>
                <kendo-slider
                    *ngIf="opacity"
                    #alphaSlider
                    [ngClass]="{'k-align-self-end': clearButton}"
                    class="k-alpha-slider k-colorgradient-slider"
                    [dragHandleTitle]="opacitySliderTitle"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    [tickPlacement]="'none'"
                    [vertical]="true"
                    [min]="0"
                    [max]="100"
                    [smallStep]="1"
                    [largeStep]="10"
                    [value]="alphaSliderValue"
                    (valueChange)="handleAlphaSliderChange($event)"
                >
                </kendo-slider>
            </div>
        </div>
        <kendo-colorinput  #inputs
            [opacity]="opacity"
            [formatView]="format"
            [value]="value"
            [disabled]="disabled"
            [readonly]="readonly"
            (valueChange)="handleInputsValueChange($event)"
        >
        </kendo-colorinput>
        <div class="k-colorgradient-color-contrast k-vbox"
            *ngIf="contrastToolVisible"
            kendoContrastTool
            [value]="value"
            [ratio]="contrastTool">
        </div>
    `,
                styles: [`
        .k-clear-color {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        .k-colorgradient-slider.k-align-self-end {
            height: 140px;
        }

        .k-color-contrast-svg {
            position: absolute;
            overflow: visible;
            pointer-events: none;
            left: 0px;
            top: 0px;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.LocalizationService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-colorgradient']
        }], id: [{
            type: Input
        }], opacity: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], delay: [{
            type: Input
        }], format: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], readonlyAttribute: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], gradientId: [{
            type: HostBinding,
            args: ['attr.id']
        }], hostTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], value: [{
            type: Input
        }], contrastTool: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], gradientDragHandle: [{
            type: ViewChild,
            args: ['gradientDragHandle', { read: ElementRef, static: false }]
        }], inputs: [{
            type: ViewChild,
            args: ['inputs', { static: false }]
        }], alphaSlider: [{
            type: ViewChild,
            args: ['alphaSlider', { static: false }]
        }], gradientWrapper: [{
            type: ViewChild,
            args: ['gradientWrapper', { static: false }]
        }], hsvRectangle: [{
            type: ViewChild,
            args: ['hsvRectangle', { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColorPaletteService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColorPaletteComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoColorPalette',
                selector: 'kendo-colorpalette',
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorPaletteComponent_1) // tslint:disable-line:no-forward-ref
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(() => ColorPaletteComponent_1)
                    },
                    ColorPaletteService,
                    ColorPaletteLocalizationService,
                    {
                        provide: LocalizationService,
                        useExisting: ColorPaletteLocalizationService
                    },
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.colorpalette'
                    }
                ],
                template: `
        <ng-container kendoColorPaletteLocalizedMessages
            i18n-colorPaletteNoColor="kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen">
        </ng-container>
        <div role="listbox" class="k-colorpalette-table-wrap"
            [attr.aria-activedescendant]="activeCellId">
            <table class="k-colorpalette-table k-palette">
                <tbody>
                    <tr *ngFor="let row of colorRows; let rowIndex = index">
                        <td *ngFor="let color of row; let colIndex = index"
                            role="option"
                            [class.k-state-selected]="selectedCell?.row === rowIndex && selectedCell?.col === colIndex"
                            [class.k-state-focus]="focusInComponent && focusedCell?.row === rowIndex && focusedCell?.col === colIndex"
                            [attr.aria-selected]="selectedCell?.row === rowIndex && selectedCell?.col === colIndex"
                            [attr.aria-label]="color"
                            class="k-colorpalette-tile"
                            [id]="'k-' + rowIndex + '-' + colIndex + '-' + uniqueId"
                            [attr.value]="color"
                            (click)="handleCellSelection(color, { row: rowIndex, col: colIndex })"
                            [ngStyle]="{
                                backgroundColor: color,
                                width: tileLayout.width + 'px',
                                height: tileLayout.height + 'px',
                                minWidth: tileLayout.width + 'px'
                            }">
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ColorPaletteService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { id: [{
            type: Input
        }], format: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tileSize: [{
            type: Input
        }], selectionChange: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], cellSelection: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-colorpalette']
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], paletteId: [{
            type: HostBinding,
            args: ['attr.id']
        }], value: [{
            type: Input
        }], columns: [{
            type: Input
        }], palette: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], hostTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], disabledClass: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], readonlyAttribute: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], 
    /**
     * @hidden
     */
    handleKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], 
    /**
     * @hidden
     */
    handleHostBlur: [{
            type: HostListener,
            args: ['blur']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FlatColorPickerHeaderComponent, [{
        type: Component,
        args: [{
                selector: '[kendoFlatColorPickerHeader]',
                template: `
        <div class="k-coloreditor-header-actions k-hstack">
            <div *ngIf="viewButtons" class="k-button-group k-button-group-flat">
                <button *ngFor="let view of views"
                    #viewButtons
                    type="button"
                    (click)="onViewButtonClick(view)"
                    class="k-button k-button-md k-button-flat k-button-flat-base k-icon-button"
                    [attr.title]="getText(view === 'gradient' ? 'gradientView' : 'paletteView')"
                    [attr.aria-label]="getText(view === 'gradient' ? 'gradientView' : 'paletteView')"
                    [attr.aria-pressed]="activeView === view"
                    [ngClass]="activeView === view ? 'k-state-selected' : ''"
                >
                    <span
                        class="k-button-icon k-icon"
                        [ngClass]="getViewButtonIcon(view)">
                    </span>
                </button>
            </div>
        </div>
        <div class="k-spacer"></div>
        <div class="k-coloreditor-header-actions k-hstack">
            <button *ngIf="clearButton"
                #clearButton
                type="button"
                class="k-button k-button-md k-button-flat k-button-flat-base k-icon-button k-coloreditor-reset"
                [attr.aria-label]="getText('clearButton')"
                [attr.title]="getText('clearButton')"
                (click)="clearButtonClick.emit()">
                    <span class="k-button-icon k-icon k-i-reset-color"></span>
            </button>
            <div class="k-coloreditor-preview k-vstack" *ngIf="preview">
                <span
                    class="k-coloreditor-preview-color k-color-preview"
                    [attr.title]="getText('previewColor')"
                    [style.background-color]="selection">
                </span>
                <span class="k-coloreditor-current-color k-color-preview"
                    [style.background-color]="value"
                    [attr.title]="getText('revertSelection')"
                    (click)="valuePaneClick.emit($event)">
                </span>
            </div>
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-coloreditor-header']
        }, {
            type: HostBinding,
            args: ['class.k-hstack']
        }], viewChange: [{
            type: Output
        }], valuePaneClick: [{
            type: Output
        }], clearButtonClick: [{
            type: Output
        }], activeView: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], views: [{
            type: Input
        }], preview: [{
            type: Input
        }], value: [{
            type: Input
        }], selection: [{
            type: Input
        }], viewButtonsCollection: [{
            type: ViewChildren,
            args: ['viewButtons', { read: ElementRef }]
        }], clearButtonElement: [{
            type: ViewChild,
            args: ['clearButton', { read: ElementRef, static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FlatColorPickerActionButtonsComponent, [{
        type: Component,
        args: [{
                selector: '[kendoFlatColorPickerActionButtons]',
                template: `
        <button
            class="k-coloreditor-cancel k-button k-button-md k-button-solid k-button-solid-base"
            [attr.title]="getText('cancelButton')"
            (click)="onActionButtonClick('cancel', $event)"
            type="button"
        >{{getText('cancelButton')}}</button>
        <button #last
            class="k-coloreditor-apply k-button k-button-md k-button-solid k-button-solid-primary"
            [attr.title]="getText('applyButton')"
            (click)="onActionButtonClick('apply', $event)"
            type="button"
        >{{getText('applyButton')}}</button>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-coloreditor-footer']
        }, {
            type: HostBinding,
            args: ['class.k-actions']
        }, {
            type: HostBinding,
            args: ['class.k-hstack']
        }], actionButtonClick: [{
            type: Output
        }], lastButton: [{
            type: ViewChild,
            args: ['last', { read: ElementRef, static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FlatColorPickerComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoFlatColorPicker',
                selector: 'kendo-flatcolorpicker',
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => FlatColorPickerComponent_1)
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => FlatColorPickerComponent_1)
                    },
                    FlatColorPickerService,
                    FlatColorPickerLocalizationService,
                    {
                        provide: LocalizationService,
                        useExisting: FlatColorPickerLocalizationService
                    },
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.flatcolorpicker'
                    }
                ],
                template: `
        <ng-container kendoFlatColorPickerLocalizedMessages
            i18n-flatColorPickerNoColor="kendo.flatcolorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty."
            flatColorPickerNoColor="Flatcolorpicker no color chosen"
            i18n-colorGradientNoColor="kendo.flatcolorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorPaletteNoColor="kendo.flatcolorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen"
            i18n-colorGradientHandle="kendo.flatcolorpicker.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.flatcolorpicker.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.flatcolorpicker.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.flatcolorpicker.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-contrastRatio="kendo.flatcolorpicker.contrastRatio|The contrast ratio message for the contrast tool."
            contrastRatio="Contrast ratio"
            i18n-previewColor="kendo.flatcolorpicker.previewColor|The message for the color preview pane."
            previewColor="Color preview"
            i18n-revertSelection="kendo.flatcolorpicker.revertSelection|The message for the selected color pane."
            revertSelection="Revert selection"
            i18n-gradientView="kendo.flatcolorpicker.gradientView|The message for the gradient view button."
            gradientView="Gradient view"
            i18n-paletteView="kendo.flatcolorpicker.paletteView|The message for the palette view button."
            paletteView="Palette view"
            i18n-formatButton="kendo.flatcolorpicker.formatButton|The message for the input format toggle button."
            formatButton="Change color format"
            i18n-applyButton="kendo.flatcolorpicker.applyButton|The message for the Apply action button."
            applyButton="Apply"
            i18n-cancelButton="kendo.flatcolorpicker.cancelButton|The message for the Cancel action button."
            cancelButton="Cancel">
        </ng-container>
        <div kendoFlatColorPickerHeader
            *ngIf="headerHasContent"
            #header
            [clearButton]="clearButton"
            [activeView]="activeView"
            [views]="views"
            [value]="value"
            [selection]="selection"
            [preview]="preview"
            (clearButtonClick)="onClearButtonClick()"
            (viewChange)="onViewChange($event)"
            (valuePaneClick)="resetSelection($event)">
        </div>
        <div class="k-coloreditor-views k-vstack">
            <kendo-colorgradient #gradient
                *ngIf="activeView === 'gradient'"
                [tabindex]="null"
                [value]="selection"
                [format]="format"
                [opacity]="gradientSettings.opacity"
                [delay]="gradientSettings.delay"
                [contrastTool]="gradientSettings.contrastTool"
                [readonly]="readonly"
                (valueChange)="handleValueChange($event)"
            >
            </kendo-colorgradient>
            <kendo-colorpalette #palette
                *ngIf="activeView === 'palette'"
                kendoFocusOnDomReady
                [palette]="paletteSettings.palette"
                [columns]="paletteSettings.columns"
                [tileSize]="paletteSettings.tileSize"
                [format]="format"
                [value]="selection"
                (valueChange)="handleValueChange($event)"
            >
            </kendo-colorpalette>
        </div>
        <div kendoFlatColorPickerActionButtons *ngIf="preview"
            #footer
            [ngClass]="'k-justify-content-' + actionsLayout"
            (actionButtonClick)="onAction($event)">
        </div>
`
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: FlatColorPickerService }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-flatcolorpicker']
        }, {
            type: HostBinding,
            args: ['class.k-coloreditor']
        }], readonly: [{
            type: Input
        }], disabled: [{
            type: Input
        }], format: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], preview: [{
            type: Input
        }], actionsLayout: [{
            type: Input
        }], views: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], cancel: [{
            type: Output
        }], activeViewChange: [{
            type: Output
        }], actionButtonClick: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }, {
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], ariaReadonly: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], hostTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], value: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], gradientSettings: [{
            type: Input
        }], paletteSettings: [{
            type: Input
        }], activeView: [{
            type: Input
        }], header: [{
            type: ViewChild,
            args: ['header', { static: false }]
        }], gradient: [{
            type: ViewChild,
            args: ['gradient', { static: false }]
        }], palette: [{
            type: ViewChild,
            args: ['palette', { static: false }]
        }], footer: [{
            type: ViewChild,
            args: ['footer', { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColorPickerComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoColorPicker',
                selector: 'kendo-colorpicker',
                providers: [{
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorPickerComponent_1)
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(() => ColorPickerComponent_1)
                    },
                    ColorPickerLocalizationService,
                    {
                        provide: LocalizationService,
                        useExisting: ColorPickerLocalizationService
                    },
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.colorpicker'
                    }
                ],
                template: `
        <ng-container kendoColorPickerLocalizedMessages
            i18n-colorPickerNoColor="kendo.colorpicker.colorPickerNoColor|The aria-label applied to the ColorPicker component when the value is empty."
            colorPickerNoColor="Colorpicker no color chosen"
            i18n-flatColorPickerNoColor="kendo.colorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty."
            flatColorPickerNoColor="Flatcolorpicker no color chosen"
            i18n-colorGradientNoColor="kendo.colorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorPaletteNoColor="kendo.colorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen"
            i18n-colorGradientHandle="kendo.colorpicker.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.colorpicker.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.colorpicker.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.colorpicker.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-contrastRatio="kendo.colorpicker.contrastRatio|The contrast ratio message for the contrast tool."
            contrastRatio="Contrast ratio"
            i18n-previewColor="kendo.colorpicker.previewColor|The message for the color preview pane."
            previewColor="Color preview"
            i18n-revertSelection="kendo.colorpicker.revertSelection|The message for the selected color pane."
            revertSelection="Revert selection"
            i18n-gradientView="kendo.colorpicker.gradientView|The message for the gradient view button."
            gradientView="Gradient view"
            i18n-paletteView="kendo.colorpicker.paletteView|The message for the palette view button."
            paletteView="Palette view"
            i18n-formatButton="kendo.colorpicker.formatButton|The message for the input format toggle button."
            formatButton="Change color format"
            i18n-applyButton="kendo.colorpicker.applyButton|The message for the Apply action button."
            applyButton="Apply"
            i18n-cancelButton="kendo.colorpicker.cancelButton|The message for the Cancel action button."
            cancelButton="Cancel">
        </ng-container>
        <span #activeColor class="k-input-inner">
            <span
                class="k-value-icon k-color-preview"
                [ngClass]="{'k-icon-color-preview': iconStyles, 'k-no-color': !value}">
                <span *ngIf="iconClass || icon" class="k-color-preview-icon k-icon" [ngClass]="iconStyles"></span>
                <span class="k-color-preview-mask" [style.background-color]="value"></span>
            </span>
        </span>
        <button
            tabindex="-1"
            type="button"
            class="k-input-button k-button k-button-md k-button-solid k-button-solid-base k-icon-button">
                <span class="k-button-icon k-icon k-i-arrow-s"></span>
        </button>
        <ng-template #popupTemplate>
            <kendo-flatcolorpicker
                #flatColorPicker
                [value]="value"
                [format]="format"
                [views]="views"
                [activeView]="activeView"
                [actionsLayout]="actionsLayout"
                [preview]="preview"
                [gradientSettings]="gradientSettings"
                [paletteSettings]="paletteSettings"
                [clearButton]="clearButton"
                (cancel)="handleCancelEvent($event)"
                (focusout)="handlePopupBlur($event)"
                (valueChange)="handleValueChange($event)"
                (keydown)="handlePopupKeyDown($event)"
                (activeViewChange)="activeViewChange.emit($event)"
                (actionButtonClick)="togglePopup()">
            </kendo-flatcolorpicker>
        </ng-template>
        <ng-container #container></ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc5.PopupService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-colorpicker']
        }, {
            type: HostBinding,
            args: ['class.k-icon-picker']
        }, {
            type: HostBinding,
            args: ['class.k-picker']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], views: [{
            type: Input
        }], readonly: [{
            type: Input
        }], disabled: [{
            type: Input
        }], format: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], preview: [{
            type: Input
        }], actionsLayout: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], cancel: [{
            type: Output
        }], activeColorClick: [{
            type: Output
        }], activeViewChange: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], focusedClass: [{
            type: HostBinding,
            args: ['class.k-focus']
        }], disabledClass: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.k-disabled']
        }], ariaReadonly: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], ariaExpanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], hostTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], view: [{
            type: Input
        }], value: [{
            type: Input
        }], popupSettings: [{
            type: Input
        }], paletteSettings: [{
            type: Input
        }], gradientSettings: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], size: [{
            type: Input
        }], rounded: [{
            type: Input
        }], fillMode: [{
            type: Input
        }], activeView: [{
            type: Input
        }], icon: [{
            type: Input
        }], iconClass: [{
            type: Input
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef, static: true }]
        }], activeColor: [{
            type: ViewChild,
            args: ['activeColor', { static: true }]
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate', { static: true }]
        }], flatColorPicker: [{
            type: ViewChild,
            args: ['flatColorPicker', { static: false }]
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColorPickerCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColorPickerMessages,
                        useExisting: forwardRef(() => ColorPickerCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-colorpicker-messages, kendo-flatcolorpicker-messages, kendo-colorgradient-messages, kendo-colorpalette-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizedColorPickerMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: ColorPickerMessages,
                        useExisting: forwardRef(() => LocalizedColorPickerMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoColorPickerLocalizedMessages], [kendoFlatColorPickerLocalizedMessages], [kendoColorGradientLocalizedMessages], [kendoColorPaletteLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FocusOnDomReadyDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoFocusOnDomReady]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContrastValidationComponent, [{
        type: Component,
        args: [{
                selector: '[kendoContrastValidation]',
                template: `
        <span>{{contrastText}}</span>
        <ng-container *ngIf="value">
            <span class="k-contrast-validation k-text-success" *ngIf="pass">
                {{passMessage}}
                <span class="k-icon k-i-check"></span>
            </span>
            <span class="k-contrast-validation k-text-error" *ngIf="!pass">
                {{failMessage}}
                <span class="k-icon k-i-close"></span>
            </span>
        </ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { type: [{
            type: Input
        }], pass: [{
            type: Input
        }], value: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContrastComponent, [{
        type: Component,
        args: [{
                selector: '[kendoContrastTool]',
                template: `
        <div class="k-contrast-ratio">
            <span class="k-contrast-ratio-text">{{contrastRatioText}}</span>
            <ng-container *ngIf="value">
                <span class="k-contrast-validation k-text-success" *ngIf="satisfiesAACondition">
                    <span class="k-icon k-i-check"></span>
                    <span class="k-icon k-i-check" *ngIf="satisfiesAAACondition"></span>
                </span>
                <span class="k-contrast-validation k-text-error" *ngIf="!satisfiesAACondition">
                    <span class="k-icon k-i-close"></span>
                </span>
            </ng-container>
        </div>
        <div kendoContrastValidation
            type="AA"
            [value]="value"
            [pass]="satisfiesAACondition">
        </div>
        <div kendoContrastValidation
            type="AAA"
            [value]="value"
            [pass]="satisfiesAAACondition">
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { value: [{
            type: Input
        }], ratio: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColorContrastSvgComponent, [{
        type: Component,
        args: [{
                selector: '[kendoColorContrastSvg]',
                template: `
        <svg:path *ngFor="let path of paths" [attr.d]="path" fill="none" stroke="white" stroke-width="1"></svg:path>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-color-contrast-svg']
        }], wrapper: [{
            type: Input
        }], hsva: [{
            type: Input
        }], backgroundColor: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColorPickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    PUBLIC_DIRECTIVES,
                    INTERNAL_DIRECTIVES
                ],
                exports: [PUBLIC_DIRECTIVES],
                imports: [
                    SliderModule,
                    NumericTextBoxModule,
                    CommonModule,
                    PopupModule,
                    DraggableModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ColorPickerModule, { declarations: function () { return [ColorPickerComponent, ColorPaletteComponent, ColorGradientComponent, FlatColorPickerComponent, LocalizedColorPickerMessagesDirective, ColorPickerCustomMessagesComponent, ColorInputComponent, FocusOnDomReadyDirective, ContrastComponent, ContrastValidationComponent, FlatColorPickerHeaderComponent, FlatColorPickerActionButtonsComponent, ColorContrastSvgComponent]; }, imports: function () { return [SliderModule, NumericTextBoxModule, CommonModule,
        PopupModule,
        DraggableModule]; }, exports: function () { return [ColorPickerComponent, ColorPaletteComponent, ColorGradientComponent, FlatColorPickerComponent, LocalizedColorPickerMessagesDirective, ColorPickerCustomMessagesComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CheckBoxDirective, [{
        type: Directive,
        args: [{
                selector: 'input[kendoCheckBox]'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { kendoClass: [{
            type: HostBinding,
            args: ['class.k-checkbox']
        }], size: [{
            type: Input
        }], rounded: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CheckBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [CheckBoxDirective],
                exports: [CheckBoxDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CheckBoxModule, { declarations: function () { return [CheckBoxDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CheckBoxDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadioButtonDirective, [{
        type: Directive,
        args: [{
                selector: 'input[kendoRadioButton]'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { kendoClass: [{
            type: HostBinding,
            args: ['class.k-radio']
        }], size: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadioButtonModule, [{
        type: NgModule,
        args: [{
                declarations: [RadioButtonDirective],
                exports: [RadioButtonDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RadioButtonModule, { declarations: function () { return [RadioButtonDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [RadioButtonDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ErrorComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-formerror',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-form-error']
        }], align: [{
            type: Input
        }], roleAttribute: [{
            type: HostBinding,
            args: ['attr.role']
        }], startClass: [{
            type: HostBinding,
            args: ['class.k-text-start']
        }], endClass: [{
            type: HostBinding,
            args: ['class.k-text-end']
        }], idAttribute: [{
            type: HostBinding,
            args: ['attr.id']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HintComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-formhint',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { align: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-form-hint']
        }], startClass: [{
            type: HostBinding,
            args: ['class.k-text-start']
        }], endClass: [{
            type: HostBinding,
            args: ['class.k-text-end']
        }], idAttribute: [{
            type: HostBinding,
            args: ['attr.id']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormFieldComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-formfield',
                template: `
        <ng-content select="label, kendo-label"></ng-content>
        <div [class.k-form-field-wrap]="horizontal">
            <ng-content></ng-content>
            <ng-content select="kendo-formhint" *ngIf="hasHints"></ng-content>
            <ng-content select="kendo-formerror" *ngIf="hasErrors"></ng-content>
        </div>
    `,
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.formfield'
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.ElementRef }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-form-field']
        }], showHints: [{
            type: Input
        }], orientation: [{
            type: Input
        }], showErrors: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], errorClass: [{
            type: HostBinding,
            args: ['class.k-form-field-error']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-form-field-disabled']
        }], formControls: [{
            type: ContentChildren,
            args: [NgControl, { descendants: true }]
        }], controlElementRefs: [{
            type: ContentChildren,
            args: [NgControl, { read: ElementRef, descendants: true }]
        }], kendoInput: [{
            type: ContentChild,
            args: [KendoInput, { static: true }]
        }], errorChildren: [{
            type: ContentChildren,
            args: [ErrorComponent, { descendants: true }]
        }], hintChildren: [{
            type: ContentChildren,
            args: [HintComponent, { descendants: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormFieldModule, [{
        type: NgModule,
        args: [{
                declarations: [HintComponent, ErrorComponent, FormFieldComponent],
                exports: [HintComponent, ErrorComponent, FormFieldComponent],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FormFieldModule, { declarations: function () { return [HintComponent, ErrorComponent, FormFieldComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [HintComponent, ErrorComponent, FormFieldComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InputsModule, [{
        type: NgModule,
        args: [{
                exports: [
                    TextAreaModule,
                    TextBoxModule,
                    SliderModule,
                    RangeSliderModule,
                    SwitchModule,
                    NumericTextBoxModule,
                    MaskedTextBoxModule,
                    ColorPickerModule,
                    CheckBoxModule,
                    RadioButtonModule,
                    FormFieldModule
                ],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(InputsModule, { imports: function () { return [CommonModule]; }, exports: function () { return [TextAreaModule, TextBoxModule, SliderModule, RangeSliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, ColorPickerModule, CheckBoxModule, RadioButtonModule, FormFieldModule]; } }); })();





/**
 * Generated bundle index. Do not edit.
 */

export { ColorContrastSvgComponent, ColorInputComponent, ContrastValidationComponent, ContrastComponent, FlatColorPickerActionButtonsComponent, FlatColorPickerHeaderComponent, FocusOnDomReadyDirective, ColorGradientLocalizationService, ColorPaletteLocalizationService, ColorPickerLocalizationService, ColorPickerCustomMessagesComponent, FlatColorPickerLocalizationService, ColorPickerMessages, ColorPaletteService, FlatColorPickerService, MaskingService, NumericTextBoxMessages, RangeSliderCustomMessagesComponent, RangeSliderMessages, SHARED_DIRECTIVES, SliderCustomMessagesComponent, SliderMessages, SliderBase, SlidersCommonModule, SwitchCustomMessagesComponent, Messages, TextFieldsBase, TextBoxCustomMessagesComponent, TextBoxMessages, SliderComponent, RangeSliderComponent, LabelTemplateDirective, SwitchComponent, TextBoxDirective, TextAreaDirective, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, MaskedTextBoxComponent, InputsModule, SliderTicksComponent, SliderModule, RangeSliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, TextBoxModule, TextAreaModule, CheckBoxModule, RadioButtonModule, ColorPickerComponent, ColorPaletteComponent, ColorGradientComponent, ColorPickerModule, FlatColorPickerComponent, CheckBoxDirective, RadioButtonDirective, HintComponent, ErrorComponent, FormFieldComponent, FormFieldModule, TextBoxComponent, TextBoxPrefixTemplateDirective, TextBoxSuffixTemplateDirective, TextAreaComponent, TextAreaSuffixComponent, InputSeparatorComponent, SharedModule, LocalizedColorPickerMessagesDirective, LocalizedNumericTextBoxMessagesDirective, LocalizedTextBoxMessagesDirective, LocalizedSliderMessagesDirective, LocalizedRangeSliderMessagesDirective, LocalizedSwitchMessagesDirective, ColorPickerCancelEvent, ColorPickerCloseEvent, ColorPickerOpenEvent, ActiveColorClickEvent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBKQUFFO0FBQ0YscUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b1ZBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1T0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQXlGRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRPQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBb0ZHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsySUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBa0RHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFRRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O2lEQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFZRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnS0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQTJFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrTkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O3VLQUFFO0FBQ0YsOEZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29KQUdtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBNENHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7MElBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBd0J5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OytCQWdCd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0TkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBQUU7QUFDRixvRkFVRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzsrSkFBRTtBQUNGLDhFQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OEdBZ0JpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dPQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBQUU7QUFDRiw4RkFVRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztvS0FBRTtBQUNGLHdGQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7bUhBZ0JzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRKQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBQUU7QUFDRixvRkFVRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzsrSkFBRTtBQUNGLDhFQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzJIQWVpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tEQUFFO0FBQ0Ysb0dBVUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7K0dBY3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OEdBT3dCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NEtBQUU7QUFDRiw2Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0S0FBRTtBQUNGLDZDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrTUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQStERztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b0tBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Z0tBQUU7QUFDRixnRkFXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFBRTtBQUNGLHNGQVVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7a0hBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSwyREFNNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs4REFNaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztvSUF1QmtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs4TkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQXdDRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7NkJBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSwyREFPNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztxSUFlbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvTUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnTkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NEtBRzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswTUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lGQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FvR0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzB0QkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUE4Skc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VNQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttS0FHd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MElBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REF5REc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQWlERztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFrQkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1UkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBdUdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpS0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REE4Rkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dnQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O29LQUFFO0FBQ0Ysd0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBQUU7QUFDRiw4RkFVRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBKQUFFO0FBQ0YsdUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozt3REFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQWlCRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztxRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0E0Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7MkRBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFROEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Y0FnQnNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozt5REFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzJGQU9tQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O3FDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OEZBT3NCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs2QkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFRbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OzZCQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFRa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dEQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBbUJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs0RkFPb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQmlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIxIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fcGFyYW0sIF9fbWV0YWRhdGEgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBpc0Rldk1vZGUsIERpcmVjdGl2ZSwgT3B0aW9uYWwsIFRlbXBsYXRlUmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIEhvc3RCaW5kaW5nLCBWaWV3Q2hpbGQsIEVsZW1lbnRSZWYsIENvbnRlbnRDaGlsZCwgQ29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3RvciwgUmVuZGVyZXIyLCBOZ1pvbmUsIENoYW5nZURldGVjdG9yUmVmLCBJbmplY3QsIEluamVjdGFibGUsIEhvc3RMaXN0ZW5lciwgVmlld0NoaWxkcmVuLCBRdWVyeUxpc3QsIE5nTW9kdWxlLCBWaWV3Q29udGFpbmVyUmVmLCBDb250ZW50Q2hpbGRyZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCwgTkdfVkFMVUVfQUNDRVNTT1IsIE5HX1ZBTElEQVRPUlMsIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIGZyb21FdmVudCwgaW50ZXJ2YWwsIG1lcmdlLCBCZWhhdmlvclN1YmplY3QsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2UsIGZpbHRlciwgY29uY2F0TWFwLCBzdGFydFdpdGgsIHRha2VVbnRpbCwgc2tpcCwgZGVib3VuY2VUaW1lLCB0aHJvdHRsZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCwgUlRMLCBDb21wb25lbnRNZXNzYWdlcywgTWVzc2FnZVNlcnZpY2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IEtleXMsIGd1aWQsIGhhc09ic2VydmVycywgYW55Q2hhbmdlZCwgaXNEb2N1bWVudEF2YWlsYWJsZSwgS2VuZG9JbnB1dCwgaXNDaGFuZ2VkLCBEcmFnZ2FibGVNb2R1bGUsIEV2ZW50c01vZHVsZSwgUmVzaXplU2Vuc29yTW9kdWxlLCBQcmV2ZW50YWJsZUV2ZW50LCBjbG9zZXN0IH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY29tbW9uJztcbmltcG9ydCB7IHZhbGlkYXRlUGFja2FnZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1saWNlbnNpbmcnO1xuaW1wb3J0IHsgYnJvd3NlciwgbW9iaWxlT1MsIGRldGVjdERlc2t0b3BCcm93c2VyLCBkZXRlY3RNb2JpbGVPUyB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1jb21tb24nO1xuaW1wb3J0IHsgSW50bFNlcnZpY2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnRsJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBQb3B1cFNlcnZpY2UsIFBvcHVwTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcG9wdXAnO1xuaW1wb3J0IHsgQ29sb3IsIHBhcnNlQ29sb3IsIG5hbWVkQ29sb3JzIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWRyYXdpbmcnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC4gRmFsc3kgdmFsdWVzIGxpa2UgJycsIDAsIGZhbHNlLCBOYU4sIGV0Yy4gYXJlIHJlZ2FyZGVkIGFzIHByZXNlbnQuXG4gKi9cbmNvbnN0IGlzUHJlc2VudCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBhcmVTYW1lID0gKHZhbHVlMSwgdmFsdWUyKSA9PiB2YWx1ZTEgPT09IHZhbHVlMiB8fCAodmFsdWUxID09PSBudWxsICYmIHZhbHVlMiA9PT0gdW5kZWZpbmVkKSB8fCAodmFsdWUxID09PSB1bmRlZmluZWQgJiYgdmFsdWUyID09PSBudWxsKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCByZXF1aXJlc1pvbmVPbkJsdXIgPSAobmdDb250cm9sKSA9PiBuZ0NvbnRyb2wgJiZcbiAgICAoIW5nQ29udHJvbC50b3VjaGVkIHx8IChuZ0NvbnRyb2wuY29udHJvbCAmJiBuZ0NvbnRyb2wuY29udHJvbC51cGRhdGVPbiA9PT0gJ2JsdXInKSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBGaXRzIHRoZSBjb250ZW5kZXIgbnVtYmVyIGludG8gdGhlIHNwZWNpZmllZCBib3VuZHMuIElmIHRoZSBudW1iZXIgaXMgTmFOIG9yIG51bGwsIHRoZSBtaW4gaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGNvbnRlbmRlciBSZXByZXNlbnRzIHRoZSBudW1iZXIgeW91IHdhbnQgdG8gZml0IGludG8gc3BlY2lmaWVkIGJvdW5kcy5cbiAqIEBwYXJhbSBtaW4gVGhlIGluY2x1c2l2ZSBsb3dlciBib3VuZCBudW1iZXIuXG4gKiBAcGFyYW0gbWF4IFRoZSBpbmNsdXNpdmUgdXBwZXIgYm91bmQgbnVtYmVyLlxuICovXG5jb25zdCBmaXRJbnRvQm91bmRzID0gKGNvbnRlbmRlciwgbWluLCBtYXgpID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudChjb250ZW5kZXIpIHx8IGlzTmFOKGNvbnRlbmRlcikpIHtcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbmRlciA8PSBtaW4gPyBtaW4gOiBjb250ZW5kZXIgPj0gbWF4ID8gbWF4IDogY29udGVuZGVyO1xufTtcbmNvbnN0IFNJWkVTID0ge1xuICAgIHNtYWxsOiAnc20nLFxuICAgIG1lZGl1bTogJ21kJyxcbiAgICBsYXJnZTogJ2xnJ1xufTtcbmNvbnN0IFJPVU5ETkVTUyA9IHtcbiAgICBzbWFsbDogJ3NtJyxcbiAgICBtZWRpdW06ICdtZCcsXG4gICAgbGFyZ2U6ICdsZycsXG4gICAgZnVsbDogJ2Z1bGwnXG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmV0dXJucyB0aGUgc3R5bGluZyBjbGFzc2VzIHRvIGJlIGFkZGVkIGFuZCByZW1vdmVkXG4gKi9cbmNvbnN0IGdldFN0eWxpbmdDbGFzc2VzID0gKGNvbXBvbmVudFR5cGUsIHN0eWxpbmdPcHRpb24sIHByZXZpb3VzVmFsdWUsIG5ld1ZhbHVlKSA9PiB7XG4gICAgc3dpdGNoIChzdHlsaW5nT3B0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3NpemUnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b1JlbW92ZTogYGstJHtjb21wb25lbnRUeXBlfS0ke1NJWkVTW3ByZXZpb3VzVmFsdWVdfWAsXG4gICAgICAgICAgICAgICAgdG9BZGQ6IG5ld1ZhbHVlID8gYGstJHtjb21wb25lbnRUeXBlfS0ke1NJWkVTW25ld1ZhbHVlXX1gIDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAncm91bmRlZCc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvUmVtb3ZlOiBgay1yb3VuZGVkLSR7Uk9VTkRORVNTW3ByZXZpb3VzVmFsdWVdfWAsXG4gICAgICAgICAgICAgICAgdG9BZGQ6IG5ld1ZhbHVlID8gYGstcm91bmRlZC0ke1JPVU5ETkVTU1tuZXdWYWx1ZV19YCA6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2ZpbGxNb2RlJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9SZW1vdmU6IGBrLSR7Y29tcG9uZW50VHlwZX0tJHtwcmV2aW91c1ZhbHVlfWAsXG4gICAgICAgICAgICAgICAgdG9BZGQ6IG5ld1ZhbHVlID8gYGstJHtjb21wb25lbnRUeXBlfS0ke25ld1ZhbHVlfWAgOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE1BWF9QUkVDSVNJT04gPSAyMDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBsaW1pdFByZWNpc2lvbiA9IChwcmVjaXNpb24pID0+IE1hdGgubWluKHByZWNpc2lvbiwgTUFYX1BSRUNJU0lPTik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZnJhY3Rpb25MZW5ndGggPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gKFN0cmluZyh2YWx1ZSkuc3BsaXQoJy4nKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG59O1xuY29uc3QgbWF4RnJhY3Rpb25MZW5ndGggPSAodmFsdWUxLCB2YWx1ZTIpID0+IHtcbiAgICByZXR1cm4gTWF0aC5tYXgoZnJhY3Rpb25MZW5ndGgodmFsdWUxKSwgZnJhY3Rpb25MZW5ndGgodmFsdWUyKSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHRvRml4ZWRQcmVjaXNpb24gPSAodmFsdWUsIHByZWNpc2lvbikgPT4ge1xuICAgIGNvbnN0IG1heFByZWNpc2lvbiA9IGxpbWl0UHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUudG9GaXhlZChtYXhQcmVjaXNpb24pKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgYWRkID0gKHZhbHVlMSwgdmFsdWUyKSA9PiB7XG4gICAgY29uc3QgbWF4UHJlY2lzaW9uID0gbWF4RnJhY3Rpb25MZW5ndGgodmFsdWUxLCB2YWx1ZTIpO1xuICAgIHJldHVybiB0b0ZpeGVkUHJlY2lzaW9uKHZhbHVlMSArIHZhbHVlMiwgbWF4UHJlY2lzaW9uKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc3VidHJhY3QgPSAodmFsdWUxLCB2YWx1ZTIpID0+IHtcbiAgICByZXR1cm4gYWRkKHZhbHVlMSwgLXZhbHVlMik7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG11bHRpcGx5ID0gKHZhbHVlMSwgdmFsdWUyKSA9PiB7XG4gICAgY29uc3QgbWF4UHJlY2lzaW9uID0gZnJhY3Rpb25MZW5ndGgodmFsdWUxKSArIGZyYWN0aW9uTGVuZ3RoKHZhbHVlMik7XG4gICAgcmV0dXJuIHRvRml4ZWRQcmVjaXNpb24odmFsdWUxICogdmFsdWUyLCBtYXhQcmVjaXNpb24pO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkaXZpZGUgPSAoZGl2aWRlbmQsIGRpdmlzb3IpID0+IHtcbiAgICBpZiAoZGl2aXNvciA9PT0gMCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBwb3dlciA9IG1heEZyYWN0aW9uTGVuZ3RoKGRpdmlkZW5kLCBkaXZpc29yKTtcbiAgICBjb25zdCBjb3JyZWN0aW9uVmFsdWUgPSBNYXRoLnBvdygxMCwgcG93ZXIpO1xuICAgIHJldHVybiAoKGNvcnJlY3Rpb25WYWx1ZSAqIGRpdmlkZW5kKSAvIChjb3JyZWN0aW9uVmFsdWUgKiBkaXZpc29yKSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHJlbWFpbmRlciA9IChkaXZpZGVuZCwgZGl2aXNvcikgPT4ge1xuICAgIHJldHVybiBNYXRoLmFicyhzdWJ0cmFjdChkaXZpZGVuZCwgbXVsdGlwbHkoZGl2aXNvciwgTWF0aC5mbG9vcihkaXZpZGUoZGl2aWRlbmQsIGRpdmlzb3IpKSkpKTtcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjYWxjdWxhdGVGaXhlZFRyYWNrU2l6ZSA9ICh7IG1heCwgbWluLCBzbWFsbFN0ZXAsIGZpeGVkVGlja1dpZHRoIH0pID0+ICgobWF4IC0gbWluKSAvIHNtYWxsU3RlcCkgKiBmaXhlZFRpY2tXaWR0aDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjYWxjdWxhdGVUaWNrc0NvdW50ID0gKG1pbiA9IDAsIG1heCA9IDAsIHNtYWxsU3RlcCA9IDEpID0+IHtcbiAgICBpZiAoc21hbGxTdGVwIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiBzbWFsbFN0ZXAgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBjb25zdCBhZGp1c3RlZFJhbmdlID0gTWF0aC5hYnMoc3VidHJhY3QobWF4LCBtaW4pKTtcbiAgICBjb25zdCBhZGp1c3RlZFJhdGlvID0gTWF0aC5mbG9vcihkaXZpZGUoYWRqdXN0ZWRSYW5nZSwgc21hbGxTdGVwKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYWRkKGFkanVzdGVkUmF0aW8sIDEpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZVZhbHVlRnJvbVRpY2sgPSAoaW5kZXgsIHsgbWF4LCBtaW4sIHNtYWxsU3RlcCwgcmV2ZXJzZSwgdmVydGljYWwgfSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gYWRkKG1pbiwgbXVsdGlwbHkoaW5kZXgsIHNtYWxsU3RlcCkpO1xuICAgIHJldHVybiB2ZXJ0aWNhbCB8fCByZXZlcnNlID8gTWF0aC5hYnMoc3VidHJhY3QodmFsdWUsIG1heCkpIDogdmFsdWU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZUhhbmRsZVBvc2l0aW9uID0gKHsgdHJhY2tXaWR0aCwgbWluLCBtYXgsIHJldmVyc2UsIHZhbHVlIH0pID0+IHtcbiAgICBjb25zdCBzdGVwID0gdHJhY2tXaWR0aCAvIE1hdGguYWJzKG1heCAtIG1pbik7XG4gICAgbGV0IHBvcyA9IGlzUHJlc2VudCh2YWx1ZSkgPyBzdGVwICogKHZhbHVlIC0gbWluKSA6IG1pbjtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICBwb3MgPSB0cmFja1dpZHRoIC0gcG9zO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcihwb3MpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkZWNyZWFzZVZhbHVlVG9TdGVwID0gKHZhbHVlLCB7IG1heCwgbWluLCBzbWFsbFN0ZXAsIGxhcmdlU3RlcCB9LCBsYXJnZSA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3Qgc3RlcCA9IGxhcmdlICYmIGxhcmdlU3RlcCA/IG11bHRpcGx5KHNtYWxsU3RlcCwgbGFyZ2VTdGVwKSA6IHNtYWxsU3RlcDtcbiAgICBjb25zdCBzdGVwVmFsdWUgPSBzdWJ0cmFjdCh2YWx1ZSwgbWluKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IHN0ZXBSZW1haW5kZXIgPSByZW1haW5kZXIoc3RlcFZhbHVlLCBzdGVwKTtcbiAgICBpZiAoc3RlcFJlbWFpbmRlciA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBzdWJ0cmFjdChzdGVwVmFsdWUsIHN0ZXApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gc3VidHJhY3Qoc3RlcFZhbHVlLCBzdGVwUmVtYWluZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbWl0VmFsdWUoYWRkKHJlc3VsdCwgbWluKSwgbWluLCBtYXgpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpbmNyZWFzZVZhbHVlVG9TdGVwID0gKHZhbHVlLCB7IG1heCwgbWluLCBzbWFsbFN0ZXAsIGxhcmdlU3RlcCB9LCBsYXJnZSA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3Qgc3RlcCA9IGxhcmdlICYmIGxhcmdlU3RlcCA/IG11bHRpcGx5KHNtYWxsU3RlcCwgbGFyZ2VTdGVwKSA6IHNtYWxsU3RlcDtcbiAgICBjb25zdCBzdGVwVmFsdWUgPSBzdWJ0cmFjdCh2YWx1ZSwgbWluKTtcbiAgICBjb25zdCBzdGVwUmVtYWluZGVyID0gcmVtYWluZGVyKHN0ZXBWYWx1ZSwgc3RlcCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYWRkKHN1YnRyYWN0KHN0ZXBWYWx1ZSwgc3RlcFJlbWFpbmRlciksIHN0ZXApO1xuICAgIHJldHVybiBsaW1pdFZhbHVlKGFkZChyZXN1bHQsIG1pbiksIG1pbiwgbWF4KTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNTdGFydEhhbmRsZSA9IChkcmFnSGFuZGxlKSA9PiBkcmFnSGFuZGxlLmlkLmluZGV4T2YoJ2stc3RhcnQtaGFuZGxlJykgPiAtMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzbmFwVmFsdWUgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IHNtYWxsU3RlcCwgbWluLCBtYXggfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgbGltaXRlZCA9IGxpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KTtcbiAgICBpZiAodmFsdWUgIT09IGxpbWl0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGxpbWl0ZWQ7XG4gICAgfVxuICAgIGNvbnN0IGxlZnQgPSBkZWNyZWFzZVZhbHVlVG9TdGVwKHZhbHVlLCBvcHRpb25zKTtcbiAgICBjb25zdCByaWdodCA9IGluY3JlYXNlVmFsdWVUb1N0ZXAodmFsdWUsIG9wdGlvbnMpO1xuICAgIGlmICgodmFsdWUgLSBtaW4pICUgc21hbGxTdGVwID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0IC0gdmFsdWUgPD0gKHJpZ2h0IC0gbGVmdCkgLyAyKSB7XG4gICAgICAgIHJldHVybiByaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHRyaW1WYWx1ZSA9IChtYXgsIG1pbiwgdmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdHJpbVZhbHVlUmFuZ2UgPSAobWF4LCBtaW4sIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlID8gW3RyaW1WYWx1ZShtYXgsIG1pbiwgdmFsdWVbMF0pLCB0cmltVmFsdWUobWF4LCBtaW4sIHZhbHVlWzFdKV0gOiBbbWluLCBtaW5dO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpZGVudGl0eSA9ICh2YWx1ZSkgPT4gdmFsdWU7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNTYW1lUmFuZ2UgPSAodmFsdWUxLCB2YWx1ZTIpID0+IGFyZVNhbWUodmFsdWUxWzBdLCB2YWx1ZTJbMF0pICYmIGFyZVNhbWUodmFsdWUxWzFdLCB2YWx1ZTJbMV0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGVsZW1lbnRPZmZzZXQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGJveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGJveC5sZWZ0ICsgKHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCkgLSAoZG9jdW1lbnRFbGVtZW50LmNsaWVudExlZnQgfHwgMCksXG4gICAgICAgIHRvcDogYm94LnRvcCArICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkgLSAoZG9jdW1lbnRFbGVtZW50LmNsaWVudFRvcCB8fCAwKVxuICAgIH07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGxpbWl0VmFsdWUgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHZhbHVlLCBtYXgpLCBtaW4pO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBldmVudFZhbHVlID0gKGV2ZW50QXJncywgc2NhbGVFbGVtZW50LCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBtaW4sIG1heCwgdmVydGljYWwsIHJ0bCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB0cmFja09mZnNldCA9IGVsZW1lbnRPZmZzZXQoc2NhbGVFbGVtZW50KTtcbiAgICBjb25zdCBvZmZzZXQgPSB2ZXJ0aWNhbCA/IGV2ZW50QXJncy5wYWdlWSAtIHRyYWNrT2Zmc2V0LnRvcCA6IGV2ZW50QXJncy5wYWdlWCAtIHRyYWNrT2Zmc2V0LmxlZnQ7XG4gICAgY29uc3Qgc2NhbGUgPSAobWF4IC0gbWluKSAvICh2ZXJ0aWNhbCA/IHNjYWxlRWxlbWVudC5jbGllbnRIZWlnaHQgOiBzY2FsZUVsZW1lbnQuY2xpZW50V2lkdGgpO1xuICAgIGNvbnN0IG9mZnNldFZhbHVlID0gb2Zmc2V0ICogc2NhbGU7XG4gICAgbGV0IHZhbHVlID0gcnRsIHx8IHZlcnRpY2FsID8gbWF4IC0gb2Zmc2V0VmFsdWUgOiBtaW4gKyBvZmZzZXRWYWx1ZTtcbiAgICBjb25zdCBzdGVwRnJhY3Rpb25MZW5ndGggPSBmcmFjdGlvbkxlbmd0aChvcHRpb25zLnNtYWxsU3RlcCk7XG4gICAgdmFsdWUgPSB0b0ZpeGVkUHJlY2lzaW9uKHZhbHVlLCBzdGVwRnJhY3Rpb25MZW5ndGggKyAxKTtcbiAgICByZXR1cm4gc25hcFZhbHVlKHZhbHVlLCBvcHRpb25zKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNCdXR0b24gPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKCdrLWJ1dHRvbi1pbmNyZWFzZScpID49IDAgfHwgZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZignay1idXR0b24tZGVjcmVhc2UnKSA+PSAwO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpbmNyZW1lbnQgPSAob3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBpbmNyZWFzZVZhbHVlVG9TdGVwKG9wdGlvbnMudmFsdWUsIG9wdGlvbnMpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkZWNyZW1lbnQgPSAob3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBkZWNyZWFzZVZhbHVlVG9TdGVwKG9wdGlvbnMudmFsdWUsIG9wdGlvbnMpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpbmNyZW1lbnRMYXJnZSA9IChvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGluY3JlYXNlVmFsdWVUb1N0ZXAob3B0aW9ucy52YWx1ZSwgb3B0aW9ucywgdHJ1ZSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRlY3JlbWVudExhcmdlID0gKG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gZGVjcmVhc2VWYWx1ZVRvU3RlcChvcHRpb25zLnZhbHVlLCBvcHRpb25zLCB0cnVlKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdmFsaWRhdGVWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmIChpc0Rldk1vZGUgJiYgdmFsdWUgJiYgdmFsdWVbMF0gPiB2YWx1ZVsxXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tSYW5nZVNsaWRlcl0gVGhlIHN0YXJ0IHZhbHVlIHNob3VsZCBub3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBlbmQgdmFsdWUuJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNsaWRlck1vZGVsQmFzZSB7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIHdyYXBwZXIsIHRyYWNrLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICAgIHRoaXMudHJhY2sgPSB0cmFjaztcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICAgIHRoaXMudHJhY2sgPSB0cmFjaztcbiAgICAgICAgdGhpcy50aWNrU2l6ZXMgPSB0aGlzLmdldFRpY2tTaXplcygpO1xuICAgIH1cbiAgICByZXNpemVUcmFjaygpIHtcbiAgICAgICAgY29uc3Qgb3JpZW50YXRpb24gPSB0aGlzLnByb3BzLnZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICBjb25zdCBhbHRPcmllbnRhdGlvbiA9IHRoaXMucHJvcHMudmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IHRyYWNrV2lkdGggPSB0aGlzLnRyYWNrV2lkdGgoKTtcbiAgICAgICAgdGhpcy50cmFjay5wYXJlbnRFbGVtZW50LnN0eWxlW29yaWVudGF0aW9uXSA9IGAke3RyYWNrV2lkdGh9cHhgO1xuICAgICAgICB0aGlzLnRyYWNrLnBhcmVudEVsZW1lbnQuc3R5bGVbYWx0T3JpZW50YXRpb25dID0gJyc7XG4gICAgfVxuICAgIHJlc2l6ZVRpY2tzKHRpY2tzQ29udGFpbmVyLCB0aWNrcykge1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLnByb3BzLnZlcnRpY2FsID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgICAgICAgWy4uLnRpY2tzXS5tYXAoKHRpY2ssIGluZGV4KSA9PiB0aWNrLnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLnRpY2tTaXplc1tpbmRleF19cHhgKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudmVydGljYWwpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0UGFkZGluZyh0aWNrc0NvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzaXplV3JhcHBlcigpIHtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5wcm9wcy52ZXJ0aWNhbCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG4gICAgICAgIGNvbnN0IGZpeGVkVHJhY2tXaWR0aCA9IGNhbGN1bGF0ZUZpeGVkVHJhY2tTaXplKHRoaXMucHJvcHMpO1xuICAgICAgICBjb25zdCB3cmFwcGVyUGFyZW50RWwgPSB0aGlzLndyYXBwZXIucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKGZpeGVkVHJhY2tXaWR0aCkge1xuICAgICAgICAgICAgd3JhcHBlclBhcmVudEVsLnN0eWxlW2RpbWVuc2lvbl0gPSBcImF1dG9cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFja1dpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5maXhlZFRpY2tXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUZpeGVkVHJhY2tTaXplKHRoaXMucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRTaXplKHRoaXMudHJhY2sucGFyZW50RWxlbWVudCk7XG4gICAgfVxuICAgIGdldFRpY2tTaXplcygpIHtcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCwgc21hbGxTdGVwIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBjb3VudCA9IGNhbGN1bGF0ZVRpY2tzQ291bnQobWluLCBtYXgsIHNtYWxsU3RlcCk7XG4gICAgICAgIGNvbnN0IHRyYWNrU2l6ZSA9IHRoaXMudHJhY2tXaWR0aCgpO1xuICAgICAgICBjb25zdCBkaXN0U3RlcCA9IHRyYWNrU2l6ZSAvIHN1YnRyYWN0KG1heCwgbWluKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCB1c2VkU3BhY2UgPSAwO1xuICAgICAgICBsZXQgZW5kUG9pbnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGNvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgIGVuZFBvaW50ICs9IChzbWFsbFN0ZXAgLyAyKSAqIGRpc3RTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kUG9pbnQgKz0gc21hbGxTdGVwICogZGlzdFN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgc3VtIG9mIHRoZSB0aWNrIHNpemVzIGRvZXMgbm90IGV4Y2VlZCB0aGUgdHJhY2sgd2lkdGhcbiAgICAgICAgICAgIGVuZFBvaW50ID0gK2VuZFBvaW50LnRvRml4ZWQoMikgLSAwLjAxO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQoZW5kUG9pbnQgLSB1c2VkU3BhY2UpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc2l6ZSk7XG4gICAgICAgICAgICB1c2VkU3BhY2UgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlZFNwYWNlID49IHRyYWNrU2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFkanVzdFBhZGRpbmcodGlja3NDb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgdG90YWxUaWNrU2l6ZSA9IHRoaXMudGlja1NpemVzLnJlZHVjZSgocHJldiwgY3VycikgPT4gcHJldiArIGN1cnIsIDApO1xuICAgICAgICBjb25zdCB0cmFja1dpZHRoID0gdGhpcy50cmFja1dpZHRoKCk7XG4gICAgICAgIGNvbnN0IHJlbWluZGVyID0gdHJhY2tXaWR0aCAtIHRvdGFsVGlja1NpemU7XG4gICAgICAgIGlmIChyZW1pbmRlciAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFkZGluZyA9IHJlbWluZGVyICsgdGhpcy5lbGVtZW50T2Zmc2V0KHRoaXMudHJhY2spO1xuICAgICAgICAgICAgdGlja3NDb250YWluZXIuc3R5bGUucGFkZGluZ1RvcCA9IGAke3BhZGRpbmd9cHhgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRPZmZzZXQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCB7IHZlcnRpY2FsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2ZXJ0aWNhbCA/IHN0eWxlLmJvdHRvbSA6IHN0eWxlLmxlZnQsIDEwKTtcbiAgICB9XG4gICAgZWxlbWVudFNpemUoZWxlbWVudCkge1xuICAgICAgICBjb25zdCB7IHZlcnRpY2FsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gdmVydGljYWwgPyBlbGVtZW50LmNsaWVudEhlaWdodCA6IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2xpZGVyTW9kZWwgZXh0ZW5kcyBTbGlkZXJNb2RlbEJhc2Uge1xuICAgIHBvc2l0aW9uSGFuZGxlKGRyYWdIYW5kbGUpIHtcbiAgICAgICAgY29uc3QgeyBtYXgsIG1pbiwgcmV2ZXJzZSwgdmVydGljYWwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdmVydGljYWwgPyAnYm90dG9tJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgdHJhY2tXaWR0aCA9IHRoaXMudHJhY2tXaWR0aCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRyaW1WYWx1ZShtYXgsIG1pbiwgdGhpcy5wcm9wcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9zaXRpb24gPSBjYWxjdWxhdGVIYW5kbGVQb3NpdGlvbih7XG4gICAgICAgICAgICBtaW4sXG4gICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICByZXZlcnNlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0cmFja1dpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGRyYWdIYW5kbGUsIHBvc2l0aW9uLCBgJHt0aGlzLmhhbmRsZVBvc2l0aW9ufXB4YCk7XG4gICAgfVxuICAgIHBvc2l0aW9uU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCB7IHJldmVyc2UsIHZlcnRpY2FsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB2ZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLmhhbmRsZVBvc2l0aW9uO1xuICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgc2l6ZSA9IHRoaXMudHJhY2tXaWR0aCgpIC0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHNlbGVjdGlvbiwgZGltZW5zaW9uLCBgJHtzaXplfXB4YCk7XG4gICAgfVxufVxuXG5jb25zdCBVTlRPVUNIRUQgPSAnbmctdW50b3VjaGVkJztcbmNvbnN0IHRvQ2xhc3NMaXN0ID0gKGNsYXNzTmFtZXMpID0+IFN0cmluZyhjbGFzc05hbWVzKS50cmltKCkuc3BsaXQoJyAnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNDbGFzcyA9IChlbGVtZW50LCBjbGFzc05hbWUpID0+IEJvb2xlYW4odG9DbGFzc0xpc3QoZWxlbWVudC5jbGFzc05hbWUpLmZpbmQoKG5hbWUpID0+IG5hbWUgPT09IGNsYXNzTmFtZSkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGludm9rZUVsZW1lbnRNZXRob2QoZWxlbWVudCwgbmFtZSwgLi4uYXJncykge1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5uYXRpdmVFbGVtZW50W25hbWVdLmFwcGx5KGVsZW1lbnQubmF0aXZlRWxlbWVudCwgYXJncyk7XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzVW50b3VjaGVkID0gKGVsZW1lbnQpID0+IGVsZW1lbnQgJiYgZWxlbWVudC5uYXRpdmVFbGVtZW50ICYmIGhhc0NsYXNzKGVsZW1lbnQubmF0aXZlRWxlbWVudCwgVU5UT1VDSEVEKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjb250YWluc0ZvY3VzID0gKGhvc3RFbGVtZW50LCBjb250ZW5kZXIpID0+IGhvc3RFbGVtZW50ICYmIGNvbnRlbmRlciAmJiAoaG9zdEVsZW1lbnQgPT09IGNvbnRlbmRlciB8fCBob3N0RWxlbWVudC5jb250YWlucyhjb250ZW5kZXIpKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0JDEgPSAobm9kZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIXByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYWNrYWdlTWV0YWRhdGEgPSB7XG4gICAgbmFtZTogJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWlucHV0cycsXG4gICAgcHJvZHVjdE5hbWU6ICdLZW5kbyBVSSBmb3IgQW5ndWxhcicsXG4gICAgcHJvZHVjdENvZGVzOiBbJ0tFTkRPVUlBTkdVTEFSJywgJ0tFTkRPVUlDT01QTEVURSddLFxuICAgIHB1Ymxpc2hEYXRlOiAxNjQ4MjExOTE2LFxuICAgIHZlcnNpb246ICcnLFxuICAgIGxpY2Vuc2luZ0RvY3NVcmw6ICdodHRwczovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL215LWxpY2Vuc2UvP3V0bV9tZWRpdW09cHJvZHVjdCZ1dG1fc291cmNlPWtlbmRvYW5ndWxhciZ1dG1fY2FtcGFpZ249a2VuZG8tdWktYW5ndWxhci1wdXJjaGFzZS1saWNlbnNlLWtleXMtd2FybmluZydcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGVtcGxhdGUgZm9yIHRoZSBsYWJlbHMgb2YgdGhlIFNsaWRlci5cbiAqIFRvIGRlZmluZSB0aGUgbGFiZWxzIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvU2xpZGVyTGFiZWxUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZVxuICogdGhlIGA8a2VuZG8tc2xpZGVyPmAgdGFnLiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBwYXNzZWQgdG8gdGhlIGBsYWJlbGAgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgPGtlbmRvLXNsaWRlciBbbGFyZ2VTdGVwXT1cIjJcIj5cbiAqICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9TbGlkZXJMYWJlbFRlbXBsYXRlIGxldC12YWx1ZT1cInZhbHVlXCI+XG4gKiAgICAgICAgICAgICA8Yj57e3ZhbHVlfX08L2I+XG4gKiAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgPC9rZW5kby1zbGlkZXI+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIExhYmVsVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvU2xpZGVyTGFiZWxUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIExhYmVsVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2xpZGVyQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uU2VydmljZSwgaW5qZWN0b3IsIHJlbmRlcmVyLCBuZ1pvbmUsIGNoYW5nZURldGVjdG9yLCBob3N0RWxlbWVudCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgdGl0bGUgb2YgdGhlIHRpY2tzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdGlja3Nfc2xpZGVyICV9I3RvYy10aXRsZXMpKS4gVGhlIGRlZmF1bHQgdGl0bGVcbiAgICAgICAgICogZm9yIGVhY2ggdGljayBpcyBpdHMgU2xpZGVyIHZhbHVlLiBJZiB5b3UgdXNlIGEgY2FsbGJhY2sgZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiBhY2NlcHRzIGFuIGFyZ3VtZW50XG4gICAgICAgICAqIHRoYXQgaG9sZHMgdGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQgYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgbmV3IHRpdGxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aXRsZSA9IGlkZW50aXR5O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVub3RlcyB0aGUgbG9jYXRpb24gb2YgdGhlIHRpY2sgbWFya3MgaW4gdGhlIFNsaWRlciAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRpY2tzX3NsaWRlciAlfSN0b2MtcGxhY2VtZW50KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAgICAgICAqICogYGJlZm9yZWAmbWRhc2g7VGhlIHRpY2sgbWFya3MgYXJlIGxvY2F0ZWQgdG8gdGhlIHRvcCBzaWRlIG9mIHRoZSBob3Jpem9udGFsIHRyYWNrIG9yIHRvIHRoZSBsZWZ0IHNpZGUgb2YgYSB2ZXJ0aWNhbCB0cmFjay5cbiAgICAgICAgICogKiBgYWZ0ZXJgJm1kYXNoO1RoZSB0aWNrIG1hcmtzIGFyZSBsb2NhdGVkIHRvIHRoZSBib3R0b20gc2lkZSBvZiB0aGUgaG9yaXpvbnRhbCB0cmFjayBvciB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgdmVydGljYWwgdHJhY2suXG4gICAgICAgICAqICogYGJvdGhgJm1kYXNoOyAoRGVmYXVsdCkgVGhlIHRpY2sgbWFya3MgYXJlIGxvY2F0ZWQgb24gYm90aCBzaWRlcyBvZiB0aGUgdHJhY2suXG4gICAgICAgICAqICogYG5vbmVgJm1kYXNoO1RoZSB0aWNrIG1hcmtzIGFyZSBub3QgdmlzaWJsZS4gVGhlIGFjdHVhbCBlbGVtZW50cyBhcmUgbm90IGFkZGVkIHRvIHRoZSBET00gdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGlja1BsYWNlbWVudCA9ICdib3RoJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB2ZXJ0aWNhbGAgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBTbGlkZXIgY2hhbmdlcyBmcm9tIGhvcml6b250YWwgdG8gdmVydGljYWxcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvcmllbnRhdGlvbl9zbGlkZXIgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVydGljYWwgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHZhbHVlIG9mIHRoZSBTbGlkZXIgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwcmVkZWZpbmVkc3RlcHNfc2xpZGVyICV9I3RvYy1zbWFsbC1zdGVwcykpLlxuICAgICAgICAgKiBUaGUgYXR0cmlidXRlIGFjY2VwdHMgYm90aCBpbnRlZ2VycyBhbmQgZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWluID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBTbGlkZXIgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwcmVkZWZpbmVkc3RlcHNfc2xpZGVyICV9I3RvYy1zbWFsbC1zdGVwcykpLlxuICAgICAgICAgKiBUaGUgYXR0cmlidXRlIGFjY2VwdHMgYm90aCBpbnRlZ2VycyBhbmQgZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4ID0gMTA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3RlcCB2YWx1ZSBvZiB0aGUgU2xpZGVyIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcHJlZGVmaW5lZHN0ZXBzX3NsaWRlciAlfSN0b2Mtc21hbGwtc3RlcHMpKS5cbiAgICAgICAgICogQWNjZXB0cyBwb3NpdGl2ZSB2YWx1ZXMgb25seS4gQ2FuIGJlIGFuIGludGVnZXIgb3IgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNtYWxsU3RlcCA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBldmVyeSBuPHN1cD50aDwvc3VwPiB0aWNrIHdpbGwgYmUgbGFyZ2UgYW5kIHdpbGwgaGF2ZSBhIGxhYmVsXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcHJlZGVmaW5lZHN0ZXBzX3NsaWRlciAlfSN0b2MtbGFyZ2Utc3RlcHMpKS5cbiAgICAgICAgICogQWNjZXB0cyBwb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlcyBvbmx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXJnZVN0ZXAgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBTbGlkZXIgaXMgZGlzYWJsZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZHN0YXRlX3NsaWRlciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBTbGlkZXIgaXMgaW4gaXRzIHJlYWQtb25seSBzdGF0ZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlYWRvbmx5X3NsaWRlciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBbdGFiaW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBTbGlkZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBmb2N1c2VzIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGNvbXBvbmVudCBpcyBibHVycmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgc2VsZWN0cyBhIG5ldyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQ2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLndpZGdldENsYXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZkVuYWJsZWQgPSAoY2FsbGJhY2ssIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBsb2NhbGl6YXRpb25TZXJ2aWNlLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuICAgIGdldCBob3Jpem9udGFsQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy52ZXJ0aWNhbDtcbiAgICB9XG4gICAgZ2V0IHZlcnRpY2FsQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgc3RhdHVzIG9mIHRoZSBjb21wb25lbnQgY2hhbmdlcyB0byBvciBmcm9tIGBkaXNhYmxlZGAuXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSwgaXQgZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgYXBwcm9wcmlhdGUgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXNEaXNhYmxlZFxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlXG4gICAgICAgICAgICAuY2hhbmdlc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgoeyBydGwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICAgICAgdGhpcy5zaXplQ29tcG9uZW50KCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHRoaXMuaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgXCJ0YWJpbmRleFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRyb2wgPSB0aGlzLmluamVjdG9yLmdldChOZ0NvbnRyb2wsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzRGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIGJ5IHRoZSBGbG9hdGluZ0xhYmVsIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHJldmVyc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UucnRsICYmICF0aGlzLnZlcnRpY2FsO1xuICAgIH1cbiAgICBnZXQga2V5QmluZGluZygpIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZSA9IHRoaXMucmV2ZXJzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtLZXlzLkFycm93TGVmdF06IHJldmVyc2UgPyBpbmNyZW1lbnQgOiBkZWNyZW1lbnQsXG4gICAgICAgICAgICBbS2V5cy5BcnJvd1JpZ2h0XTogcmV2ZXJzZSA/IGRlY3JlbWVudCA6IGluY3JlbWVudCxcbiAgICAgICAgICAgIFtLZXlzLkFycm93RG93bl06IGRlY3JlbWVudCxcbiAgICAgICAgICAgIFtLZXlzLkFycm93VXBdOiBpbmNyZW1lbnQsXG4gICAgICAgICAgICBbS2V5cy5QYWdlVXBdOiBpbmNyZW1lbnRMYXJnZSxcbiAgICAgICAgICAgIFtLZXlzLlBhZ2VEb3duXTogZGVjcmVtZW50TGFyZ2UsXG4gICAgICAgICAgICBbS2V5cy5Ib21lXTogKHsgbWluIH0pID0+IG1pbixcbiAgICAgICAgICAgIFtLZXlzLkVuZF06ICh7IG1heCB9KSA9PiBtYXhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVzZXRTdHlsZXMoZWxlbWVudHMpIHtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZVN0eWxlKGVsLCAnd2lkdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVTdHlsZShlbCwgJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVTdHlsZShlbCwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZVN0eWxlKGVsLCAnaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlU3R5bGUoZWwsICdib3R0b20nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVTdHlsZShlbCwgJ3BhZGRpbmctdG9wJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgU2xpZGVyQmFzZS5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcInRpY2tQbGFjZW1lbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTbGlkZXJCYXNlLnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2xpZGVyQmFzZS5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTbGlkZXJCYXNlLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcInNtYWxsU3RlcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2xpZGVyQmFzZS5wcm90b3R5cGUsIFwibGFyZ2VTdGVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTbGlkZXJCYXNlLnByb3RvdHlwZSwgXCJmaXhlZFRpY2tXaWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2xpZGVyQmFzZS5wcm90b3R5cGUsIFwicmVhZG9ubHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2ZvY3VzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcIm9uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnYmx1cicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBTbGlkZXJCYXNlLnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBTbGlkZXJCYXNlLnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc2xpZGVyLWhvcml6b250YWwnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgU2xpZGVyQmFzZS5wcm90b3R5cGUsIFwiaG9yaXpvbnRhbENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc2xpZGVyLXZlcnRpY2FsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcInZlcnRpY2FsQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zbGlkZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcInNsaWRlckNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay13aWRnZXQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcIndpZGdldENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBTbGlkZXJCYXNlLnByb3RvdHlwZSwgXCJkaXNhYmxlZENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCd3cmFwJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBTbGlkZXJCYXNlLnByb3RvdHlwZSwgXCJ3cmFwcGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3RyYWNrJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBTbGlkZXJCYXNlLnByb3RvdHlwZSwgXCJ0cmFja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdzbGlkZXJTZWxlY3Rpb24nLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcInNsaWRlclNlbGVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCd0aWNrcycsIHsgcmVhZDogRWxlbWVudFJlZiwgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcInRpY2tzQ29udGFpbmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3RpY2tzJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTbGlkZXJCYXNlLnByb3RvdHlwZSwgXCJ0aWNrc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKExhYmVsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIFNsaWRlckJhc2UucHJvdG90eXBlLCBcImxhYmVsVGVtcGxhdGVcIiwgdm9pZCAwKTtcblxudmFyIFNsaWRlckNvbXBvbmVudF8xO1xuY29uc3QgUFJFU1NFRCA9ICdrLXByZXNzZWQnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgU2xpZGVyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19zbGlkZXIgJX0pLlxuICovXG5sZXQgU2xpZGVyQ29tcG9uZW50ID0gU2xpZGVyQ29tcG9uZW50XzEgPSBjbGFzcyBTbGlkZXJDb21wb25lbnQgZXh0ZW5kcyBTbGlkZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIGluamVjdG9yLCByZW5kZXJlciwgbmdab25lLCBjaGFuZ2VEZXRlY3RvciwgaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgc3VwZXIobG9jYWxpemF0aW9uLCBpbmplY3RvciwgcmVuZGVyZXIsIG5nWm9uZSwgY2hhbmdlRGV0ZWN0b3IsIGhvc3RFbGVtZW50KTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUlkID0gYGstJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIGFuaW1hdGlvbiB3aWxsIGJlIHBsYXllZCBvbiB2YWx1ZSBjaGFuZ2UuXG4gICAgICAgICAqIFJlZ2FyZGxlc3Mgb2YgdGhpcyBzZXR0aW5nLCBubyBhbmltYXRpb24gd2lsbCBiZSBwbGF5ZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlcmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIHRoZSBhcnJvdyBzaWRlIGJ1dHRvbnMgb2YgdGhlIFNsaWRlciAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNpZGVidXR0b25zX3NsaWRlciAlfSN0b2MtaGlkZGVuLXN0YXRlKSkuXG4gICAgICAgICAqIFdoZW4gYHNob3dCdXR0b25zYCBpcyBzZXQgdG8gYGZhbHNlYCwgdGhlIGJ1dHRvbnMgYXJlIG5vdCBkaXNwbGF5ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dCdXR0b25zID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBTbGlkZXIgd2hlbiBpdCBpcyBpbml0aWFsbHkgZGlzcGxheWVkLlxuICAgICAgICAgKiBUaGUgY29tcG9uZW50IGNhbiB1c2UgZWl0aGVyIE5nTW9kZWwgb3IgdGhlIGB2YWx1ZWAgYmluZGluZyBidXQgbm90IGJvdGggb2YgdGhlbSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubWluO1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25XcmFwQ2xpY2sgPSAoYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXJncy50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZCAmJiAhKGlzQnV0dG9uKHRhcmdldCkgfHwgaXNCdXR0b24odGFyZ2V0LnBhcmVudE5vZGUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXZlbnRWYWx1ZShhcmdzLCB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQsIHRoaXMuZ2V0UHJvcHMoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuZHJhZ2hhbmRsZSwgJ2ZvY3VzJyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uS2V5RG93biA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAgICAgY29uc3QgeyBtYXgsIG1pbiB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmtleUJpbmRpbmdbZS5rZXlDb2RlXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlzYWJsZWQgfHwgIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhhbmRsZXIob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlKHRyaW1WYWx1ZShtYXgsIG1pbiwgdmFsdWUpKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uZ0NoYW5nZSA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLmRlY3JlYXNlVmFsdWUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlKGRlY3JlYXNlVmFsdWVUb1N0ZXAodGhpcy52YWx1ZSwgdGhpcy5nZXRQcm9wcygpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5jcmVhc2VWYWx1ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWUoaW5jcmVhc2VWYWx1ZVRvU3RlcCh0aGlzLnZhbHVlLCB0aGlzLmdldFByb3BzKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVCbHVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uQmx1cikgfHwgcmVxdWlyZXNab25lT25CbHVyKHRoaXMuY29udHJvbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nVG91Y2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkJsdXIuZW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgdGFiSW5kZXgodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy50YWJpbmRleCA9IHRhYkluZGV4O1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYmluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUudG9TdHJpbmcoKSA6ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBTbGlkZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzLW5vLXJ1blxuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogdGVtcGxhdGU6IGBcbiAgICAgKiAgPGJ1dHRvbiAoY2xpY2spPVwic2xpZGVyLmZvY3VzKClcIj5Gb2N1czwvYnV0dG9uPlxuICAgICAqICA8a2VuZG8tc2xpZGVyICNzbGlkZXI+PC9rZW5kby1zbGlkZXI+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuZHJhZ2hhbmRsZSwgJ2ZvY3VzJyk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgU2xpZGVyLlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IHRydWU7XG4gICAgICAgIGludm9rZUVsZW1lbnRNZXRob2QodGhpcy5kcmFnaGFuZGxlLCAnYmx1cicpO1xuICAgICAgICB0aGlzLmhhbmRsZUJsdXIoKTtcbiAgICAgICAgdGhpcy5mb2N1c0NoYW5nZWRQcm9ncmFtbWF0aWNhbGx5ID0gZmFsc2U7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGFueUNoYW5nZWQoWyd2YWx1ZScsICdmaXhlZFRpY2tXaWR0aCcsICd0aWNrUGxhY2VtZW50J10sIGNoYW5nZXMsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKS5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplQ29tcG9uZW50KGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG93QnV0dG9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUNoYW5nZUludGVydmFsKHRoaXMuaW5jcmVhc2VCdXR0b24ubmF0aXZlRWxlbWVudCwgKCkgPT4gdGhpcy5pbmNyZWFzZVZhbHVlKCkpO1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUNoYW5nZUludGVydmFsKHRoaXMuZGVjcmVhc2VCdXR0b24ubmF0aXZlRWxlbWVudCwgKCkgPT4gdGhpcy5kZWNyZWFzZVZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZUNvbXBvbmVudChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLnRpY2tzKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tzLnRpY2tFbGVtZW50c1xuICAgICAgICAgICAgICAgIC5jaGFuZ2VzXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNpemVDb21wb25lbnQoZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dGFjaEVsZW1lbnRFdmVudEhhbmRsZXJzKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGluY3JlbWVudE1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluY3JlbWVudFRpdGxlIHx8IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQoJ2luY3JlbWVudCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGRlY3JlbWVudE1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY3JlbWVudFRpdGxlIHx8IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQoJ2RlY3JlbWVudCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGRyYWdIYW5kbGVNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnSGFuZGxlVGl0bGUgfHwgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmdldCgnZHJhZ0hhbmRsZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlRHJhZ1ByZXNzKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3Mub3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgYXJncy5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdrLXNsaWRlci10cmFuc2l0aW9ucycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25IYW5kbGVEcmFnKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hhbmdlVmFsdWUoZXZlbnRWYWx1ZShhcmdzLCB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQsIHRoaXMuZ2V0UHJvcHMoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25IYW5kbGVSZWxlYXNlKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7IC8vbmVlZGVkIGZvciBhbmltYXRpb25cbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdrLXNsaWRlci10cmFuc2l0aW9ucycpO1xuICAgIH1cbiAgICAvL25nTW9kZWwgYmluZGluZ1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zaXplQ29tcG9uZW50KHRoaXMuYW5pbWF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMubmdDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjaGFuZ2VWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIWFyZVNhbWUodGhpcy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZUNvbXBvbmVudCh0aGlzLmFuaW1hdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2l6ZUNvbXBvbmVudChhbmltYXRlKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2submF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uRWwgPSB0aGlzLnNsaWRlclNlbGVjdGlvbi5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBkcmFnSGFuZGxlRWwgPSB0aGlzLmRyYWdoYW5kbGUubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzID8gdGhpcy50aWNrc0NvbnRhaW5lci5uYXRpdmVFbGVtZW50IDogbnVsbDtcbiAgICAgICAgaWYgKCFhbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2stc2xpZGVyLXRyYW5zaXRpb25zJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldFN0eWxlcyhbdHJhY2ssIHNlbGVjdGlvbkVsLCBkcmFnSGFuZGxlRWwsIHRpY2tzLCB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnRdKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gbmV3IFNsaWRlck1vZGVsKHByb3BzLCB3cmFwcGVyLCB0cmFjaywgdGhpcy5yZW5kZXJlcik7XG4gICAgICAgIG1vZGVsLnJlc2l6ZVRyYWNrKCk7XG4gICAgICAgIGlmICh0aGlzLnRpY2tzKSB7IC8vZm9yIGNhc2Ugd2hlbiB0aWNrUGxhY2VtZW50OiBub25lXG4gICAgICAgICAgICBtb2RlbC5yZXNpemVUaWNrcyh0aGlzLnRpY2tzQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsIHRoaXMudGlja3MudGlja0VsZW1lbnRzLm1hcChlbGVtZW50ID0+IGVsZW1lbnQubmF0aXZlRWxlbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLnBvc2l0aW9uSGFuZGxlKGRyYWdIYW5kbGVFbCk7XG4gICAgICAgIG1vZGVsLnBvc2l0aW9uU2VsZWN0aW9uKHNlbGVjdGlvbkVsKTtcbiAgICAgICAgaWYgKCFhbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2stc2xpZGVyLXRyYW5zaXRpb25zJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZml4ZWRUaWNrV2lkdGgpIHtcbiAgICAgICAgICAgIG1vZGVsLnJlc2l6ZVdyYXBwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgZm9jdXNlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQgIT09IHZhbHVlICYmIHRoaXMuaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0IGRyYWdnaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dlZCAhPT0gdmFsdWUgJiYgdGhpcy5zbGlkZXJTZWxlY3Rpb24gJiYgdGhpcy5kcmFnaGFuZGxlKSB7XG4gICAgICAgICAgICBjb25zdCBzbGlkZXJTZWxlY3Rpb24gPSB0aGlzLnNsaWRlclNlbGVjdGlvbi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgZHJhZ2hhbmRsZSA9IHRoaXMuZHJhZ2hhbmRsZS5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhzbGlkZXJTZWxlY3Rpb24sIFBSRVNTRUQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZHJhZ2hhbmRsZSwgUFJFU1NFRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHNsaWRlclNlbGVjdGlvbiwgUFJFU1NFRCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhkcmFnaGFuZGxlLCBQUkVTU0VEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2VkID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VmFsdWVDaGFuZ2VJbnRlcnZhbChlbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZWRvd24gPSBmcm9tRXZlbnQoZWxlbWVudCwgJ21vdXNlZG93bicpO1xuICAgICAgICAgICAgY29uc3QgbW91c2V1cCA9IGZyb21FdmVudChlbGVtZW50LCAnbW91c2V1cCcpO1xuICAgICAgICAgICAgY29uc3QgbW91c2VvdXQgPSBmcm9tRXZlbnQoZWxlbWVudCwgJ21vdXNlb3V0Jyk7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBtb3VzZWRvd24ucGlwZShmaWx0ZXIoKGUpID0+IGUuYnV0dG9uID09PSAwICYmICF0aGlzLmlzRGlzYWJsZWQpLCBjb25jYXRNYXAoKCkgPT4gaW50ZXJ2YWwoMTUwKS5waXBlKHN0YXJ0V2l0aCgtMSksIHRha2VVbnRpbChtZXJnZShtb3VzZXVwLCBtb3VzZW91dCkpKSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuZHJhZ2hhbmRsZSwgJ2ZvY3VzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFByb3BzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnV0dG9uczogdGhpcy5zaG93QnV0dG9ucyxcbiAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICAgICAgZml4ZWRUaWNrV2lkdGg6IHRoaXMuZml4ZWRUaWNrV2lkdGgsXG4gICAgICAgICAgICBsYXJnZVN0ZXA6IHRoaXMubGFyZ2VTdGVwLFxuICAgICAgICAgICAgbWF4OiB0aGlzLm1heCxcbiAgICAgICAgICAgIG1pbjogdGhpcy5taW4sXG4gICAgICAgICAgICByZWFkb25seTogdGhpcy5yZWFkb25seSxcbiAgICAgICAgICAgIHJldmVyc2U6IHRoaXMucmV2ZXJzZSxcbiAgICAgICAgICAgIHJ0bDogdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLnJ0bCxcbiAgICAgICAgICAgIHNtYWxsU3RlcDogdGhpcy5zbWFsbFN0ZXAsXG4gICAgICAgICAgICB2YWx1ZTogdHJpbVZhbHVlKHRoaXMubWF4LCB0aGlzLm1pbiwgdGhpcy52YWx1ZSksXG4gICAgICAgICAgICB2ZXJ0aWNhbDogdGhpcy52ZXJ0aWNhbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhdHRhY2hFbGVtZW50RXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgY29uc3QgaG9zdEVsZW1lbnQgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGxldCB0YWJiaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBjdXJzb3JJbnNpZGVXcmFwcGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGZvY3VzSW4gYW5kIGZvY3VzT3V0IGFyZSByZWxhdGl2ZSB0byB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucmVuZGVyZXIubGlzdGVuKGhvc3RFbGVtZW50LCAnZm9jdXNpbicsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucmVuZGVyZXIubGlzdGVuKGhvc3RFbGVtZW50LCAnZm9jdXNvdXQnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGFiYmluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5yZWxhdGVkVGFyZ2V0ICE9PSB0aGlzLmRyYWdoYW5kbGUubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVCbHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFiYmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3JJbnNpZGVXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdtb3VzZWVudGVyJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnNvckluc2lkZVdyYXBwZXIgPSB0cnVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbihob3N0RWxlbWVudCwgJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3Vyc29ySW5zaWRlV3JhcHBlciA9IGZhbHNlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbihob3N0RWxlbWVudCwgJ2tleWRvd24nLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuVGFiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFiYmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNsaWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNhYmxlSWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNsaWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZHJhZ0hhbmRsZVRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTbGlkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImluY3JlbWVudFRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2xpZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTbGlkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRlY3JlbWVudFRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2xpZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93QnV0dG9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2xpZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBTbGlkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdkcmFnaGFuZGxlJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBTbGlkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRyYWdoYW5kbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnZGVjcmVhc2VCdXR0b24nLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBTbGlkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRlY3JlYXNlQnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2luY3JlYXNlQnV0dG9uJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgU2xpZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmNyZWFzZUJ1dHRvblwiLCB2b2lkIDApO1xuU2xpZGVyQ29tcG9uZW50ID0gU2xpZGVyQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvU2xpZGVyJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgeyBwcm92aWRlOiBMMTBOX1BSRUZJWCwgdXNlVmFsdWU6ICdrZW5kby5zbGlkZXInIH0sXG4gICAgICAgICAgICB7IG11bHRpOiB0cnVlLCBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU2xpZGVyQ29tcG9uZW50XzEpIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IEtlbmRvSW5wdXQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNsaWRlckNvbXBvbmVudF8xKSB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tc2xpZGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBrZW5kb1NsaWRlckxvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLWluY3JlbWVudD1cImtlbmRvLnNsaWRlci5pbmNyZW1lbnR8VGhlIHRpdGxlIG9mIHRoZSAqKkluY3JlYXNlKiogYnV0dG9uIG9mIHRoZSBTbGlkZXIuXCJcbiAgICAgICAgICAgIGluY3JlbWVudD1cImluY3JlbWVudFwiXG4gICAgICAgICAgICBpMThuLWRlY3JlbWVudD1cImtlbmRvLnNsaWRlci5kZWNyZW1lbnR8VGhlIHRpdGxlIG9mIHRoZSAqKkRlY3JlYXNlKiogYnV0dG9uIG9mIHRoZSBTbGlkZXIuXCJcbiAgICAgICAgICAgIGRlY3JlbWVudD1cImRlY3JlbWVudFwiXG4gICAgICAgICAgICBpMThuLWRyYWdIYW5kbGU9XCJrZW5kby5zbGlkZXIuZHJhZ0hhbmRsZXxUaGUgdGl0bGUgb2YgdGhlIGRyYWcgaGFuZGxlIG9mIHRoZSBTbGlkZXIuXCJcbiAgICAgICAgICAgIGRyYWdIYW5kbGU9XCJEcmFnXCJcbiAgICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1zbGlkZXItd3JhcFwiICN3cmFwXG4gICAgICAgICAgICBbY2xhc3Muay1zbGlkZXItYnV0dG9uc109XCJzaG93QnV0dG9uc1wiXG4gICAgICAgICAgICBbY2xhc3Muay1zbGlkZXItdG9wbGVmdF09XCJ0aWNrUGxhY2VtZW50ID09PSAnYmVmb3JlJ1wiXG4gICAgICAgICAgICBbY2xhc3Muay1zbGlkZXItYm90dG9tcmlnaHRdPVwidGlja1BsYWNlbWVudCA9PT0gJ2FmdGVyJ1wiXG4gICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7IGNsaWNrOiBvbldyYXBDbGljaywga2V5ZG93bjogb25LZXlEb3duIH1cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPGJ1dHRvbiAqbmdJZj1cInNob3dCdXR0b25zXCIgdHlwZT1cImJ1dHRvblwiICNkZWNyZWFzZUJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay1idXR0b24tZGVjcmVhc2Ugay1idXR0b24gay1idXR0b24tbWQgay1yb3VuZGVkLWZ1bGwgay1idXR0b24tcmVjdGFuZ2xlIGstYnV0dG9uLXNvbGlkIGstYnV0dG9uLXNvbGlkLWJhc2Ugay1pY29uLWJ1dHRvblwiXG4gICAgICAgICAgICAgICAgW3RpdGxlXT1cImRlY3JlbWVudE1lc3NhZ2VcIlxuICAgICAgICAgICAgICAgIFthdHRyLnRhYmluZGV4XT1cIi0xXCJcbiAgICAgICAgICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1idXR0b24taWNvbiBrLWljb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstaS1hcnJvdy13XT1cIiF2ZXJ0aWNhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1pLWFycm93LXNdPVwidmVydGljYWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1zbGlkZXItdHJhY2std3JhcFwiPlxuICAgICAgICAgICAgICAgIDx1bCBrZW5kb1NsaWRlclRpY2tzXG4gICAgICAgICAgICAgICAgICAgICN0aWNrc1xuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cInRpY2tQbGFjZW1lbnQgIT09ICdub25lJ1wiXG4gICAgICAgICAgICAgICAgICAgIFt0aWNrVGl0bGVdPVwidGl0bGVcIlxuICAgICAgICAgICAgICAgICAgICBbdmVydGljYWxdPVwidmVydGljYWxcIlxuICAgICAgICAgICAgICAgICAgICBbc3RlcF09XCJzbWFsbFN0ZXBcIlxuICAgICAgICAgICAgICAgICAgICBbbGFyZ2VTdGVwXT1cImxhcmdlU3RlcFwiXG4gICAgICAgICAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgICAgICAgICBbbGFiZWxUZW1wbGF0ZV09XCJsYWJlbFRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtaGlkZGVuXT1cInRydWVcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgIDxkaXYgI3RyYWNrIGNsYXNzPVwiay1zbGlkZXItdHJhY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiAjc2xpZGVyU2VsZWN0aW9uIGNsYXNzPVwiay1zbGlkZXItc2VsZWN0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8YSAjZHJhZ2hhbmRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cInNsaWRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWluXT1cIm1pblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cImN1cnJlbnRWYWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVldGV4dF09XCJjdXJyZW50VmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJkaXNhYmxlZCA/IHRydWUgOiB1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1yZWFkb25seV09XCJyZWFkb25seSA/IHRydWUgOiB1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1vcmllbnRhdGlvbl09XCJ2ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLnRvdWNoLWFjdGlvbl09XCJpc0Rpc2FibGVkID8gJycgOiAnbm9uZSdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWRyYWdoYW5kbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlXT1cImRyYWdIYW5kbGVNZXNzYWdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLnRhYmluZGV4XT1cImRpc2FibGVkID8gJy0xJyA6IHRhYkluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtpZF09XCJmb2N1c2FibGVJZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBrZW5kb0RyYWdnYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgKGtlbmRvUHJlc3MpPVwiaWZFbmFibGVkKGhhbmRsZURyYWdQcmVzcywgJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoa2VuZG9EcmFnKT1cImlmRW5hYmxlZChvbkhhbmRsZURyYWcsICRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKGtlbmRvUmVsZWFzZSk9XCJpZkVuYWJsZWQob25IYW5kbGVSZWxlYXNlLCAkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgPjwvYT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGJ1dHRvbiAqbmdJZj1cInNob3dCdXR0b25zXCIgdHlwZT1cImJ1dHRvblwiICNpbmNyZWFzZUJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay1idXR0b24taW5jcmVhc2Ugay1idXR0b24gay1idXR0b24tbWQgay1yb3VuZGVkLWZ1bGwgay1idXR0b24tcmVjdGFuZ2xlIGstYnV0dG9uLXNvbGlkIGstYnV0dG9uLXNvbGlkLWJhc2Ugay1pY29uLWJ1dHRvblwiXG4gICAgICAgICAgICAgICAgW3RpdGxlXT1cImluY3JlbWVudE1lc3NhZ2VcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCIkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwiLTFcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY3VycmVudFZhbHVlXCJcbiAgICAgICAgICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1idXR0b24taWNvbiBrLWljb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstaS1hcnJvdy1lXT1cIiF2ZXJ0aWNhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1pLWFycm93LW5dPVwidmVydGljYWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8a2VuZG8tcmVzaXplLXNlbnNvciAocmVzaXplKT1cInNpemVDb21wb25lbnQoZmFsc2UpXCI+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgICAgICA8L2Rpdj5cbiAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgSW5qZWN0b3IsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTmdab25lLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgRWxlbWVudFJlZl0pXG5dLCBTbGlkZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUmFuZ2VTbGlkZXJNb2RlbCBleHRlbmRzIFNsaWRlck1vZGVsQmFzZSB7XG4gICAgcG9zaXRpb25IYW5kbGUoZHJhZ0hhbmRsZSkge1xuICAgICAgICBpZiAoIWRyYWdIYW5kbGUuaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG1heCwgbWluLCByZXZlcnNlLCB2ZXJ0aWNhbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB2ZXJ0aWNhbCA/ICdib3R0b20nIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCB0cmFja1dpZHRoID0gdGhpcy50cmFja1dpZHRoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTdGFydEhhbmRsZShkcmFnSGFuZGxlKSA/IHRyaW1WYWx1ZVJhbmdlKG1heCwgbWluLCB0aGlzLnByb3BzLnZhbHVlKVswXVxuICAgICAgICAgICAgOiB0cmltVmFsdWVSYW5nZShtYXgsIG1pbiwgdGhpcy5wcm9wcy52YWx1ZSlbMV07XG4gICAgICAgIGlmIChpc1N0YXJ0SGFuZGxlKGRyYWdIYW5kbGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SGFuZGxlUG9zaXRpb24gPSBjYWxjdWxhdGVIYW5kbGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgICAgICByZXZlcnNlLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHRyYWNrV2lkdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShkcmFnSGFuZGxlLCBwb3NpdGlvbiwgYCR7dGhpcy5zdGFydEhhbmRsZVBvc2l0aW9ufXB4YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVuZEhhbmRsZVBvc2l0aW9uID0gY2FsY3VsYXRlSGFuZGxlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICAgICAgcmV2ZXJzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB0cmFja1dpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZHJhZ0hhbmRsZSwgcG9zaXRpb24sIGAke3RoaXMuZW5kSGFuZGxlUG9zaXRpb259cHhgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3NpdGlvblNlbGVjdGlvbihkcmFnSGFuZGxlLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgeyByZXZlcnNlLCB2ZXJ0aWNhbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdmVydGljYWwgPyAnYm90dG9tJyA6IHJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBzaXplID0gTWF0aC5hYnModGhpcy5lbmRIYW5kbGVQb3NpdGlvbiAtIHRoaXMuc3RhcnRIYW5kbGVQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb25Qb3NpdGlvbiA9IHZlcnRpY2FsID8gZHJhZ0hhbmRsZS5zdHlsZS5ib3R0b20gOiBkcmFnSGFuZGxlLnN0eWxlLmxlZnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoc2VsZWN0aW9uLCBkaW1lbnNpb24sIGAke3NpemV9cHhgKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShzZWxlY3Rpb24sIHBvc2l0aW9uLCByZXZlcnNlID8gdGhpcy50cmFja1dpZHRoKCkgLSBwYXJzZUZsb2F0KGN1cnJlbnRTZWxlY3Rpb25Qb3NpdGlvbikgKyAncHgnXG4gICAgICAgICAgICA6IHBhcnNlRmxvYXQoY3VycmVudFNlbGVjdGlvblBvc2l0aW9uKSArICdweCcpO1xuICAgIH1cbn1cblxudmFyIFJhbmdlU2xpZGVyQ29tcG9uZW50XzE7XG5jb25zdCBQUkVTU0VEJDEgPSAnay1wcmVzc2VkJztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIFJhbmdlU2xpZGVyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19yYW5nZXNsaWRlciAlfSkuXG4gKi9cbmxldCBSYW5nZVNsaWRlckNvbXBvbmVudCA9IFJhbmdlU2xpZGVyQ29tcG9uZW50XzEgPSBjbGFzcyBSYW5nZVNsaWRlckNvbXBvbmVudCBleHRlbmRzIFNsaWRlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgaW5qZWN0b3IsIHJlbmRlcmVyLCBuZ1pvbmUsIGNoYW5nZURldGVjdG9yLCBob3N0RWxlbWVudCkge1xuICAgICAgICBzdXBlcihsb2NhbGl6YXRpb24sIGluamVjdG9yLCByZW5kZXJlciwgbmdab25lLCBjaGFuZ2VEZXRlY3RvciwgaG9zdEVsZW1lbnQpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRIYW5kbGVJZCA9IGBrLXN0YXJ0LWhhbmRsZS0ke2d1aWQoKX1gO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmRIYW5kbGVJZCA9IGBrLWVuZC1oYW5kbGUtJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNhYmxlSWQgPSB0aGlzLnN0YXJ0SGFuZGxlSWQ7XG4gICAgICAgIHRoaXMuaGFuZGxlWkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5hY3RpdmVIYW5kbGUgPSAnc3RhcnRIYW5kbGUnO1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25XcmFwQ2xpY2sgPSAoYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZSB8fCBbdGhpcy5taW4sIHRoaXMubWluXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja1ZhbHVlID0gZXZlbnRWYWx1ZShhcmdzLCB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQsIHRoaXMuZ2V0UHJvcHMoKSk7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1JhbmdlVmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgW3N0YXJ0VmFsdWUsIGVuZFZhbHVlXSA9IG5ld1JhbmdlVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja1ZhbHVlIDw9IHN0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2VWYWx1ZSA9IFt0cmFja1ZhbHVlLCBlbmRWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSGFuZGxlID0gJ3N0YXJ0SGFuZGxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRWYWx1ZSA8IHRyYWNrVmFsdWUgJiYgdHJhY2tWYWx1ZSA8IGVuZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja1ZhbHVlIDwgKHN0YXJ0VmFsdWUgKyBlbmRWYWx1ZSkgLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSYW5nZVZhbHVlID0gW3RyYWNrVmFsdWUsIGVuZFZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSGFuZGxlID0gJ3N0YXJ0SGFuZGxlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JhbmdlVmFsdWUgPSBbc3RhcnRWYWx1ZSwgdHJhY2tWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUhhbmRsZSA9ICdlbmRIYW5kbGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyYWNrVmFsdWUgPj0gZW5kVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2VWYWx1ZSA9IFtzdGFydFZhbHVlLCB0cmFja1ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVIYW5kbGUgPSAnZW5kSGFuZGxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlSGFuZGxlID0gdGhpcy5hY3RpdmVIYW5kbGUgPT09ICdzdGFydEhhbmRsZScgPyB0aGlzLmRyYWdoYW5kbGVTdGFydCA6IHRoaXMuZHJhZ2hhbmRsZUVuZDtcbiAgICAgICAgICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKGFjdGl2ZUhhbmRsZSwgJ2ZvY3VzJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZShuZXdSYW5nZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25LZXlEb3duID0gKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlIHx8IFt0aGlzLm1pbiwgdGhpcy5taW5dO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWF4LCBtaW4gfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5rZXlCaW5kaW5nW2Uua2V5Q29kZV07XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Rpc2FibGVkIHx8ICFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlLnRhcmdldCwgJ3pJbmRleCcsICsrdGhpcy5oYW5kbGVaSW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRIYW5kbGVJc0FjdGl2ZSA9IGlzU3RhcnRIYW5kbGUoZS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBoYW5kbGVyKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdmFsdWU6IHN0YXJ0SGFuZGxlSXNBY3RpdmUgPyB0aGlzLnZhbHVlWzBdIDogdGhpcy52YWx1ZVsxXSB9KSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRIYW5kbGVJc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IHRoaXMudmFsdWVbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVsxXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IHRoaXMudmFsdWVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVswXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRWYWx1ZSA9IHRyaW1WYWx1ZShtYXgsIG1pbiwgdmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBzdGFydEhhbmRsZUlzQWN0aXZlID8gW3RyaW1tZWRWYWx1ZSwgdGhpcy52YWx1ZVsxXV1cbiAgICAgICAgICAgICAgICA6IFt0aGlzLnZhbHVlWzBdLCB0cmltbWVkVmFsdWVdO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmdDaGFuZ2UgPSAoXykgPT4geyB9O1xuICAgICAgICB0aGlzLm5nVG91Y2hlZCA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVCbHVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uQmx1cikgfHwgcmVxdWlyZXNab25lT25CbHVyKHRoaXMuY29udHJvbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nVG91Y2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkJsdXIuZW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIFJhbmdlU2xpZGVyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0cy1uby1ydW5cbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogICAgIDxkaXY+XG4gICAgICogICAgICAgICA8YnV0dG9uIGNsYXNzPVwiay1idXR0b25cIiAoY2xpY2spPVwic2xpZGVyLmZvY3VzKClcIj5Gb2N1czwvYnV0dG9uPlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgICAgPGtlbmRvLXJhbmdlc2xpZGVyICNzbGlkZXI+PC9rZW5kby1yYW5nZXNsaWRlcj5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IHRydWU7XG4gICAgICAgIGludm9rZUVsZW1lbnRNZXRob2QodGhpcy5kcmFnaGFuZGxlU3RhcnQsICdmb2N1cycpO1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIFJhbmdlU2xpZGVyLlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUhhbmRsZSA9IHRoaXMuYWN0aXZlSGFuZGxlID09PSAnc3RhcnRIYW5kbGUnID8gdGhpcy5kcmFnaGFuZGxlU3RhcnQgOiB0aGlzLmRyYWdoYW5kbGVFbmQ7XG4gICAgICAgIGludm9rZUVsZW1lbnRNZXRob2QoYWN0aXZlSGFuZGxlLCAnYmx1cicpO1xuICAgICAgICB0aGlzLmhhbmRsZUJsdXIoKTtcbiAgICAgICAgdGhpcy5mb2N1c0NoYW5nZWRQcm9ncmFtbWF0aWNhbGx5ID0gZmFsc2U7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbdGhpcy5taW4sIHRoaXMubWF4XTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChhbnlDaGFuZ2VkKFsndmFsdWUnLCAnZml4ZWRUaWNrV2lkdGgnLCAndGlja1BsYWNlbWVudCddLCBjaGFuZ2VzLCB0cnVlKSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMudmFsdWUgJiYgY2hhbmdlcy52YWx1ZS5jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZVZhbHVlKGNoYW5nZXMudmFsdWUuY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVDb21wb25lbnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemVDb21wb25lbnQoKTtcbiAgICAgICAgaWYgKHRoaXMudGlja3MpIHtcbiAgICAgICAgICAgIHRoaXMudGlja3MudGlja0VsZW1lbnRzXG4gICAgICAgICAgICAgICAgLmNoYW5nZXNcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2l6ZUNvbXBvbmVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dGFjaEVsZW1lbnRFdmVudEhhbmRsZXJzKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdGV4dEZvcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldChrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPyBgJHt0aGlzLnZhbHVlWzBdfSAtICR7dGhpcy52YWx1ZVsxXX1gIDogJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVEcmFnUHJlc3MoYXJncykge1xuICAgICAgICBpZiAoYXJncy5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICBhcmdzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBhcmdzLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICAgICAgICB0aGlzLmRyYWdnZWRIYW5kbGUgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGFyZ2V0LCAnekluZGV4JywgKyt0aGlzLmhhbmRsZVpJbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkhhbmRsZURyYWcoYXJncykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZSB8fCBbdGhpcy5taW4sIHRoaXMubWluXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXJncy5vcmlnaW5hbEV2ZW50LnRhcmdldDtcbiAgICAgICAgY29uc3QgbGFzdENvb3JkcyA9IHRoaXMuZHJhZ2dlZEhhbmRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5sYXN0SGFuZGxlUG9zaXRpb24gPSB7IHg6IGxhc3RDb29yZHMubGVmdCwgeTogbGFzdENvb3Jkcy50b3AgfTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHsgdmFsdWU6IHRydWUsIHRhcmdldCB9O1xuICAgICAgICBjb25zdCBtb3VzZVBvcyA9IHtcbiAgICAgICAgICAgIHg6IChhcmdzLnBhZ2VYIC0gMC41KSAtIChsYXN0Q29vcmRzLndpZHRoIC8gMiksXG4gICAgICAgICAgICB5OiAoYXJncy5wYWdlWSAtIChsYXN0Q29vcmRzLndpZHRoIC8gMikpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxlZnQgPSBtb3VzZVBvcy54IDwgdGhpcy5sYXN0SGFuZGxlUG9zaXRpb24ueDtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBtb3VzZVBvcy54ID4gdGhpcy5sYXN0SGFuZGxlUG9zaXRpb24ueDtcbiAgICAgICAgY29uc3QgdXAgPSBtb3VzZVBvcy55ID4gdGhpcy5sYXN0SGFuZGxlUG9zaXRpb24ueTtcbiAgICAgICAgY29uc3QgbW92ZVN0YXJ0SGFuZGxlID0gKCkgPT4gdGhpcy5jaGFuZ2VWYWx1ZShbZXZlbnRWYWx1ZShhcmdzLCB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQsIHRoaXMuZ2V0UHJvcHMoKSksIHRoaXMudmFsdWVbMV1dKTtcbiAgICAgICAgY29uc3QgbW92ZUVuZEhhbmRsZSA9ICgpID0+IHRoaXMuY2hhbmdlVmFsdWUoW3RoaXMudmFsdWVbMF0sIGV2ZW50VmFsdWUoYXJncywgdGhpcy50cmFjay5uYXRpdmVFbGVtZW50LCB0aGlzLmdldFByb3BzKCkpXSk7XG4gICAgICAgIGNvbnN0IG1vdmVCb3RoSGFuZGxlcyA9ICgpID0+IHRoaXMuY2hhbmdlVmFsdWUoW2V2ZW50VmFsdWUoYXJncywgdGhpcy50cmFjay5uYXRpdmVFbGVtZW50LCB0aGlzLmdldFByb3BzKCkpLCBldmVudFZhbHVlKGFyZ3MsIHRoaXMudHJhY2submF0aXZlRWxlbWVudCwgdGhpcy5nZXRQcm9wcygpKV0pO1xuICAgICAgICBjb25zdCBhY3RpdmVTdGFydEhhbmRsZSA9IGlzU3RhcnRIYW5kbGUodGhpcy5kcmFnZ2VkSGFuZGxlKTtcbiAgICAgICAgY29uc3QgdmVydGljYWwgPSB0aGlzLnZlcnRpY2FsO1xuICAgICAgICBjb25zdCBob3Jpem9udGFsID0gIXZlcnRpY2FsO1xuICAgICAgICBjb25zdCBmb3J3YXJkID0gKHZlcnRpY2FsICYmIHVwKSB8fCAodGhpcy5yZXZlcnNlID8gaG9yaXpvbnRhbCAmJiByaWdodCA6IGhvcml6b250YWwgJiYgbGVmdCk7XG4gICAgICAgIGNvbnN0IGluY29ycmVjdFZhbHVlU3RhdGUgPSB0aGlzLnZhbHVlWzBdID4gdGhpcy52YWx1ZVsxXTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVbMF0gPT09IHRoaXMudmFsdWVbMV0gfHwgaW5jb3JyZWN0VmFsdWVTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTdGFydEhhbmRsZSA/IG1vdmVTdGFydEhhbmRsZSgpIDogbW92ZUJvdGhIYW5kbGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTdGFydEhhbmRsZSA/IG1vdmVCb3RoSGFuZGxlcygpIDogbW92ZUVuZEhhbmRsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlU3RhcnRIYW5kbGUgPyBtb3ZlU3RhcnRIYW5kbGUoKSA6IG1vdmVFbmRIYW5kbGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25IYW5kbGVSZWxlYXNlKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHsgdmFsdWU6IGZhbHNlLCB0YXJnZXQ6IGFyZ3Mub3JpZ2luYWxFdmVudC50YXJnZXQgfTsgLy9uZWVkZWQgZm9yIGFuaW1hdGlvblxuICAgICAgICB0aGlzLmRyYWdnZWRIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vbmdNb2RlbCBiaW5kaW5nXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdmFsaWRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zaXplQ29tcG9uZW50KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMubmdDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjaGFuZ2VWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWUgfHwgIWlzU2FtZVJhbmdlKHRoaXMudmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ0NoYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplQ29tcG9uZW50KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2l6ZUNvbXBvbmVudCgpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFjay5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25FbCA9IHRoaXMuc2xpZGVyU2VsZWN0aW9uLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGRyYWdIYW5kbGVTdGFydEVsID0gdGhpcy5kcmFnaGFuZGxlU3RhcnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgZHJhZ0hhbmRsZUVuZEVsID0gdGhpcy5kcmFnaGFuZGxlRW5kLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyA/IHRoaXMudGlja3NDb250YWluZXIubmF0aXZlRWxlbWVudCA6IG51bGw7XG4gICAgICAgIHRoaXMucmVzZXRTdHlsZXMoW3RyYWNrLCBzZWxlY3Rpb25FbCwgZHJhZ0hhbmRsZVN0YXJ0RWwsIGRyYWdIYW5kbGVFbmRFbCwgdGlja3MsIHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudF0pO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBuZXcgUmFuZ2VTbGlkZXJNb2RlbChwcm9wcywgd3JhcHBlciwgdHJhY2ssIHRoaXMucmVuZGVyZXIpO1xuICAgICAgICBtb2RlbC5yZXNpemVUcmFjaygpO1xuICAgICAgICBpZiAodGhpcy50aWNrcykgeyAvL2ZvciBjYXNlIHdoZW4gdGlja1BsYWNlbWVudDogbm9uZVxuICAgICAgICAgICAgbW9kZWwucmVzaXplVGlja3ModGhpcy50aWNrc0NvbnRhaW5lci5uYXRpdmVFbGVtZW50LCB0aGlzLnRpY2tzLnRpY2tFbGVtZW50cy5tYXAoZWxlbWVudCA9PiBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5wb3NpdGlvbkhhbmRsZShkcmFnSGFuZGxlU3RhcnRFbCk7XG4gICAgICAgIG1vZGVsLnBvc2l0aW9uSGFuZGxlKGRyYWdIYW5kbGVFbmRFbCk7XG4gICAgICAgIG1vZGVsLnBvc2l0aW9uU2VsZWN0aW9uKGRyYWdIYW5kbGVTdGFydEVsLCBzZWxlY3Rpb25FbCk7XG4gICAgICAgIGlmICh0aGlzLmZpeGVkVGlja1dpZHRoKSB7XG4gICAgICAgICAgICBtb2RlbC5yZXNpemVXcmFwcGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpc0Rpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXNlZCBieSB0aGUgRmxvYXRpbmdMYWJlbCB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldCBmb2N1c2VkKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRm9jdXNlZCAhPT0gdmFsdWUgJiYgdGhpcy5ob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgZHJhZ2dpbmcoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnZWQgIT09IGRhdGEudmFsdWUgJiYgdGhpcy5zbGlkZXJTZWxlY3Rpb24gJiYgdGhpcy5kcmFnaGFuZGxlU3RhcnQgJiYgdGhpcy5kcmFnaGFuZGxlRW5kKSB7XG4gICAgICAgICAgICBjb25zdCBzbGlkZXJTZWxlY3Rpb24gPSB0aGlzLnNsaWRlclNlbGVjdGlvbi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgZHJhZ2hhbmRsZSA9IGRhdGEudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRhdGEudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHNsaWRlclNlbGVjdGlvbiwgUFJFU1NFRCQxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGRyYWdoYW5kbGUsIFBSRVNTRUQkMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHNsaWRlclNlbGVjdGlvbiwgUFJFU1NFRCQxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGRyYWdoYW5kbGUsIFBSRVNTRUQkMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dlZCA9IGRhdGEudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UHJvcHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZCxcbiAgICAgICAgICAgIGZpeGVkVGlja1dpZHRoOiB0aGlzLmZpeGVkVGlja1dpZHRoLFxuICAgICAgICAgICAgbGFyZ2VTdGVwOiB0aGlzLmxhcmdlU3RlcCxcbiAgICAgICAgICAgIG1heDogdGhpcy5tYXgsXG4gICAgICAgICAgICBtaW46IHRoaXMubWluLFxuICAgICAgICAgICAgcmVhZG9ubHk6IHRoaXMucmVhZG9ubHksXG4gICAgICAgICAgICByZXZlcnNlOiB0aGlzLnJldmVyc2UsXG4gICAgICAgICAgICBydGw6IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5ydGwsXG4gICAgICAgICAgICBzbWFsbFN0ZXA6IHRoaXMuc21hbGxTdGVwLFxuICAgICAgICAgICAgdmFsdWU6IHRyaW1WYWx1ZVJhbmdlKHRoaXMubWF4LCB0aGlzLm1pbiwgdGhpcy52YWx1ZSksXG4gICAgICAgICAgICB2ZXJ0aWNhbDogdGhpcy52ZXJ0aWNhbCxcbiAgICAgICAgICAgIGJ1dHRvbnM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGF0dGFjaEVsZW1lbnRFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IHRhYmJpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IGN1cnNvckluc2lkZVdyYXBwZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgLy8gZm9jdXNJbiBhbmQgZm9jdXNPdXQgYXJlIHJlbGF0aXZlIHRvIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1c2luJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5mb2N1c0NoYW5nZWRQcm9ncmFtbWF0aWNhbGx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1c291dCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YWJiaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLnJlbGF0ZWRUYXJnZXQgIT09IHRoaXMuZHJhZ2hhbmRsZVN0YXJ0Lm5hdGl2ZUVsZW1lbnQgJiYgYXJncy5yZWxhdGVkVGFyZ2V0ICE9PSB0aGlzLmRyYWdoYW5kbGVFbmQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVCbHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFiYmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3JJbnNpZGVXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdtb3VzZWVudGVyJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnNvckluc2lkZVdyYXBwZXIgPSB0cnVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbihob3N0RWxlbWVudCwgJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3Vyc29ySW5zaWRlV3JhcHBlciA9IGZhbHNlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbihob3N0RWxlbWVudCwgJ2tleWRvd24nLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuVGFiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFiYmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgUmFuZ2VTbGlkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2RyYWdoYW5kbGVTdGFydCcsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgUmFuZ2VTbGlkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRyYWdoYW5kbGVTdGFydFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdkcmFnaGFuZGxlRW5kJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBSYW5nZVNsaWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZHJhZ2hhbmRsZUVuZFwiLCB2b2lkIDApO1xuUmFuZ2VTbGlkZXJDb21wb25lbnQgPSBSYW5nZVNsaWRlckNvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1JhbmdlU2xpZGVyJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgeyBwcm92aWRlOiBMMTBOX1BSRUZJWCwgdXNlVmFsdWU6ICdrZW5kby5yYW5nZXNsaWRlcicgfSxcbiAgICAgICAgICAgIHsgbXVsdGk6IHRydWUsIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSYW5nZVNsaWRlckNvbXBvbmVudF8xKSB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBLZW5kb0lucHV0LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSYW5nZVNsaWRlckNvbXBvbmVudF8xKSB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcmFuZ2VzbGlkZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvU2xpZGVyTG9jYWxpemVkTWVzc2FnZXNcbiAgICAgICAgICAgIGkxOG4tZHJhZ0hhbmRsZVN0YXJ0PVwia2VuZG8ucmFuZ2VzbGlkZXIuZHJhZ0hhbmRsZVN0YXJ0fFRoZSB0aXRsZSBvZiB0aGUgKipTdGFydCoqIGRyYWcgaGFuZGxlIG9mIHRoZSBTbGlkZXIuXCJcbiAgICAgICAgICAgIGRyYWdIYW5kbGVTdGFydD1cIkRyYWdcIlxuICAgICAgICAgICAgaTE4bi1kcmFnSGFuZGxlRW5kPVwia2VuZG8ucmFuZ2VzbGlkZXIuZHJhZ0hhbmRsZUVuZHxUaGUgdGl0bGUgb2YgdGhlICoqRW5kKiogZHJhZyBoYW5kbGUgb2YgdGhlIFNsaWRlci5cIlxuICAgICAgICAgICAgZHJhZ0hhbmRsZUVuZD1cIkRyYWdcIlxuICAgICAgICA+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImstc2xpZGVyLXdyYXBcIiAjd3JhcFxuICAgICAgICAgICAgW2NsYXNzLmstc2xpZGVyLXRvcGxlZnRdPVwidGlja1BsYWNlbWVudCA9PT0gJ2JlZm9yZSdcIlxuICAgICAgICAgICAgW2NsYXNzLmstc2xpZGVyLWJvdHRvbXJpZ2h0XT1cInRpY2tQbGFjZW1lbnQgPT09ICdhZnRlcidcIlxuICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwieyBjbGljazogb25XcmFwQ2xpY2ssIGtleWRvd246IG9uS2V5RG93biB9XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJrLXNsaWRlci10cmFjay13cmFwXCI+XG4gICAgICAgICAgICAgICAgPHVsIGtlbmRvU2xpZGVyVGlja3NcbiAgICAgICAgICAgICAgICAgICAgI3RpY2tzXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwidGlja1BsYWNlbWVudCAhPT0gJ25vbmUnXCJcbiAgICAgICAgICAgICAgICAgICAgW3RpY2tUaXRsZV09XCJ0aXRsZVwiXG4gICAgICAgICAgICAgICAgICAgIFt2ZXJ0aWNhbF09XCJ2ZXJ0aWNhbFwiXG4gICAgICAgICAgICAgICAgICAgIFtzdGVwXT1cInNtYWxsU3RlcFwiXG4gICAgICAgICAgICAgICAgICAgIFtsYXJnZVN0ZXBdPVwibGFyZ2VTdGVwXCJcbiAgICAgICAgICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgICAgIFtsYWJlbFRlbXBsYXRlXT1cImxhYmVsVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1oaWRkZW5dPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgPGRpdiAjdHJhY2sgY2xhc3M9XCJrLXNsaWRlci10cmFja1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2ICNzbGlkZXJTZWxlY3Rpb24gY2xhc3M9XCJrLXNsaWRlci1zZWxlY3Rpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxhICNkcmFnaGFuZGxlU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU9XCJzbGlkZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2lkXT1cInN0YXJ0SGFuZGxlSWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwiZGlzYWJsZWQgPyB1bmRlZmluZWQgOiB0YWJpbmRleFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWluXT1cIm1pblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cInZhbHVlID8gdmFsdWVbMF0gOiBudWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtdmFsdWV0ZXh0XT1cInZhbHVlVGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cImRpc2FibGVkID8gdHJ1ZSA6IHVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXJlYWRvbmx5XT1cInJlYWRvbmx5ID8gdHJ1ZSA6IHVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLW9yaWVudGF0aW9uXT1cInZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUudG91Y2gtYWN0aW9uXT1cImlzRGlzYWJsZWQgPyAnJyA6ICdub25lJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstZHJhZ2hhbmRsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGl0bGVdPVwidGV4dEZvcignZHJhZ0hhbmRsZVN0YXJ0JylcIlxuICAgICAgICAgICAgICAgICAgICAgICAga2VuZG9EcmFnZ2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZW5kb1ByZXNzKT1cImlmRW5hYmxlZChoYW5kbGVEcmFnUHJlc3MgLCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKGtlbmRvRHJhZyk9XCJpZkVuYWJsZWQob25IYW5kbGVEcmFnICwkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZW5kb1JlbGVhc2UpPVwiaWZFbmFibGVkKG9uSGFuZGxlUmVsZWFzZSwgJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgID48L2E+XG4gICAgICAgICAgICAgICAgICAgIDxhICNkcmFnaGFuZGxlRW5kXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwic2xpZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtpZF09XCJlbmRIYW5kbGVJZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IHRhYmluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtdmFsdWVtaW5dPVwibWluXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtdmFsdWVtYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtdmFsdWVub3ddPVwidmFsdWUgPyB2YWx1ZVsxXSA6IG51bGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS12YWx1ZXRleHRdPVwidmFsdWVUZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwiZGlzYWJsZWQgPyB0cnVlIDogdW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtcmVhZG9ubHldPVwicmVhZG9ubHkgPyB0cnVlIDogdW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtb3JpZW50YXRpb25dPVwidmVydGljYWwgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS50b3VjaC1hY3Rpb25dPVwiaXNEaXNhYmxlZCA/ICcnIDogJ25vbmUnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1kcmFnaGFuZGxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aXRsZV09XCJ0ZXh0Rm9yKCdkcmFnSGFuZGxlRW5kJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAga2VuZG9EcmFnZ2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZW5kb1ByZXNzKT1cImlmRW5hYmxlZChoYW5kbGVEcmFnUHJlc3MgLCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKGtlbmRvRHJhZyk9XCJpZkVuYWJsZWQob25IYW5kbGVEcmFnICwkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZW5kb1JlbGVhc2UpPVwiaWZFbmFibGVkKG9uSGFuZGxlUmVsZWFzZSwgJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgID48L2E+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxrZW5kby1yZXNpemUtc2Vuc29yIChyZXNpemUpPVwic2l6ZUNvbXBvbmVudCgpXCI+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgICAgICA8L2Rpdj5cbiAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgSW5qZWN0b3IsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTmdab25lLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgRWxlbWVudFJlZl0pXG5dLCBSYW5nZVNsaWRlckNvbXBvbmVudCk7XG5cbnZhciBTd2l0Y2hDb21wb25lbnRfMTtcbmNvbnN0IEZPQ1VTRUQgPSAnay1mb2N1cyc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBTd2l0Y2ggY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3N3aXRjaCAlfSkuXG4gKi9cbmxldCBTd2l0Y2hDb21wb25lbnQgPSBTd2l0Y2hDb21wb25lbnRfMSA9IGNsYXNzIFN3aXRjaENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGhvc3RFbGVtZW50LCBsb2NhbGl6YXRpb25TZXJ2aWNlLCBpbmplY3RvciwgY2hhbmdlRGV0ZWN0b3IsIG5nWm9uZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2FibGVJZCA9IGBrLSR7Z3VpZCgpfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIFN3aXRjaCBpcyBkaXNhYmxlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX3N3aXRjaCAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBTd2l0Y2ggaXMgaW4gaXRzIHJlYWQtb25seSBzdGF0ZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlYWRvbmx5X3N3aXRjaCAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBbdGFiaW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBTd2l0Y2guXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBmb2N1c2VzIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGBpbnB1dGAgZWxlbWVudCBnZXRzIGJsdXJyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBzZWxlY3RzIGEgbmV3IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaG9zdENsaWNrU3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zaXplID0gJ21lZGl1bSc7XG4gICAgICAgIHRoaXMuX3RyYWNrUm91bmRlZCA9ICdmdWxsJztcbiAgICAgICAgdGhpcy5fdGh1bWJSb3VuZGVkID0gJ2Z1bGwnO1xuICAgICAgICB0aGlzLm5nQ2hhbmdlID0gKF8pID0+IHsgfTtcbiAgICAgICAgdGhpcy5uZ1RvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkZvY3VzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUJsdXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudCAmJiBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudC5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkJsdXIpIHx8IHJlcXVpcmVzWm9uZU9uQmx1cih0aGlzLmNvbnRyb2wpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1RvdWNoZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkJsdXIuZW1pdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBsb2NhbGl6YXRpb25TZXJ2aWNlLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIHRoaXMua2V5RG93bkhhbmRsZXIgPSB0aGlzLmtleURvd25IYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xpY2tIYW5kbGVyID0gdGhpcy5jbGlja0hhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIFN3aXRjaCB3aGVuIGl0IGlzIGluaXRpYWxseSBkaXNwbGF5ZWQuXG4gICAgICovXG4gICAgc2V0IGNoZWNrZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRIb3N0Q2xhc3Nlcyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2NoZWNrZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIFN3aXRjaC5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzbWFsbCdgXG4gICAgICogKiBgJ21lZGl1bSdgIChkZWZhdWx0KVxuICAgICAqICogYCdsYXJnZSdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKi9cbiAgICBzZXQgc2l6ZShzaXplKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xhc3NlcyhzaXplLCAnc2l6ZScpO1xuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGJvcmRlciByYWRpdXMgb2YgdGhlIFN3aXRjaCB0aHVtYi5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdmdWxsJ2AgKGRlZmF1bHQpXG4gICAgICogKiBgJ3NtYWxsJ2BcbiAgICAgKiAqIGAnbWVkaXVtJ2BcbiAgICAgKiAqIGAnbGFyZ2UnYFxuICAgICAqICogYG51bGxgXG4gICAgICovXG4gICAgc2V0IHRodW1iUm91bmRlZCh0aHVtYlJvdW5kZWQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVUaHVtYkNsYXNzZXModGh1bWJSb3VuZGVkKTtcbiAgICAgICAgdGhpcy5fdGh1bWJSb3VuZGVkID0gdGh1bWJSb3VuZGVkO1xuICAgIH1cbiAgICBnZXQgdGh1bWJSb3VuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGh1bWJSb3VuZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGJvcmRlciByYWRpdXMgb2YgdGhlIFN3aXRjaCB0cmFjay5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdmdWxsJ2AgKGRlZmF1bHQpXG4gICAgICogKiBgJ3NtYWxsJ2BcbiAgICAgKiAqIGAnbWVkaXVtJ2BcbiAgICAgKiAqIGAnbGFyZ2UnYFxuICAgICAqICogYG51bGxgXG4gICAgICovXG4gICAgc2V0IHRyYWNrUm91bmRlZCh0cmFja1JvdW5kZWQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVUcmFja0NsYXNzZXModHJhY2tSb3VuZGVkKTtcbiAgICAgICAgdGhpcy5fdHJhY2tSb3VuZGVkID0gdHJhY2tSb3VuZGVkO1xuICAgIH1cbiAgICBnZXQgdHJhY2tSb3VuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tSb3VuZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IHRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgZ2V0IGllQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiBicm93c2VyICYmIGJyb3dzZXIubXNpZTtcbiAgICB9XG4gICAgZ2V0IGFyaWFEaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyB0cnVlIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgYXJpYVJlYWRvbmx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkb25seTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IG9uTGFiZWxNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkxhYmVsIHx8IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQoJ29uJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgb2ZmTGFiZWxNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZMYWJlbCB8fCB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KCdvZmYnKTtcbiAgICB9XG4gICAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRpc2FibGVkICYmICF0aGlzLnJlYWRvbmx5O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh3cmFwcGVyLCBcInRhYmluZGV4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlXG4gICAgICAgICAgICAuY2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUoc2tpcCgxKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMuaW5qZWN0b3IuZ2V0KE5nQ29udHJvbCwgbnVsbCk7XG4gICAgICAgIHRoaXMubmdab25lLm9uU3RhYmxlLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLmF0dGFjaEhvc3RDbGlja0hhbmRsZXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrZWQgJiYgIXdyYXBwZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdrLXN3aXRjaC1vZmYnKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh3cmFwcGVyLCAnay1zd2l0Y2gtb2ZmJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVDbGFzc2VzKHRoaXMuc2l6ZSwgJ3NpemUnKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUcmFja0NsYXNzZXModGhpcy50cmFja1JvdW5kZWQpO1xuICAgICAgICB0aGlzLmhhbmRsZVRodW1iQ2xhc3Nlcyh0aGlzLnRodW1iUm91bmRlZCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaG9zdENsaWNrU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RDbGlja1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIFN3aXRjaC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHMtbm8tcnVuXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8YnV0dG9uIChjbGljayk9XCJzd2l0Y2guZm9jdXMoKVwiPkZvY3VzPC9idXR0b24+XG4gICAgICogIDxrZW5kby1zd2l0Y2ggI3N3aXRjaD48L2tlbmRvLXN3aXRjaD5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy50cmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2submF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgU3dpdGNoLlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmICghdGhpcy50cmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2submF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgc3RhdHVzIG9mIHRoZSBjb21wb25lbnQgY2hhbmdlcyB0byBvciBmcm9tIGBkaXNhYmxlZGAuXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSwgaXQgZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgYXBwcm9wcmlhdGUgRE9NIGVsZW1lbnQuXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSB2YWx1ZSA9PT0gbnVsbCA/IGZhbHNlIDogdmFsdWU7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMubmdDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBrZXlEb3duSGFuZGxlcihlKSB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCAmJiAoa2V5Q29kZSA9PT0gS2V5cy5TcGFjZSB8fCBrZXlDb2RlID09PSBLZXlzLkVudGVyKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZSghdGhpcy5jaGVja2VkKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY2xpY2tIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWUoIXRoaXMuY2hlY2tlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgYnkgdGhlIEZsb2F0aW5nTGFiZWwgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgaXMgZW1wdHkuXG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjaGFuZ2VWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jaGVja2VkICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgZm9jdXNlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQgIT09IHZhbHVlICYmIHRoaXMuaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHdyYXBwZXIsIEZPQ1VTRUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh3cmFwcGVyLCBGT0NVU0VEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoSG9zdENsaWNrSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ob3N0Q2xpY2tTdWJzY3JpcHRpb24uYWRkKHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldEhvc3RDbGFzc2VzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh3cmFwcGVyLCAnay1zd2l0Y2gtb2ZmJyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHdyYXBwZXIsICdrLXN3aXRjaC1vbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh3cmFwcGVyLCAnay1zd2l0Y2gtb24nKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3Mod3JhcHBlciwgJ2stc3dpdGNoLW9mZicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNsYXNzZXModmFsdWUsIGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBnZXRTdHlsaW5nQ2xhc3Nlcygnc3dpdGNoJywgaW5wdXQsIHRoaXNbaW5wdXRdLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjbGFzc2VzLnRvUmVtb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzZXMudG9SZW1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc2VzLnRvQWRkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW0sIGNsYXNzZXMudG9BZGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVRyYWNrQ2xhc3Nlcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2submF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IGdldFN0eWxpbmdDbGFzc2VzKCdzd2l0Y2gnLCAncm91bmRlZCcsIHRoaXMudHJhY2tSb3VuZGVkLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjbGFzc2VzLnRvUmVtb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzZXMudG9SZW1vdmUpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0cmFjaywgY2xhc3Nlcy50b1JlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzZXMudG9BZGQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbSwgY2xhc3Nlcy50b0FkZCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRyYWNrLCBjbGFzc2VzLnRvQWRkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVUaHVtYkNsYXNzZXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGh1bWIgPSB0aGlzLnRodW1iLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBnZXRTdHlsaW5nQ2xhc3Nlcygnc3dpdGNoJywgJ3JvdW5kZWQnLCB0aGlzLnRodW1iUm91bmRlZCwgdmFsdWUpO1xuICAgICAgICBpZiAoY2xhc3Nlcy50b1JlbW92ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aHVtYiwgY2xhc3Nlcy50b1JlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzZXMudG9BZGQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGh1bWIsIGNsYXNzZXMudG9BZGQpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFN3aXRjaENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNhYmxlSWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFN3aXRjaENvbXBvbmVudC5wcm90b3R5cGUsIFwib25MYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3dpdGNoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvZmZMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIFN3aXRjaENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTd2l0Y2hDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU3dpdGNoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU3dpdGNoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBTd2l0Y2hDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIFN3aXRjaENvbXBvbmVudC5wcm90b3R5cGUsIFwidGh1bWJSb3VuZGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBTd2l0Y2hDb21wb25lbnQucHJvdG90eXBlLCBcInRyYWNrUm91bmRlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgU3dpdGNoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnZm9jdXMnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgU3dpdGNoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2JsdXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgU3dpdGNoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBTd2l0Y2hDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5kaXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3dpdGNoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWllJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFN3aXRjaENvbXBvbmVudC5wcm90b3R5cGUsIFwiaWVDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgU3dpdGNoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhRGlzYWJsZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLXJlYWRvbmx5JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFN3aXRjaENvbXBvbmVudC5wcm90b3R5cGUsIFwiYXJpYVJlYWRvbmx5XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc3dpdGNoJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTd2l0Y2hDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBTd2l0Y2hDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3RyYWNrJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFN3aXRjaENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJhY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgndGh1bWInLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU3dpdGNoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aHVtYlwiLCB2b2lkIDApO1xuU3dpdGNoQ29tcG9uZW50ID0gU3dpdGNoQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvU3dpdGNoJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgeyBwcm92aWRlOiBMMTBOX1BSRUZJWCwgdXNlVmFsdWU6ICdrZW5kby5zd2l0Y2gnIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU3dpdGNoQ29tcG9uZW50XzEpIC8qIHRzbGludDpkaXNhYmxlLWxpbmUgKi9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogS2VuZG9JbnB1dCxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTd2l0Y2hDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1zd2l0Y2gnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvU3dpdGNoTG9jYWxpemVkTWVzc2FnZXNcbiAgICAgICAgICAgIGkxOG4tb249XCJrZW5kby5zd2l0Y2gub258VGhlICoqT24qKiBsYWJlbCBvZiB0aGUgU3dpdGNoLlwiXG4gICAgICAgICAgICBvbj1cIk9OXCJcbiAgICAgICAgICAgIGkxOG4tb2ZmPVwia2VuZG8uc3dpdGNoLm9mZnxUaGUgKipPZmYqKiBsYWJlbCBvZiB0aGUgU3dpdGNoLlwiXG4gICAgICAgICAgICBvZmY9XCJPRkZcIlxuICAgICAgICA+XG5cbiAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICN0cmFja1xuICAgICAgICAgICAgY2xhc3M9XCJrLXN3aXRjaC10cmFja1wiXG4gICAgICAgICAgICBbaWRdPVwiZm9jdXNhYmxlSWRcIlxuICAgICAgICAgICAgcm9sZT1cInN3aXRjaFwiXG4gICAgICAgICAgICBbc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXT1cImluaXRpYWxpemVkID8gJzIwMG1zJyA6ICcwbXMnXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtY2hlY2tlZF09XCJjaGVja2VkXCJcbiAgICAgICAgICAgIFthdHRyLnRhYmluZGV4XT1cIihkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IHRhYkluZGV4KVwiXG4gICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7IGtleWRvd246IGtleURvd25IYW5kbGVyLCBmb2N1czogaGFuZGxlRm9jdXMsIGJsdXI6IGhhbmRsZUJsdXIgfVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1zd2l0Y2gtbGFiZWwtb25cIiBbYXR0ci5hcmlhLWhpZGRlbl09XCJ0cnVlXCIgPnt7b25MYWJlbE1lc3NhZ2V9fTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1zd2l0Y2gtbGFiZWwtb2ZmXCIgW2F0dHIuYXJpYS1oaWRkZW5dPVwidHJ1ZVwiPnt7b2ZmTGFiZWxNZXNzYWdlfX08L3NwYW4+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPHNwYW5cbiAgICAgICAgICAgIGNsYXNzPVwiay1zd2l0Y2gtdGh1bWItd3JhcFwiXG4gICAgICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uRHVyYXRpb25dPVwiaW5pdGlhbGl6ZWQgPyAnMjAwbXMnIDogJzBtcydcIiBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAga2V5ZG93bjoga2V5RG93bkhhbmRsZXIsXG4gICAgICAgICAgICAgICAgZm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgICAgICAgICAgICAgIGJsdXI6IGhhbmRsZUJsdXJcbiAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgIDxzcGFuICN0aHVtYiBjbGFzcz1cImstc3dpdGNoLXRodW1iXCI+PC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG4gIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JlbmRlcmVyMixcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgSW5qZWN0b3IsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBOZ1pvbmVdKVxuXSwgU3dpdGNoQ29tcG9uZW50KTtcblxudmFyIFRleHRCb3hEaXJlY3RpdmVfMTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIFRleHRCb3ggZGlyZWN0aXZlXSh7JSBzbHVnIG92ZXJ2aWV3X3RleHRib3ggJX0pIGZvciB0aGUgSW5wdXRzIGNvbXBvbmVudHMgZm9yIEFuZ3VsYXIuXG4gKiBVc2VkIHRvIHN0eWxlIHRoZSB0ZXh0Ym94IG9mIGFueSBgaW5wdXRgIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogPGlucHV0IGtlbmRvVGV4dEJveCAvPlxuICogPGlucHV0IGtlbmRvVGV4dEJveCB0eXBlPVwiZW1haWxcIiAvPlxuICogPGlucHV0IGtlbmRvVGV4dEJveCB0eXBlPVwicGFzc3dvcmRcIiAvPlxuICogYGBgXG4gKi9cbmxldCBUZXh0Qm94RGlyZWN0aXZlID0gVGV4dEJveERpcmVjdGl2ZV8xID0gY2xhc3MgVGV4dEJveERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGlucHV0RWxlbWVudCwgbmdab25lKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQgPSBpbnB1dEVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CbHVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvRmlsbFN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvRmlsbEVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh0ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LnZhbHVlID0gKHRleHQgPT09IHVuZGVmaW5lZCB8fCB0ZXh0ID09PSBudWxsKSA/ICcnIDogdGV4dDtcbiAgICAgICAgdGhpcy5vblZhbHVlQ2hhbmdlLmVtaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuaWQ7XG4gICAgfVxuICAgIHNldCBpZChpZCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmlucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWQnLCBpZCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKGlucHV0LCAnZm9jdXMnLCAoKSA9PiB0aGlzLm9uRm9jdXMuZW1pdCgpKSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKGlucHV0LCAnYmx1cicsICgpID0+IHRoaXMub25CbHVyLmVtaXQoKSlcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5saXN0ZW4oaW5wdXQsICdhbmltYXRpb25zdGFydCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuYW5pbWF0aW9uTmFtZSA9PT0gJ2F1dG9GaWxsU3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b0ZpbGxTdGFydC5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuYW5pbWF0aW9uTmFtZSA9PT0gJ2F1dG9GaWxsRW5kJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9GaWxsRW5kLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKCkpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay10ZXh0Ym94JyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstaW5wdXQnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1pbnB1dC1tZCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXJvdW5kZWQtbWQnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1pbnB1dC1zb2xpZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGV4dEJveERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgVGV4dEJveERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG5UZXh0Qm94RGlyZWN0aXZlID0gVGV4dEJveERpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFtrZW5kb1RleHRCb3hdJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtlbmRvSW5wdXQsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGV4dEJveERpcmVjdGl2ZV8xKVxuICAgICAgICAgICAgfV1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JlbmRlcmVyMixcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgTmdab25lXSlcbl0sIFRleHRCb3hEaXJlY3RpdmUpO1xuXG52YXIgVGV4dEFyZWFEaXJlY3RpdmVfMTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIFRleHRBcmVhIGRpcmVjdGl2ZSBmb3IgdGhlIElucHV0cyBjb21wb25lbnRzIGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3RleHRhcmVhICV9KS5cbiAqIFByb3ZpZGVzIGZsb2F0aW5nIGxhYmVscyB0byBgdGV4dGFyZWFgIGVsZW1lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1uby1ydW5cbiAqIDx0ZXh0YXJlYSBrZW5kb1RleHRBcmVhPjwvdGV4dGFyZWE+XG4gKiBgYGBcbiAqL1xubGV0IFRleHRBcmVhRGlyZWN0aXZlID0gVGV4dEFyZWFEaXJlY3RpdmVfMSA9IGNsYXNzIFRleHRBcmVhRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgZWxlbWVudCwgem9uZSwgY2hhbmdlRGV0ZWN0b3IsIGluamVjdG9yLCBydGwpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5lbGVtZW50Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuYXV0b2ZpbGxDbGFzcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHRleHRhcmVhIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSBgdGV4dGFyZWFgIGVsZW1lbnQgd2lsbCByZXNpemUgaXRzIGhlaWdodCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfdGV4dGFyZWEgJX0jdG9jLWF1dG8tcmVzaXppbmcpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b1NpemUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CbHVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvRmlsbFN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvRmlsbEVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5uZ0NoYW5nZSA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmlkO1xuICAgIH1cbiAgICBzZXQgaWQoaWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdpZCcsIGlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5uZ0NoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5uZ1RvdWNoZWQgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnRQcm9wZXJ0eSgnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMuYmluZCh0aGlzKSksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIuYmluZCh0aGlzKSksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2FuaW1hdGlvbnN0YXJ0JywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYW5pbWF0aW9uTmFtZSA9PT0gJ2F1dG9GaWxsU3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9GaWxsU3RhcnQuZW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuYW5pbWF0aW9uTmFtZSA9PT0gJ2F1dG9GaWxsRW5kJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvRmlsbEVuZC5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChpc0RvY3VtZW50QXZhaWxhYmxlKCkgJiYgdGhpcy5hdXRvU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKChkZWJvdW5jZVRpbWUoNTApKSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnJlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQoZWxlbWVudCwgJ2lucHV0JylcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuaGFuZGxlSW5wdXQuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSB0aGlzLmluamVjdG9yLmdldChOZ0NvbnRyb2wsIG51bGwpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKGNoYW5nZXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5hdXRvU2l6ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsICdyZXNpemUnLCAnbm9uZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbGVtZW50LCAnb3ZlcmZsb3cteScsICdhdXRvJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbGVtZW50LCAncmVzaXplJywgJ2JvdGgnKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke3RoaXMuaW5pdGlhbEhlaWdodH1weGA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy56b25lLm9uU3RhYmxlLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVzaXplKCkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXNpemVTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnRWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgc2V0IGVsZW1lbnRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnRQcm9wZXJ0eSgndmFsdWUnLCAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkgPyAnJyA6IHZhbHVlKTtcbiAgICB9XG4gICAgc2V0RWxlbWVudFByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5hdXRvU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbGVtZW50LCAnb3ZlcmZsb3cteScsICdoaWRkZW4nKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmluaXRpYWxIZWlnaHR9cHhgO1xuICAgICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAgICAgaWYgKHNjcm9sbEhlaWdodCA+IHRoaXMuaW5pdGlhbEhlaWdodCkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtzY3JvbGxIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUlucHV0KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZWxlbWVudFZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2wgfHwgaGFzT2JzZXJ2ZXJzKHRoaXMub25WYWx1ZUNoYW5nZSkgfHwgaGFzT2JzZXJ2ZXJzKHRoaXMudmFsdWVDaGFuZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9XG4gICAgaGFuZGxlRm9jdXMoKSB7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkZvY3VzKSkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUJsdXIoKSB7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkJsdXIpIHx8IHJlcXVpcmVzWm9uZU9uQmx1cih0aGlzLmNvbnRyb2wpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nVG91Y2hlZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdGV4dGFyZWEnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1pbnB1dCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWlucHV0LW1kJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstcm91bmRlZC1tZCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWlucHV0LXNvbGlkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUZXh0QXJlYURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZWxlbWVudENsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWF1dG9maWxsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUZXh0QXJlYURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYXV0b2ZpbGxDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRleHRBcmVhRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUZXh0QXJlYURpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUZXh0QXJlYURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYXV0b1NpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRleHRBcmVhRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuVGV4dEFyZWFEaXJlY3RpdmUgPSBUZXh0QXJlYURpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgcHJvdmlkZXJzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRleHRBcmVhRGlyZWN0aXZlXzEpLFxuICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogS2VuZG9JbnB1dCxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUZXh0QXJlYURpcmVjdGl2ZV8xKVxuICAgICAgICAgICAgfV0sXG4gICAgICAgIHNlbGVjdG9yOiAndGV4dGFyZWFba2VuZG9UZXh0QXJlYV0nXG4gICAgfSksXG4gICAgX19wYXJhbSg1LCBPcHRpb25hbCgpKSwgX19wYXJhbSg1LCBJbmplY3QoUlRMKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtSZW5kZXJlcjIsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEluamVjdG9yLCBCb29sZWFuXSlcbl0sIFRleHRBcmVhRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNyZWF0ZU1heFZhbGlkYXRvciA9IChtYXhWYWx1ZSkgPT4ge1xuICAgIHJldHVybiAoYykgPT4ge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChtYXhWYWx1ZSkgfHwgIWlzUHJlc2VudChjLnZhbHVlKSB8fCBjLnZhbHVlIDw9IG1heFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF4RXJyb3I6IHtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZTogbWF4VmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGMudmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNyZWF0ZU1pblZhbGlkYXRvciA9IChtaW5WYWx1ZSkgPT4ge1xuICAgIHJldHVybiAoYykgPT4ge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChtaW5WYWx1ZSkgfHwgIWlzUHJlc2VudChjLnZhbHVlKSB8fCBjLnZhbHVlID49IG1pblZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluRXJyb3I6IHtcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZTogbWluVmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGMudmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE1JTl9ET0NfTElOSyA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9pbnB1dHMvYXBpL051bWVyaWNUZXh0Qm94Q29tcG9uZW50LyN0b2MtbWluJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBNQVhfRE9DX0xJTksgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvaW5wdXRzL2FwaS9OdW1lcmljVGV4dEJveENvbXBvbmVudC8jdG9jLW1heCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUE9JTlQgPSBcIi5cIjtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBJTklUSUFMX1NQSU5fREVMQVkgPSA1MDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgU1BJTl9ERUxBWSA9IDUwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEVYUE9ORU5UX1JFR0VYID0gL1tlRV1bXFwtK10/KFswLTldKykvO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbnVtZXJpY1JlZ2V4ID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IGF1dG9Db3JyZWN0LCBkZWNpbWFscywgbWluIH0gPSBvcHRpb25zO1xuICAgIGxldCBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvcjtcbiAgICBpZiAoc2VwYXJhdG9yID09PSBQT0lOVCkge1xuICAgICAgICBzZXBhcmF0b3IgPSAnXFxcXCcgKyBzZXBhcmF0b3I7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25QYXR0ZXJuID0gYXV0b0NvcnJlY3QgJiYgbWluICE9PSBudWxsICYmIG1pbiA+PSAwID8gJycgOiAnLT8nO1xuICAgIGxldCBudW1iZXJQYXR0ZXJuO1xuICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICBudW1iZXJQYXR0ZXJuID0gJ1xcXFxkKic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBudW1iZXJQYXR0ZXJuID0gYCg/Oig/OlxcXFxkKygke3NlcGFyYXRvcn1cXFxcZCopPyl8KD86JHtzZXBhcmF0b3J9XFxcXGQqKSk/YDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3NpZ25QYXR0ZXJufSR7bnVtYmVyUGF0dGVybn0kYCk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRlY2ltYWxQYXJ0ID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlID49IDAgPyBNYXRoLmZsb29yKHZhbHVlKSA6IE1hdGguY2VpbCh2YWx1ZSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG5vb3AgPSAoXykgPT4geyB9OyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWVtcHR5XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGVmaW5lZCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAhaXNOYU4odmFsdWUpICYmIHZhbHVlICE9PSBudWxsO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBwYWQodmFsdWUsIGRpZ2l0cykge1xuICAgIGNvbnN0IGNvdW50ID0gZGlnaXRzIC0gU3RyaW5nKHZhbHVlKS5sZW5ndGg7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlO1xuICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgY29uc3QgcGFkU3RyaW5nID0gbmV3IEFycmF5KGNvdW50ICsgMSkuam9pbihcIjBcIik7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQodmFsdWUgKyBwYWRTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldERlbHRhRnJvbU1vdXNlV2hlZWwgPSAoZSkgPT4ge1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgaWYgKGUud2hlZWxEZWx0YSkge1xuICAgICAgICBkZWx0YSA9IGUud2hlZWxEZWx0YSAvIDEyMDtcbiAgICAgICAgZGVsdGEgPSBkZWx0YSA+IDAgPyBNYXRoLmNlaWwoZGVsdGEpIDogTWF0aC5mbG9vcihkZWx0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGUuZGV0YWlsKSB7XG4gICAgICAgIGRlbHRhID0gTWF0aC5yb3VuZCgtZS5kZXRhaWwgLyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbHRhO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBnZXRDYXJldFBvc2l0aW9uID0gKGVsZW1lbnQpID0+IGVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZXh0cmFjdFNpZ25pZmljYW50TnVtZXJpY0NoYXJzID0gKGZvcm1hdHRlZFN0cmluZywgc2VwYXJhdG9yKSA9PiB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRDaGFyYWN0ZXJzID0gYCR7c2VwYXJhdG9yfTAxMjM0NTY3ODktYDtcbiAgICByZXR1cm4gZm9ybWF0dGVkU3RyaW5nLnNwbGl0KCcnKS5yZWR1Y2UoKGFjYywgY3VycikgPT4gc2lnbmlmaWNhbnRDaGFyYWN0ZXJzLmluY2x1ZGVzKGN1cnIpID8gKythY2MgOiBhY2MsIDApO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1JpZ2h0Q2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBpc1JpZ2h0Q2xpY2tJRSA9IGV2ZW50LmJ1dHRvbiAmJiBldmVudC5idXR0b24gPT09IDI7XG4gICAgY29uc3QgaXNSaWdodENsaWNrT3RoZXIgPSBldmVudC53aGljaCAmJiBldmVudC53aGljaCA9PT0gMztcbiAgICByZXR1cm4gaXNSaWdodENsaWNrSUUgfHwgaXNSaWdodENsaWNrT3RoZXI7XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xudmFyIEFycm93RGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChBcnJvd0RpcmVjdGlvbikge1xuICAgIEFycm93RGlyZWN0aW9uW0Fycm93RGlyZWN0aW9uW1wiRG93blwiXSA9IC0xXSA9IFwiRG93blwiO1xuICAgIEFycm93RGlyZWN0aW9uW0Fycm93RGlyZWN0aW9uW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgQXJyb3dEaXJlY3Rpb25bQXJyb3dEaXJlY3Rpb25bXCJVcFwiXSA9IDFdID0gXCJVcFwiO1xufSkoQXJyb3dEaXJlY3Rpb24gfHwgKEFycm93RGlyZWN0aW9uID0ge30pKTtcblxudmFyIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50XzE7XG5jb25zdCBQQVJTQUJMRV9PUFRJT05TID0gWydtaW4nLCAnbWF4JywgJ3N0ZXAnLCAnZGVjaW1hbHMnXTtcbmNvbnN0IFBBUlNBQkxFX0RFRkFVTFRTID0ge1xuICAgIGRlY2ltYWxzOiBudWxsLFxuICAgIG1heDogbnVsbCxcbiAgICBtaW46IG51bGwsXG4gICAgc3RlcDogMVxufTtcbmNvbnN0IEZPQ1VTRUQkMSA9ICdrLWZvY3VzJztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIE51bWVyaWNUZXh0Qm94IGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19udW1lcmljdGV4dGJveCAlfSkuXG4gKi9cbmxldCBOdW1lcmljVGV4dEJveENvbXBvbmVudCA9IE51bWVyaWNUZXh0Qm94Q29tcG9uZW50XzEgPSBjbGFzcyBOdW1lcmljVGV4dEJveENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoaW50bCwgcmVuZGVyZXIsIGxvY2FsaXphdGlvblNlcnZpY2UsIGluamVjdG9yLCBuZ1pvbmUsIGNoYW5nZURldGVjdG9yLCBob3N0RWxlbWVudCkge1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2FibGVJZCA9IGBrLSR7Z3VpZCgpfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIE51bWVyaWNUZXh0Qm94IGlzIGRpc2FibGVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGlzYWJsZWRfbnVtZXJpY3RleHRib3ggJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgTnVtZXJpY1RleHRCb3ggaXMgaW4gaXRzIHJlYWQtb25seSBzdGF0ZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlYWRvbmx5X251bWVyaWN0ZXh0Ym94ICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50IG9mIHRoZSBOdW1lcmljVGV4dEJveC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGl0bGUgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRoZSB2YWx1ZSB3aWxsIGJlIGF1dG8tY29ycmVjdGVkIGJhc2VkIG9uIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlc1xuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHByZWNpc2lvbl9udW1lcmljdGV4dGJveCAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgZGVjaW1hbHMgdGhhdCB0aGUgdXNlciBjYW4gZW50ZXIgd2hlbiB0aGUgaW5wdXQgaXMgZm9jdXNlZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHByZWNpc2lvbl9udW1lcmljdGV4dGJveCAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWNpbWFscyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHZhbHVlIHRoYXQgaXMgdXNlZCB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRoZSBjb21wb25lbnQgdmFsdWVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwcmVkZWZpbmVkc3RlcHNfbnVtZXJpY3RleHRib3ggJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RlcCA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgKipVcCoqIGFuZCAqKkRvd24qKiBzcGluIGJ1dHRvbnMgd2lsbCBiZSByZW5kZXJlZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNwaW5idXR0b25zX251bWVyaWN0ZXh0Ym94ICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNwaW5uZXJzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gbWluaW11bSBvciBtYXhpbXVtIHZhbGlkYXRvcnMgYXJlIGVuZm9yY2VkIHdoZW4gYSBmb3JtIGlzIHZhbGlkYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUaGUgNC4yLjAgQW5ndWxhciB2ZXJzaW9uIGludHJvZHVjZXMgdGhlIGBtaW5gIGFuZCBgbWF4YCB2YWxpZGF0aW9uIGRpcmVjdGl2ZXMuIEFzIGEgcmVzdWx0LCBldmVuIGlmIHlvdSBzZXQgYHJhbmdlVmFsaWRhdGlvbmBcbiAgICAgICAgICogdG8gYGZhbHNlYCwgdGhlIGJ1aWx0LWluIEFuZ3VsYXIgdmFsaWRhdG9ycyB3aWxsIGJlIGV4ZWN1dGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZVZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBbdGFiaW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgdmFsdWUgb2YgdGhlIE51bWVyaWNUZXh0Qm94IHdpbGwgYmUgY2hhbmdlZCB2aWEgc2Nyb2xsaW5nLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbmdlVmFsdWVPblNjcm9sbCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHdob2xlIHZhbHVlIHdpbGwgYmUgc2VsZWN0ZWQgd2hlbiB0aGUgTnVtZXJpY1RleHRCb3ggaXMgY2xpY2tlZC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RPbkZvY3VzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgdmFsdWUgb2YgdGhlIE51bWVyaWNUZXh0Qm94XG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZm9ybWF0c19udW1lcmljdGV4dGJveCAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgc2VsZWN0cyBhIG5ldyB2YWx1ZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X251bWVyaWN0ZXh0Ym94ICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgZm9jdXNlcyB0aGUgYGlucHV0YCBlbGVtZW50IChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfbnVtZXJpY3RleHRib3ggJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBgaW5wdXRgIGVsZW1lbnQgZ2V0cyBibHVycmVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfbnVtZXJpY3RleHRib3ggJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLkFycm93RGlyZWN0aW9uID0gQXJyb3dEaXJlY3Rpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFycm93RGlyZWN0aW9uID0gQXJyb3dEaXJlY3Rpb24uTm9uZTtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLm1pblZhbGlkYXRlRm4gPSBub29wO1xuICAgICAgICB0aGlzLm1heFZhbGlkYXRlRm4gPSBub29wO1xuICAgICAgICB0aGlzLl9mb3JtYXQgPSBcIm4yXCI7XG4gICAgICAgIHRoaXMuaXNQYXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICB0aGlzLl9yb3VuZGVkID0gJ21lZGl1bSc7XG4gICAgICAgIHRoaXMuX2ZpbGxNb2RlID0gJ3NvbGlkJztcbiAgICAgICAgdGhpcy5uZ0NoYW5nZSA9IG5vb3A7XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gbm9vcDtcbiAgICAgICAgdGhpcy5uZ1ZhbGlkYXRvckNoYW5nZSA9IG5vb3A7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluY3JlYXNlUHJlc3MgPSAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcnJvd1ByZXNzKEFycm93RGlyZWN0aW9uLlVwLCBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVjcmVhc2VQcmVzcyA9IChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFycm93UHJlc3MoQXJyb3dEaXJlY3Rpb24uRG93biwgZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbGVhc2VBcnJvdyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNwaW5UaW1lb3V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFycm93RGlyZWN0aW9uICE9PSBBcnJvd0RpcmVjdGlvbi5Ob25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJvd0RpcmVjdGlvbiA9IEFycm93RGlyZWN0aW9uLk5vbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZVBhc3RlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc1Bhc3RlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUlucHV0ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLm51bWVyaWNJbnB1dC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgbGV0IHsgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCwgdmFsdWU6IGlucHV0VmFsdWUgfSA9IGlucHV0O1xuICAgICAgICAgICAgaWYgKHRoaXMucHJlc3NlZEtleSA9PT0gS2V5cy5OdW1wYWREZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHRoaXMucmVwbGFjZU51bXBhZERvdFZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Bhc3RlZCkge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSB0aGlzLmZvcm1hdElucHV0VmFsdWUodGhpcy5pbnRsLnBhcnNlTnVtYmVyKGlucHV0VmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKGlucHV0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLmlucHV0VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uU3RhcnQgLSAxLCBzZWxlY3Rpb25FbmQgLSAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHRoaXMuaW50bC5wYXJzZU51bWJlcihpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMucmVzdHJpY3REZWNpbWFscyhwYXJzZWRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvQ29ycmVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0ZWQgPSB0aGlzLmxpbWl0SW5wdXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsaW1pdGVkLnZhbHVlO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gbGltaXRlZC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQgPSBsaW1pdGVkLnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZWRWYWx1ZSAhPT0gdmFsdWUgfHwgdGhpcy5oYXNUcmFpbGluZ1plcm9zKGlucHV0VmFsdWUpIHx8ICF0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldElucHV0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFZhbHVlID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzUGFzdGVkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLmlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pc1Bhc3RlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW50ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9jdXNlZCAmJiAhdGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbnB1dFZhbHVlKHRoaXMudmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURvd24gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFNlbGVjdEFsbCA9IHRoaXMuc2VsZWN0T25Gb2N1cyB8fCAhdGhpcy5tb3VzZURvd247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTZWxlY3RBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Q2FyZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkZvY3VzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUJsdXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAvL2JsdXIgaXMgdGhyb3duIGJlZm9yZSBpbnB1dCB3aGVuIGRyYWdnaW5nIHRoZSBpbnB1dCB0ZXh0IGluIElFXG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dFZhbHVlICE9PSB0aGlzLmVsZW1lbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5wdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uQmx1cikgfHwgcmVxdWlyZXNab25lT25CbHVyKHRoaXMuY29udHJvbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nVG91Y2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUtleURvd24gPSAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGVwO1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS2V5cy5BcnJvd0Rvd24pIHtcbiAgICAgICAgICAgICAgICBzdGVwID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT09IEtleXMuQXJyb3dVcCkge1xuICAgICAgICAgICAgICAgIHN0ZXAgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0ZXAgJiYgdGhpcy5zdGVwKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3RlcChzdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5udW1lcmljSW5wdXQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZWxlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkS2V5ID0gZS5rZXlDb2RlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVXaGVlbCA9IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2N1c2VkICYmICF0aGlzLmlzRGlzYWJsZWQgJiYgdGhpcy5jaGFuZ2VWYWx1ZU9uU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZ2V0RGVsdGFGcm9tTW91c2VXaGVlbChlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN0ZXAoZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBsb2NhbGl6YXRpb25TZXJ2aWNlLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIGZvcm1hdCB3aGljaCBpcyB1c2VkIHdoZW4gdGhlIE51bWVyaWNUZXh0Qm94IGlzIG5vdCBmb2N1c2VkXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBmb3JtYXRzX251bWVyaWN0ZXh0Ym94ICV9KSkuXG4gICAgICogSWYgYGZvcm1hdGAgaXMgc2V0IHRvIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIGRlZmF1bHQgZm9ybWF0IHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgZm9ybWF0KCkge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLl9mb3JtYXQ7XG4gICAgICAgIHJldHVybiBmb3JtYXQgIT09IG51bGwgJiYgZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiAnbjInO1xuICAgIH1cbiAgICBzZXQgZm9ybWF0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Zvcm1hdCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IHRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNpemUgcHJvcGVydHkgc3BlY2lmaWVzIHBhZGRpbmcgb2YgdGhlIE51bWVyaWNUZXh0Qm94IGludGVybmFsIGlucHV0IGVsZW1lbnRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwcGVhcmFuY2VfbnVtZXJpY3RleHRib3ggJX0jdG9jLXNpemUpKS5cbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGAnc21hbGwnYFxuICAgICAqICogYCdtZWRpdW0nYCAoZGVmYXVsdClcbiAgICAgKiAqIGAnbGFyZ2UnYFxuICAgICAqICogYG51bGxgXG4gICAgICovXG4gICAgc2V0IHNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUNsYXNzZXMoc2l6ZSwgJ3NpemUnKTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJvdW5kZWQgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBib3JkZXIgcmFkaXVzIG9mIHRoZSBOdW1lcmljVGV4dEJveFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBwZWFyYW5jZV9udW1lcmljdGV4dGJveCAlfSN0b2Mtcm91bmRlZCkpLlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzbWFsbCdgXG4gICAgICogKiBgJ21lZGl1bSdgIChkZWZhdWx0KVxuICAgICAqICogYCdsYXJnZSdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKi9cbiAgICBzZXQgcm91bmRlZChyb3VuZGVkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xhc3Nlcyhyb3VuZGVkLCAncm91bmRlZCcpO1xuICAgICAgICB0aGlzLl9yb3VuZGVkID0gcm91bmRlZDtcbiAgICB9XG4gICAgZ2V0IHJvdW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3VuZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlsbE1vZGUgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBiYWNrZ3JvdW5kIGFuZCBib3JkZXIgc3R5bGVzIG9mIHRoZSBOdW1lcmljVGV4dEJveFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBwZWFyYW5jZV9udW1lcmljdGV4dGJveCAlfSN0b2MtZmlsbE1vZGUpKS5cbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGAnZmxhdCdgXG4gICAgICogKiBgJ3NvbGlkJ2AgKGRlZmF1bHQpXG4gICAgICogKiBgJ291dGxpbmUnYFxuICAgICAqICogYG51bGxgXG4gICAgICovXG4gICAgc2V0IGZpbGxNb2RlKGZpbGxNb2RlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xhc3NlcyhmaWxsTW9kZSwgJ2ZpbGxNb2RlJyk7XG4gICAgICAgIHRoaXMuX2ZpbGxNb2RlID0gZmlsbE1vZGU7XG4gICAgfVxuICAgIGdldCBmaWxsTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxNb2RlO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMubG9jYWxpemF0aW9uU2VydmljZVxuICAgICAgICAgICAgLmNoYW5nZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5pbnRsLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMuaW50bENoYW5nZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIGlmICh0aGlzLmhvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIFwidGFiaW5kZXhcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250cm9sID0gdGhpcy5pbmplY3Rvci5nZXQoTmdDb250cm9sLCBudWxsKTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb21FdmVudHMucHVzaCh0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtb3VzZXdoZWVsJywgdGhpcy5oYW5kbGVXaGVlbC5iaW5kKHRoaXMpKSk7XG4gICAgICAgICAgICB0aGlzLmRvbUV2ZW50cy5wdXNoKHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5oYW5kbGVXaGVlbC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGNvbnN0IHN0eWxpbmdJbnB1dHMgPSBbJ3NpemUnLCAncm91bmRlZCcsICdmaWxsTW9kZSddO1xuICAgICAgICBzdHlsaW5nSW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGFzc2VzKHRoaXNbaW5wdXRdLCBpbnB1dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoYW55Q2hhbmdlZChQQVJTQUJMRV9PUFRJT05TLCBjaGFuZ2VzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VPcHRpb25zKFBBUlNBQkxFX09QVElPTlMuZmlsdGVyKG9wdGlvbiA9PiBjaGFuZ2VzW29wdGlvbl0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcmlmeVNldHRpbmdzKCk7XG4gICAgICAgIGlmIChhbnlDaGFuZ2VkKFsnbWluJywgJ21heCcsICdyYW5nZVZhbGlkYXRpb24nXSwgY2hhbmdlcywgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLm1pblZhbGlkYXRlRm4gPSB0aGlzLnJhbmdlVmFsaWRhdGlvbiA/IGNyZWF0ZU1pblZhbGlkYXRvcih0aGlzLm1pbikgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5tYXhWYWxpZGF0ZUZuID0gdGhpcy5yYW5nZVZhbGlkYXRpb24gPyBjcmVhdGVNYXhWYWxpZGF0b3IodGhpcy5tYXgpIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMubmdWYWxpZGF0b3JDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlZChbJ2F1dG9Db3JyZWN0JywgJ2RlY2ltYWxzJywgJ21pbiddLCBjaGFuZ2VzKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubnVtZXJpY1JlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlDaGFuZ2VkKFsndmFsdWUnLCAnZm9ybWF0J10sIGNoYW5nZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnJlc3RyaWN0TW9kZWxWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb2N1c2VkIHx8ICh0aGlzLmludGwucGFyc2VOdW1iZXIodGhpcy5lbGVtZW50VmFsdWUpICE9PSB0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc3BpblRpbWVvdXQpO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cy5mb3JFYWNoKHVuYmluZEhhbmRsZXIgPT4gdW5iaW5kSGFuZGxlcigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHZhbGlkYXRlKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluVmFsaWRhdGVGbihjb250cm9sKSB8fCB0aGlzLm1heFZhbGlkYXRlRm4oY29udHJvbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMubmdWYWxpZGF0b3JDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGxldCByZXN0cmljdGVkVmFsdWUgPSB0aGlzLnJlc3RyaWN0TW9kZWxWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSByZXN0cmljdGVkVmFsdWU7XG4gICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm5nQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm5nVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXR1cyBvZiB0aGUgY29tcG9uZW50IGNoYW5nZXMgdG8gb3IgZnJvbSBgZGlzYWJsZWRgLlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgdmFsdWUsIGl0IGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGFwcHJvcHJpYXRlIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWRcbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIE51bWVyaWNUZXh0Qm94LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0cy1uby1ydW5cbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxidXR0b24gKGNsaWNrKT1cIm51bWVyaWN0ZXh0Ym94LmZvY3VzKClcIj5Gb2N1cyBOdW1lcmljVGV4dEJveDwvYnV0dG9uPlxuICAgICAqICA8a2VuZG8tbnVtZXJpY3RleHRib3ggI251bWVyaWN0ZXh0Ym94Pjwva2VuZG8tbnVtZXJpY3RleHRib3g+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKHRoaXMubnVtZXJpY0lucHV0LCAnZm9jdXMnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIE51bWVyaWNUZXh0Qm94LlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGludm9rZUVsZW1lbnRNZXRob2QodGhpcy5udW1lcmljSW5wdXQsICdibHVyJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBgTnVtZXJpY1RleHRCb3hDb21wb25lbnRgIHRoYXQgdGhlIGlucHV0IHZhbHVlIHNob3VsZCBiZSBjaGFuZ2VkLlxuICAgICAqIENhbiBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgaW5wdXQgYWZ0ZXIgc2V0dGluZyB0aGUgY29tcG9uZW50IHByb3BlcnRpZXMgZGlyZWN0bHkuXG4gICAgICovXG4gICAgbm90aWZ5VmFsdWVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGluY3JlbWVudFRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmdldCgnaW5jcmVtZW50Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZGVjcmVtZW50VGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KCdkZWNyZW1lbnQnKTtcbiAgICB9XG4gICAgZ2V0IGRlY2ltYWxTZXBhcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IG51bWJlclN5bWJvbHMgPSB0aGlzLmludGwubnVtYmVyU3ltYm9scygpO1xuICAgICAgICByZXR1cm4gbnVtYmVyU3ltYm9scy5kZWNpbWFsO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1lcmljSW5wdXQubmF0aXZlRWxlbWVudC52YWx1ZTtcbiAgICB9XG4gICAgc2V0IGVsZW1lbnRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMubnVtZXJpY0lucHV0Lm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRm9jdXNlZDtcbiAgICB9XG4gICAgZ2V0IGhhc0RlY2ltYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNpbWFscyAhPT0gbnVsbCAmJiB0aGlzLmRlY2ltYWxzID49IDA7XG4gICAgfVxuICAgIHNldCBmb2N1c2VkKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRm9jdXNlZCAhPT0gdmFsdWUgJiYgdGhpcy5ob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3Qgd3JhcCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3Mod3JhcCwgRk9DVVNFRCQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3Mod3JhcCwgRk9DVVNFRCQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzRGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHk7XG4gICAgfVxuICAgIGFycm93UHJlc3MoZGlyZWN0aW9uLCBlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNhYmxlZCB8fCBpc1JpZ2h0Q2xpY2soZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vYmlsZU9TKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFycm93RGlyZWN0aW9uICE9PSBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYXJyb3dEaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGVwKSB7XG4gICAgICAgICAgICB0aGlzLnNwaW4oZGlyZWN0aW9uLCBJTklUSUFMX1NQSU5fREVMQVkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRJbnB1dFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFhcmVTYW1lKHRoaXMudmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ0NoYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZU51bXBhZERvdFZhbHVlKCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmlucHV0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5udW1lcmljSW5wdXQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCB9ID0gaW5wdXQ7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMucHJldmlvdXNTZWxlY3Rpb247XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHRoaXMuZGVjaW1hbFNlcGFyYXRvciArIHZhbHVlLnN1YnN0cmluZyhlbmQpO1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpc1ZhbGlkKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5udW1lcmljUmVnZXgpIHtcbiAgICAgICAgICAgIHRoaXMubnVtZXJpY1JlZ2V4ID0gbnVtZXJpY1JlZ2V4KHtcbiAgICAgICAgICAgICAgICBhdXRvQ29ycmVjdDogdGhpcy5hdXRvQ29ycmVjdCxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogdGhpcy5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICBtaW46IHRoaXMubWluLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjogdGhpcy5kZWNpbWFsU2VwYXJhdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5udW1lcmljUmVnZXgudGVzdCh2YWx1ZSk7XG4gICAgfVxuICAgIHNwaW4oc3RlcCwgdGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zcGluVGltZW91dCk7XG4gICAgICAgIHRoaXMuc3BpblRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNwaW4oc3RlcCwgU1BJTl9ERUxBWSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLmFkZFN0ZXAoc3RlcCk7XG4gICAgfVxuICAgIGFkZFN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgdmFsdWUgPSBhZGQodGhpcy52YWx1ZSB8fCAwLCB0aGlzLnN0ZXAgKiBzdGVwKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmxpbWl0VmFsdWUodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHRoaXMucmVzdHJpY3REZWNpbWFscyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAodGhpcy5mb2N1c2VkKSB7XG4gICAgICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKHRoaXMubnVtZXJpY0lucHV0LCAnc2V0U2VsZWN0aW9uUmFuZ2UnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW1pdFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5SYW5nZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcih0aGlzLm1heCkgJiYgdmFsdWUgPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHRoaXMubWluKSAmJiB2YWx1ZSA8IHRoaXMubWluKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5taW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGltaXRJbnB1dFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGxldCB7IHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQsIHZhbHVlOiBlbnRlcmVkVmFsdWUgfSA9IHRoaXMubnVtZXJpY0lucHV0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGxldCBsaW1pdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgbGV0IHNlbGVjdFRvRW5kID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5pc0luUmFuZ2UodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGhDaGFuZ2UgPSBlbnRlcmVkVmFsdWUubGVuZ3RoIC0gU3RyaW5nKHRoaXMuaW5wdXRWYWx1ZSkubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGhhc01heCA9IGlzTnVtYmVyKG1heCk7XG4gICAgICAgICAgICBjb25zdCBoYXNNaW4gPSBpc051bWJlcihtaW4pO1xuICAgICAgICAgICAgbGV0IHBhZExpbWl0LCByZXBsYWNlTmV4dDtcbiAgICAgICAgICAgIGxldCBjb3JyZWN0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRoaXMuaW5wdXRWYWx1ZS5zdWJzdHIoMSkgPT09IGVudGVyZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVuZDogc2VsZWN0aW9uRW5kLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNNYXggJiYgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VOZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZExpbWl0ID0gbWF4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc01pbiAmJiB2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkTGltaXQgPSBtaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlTmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZExpbWl0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFkZGVkVmFsdWUgPSB0aGlzLnRyeVBhZFZhbHVlKHZhbHVlLCBwYWRMaW1pdCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhZGRlZFZhbHVlICYmIGRlY2ltYWxQYXJ0KHZhbHVlKSAhPT0gZGVjaW1hbFBhcnQocGFkTGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3RlZFZhbHVlID0gcGFkZGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdFRvRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXBsYWNlTmV4dCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0VmFsdWUgJiYgc2VsZWN0aW9uU3RhcnQgIT09IGVudGVyZWRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ycmVjdGVkVmFsdWUgPSBwYXJzZUZsb2F0KGVudGVyZWRWYWx1ZS5zdWJzdHIoMCwgc2VsZWN0aW9uU3RhcnQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyZWRWYWx1ZS5zdWJzdHIoc2VsZWN0aW9uU3RhcnQgKyBsZW5ndGhDaGFuZ2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdGVkVmFsdWUgPSB0aGlzLmxpbWl0VmFsdWUoY29ycmVjdGVkVmFsdWUpO1xuICAgICAgICAgICAgc2VsZWN0VG9FbmQgPSAoc2VsZWN0VG9FbmQgfHwgbGltaXRlZFZhbHVlICE9PSBjb3JyZWN0ZWRWYWx1ZSkgJiYgdGhpcy5wcmV2aW91c1NlbGVjdGlvbiAmJlxuICAgICAgICAgICAgICAgICh0aGlzLnByZXZpb3VzU2VsZWN0aW9uLmVuZCAtIHRoaXMucHJldmlvdXNTZWxlY3Rpb24uc3RhcnQgKyBsZW5ndGhDaGFuZ2UpID4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiBzZWxlY3RUb0VuZCA/IFN0cmluZyhsaW1pdGVkVmFsdWUpLmxlbmd0aCA6IHNlbGVjdGlvbkVuZCxcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgIHZhbHVlOiBsaW1pdGVkVmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdHJ5UGFkVmFsdWUodmFsdWUsIGxpbWl0KSB7XG4gICAgICAgIGNvbnN0IGxpbWl0TGVuZ3RoID0gU3RyaW5nKE1hdGguZmxvb3IobGltaXQpKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHplcm9QYWRkZWQgPSBwYWQodmFsdWUsIGxpbWl0TGVuZ3RoKTtcbiAgICAgICAgY29uc3QgemVyb1BhZGRlZE5leHQgPSBwYWQodmFsdWUsIGxpbWl0TGVuZ3RoICsgMSk7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmICh0aGlzLmlzSW5SYW5nZSh6ZXJvUGFkZGVkKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gemVyb1BhZGRlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzSW5SYW5nZSh6ZXJvUGFkZGVkTmV4dCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHplcm9QYWRkZWROZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlzSW5SYW5nZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gIWlzTnVtYmVyKHZhbHVlKSB8fCAoKCFpc051bWJlcih0aGlzLm1pbikgfHwgdGhpcy5taW4gPD0gdmFsdWUpICYmICghaXNOdW1iZXIodGhpcy5tYXgpIHx8IHZhbHVlIDw9IHRoaXMubWF4KSk7XG4gICAgfVxuICAgIHJlc3RyaWN0TW9kZWxWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5yZXN0cmljdERlY2ltYWxzKHZhbHVlLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0NvcnJlY3QgJiYgdGhpcy5saW1pdFZhbHVlKHJlc3VsdCkgIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXN0cmljdERlY2ltYWxzKHZhbHVlLCByb3VuZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLmhhc0RlY2ltYWxzKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IHRoaXMuZGVjaW1hbHM7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocm91bmQgfHwgRVhQT05FTlRfUkVHRVgudGVzdChzdHJpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0b0ZpeGVkUHJlY2lzaW9uKHZhbHVlLCBkZWNpbWFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHN0cmluZ1ZhbHVlLnNwbGl0KFBPSU5UKTtcbiAgICAgICAgICAgICAgICBsZXQgZnJhY3Rpb24gPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhY3Rpb24gJiYgZnJhY3Rpb24ubGVuZ3RoID4gZGVjaW1hbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zdWJzdHIoMCwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUZsb2F0KGAke3BhcnRzWzBdfSR7UE9JTlR9JHtmcmFjdGlvbn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZm9ybWF0SW5wdXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBsZXQgc3RyaW5nVmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICBjb25zdCBleHBvbmVudE1hdGNoID0gRVhQT05FTlRfUkVHRVguZXhlYyhzdHJpbmdWYWx1ZSk7XG4gICAgICAgIGlmIChleHBvbmVudE1hdGNoKSB7XG4gICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IHZhbHVlLnRvRml4ZWQobGltaXRQcmVjaXNpb24ocGFyc2VJbnQoZXhwb25lbnRNYXRjaFsxXSwgMTApKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlLnJlcGxhY2UoUE9JTlQsIHRoaXMuZGVjaW1hbFNlcGFyYXRvcik7XG4gICAgfVxuICAgIGZvcm1hdFZhbHVlKHZhbHVlLCBmb2N1c2VkKSB7XG4gICAgICAgIGxldCBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8ICFkZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9jdXNlZCAmJiAhdGhpcy5yZWFkb25seSkge1xuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSB0aGlzLmZvcm1hdElucHV0VmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSB0aGlzLmludGwuZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFZhbHVlO1xuICAgIH1cbiAgICBzZXRJbnB1dFZhbHVlKHZhbHVlID0gdGhpcy52YWx1ZSwgZm9jdXNlZCA9IHRoaXMuZm9jdXNlZCkge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuZm9ybWF0VmFsdWUodmFsdWUsIGZvY3VzZWQpO1xuICAgICAgICB0aGlzLmVsZW1lbnRWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB0aGlzLmlucHV0VmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICB9XG4gICAgdmVyaWZ5U2V0dGluZ3MoKSB7XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW4gIT09IG51bGwgJiYgdGhpcy5tYXggIT09IG51bGwgJiYgdGhpcy5taW4gPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWF4IHZhbHVlIHNob3VsZCBiZSBiaWdnZXIgdGhhbiB0aGUgbWluLiBTZWUgJHtNSU5fRE9DX0xJTkt9IGFuZCAke01BWF9ET0NfTElOS30uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmVyaWZ5VmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIE51bWVyaWNUZXh0Qm94IGNvbXBvbmVudCByZXF1aXJlcyB2YWx1ZSBvZiB0eXBlIE51bWJlciBhbmQgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IHdhcyBzZXQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgb3B0aW9ucy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gb3B0aW9uc1tpZHhdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9ICFpc05hTihwYXJzZWQpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Rldk1vZGUoKSAmJiAhdmFsaWQgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIE51bWVyaWNUZXh0Qm94IGNvbXBvbmVudCByZXF1aXJlcyB2YWx1ZSBvZiB0eXBlIE51bWJlciBvciBhIFN0cmluZyByZXByZXNlbnRpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBgYSBudW1iZXIgZm9yIHRoZSAke25hbWV9IHByb3BlcnR5IGFuZCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gd2FzIHNldC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHZhbGlkID8gcGFyc2VkIDogUEFSU0FCTEVfREVGQVVMVFNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW50bENoYW5nZSgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubnVtZXJpY1JlZ2V4O1xuICAgICAgICBpZiAodGhpcy5udW1lcmljSW5wdXQgJiYgKCF0aGlzLmZvY3VzZWQgfHwgIXRoaXMuaXNWYWxpZCh0aGlzLmVsZW1lbnRWYWx1ZSkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldElucHV0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNUcmFpbGluZ1plcm9zKGlucHV0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRGVjaW1hbHMgJiYgdGhpcy5mb2N1c2VkKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFjdGlvbiA9IGlucHV0VmFsdWUuc3BsaXQodGhpcy5kZWNpbWFsU2VwYXJhdG9yKVsxXTtcbiAgICAgICAgICAgIHJldHVybiBmcmFjdGlvbiAmJiBmcmFjdGlvbi5sZW5ndGggPiB0aGlzLmRlY2ltYWxzICYmIGZyYWN0aW9uLmxhc3RJbmRleE9mKCcwJykgPT09IGZyYWN0aW9uLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0QWxsKCkge1xuICAgICAgICB0aGlzLnNldElucHV0VmFsdWUoKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oMCwgdGhpcy5pbnB1dFZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICAgIHNlbGVjdENhcmV0KCkge1xuICAgICAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gZ2V0Q2FyZXRQb3NpdGlvbih0aGlzLm51bWVyaWNJbnB1dC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkVmFsdWUgPSB0aGlzLmVsZW1lbnRWYWx1ZTtcbiAgICAgICAgY29uc3QgcGFydGlhbFZhbHVlID0gZm9ybWF0dGVkVmFsdWUuc3Vic3RyaW5nKDAsIGNhcmV0UG9zaXRpb24pO1xuICAgICAgICB0aGlzLnNldElucHV0VmFsdWUoKTtcbiAgICAgICAgaWYgKHBhcnRpYWxWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25pZmljYW50Q2hhcnNJbkZvcm1hdHRlZFZhbHVlID0gZXh0cmFjdFNpZ25pZmljYW50TnVtZXJpY0NoYXJzKHBhcnRpYWxWYWx1ZSwgdGhpcy5kZWNpbWFsU2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkU2lnbmlmaWNhbnRDaGFycyA9IHRoaXMuYWRqdXN0U2lnbmlmaWNhbnRDaGFycyhmb3JtYXR0ZWRWYWx1ZSwgc2lnbmlmaWNhbnRDaGFyc0luRm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oYWRqdXN0ZWRTaWduaWZpY2FudENoYXJzLCBhZGp1c3RlZFNpZ25pZmljYW50Q2hhcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oMCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbnVtYmVyT2ZMZWFkaW5nWmVyb2VzKGZvcm1hdHRlZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gZm9ybWF0dGVkVmFsdWUuaW5kZXhPZih0aGlzLmRlY2ltYWxTZXBhcmF0b3IpO1xuICAgICAgICBjb25zdCBtYXRjaGVkTGVhZGluZ1plcm9lcyA9IGZvcm1hdHRlZFZhbHVlLm1hdGNoKC9eW14xLTldKj8oMCspLyk7XG4gICAgICAgIGlmIChtYXRjaGVkTGVhZGluZ1plcm9lcykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoT2ZNYXRjaCA9IG1hdGNoZWRMZWFkaW5nWmVyb2VzWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aE9mTGVhZGluZ1plcm9lc01hdGNoID0gbWF0Y2hlZExlYWRpbmdaZXJvZXNbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aE9mTWF0Y2ggPT09IHNlcGFyYXRvckluZGV4ID8gbGVuZ3RoT2ZMZWFkaW5nWmVyb2VzTWF0Y2ggLSAxIDogbGVuZ3RoT2ZMZWFkaW5nWmVyb2VzTWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGFkanVzdFNpZ25pZmljYW50Q2hhcnMoZm9ybWF0dGVkVmFsdWUsIHNpZ25pZmljYW50Q2hhcnMpIHtcbiAgICAgICAgY29uc3QgbGVhZGluZ1plcm9lcyA9IHRoaXMubnVtYmVyT2ZMZWFkaW5nWmVyb2VzKGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgICAgaWYgKGxlYWRpbmdaZXJvZXMgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgc2lnbmlmaWNhbnRDaGFycyAtIGxlYWRpbmdaZXJvZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduaWZpY2FudENoYXJzO1xuICAgIH1cbiAgICBoYW5kbGVDbGFzc2VzKHZhbHVlLCBpbnB1dCkge1xuICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gZ2V0U3R5bGluZ0NsYXNzZXMoJ2lucHV0JywgaW5wdXQsIHRoaXNbaW5wdXRdLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjbGFzc2VzLnRvUmVtb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzZXMudG9SZW1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc2VzLnRvQWRkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW0sIGNsYXNzZXMudG9BZGQpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c2FibGVJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTnVtZXJpY1RleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTnVtZXJpY1RleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImF1dG9Db3JyZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOdW1lcmljVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOdW1lcmljVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOdW1lcmljVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVjaW1hbHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTnVtZXJpY1RleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInN0ZXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOdW1lcmljVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwic3Bpbm5lcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOdW1lcmljVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VWYWxpZGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOdW1lcmljVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgTnVtZXJpY1RleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjaGFuZ2VWYWx1ZU9uU2Nyb2xsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTnVtZXJpY1RleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdE9uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTnVtZXJpY1RleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcIm1heGxlbmd0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBOdW1lcmljVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgTnVtZXJpY1RleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsTW9kZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOdW1lcmljVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnZm9jdXMnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTnVtZXJpY1RleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnYmx1cicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOdW1lcmljVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwib25CbHVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ251bWVyaWNJbnB1dCcsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgTnVtZXJpY1RleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcIm51bWVyaWNJbnB1dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1pbnB1dCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLW51bWVyaWN0ZXh0Ym94JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOdW1lcmljVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgdm9pZCAwKTtcbk51bWVyaWNUZXh0Qm94Q29tcG9uZW50ID0gTnVtZXJpY1RleHRCb3hDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9OdW1lcmljVGV4dEJveCcsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTDEwTl9QUkVGSVgsIHVzZVZhbHVlOiAna2VuZG8ubnVtZXJpY3RleHRib3gnIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOdW1lcmljVGV4dEJveENvbXBvbmVudF8xKSwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTkdfVkFMSURBVE9SUywgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnVtZXJpY1RleHRCb3hDb21wb25lbnRfMSksIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IEtlbmRvSW5wdXQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE51bWVyaWNUZXh0Qm94Q29tcG9uZW50XzEpIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1udW1lcmljdGV4dGJveCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIga2VuZG9OdW1lcmljVGV4dEJveExvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLWluY3JlbWVudD1cImtlbmRvLm51bWVyaWN0ZXh0Ym94LmluY3JlbWVudHxUaGUgdGl0bGUgZm9yIHRoZSAqKkluY3JlbWVudCoqIGJ1dHRvbiBpbiB0aGUgTnVtZXJpY1RleHRCb3hcIlxuICAgICAgICAgICAgaW5jcmVtZW50PVwiSW5jcmVhc2UgdmFsdWVcIlxuICAgICAgICAgICAgaTE4bi1kZWNyZW1lbnQ9XCJrZW5kby5udW1lcmljdGV4dGJveC5kZWNyZW1lbnR8VGhlIHRpdGxlIGZvciB0aGUgKipEZWNyZW1lbnQqKiBidXR0b24gaW4gdGhlIE51bWVyaWNUZXh0Qm94XCJcbiAgICAgICAgICAgIGRlY3JlbWVudD1cIkRlY3JlYXNlIHZhbHVlXCJcbiAgICAgICAgPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgcm9sZT1cInNwaW5idXR0b25cIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWlucHV0LWlubmVyXCJcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgICAgICAgICBhdXRvY29ycmVjdD1cIm9mZlwiXG4gICAgICAgICAgICBbaWRdPVwiZm9jdXNhYmxlSWRcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1pbl09XCJtaW5cIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1heF09XCJtYXhcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW5vd109XCJ2YWx1ZVwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJ0aXRsZVwiXG4gICAgICAgICAgICBbYXR0ci5wbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbYXR0ci5tYXhMZW5ndGhdPVwibWF4bGVuZ3RoXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCJ0YWJJbmRleFwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICBtb3VzZWRvd246IGhhbmRsZU1vdXNlRG93bixcbiAgICAgICAgICAgICAgICBkcmFnZW50ZXI6IGhhbmRsZURyYWdFbnRlcixcbiAgICAgICAgICAgICAgICBrZXlkb3duOiBoYW5kbGVLZXlEb3duLFxuICAgICAgICAgICAgICAgIGlucHV0OiBoYW5kbGVJbnB1dCxcbiAgICAgICAgICAgICAgICBmb2N1czogaGFuZGxlRm9jdXMsXG4gICAgICAgICAgICAgICAgYmx1cjogaGFuZGxlQmx1cixcbiAgICAgICAgICAgICAgICBwYXN0ZTogaGFuZGxlUGFzdGVcbiAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgI251bWVyaWNJbnB1dCAvPlxuICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICBjbGFzcz1cImstaW5wdXQtc3Bpbm5lciBrLXNwaW4tYnV0dG9uXCIgKm5nSWY9XCJzcGlubmVyc1wiXG4gICAgICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwieyBtb3VzZXVwOiByZWxlYXNlQXJyb3csIG1vdXNlbGVhdmU6IHJlbGVhc2VBcnJvdyB9XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cInsgbW91c2Vkb3duOiBpbmNyZWFzZVByZXNzIH1cIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWhpZGRlbl09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJpbmNyZW1lbnRUaXRsZVwiXG4gICAgICAgICAgICAgICAgICAgIFt0aXRsZV09XCJpbmNyZW1lbnRUaXRsZVwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLWFjdGl2ZV09XCJhcnJvd0RpcmVjdGlvbiA9PT0gQXJyb3dEaXJlY3Rpb24uVXBcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstc3Bpbm5lci1pbmNyZWFzZSBrLWJ1dHRvbiBrLWljb24tYnV0dG9uIGstYnV0dG9uLXNvbGlkIGstYnV0dG9uLXNvbGlkLWJhc2VcIlxuICAgICAgICAgICAgICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1idXR0b24taWNvbiBrLWljb24gay1pLWFycm93LW5cIj48L3NwYW4+XG4gICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cInsgbW91c2Vkb3duOiBkZWNyZWFzZVByZXNzIH1cIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWhpZGRlbl09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJkZWNyZW1lbnRUaXRsZVwiXG4gICAgICAgICAgICAgICAgICAgIFt0aXRsZV09XCJkZWNyZW1lbnRUaXRsZVwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLWFjdGl2ZV09XCJhcnJvd0RpcmVjdGlvbiA9PT0gQXJyb3dEaXJlY3Rpb24uRG93blwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1zcGlubmVyLWRlY3JlYXNlIGstYnV0dG9uIGstaWNvbi1idXR0b24gay1idXR0b24tc29saWQgay1idXR0b24tc29saWQtYmFzZVwiXG4gICAgICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstYnV0dG9uLWljb24gay1pY29uIGstaS1hcnJvdy1zXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtJbnRsU2VydmljZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBJbmplY3RvcixcbiAgICAgICAgTmdab25lLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgRWxlbWVudFJlZl0pXG5dLCBOdW1lcmljVGV4dEJveENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBOdW1lcmljVGV4dEJveE1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTnVtZXJpY1RleHRCb3hNZXNzYWdlcy5wcm90b3R5cGUsIFwiZGVjcmVtZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOdW1lcmljVGV4dEJveE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJpbmNyZW1lbnRcIiwgdm9pZCAwKTtcblxudmFyIE51bWVyaWNUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMTtcbi8qKlxuICogQ3VzdG9tIGNvbXBvbmVudCBtZXNzYWdlcyBvdmVycmlkZSBkZWZhdWx0IGNvbXBvbmVudCBtZXNzYWdlcy5cbiAqL1xubGV0IE51bWVyaWNUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBOdW1lcmljVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBjbGFzcyBOdW1lcmljVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50IGV4dGVuZHMgTnVtZXJpY1RleHRCb3hNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5OdW1lcmljVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gTnVtZXJpY1RleHRCb3hDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTnVtZXJpY1RleHRCb3hNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOdW1lcmljVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1udW1lcmljdGV4dGJveC1tZXNzYWdlcycsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBOdW1lcmljVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBSZXN1bHRUeXBlO1xuKGZ1bmN0aW9uIChSZXN1bHRUeXBlKSB7XG4gICAgUmVzdWx0VHlwZVtSZXN1bHRUeXBlW1wiTGl0ZXJhbFwiXSA9IDBdID0gXCJMaXRlcmFsXCI7XG4gICAgUmVzdWx0VHlwZVtSZXN1bHRUeXBlW1wiTWFza1wiXSA9IDFdID0gXCJNYXNrXCI7XG4gICAgUmVzdWx0VHlwZVtSZXN1bHRUeXBlW1wiVW5kZWZpbmVkXCJdID0gMl0gPSBcIlVuZGVmaW5lZFwiO1xufSkoUmVzdWx0VHlwZSB8fCAoUmVzdWx0VHlwZSA9IHt9KSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgcmVzdCwgdHlwZSA9IFJlc3VsdFR5cGUuVW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5yZXN0ID0gcmVzdDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgLy9tYXAgOjogRnVuY3RvciBmID0+IGYgYSB+PiAoYSAtPiBiKSAtPiBmIGJcbiAgICBtYXAoZm4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoZm4odGhpcy52YWx1ZSksIHRoaXMucmVzdCk7XG4gICAgfVxuICAgIC8vY2hhaW4gOjogQ2hhaW4gbSA9PiBtIGEgfj4gKGEgLT4gbSBiKSAtPiBtIGJcbiAgICBjaGFpbihmbikge1xuICAgICAgICByZXR1cm4gZm4odGhpcy52YWx1ZSwgdGhpcy5yZXN0KTtcbiAgICB9XG4gICAgZm9sZChzLCBfIC8qd2UgZG9uJ3QgbmVlZCBpdCovKSB7XG4gICAgICAgIHJldHVybiBzKHRoaXMudmFsdWUsIHRoaXMucmVzdCk7XG4gICAgfVxuICAgIGNvbmNhdChyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcCgodnMsIF8pID0+IHIuY2hhaW4oKHYsIF9fKSA9PiB2cy5jb25jYXQoW3ZdKSkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBSZXN1bHQoeyB2YWx1ZTogJyR7dGhpcy52YWx1ZX0nLCByZXN0OiAke3RoaXMucmVzdH0gfSlgO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQgPSBbXSwgY29udHJvbCA9IFtdKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgICAgdGhpcy5pbnB1dEN1cnNvciA9IDA7XG4gICAgICAgIHRoaXMuY29udHJvbEN1cnNvciA9IDA7XG4gICAgfVxuICAgIGVvZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRDdXJzb3IgPj0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgZmlyc3QgdmFsdWUgZnJvbSB0aGUgaW5wdXQuXG4gICAgbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYXI6IHRoaXMuaW5wdXRbdGhpcy5pbnB1dEN1cnNvcisrXSxcbiAgICAgICAgICAgIGNvbnRyb2w6IHRoaXMuY29udHJvbFt0aGlzLmNvbnRyb2xDdXJzb3IrK11cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYXI6IHRoaXMuaW5wdXRbdGhpcy5pbnB1dEN1cnNvcl0sXG4gICAgICAgICAgICBjb250cm9sOiB0aGlzLmNvbnRyb2xbdGhpcy5jb250cm9sQ3Vyc29yXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlYXRfaW5wdXQoKSB7XG4gICAgICAgIHRoaXMuaW5wdXRDdXJzb3IrKztcbiAgICB9XG4gICAgZWF0X2NvbnRyb2woKSB7XG4gICAgICAgIHRoaXMuY29udHJvbEN1cnNvcisrO1xuICAgIH1cbiAgICBlYXQoKSB7XG4gICAgICAgIHRoaXMuaW5wdXRDdXJzb3IrKztcbiAgICAgICAgdGhpcy5jb250cm9sQ3Vyc29yKys7XG4gICAgfVxufVxuXG5jb25zdCB0b0FycmF5ID0gKHZhbHVlKSA9PiAodmFsdWUgfHwgJycpLnNwbGl0KCcnKTtcbmNvbnN0IEVTQ0FQRV9DSEFSQUNURVIgPSAnXFxcXCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZSkge1xuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2U7XG4gICAgfVxuICAgIHJ1bihpbnB1dCwgY29udHJvbCA9ICcnKSB7XG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UobmV3IFN0cmVhbSh0b0FycmF5KGlucHV0KSwgdG9BcnJheShjb250cm9sKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vbWFwIDo6IEZ1bmN0b3IgZiA9PiBmIGEgfj4gKGEgLT4gYikgLT4gZiBiXG4gICAgbWFwKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoc3RyZWFtID0+IHRoaXMucGFyc2Uoc3RyZWFtKS5tYXAoZikpO1xuICAgIH1cbiAgICAvL2NoYWluIDo6IENoYWluIG0gPT4gbSBhIH4+IChhIC0+IG0gYikgLT4gbSBiXG4gICAgY2hhaW4oZikge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcihzdHJlYW0gPT4gdGhpcy5wYXJzZShzdHJlYW0pLmNoYWluKCh2LCBzKSA9PiBmKHYpLnJ1bihzKSkpO1xuICAgIH1cbiAgICBpc0xpdGVyYWwoYykge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW4oYykudHlwZSA9PT0gUmVzdWx0VHlwZS5MaXRlcmFsO1xuICAgIH1cbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBtYXNrID0gKHsgcHJvbXB0LCBwcm9tcHRQbGFjZWhvbGRlciB9KSA9PiBydWxlID0+IG5ldyBQYXJzZXIoc3RyZWFtID0+IHtcbiAgICB3aGlsZSAoIXN0cmVhbS5lb2YoKSkge1xuICAgICAgICBjb25zdCB7IGNoYXIsIGNvbnRyb2wgfSA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICAgIGlmIChjaGFyID09PSBjb250cm9sICYmIGNvbnRyb2wgPT09IHByb21wdCkge1xuICAgICAgICAgICAgc3RyZWFtLmVhdCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQocHJvbXB0LCBzdHJlYW0sIFJlc3VsdFR5cGUuTWFzayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bGUudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgc3RyZWFtLmVhdCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoY2hhciwgc3RyZWFtLCBSZXN1bHRUeXBlLk1hc2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBwcm9tcHRQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgc3RyZWFtLmVhdCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQocHJvbXB0LCBzdHJlYW0sIFJlc3VsdFR5cGUuTWFzayk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLmVhdF9pbnB1dCgpO1xuICAgIH1cbiAgICBzdHJlYW0uZWF0KCk7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQocHJvbXB0LCBzdHJlYW0sIFJlc3VsdFR5cGUuTWFzayk7XG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBsaXRlcmFsID0gX3Rva2VuID0+IG5ldyBQYXJzZXIoc3RyZWFtID0+IHtcbiAgICAvLyAgICBsZXQge2NoYXIsIGNvbnRyb2x9ID0gc3RyZWFtLnBlZWsoKTtcbiAgICBsZXQgY2hhciA9IHN0cmVhbS5wZWVrKCkuY2hhcjtcbiAgICBpZiAoY2hhciA9PT0gX3Rva2VuKSB7XG4gICAgICAgIHN0cmVhbS5lYXQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX3Rva2VuLCBzdHJlYW0sIFJlc3VsdFR5cGUuTGl0ZXJhbCk7XG4gICAgfVxuICAgIC8vICAgIGlmIChjb250cm9sID09PSBfdG9rZW4pIHtcbiAgICAvLyAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9mKCkgJiYgY2hhciAhPT0gX3Rva2VuKSB7XG4gICAgLy8gICAgICAgICAgICBzdHJlYW0uZWF0X2lucHV0KCk7XG4gICAgLy8gICAgICAgICAgICBjaGFyID0gc3RyZWFtLnBlZWsoKS5jaGFyO1xuICAgIC8vICAgICAgICB9XG4gICAgLy8gICAgfVxuICAgIC8vXG4gICAgLy8gICAgaWYgKGNvbnRyb2wgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgICAgICBzdHJlYW0uZWF0KCk7XG4gICAgLy8gICAgfVxuICAgIHJldHVybiBuZXcgUmVzdWx0KF90b2tlbiwgc3RyZWFtLCBSZXN1bHRUeXBlLkxpdGVyYWwpO1xufSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdW5tYXNrID0gcHJvbXB0ID0+IHJ1bGUgPT4gbmV3IFBhcnNlcihzdHJlYW0gPT4ge1xuICAgIHdoaWxlICghc3RyZWFtLmVvZigpKSB7XG4gICAgICAgIGNvbnN0IHsgY2hhciwgY29udHJvbCB9ID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgaWYgKGNoYXIgPT09IHByb21wdCAmJiBjb250cm9sID09PSBwcm9tcHQpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lYXQoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0KGNoYXIsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bGUudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgc3RyZWFtLmVhdCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoY2hhciwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uZWF0X2lucHV0KCk7XG4gICAgfVxuICAgIHN0cmVhbS5lYXQoKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCgnJywgc3RyZWFtKTtcbn0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHVubGl0ZXJhbCA9IF90b2tlbiA9PiBuZXcgUGFyc2VyKHN0cmVhbSA9PiB7XG4gICAgaWYgKHN0cmVhbS5lb2YoKSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdCgnJywgc3RyZWFtKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGFyIH0gPSBzdHJlYW0ucGVlaygpO1xuICAgIGlmIChjaGFyID09PSBfdG9rZW4pIHtcbiAgICAgICAgc3RyZWFtLmVhdCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlc3VsdChfdG9rZW4sIHN0cmVhbSk7XG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0b2tlbiA9IChydWxlcywgY3JlYXRvcikgPT4gbmV3IFBhcnNlcihzdHJlYW0gPT4ge1xuICAgIGxldCB7IGNoYXIgfSA9IHN0cmVhbS5uZXh0KCk7XG4gICAgY29uc3QgcnVsZSA9IHJ1bGVzW2NoYXJdO1xuICAgIGlmIChjaGFyID09PSBFU0NBUEVfQ0hBUkFDVEVSKSB7XG4gICAgICAgIGNoYXIgPSBzdHJlYW0ubmV4dCgpLmNoYXI7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KGNyZWF0b3IubGl0ZXJhbChjaGFyKSwgc3RyZWFtKTtcbiAgICB9XG4gICAgaWYgKCFydWxlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KGNyZWF0b3IubGl0ZXJhbChjaGFyKSwgc3RyZWFtKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQoY3JlYXRvci5tYXNrKHJ1bGUpLCBzdHJlYW0pO1xufSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcmF3TWFzayA9ICh7IHByb21wdCwgcHJvbXB0UGxhY2Vob2xkZXIgfSkgPT4gbmV3IFBhcnNlcihzdHJlYW0gPT4ge1xuICAgIGxldCB7IGNoYXIgfSA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoYXIgPT09IHByb21wdCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChwcm9tcHRQbGFjZWhvbGRlciwgc3RyZWFtKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQoY2hhciwgc3RyZWFtKTtcbn0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHJhd0xpdGVyYWwgPSBpbmNsdWRlTGl0ZXJhbHMgPT4gbmV3IFBhcnNlcihzdHJlYW0gPT4ge1xuICAgIGxldCB7IGNoYXIgfSA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGluY2x1ZGVMaXRlcmFscykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChjaGFyLCBzdHJlYW0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlc3VsdCgnJywgc3RyZWFtKTtcbn0pO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgYWx3YXlzID0gdmFsdWUgPT4gbmV3IFBhcnNlcihzdHJlYW0gPT4gbmV3IFJlc3VsdCh2YWx1ZSwgc3RyZWFtKSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgYXBwZW5kID0gKHAxLCBwMikgPT4gcDEuY2hhaW4odnMgPT4gcDIubWFwKHYgPT4gdnMuY29uY2F0KFt2XSkpKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzZXF1ZW5jZSA9IGxpc3QgPT4gbGlzdC5yZWR1Y2UoKGFjYywgcGFyc2VyKSA9PiBhcHBlbmQoYWNjLCBwYXJzZXIpLCBhbHdheXMoW10pKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBncmVlZHkgPSBwYXJzZXIgPT4gbmV3IFBhcnNlcihzdHJlYW0gPT4ge1xuICAgIGxldCByZXN1bHQgPSBuZXcgUmVzdWx0KFtdLCBzdHJlYW0pO1xuICAgIHdoaWxlICghc3RyZWFtLmVvZigpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQocGFyc2VyLnJ1bihzdHJlYW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IE1hc2tpbmdTZXJ2aWNlID0gY2xhc3MgTWFza2luZ1NlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHt9O1xuICAgICAgICB0aGlzLnByb21wdCA9IFwiX1wiO1xuICAgICAgICB0aGlzLm1hc2sgPSBcIlwiO1xuICAgICAgICB0aGlzLnByb21wdFBsYWNlaG9sZGVyID0gXCIgXCI7XG4gICAgICAgIHRoaXMuaW5jbHVkZUxpdGVyYWxzID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWFza1Rva2VucyA9IFtdO1xuICAgICAgICB0aGlzLnVubWFza1Rva2VucyA9IFtdO1xuICAgICAgICB0aGlzLnJhd1Rva2VucyA9IFtdO1xuICAgICAgICB0aGlzLnZhbGlkYXRpb25Ub2tlbnMgPSBbXTtcbiAgICB9XG4gICAgdXBkYXRlKHsgbWFzazogbWFzayQkMSA9ICcnLCBwcm9tcHQgPSAnJywgcHJvbXB0UGxhY2Vob2xkZXIgPSAnICcsIHJ1bGVzID0ge30sIGluY2x1ZGVMaXRlcmFscyA9IGZhbHNlIH0pIHtcbiAgICAgICAgdGhpcy5tYXNrID0gbWFzayQkMTtcbiAgICAgICAgdGhpcy5wcm9tcHQgPSBwcm9tcHQ7XG4gICAgICAgIHRoaXMucHJvbXB0UGxhY2Vob2xkZXIgPSBwcm9tcHRQbGFjZWhvbGRlcjtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVMaXRlcmFscyA9IGluY2x1ZGVMaXRlcmFscztcbiAgICAgICAgdGhpcy50b2tlbml6ZSgpO1xuICAgIH1cbiAgICB2YWxpZGF0aW9uVmFsdWUobWFza2VkVmFsdWUgPSAnJykge1xuICAgICAgICBsZXQgdmFsdWUgPSBtYXNrZWRWYWx1ZTtcbiAgICAgICAgc2VxdWVuY2UodGhpcy52YWxpZGF0aW9uVG9rZW5zKVxuICAgICAgICAgICAgLnJ1bihtYXNrZWRWYWx1ZSlcbiAgICAgICAgICAgIC5mb2xkKHVubWFza2VkID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gdW5tYXNrZWQuam9pbignJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJhd1ZhbHVlKG1hc2tlZFZhbHVlID0gJycpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbWFza2VkVmFsdWU7XG4gICAgICAgIGlmICghdGhpcy5yYXdUb2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VxdWVuY2UodGhpcy5yYXdUb2tlbnMpXG4gICAgICAgICAgICAucnVuKG1hc2tlZFZhbHVlKVxuICAgICAgICAgICAgLmZvbGQodW5tYXNrZWQgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSB1bm1hc2tlZC5qb2luKCcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG1hc2tSYXcocmF3VmFsdWUgPSAnJykge1xuICAgICAgICBsZXQgdmFsdWUgPSByYXdWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLm1hc2tUb2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VxdWVuY2UodGhpcy5tYXNrVG9rZW5zKVxuICAgICAgICAgICAgLnJ1bihyYXdWYWx1ZSlcbiAgICAgICAgICAgIC5mb2xkKG1hc2tlZCA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hc2tlZC5qb2luKCcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbWFza0lucHV0KGlucHV0LCBjb250cm9sLCBzcGxpdFBvaW50KSB7XG4gICAgICAgIGlmIChpbnB1dC5sZW5ndGggPCBjb250cm9sLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFza1JlbW92ZWQoaW5wdXQsIGNvbnRyb2wsIHNwbGl0UG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hc2tJbnNlcnRlZChpbnB1dCwgY29udHJvbCwgc3BsaXRQb2ludCk7XG4gICAgfVxuICAgIG1hc2tJblJhbmdlKHBhc3RlZCwgb2xkVmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBlbmQ7XG4gICAgICAgIGNvbnN0IGJlZm9yZUNoYW5nZSA9IG9sZFZhbHVlLnNwbGl0KCcnKS5zbGljZSgwLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IGFmdGVyQ2hhbmdlID0gb2xkVmFsdWUuc3BsaXQoJycpLnNsaWNlKGVuZCk7XG4gICAgICAgIHNlcXVlbmNlKHRoaXMubWFza1Rva2Vucy5zbGljZShzdGFydCwgZW5kKSlcbiAgICAgICAgICAgIC5ydW4ocGFzdGVkKVxuICAgICAgICAgICAgLmZvbGQobWFza2VkID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gYmVmb3JlQ2hhbmdlXG4gICAgICAgICAgICAgICAgLmNvbmNhdChtYXNrZWQpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChhZnRlckNoYW5nZSlcbiAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFza1JlbW92ZWQoaW5wdXQsIGNvbnRyb2wsIHNwbGl0UG9pbnQpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBzcGxpdFBvaW50O1xuICAgICAgICBjb25zdCB1bmNoYW5nZWQgPSBpbnB1dC5zcGxpdCgnJykuc2xpY2Uoc3BsaXRQb2ludCk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSBpbnB1dC5zcGxpdCgnJykuc2xpY2UoMCwgc3BsaXRQb2ludCkuam9pbignJyk7XG4gICAgICAgIGNvbnN0IHRha2UkJDEgPSB0aGlzLm1hc2tUb2tlbnMubGVuZ3RoIC0gKGlucHV0Lmxlbmd0aCAtIHNwbGl0UG9pbnQpO1xuICAgICAgICBzZXF1ZW5jZSh0aGlzLm1hc2tUb2tlbnMuc2xpY2UoMCwgdGFrZSQkMSkpXG4gICAgICAgICAgICAucnVuKGNoYW5nZWQsIGNvbnRyb2wpXG4gICAgICAgICAgICAuZm9sZChtYXNrZWQgPT4ge1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gdGhpcy5hZGp1c3RQb3NpdGlvbihtYXNrZWQsIHNlbGVjdGlvbik7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hc2tlZC5jb25jYXQodW5jaGFuZ2VkKS5qb2luKCcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGp1c3RQb3NpdGlvbihpbnB1dCwgc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNhcmV0Q2hhciA9IGlucHV0W3NlbGVjdGlvbl07XG4gICAgICAgIGNvbnN0IGlzTGl0ZXJhbCA9IHRoaXMubWFza1Rva2Vuc1tzZWxlY3Rpb25dLmlzTGl0ZXJhbChjYXJldENoYXIpO1xuICAgICAgICBpZiAoIWlzTGl0ZXJhbCAmJiBjYXJldENoYXIgIT09IHRoaXMucHJvbXB0KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH1cbiAgICBtYXNrSW5zZXJ0ZWQoaW5wdXQsIGNvbnRyb2wsIHNwbGl0UG9pbnQpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBzcGxpdFBvaW50O1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gaW5wdXQuc2xpY2UoMCwgc3BsaXRQb2ludCk7XG4gICAgICAgIHNlcXVlbmNlKHRoaXMudW5tYXNrVG9rZW5zKVxuICAgICAgICAgICAgLnJ1bihjaGFuZ2VkLCBjb250cm9sKVxuICAgICAgICAgICAgLmNoYWluKHVubWFza2VkID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHVubWFza2VkLmpvaW4oJycpLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZCA9IGNvbnRyb2wuc2xpY2Uoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBzZXF1ZW5jZSh0aGlzLm1hc2tUb2tlbnMpXG4gICAgICAgICAgICAgICAgLnJ1bih1bm1hc2tlZC5qb2luKCcnKSArIHVuY2hhbmdlZCwgY29udHJvbCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZm9sZChtYXNrZWQgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXNrZWQuam9pbignJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IG1hc2tUb2tlbkNyZWF0b3IoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvbXB0LCBwcm9tcHRQbGFjZWhvbGRlciB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpdGVyYWw6IHJ1bGUgPT4gbGl0ZXJhbChydWxlKSxcbiAgICAgICAgICAgIG1hc2s6IHJ1bGUgPT4gbWFzayh7IHByb21wdCwgcHJvbXB0UGxhY2Vob2xkZXIgfSkocnVsZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHVubWFza1Rva2VuQ3JlYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpdGVyYWw6IHJ1bGUgPT4gdW5saXRlcmFsKHJ1bGUpLFxuICAgICAgICAgICAgbWFzazogcnVsZSA9PiB1bm1hc2sodGhpcy5wcm9tcHQpKHJ1bGUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCByYXdUb2tlbkNyZWF0b3IoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvbXB0LCBwcm9tcHRQbGFjZWhvbGRlciwgaW5jbHVkZUxpdGVyYWxzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGl0ZXJhbDogXyA9PiByYXdMaXRlcmFsKGluY2x1ZGVMaXRlcmFscyksXG4gICAgICAgICAgICBtYXNrOiBfID0+IHJhd01hc2soeyBwcm9tcHQsIHByb21wdFBsYWNlaG9sZGVyIH0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCB2YWxpZGF0aW9uVG9rZW5DcmVhdG9yKCkge1xuICAgICAgICBjb25zdCB7IHByb21wdCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpdGVyYWw6IF8gPT4gcmF3TGl0ZXJhbChmYWxzZSksXG4gICAgICAgICAgICBtYXNrOiBfID0+IHJhd01hc2soeyBwcm9tcHQsIHByb21wdFBsYWNlaG9sZGVyOiAnJyB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b2tlbml6ZSgpIHtcbiAgICAgICAgZ3JlZWR5KHRva2VuKHRoaXMucnVsZXMsIHRoaXMubWFza1Rva2VuQ3JlYXRvcikpXG4gICAgICAgICAgICAucnVuKHRoaXMubWFzaylcbiAgICAgICAgICAgIC5mb2xkKCh0b2tlbnMsIF8pID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFza1Rva2VucyA9IHRva2VucztcbiAgICAgICAgfSk7XG4gICAgICAgIGdyZWVkeSh0b2tlbih0aGlzLnJ1bGVzLCB0aGlzLnVubWFza1Rva2VuQ3JlYXRvcikpXG4gICAgICAgICAgICAucnVuKHRoaXMubWFzaylcbiAgICAgICAgICAgIC5mb2xkKCh0b2tlbnMsIF8pID0+IHtcbiAgICAgICAgICAgIHRoaXMudW5tYXNrVG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB9KTtcbiAgICAgICAgZ3JlZWR5KHRva2VuKHRoaXMucnVsZXMsIHRoaXMucmF3VG9rZW5DcmVhdG9yKSlcbiAgICAgICAgICAgIC5ydW4odGhpcy5tYXNrKVxuICAgICAgICAgICAgLmZvbGQoKHRva2VucywgXykgPT4ge1xuICAgICAgICAgICAgdGhpcy5yYXdUb2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIH0pO1xuICAgICAgICBncmVlZHkodG9rZW4odGhpcy5ydWxlcywgdGhpcy52YWxpZGF0aW9uVG9rZW5DcmVhdG9yKSlcbiAgICAgICAgICAgIC5ydW4odGhpcy5tYXNrKVxuICAgICAgICAgICAgLmZvbGQoKHRva2VucywgXykgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0aW9uVG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuTWFza2luZ1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIE1hc2tpbmdTZXJ2aWNlKTtcblxudmFyIE1hc2tlZFRleHRCb3hDb21wb25lbnRfMTtcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbmNvbnN0IEZPQ1VTRUQkMiA9ICdrLWZvY3VzJztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIE1hc2tlZFRleHRCb3ggY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X21hc2tlZHRleHRib3ggJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1uby1ydW5cbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgIDxrZW5kby1tYXNrZWR0ZXh0Ym94XG4gKiAgICAgICAgICBbbWFza109XCJtYXNrXCJcbiAqICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiPlxuICogICAgICA8L2tlbmRvLW1hc2tlZHRleHRib3g+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogIHB1YmxpYyB2YWx1ZTogc3RyaW5nID0gXCI5NTgwMTI4MDU1ODA3NzkyXCI7XG4gKiAgcHVibGljIG1hc2s6IHN0cmluZyA9IFwiMDAwMC0wMDAwLTAwMDAtMDAwMFwiO1xuICogfVxuICogYGBgXG4gKi9cbmxldCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50ID0gTWFza2VkVGV4dEJveENvbXBvbmVudF8xID0gY2xhc3MgTWFza2VkVGV4dEJveENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgcmVuZGVyZXIsIGhvc3RFbGVtZW50LCBuZ1pvbmUsIGluamVjdG9yLCBjaGFuZ2VEZXRlY3RvciwgcnRsKSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUlkID0gYGstJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgTWFza2VkVGV4dEJveCBpcyBkaXNhYmxlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX21hc2tlZHRleHRib3ggJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgTWFza2VkVGV4dEJveCBpcyBpbiBpdHMgcmVhZC1vbmx5IHN0YXRlIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcmVhZG9ubHlfbWFza2VkdGV4dGJveCAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyBhIHByb21wdCBjaGFyYWN0ZXIgZm9yIHRoZSBtYXNrZWQgdmFsdWUuXG4gICAgICAgICAqIEBkZWZhdWx0IGBfYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9tcHQgPSAnXyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgYSBjaGFyYWN0ZXIgd2hpY2ggcmVwcmVzZW50cyBhbiBlbXB0eSBwb3NpdGlvbiBpbiB0aGUgcmF3IHZhbHVlLlxuICAgICAgICAgKiBAZGVmYXVsdCAnICdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvbXB0UGxhY2Vob2xkZXIgPSAnICc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIGxpdGVyYWxzIGluIHRoZSByYXcgdmFsdWUgIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdmFsdWVfbWFza2VkdGV4dGJveCAlfSkpLlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmNsdWRlTGl0ZXJhbHMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgbWFzayBzaG91bGQgYmUgc2hvd24gb24gZm9jdXMgZm9yIGVtcHR5IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXNrT25Gb2N1cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBidWlsdC1pbiBtYXNrIHZhbGlkYXRvciBpcyBlbmZvcmNlZCB3aGVuIGEgZm9ybSBpcyB2YWxpZGF0ZWRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB2YWxpZGF0aW9uX21hc2tlZHRleHRib3ggJX0pKS5cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXNrVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIFt0YWJpbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy90YWJpbmRleCkgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFiaW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGZvY3VzZXMgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUbyB3aXJlIHRoZSBldmVudCBwcm9ncmFtbWF0aWNhbGx5LCB1c2UgdGhlIGBvbkZvY3VzYCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHMtbm8tcnVuXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLW1hc2tlZHRleHRib3ggKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIj48L2tlbmRvLW1hc2tlZHRleHRib3g+XG4gICAgICAgICAqIGBcbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgaGFuZGxlRm9jdXMoKTogdm9pZCB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coXCJDb21wb25lbnQgaXMgZm9jdXNlZFwiKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGBpbnB1dGAgZWxlbWVudCBnZXRzIGJsdXJyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25CbHVyYCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHMtbm8tcnVuXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLW1hc2tlZHRleHRib3ggKGJsdXIpPVwiaGFuZGxlQmx1cigpXCI+PC9rZW5kby1tYXNrZWR0ZXh0Ym94PlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgcHVibGljIGhhbmRsZUJsdXIoKTogdm9pZCB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coXCJDb21wb25lbnQgaXMgYmx1cnJlZFwiKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvY3VzQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0UnVsZXMgPSB7XG4gICAgICAgICAgICBcIiNcIjogL1tcXGRcXHNcXCtcXC1dLyxcbiAgICAgICAgICAgIFwiJlwiOiAvW1xcU10vLFxuICAgICAgICAgICAgXCIwXCI6IC9bXFxkXS8sXG4gICAgICAgICAgICBcIjlcIjogL1tcXGRcXHNdLyxcbiAgICAgICAgICAgIFwiP1wiOiAvW2EtekEtWlxcc10vLFxuICAgICAgICAgICAgXCJBXCI6IC9bYS16QS1aMC05XS8sXG4gICAgICAgICAgICBcIkNcIjogLy4vLFxuICAgICAgICAgICAgXCJMXCI6IC9bYS16QS1aXS8sXG4gICAgICAgICAgICBcImFcIjogL1thLXpBLVowLTlcXHNdL1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzUGFzdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gWzAsIDBdO1xuICAgICAgICB0aGlzLl9zaXplID0gJ21lZGl1bSc7XG4gICAgICAgIHRoaXMuX3JvdW5kZWQgPSAnbWVkaXVtJztcbiAgICAgICAgdGhpcy5fZmlsbE1vZGUgPSAnc29saWQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1cyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXNrT25Gb2N1cyAmJiB0aGlzLmVtcHR5TWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5wdXQodGhpcy5zZXJ2aWNlLm1hc2tSYXcodGhpcy52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuc2V0U2VsZWN0aW9uKDAsIDApOyB9LCAwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkZvY3VzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXNlZCAmJiAhdGhpcy5mb2N1c0NsaWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0NsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQgfSA9IHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZvY3VzU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVCbHVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5mb2N1c0NsaWNrID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXNrT25Gb2N1cyAmJiB0aGlzLmVtcHR5TWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5wdXQodGhpcy5tYXNrZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMub25CbHVyKSB8fCByZXF1aXJlc1pvbmVPbkJsdXIodGhpcy5jb250cm9sKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gKCkgPT4geyB9O1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlcnZpY2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNpemUgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBwYWRkaW5nIG9mIHRoZSBNYXNrZWRUZXh0Qm94IGludGVybmFsIGlucHV0IGVsZW1lbnRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwcGVhcmFuY2VfbWFza2VkdGV4dGJveCAlfSN0b2Mtc2l6ZSkpLlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzbWFsbCdgXG4gICAgICogKiBgJ21lZGl1bSdgIChkZWZhdWx0KVxuICAgICAqICogYCdsYXJnZSdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKi9cbiAgICBzZXQgc2l6ZShzaXplKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xhc3NlcyhzaXplLCAnc2l6ZScpO1xuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcm91bmRlZCBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIGJvcmRlciByYWRpdXMgb2YgdGhlIE1hc2tlZFRleHRCb3hcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwcGVhcmFuY2VfbWFza2VkdGV4dGJveCAlfSN0b2Mtcm91bmRlZCkpLlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzbWFsbCdgXG4gICAgICogKiBgJ21lZGl1bSdgIChkZWZhdWx0KVxuICAgICAqICogYCdsYXJnZSdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKi9cbiAgICBzZXQgcm91bmRlZChyb3VuZGVkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xhc3Nlcyhyb3VuZGVkLCAncm91bmRlZCcpO1xuICAgICAgICB0aGlzLl9yb3VuZGVkID0gcm91bmRlZDtcbiAgICB9XG4gICAgZ2V0IHJvdW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3VuZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlsbE1vZGUgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBiYWNrZ3JvdW5kIGFuZCBib3JkZXIgc3R5bGVzIG9mIHRoZSBNYXNrZWRUZXhCb3hcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwcGVhcmFuY2VfbWFza2VkdGV4dGJveCAlfSN0b2MtZmlsbE1vZGUpKS5cbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGBmbGF0YFxuICAgICAqICogYHNvbGlkYCAoZGVmYXVsdClcbiAgICAgKiAqIGBvdXRsaW5lYFxuICAgICAqICogYG51bGxgXG4gICAgICovXG4gICAgc2V0IGZpbGxNb2RlKGZpbGxNb2RlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xhc3NlcyhmaWxsTW9kZSwgJ2ZpbGxNb2RlJyk7XG4gICAgICAgIHRoaXMuX2ZpbGxNb2RlID0gZmlsbE1vZGU7XG4gICAgfVxuICAgIGdldCBmaWxsTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxNb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvc2VzIHRoZSBSZWdFeHAtYmFzZWQgbWFzayB2YWxpZGF0aW9uIGFycmF5IChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbWFza3NfbWFza2VkdGV4dGJveCAlfSkpLlxuICAgICAqL1xuICAgIHNldCBydWxlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9ydWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFJ1bGVzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBydWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzIHx8IHRoaXMuZGVmYXVsdFJ1bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IHRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgZ2V0IGhvc3REaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIFwidGFiaW5kZXhcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250cm9sID0gdGhpcy5pbmplY3Rvci5nZXQoTmdDb250cm9sLCBudWxsKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBjb25zdCBzdHlsaW5nSW5wdXRzID0gWydzaXplJywgJ3JvdW5kZWQnLCAnZmlsbE1vZGUnXTtcbiAgICAgICAgc3R5bGluZ0lucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xhc3Nlcyh0aGlzW2lucHV0XSwgaW5wdXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgYnkgdGhlIEZsb2F0aW5nTGFiZWwgdG8gZGV0ZXJtaW5lIGlmIHRoZSBNYXNrZWRUZXh0Qm94IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gIUJvb2xlYW4odGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlRHJhZ0Ryb3AoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgTWFza2VkVGV4dEJveC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHMtbm8tcnVuXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8YnV0dG9uIChjbGljayk9XCJtYXNrZWRpbnB1dC5mb2N1cygpXCI+Rm9jdXMgdGhlIGlucHV0PC9idXR0b24+XG4gICAgICogIDxrZW5kby1tYXNrZWR0ZXh0Ym94ICNtYXNrZWRpbnB1dD48L2tlbmRvLW1hc2tlZHRleHRib3g+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5zZXRGb2N1c1NlbGVjdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgTWFza2VkVGV4dEJveC5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcGFzdGVIYW5kbGVyKGUpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kIH0gPSBlLnRhcmdldDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbkVuZCA9PT0gc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGFzdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBbc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpbnB1dEhhbmRsZXIoZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCF0aGlzLm1hc2spIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVXaXRoRXZlbnRzKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuaXNQYXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAodGhpcy5pc1Bhc3RlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1Bhc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcmlnaHRQYXJ0ID0gdGhpcy5tYXNrZWRWYWx1ZS5sZW5ndGggLSBlbmQ7XG4gICAgICAgICAgICBjb25zdCB0byA9IHZhbHVlLmxlbmd0aCAtIHJpZ2h0UGFydDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuc2VydmljZS5tYXNrSW5SYW5nZSh2YWx1ZS5zbGljZShzdGFydCwgdG8pLCB0aGlzLm1hc2tlZFZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuc2VydmljZS5tYXNrSW5wdXQodmFsdWUsIHRoaXMubWFza2VkVmFsdWUgfHwgJycsIGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUlucHV0KHJlc3VsdC52YWx1ZSwgcmVzdWx0LnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVXaXRoRXZlbnRzKHJlc3VsdC52YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5ub3JtYWxpemVWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tYXNrKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlucHV0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmV4dHJhY3RDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlcnZpY2UobmV4dCk7XG4gICAgICAgIGNvbnN0IG1hc2tlZFZhbHVlID0gdGhpcy5zZXJ2aWNlLm1hc2tSYXcodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5wdXQobWFza2VkVmFsdWUsIG51bGwsIHRydWUpO1xuICAgICAgICBpZiAoY2hhbmdlcy5pbmNsdWRlTGl0ZXJhbHMgfHwgaXNDaGFuZ2VkKCdwcm9tcHRQbGFjZWhvbGRlcicsIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZVdpdGhFdmVudHModGhpcy5tYXNrZWRWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogV3JpdGVzIGEgbmV3IHZhbHVlIHRvIHRoZSBlbGVtZW50LlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUlucHV0KHRoaXMuc2VydmljZS5tYXNrUmF3KHRoaXMudmFsdWUpKTtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZUxpdGVyYWxzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMubWFza2VkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBTZXRzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBTZXRzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBgdG91Y2hgIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXR1cyBvZiB0aGUgY29tcG9uZW50IGNoYW5nZXMgdG8gb3IgZnJvbSBgZGlzYWJsZWRgLlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgdmFsdWUsIGl0IGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGFwcHJvcHJpYXRlIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWRcbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZShfKSB7XG4gICAgICAgIGlmICh0aGlzLm1hc2tWYWxpZGF0aW9uID09PSBmYWxzZSB8fCAhdGhpcy5tYXNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2VydmljZS52YWxpZGF0aW9uVmFsdWUodGhpcy5tYXNrZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hc2tlZFZhbHVlLmluZGV4T2YodGhpcy5wcm9tcHQpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuRXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgbWFzazogdGhpcy5tYXNrLFxuICAgICAgICAgICAgICAgICAgICBtYXNrZWRWYWx1ZTogdGhpcy5tYXNrZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdXBkYXRlVmFsdWVXaXRoRXZlbnRzKG1hc2tlZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUobWFza2VkVmFsdWUpO1xuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMudmFsdWVDaGFuZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMubWFzayAmJiAhdGhpcy5zZXJ2aWNlLnZhbGlkYXRpb25WYWx1ZSh2YWx1ZSkgJiYgIXRoaXMuaW5jbHVkZUxpdGVyYWxzKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5zZXJ2aWNlLnJhd1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICB1cGRhdGVJbnB1dChtYXNrZWRWYWx1ZSA9ICcnLCBzZWxlY3Rpb24sIGlzRnJvbU9uQ2hhbmdlcykge1xuICAgICAgICBpZiAoaXNGcm9tT25DaGFuZ2VzICYmIG1hc2tlZFZhbHVlID09PSB0aGlzLm1hc2tlZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXNrZWRWYWx1ZSA9IG1hc2tlZFZhbHVlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMubWFza09uRm9jdXMgJiYgIXRoaXMuZm9jdXNlZCAmJiB0aGlzLmVtcHR5TWFzayA/ICcnIDogbWFza2VkVmFsdWU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24sIHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmFjdENoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY2hhbmdlcykuZmlsdGVyKGtleSA9PiBrZXkgIT09ICdydWxlcycpLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICAgICAgICAgIG9ialtrZXldID0gY2hhbmdlc1trZXldLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sIHt9KTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTphbGlnblxuICAgIH1cbiAgICB1cGRhdGVTZXJ2aWNlKGV4dHJhKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgaW5jbHVkZUxpdGVyYWxzOiB0aGlzLmluY2x1ZGVMaXRlcmFscyxcbiAgICAgICAgICAgIG1hc2s6IHRoaXMubWFzayxcbiAgICAgICAgICAgIHByb21wdDogdGhpcy5wcm9tcHQsXG4gICAgICAgICAgICBwcm9tcHRQbGFjZWhvbGRlcjogdGhpcy5wcm9tcHRQbGFjZWhvbGRlcixcbiAgICAgICAgICAgIHJ1bGVzOiB0aGlzLnJ1bGVzXG4gICAgICAgIH0sIGV4dHJhKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTphbGlnblxuICAgICAgICB0aGlzLnNlcnZpY2UudXBkYXRlKGNvbmZpZyk7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbihzdGFydCA9IHRoaXMuc2VsZWN0aW9uWzBdLCBlbmQgPSB0aGlzLnNlbGVjdGlvblsxXSkge1xuICAgICAgICBpZiAodGhpcy5mb2N1c2VkKSB7XG4gICAgICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuaW5wdXQsICdzZXRTZWxlY3Rpb25SYW5nZScsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbXB0eU1hc2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2UubWFza1JhdygpID09PSB0aGlzLm1hc2tlZFZhbHVlO1xuICAgIH1cbiAgICBzZXRGb2N1c1NlbGVjdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tYXNrZWRWYWx1ZSA/IHRoaXMubWFza2VkVmFsdWUuaW5kZXhPZih0aGlzLnByb21wdCkgOiAwO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IFtpbmRleCwgaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGb2N1c2VkO1xuICAgIH1cbiAgICBzZXQgZm9jdXNlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQgIT09IHZhbHVlICYmIHRoaXMuaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsIEZPQ1VTRUQkMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW1lbnQsIEZPQ1VTRUQkMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vcm1hbGl6ZVZhbHVlKHZhbHVlID0gdGhpcy52YWx1ZSkge1xuICAgICAgICBjb25zdCBwcmVzZW50ID0gaXNQcmVzZW50KHZhbHVlKTtcbiAgICAgICAgaWYgKHByZXNlbnQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgTWFza2VkVGV4dEJveCBjb21wb25lbnQgc3VwcG9ydHMgb25seSBzdHJpbmcgdmFsdWVzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXNlbnQgPyB2YWx1ZSA6ICcnO1xuICAgIH1cbiAgICBoYW5kbGVDbGFzc2VzKHZhbHVlLCBpbnB1dCkge1xuICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gZ2V0U3R5bGluZ0NsYXNzZXMoJ2lucHV0JywgaW5wdXQsIHRoaXNbaW5wdXRdLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjbGFzc2VzLnRvUmVtb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzZXMudG9SZW1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc2VzLnRvQWRkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW0sIGNsYXNzZXMudG9BZGQpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1hc2tlZFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImZvY3VzYWJsZUlkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTWFza2VkVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWFza2VkVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgTWFza2VkVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgTWFza2VkVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmRlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgTWFza2VkVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbE1vZGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJydWxlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1hc2tlZFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInByb21wdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWFza2VkVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwicHJvbXB0UGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmNsdWRlTGl0ZXJhbHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXNrT25Gb2N1c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE1hc2tlZFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcIm1hc2tWYWxpZGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnZm9jdXMnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTWFza2VkVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwib25Gb2N1c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCdibHVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE1hc2tlZFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcIm9uQmx1clwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE1hc2tlZFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5kaXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWFza2VkVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlyZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1pbnB1dCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLW1hc2tlZHRleHRib3gnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE1hc2tlZFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0RGlzYWJsZWRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnaW5wdXQnLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIE1hc2tlZFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0TGlzdGVuZXIoJ3Bhc3RlJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwYXN0ZUhhbmRsZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBNYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEhhbmRsZXJcIiwgbnVsbCk7XG5NYXNrZWRUZXh0Qm94Q29tcG9uZW50ID0gTWFza2VkVGV4dEJveENvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb01hc2tlZFRleHRCb3gnLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIE1hc2tpbmdTZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1hc2tlZFRleHRCb3hDb21wb25lbnRfMSkgLyogdHNsaW50OmRpc2FibGUtbGluZSAqL1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1hc2tlZFRleHRCb3hDb21wb25lbnRfMSkgLyogdHNsaW50OmRpc2FibGUtbGluZSAqL1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBLZW5kb0lucHV0LFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1hc2tlZFRleHRCb3hDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1tYXNrZWR0ZXh0Ym94JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICNpbnB1dFxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgICAgIGF1dG9jb3JyZWN0PVwib2ZmXCJcbiAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplPVwib2ZmXCJcbiAgICAgICAgICAgIHNwZWxsY2hlY2s9XCJmYWxzZVwiXG4gICAgICAgICAgICBjbGFzcz1cImstaW5wdXQtaW5uZXJcIlxuICAgICAgICAgICAgW2lkXT1cImZvY3VzYWJsZUlkXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCJ0YWJJbmRleFwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJ0aXRsZVwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICBmb2N1czogaGFuZGxlRm9jdXMsXG4gICAgICAgICAgICAgICAgYmx1cjogaGFuZGxlQmx1cixcbiAgICAgICAgICAgICAgICBjbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICAgICAgICAgICAgZHJhZ3N0YXJ0OiBoYW5kbGVEcmFnRHJvcCxcbiAgICAgICAgICAgICAgICBkcm9wOiBoYW5kbGVEcmFnRHJvcFxuICAgICAgICAgICAgfVwiXG4gICAgICAgIC8+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oNiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oNiwgSW5qZWN0KFJUTCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTWFza2luZ1NlcnZpY2UsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgTmdab25lLFxuICAgICAgICBJbmplY3RvcixcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsIEJvb2xlYW5dKVxuXSwgTWFza2VkVGV4dEJveENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTbGlkZXJUaWNrIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IHtcbiAgICAgICAgICAgICdrLXRpY2snOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTbGlkZXJUaWNrc0NvbXBvbmVudCA9IGNsYXNzIFNsaWRlclRpY2tzQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMud3JhcHBlckNsYXNzZXMgPSAnay1yZXNldCBrLXNsaWRlci1pdGVtcyc7XG4gICAgICAgIHRoaXMudGlja3MgPSBbXTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoXykge1xuICAgICAgICB0aGlzLmNyZWF0ZVRpY2tzKCk7XG4gICAgfVxuICAgIGNyZWF0ZVRpY2tzKCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IGNhbGN1bGF0ZVRpY2tzQ291bnQodGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLnN0ZXApO1xuICAgICAgICBjb25zdCBsYXJnZVN0ZXAgPSB0aGlzLmxhcmdlU3RlcDtcbiAgICAgICAgY29uc3QgdGlja1ZhbHVlUHJvcHMgPSB7XG4gICAgICAgICAgICBtYXg6IHRoaXMubWF4LFxuICAgICAgICAgICAgbWluOiB0aGlzLm1pbixcbiAgICAgICAgICAgIHNtYWxsU3RlcDogdGhpcy5zdGVwXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU2xpZGVyVGljayhjYWxjdWxhdGVWYWx1ZUZyb21UaWNrKGksIHRpY2tWYWx1ZVByb3BzKSkpO1xuICAgICAgICAgICAgaWYgKGxhcmdlU3RlcCAmJiBpICUgbGFyZ2VTdGVwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldLmxhcmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0uY2xhc3Nlc1snay10aWNrLWxhcmdlJ10gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHRbMF0uY2xhc3NlcywgdGhpcy5lbmRUaWNrQ2xhc3Nlcyh0cnVlKSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0uY2xhc3NlcywgdGhpcy5lbmRUaWNrQ2xhc3NlcyhmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlja3MgPSByZXN1bHQ7XG4gICAgfVxuICAgIGVuZFRpY2tDbGFzc2VzKGZpcnN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnay1maXJzdCc6IChmaXJzdCAmJiAhdGhpcy52ZXJ0aWNhbCkgfHwgKCFmaXJzdCAmJiB0aGlzLnZlcnRpY2FsKSxcbiAgICAgICAgICAgICdrLWxhc3QnOiAoIWZpcnN0ICYmICF0aGlzLnZlcnRpY2FsKSB8fCAoZmlyc3QgJiYgdGhpcy52ZXJ0aWNhbClcbiAgICAgICAgfTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNsaWRlclRpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3cmFwcGVyQ2xhc3Nlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTbGlkZXJUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja1RpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2xpZGVyVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInZlcnRpY2FsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTbGlkZXJUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic3RlcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2xpZGVyVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcImxhcmdlU3RlcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2xpZGVyVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2xpZGVyVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBTbGlkZXJUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkcmVuKCd0aWNrRWxlbWVudCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBTbGlkZXJUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja0VsZW1lbnRzXCIsIHZvaWQgMCk7XG5TbGlkZXJUaWNrc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvU2xpZGVyVGlja3NdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bGkgI3RpY2tFbGVtZW50ICpuZ0Zvcj1cImxldCB0aWNrIG9mIHRpY2tzO1wiXG4gICAgICAgIFtuZ0NsYXNzXT1cInRpY2suY2xhc3Nlc1wiXG4gICAgICAgIHRpdGxlPVwie3sgdGlja1RpdGxlKHRpY2sudmFsdWUpIH19XCJcbiAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgID5cbiAgICAgICAgIDxuZy1jb250YWluZXIgW25nU3dpdGNoXT1cInRpY2subGFyZ2VcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1sYWJlbFwiICpuZ1N3aXRjaENhc2U9XCJ0cnVlXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJsYWJlbFRlbXBsYXRlIHx8IGRlZmF1bHRMYWJlbFwiIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ0aWNrXCI+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1N3aXRjaENhc2U9XCJmYWxzZVwiPiZuYnNwOzwvbmctY29udGFpbmVyPlxuICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgIDwvbGk+XG5cbiAgICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0TGFiZWwgbGV0LXZhbHVlPVwidmFsdWVcIj5cbiAgICAgICAge3sgdGlja1RpdGxlKHZhbHVlKSB9fVxuICAgICA8L25nLXRlbXBsYXRlPlxuICBgXG4gICAgfSlcbl0sIFNsaWRlclRpY2tzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTbGlkZXJzQ29tbW9uTW9kdWxlID0gY2xhc3MgU2xpZGVyc0NvbW1vbk1vZHVsZSB7XG59O1xuU2xpZGVyc0NvbW1vbk1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBTbGlkZXJUaWNrc0NvbXBvbmVudCxcbiAgICAgICAgICAgIExhYmVsVGVtcGxhdGVEaXJlY3RpdmVcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIFNsaWRlclRpY2tzQ29tcG9uZW50LFxuICAgICAgICAgICAgRHJhZ2dhYmxlTW9kdWxlLFxuICAgICAgICAgICAgRXZlbnRzTW9kdWxlLFxuICAgICAgICAgICAgUmVzaXplU2Vuc29yTW9kdWxlXG4gICAgICAgIF0sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIERyYWdnYWJsZU1vZHVsZSwgRXZlbnRzTW9kdWxlLCBSZXNpemVTZW5zb3JNb2R1bGVdXG4gICAgfSlcbl0sIFNsaWRlcnNDb21tb25Nb2R1bGUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2xpZGVyTWVzc2FnZXMgZXh0ZW5kcyBDb21wb25lbnRNZXNzYWdlcyB7XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTbGlkZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiZGVjcmVtZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTbGlkZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiaW5jcmVtZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTbGlkZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiZHJhZ0hhbmRsZVwiLCB2b2lkIDApO1xuXG52YXIgTG9jYWxpemVkU2xpZGVyTWVzc2FnZXNEaXJlY3RpdmVfMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTG9jYWxpemVkU2xpZGVyTWVzc2FnZXNEaXJlY3RpdmUgPSBMb2NhbGl6ZWRTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZV8xID0gY2xhc3MgTG9jYWxpemVkU2xpZGVyTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBTbGlkZXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5Mb2NhbGl6ZWRTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZSA9IExvY2FsaXplZFNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBTbGlkZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMb2NhbGl6ZWRTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZV8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvU2xpZGVyTG9jYWxpemVkTWVzc2FnZXNdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBMb2NhbGl6ZWRTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZSk7XG5cbnZhciBTbGlkZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xO1xuLyoqXG4gKiBDdXN0b20gY29tcG9uZW50IG1lc3NhZ2VzIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50IG1lc3NhZ2VzLlxuICovXG5sZXQgU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBTbGlkZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gY2xhc3MgU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgZXh0ZW5kcyBTbGlkZXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5TbGlkZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IFNsaWRlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBTbGlkZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTbGlkZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tc2xpZGVyLW1lc3NhZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFNsaWRlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgU2xpZGVyIGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBJbnB1dHMgbW9kdWxlXG4gKiBpbXBvcnQgeyBTbGlkZXJNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKiBpbXBvcnQgeyBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSwgU2xpZGVyTW9kdWxlXSwgLy8gaW1wb3J0IFNsaWRlciBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBTbGlkZXJNb2R1bGUgPSBjbGFzcyBTbGlkZXJNb2R1bGUge1xufTtcblNsaWRlck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBTbGlkZXJDb21wb25lbnQsXG4gICAgICAgICAgICBTbGlkZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCxcbiAgICAgICAgICAgIExvY2FsaXplZFNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIFNsaWRlckNvbXBvbmVudCxcbiAgICAgICAgICAgIFNsaWRlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICAgICAgTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIExvY2FsaXplZFNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlXG4gICAgICAgIF0sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIFNsaWRlcnNDb21tb25Nb2R1bGVdXG4gICAgfSlcbl0sIFNsaWRlck1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBSYW5nZVNsaWRlck1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUmFuZ2VTbGlkZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiZHJhZ0hhbmRsZVN0YXJ0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBSYW5nZVNsaWRlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJkcmFnSGFuZGxlRW5kXCIsIHZvaWQgMCk7XG5cbnZhciBMb2NhbGl6ZWRSYW5nZVNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlXzE7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IExvY2FsaXplZFJhbmdlU2xpZGVyTWVzc2FnZXNEaXJlY3RpdmUgPSBMb2NhbGl6ZWRSYW5nZVNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBjbGFzcyBMb2NhbGl6ZWRSYW5nZVNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlIGV4dGVuZHMgUmFuZ2VTbGlkZXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5Mb2NhbGl6ZWRSYW5nZVNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlID0gTG9jYWxpemVkUmFuZ2VTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogUmFuZ2VTbGlkZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMb2NhbGl6ZWRSYW5nZVNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlXzEpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9TbGlkZXJMb2NhbGl6ZWRNZXNzYWdlc10nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIExvY2FsaXplZFJhbmdlU2xpZGVyTWVzc2FnZXNEaXJlY3RpdmUpO1xuXG52YXIgUmFuZ2VTbGlkZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xO1xuLyoqXG4gKiBDdXN0b20gY29tcG9uZW50IG1lc3NhZ2VzIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50IG1lc3NhZ2VzLlxuICovXG5sZXQgUmFuZ2VTbGlkZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IFJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IGNsYXNzIFJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgZXh0ZW5kcyBSYW5nZVNsaWRlck1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBSYW5nZVNsaWRlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBSYW5nZVNsaWRlck1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXJhbmdlc2xpZGVyLW1lc3NhZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBSYW5nZVNsaWRlciBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgSW5wdXRzIG1vZHVsZVxuICogaW1wb3J0IHsgUmFuZ2VTbGlkZXJNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKiBpbXBvcnQgeyBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSwgUmFuZ2VTbGlkZXJNb2R1bGVdLCAvLyBpbXBvcnQgUmFuZ2VTbGlkZXIgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5sZXQgUmFuZ2VTbGlkZXJNb2R1bGUgPSBjbGFzcyBSYW5nZVNsaWRlck1vZHVsZSB7XG59O1xuUmFuZ2VTbGlkZXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgUmFuZ2VTbGlkZXJDb21wb25lbnQsXG4gICAgICAgICAgICBSYW5nZVNsaWRlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICAgICAgTG9jYWxpemVkUmFuZ2VTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZVxuICAgICAgICBdLFxuICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICBSYW5nZVNsaWRlckNvbXBvbmVudCxcbiAgICAgICAgICAgIFJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICBMb2NhbGl6ZWRSYW5nZVNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlLFxuICAgICAgICAgICAgTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZVxuICAgICAgICBdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBTbGlkZXJzQ29tbW9uTW9kdWxlXVxuICAgIH0pXG5dLCBSYW5nZVNsaWRlck1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBNZXNzYWdlcyBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcIm9mZlwiLCB2b2lkIDApO1xuXG52YXIgTG9jYWxpemVkU3dpdGNoTWVzc2FnZXNEaXJlY3RpdmVfMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTG9jYWxpemVkU3dpdGNoTWVzc2FnZXNEaXJlY3RpdmUgPSBMb2NhbGl6ZWRTd2l0Y2hNZXNzYWdlc0RpcmVjdGl2ZV8xID0gY2xhc3MgTG9jYWxpemVkU3dpdGNoTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5Mb2NhbGl6ZWRTd2l0Y2hNZXNzYWdlc0RpcmVjdGl2ZSA9IExvY2FsaXplZFN3aXRjaE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMb2NhbGl6ZWRTd2l0Y2hNZXNzYWdlc0RpcmVjdGl2ZV8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvU3dpdGNoTG9jYWxpemVkTWVzc2FnZXNdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBMb2NhbGl6ZWRTd2l0Y2hNZXNzYWdlc0RpcmVjdGl2ZSk7XG5cbnZhciBTd2l0Y2hDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xO1xuLyoqXG4gKiBDdXN0b20gY29tcG9uZW50IG1lc3NhZ2VzIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50IG1lc3NhZ2VzLlxuICovXG5sZXQgU3dpdGNoQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBTd2l0Y2hDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gY2xhc3MgU3dpdGNoQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgZXh0ZW5kcyBNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5Td2l0Y2hDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IFN3aXRjaEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTd2l0Y2hDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tc3dpdGNoLW1lc3NhZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFN3aXRjaEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgU3dpdGNoIGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBTd2l0Y2ggbW9kdWxlXG4gKiBpbXBvcnQgeyBTd2l0Y2hNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBTd2l0Y2hNb2R1bGVdLCAvLyBpbXBvcnQgU3dpdGNoIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xubGV0IFN3aXRjaE1vZHVsZSA9IGNsYXNzIFN3aXRjaE1vZHVsZSB7XG59O1xuU3dpdGNoTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIFN3aXRjaENvbXBvbmVudCxcbiAgICAgICAgICAgIFN3aXRjaEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICAgICAgTG9jYWxpemVkU3dpdGNoTWVzc2FnZXNEaXJlY3RpdmVcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgU3dpdGNoQ29tcG9uZW50LFxuICAgICAgICAgICAgU3dpdGNoQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICBMb2NhbGl6ZWRTd2l0Y2hNZXNzYWdlc0RpcmVjdGl2ZVxuICAgICAgICBdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBFdmVudHNNb2R1bGUsIFJlc2l6ZVNlbnNvck1vZHVsZV1cbiAgICB9KVxuXSwgU3dpdGNoTW9kdWxlKTtcblxudmFyIExvY2FsaXplZE51bWVyaWNUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmVfMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTG9jYWxpemVkTnVtZXJpY1RleHRCb3hNZXNzYWdlc0RpcmVjdGl2ZSA9IExvY2FsaXplZE51bWVyaWNUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmVfMSA9IGNsYXNzIExvY2FsaXplZE51bWVyaWNUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBOdW1lcmljVGV4dEJveE1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxufTtcbkxvY2FsaXplZE51bWVyaWNUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmUgPSBMb2NhbGl6ZWROdW1lcmljVGV4dEJveE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBOdW1lcmljVGV4dEJveE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExvY2FsaXplZE51bWVyaWNUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmVfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb051bWVyaWNUZXh0Qm94TG9jYWxpemVkTWVzc2FnZXNdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBMb2NhbGl6ZWROdW1lcmljVGV4dEJveE1lc3NhZ2VzRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgTnVtZXJpY1RleHRCb3ggY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIE51bWVyaWNUZXh0Qm94IG1vZHVsZVxuICogaW1wb3J0IHsgTnVtZXJpY1RleHRCb3hNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBOdW1lcmljVGV4dEJveE1vZHVsZV0sIC8vIGltcG9ydCBOdW1lcmljVGV4dEJveCBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBOdW1lcmljVGV4dEJveE1vZHVsZSA9IGNsYXNzIE51bWVyaWNUZXh0Qm94TW9kdWxlIHtcbn07XG5OdW1lcmljVGV4dEJveE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBMb2NhbGl6ZWROdW1lcmljVGV4dEJveE1lc3NhZ2VzRGlyZWN0aXZlLFxuICAgICAgICAgICAgTnVtZXJpY1RleHRCb3hDb21wb25lbnQsXG4gICAgICAgICAgICBOdW1lcmljVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LFxuICAgICAgICAgICAgTnVtZXJpY1RleHRCb3hDdXN0b21NZXNzYWdlc0NvbXBvbmVudFxuICAgICAgICBdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBFdmVudHNNb2R1bGVdXG4gICAgfSlcbl0sIE51bWVyaWNUZXh0Qm94TW9kdWxlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgTWFza2VkVGV4dEJveCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgTWFza2VkVGV4dEJveCBtb2R1bGVcbiAqIGltcG9ydCB7IE1hc2tlZFRleHRCb3hNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBNYXNrZWRUZXh0Qm94TW9kdWxlXSwgLy8gaW1wb3J0IE1hc2tlZFRleHRCb3ggbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5sZXQgTWFza2VkVGV4dEJveE1vZHVsZSA9IGNsYXNzIE1hc2tlZFRleHRCb3hNb2R1bGUge1xufTtcbk1hc2tlZFRleHRCb3hNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW01hc2tlZFRleHRCb3hDb21wb25lbnRdLFxuICAgICAgICBleHBvcnRzOiBbTWFza2VkVGV4dEJveENvbXBvbmVudF0sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEV2ZW50c01vZHVsZV1cbiAgICB9KVxuXSwgTWFza2VkVGV4dEJveE1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdXNlZCBicm93c2VyIGlzIFNhZmFyaS5cbiAqL1xuY29uc3QgaXNTYWZhcmkgPSAodXNlckFnZW50KSA9PiB7XG4gICAgY29uc3QgZGVza3RvcEJyb3dzZXIgPSBkZXRlY3REZXNrdG9wQnJvd3Nlcih1c2VyQWdlbnQpO1xuICAgIGNvbnN0IG1vYmlsZU9TJCQxID0gZGV0ZWN0TW9iaWxlT1ModXNlckFnZW50KTtcbiAgICByZXR1cm4gKGRlc2t0b3BCcm93c2VyICYmIGRlc2t0b3BCcm93c2VyLnNhZmFyaSkgfHwgKG1vYmlsZU9TJCQxICYmIG1vYmlsZU9TJCQxLmJyb3dzZXIgPT09ICdtb2JpbGVzYWZhcmknKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBDaGVja3MgaWYgaW5wdXQgaXMgSmFwYW5lc2UgSU1FXG4gKi9cbmNvbnN0IGlzSmFwYW5lc2UgPSAoaW5wdXQpID0+IHtcbiAgICBjb25zdCBqYXBhbmVzZVJlZ2V4ID0gL1tcXHUzMDAwLVxcdTMwM0ZdfFtcXHUzMDQwLVxcdTMwOUZdfFtcXHUzMEEwLVxcdTMwRkZdfFtcXHVGRjAwLVxcdUZGRUZdfFtcXHU0RTAwLVxcdTlGQUZdfFtcXHUyNjA1LVxcdTI2MDZdfFtcXHUyMTkwLVxcdTIxOTVdfFxcdTIwM0IvZztcbiAgICByZXR1cm4gamFwYW5lc2VSZWdleC50ZXN0KGlucHV0KTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhZG9ybm1lbnRzIGluIHRoZSBzdWZmaXggY29udGFpbmVyIChbc2VlIGV4YW1wbGVzXSh7JSBzbHVnIGFkb3JubWVudHNfdGV4dGJveCAlfSN0b2Mtc3VmZml4YWRvcm5tZW50cykpLlxuICogYGBgdHMtbm8tcnVuXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby10ZXh0Ym94PlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvVGV4dEJveFN1ZmZpeFRlbXBsYXRlPlxuICogICAgICAgIDxidXR0b24ga2VuZG9CdXR0b24gbG9vaz1cImNsZWFyXCIgaWNvbj1cImltYWdlXCI+PC9idXR0b24+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tdGV4dGJveD5cbiAqIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge31cbiAqIGBgYFxuICovXG5sZXQgVGV4dEJveFN1ZmZpeFRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgVGV4dEJveFN1ZmZpeFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcblRleHRCb3hTdWZmaXhUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVGV4dEJveFN1ZmZpeFRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgVGV4dEJveFN1ZmZpeFRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGFkb3JubWVudHMgaW4gdGhlIHByZWZpeCBjb250YWluZXIgKFtzZWUgZXhhbXBsZXNdKHslIHNsdWcgYWRvcm5tZW50c190ZXh0Ym94ICV9I3RvYy1wcmVmaXhhZG9ybm1lbnRzKSkuXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby10ZXh0Ym94PlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvVGV4dEJveFByZWZpeFRlbXBsYXRlPlxuICogICAgICAgIDxidXR0b24ga2VuZG9CdXR0b24gbG9vaz1cImNsZWFyXCIgaWNvbj1cImltYWdlXCI+PC9idXR0b24+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tdGV4dGJveD5cbiAqIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge31cbiAqIGBgYFxuICovXG5sZXQgVGV4dEJveFByZWZpeFRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgVGV4dEJveFByZWZpeFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcblRleHRCb3hQcmVmaXhUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVGV4dEJveFByZWZpeFRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgVGV4dEJveFByZWZpeFRlbXBsYXRlRGlyZWN0aXZlKTtcblxudmFyIFRleHRCb3hDb21wb25lbnRfMTtcbmNvbnN0IEZPQ1VTRUQkMyA9ICdrLWZvY3VzJztcbmxldCBUZXh0Qm94Q29tcG9uZW50ID0gVGV4dEJveENvbXBvbmVudF8xID0gY2xhc3MgVGV4dEJveENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uU2VydmljZSwgbmdab25lLCBjaGFuZ2VEZXRlY3RvciwgcmVuZGVyZXIsIGluamVjdG9yLCBob3N0RWxlbWVudCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2FibGVJZCA9IGBrLSR7Z3VpZCgpfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBgdGl0bGVgIGF0dHJpYnV0ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50IG9mIHRoZSBUZXh0Qm94LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aXRsZSA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHJlYWQtb25seSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBgdGFiaW5kZXhgIG9mIHRoZSBUZXh0Qm94LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGVzIGEgdmFsdWUgZm9yIHRoZSBUZXh0Qm94LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHdob2xlIHZhbHVlIHdpbGwgYmUgc2VsZWN0ZWQgd2hlbiB0aGUgVGV4dEJveCBpcyBjbGlja2VkLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RPbkZvY3VzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hlbiB0aGUgU3VjY2VzcyBpY29uIHdpbGwgYmUgc2hvd24gKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB2YWxpZGF0aW9uX3RleHRib3ggJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqXG4gICAgICAgICAqIGBib29sZWFuYCZtZGFzaDtUaGUgU3VjY2VzcyBpY29uIGlzIGRpc3BsYXllZCwgaWYgdGhlIGNvbmRpdGlvbiBnaXZlbiBieSB0aGUgZGV2ZWxvcGVyIGlzIG1ldC5cbiAgICAgICAgICpcbiAgICAgICAgICogYGluaXRpYWxgJm1kYXNoO1RoZSBTdWNjZXNzIGljb24gd2lsbCBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgY29tcG9uZW50IHN0YXRlIGlzIG5laXRoZXIgYGludmFsaWRgIG5vciBgdG91Y2hlZGAgb3IgYGRpcnR5YC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvd1N1Y2Nlc3NJY29uID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hlbiB0aGUgRXJyb3IgaWNvbiB3aWxsIGJlIHNob3duIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdmFsaWRhdGlvbl90ZXh0Ym94ICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBpbml0aWFsYCZtZGFzaDtUaGUgRXJyb3IgaWNvbiB3aWxsIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBjb21wb25lbnQgc3RhdGUgaXNcbiAgICAgICAgICogYGludmFsaWRgIGFuZCBgdG91Y2hlZGAgb3IgYGRpcnR5YC5cbiAgICAgICAgICogKiBgYm9vbGVhbmAmbWRhc2g7VGhlIEVycm9yIGljb24gaXMgZGlzcGxheWVkLCBpZiB0aGUgY29uZGl0aW9uIGdpdmVuIGJ5IHRoZSBkZXZlbG9wZXIgaXMgbWV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93RXJyb3JJY29uID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciBhIENsZWFyIGJ1dHRvbiB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhckJ1dHRvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkJm1kYXNoO1xuICAgICAgICAgKiB3aGVuIHRoZSBjb21wb25lbnQgaXMgYmx1cnJlZCBvciB0aGUgdmFsdWUgaXMgY2xlYXJlZCB0aHJvdWdoIHRoZSAqKkNsZWFyKiogYnV0dG9uXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfdGV4dGJveCAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqIFdoZW4gdGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQgaXMgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VkIHRvIGBuZ01vZGVsYCBvciBgZm9ybUNvbnRyb2xgXG4gICAgICAgICAqIHRocm91Z2ggaXRzIEFQSSBvciBmb3JtIGJpbmRpbmcsIHRoZSBgdmFsdWVDaGFuZ2VgIGV2ZW50IGlzIG5vdCB0cmlnZ2VyZWQgYmVjYXVzZSBpdFxuICAgICAgICAgKiBtaWdodCBjYXVzZSBhIG1peC11cCB3aXRoIHRoZSBidWlsdC1pbiBgdmFsdWVDaGFuZ2VgIG1lY2hhbmlzbXMgb2YgdGhlIGBuZ01vZGVsYCBvciBgZm9ybUNvbnRyb2xgIGJpbmRpbmdzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBmb2N1c2VzIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlucHV0Rm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGBpbnB1dGAgZWxlbWVudCBnZXRzIGJsdXJyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlucHV0Qmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBmb2N1c2VzIHRoZSBUZXh0Qm94IGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUbyB3aXJlIHRoZSBldmVudCBwcm9ncmFtbWF0aWNhbGx5LCB1c2UgdGhlIGBvbkZvY3VzYCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHMtbm8tcnVuXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLXRleHRib3ggKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIj48L2tlbmRvLXRleHRib3g+XG4gICAgICAgICAqIGBcbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgaGFuZGxlRm9jdXMoKTogdm9pZCB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coJ0NvbXBvbmVudCBpcyBpc0ZvY3VzZWQnKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIFRleHRCb3ggY29tcG9uZW50IGdldHMgYmx1cnJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUbyB3aXJlIHRoZSBldmVudCBwcm9ncmFtbWF0aWNhbGx5LCB1c2UgdGhlIGBvbkJsdXJgIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0cy1uby1ydW5cbiAgICAgICAgICogX0BDb21wb25lbnQoe1xuICAgICAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICAgICAqICA8a2VuZG8tdGV4dGJveCAoYmx1cik9XCJoYW5kbGVCbHVyKClcIj48L2tlbmRvLXRleHRib3g+XG4gICAgICAgICAqIGBcbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgaGFuZGxlQmx1cigpOiB2b2lkIHtcbiAgICAgICAgICogICAgICBjb25zb2xlLmxvZygnQ29tcG9uZW50IGlzIGJsdXJyZWQnKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICB0aGlzLl9yb3VuZGVkID0gJ21lZGl1bSc7XG4gICAgICAgIHRoaXMuX2ZpbGxNb2RlID0gJ3NvbGlkJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlSW5wdXRGb2N1cyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdE9uRm9jdXMgJiYgdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuc2VsZWN0QWxsKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uRm9jdXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5pbnB1dEZvY3VzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSB8fCAodGhpcy5mb2N1c0NoYW5nZWRQcm9ncmFtbWF0aWNhbGx5ICYmIHRoaXMuY2xlYXJCdXR0b25DbGlja2VkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Rm9jdXMuZW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVJbnB1dEJsdXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLmlucHV0Qmx1cikgfHwgcmVxdWlyZXNab25lT25CbHVyKHRoaXMuY29udHJvbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nVG91Y2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Qmx1ci5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUlucHV0ID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldi50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBpc0Jyb3dzZXJTYWZhcmkgPSBpc1NhZmFyaShuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGluY29taW5nVmFsdWUgPSBpc0Jyb3dzZXJTYWZhcmkgJiYgaXNKYXBhbmVzZSh0YXJnZXQudmFsdWUpID8gZXYuZGF0YSA6IHRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IFtjYXJldFN0YXJ0LCBjYXJldEVuZF0gPSBbdGFyZ2V0LnNlbGVjdGlvblN0YXJ0LCB0YXJnZXQuc2VsZWN0aW9uRW5kXTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUoaW5jb21pbmdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNCcm93c2VyU2FmYXJpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKGNhcmV0U3RhcnQsIGNhcmV0RW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uZ0NoYW5nZSA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gKCkgPT4geyB9O1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBsb2NhbGl6YXRpb25TZXJ2aWNlLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIHByb3BlcnR5IHNwZWNpZmllcyB0aGUgcGFkZGluZyBvZiB0aGUgVGV4dEJveCBpbnRlcm5hbCBpbnB1dCBlbGVtZW50XG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcHBlYXJhbmNlX3RleHRib3ggJX0jdG9jLXNpemUpKS5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzbWFsbCdgXG4gICAgICogKiBgJ21lZGl1bSdgIChkZWZhdWx0KVxuICAgICAqICogYCdsYXJnZSdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKi9cbiAgICBzZXQgc2l6ZShzaXplKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xhc3NlcyhzaXplLCAnc2l6ZScpO1xuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcm91bmRlZCBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIGJvcmRlciByYWRpdXMgb2YgdGhlIFRleHRCb3hcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwcGVhcmFuY2VfdGV4dGJveCAlfSN0b2Mtcm91bmRlZCkpLlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgJ3NtYWxsJ2BcbiAgICAgKiAqIGAnbWVkaXVtJ2AgKGRlZmF1bHQpXG4gICAgICogKiBgJ2xhcmdlJ2BcbiAgICAgKiAqIGAnZnVsbCdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKi9cbiAgICBzZXQgcm91bmRlZChyb3VuZGVkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xhc3Nlcyhyb3VuZGVkLCAncm91bmRlZCcpO1xuICAgICAgICB0aGlzLl9yb3VuZGVkID0gcm91bmRlZDtcbiAgICB9XG4gICAgZ2V0IHJvdW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3VuZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlsbE1vZGUgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBiYWNrZ3JvdW5kIGFuZCBib3JkZXIgc3R5bGVzIG9mIHRoZSBUZXh0Qm94XG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcHBlYXJhbmNlX3RleHRib3ggJX0jdG9jLWZpbGxNb2RlKSkuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGAnZmxhdCdgXG4gICAgICogKiBgJ3NvbGlkJ2AgKGRlZmF1bHQpXG4gICAgICogKiBgJ291dGxpbmUnYFxuICAgICAqICogYG51bGxgXG4gICAgICovXG4gICAgc2V0IGZpbGxNb2RlKGZpbGxNb2RlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xhc3NlcyhmaWxsTW9kZSwgJ2ZpbGxNb2RlJyk7XG4gICAgICAgIHRoaXMuX2ZpbGxNb2RlID0gZmlsbE1vZGU7XG4gICAgfVxuICAgIGdldCBmaWxsTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxNb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IHRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gdGhpcy5pbmplY3Rvci5nZXQoTmdDb250cm9sLCBudWxsKTtcbiAgICAgICAgdGhpcy5jaGVja0NsZWFyQnV0dG9uKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IGN1cnNvckluc2lkZVdyYXBwZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRhYmJpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgLy8gZm9jdXNJbiBhbmQgZm9jdXNPdXQgYXJlIHJlbGF0aXZlIHRvIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1c2luJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1c291dCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YWJiaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RUZXh0Ym94ID0gY2xvc2VzdCQxKGFyZ3MucmVsYXRlZFRhcmdldCwgKGVsZW1lbnQpID0+IGVsZW1lbnQgPT09IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VzdFRleHRib3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhYmJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29ySW5zaWRlV3JhcHBlciAmJiAhdGhpcy5jbGVhckJ1dHRvbkNsaWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbihob3N0RWxlbWVudCwgJ21vdXNlZW50ZXInLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3Vyc29ySW5zaWRlV3JhcHBlciA9IHRydWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucmVuZGVyZXIubGlzdGVuKGhvc3RFbGVtZW50LCAnbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjdXJzb3JJbnNpZGVXcmFwcGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucmVuZGVyZXIubGlzdGVuKGhvc3RFbGVtZW50LCAna2V5ZG93bicsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5UYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFiYmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWJiaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3R5bGluZ0lucHV0cyA9IFsnc2l6ZScsICdyb3VuZGVkJywgJ2ZpbGxNb2RlJ107XG4gICAgICAgIHN0eWxpbmdJbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsYXNzZXModGhpc1tpbnB1dF0sIGlucHV0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZGlzYWJsZWQgfHwgY2hhbmdlcy5yZWFkb25seSB8fCBjaGFuZ2VzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ2xlYXJCdXR0b24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgVGV4dEJveC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHMtbm8tcnVuXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8YnV0dG9uIChjbGljayk9XCJpbnB1dC5mb2N1cygpXCI+Rm9jdXMgdGhlIGlucHV0PC9idXR0b24+XG4gICAgICogIDxrZW5kby10ZXh0Ym94ICNpbnB1dD48L2tlbmRvLXRleHRib3g+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIFRleHRCb3guXG4gICAgICovXG4gICAgYmx1cigpIHtcbiAgICAgICAgdGhpcy5mb2N1c0NoYW5nZWRQcm9ncmFtbWF0aWNhbGx5ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaXNGb2N1c2VkRWxlbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCc6Zm9jdXMnKTtcbiAgICAgICAgaWYgKGlzRm9jdXNlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlzRm9jdXNlZEVsZW1lbnQuYmx1cigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY2xlYXJUaXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQoJ2NsZWFyJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjaGVja0NsZWFyQnV0dG9uKCkge1xuICAgICAgICB0aGlzLnNob3dDbGVhckJ1dHRvbiA9XG4gICAgICAgICAgICAhdGhpcy5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnJlYWRvbmx5ICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckJ1dHRvbiAmJlxuICAgICAgICAgICAgICAgICEhdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNsZWFyVmFsdWUoZXYpIHtcbiAgICAgICAgaWYgKGV2KSB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJCdXR0b25DbGlja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LnZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKCcnKTtcbiAgICAgICAgdGhpcy5jaGVja0NsZWFyQnV0dG9uKCk7XG4gICAgICAgIHRoaXMuY2xlYXJCdXR0b25DbGlja2VkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jaGVja0NsZWFyQnV0dG9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMubmdDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgc3RhdHVzIG9mIHRoZSBjb21wb25lbnQgY2hhbmdlcyB0byBvciBmcm9tIGBkaXNhYmxlZGAuXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSwgaXQgZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgYXBwcm9wcmlhdGUgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXNEaXNhYmxlZFxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNob3dFcnJvcnNJbml0aWFsKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW52YWxpZCwgZGlydHksIHRvdWNoZWQgfSA9IHRoaXMuY29udHJvbDtcbiAgICAgICAgcmV0dXJuIGludmFsaWQgJiYgKGRpcnR5IHx8IHRvdWNoZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2hvd1N1Y2Nlc3NJbml0aWFsKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdmFsaWQsIGRpcnR5LCB0b3VjaGVkIH0gPSB0aGlzLmNvbnRyb2w7XG4gICAgICAgIHJldHVybiB2YWxpZCAmJiAoZGlydHkgfHwgdG91Y2hlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc3VjY2Vzc0ljb25DbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWNjZXNzSWNvblxuICAgICAgICAgICAgPyBgJHt0aGlzLnN1Y2Nlc3NJY29ufWBcbiAgICAgICAgICAgIDogYGstaW5wdXQtdmFsaWRhdGlvbi1pY29uIGstaWNvbiBrLWktY2hlY2tgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGVycm9ySWNvbkNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9ySWNvblxuICAgICAgICAgICAgPyBgJHt0aGlzLmVycm9ySWNvbn1gXG4gICAgICAgICAgICA6IGBrLWlucHV0LXZhbGlkYXRpb24taWNvbiBrLWljb24gay1pLXdhcm5pbmdgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNsZWFyQnV0dG9uQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXJCdXR0b25JY29uXG4gICAgICAgICAgICA/IHRoaXMuY2xlYXJCdXR0b25JY29uXG4gICAgICAgICAgICA6IGBrLWljb24gay1pLXhgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhhc0Vycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvd0Vycm9ySWNvbiA9PT0gJ2luaXRpYWwnXG4gICAgICAgICAgICA/IHRoaXMuc2hvd0Vycm9yc0luaXRpYWwoKVxuICAgICAgICAgICAgOiB0aGlzLnNob3dFcnJvckljb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaXNTdWNjZXNzZnVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93U3VjY2Vzc0ljb24gPT09ICdpbml0aWFsJ1xuICAgICAgICAgICAgPyB0aGlzLnNob3dTdWNjZXNzSW5pdGlhbCgpXG4gICAgICAgICAgICA6IHRoaXMuc2hvd1N1Y2Nlc3NJY29uO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIGludm9rZUVsZW1lbnRNZXRob2QodGhpcy5pbnB1dCwgJ3NldFNlbGVjdGlvblJhbmdlJywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0QWxsKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oMCwgdGhpcy52YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghYXJlU2FtZSh0aGlzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMubmdDaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0NsZWFyQnV0dG9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0ZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0ZvY3VzZWQ7XG4gICAgfVxuICAgIHNldCBpc0ZvY3VzZWQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRm9jdXNlZCAhPT0gdmFsdWUgJiYgdGhpcy5ob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgRk9DVVNFRCQzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgRk9DVVNFRCQzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lzRm9jdXNlZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUJsdXIoKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVDbGFzc2VzKHZhbHVlLCBpbnB1dCkge1xuICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gZ2V0U3R5bGluZ0NsYXNzZXMoJ2lucHV0JywgaW5wdXQsIHRoaXNbaW5wdXRdLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjbGFzc2VzLnRvUmVtb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzZXMudG9SZW1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc2VzLnRvQWRkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW0sIGNsYXNzZXMudG9BZGQpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImZvY3VzYWJsZUlkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwicmVhZG9ubHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdE9uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dTdWNjZXNzSWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0Vycm9ySWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImNsZWFyQnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdWNjZXNzSWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JJY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjbGVhckJ1dHRvbkljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmRlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbE1vZGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcbl0sIFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcIm1heGxlbmd0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5wdXRGb2N1c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRleHRCb3hDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0Qmx1clwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCdmb2N1cycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2JsdXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwib25CbHVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2lucHV0JywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFRleHRCb3hTdWZmaXhUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZXh0Qm94U3VmZml4VGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdWZmaXhUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFRleHRCb3hQcmVmaXhUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZXh0Qm94UHJlZml4VGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmVmaXhUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXRleHRib3gnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1pbnB1dCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGV4dEJveENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmRpcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUZXh0Qm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcblRleHRCb3hDb21wb25lbnQgPSBUZXh0Qm94Q29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvVGV4dEJveCcsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTDEwTl9QUkVGSVgsIHVzZVZhbHVlOiAna2VuZG8udGV4dGJveCcgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUZXh0Qm94Q29tcG9uZW50XzEpLFxuICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBLZW5kb0lucHV0LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUZXh0Qm94Q29tcG9uZW50XzEpIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10ZXh0Ym94JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBrZW5kb1RleHRCb3hMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICAgICAgaTE4bi1jbGVhcj1cImtlbmRvLnRleHRib3guY2xlYXJ8VGhlIHRpdGxlIGZvciB0aGUgKipDbGVhcioqIGJ1dHRvbiBpbiB0aGUgVGV4dEJveC5cIlxuICAgICAgICAgICAgY2xlYXI9XCJDbGVhclwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWlucHV0LXByZWZpeFwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJwcmVmaXhUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwicHJlZml4VGVtcGxhdGU/LnRlbXBsYXRlUmVmXCI+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxpbnB1dCAjaW5wdXRcbiAgICAgICAgICAgIGNsYXNzPVwiay1pbnB1dC1pbm5lclwiXG4gICAgICAgICAgICBbaWRdPVwiZm9jdXNhYmxlSWRcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seVwiXG4gICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IHRhYmluZGV4XCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICBbYXR0ci5wbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJ0aXRsZVwiXG4gICAgICAgICAgICBbYXR0ci5tYXhsZW5ndGhdPVwibWF4bGVuZ3RoXCJcbiAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICBmb2N1czogaGFuZGxlSW5wdXRGb2N1cyxcbiAgICAgICAgICAgICAgICBibHVyOiBoYW5kbGVJbnB1dEJsdXIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGhhbmRsZUlucHV0fVwiXG4gICAgICAgIC8+XG4gICAgICAgIDxzcGFuXG4gICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzPVwiay1jbGVhci12YWx1ZVwiXG4gICAgICAgICAgICAqbmdJZj1cInNob3dDbGVhckJ1dHRvblwiXG4gICAgICAgICAgICAoY2xpY2spPVwiY2xlYXJWYWx1ZSgpXCJcbiAgICAgICAgICAgIChtb3VzZWRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgICAgW3RhYmluZGV4XT1cInRhYkluZGV4XCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY2xlYXJUaXRsZSgpXCJcbiAgICAgICAgICAgIFt0aXRsZV09XCJjbGVhclRpdGxlKClcIlxuICAgICAgICAgICAgKGtleWRvd24uZW50ZXIpPVwiY2xlYXJWYWx1ZSgkZXZlbnQpXCJcbiAgICAgICAgICAgIChrZXlkb3duLnNwYWNlKT1cImNsZWFyVmFsdWUoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIFtuZ0NsYXNzXT1cImNsZWFyQnV0dG9uQ2xhc3Nlc1wiPjwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8c3BhbiAqbmdJZj1cImhhc0Vycm9yc1wiIFtuZ0NsYXNzXT1cImVycm9ySWNvbkNsYXNzZXNcIj48L3NwYW4+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiaXNTdWNjZXNzZnVsXCIgW25nQ2xhc3NdPVwic3VjY2Vzc0ljb25DbGFzc2VzXCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImstaW5wdXQtc3VmZml4XCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAqbmdJZj1cInN1ZmZpeFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJzdWZmaXhUZW1wbGF0ZT8udGVtcGxhdGVSZWZcIj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvc3Bhbj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIEluamVjdG9yLFxuICAgICAgICBFbGVtZW50UmVmXSlcbl0sIFRleHRCb3hDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVGV4dEJveE1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGV4dEJveE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJjbGVhclwiLCB2b2lkIDApO1xuXG52YXIgVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzE7XG4vKipcbiAqIEN1c3RvbSBjb21wb25lbnQgbWVzc2FnZXMgb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnQgbWVzc2FnZXMuXG4gKi9cbmxldCBUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IGNsYXNzIFRleHRCb3hDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIFRleHRCb3hNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5UZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRleHRCb3hNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRleHRib3gtbWVzc2FnZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KTtcblxudmFyIExvY2FsaXplZFRleHRCb3hNZXNzYWdlc0RpcmVjdGl2ZV8xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBMb2NhbGl6ZWRUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmUgPSBMb2NhbGl6ZWRUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmVfMSA9IGNsYXNzIExvY2FsaXplZFRleHRCb3hNZXNzYWdlc0RpcmVjdGl2ZSBleHRlbmRzIFRleHRCb3hNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5Mb2NhbGl6ZWRUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmUgPSBMb2NhbGl6ZWRUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRleHRCb3hNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMb2NhbGl6ZWRUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmVfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RleHRCb3hMb2NhbGl6ZWRNZXNzYWdlc10nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIExvY2FsaXplZFRleHRCb3hNZXNzYWdlc0RpcmVjdGl2ZSk7XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgc2VwYXJhdG9yIGluIHRoZSBjb250ZW50IG9mIGNvbXBvbmVudHMgbGlrZSB0aGUgVGV4dEFyZWEgYW5kIHRoZSBUZXh0Qm94LiAoW3NlZSBleGFtcGxlc10oeyUgc2x1ZyBhZG9ybm1lbnRzX3RleHRib3ggJX0jdG9jLXNlcGFyYXRvcikpLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tdGV4dGJveD5cbiAqICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RleHRCb3hTdWZmaXhUZW1wbGF0ZT5cbiAqICAgICAgICA8a2VuZG8taW5wdXQtc2VwYXJhdG9yPjwva2VuZG8taW5wdXQtc2VwYXJhdG9yPlxuICogICAgICAgIDxidXR0b24ga2VuZG9CdXR0b24gbG9vaz1cImNsZWFyXCIgaWNvbj1cImltYWdlXCI+PC9idXR0b24+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tdGV4dGJveD5cbiAqIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge31cbiAqIGBgYFxuICovXG5sZXQgSW5wdXRTZXBhcmF0b3JDb21wb25lbnQgPSBjbGFzcyBJbnB1dFNlcGFyYXRvckNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIGEgc2VwYXJhdG9yIGluIHRoZSBjb250ZW50IG9mIGNvbXBvbmVudHMgbGlrZSB0aGUgVGV4dEFyZWEgYW5kIHRoZSBUZXh0Qm94LiAoW3NlZSBleGFtcGxlc10oeyUgc2x1ZyBhZG9ybm1lbnRzX3RleHRib3ggJX0jdG9jLXNlcGFyYXRvcikpLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHMtbm8tcnVuXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8a2VuZG8tdGV4dGJveD5cbiAgICAgKiAgICA8bmctdGVtcGxhdGUga2VuZG9UZXh0Qm94U3VmZml4VGVtcGxhdGU+XG4gICAgICogICAgICAgIDxrZW5kby1pbnB1dC1zZXBhcmF0b3I+PC9rZW5kby1pbnB1dC1zZXBhcmF0b3I+XG4gICAgICogICAgICAgIDxidXR0b24ga2VuZG9CdXR0b24gbG9vaz1cImNsZWFyXCIgaWNvbj1cImltYWdlXCI+PC9idXR0b24+XG4gICAgICogICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgPC9rZW5kby10ZXh0Ym94PlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7fVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWlucHV0LXNlcGFyYXRvcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgSW5wdXRTZXBhcmF0b3JDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc1wiLCB2b2lkIDApO1xuSW5wdXRTZXBhcmF0b3JDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWlucHV0LXNlcGFyYXRvciwga2VuZG8tdGV4dGJveC1zZXBhcmF0b3InLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KVxuXSwgSW5wdXRTZXBhcmF0b3JDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgU0hBUkVEX0RJUkVDVElWRVMgPSBbXG4gICAgSW5wdXRTZXBhcmF0b3JDb21wb25lbnQsXG4gICAgVGV4dEFyZWFEaXJlY3RpdmVcbl07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFNoYXJlZE1vZHVsZSA9IGNsYXNzIFNoYXJlZE1vZHVsZSB7XG59O1xuU2hhcmVkTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtTSEFSRURfRElSRUNUSVZFU10sXG4gICAgICAgIGV4cG9ydHM6IFtTSEFSRURfRElSRUNUSVZFU11cbiAgICB9KVxuXSwgU2hhcmVkTW9kdWxlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgVGV4dEJveCBkaXJlY3RpdmUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgVGV4dEJveCBtb2R1bGVcbiAqIGltcG9ydCB7IFRleHRCb3hNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBUZXh0Qm94TW9kdWxlXSwgLy8gaW1wb3J0IFRleHRCb3ggbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5sZXQgVGV4dEJveE1vZHVsZSA9IGNsYXNzIFRleHRCb3hNb2R1bGUge1xufTtcblRleHRCb3hNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgVGV4dEJveERpcmVjdGl2ZSxcbiAgICAgICAgICAgIFRleHRCb3hDb21wb25lbnQsXG4gICAgICAgICAgICBUZXh0Qm94U3VmZml4VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBUZXh0Qm94UHJlZml4VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICBMb2NhbGl6ZWRUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmVcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgVGV4dEJveERpcmVjdGl2ZSxcbiAgICAgICAgICAgIFRleHRCb3hDb21wb25lbnQsXG4gICAgICAgICAgICBUZXh0Qm94U3VmZml4VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBUZXh0Qm94UHJlZml4VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBFdmVudHNNb2R1bGUsXG4gICAgICAgICAgICBUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICBMb2NhbGl6ZWRUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmUsXG4gICAgICAgICAgICBTSEFSRURfRElSRUNUSVZFU1xuICAgICAgICBdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBFdmVudHNNb2R1bGUsIFNoYXJlZE1vZHVsZV1cbiAgICB9KVxuXSwgVGV4dEJveE1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBUZXh0RmllbGRzQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uU2VydmljZSwgbmdab25lLCBjaGFuZ2VEZXRlY3RvciwgcmVuZGVyZXIsIGluamVjdG9yLCBob3N0RWxlbWVudCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgYHRpdGxlYCBhdHRyaWJ1dGUgb2YgdGhlIGludGVybmFsIHRleHRhcmVhIGlucHV0IGVsZW1lbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGl0bGUgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBUZXh0QXJlYSBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIFRleHRBcmVhIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGVzIGEgdmFsdWUgZm9yIHRoZSBUZXh0QXJlYSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgd2hvbGUgdmFsdWUgd2lsbCBiZSBzZWxlY3RlZCB3aGVuIHRoZSBUZXh0QXJlYSBpcyBjbGlja2VkLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RPbkZvY3VzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgZm9jdXNlcyB0aGUgaW50ZXJuYWwgdGV4dGFyZWEgZWxlbWVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gZm9jdXNpbmcgdGhlIHRleHRhcmVhIGVsZW1lbnQgYW5kIGZvY3VzaW5nIG9uZSBvZiBpdHMgYWRvcm5tZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5wdXRGb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgaW50ZXJuYWwgdGV4dGFyZWEgZWxlbWVudCBnZXRzIGJsdXJyZWQuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgdXNlZnVsIHdoZW4gYWRvcm5tZW50cyBhcmUgdXNlZCwgaW4gb3JkZXIgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBibHVycmluZyB0aGUgdGV4dGFyZWEgZWxlbWVudCBhbmQgYmx1cnJpbmcgdGhlIHdob2xlIFRleHRBcmVhIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5wdXRCbHVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuX2lzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlSW5wdXRCbHVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5pbnB1dEJsdXIpIHx8IHJlcXVpcmVzWm9uZU9uQmx1cih0aGlzLmNvbnRyb2wpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1RvdWNoZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dEJsdXIuZW1pdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5nQ2hhbmdlID0gKF8pID0+IHsgfTtcbiAgICAgICAgdGhpcy5uZ1RvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXR1cyBvZiB0aGUgY29tcG9uZW50IGNoYW5nZXMgdG8gb3IgZnJvbSBgZGlzYWJsZWRgLlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgdmFsdWUsIGl0IGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGFwcHJvcHJpYXRlIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWRcbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGV4dEZpZWxkc0Jhc2UucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGV4dEZpZWxkc0Jhc2UucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGV4dEZpZWxkc0Jhc2UucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUZXh0RmllbGRzQmFzZS5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUZXh0RmllbGRzQmFzZS5wcm90b3R5cGUsIFwic2VsZWN0T25Gb2N1c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGV4dEZpZWxkc0Jhc2UucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVGV4dEZpZWxkc0Jhc2UucHJvdG90eXBlLCBcImlucHV0Rm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUZXh0RmllbGRzQmFzZS5wcm90b3R5cGUsIFwiaW5wdXRCbHVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2lucHV0JywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBUZXh0RmllbGRzQmFzZS5wcm90b3R5cGUsIFwiaW5wdXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRleHRGaWVsZHNCYXNlLnByb3RvdHlwZSwgXCJkaXNhYmxlZENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRleHRGaWVsZHNCYXNlLnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcblxudmFyIFRleHRBcmVhQ29tcG9uZW50XzE7XG5jb25zdCByZXNpemVDbGFzc2VzID0ge1xuICAgICd2ZXJ0aWNhbCc6ICdrLXJlc2l6ZS12ZXJ0aWNhbCcsXG4gICAgJ2hvcml6b250YWwnOiAnay1yZXNpemUtaG9yaXpvbnRhbCcsXG4gICAgJ2JvdGgnOiAnay1yZXNpemUtYm90aCcsXG4gICAgJ25vbmUnOiAnay1yZXNpemUtbm9uZScsXG4gICAgJ2F1dG8nOiAnay1yZXNpemUtbm9uZSdcbn07XG5jb25zdCBGT0NVU0VEJDQgPSAnay1mb2N1cyc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBUZXh0QXJlYSBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfdGV4dGFyZWEgJX0pLlxuICovXG5sZXQgVGV4dEFyZWFDb21wb25lbnQgPSBUZXh0QXJlYUNvbXBvbmVudF8xID0gY2xhc3MgVGV4dEFyZWFDb21wb25lbnQgZXh0ZW5kcyBUZXh0RmllbGRzQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uU2VydmljZSwgbmdab25lLCBjaGFuZ2VEZXRlY3RvciwgcmVuZGVyZXIsIGluamVjdG9yLCBob3N0RWxlbWVudCkge1xuICAgICAgICBzdXBlcihsb2NhbGl6YXRpb25TZXJ2aWNlLCBuZ1pvbmUsIGNoYW5nZURldGVjdG9yLCByZW5kZXJlciwgaW5qZWN0b3IsIGhvc3RFbGVtZW50KTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNhYmxlSWQgPSBgay0ke2d1aWQoKX1gO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgZmxvdyBkaXJlY3Rpb24gb2YgdGhlIFRleHRBcmVhIHNlY3Rpb25zLiBUaGlzIHByb3BlcnR5IGlzIHVzZWZ1bCB3aGVuIGFkb3JubWVudHMgYXJlIHVzZWQsIGluIG9yZGVyIHRvIHNwZWNpZnlcbiAgICAgICAgICogdGhlaXIgcG9zaXRpb24gaW4gcmVsYXRpb24gdG8gdGhlIHRleHRhcmVhIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIGB2ZXJ0aWNhbGAoRGVmYXVsdCkgJm1kYXNoO1RleHRBcmVhIHNlY3Rpb25zIGFyZSBwbGFjZWQgZnJvbSB0b3AgdG8gYm90dG9tLlxuICAgICAgICAgKiAqIGBob3Jpem9udGFsYCZtZGFzaDtUZXh0QXJlYSBzZWN0aW9ucyBhcmUgcGxhY2VkIGZyb20gbGVmdCB0byByaWdodCBpbiBgbHRyYCwgYW5kIGZyb20gcmlnaHQgdG8gbGVmdCBpbiBgcnRsYCBtb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbG93ID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgW3RhYmluZGV4XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4KSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJpbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmVzIHRoZSByZXNpemUgYmVoYXZpb3Igb2YgdGhlIFRleHRBcmVhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiBgdmVydGljYWxgKERlZmF1bHQpJm1kYXNoO1RoZSBUZXh0QXJlYSBjb21wb25lbnQgY2FuIGJlIHJlc2l6ZWQgb25seSB2ZXJ0aWNhbGx5LlxuICAgICAgICAgKiAqIGBob3Jpem9udGFsYCZtZGFzaDtUaGUgVGV4dEFyZWEgY29tcG9uZW50IGNhbiBiZSByZXNpemVkIG9ubHkgaG9yaXpvbnRhbGx5LlxuICAgICAgICAgKiAqIGBib3RoYCZtZGFzaDtUaGUgVGV4dEFyZWEgY29tcG9uZW50IGNhbiBiZSByZXNpemVkIGluIGJvdGggKGhvcml6b250YWwgYW5kIHZlcnRpY2FsKSBkaXJlY3Rpb25zLlxuICAgICAgICAgKiAqIGBhdXRvYCZtZGFzaDtTcGVjaWZpZXMgd2hldGhlciB0aGUgVGV4dEFyZWEgY29tcG9uZW50IHdpbGwgYWRqdXN0IGl0cyBoZWlnaHQgYXV0b21hdGljYWxseSwgYmFzZWQgb24gdGhlIGNvbnRlbnQuXG4gICAgICAgICAqICogYG5vbmVgJm1kYXNoO1RoZSBUZXh0QXJlYSBjYW5ub3QgYmUgcmVzaXplZC5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXphYmxlID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBmb2N1c2VzIHRoZSBUZXh0QXJlYSBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25Gb2N1c2AgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLXRleHRhcmVhIChmb2N1cyk9XCJoYW5kbGVGb2N1cygpXCI+PC9rZW5kby10ZXh0YXJlYT5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAgICAgKiAgIHB1YmxpYyBoYW5kbGVGb2N1cygpOiB2b2lkIHtcbiAgICAgICAgICogICAgICBjb25zb2xlLmxvZygnQ29tcG9uZW50IGlzIGZvY3VzZWQnKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIFRleHRBcmVhIGNvbXBvbmVudCBnZXRzIGJsdXJyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25CbHVyYCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogX0BDb21wb25lbnQoe1xuICAgICAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICAgICAqICA8a2VuZG8tdGV4dGFyZWEgKGJsdXIpPVwiaGFuZGxlQmx1cigpXCI+PC9rZW5kby10ZXh0YXJlYT5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAgICAgKiAgIHB1YmxpYyBoYW5kbGVCbHVyKCk6IHZvaWQge1xuICAgICAgICAgKiAgICAgIGNvbnNvbGUubG9nKCdDb21wb25lbnQgaXMgYmx1cnJlZCcpO1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CbHVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkIG9yIHRoZSBjb21wb25lbnQgaXMgYmx1cnJlZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X3RleHRhcmVhICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICogV2hlbiB0aGUgY29tcG9uZW50IHZhbHVlIGlzIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseSBvciB2aWEgaXRzIGZvcm0gY29udHJvbCBiaW5kaW5nLCB0aGUgdmFsdWVDaGFuZ2UgZXZlbnQgaXMgbm90IGVtaXR0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9zaXplID0gJ21lZGl1bSc7XG4gICAgICAgIHRoaXMuX3JvdW5kZWQgPSAnbWVkaXVtJztcbiAgICAgICAgdGhpcy5fZmlsbE1vZGUgPSAnc29saWQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVJbnB1dCA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IGluY29taW5nVmFsdWUgPSBldi50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKGluY29taW5nVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlSW5wdXRGb2N1cyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdE9uRm9jdXMgJiYgdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuc2VsZWN0QWxsKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uRm9jdXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5pbnB1dEZvY3VzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Rm9jdXMuZW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBsb2NhbGl6YXRpb25TZXJ2aWNlLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuICAgIGdldCBmbG93Q29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93ID09PSAndmVydGljYWwnO1xuICAgIH1cbiAgICBnZXQgZmxvd1JvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvdyA9PT0gJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IHRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNpemUgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBwYWRkaW5nIG9mIHRoZSBpbnRlcm5hbCB0ZXh0YXJlYSBlbGVtZW50XG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcHBlYXJhbmNlX3RleHRhcmVhICV9I3RvYy1zaXplKSkuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGAnc21hbGwnYFxuICAgICAqICogYCdtZWRpdW0nYCAoZGVmYXVsdClcbiAgICAgKiAqIGAnbGFyZ2UnYFxuICAgICAqICogYG51bGxgXG4gICAgICovXG4gICAgc2V0IHNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUNsYXNzZXMoc2l6ZSwgJ3NpemUnKTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJvdW5kZWQgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBib3JkZXIgcmFkaXVzIG9mIHRoZSBUZXh0QXJlYVxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBwZWFyYW5jZV90ZXh0YXJlYSAlfSN0b2Mtcm91bmRlZCkpLlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgJ3NtYWxsJ2BcbiAgICAgKiAqIGAnbWVkaXVtJ2AgKGRlZmF1bHQpXG4gICAgICogKiBgJ2xhcmdlJ2BcbiAgICAgKiAqIGBudWxsYFxuICAgICAqL1xuICAgIHNldCByb3VuZGVkKHJvdW5kZWQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGFzc2VzKHJvdW5kZWQsICdyb3VuZGVkJyk7XG4gICAgICAgIHRoaXMuX3JvdW5kZWQgPSByb3VuZGVkO1xuICAgIH1cbiAgICBnZXQgcm91bmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdW5kZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaWxsTW9kZSBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIGJhY2tncm91bmQgYW5kIGJvcmRlciBzdHlsZXMgb2YgdGhlIFRleHRBcmVhXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcHBlYXJhbmNlX3RleHRhcmVhICV9I3RvYy1maWxsTW9kZSkpLlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgJ2ZsYXQnYFxuICAgICAqICogYCdzb2xpZCdgIChkZWZhdWx0KVxuICAgICAqICogYCdvdXRsaW5lJ2BcbiAgICAgKiAqIGBudWxsYFxuICAgICAqL1xuICAgIHNldCBmaWxsTW9kZShmaWxsTW9kZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUNsYXNzZXMoZmlsbE1vZGUsICdmaWxsTW9kZScpO1xuICAgICAgICB0aGlzLl9maWxsTW9kZSA9IGZpbGxNb2RlO1xuICAgIH1cbiAgICBnZXQgZmlsbE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsTW9kZTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IGN1cnNvckluc2lkZVdyYXBwZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRhYmJpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgLy8gZm9jdXNJbiBhbmQgZm9jdXNPdXQgYXJlIHJlbGF0aXZlIHRvIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1c2luJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1c291dCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YWJiaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RUZXh0Ym94ID0gY2xvc2VzdCQxKGFyZ3MucmVsYXRlZFRhcmdldCwgKGVsZW1lbnQpID0+IGVsZW1lbnQgPT09IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VzdFRleHRib3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhYmJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29ySW5zaWRlV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVCbHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucmVuZGVyZXIubGlzdGVuKGhvc3RFbGVtZW50LCAnbW91c2VlbnRlcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjdXJzb3JJbnNpZGVXcmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdtb3VzZWxlYXZlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnNvckluc2lkZVdyYXBwZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdrZXlkb3duJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5rZXlDb2RlID09PSBLZXlzLlRhYikge1xuICAgICAgICAgICAgICAgICAgICB0YWJiaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZsb3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN0eWxpbmdJbnB1dHMgPSBbJ3NpemUnLCAncm91bmRlZCcsICdmaWxsTW9kZSddO1xuICAgICAgICBzdHlsaW5nSW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGFzc2VzKHRoaXNbaW5wdXRdLCBpbnB1dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gdGhpcy5pbmplY3Rvci5nZXQoTmdDb250cm9sLCBudWxsKTtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRBdmFpbGFibGUoKSAmJiB0aGlzLnJlc2l6YWJsZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVN1YnNjcmlwdGlvbiA9IGZyb21FdmVudCh3aW5kb3csICdyZXNpemUnKVxuICAgICAgICAgICAgICAgIC5waXBlKChkZWJvdW5jZVRpbWUoNTApKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVzaXplKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIFwidGFiaW5kZXhcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGhvc3RFbGVtZW50ID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAoY2hhbmdlcy5mbG93KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZsb3coKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc2l6YWJsZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50LCAnXFwhay1vdmVyZmxvdy15LWF1dG8nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgJ1xcIWstb3ZlcmZsb3cteS1hdXRvJyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmluaXRpYWxIZWlnaHR9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLmNvbHMpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY2hhbmdlcy5jb2xzLmN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGhvc3RFbGVtZW50LCAnd2lkdGgnLCAnYXV0bycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVTdHlsZShob3N0RWxlbWVudCwgJ3dpZHRoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMubmdDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghYXJlU2FtZSh0aGlzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMubmdDaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5yZXNpemVTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCByZXNpemFibGVDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHJlc2l6ZUNsYXNzZXNbdGhpcy5yZXNpemFibGVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBUZXh0QXJlYSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8YnV0dG9uIChjbGljayk9XCJ0ZXh0YXJlYS5mb2N1cygpXCI+Rm9jdXMgdGhlIHRleHRhcmVhPC9idXR0b24+XG4gICAgICogIDxrZW5kby10ZXh0YXJlYSAjdGV4dGFyZWE+PC9rZW5kby10ZXh0YXJlYT5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgVGV4dEFyZWEgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGlzRm9jdXNlZEVsZW1lbnQgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignOmZvY3VzJyk7XG4gICAgICAgIGlmIChpc0ZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBpc0ZvY3VzZWRFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemFibGUgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWxlbWVudCwgJ2hlaWdodCcsIGAke3RoaXMuaW5pdGlhbEhlaWdodH1weGApO1xuICAgICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAgICAgaWYgKHNjcm9sbEhlaWdodCA+IHRoaXMuaW5pdGlhbEhlaWdodCkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtzY3JvbGxIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0ZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0ZvY3VzZWQ7XG4gICAgfVxuICAgIHNldCBpc0ZvY3VzZWQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRm9jdXNlZCAhPT0gdmFsdWUgJiYgdGhpcy5ob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgRk9DVVNFRCQ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgRk9DVVNFRCQ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lzRm9jdXNlZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUJsdXIoKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIGludm9rZUVsZW1lbnRNZXRob2QodGhpcy5pbnB1dCwgJ3NldFNlbGVjdGlvblJhbmdlJywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0QWxsKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oMCwgdGhpcy52YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNsYXNzZXModmFsdWUsIGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBnZXRTdHlsaW5nQ2xhc3NlcygnaW5wdXQnLCBpbnB1dCwgdGhpc1tpbnB1dF0sIHZhbHVlKTtcbiAgICAgICAgaWYgKGNsYXNzZXMudG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbSwgY2xhc3Nlcy50b1JlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzZXMudG9BZGQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbSwgY2xhc3Nlcy50b0FkZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRmxvdygpIHtcbiAgICAgICAgY29uc3QgaXNWZXJ0aWNhbCA9IHRoaXMuZmxvdyA9PT0gJ3ZlcnRpY2FsJztcbiAgICAgICAgY29uc3QgaG9zdEVsZW1lbnQgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGhvc3RFbGVtZW50LmNoaWxkcmVuWzFdO1xuICAgICAgICB0aGlzLnJlbmRlcmVyW2lzVmVydGljYWwgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oZWxlbWVudCwgJ1xcIWstZmxleC1ub25lJyk7XG4gICAgICAgIGlmIChzdWZmaXgpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJbaXNWZXJ0aWNhbCA/ICdyZW1vdmVDbGFzcycgOiAnYWRkQ2xhc3MnXShzdWZmaXgsICdcXCFrLWFsaWduLWl0ZW1zLXN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGV4dEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImZvY3VzYWJsZUlkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay10ZXh0YXJlYScpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWlucHV0JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUZXh0QXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5cXCFrLWZsZXgtY29sJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRleHRBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmbG93Q29sXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLlxcIWstZmxleC1yb3cnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVGV4dEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImZsb3dSb3dcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUZXh0QXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmxvd1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVGV4dEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcInJvd3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFRleHRBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBUZXh0QXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4bGVuZ3RoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBUZXh0QXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgVGV4dEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGV4dEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBUZXh0QXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgVGV4dEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIFRleHRBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsTW9kZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnZm9jdXMnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVGV4dEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnYmx1cicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUZXh0QXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25CbHVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVGV4dEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5UZXh0QXJlYUNvbXBvbmVudCA9IFRleHRBcmVhQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvVGV4dEFyZWEnLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7IHByb3ZpZGU6IEwxME5fUFJFRklYLCB1c2VWYWx1ZTogJ2tlbmRvLnRleHRhcmVhJyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRleHRBcmVhQ29tcG9uZW50XzEpLFxuICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBLZW5kb0lucHV0LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUZXh0QXJlYUNvbXBvbmVudF8xKSB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdGV4dGFyZWEnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICNpbnB1dFxuICAgICAgICAgICAgW2F0dHIuYXJpYS1tdWx0aWxpbmVdPVwidHJ1ZVwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cImRpc2FibGVkID8gdHJ1ZSA6IHVuZGVmaW5lZFwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLXJlYWRvbmx5XT1cInJlYWRvbmx5ID8gdHJ1ZSA6IHVuZGVmaW5lZFwiXG4gICAgICAgICAgICBjbGFzcz1cImstaW5wdXQtaW5uZXJcIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwicmVzaXphYmxlQ2xhc3NcIlxuICAgICAgICAgICAgW2lkXT1cImZvY3VzYWJsZUlkXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICBbYXR0ci5wbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgIFthdHRyLnJvd3NdPVwicm93c1wiXG4gICAgICAgICAgICBbYXR0ci5jb2xzXT1cImNvbHNcIlxuICAgICAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwidGFiSW5kZXhcIlxuICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwidGl0bGVcIlxuICAgICAgICAgICAgW2F0dHIubWF4bGVuZ3RoXT1cIm1heGxlbmd0aFwiXG4gICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgZm9jdXM6IGhhbmRsZUlucHV0Rm9jdXMsXG4gICAgICAgICAgICAgICAgYmx1cjogaGFuZGxlSW5wdXRCbHVyLFxuICAgICAgICAgICAgICAgIGlucHV0OiBoYW5kbGVJbnB1dH1cIj5cbiAgICAgICAgICAgIDwvdGV4dGFyZWE+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJrZW5kby10ZXh0YXJlYS1zdWZmaXhcIj48L25nLWNvbnRlbnQ+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgTmdab25lLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBJbmplY3RvcixcbiAgICAgICAgRWxlbWVudFJlZl0pXG5dLCBUZXh0QXJlYUNvbXBvbmVudCk7XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhZG9ybm1lbnRzIGluIHRoZSBzdWZmaXggY29udGFpbmVyIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdGV4dGFyZWFfYWRvcm5tZW50cyAlfSkpLlxuICogYGBgdHMtbm8tcnVuXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby10ZXh0YXJlYT5cbiAqICAgIDxrZW5kby10ZXh0YXJlYS1zdWZmaXg+XG4gKiAgICAgICAgPGJ1dHRvbiBrZW5kb0J1dHRvbiBsb29rPVwiY2xlYXJcIiBpY29uPVwiaW1hZ2VcIj48L2J1dHRvbj5cbiAqICAgIDwva2VuZG8tdGV4dGFyZWEtc3VmZml4PlxuICogIDwva2VuZG8tdGV4dGFyZWE+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHt9XG4gKiBgYGBcbiAqL1xubGV0IFRleHRBcmVhU3VmZml4Q29tcG9uZW50ID0gY2xhc3MgVGV4dEFyZWFTdWZmaXhDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgYWRvcm5tZW50cyBpbiB0aGUgc3VmZml4IGNvbnRhaW5lciAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRleHRhcmVhX2Fkb3JubWVudHMgJX0pKS5cbiAgICAgKiBgYGB0cy1uby1ydW5cbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxrZW5kby10ZXh0YXJlYT5cbiAgICAgKiAgICA8a2VuZG8tdGV4dGFyZWEtc3VmZml4PlxuICAgICAqICAgICAgICA8YnV0dG9uIGtlbmRvQnV0dG9uIGxvb2s9XCJjbGVhclwiIGljb249XCJpbWFnZVwiPjwvYnV0dG9uPlxuICAgICAqICAgIDwva2VuZG8tdGV4dGFyZWEtc3VmZml4PlxuICAgICAqICA8L2tlbmRvLXRleHRhcmVhPlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7fVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWlucHV0LXN1ZmZpeCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGV4dEFyZWFTdWZmaXhDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc1wiLCB2b2lkIDApO1xuVGV4dEFyZWFTdWZmaXhDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvVGV4dEFyZWFTdWZmaXgnLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRleHRhcmVhLXN1ZmZpeCcsXG4gICAgICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PmBcbiAgICB9KVxuXSwgVGV4dEFyZWFTdWZmaXhDb21wb25lbnQpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBUZXh0QXJlYSBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgVGV4dEFyZWEgbW9kdWxlXG4gKiBpbXBvcnQgeyBUZXh0QXJlYU1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWlucHV0cyc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIFRleHRBcmVhTW9kdWxlXSwgLy8gaW1wb3J0IFRleHRBcmVhIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xubGV0IFRleHRBcmVhTW9kdWxlID0gY2xhc3MgVGV4dEFyZWFNb2R1bGUge1xufTtcblRleHRBcmVhTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIFRleHRBcmVhQ29tcG9uZW50LFxuICAgICAgICAgICAgVGV4dEFyZWFTdWZmaXhDb21wb25lbnRcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgVGV4dEFyZWFDb21wb25lbnQsXG4gICAgICAgICAgICBFdmVudHNNb2R1bGUsXG4gICAgICAgICAgICBUZXh0QXJlYVN1ZmZpeENvbXBvbmVudCxcbiAgICAgICAgICAgIFNIQVJFRF9ESVJFQ1RJVkVTXG4gICAgICAgIF0sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEV2ZW50c01vZHVsZSwgU2hhcmVkTW9kdWxlXVxuICAgIH0pXG5dLCBUZXh0QXJlYU1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ29sb3JQaWNrZXJMb2NhbGl6YXRpb25TZXJ2aWNlID0gY2xhc3MgQ29sb3JQaWNrZXJMb2NhbGl6YXRpb25TZXJ2aWNlIGV4dGVuZHMgTG9jYWxpemF0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocHJlZml4LCBtZXNzYWdlU2VydmljZSwgX3J0bCkge1xuICAgICAgICBzdXBlcihwcmVmaXgsIG1lc3NhZ2VTZXJ2aWNlLCBfcnRsKTtcbiAgICB9XG59O1xuQ29sb3JQaWNrZXJMb2NhbGl6YXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBJbmplY3QoTDEwTl9QUkVGSVgpKSxcbiAgICBfX3BhcmFtKDEsIE9wdGlvbmFsKCkpLFxuICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMiwgSW5qZWN0KFJUTCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nLCBNZXNzYWdlU2VydmljZSwgQm9vbGVhbl0pXG5dLCBDb2xvclBpY2tlckxvY2FsaXphdGlvblNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEZsYXRDb2xvclBpY2tlckxvY2FsaXphdGlvblNlcnZpY2UgPSBjbGFzcyBGbGF0Q29sb3JQaWNrZXJMb2NhbGl6YXRpb25TZXJ2aWNlIGV4dGVuZHMgTG9jYWxpemF0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocHJlZml4LCBtZXNzYWdlU2VydmljZSwgX3J0bCwgY29sb3JQaWNrZXJMb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIocHJlZml4LCBtZXNzYWdlU2VydmljZSwgX3J0bCk7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJMb2NhbGl6YXRpb24gPSBjb2xvclBpY2tlckxvY2FsaXphdGlvbjtcbiAgICB9XG4gICAgZ2V0KHNob3J0S2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbG9yUGlja2VyTG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvclBpY2tlckxvY2FsaXphdGlvbi5nZXQoc2hvcnRLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoc2hvcnRLZXkpO1xuICAgIH1cbn07XG5GbGF0Q29sb3JQaWNrZXJMb2NhbGl6YXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBJbmplY3QoTDEwTl9QUkVGSVgpKSxcbiAgICBfX3BhcmFtKDEsIE9wdGlvbmFsKCkpLFxuICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMiwgSW5qZWN0KFJUTCkpLFxuICAgIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgSW5qZWN0KENvbG9yUGlja2VyTG9jYWxpemF0aW9uU2VydmljZSkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nLCBNZXNzYWdlU2VydmljZSwgQm9vbGVhbiwgQ29sb3JQaWNrZXJMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIEZsYXRDb2xvclBpY2tlckxvY2FsaXphdGlvblNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgREVGQVVMVF9PVVRQVVRfRk9STUFUID0gJ3JnYmEnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IERFRkFVTFRfR1JBRElFTlRfQkFDS0dST1VORF9DT0xPUiA9ICdyZ2JhKDI1NSwgMCwgMCwgMSknO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IERSQUdIQU5ETEVfTU9WRV9TUEVFRCA9IDU7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgQUFBX1JBVElPID0gNy4wO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEFBX1JBVElPID0gNC41O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IERFRkFVTFRfUFJFU0VUID0gJ29mZmljZSc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgREVGQVVMVF9BQ0NFU1NJQkxFX1BSRVNFVCA9ICdhY2Nlc3NpYmxlJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBTVEVQX0NPVU5UID0gMTY7XG5cbi8vIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aFxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFBBTEVUVEVQUkVTRVRTID0ge1xuICAgIGJhc2ljOiB7XG4gICAgICAgIGNvbG9yczogJzAwMDAwMCw3ZjdmN2YsODgwMDE1LGVkMWMyNCxmZjdmMjcsZmZmMjAwLDIyYjE0YywwMGEyZTgsM2Y0OGNjLGEzNDlhNCxmZmZmZmYsYzNjM2MzLGI5N2E1NyxmZmFlYzksZmZjOTBlLGVmZTRiMCxiNWU2MWQsOTlkOWVhLDcwOTJiZSxjOGJmZTcnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgb2ZmaWNlOiB7XG4gICAgICAgIGNvbG9yczogJ2ZmZmZmZiwgMDAwMDAwLCBlNmU2ZTYsIDQzNTU2OSwgNDM3MWM0LCBlZDdlMzIsIGE1YTRhNSwgZmViZjA0LCA1YTliZDUsIDcxYWU0OCwgZjJmMmYzLCA3ZjdmN2YsIGQxY2VjZSwgZDVkZGUzLCBkYWUxZjQsIGZjZTVkNCwgZGVlZGVkLCBmZmYyY2MsIGRlZWFmNiwgZTFlZmQ5LCBkN2Q4ZDgsIDU4NTk1OSwgYWVhYmFiLCBhZGJhY2EsIGI0YzVlNywgZjZjYWFjLCBkYmRiZGIsIGZmZTQ5OCwgYmNkNmVlLCBjNWUwYjIsIGJmYmZjMCwgM2YzZjNmLCA3NjcwNzAsIDg1OTViMSwgOGZhYmRiLCBmNWIxODMsIGM5YzhjOSwgZmVkOTY1LCA5YmM0ZTUsIGE4ZDA4ZCwgYTVhNWE2LCAyNjI2MjUsIDM5MzkzOSwgMzM0MDUwLCAyZTU0OTYsIGM0NWExMSwgN2I3YjdhLCBiZjkwMDAsIDJmNzViNSwgNTQ4MjM1LCA3ZjdmN2YsIDBiMGMwYywgMTYxNjE2LCAyMjJhMzQsIDIwMzc2NCwgODQzZDBiLCA1MjUyNTIsIDdmNjAwMCwgMWQ0ZDc5LCAzNzU2MjMnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgYXBleDoge1xuICAgICAgICBjb2xvcnM6ICdmZmZmZmYsIDAwMDAwMCwgYzljMmQxLCA2OTY3NmQsIGNlYjk2NiwgOWNiMDg0LCA2YmIxYzksIDY1ODVjZiwgN2U2YmM5LCBhMzc5YmIsIGYyZjJmMiwgN2Y3ZjdmLCBmNGYyZjUsIGUwZTBlMiwgZjVmMWUwLCBlYmVmZTYsIGUxZWZmNCwgZTBlNmY1LCBlNWUxZjQsIGVjZTRmMSwgZDhkOGQ4LCA1OTU5NTksIGU5ZTZlYywgYzJjMWM1LCBlYmUzYzEsIGQ3ZGZjZCwgYzNkZmU5LCBjMWNlZWIsIGNiYzNlOSwgZGFjOWUzLCBiZmJmYmYsIDNmM2YzZiwgZGVkYWUzLCBhNGEzYTgsIGUxZDVhMywgYzNjZmI1LCBhNmQwZGUsIGEyYjVlMiwgYjFhNmRlLCBjN2FlZDYsIGE1YTVhNSwgMjYyNjI2LCA5Njg4YTUsIDRlNGQ1MSwgYWU5NjM4LCA3NThjNWEsIDNkOGRhOSwgMzY1YmIwLCA1MzNkYTksIDdkNGQ5OSwgN2Y3ZjdmLCAwYzBjMGMsIDYzNTY3MiwgMzQzMzM2LCA3NDY0MjUsIDRlNWQzYywgMjk1ZTcwLCAyNDNjNzUsIDM3Mjk3MCwgNTMzMzY2JyxcbiAgICAgICAgY29sdW1uczogMTBcbiAgICB9LFxuICAgIGF1c3Rpbjoge1xuICAgICAgICBjb2xvcnM6ICdmZmZmZmYsIDAwMDAwMCwgY2FmMjc4LCAzZTNkMmQsIDk0YzYwMCwgNzE2ODVhLCBmZjY3MDAsIDkwOTQ2NSwgOTU2YjQzLCBmZWEwMjIsIGYyZjJmMiwgN2Y3ZjdmLCBmNGZjZTQsIGRkZGNkMCwgZWZmZmMwLCBlM2UxZGMsIGZmZTBjYiwgZThlOWRmLCBlY2UxZDYsIGZlZWNkMiwgZDhkOGQ4LCA1OTU5NTksIGU5ZjljOSwgYmJiOWExLCBkZmZmODIsIGM4YzNiYSwgZmZjMjk5LCBkMmQ0YzAsIGRhYzNhZCwgZmVkOWE2LCBiZmJmYmYsIDNmM2YzZiwgZGZmN2FlLCBhZGE1OTgsIGNmZmY0MywgYWRhNTk4LCBmZmEzNjUsIGJjYmZhMSwgYzhhNTg1LCBmZWM2N2EsIGE1YTVhNSwgMjYyNjI2LCBhOWVhMjUsIDJlMmQyMSwgNmY5NDAwLCA1NDRlNDMsIGJmNGQwMCwgNmM2ZjRiLCA2ZjUwMzIsIGQ3N2IwMCwgN2Y3ZjdmLCAwYzBjMGMsIDc0YTUwZiwgMWYxZTE2LCA0YTYzMDAsIDM4MzQyZCwgN2YzMzAwLCA0ODRhMzIsIDRhMzUyMSwgOGY1MjAwJyxcbiAgICAgICAgY29sdW1uczogMTBcbiAgICB9LFxuICAgIGNsYXJpdHk6IHtcbiAgICAgICAgY29sb3JzOiAnZmZmZmZmLCAyOTI5MzQsIGYzZjJkYywgZDI1MzNjLCA5M2EyOTksIGFkOGY2NywgNzI2MDU2LCA0YzVhNmEsIDgwOGRhMCwgNzk0NjNkLCBmMmYyZjIsIGU3ZTdlYywgZTdlNWI5LCBmNmRjZDgsIGU5ZWNlYSwgZWVlOGUwLCBlNGRlZGIsIGQ4ZGRlMywgZTVlOGVjLCBlOWQ2ZDMsIGQ4ZDhkOCwgYzRjNGQxLCBkNWQxODUsIGVkYmFiMSwgZDNkOWQ2LCBkZWQyYzIsIGM5YmViOCwgYjJiY2M4LCBjY2QxZDksIGQzYWVhNywgYmZiZmJmLCA4YThhYTMsIGFjYTczYiwgZTQ5NzhhLCBiZWM3YzEsIGNkYmJhMywgYWY5ZTk0LCA4YzliYWMsIGIyYmFjNiwgYmQ4NTdjLCBhNWE1YTUsIDU2NTY2ZSwgNTY1MzFkLCBhNDM5MjUsIDZiN2M3MiwgODY2YjQ4LCA1NTQ4NDAsIDM5NDM0ZiwgNWM2OTdiLCA1YTM0MmQsIDdmN2Y3ZiwgM2IzYjRiLCAyMjIxMGIsIDZkMjYxOSwgNDc1MzRjLCA1OTQ3MzAsIDM5MzAyYiwgMjYyZDM1LCAzZDQ2NTIsIDNjMjMxZScsXG4gICAgICAgIGNvbHVtbnM6IDEwXG4gICAgfSxcbiAgICBzbGlwc3RyZWFtOiB7XG4gICAgICAgIGNvbG9yczogJ2ZmZmZmZiwgMDAwMDAwLCBiNGRjZmEsIDIxMjc0NSwgNGU2N2M4LCA1ZWNjZjMsIGE3ZWE1MiwgNWRjZWFmLCBmZjgwMjEsIGYxNDEyNCwgZjJmMmYyLCA3ZjdmN2YsIDhiYzlmNywgYzdjY2U0LCBkYmUwZjQsIGRlZjRmYywgZWRmYWRjLCBkZWY1ZWYsIGZmZTVkMiwgZmNkOWQzLCBkOGQ4ZDgsIDU5NTk1OSwgNGZhY2YzLCA5MDlhY2EsIGI4YzJlOSwgYmVlYWZhLCBkYmY2YjksIGJlZWJkZiwgZmZjY2E2LCBmOWIzYTcsIGJmYmZiZiwgM2YzZjNmLCAwZDc4YzksIDU5NjdhZiwgOTRhM2RlLCA5ZWUwZjcsIGNhZjI5NywgOWRlMWNmLCBmZmIyNzksIGY2OGQ3YiwgYTVhNWE1LCAyNjI2MjYsIDA2M2M2NCwgMTgxZDMzLCAzMTQ3OWYsIDExYjJlYiwgODFkMzE5LCAzNGFjOGIsIGQ4NWMwMCwgYzMyNjBjLCA3ZjdmN2YsIDBjMGMwYywgMDIxODI4LCAxMDEzMjIsIDIwMmY2YSwgMGI3NjljLCA1NjhjMTEsIDIyNzI1YywgOTAzZDAwLCA4MjE5MDgnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgbWV0cm86IHtcbiAgICAgICAgY29sb3JzOiAnZmZmZmZmLCAwMDAwMDAsIGQ2ZWNmZiwgNGU1YjZmLCA3ZmQxM2IsIGVhMTU3YSwgZmViODBhLCAwMGFkZGMsIDczOGFjOCwgMWFiMzlmLCBmMmYyZjIsIDdmN2Y3ZiwgYTdkNmZmLCBkOWRkZTQsIGU1ZjVkNywgZmFkMGU0LCBmZWYwY2QsIGM1ZjJmZiwgZTJlN2Y0LCBjOWY3ZjEsIGQ4ZDhkOCwgNTk1OTU5LCA2MGI1ZmYsIGIzYmNjYSwgY2JlY2IwLCBmNmExYzksIGZlZTI5YywgOGJlNmZmLCBjN2QwZTksIDk0ZWZlMywgYmZiZmJmLCAzZjNmM2YsIDAwN2RlYSwgOGQ5YmFmLCBiMmUzODksIGYyNzJhZiwgZmVkNDZiLCA1MWQ5ZmYsIGFhYjhkZSwgNWZlN2Q1LCBhNWE1YTUsIDI2MjYyNiwgMDAzZTc1LCAzYTQ0NTMsIDVlYTIyNiwgYWYwZjViLCBjNThjMDAsIDAwODFhNSwgNDI1ZWE5LCAxMzg2NzcsIDdmN2Y3ZiwgMGMwYzBjLCAwMDE5MmUsIDI3MmQzNywgM2Y2YzE5LCA3NTBhM2QsIDgzNWQwMCwgMDA1NjZlLCAyYzNmNzEsIDBjNTk0ZicsXG4gICAgICAgIGNvbHVtbnM6IDEwXG4gICAgfSxcbiAgICBmbG93OiB7XG4gICAgICAgIGNvbG9yczogJ2ZmZmZmZiwgMDAwMDAwLCBkYmY1ZjksIDA0NjE3YiwgMGY2ZmM2LCAwMDlkZDksIDBiZDBkOSwgMTBjZjliLCA3Y2NhNjIsIGE1YzI0OSwgZjJmMmYyLCA3ZjdmN2YsIGIyZTlmMiwgYjRlY2ZjLCBjN2UyZmEsIGM0ZWVmZiwgYzlmYWZjLCBjOWZhZWQsIGU0ZjRkZiwgZWRmMmRhLCBkOGQ4ZDgsIDU5NTk1OSwgNzZkOWU4LCA2YWRhZmEsIDkwYzZmNiwgODlkZWZmLCA5M2Y1ZjksIDk0ZjZkYiwgY2FlOWMwLCBkYmU2YjYsIGJmYmZiZiwgM2YzZjNmLCAyMWIyYzgsIDIwYzhmNywgNTlhOWYyLCA0ZmNlZmYsIDVkZjBmNiwgNWZmMmNhLCBiMGRmYTAsIGM5ZGE5MSwgYTVhNWE1LCAyNjI2MjYsIDEwNTk2NCwgMDI0ODVjLCAwYjUzOTQsIDAwNzVhMiwgMDg5Y2EyLCAwYjliNzQsIDU0YTgzOCwgN2U5NTMyLCA3ZjdmN2YsIDBjMGMwYywgMDYyMzI4LCAwMTMwM2QsIDA3Mzc2MywgMDA0ZTZjLCAwNTY4NmMsIDA3Njc0ZCwgMzg3MDI1LCA1NDYzMjEnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgaGFyZGNvdmVyOiB7XG4gICAgICAgIGNvbG9yczogJ2ZmZmZmZiwgMDAwMDAwLCBlY2U5YzYsIDg5NWQxZCwgODczNjI0LCBkNjg2MmQsIGQwYmU0MCwgODc3ZjZjLCA5NzIxMDksIGFlYjc5NSwgZjJmMmYyLCA3ZjdmN2YsIGUxZGNhNSwgZjJlMGM2LCBmMGQwYzksIGY2ZTZkNSwgZjVmMmQ4LCBlN2U1ZTEsIGZiYzdiYywgZWVmMGU5LCBkOGQ4ZDgsIDU5NTk1OSwgZDBjOTc0LCBlNmMyOGQsIGUyYTI5MywgZWVjZWFhLCBlY2U1YjIsIGNmY2NjMywgZjc4ZjdhLCBkZWUyZDQsIGJmYmZiZiwgM2YzZjNmLCBhMjlhMzYsIGRhYTQ1NCwgZDQ3MzVlLCBlNmI2ODEsIGUyZDg4YywgYjdiMmE1LCBmMzU4MzgsIGNlZDNiZiwgYTVhNWE1LCAyNjI2MjYsIDUxNGQxYiwgNjY0NTE1LCA2NTI4MWEsIGEyNjQxZiwgYTM5NDI4LCA2NTVmNTAsIDcxMTgwNiwgODc5NDY0LCA3ZjdmN2YsIDBjMGMwYywgMjAxZTBhLCA0NDJlMGUsIDQzMWIxMSwgNmM0MzE1LCA2ZDYyMWEsIDQzM2YzNSwgNGIxMDA0LCA1YTYyNDMnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgdHJlazoge1xuICAgICAgICBjb2xvcnM6ICdmZmZmZmYsIDAwMDAwMCwgZmJlZWM5LCA0ZTNiMzAsIGYwYTIyZSwgYTU2NDRlLCBiNThiODAsIGMzOTg2ZCwgYTE5NTc0LCBjMTc1MjksIGYyZjJmMiwgN2Y3ZjdmLCBmN2UwOWUsIGUxZDZjZiwgZmNlY2Q1LCBlZGRmZGEsIGYwZTdlNSwgZjNlYWUxLCBlY2U5ZTMsIGY1ZTNkMSwgZDhkOGQ4LCA1OTU5NTksIGYzY2M1ZiwgYzRhZDlmLCBmOWQ5YWIsIGRjYzBiNiwgZTFkMGNjLCBlN2Q1YzQsIGQ5ZDRjNywgZWJjN2EzLCBiZmJmYmYsIDNmM2YzZiwgZDI5ZjBmLCBhNzg0NzAsIGY2Yzc4MSwgY2JhMDkyLCBkMmI5YjIsIGRiYzFhNywgYzZiZmFiLCBlMWFjNzYsIGE1YTVhNSwgMjYyNjI2LCA2OTRmMDcsIDNhMmMyNCwgYzg3ZDBlLCA3YjRiM2EsIDkyNjI1NSwgYTE3MjQyLCA3YjcxNTMsIDkwNTcxZSwgN2Y3ZjdmLCAwYzBjMGMsIDJhMWYwMywgMjcxZDE4LCA4NTUzMDksIDUyMzIyNiwgNjE0MTM4LCA2YjRjMmMsIDUyNGIzNywgNjAzYTE0JyxcbiAgICAgICAgY29sdW1uczogMTBcbiAgICB9LFxuICAgIHZlcnZlOiB7XG4gICAgICAgIGNvbG9yczogJ2ZmZmZmZiwgMDAwMDAwLCBkMmQyZDIsIDY2NjY2NiwgZmYzODhjLCBlNDAwNTksIDljMDA3ZiwgNjgwMDdmLCAwMDViZDMsIDAwMzQ5ZSwgZjJmMmYyLCA3ZjdmN2YsIGJkYmRiZCwgZTBlMGUwLCBmZmQ3ZTgsIGZmYzZkYywgZmZiOGYxLCBmMWIyZmYsIGMzZGNmZiwgYjhjZmZmLCBkOGQ4ZDgsIDU5NTk1OSwgOWQ5ZDlkLCBjMWMxYzEsIGZmYWZkMSwgZmY4ZWJhLCBmZjcxZTQsIGUzNjVmZiwgODdiYWZmLCA3MmEwZmYsIGJmYmZiZiwgM2YzZjNmLCA2OTY5NjksIGEzYTNhMywgZmY4N2JhLCBmZjU1OTcsIGZmMmFkNywgZDUxOWZmLCA0Yjk4ZmYsIDJiNzFmZiwgYTVhNWE1LCAyNjI2MjYsIDM0MzQzNCwgNGM0YzRjLCBlOTAwNjIsIGFiMDA0MiwgNzUwMDVmLCA0ZTAwNWYsIDAwNDQ5ZSwgMDAyNjc2LCA3ZjdmN2YsIDBjMGMwYywgMTUxNTE1LCAzMzMzMzMsIDliMDA0MSwgNzIwMDJjLCA0ZTAwM2YsIDM0MDAzZiwgMDAyZDY5LCAwMDE5NGYnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgbW9ub2Nocm9tZToge1xuICAgICAgICBjb2xvcnM6ICcwMDAwMDAsIDFhMWExYSwgMzMzMzMzLCA0ZDRkNGQsIDY2NjY2NiwgODA4MDgwLCA5OTk5OTksIGIzYjNiMywgY2NjY2NjLCBlNmU2ZTYsIGYyZjJmMiwgZmZmZmZmJyxcbiAgICAgICAgY29sdW1uczogMTJcbiAgICB9LFxuICAgIGFjY2Vzc2libGU6IHtcbiAgICAgICAgY29sb3JzOiAnYmxhY2ssIGdyZXksIGRhcmtyZWQsIHJlZCwgZGFya29yYW5nZSwgZ29sZCwgZ3JlZW4sIGJsdWUsIGRhcmtibHVlLCBwdXJwbGUsIHdoaXRlLCBkYXJrZ3JleSwgc2FkZGxlYnJvd24sIHBpbmssIG9yYW5nZSwgeWVsbG93LCBsaWdodGdyZWVuLCBsaWdodHNreWJsdWUsIGxpZ2h0Ymx1ZSwgbWVkaXVtcHVycGxlJyxcbiAgICAgICAgY29sdW1uczogMTBcbiAgICB9XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEZsYXRDb2xvclBpY2tlclNlcnZpY2UgPSBjbGFzcyBGbGF0Q29sb3JQaWNrZXJTZXJ2aWNlIHtcbiAgICBnZXRQYWxldHRlU2V0dGluZ3Moc2V0dGluZ3MsIGZvcm1hdCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0UHJlc2V0ID0gKGZvcm1hdCAhPT0gJ25hbWUnKSA/IERFRkFVTFRfUFJFU0VUIDogREVGQVVMVF9BQ0NFU1NJQkxFX1BSRVNFVDtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3NQYWxldHRlID0gc2V0dGluZ3MucGFsZXR0ZTtcbiAgICAgICAgY29uc3QgcHJlc2V0Q29sdW1ucyA9IHR5cGVvZiBzZXR0aW5nc1BhbGV0dGUgPT09ICdzdHJpbmcnICYmIFBBTEVUVEVQUkVTRVRTW3NldHRpbmdzUGFsZXR0ZV0gP1xuICAgICAgICAgICAgUEFMRVRURVBSRVNFVFNbc2V0dGluZ3NQYWxldHRlXS5jb2x1bW5zIDpcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhbGV0dGU6IHNldHRpbmdzUGFsZXR0ZSB8fCBkZWZhdWx0UHJlc2V0LFxuICAgICAgICAgICAgdGlsZVNpemU6IHNldHRpbmdzLnRpbGVTaXplIHx8IDI0LFxuICAgICAgICAgICAgY29sdW1uczogc2V0dGluZ3MuY29sdW1ucyB8fCBwcmVzZXRDb2x1bW5zIHx8IDEwXG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhbGV0dGVUaWxlTGF5b3V0KHRpbGVTaXplKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGlsZVNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4geyB3aWR0aDogdGlsZVNpemUsIGhlaWdodDogdGlsZVNpemUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHRpbGVTaXplLndpZHRoID8gdGlsZVNpemUud2lkdGggOiB0aWxlU2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IHRpbGVTaXplLmhlaWdodCA/IHRpbGVTaXplLmhlaWdodCA6IHRpbGVTaXplLndpZHRoXG4gICAgICAgIH07XG4gICAgfVxufTtcbkZsYXRDb2xvclBpY2tlclNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIEZsYXRDb2xvclBpY2tlclNlcnZpY2UpO1xuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBjYW5jZWxgIGV2ZW50IG9mIHRoZSBDb2xvclBpY2tlciBhbmQgRmxhdENvbG9yUGlja2VyIGNvbXBvbmVudHMuXG4gKi9cbmNsYXNzIENvbG9yUGlja2VyQ2FuY2VsRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBjbG9zZWAgZXZlbnQgb2YgdGhlIENvbG9yUGlja2VyIGNvbXBvbmVudC5cbiAqL1xuY2xhc3MgQ29sb3JQaWNrZXJDbG9zZUV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYG9wZW5gIGV2ZW50IG9mIHRoZSBDb2xvclBpY2tlciBjb21wb25lbnQuXG4gKi9cbmNsYXNzIENvbG9yUGlja2VyT3BlbkV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG59XG5cbi8qKlxuICogRmlyZXMgZWFjaCB0aW1lIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIENvbG9yUGlja2VyIHdyYXBwZXIgaXMgY2xpY2tlZC5cbiAqIFRoZSBldmVudCBpcyB0cmlnZ2VyZWQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGEgQ29sb3JQaWNrZXIgaWNvbiBpcyBzZXQgb3Igbm90LlxuICpcbiAqIFByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGFjdGl2ZSBjb2xvciBhbmQgZ2l2ZXMgdGhlIG9wdGlvbiB0byBwcmV2ZW50IHRoZSBvcGVuaW5nIG9mIHRoZSBwb3B1cC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8a2VuZG8tY29sb3JwaWNrZXJcbiAqICAgICAgICAgICBbaWNvbl09XCInZWRpdC10b29scydcIlxuICogICAgICAgICAgIFt2YWx1ZV09XCInIzkwMCdcIlxuICogICAgICAgICAgIChhY3RpdmVDb2xvckNsaWNrKT1cImhhbmRsZUFjdGl2ZUNvbG9yQ2xpY2soJGV2ZW50KVwiXG4gKiAgICAgICA+XG4gKiAgICAgICA8L2tlbmRvLWNvbG9ycGlja2VyPlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICBwdWJsaWMgaGFuZGxlQWN0aXZlQ29sb3JDbGljayhldmVudDogQWN0aXZlQ29sb3JDbGlja0V2ZW50KTogdm9pZCB7XG4gKiAgICAgICAgIGV2ZW50LnByZXZlbnRPcGVuKCk7XG4gKlxuICogICAgICAgICBjb25zb2xlLmxvZygnT3BlbiBwcmV2ZW50ZWQ6JywgZXZlbnQuaXNPcGVuUHJldmVudGVkKCkpO1xuICogICAgICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBjb2xvcjonLCBldmVudC5jb2xvcik7XG4gKiAgICAgfVxuICogIH1cbiAqIGBgYFxuICovXG5jbGFzcyBBY3RpdmVDb2xvckNsaWNrRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAcGFyYW0gY29sb3IgUmVwcmVzZW50cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29sb3IpIHtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLm9wZW5QcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIG9wZW5pbmcgb2YgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIHByZXZlbnRPcGVuKCkge1xuICAgICAgICB0aGlzLm9wZW5QcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgb3BlbmluZyBpcyBwcmV2ZW50ZWQgYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9wZW4gYWN0aW9uIHdhcyBwcmV2ZW50ZWQuIE90aGVyd2lzZSwgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqL1xuICAgIGlzT3BlblByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlblByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgdGhlIGhleCBvciByZ2JhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3IuXG4gKi9cbmNvbnN0IHBhcnNlQ29sb3IkMSA9ICh2YWx1ZSwgZm9ybWF0LCBvcGFjaXR5RW5hYmxlZCA9IGZhbHNlLCBzYWZlID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IGFsbG93ZWRGb3JtYXRzID0gWydoZXgnLCAncmdiYScsICduYW1lJ107XG4gICAgaWYgKGFsbG93ZWRGb3JtYXRzLmluZGV4T2YoZm9ybWF0KSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb2xvciBvdXRwdXQgZm9ybWF0ICcke2Zvcm1hdH0nLiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlICdoZXgnLCAncmdiYScgb3IgJ25hbWUnLmApO1xuICAgIH1cbiAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSAnbmFtZScpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVGb3JtYXQodmFsdWUsIHNhZmUpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRDb2xvciA9IHBhcnNlQ29sb3IodmFsdWUudHJpbSgpLCBzYWZlKTtcbiAgICBpZiAoIWlzUHJlc2VudChwYXJzZWRDb2xvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRDb2xvclJlc3VsdCA9IGZvcm1hdCA9PT0gJ2hleCcgPyBnZXRIZXhWYWx1ZShwYXJzZWRDb2xvciwgb3BhY2l0eUVuYWJsZWQpIDogcGFyc2VkQ29sb3IudG9Dc3NSZ2JhKCk7XG4gICAgcmV0dXJuIHBhcnNlZENvbG9yUmVzdWx0O1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgYW4gSFNWIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3Igc3RyaW5nLlxuICovXG5jb25zdCBnZXRIU1YgPSAodmFsdWUsIHNhZmUgPSB0cnVlKSA9PiB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VDb2xvcih2YWx1ZSwgc2FmZSk7XG4gICAgaWYgKCFpc1ByZXNlbnQocGFyc2VkKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQudG9IU1YoKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBSZXR1cm5zIGFuIFJHQkEgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvciBzdHJpbmcuXG4gKi9cbmNvbnN0IGdldFJHQkEgPSAodmFsdWUsIHNhZmUgPSB0cnVlKSA9PiB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VDb2xvcih2YWx1ZSwgc2FmZSk7XG4gICAgaWYgKCFpc1ByZXNlbnQocGFyc2VkKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQudG9CeXRlcygpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgdGhlIFJHQkEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvci5cbiAqL1xuY29uc3QgZ2V0Q29sb3JGcm9tSFNWID0gKGhzdmEsIGZvcm1hdCA9ICdyZ2JhJywgb3BhY2l0eUVuYWJsZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGh1ZSA9IGZpdEludG9Cb3VuZHMoaHN2YS5oLCAwLCAzNTkuOSk7XG4gICAgY29uc3Qgc2F0dXJhdGlvbiA9IGZpdEludG9Cb3VuZHMoaHN2YS5zLCAwLCAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IGZpdEludG9Cb3VuZHMoaHN2YS52LCAwLCAxKTtcbiAgICBjb25zdCBhbHBoYSA9IGZpdEludG9Cb3VuZHMoaHN2YS5hLCAwLCAxKTtcbiAgICBjb25zdCBjb2xvciA9IENvbG9yLmZyb21IU1YoaHVlLCBzYXR1cmF0aW9uLCB2YWx1ZSwgYWxwaGEpO1xuICAgIHJldHVybiBmb3JtYXQgPT09ICdoZXgnID8gZ2V0SGV4VmFsdWUoY29sb3IsIG9wYWNpdHlFbmFibGVkKSA6IGNvbG9yLnRvQ3NzUmdiYSgpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgdGhlIEhFWCB2YWx1ZS5cbiAqL1xuY29uc3QgZ2V0SGV4VmFsdWUgPSAoY29sb3IsIG9wYWNpdHkpID0+IHtcbiAgICByZXR1cm4gb3BhY2l0eSAmJiBjb2xvci5hIDwgMSA/IGNvbG9yLnRvQ3NzKHsgYWxwaGE6IHRydWUgfSkgOiBjb2xvci50b0NzcygpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgdGhlIFJHQkEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvciBiYXNlZCBvbiB0aGUgYGh1ZWAsIGFzc3VtaW5nIHRoZSBgdmFsdWVgLCBgc2F0dXJhdGlvbmAgYW5kIGBhbHBoYWAgaGF2ZSB2YWx1ZSBvZiBgMWAuXG4gKi9cbmNvbnN0IGdldENvbG9yRnJvbUh1ZSA9IChodWUpID0+IHtcbiAgICByZXR1cm4gZ2V0Q29sb3JGcm9tSFNWKHsgaDogaHVlLCBzOiAxLCB2OiAxLCBhOiAxIH0pO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgdGhlIFJHQkEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvci5cbiAqL1xuY29uc3QgZ2V0Q29sb3JGcm9tUkdCQSA9IChyZ2JhKSA9PiB7XG4gICAgY29uc3QgcmVkID0gZml0SW50b0JvdW5kcyhyZ2JhLnIsIDAsIDI1NSk7XG4gICAgY29uc3QgZ3JlZW4gPSBmaXRJbnRvQm91bmRzKHJnYmEuZywgMCwgMjU1KTtcbiAgICBjb25zdCBibHVlID0gZml0SW50b0JvdW5kcyhyZ2JhLmIsIDAsIDI1NSk7XG4gICAgY29uc3QgYWxwaGEgPSBmaXRJbnRvQm91bmRzKHJnYmEuYSwgMCwgMSk7XG4gICAgcmV0dXJuIENvbG9yLmZyb21CeXRlcyhyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkudG9Dc3NSZ2JhKCk7XG59O1xuLyoqXG4gKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBuYW1lRm9ybWF0KHZhbHVlLCBzYWZlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBpZiAoaXNQcmVzZW50KG5hbWVkQ29sb3JzW3ZhbHVlXSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAocGFyc2VDb2xvcih2YWx1ZSwgc2FmZSkpIHtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUNvbG9yKHZhbHVlLCBzYWZlKS50b0hleCgpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBPYmplY3Qua2V5cyhuYW1lZENvbG9ycykuZmluZChrZXkgPT4gbmFtZWRDb2xvcnNba2V5XSA9PT0gdmFsdWUpO1xuICAgIGlmICgha2V5ICYmICFzYWZlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHByb3ZpZGVkIGNvbG9yICR7dmFsdWV9IGlzIG5vdCBzdXBwb3J0ZWQgZm9yICdmb3JtYXQ9XCJuYW1lXCInIHByb3BlcnR5LlRvIGRpc3BsYXkgJHt2YWx1ZX0gY29sb3IsIHRoZSBjb21wb25lbnQgJ2Zvcm1hdCcgcHJvcGVydHkgc2hvdWxkIGJlIHNldCB0byAnaGV4JyBvciAncmdiYScgYCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBSZXR1cm5zIHRoZSBSR0Igb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvciBiYXNlZCBvbiB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAqL1xuY29uc3QgZ2V0UkdCRnJvbVJHQkEgPSAoZm9yZWdyb3VuZENvbG9yLCBiYWNrZ3JvdW5kQ29sb3IpID0+IHtcbiAgICBjb25zdCByMSA9IGZpdEludG9Cb3VuZHMoZm9yZWdyb3VuZENvbG9yLnIsIDAsIDI1NSk7XG4gICAgY29uc3QgZzEgPSBmaXRJbnRvQm91bmRzKGZvcmVncm91bmRDb2xvci5nLCAwLCAyNTUpO1xuICAgIGNvbnN0IGIxID0gZml0SW50b0JvdW5kcyhmb3JlZ3JvdW5kQ29sb3IuYiwgMCwgMjU1KTtcbiAgICBjb25zdCBhMSA9IGZpdEludG9Cb3VuZHMoZm9yZWdyb3VuZENvbG9yLmEsIDAsIDEpO1xuICAgIGNvbnN0IHIyID0gZml0SW50b0JvdW5kcyhiYWNrZ3JvdW5kQ29sb3IuciwgMCwgMjU1KTtcbiAgICBjb25zdCBnMiA9IGZpdEludG9Cb3VuZHMoYmFja2dyb3VuZENvbG9yLmcsIDAsIDI1NSk7XG4gICAgY29uc3QgYjIgPSBmaXRJbnRvQm91bmRzKGJhY2tncm91bmRDb2xvci5iLCAwLCAyNTUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IE1hdGgucm91bmQoKCgxIC0gYTEpICogcjIpICsgKGExICogcjEpKSxcbiAgICAgICAgZzogTWF0aC5yb3VuZCgoKDEgLSBhMSkgKiBnMikgKyAoYTEgKiBnMSkpLFxuICAgICAgICBiOiBNYXRoLnJvdW5kKCgoMSAtIGExKSAqIGIyKSArIChhMSAqIGIxKSlcbiAgICB9O1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgdGhlIHJlbGF0aXZlIGx1bWluYW5jZS5cbiAqL1xuY29uc3QgZ2V0THVtaW5hbmNlID0gKHJnYikgPT4ge1xuICAgIGxldCBhID0gW3JnYi5yLCByZ2IuZywgcmdiLmJdLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICB2IC89IDI1NTtcbiAgICAgICAgcmV0dXJuIHYgPD0gMC4wMzkyOFxuICAgICAgICAgICAgPyB2IC8gMTIuOTJcbiAgICAgICAgICAgIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYVswXSAqIDAuMjEyNiArIGFbMV0gKiAwLjcxNTIgKyBhWzJdICogMC4wNzIyO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgdGhlIGNvbG9yIGNvbnRyYXN0LlxuICovXG5jb25zdCBnZXRDb250cmFzdCA9IChsdW1pbmFuY2UxLCBsdW1pbmFuY2UyKSA9PiB7XG4gICAgY29uc3QgYnJpZ2h0ZXN0ID0gTWF0aC5tYXgobHVtaW5hbmNlMSwgbHVtaW5hbmNlMik7XG4gICAgY29uc3QgZGFya2VzdCA9IE1hdGgubWluKGx1bWluYW5jZTEsIGx1bWluYW5jZTIpO1xuICAgIHJldHVybiAoYnJpZ2h0ZXN0ICsgMC4wNSlcbiAgICAgICAgLyAoZGFya2VzdCArIDAuMDUpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgdGhlIGNvbG9yIGNvbnRyYXN0IGZyb20gdHdvIFJHQkEgY29sb3JzLlxuICovXG5jb25zdCBnZXRDb250cmFzdEZyb21Ud29SR0JBcyA9IChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGdldENvbnRyYXN0KGdldEx1bWluYW5jZShnZXRSR0JGcm9tUkdCQShhLCBiKSksIGdldEx1bWluYW5jZShnZXRSR0JGcm9tUkdCQShiLCB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDEgfSkpKTtcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBiZXppZXJDb21tYW5kID0gKGNvbnRyb2xQb2ludENhbGMpID0+IChwb2ludCwgaSwgYSkgPT4ge1xuICAgIC8vIHN0YXJ0IGNvbnRyb2wgcG9pbnRcbiAgICBjb25zdCBbY3BzWCwgY3BzWV0gPSBjb250cm9sUG9pbnRDYWxjKGFbaSAtIDFdLCBhW2kgLSAyXSwgcG9pbnQpO1xuICAgIC8vIGVuZCBjb250cm9sIHBvaW50XG4gICAgY29uc3QgW2NwZVgsIGNwZVldID0gY29udHJvbFBvaW50Q2FsYyhwb2ludCwgYVtpIC0gMV0sIGFbaSArIDFdLCB0cnVlKTtcbiAgICByZXR1cm4gYEMgJHtjcHNYfSwke2Nwc1l9ICR7Y3BlWH0sJHtjcGVZfSAke3BvaW50WzBdfSwke3BvaW50WzFdfWA7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNvbnRyb2xQb2ludCA9IChsaW5lQ2FsYykgPT4gKGN1cnJlbnQsIHByZXZpb3VzLCBuZXh0LCByZXZlcnNlKSA9PiB7XG4gICAgLy8gd2hlbiAnY3VycmVudCcgaXMgdGhlIGZpcnN0IG9yIGxhc3QgcG9pbnQgb2YgdGhlIGFycmF5XG4gICAgLy8gJ3ByZXZpb3VzJyBhbmQgJ25leHQnIGFyZSB1bmRlZmluZWRcbiAgICAvLyByZXBsYWNlIHdpdGggJ2N1cnJlbnQnXG4gICAgY29uc3QgcCA9IHByZXZpb3VzIHx8IGN1cnJlbnQ7XG4gICAgY29uc3QgbiA9IG5leHQgfHwgY3VycmVudDtcbiAgICBjb25zdCBzbW9vdGggPSAwLjE7XG4gICAgLy8gcHJvcGVydGllcyBvZiB0aGUgbGluZSBiZXR3ZWVuIHByZXZpb3VzIGFuZCBuZXh0XG4gICAgY29uc3QgbCA9IGxpbmVDYWxjKHAsIG4pO1xuICAgIC8vIElmIGlzIGVuZC1jb250cm9sLXBvaW50LCBhZGQgUEkgdG8gdGhlIGFuZ2xlIHRvIGdvIGJhY2t3YXJkXG4gICAgY29uc3QgYW5nbGUgPSBsLmFuZ2xlICsgKHJldmVyc2UgPyBNYXRoLlBJIDogMCk7XG4gICAgY29uc3QgbGVuZ3RoID0gbC5sZW5ndGggKiBzbW9vdGg7XG4gICAgLy8gVGhlIGNvbnRyb2wgcG9pbnQgcG9zaXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnRcbiAgICBjb25zdCB4ID0gY3VycmVudFswXSArIE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aDtcbiAgICBjb25zdCB5ID0gY3VycmVudFsxXSArIE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aDtcbiAgICByZXR1cm4gW3gsIHldO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBsaW5lID0gKHBvaW50QSwgcG9pbnRCKSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoWCA9IHBvaW50QlswXSAtIHBvaW50QVswXTtcbiAgICBjb25zdCBsZW5ndGhZID0gcG9pbnRCWzFdIC0gcG9pbnRBWzFdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlbmd0aDogTWF0aC5zcXJ0KE1hdGgucG93KGxlbmd0aFgsIDIpICsgTWF0aC5wb3cobGVuZ3RoWSwgMikpLFxuICAgICAgICBhbmdsZTogTWF0aC5hdGFuMihsZW5ndGhZLCBsZW5ndGhYKVxuICAgIH07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmVuZGVyIHRoZSBzdmcgPHBhdGg+IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHBvaW50cyAoYXJyYXkpIFJlcHJlc2VudHMgdGhlIHBvaW50cyBjb29yZGluYXRlcyBhcyBhbiBhcnJheSBvZiB0dXBsZXMuXG4gKiBAcGFyYW0gY29tbWFuZCAoZnVuY3Rpb24pIFRoZSBjb21tYW5kIHRoYXQgaXMgdXNlZCAoYmV6aWVyQ29tbWFuZCwgbGluZUNvbW1hbmQpLlxuICogICAgICBAcGFyYW0gcG9pbnQgKGFycmF5KSBbeCx5XSBSZXByZXNlbnRzIHRoZSBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzLlxuICogICAgICBAcGFyYW0gaSAoaW50ZWdlcikgUmVwcmVzZW50cyB0aGUgaW5kZXggb2YgJ3BvaW50JyBpbiB0aGUgYXJyYXkgJ2EnLlxuICogICAgICBAcGFyYW0gYSAoYXJyYXkpIFJlcHJlc2VudHMgdGhlIGNvbXBsZXRlIGFycmF5IG9mIHBvaW50cyBjb29yZGluYXRlcy5cbiAqICAgICAgQG91dHB1dCAoc3RyaW5nKSBhIHN2ZyBwYXRoIGNvbW1hbmQuXG4gKiBAb3V0cHV0IChzdHJpbmcpIGEgU3ZnIDxwYXRoPiBlbGVtZW50XG4gKi9cbmNvbnN0IHN2Z1BhdGggPSAocG9pbnRzLCBjb21tYW5kKSA9PiB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBidWlsZCB0aGUgZCBhdHRyaWJ1dGVzIGJ5IGxvb3Bpbmcgb3ZlciB0aGUgcG9pbnRzXG4gICAgY29uc3QgZCA9IHBvaW50cy5yZWR1Y2UoKGFjYywgcG9pbnQsIGksIGEpID0+IGkgPT09IDAgP1xuICAgICAgICAvLyBpZiBmaXJzdCBwb2ludFxuICAgICAgICBgTSAke3BvaW50WzBdfSwke3BvaW50WzFdfWAgOlxuICAgICAgICAvLyBlbHNlXG4gICAgICAgIGAke2FjY30gJHtjb21tYW5kKHBvaW50LCBpLCBhKX1gLCAnJyk7XG4gICAgcmV0dXJuIGQ7XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENvbG9yR3JhZGllbnRMb2NhbGl6YXRpb25TZXJ2aWNlID0gY2xhc3MgQ29sb3JHcmFkaWVudExvY2FsaXphdGlvblNlcnZpY2UgZXh0ZW5kcyBMb2NhbGl6YXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG1lc3NhZ2VTZXJ2aWNlLCBfcnRsLCBmbGF0Q29sb3JQaWNrZXJMb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIocHJlZml4LCBtZXNzYWdlU2VydmljZSwgX3J0bCk7XG4gICAgICAgIHRoaXMuZmxhdENvbG9yUGlja2VyTG9jYWxpemF0aW9uID0gZmxhdENvbG9yUGlja2VyTG9jYWxpemF0aW9uO1xuICAgIH1cbiAgICBnZXQoc2hvcnRLZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhdENvbG9yUGlja2VyTG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbGF0Q29sb3JQaWNrZXJMb2NhbGl6YXRpb24uZ2V0KHNob3J0S2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KHNob3J0S2V5KTtcbiAgICB9XG59O1xuQ29sb3JHcmFkaWVudExvY2FsaXphdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIEluamVjdChMMTBOX1BSRUZJWCkpLFxuICAgIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksXG4gICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgyLCBJbmplY3QoUlRMKSksXG4gICAgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBJbmplY3QoRmxhdENvbG9yUGlja2VyTG9jYWxpemF0aW9uU2VydmljZSkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nLCBNZXNzYWdlU2VydmljZSwgQm9vbGVhbiwgRmxhdENvbG9yUGlja2VyTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBDb2xvckdyYWRpZW50TG9jYWxpemF0aW9uU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ29sb3JJbnB1dENvbXBvbmVudCA9IGNsYXNzIENvbG9ySW5wdXRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QsIHJlbmRlcmVyLCBsb2NhbGl6YXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgaGV4IGlucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2FibGVJZCA9IGBrLSR7Z3VpZCgpfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIGFscGhhIHNsaWRlciB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBDb2xvcklucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgcmVhZC1vbmx5IHN0YXRlIG9mIHRoZSBDb2xvcklucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgYSBwYXJzZWQgcmdiYSBzdHJpbmcgY29sb3IuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNvbG9ySW5wdXRDbGFzcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmdiYSBpbnB1dHMgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZ2JhID0ge307XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYW55IG9mIHRoZSBpbnB1dHMgYXJlIGZvY3VzZWQuXG4gICAgICovXG4gICAgZ2V0IGlzRm9jdXNlZCgpIHtcbiAgICAgICAgaWYgKCEoaXNEb2N1bWVudEF2YWlsYWJsZSgpICYmIGlzUHJlc2VudCh0aGlzLmhvc3QpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoYWN0aXZlRWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGFueSBvZiB0aGUgcmdiYSBpbnB1dHMgaGF2ZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgcmdiYUlucHV0VmFsaWQoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJnYmEpLmV2ZXJ5KGtleSA9PiBpc1ByZXNlbnQodGhpcy5yZ2JhW2tleV0pKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmluaXREb21FdmVudHMoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGFuZ2VzLnZhbHVlKSAmJiAhdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGV4ID0gcGFyc2VDb2xvciQxKHRoaXMudmFsdWUsICdoZXgnLCB0aGlzLm9wYWNpdHkpO1xuICAgICAgICAgICAgdGhpcy5yZ2JhID0gZ2V0UkdCQSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMucmdiYS5hID0gcGFyc2VDb2xvciQxKHRoaXMudmFsdWUsICdyZ2JhJywgdGhpcy5vcGFjaXR5KSA/IHRoaXMucmdiYS5hIDogMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZm9ybWF0QnV0dG9uVGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KCdmb3JtYXRCdXR0b24nKTtcbiAgICB9XG4gICAgaGFuZGxlUmdiYVZhbHVlQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yRnJvbVJHQkEodGhpcy5yZ2JhKTtcbiAgICAgICAgaWYgKCF0aGlzLnJnYmFJbnB1dFZhbGlkIHx8IGNvbG9yID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLnJnYmEgPSBnZXRSR0JBKHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLmhleCA9IHBhcnNlQ29sb3IkMShjb2xvciwgJ2hleCcsIHRoaXMub3BhY2l0eSk7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdChjb2xvcik7XG4gICAgfVxuICAgIGhhbmRsZUhleFZhbHVlQ2hhbmdlKGhleCkge1xuICAgICAgICB0aGlzLmhleCA9IGhleDtcbiAgICAgICAgY29uc3QgY29sb3IgPSBwYXJzZUNvbG9yJDEoaGV4LCAncmdiYScsIHRoaXMub3BhY2l0eSk7XG4gICAgICAgIGlmICghaXNQcmVzZW50KGNvbG9yKSB8fCBjb2xvciA9PT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5yZ2JhID0gZ2V0UkdCQShjb2xvcik7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdChjb2xvcik7XG4gICAgfVxuICAgIGhhbmRsZVJnYmFJbnB1dEJsdXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZ2JhSW5wdXRWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5yZ2JhID0gZ2V0UkdCQSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVIZXhJbnB1dEJsdXIoKSB7XG4gICAgICAgIHRoaXMuaGV4ID0gcGFyc2VDb2xvciQxKHRoaXMudmFsdWUsICdoZXgnLCB0aGlzLm9wYWNpdHkpO1xuICAgIH1cbiAgICB0b2dnbGVGb3JtYXRWaWV3KCkge1xuICAgICAgICB0aGlzLmZvcm1hdFZpZXcgPSB0aGlzLmZvcm1hdFZpZXcgPT09ICdoZXgnID8gJ3JnYmEnIDogJ2hleCc7XG4gICAgfVxuICAgIGluaXREb21FdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5ob3N0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLnRvZ2dsZUZvcm1hdEJ1dHRvbi5uYXRpdmVFbGVtZW50LCAnY2xpY2snLCAoKSA9PiB0aGlzLnRvZ2dsZUZvcm1hdFZpZXcoKSkpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvcklucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c2FibGVJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0Vmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2xvcklucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sb3JJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2xvcklucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENvbG9ySW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jb2xvcmdyYWRpZW50LWlucHV0cycpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWhzdGFjaycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sb3JJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JJbnB1dENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ29wYWNpdHlJbnB1dCcsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtZXJpY1RleHRCb3hDb21wb25lbnQpXG5dLCBDb2xvcklucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGFjaXR5SW5wdXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnaGV4SW5wdXQnLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBDb2xvcklucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJoZXhJbnB1dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdibHVlSW5wdXQnLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBDb2xvcklucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJibHVlSW5wdXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgndG9nZ2xlRm9ybWF0QnV0dG9uJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgQ29sb3JJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9nZ2xlRm9ybWF0QnV0dG9uXCIsIHZvaWQgMCk7XG5Db2xvcklucHV0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jb2xvcmlucHV0JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImstdnN0YWNrXCI+XG4gICAgICAgICAgICA8YnV0dG9uICN0b2dnbGVGb3JtYXRCdXR0b25cbiAgICAgICAgICAgICAgICBjbGFzcz1cImstY29sb3JncmFkaWVudC10b2dnbGUtbW9kZSBrLWJ1dHRvbiBrLWJ1dHRvbi1tZCBrLWJ1dHRvbi1mbGF0IGstYnV0dG9uLWZsYXQtYmFzZSBrLWljb24tYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImZvcm1hdEJ1dHRvblRpdGxlXCJcbiAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJmb3JtYXRCdXR0b25UaXRsZVwiXG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWJ1dHRvbi1pY29uIGstaWNvbiBrLWktYXJyb3dzLWtwaVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiAqbmdJZj1cImZvcm1hdFZpZXcgPT09ICdoZXgnXCIgY2xhc3M9XCJrLXZzdGFja1wiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgI2hleElucHV0XG4gICAgICAgICAgICAgICAgW2lkXT1cImZvY3VzYWJsZUlkXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstaW5wdXQgay10ZXh0Ym94IGstaW5wdXQtc29saWQgay1pbnB1dC1tZCBrLXJvdW5kZWQtbWQgay1oZXgtdmFsdWVcIlxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICBbdmFsdWVdPVwiaGV4IHx8ICcnXCJcbiAgICAgICAgICAgICAgICAoYmx1cik9XCJoYW5kbGVIZXhJbnB1dEJsdXIoKVwiXG4gICAgICAgICAgICAgICAgKGlucHV0KT1cImhhbmRsZUhleFZhbHVlQ2hhbmdlKGhleElucHV0LnZhbHVlKVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGxhYmVsIFtmb3JdPVwiZm9jdXNhYmxlSWRcIiBjbGFzcz1cImstY29sb3JncmFkaWVudC1pbnB1dC1sYWJlbFwiPkhFWDwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiZm9ybWF0VmlldyA9PT0gJ3JnYmEnXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay12c3RhY2tcIj5cbiAgICAgICAgICAgICAgICA8a2VuZG8tbnVtZXJpY3RleHRib3hcbiAgICAgICAgICAgICAgICAgICAgI3JlZFxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICBbcmVhZG9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgICBbbWluXT1cIjBcIlxuICAgICAgICAgICAgICAgICAgICBbbWF4XT1cIjI1NVwiXG4gICAgICAgICAgICAgICAgICAgIFsodmFsdWUpXT1cInJnYmEuclwiXG4gICAgICAgICAgICAgICAgICAgIFthdXRvQ29ycmVjdF09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgW3NwaW5uZXJzXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW2Zvcm1hdF09XCInbidcIlxuICAgICAgICAgICAgICAgICAgICBbZGVjaW1hbHNdPVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIChibHVyKT1cImhhbmRsZVJnYmFJbnB1dEJsdXIoKVwiXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVSZ2JhVmFsdWVDaGFuZ2UoKVwiPlxuICAgICAgICAgICAgICAgIDwva2VuZG8tbnVtZXJpY3RleHRib3g+XG4gICAgICAgICAgICAgICAgPGxhYmVsIFtmb3JdPVwicmVkLmZvY3VzYWJsZUlkXCIgY2xhc3M9XCJrLWNvbG9yZ3JhZGllbnQtaW5wdXQtbGFiZWxcIj5SPC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstdnN0YWNrXCI+XG4gICAgICAgICAgICAgICAgPGtlbmRvLW51bWVyaWN0ZXh0Ym94XG4gICAgICAgICAgICAgICAgICAgICNncmVlblxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICBbcmVhZG9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgICBbbWluXT1cIjBcIlxuICAgICAgICAgICAgICAgICAgICBbbWF4XT1cIjI1NVwiXG4gICAgICAgICAgICAgICAgICAgIFsodmFsdWUpXT1cInJnYmEuZ1wiXG4gICAgICAgICAgICAgICAgICAgIFthdXRvQ29ycmVjdF09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgW3NwaW5uZXJzXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW2Zvcm1hdF09XCInbidcIlxuICAgICAgICAgICAgICAgICAgICBbZGVjaW1hbHNdPVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIChibHVyKT1cImhhbmRsZVJnYmFJbnB1dEJsdXIoKVwiXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVSZ2JhVmFsdWVDaGFuZ2UoKVwiPlxuICAgICAgICAgICAgICAgIDwva2VuZG8tbnVtZXJpY3RleHRib3g+XG4gICAgICAgICAgICAgICAgPGxhYmVsIFtmb3JdPVwiZ3JlZW4uZm9jdXNhYmxlSWRcIiBjbGFzcz1cImstY29sb3JncmFkaWVudC1pbnB1dC1sYWJlbFwiPkc8L2xhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay12c3RhY2tcIj5cbiAgICAgICAgICAgICAgICA8a2VuZG8tbnVtZXJpY3RleHRib3hcbiAgICAgICAgICAgICAgICAgICAgI2JsdWVcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgW21pbl09XCIwXCJcbiAgICAgICAgICAgICAgICAgICAgW21heF09XCIyNTVcIlxuICAgICAgICAgICAgICAgICAgICBbKHZhbHVlKV09XCJyZ2JhLmJcIlxuICAgICAgICAgICAgICAgICAgICBbYXV0b0NvcnJlY3RdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtzcGlubmVyc109XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgIFtmb3JtYXRdPVwiJ24nXCJcbiAgICAgICAgICAgICAgICAgICAgW2RlY2ltYWxzXT1cIjBcIlxuICAgICAgICAgICAgICAgICAgICAoYmx1cik9XCJoYW5kbGVSZ2JhSW5wdXRCbHVyKClcIlxuICAgICAgICAgICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwiaGFuZGxlUmdiYVZhbHVlQ2hhbmdlKClcIj5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLW51bWVyaWN0ZXh0Ym94PlxuICAgICAgICAgICAgICAgIDxsYWJlbCBbZm9yXT1cImJsdWUuZm9jdXNhYmxlSWRcIiBjbGFzcz1cImstY29sb3JncmFkaWVudC1pbnB1dC1sYWJlbFwiPkI8L2xhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay12c3RhY2tcIiAqbmdJZj1cIm9wYWNpdHlcIj5cbiAgICAgICAgICAgICAgICA8a2VuZG8tbnVtZXJpY3RleHRib3ggICNvcGFjaXR5SW5wdXRcbiAgICAgICAgICAgICAgICAgICAgI2FscGhhXG4gICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgICAgIFttaW5dPVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIFttYXhdPVwiMVwiXG4gICAgICAgICAgICAgICAgICAgIFsodmFsdWUpXT1cInJnYmEuYVwiXG4gICAgICAgICAgICAgICAgICAgIFthdXRvQ29ycmVjdF09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgW3NwaW5uZXJzXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW3N0ZXBdPVwiMC4wMVwiXG4gICAgICAgICAgICAgICAgICAgIFtmb3JtYXRdPVwiJ24yJ1wiXG4gICAgICAgICAgICAgICAgICAgIFtkZWNpbWFsc109XCIyXCJcbiAgICAgICAgICAgICAgICAgICAgKGJsdXIpPVwiaGFuZGxlUmdiYUlucHV0Qmx1cigpXCJcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZVJnYmFWYWx1ZUNoYW5nZSgpXCI+XG4gICAgICAgICAgICAgICAgPC9rZW5kby1udW1lcmljdGV4dGJveD5cbiAgICAgICAgICAgICAgICA8bGFiZWwgW2Zvcl09XCJhbHBoYS5mb2N1c2FibGVJZFwiIGNsYXNzPVwiay1jb2xvcmdyYWRpZW50LWlucHV0LWxhYmVsXCI+QTwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIENvbG9ySW5wdXRDb21wb25lbnQpO1xuXG52YXIgQ29sb3JHcmFkaWVudENvbXBvbmVudF8xO1xubGV0IHNlcmlhbCA9IDA7XG4vKipcbiAqIFRoZSBDb2xvckdyYWRpZW50IGNvbXBvbmVudCBlbmFibGVzIHNtb290aCBjb2xvciB0cmFuc2l0aW9ucyBhbmQgcHJvdmlkZXMgb3B0aW9ucyBmb3Igc2VsZWN0aW5nIHNwZWNpZmljIGNvbG9ycyBvdmVyIHRoZSBkcmFnIGhhbmRsZS5cbiAqIFRoZSBDb2xvckdyYWRpZW50IGlzIGluZGVwZW5kZW50bHkgdXNlZCBieSBga2VuZG8tY29sb3JwaWNrZXJgIGFuZCBjYW4gYmUgZGlyZWN0bHkgYWRkZWQgdG8gdGhlIHBhZ2UuXG4gKi9cbmxldCBDb2xvckdyYWRpZW50Q29tcG9uZW50ID0gQ29sb3JHcmFkaWVudENvbXBvbmVudF8xID0gY2xhc3MgQ29sb3JHcmFkaWVudENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoaG9zdCwgbmdab25lLCByZW5kZXJlciwgY2RyLCBsb2NhbGl6YXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBgay1jb2xvcmdyYWRpZW50LSR7c2VyaWFsKyt9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgd2hldGhlciB0aGUgYWxwaGEgc2xpZGVyIHdpbGwgYmUgZGlzcGxheWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhlIENvbG9yR3JhZGllbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIENvbG9yR3JhZGllbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgQ29sb3JHcmFkaWVudCBzaG91bGQgZGlzcGxheSBhICdDbGVhciBjb2xvcicgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhckJ1dHRvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgZGVsYXkgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBiZWZvcmUgdGhlIHZhbHVlIGlzIGNoYW5nZWQgb24gaGFuZGxlIGRyYWcuIEEgdmFsdWUgb2YgMCBpbmRpY2F0ZXMgbm8gZGVsYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBvdXRwdXQgZm9ybWF0IG9mIHRoZSBDb2xvckdyYWRpZW50Q29tcG9uZW50LlxuICAgICAgICAgKiBUaGUgaW5wdXQgdmFsdWUgbWF5IGJlIGluIGEgZGlmZmVyZW50IGZvcm1hdCwgYnV0IGl0IHdpbGwgYmUgcGFyc2VkIGludG8gdGhlIG91dHB1dCBgZm9ybWF0YFxuICAgICAgICAgKiBhZnRlciB0aGUgY29tcG9uZW50IHByb2Nlc3NlcyBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHN1cHBvcnRlZCB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgcmdiYWBcbiAgICAgICAgICogKiBgaGV4YFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBERUZBVUxUX09VVFBVVF9GT1JNQVQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgc2VsZWN0cyBhIG5ldyBjb2xvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IERFRkFVTFRfR1JBRElFTlRfQkFDS0dST1VORF9DT0xPUjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICpcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGBodWVgLCBgc2F0dXJhdGlvbmAsIGB2YWx1ZWAsIGFuZCBgYWxwaGFgIHZhbHVlcy5cbiAgICAgICAgICogVGhlIHZhbHVlcyBhcmUgaW5pdGlhbGx5IHNldCBpbiBgbmdPbkluaXRgIG9yIGluIGBuZ09uQ2hhbmdlc2AgYW5kIGFyZVxuICAgICAgICAgKiB1cGRhdGVkIG9uIG1vdmluZyB0aGUgZHJhZyBoYW5kbGUgb3IgdGhlIHNsaWRlcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhzdmEgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHt9KTtcbiAgICAgICAgdGhpcy5fdGFiaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmh1ZVNsaWRlclRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbHBoYVNsaWRlclRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLm5vdGlmeU5nQ2hhbmdlZCA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24gPSBsb2NhbGl6YXRpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgcmVhZG9ubHlBdHRyaWJ1dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRvbmx5O1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIGdldCBncmFkaWVudElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG4gICAgZ2V0IGhvc3RUYWJpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiaW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgdmFsdWUgb2YgdGhlIGluaXRpYWxseSBzZWxlY3RlZCBjb2xvci5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBwYXJzZUNvbG9yJDEodmFsdWUsIHRoaXMuZm9ybWF0LCB0aGlzLm9wYWNpdHkpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgY29sb3IgY29udHJhc3QgdG9vbC4gQWNjZXB0cyB0aGUgYmFja2dyb3VuZCBjb2xvciB0aGF0IHdpbGwgYmUgY29tcGFyZWQgdG8gdGhlIHNlbGVjdGVkIHZhbHVlLlxuICAgICAqIFRoZSB0b29sIHdpbGwgY2FsY3VsYXRlIHRoZSBjb250cmFzdCByYXRpbyBiZXR3ZWVuIHRoZSB0d28gY29sb3JzLlxuICAgICAqL1xuICAgIHNldCBjb250cmFzdFRvb2wodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29udHJhc3RUb29sID0gcGFyc2VDb2xvciQxKHZhbHVlLCB0aGlzLmZvcm1hdCwgdGhpcy5vcGFjaXR5KTtcbiAgICB9XG4gICAgZ2V0IGNvbnRyYXN0VG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyYXN0VG9vbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBbdGFiaW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc2V0IHRhYmluZGV4KHZhbHVlKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJpbmRleCA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl90YWJpbmRleCA9ICFpc05hTih0YWJpbmRleCkgPyB0YWJpbmRleCA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBbGxvd3MgcmVtb3ZhbCBvZiB0aGUgdGFiaW5kZXggYXR0cmlidXRlXG4gICAgICAgICAgICB0aGlzLl90YWJpbmRleCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0YWJpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRpc2FibGVkID8gdGhpcy5fdGFiaW5kZXggOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBDb2xvckdyYWRpZW50IG9yIGFueSBvZiBpdHMgY29udGVudCBpcyBmb2N1c2VkLlxuICAgICAqL1xuICAgIGdldCBpc0ZvY3VzZWQoKSB7XG4gICAgICAgIGlmICghKGlzRG9jdW1lbnRBdmFpbGFibGUoKSAmJiBpc1ByZXNlbnQodGhpcy5ob3N0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgYWxwaGFTbGlkZXJWYWx1ZSgpIHtcbiAgICAgICAgLy8gc2V0dGluZyB0aGUgaW5pdGlhbCB2YWx1ZSB0byB1bmRlZmluZWQgdG8gZm9yY2UgdGhlIHNsaWRlciB0byByZWNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBzbGlkZXIgdHJhY2sgb24gdGhlIG5leHQgY2RyIHJ1blxuICAgICAgICBpZiAoIShpc1ByZXNlbnQodGhpcy5oc3ZhLnZhbHVlKSAmJiBpc1ByZXNlbnQodGhpcy5oc3ZhLnZhbHVlLmEpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhzdmEudmFsdWUuYSAqIDEwMDtcbiAgICB9XG4gICAgZ2V0IGdyYWRpZW50UmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhZGllbnRXcmFwcGVyLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY29udHJhc3RUb29sVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJhc3RUb29sICYmIHRoaXMuY29udHJhc3RUb29sLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVDaGFuZ2VzKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGlzQ2hhbmdlZCgndmFsdWUnLCBjaGFuZ2VzKSAmJiAhdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVUkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdkZWxheScsIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2hhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2gocmVtb3ZlTGlzdGVuZXIgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDaGFuZ2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYWRpZW50RHJhZ0hhbmRsZS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnVwZGF0ZVVJKCk7XG4gICAgICAgIHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVEcmFnUHJlc3MoYXJncykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5IHx8ICFpc1ByZXNlbnQoYXJncy5vcmlnaW5hbEV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgYXJncy5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkhhbmRsZURyYWcoYXJncykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmdyYWRpZW50V3JhcHBlci5uYXRpdmVFbGVtZW50LCAnay1kcmFnZ2luZycpO1xuICAgICAgICB0aGlzLmNoYW5nZVBvc2l0aW9uKGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25IYW5kbGVSZWxlYXNlKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmdyYWRpZW50V3JhcHBlci5uYXRpdmVFbGVtZW50LCAnay1kcmFnZ2luZycpO1xuICAgICAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKGdldENvbG9yRnJvbUhTVih0aGlzLmhzdmEudmFsdWUsIHRoaXMuZm9ybWF0LCB0aGlzLm9wYWNpdHkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uS2V5Ym9hcmRBY3Rpb24oYXJncykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3Mua2V5ICYmIGFyZ3Mua2V5LmluZGV4T2YoJ0Fycm93JykgIT09IC0xKSB7XG4gICAgICAgICAgICBhcmdzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCBkcmFnSGFuZGxlRWxlbWVudCA9IHRoaXMuZ3JhZGllbnREcmFnSGFuZGxlLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZ3JhZGllbnRXcmFwcGVyLm5hdGl2ZUVsZW1lbnQsICdrLWRyYWdnaW5nJyk7XG4gICAgICAgICAgICBsZXQga2V5Ym9hcmRNb3ZlWCA9IDA7XG4gICAgICAgICAgICBsZXQga2V5Ym9hcmRNb3ZlWSA9IDA7XG4gICAgICAgICAgICBzd2l0Y2ggKGFyZ3Mua2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIGtleWJvYXJkTW92ZVggPSBEUkFHSEFORExFX01PVkVfU1BFRUQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIGtleWJvYXJkTW92ZVggPSAtRFJBR0hBTkRMRV9NT1ZFX1NQRUVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgICAgICAgICAga2V5Ym9hcmRNb3ZlWSA9IC1EUkFHSEFORExFX01PVkVfU1BFRUQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICAgICAgICAgIGtleWJvYXJkTW92ZVkgPSBEUkFHSEFORExFX01PVkVfU1BFRUQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3WSA9IHBhcnNlSW50KGRyYWdIYW5kbGVFbGVtZW50LnN0eWxlLnRvcCwgMTApICsga2V5Ym9hcmRNb3ZlWTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ggPSBwYXJzZUludChkcmFnSGFuZGxlRWxlbWVudC5zdHlsZS5sZWZ0LCAxMCkgKyBrZXlib2FyZE1vdmVYO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShkcmFnSGFuZGxlRWxlbWVudCwgJ3RvcCcsIGAke25ld1l9cHhgKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZHJhZ0hhbmRsZUVsZW1lbnQsICdsZWZ0JywgYCR7bmV3WH1weGApO1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMubW92ZURyYWdIYW5kbGUobmV3WCwgbmV3WSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjaGFuZ2VQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmFkaWVudERyYWdIYW5kbGUubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICBjb25zdCBncmFkaWVudFJlY3QgPSB0aGlzLmdyYWRpZW50UmVjdDtcbiAgICAgICAgY29uc3QgbmV3WCA9IHBvc2l0aW9uLmNsaWVudFggLSBncmFkaWVudFJlY3QubGVmdDtcbiAgICAgICAgY29uc3QgbmV3WSA9IHBvc2l0aW9uLmNsaWVudFkgLSBncmFkaWVudFJlY3QudG9wO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5tb3ZlRHJhZ0hhbmRsZShuZXdYLCBuZXdZKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVIdWVTbGlkZXJDaGFuZ2UoaHVlKSB7XG4gICAgICAgIGNvbnN0IGhzdmEgPSB0aGlzLmhzdmEudmFsdWU7XG4gICAgICAgIGhzdmEuaCA9IGh1ZTtcbiAgICAgICAgdGhpcy5oc3ZhLm5leHQoaHN2YSk7XG4gICAgICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UoZ2V0Q29sb3JGcm9tSFNWKHRoaXMuaHN2YS52YWx1ZSwgdGhpcy5mb3JtYXQsIHRoaXMub3BhY2l0eSkpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGdldENvbG9yRnJvbUh1ZShodWUpO1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmRDb2xvcih0aGlzLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIHRoaXMuc2V0QWxwaGFTbGlkZXJCYWNrZ3JvdW5kKHRoaXMuYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgdGhpcy5odWVTbGlkZXJUb3VjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUFscGhhU2xpZGVyQ2hhbmdlKGFscGhhKSB7XG4gICAgICAgIGNvbnN0IGhzdmEgPSB0aGlzLmhzdmEudmFsdWU7XG4gICAgICAgIGhzdmEuYSA9IGFscGhhIC8gMTAwO1xuICAgICAgICB0aGlzLmhzdmEubmV4dChoc3ZhKTtcbiAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZShnZXRDb2xvckZyb21IU1YodGhpcy5oc3ZhLnZhbHVlLCB0aGlzLmZvcm1hdCwgdGhpcy5vcGFjaXR5KSk7XG4gICAgICAgIHRoaXMuYWxwaGFTbGlkZXJUb3VjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUlucHV0c1ZhbHVlQ2hhbmdlKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQ29sb3IkMShjb2xvciwgdGhpcy5mb3JtYXQsIHRoaXMub3BhY2l0eSk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSBwYXJzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UocGFyc2VkKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVUkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5ncmFkaWVudFdyYXBwZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVVJKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ0NoYW5nZWQgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMubm90aWZ5TmdUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbG9yR3JhZGllbnRIYW5kbGVUaXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQoJ2NvbG9yR3JhZGllbnRIYW5kbGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBjb2xvckdyYWRpZW50SGFuZGxlQXJpYUxhYmVsKCkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvbG9yJDEodGhpcy52YWx1ZSwgdGhpcy5mb3JtYXQsIHRoaXMub3BhY2l0eSk7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnZhbHVlID8gcGFyc2VkIDogdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmdldCgnY29sb3JHcmFkaWVudEhhbmRsZScpfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaHVlU2xpZGVyVGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KCdodWVTbGlkZXJIYW5kbGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBvcGFjaXR5U2xpZGVyVGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KCdvcGFjaXR5U2xpZGVySGFuZGxlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY2xlYXJCdXR0b25UaXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQoJ2NsZWFyQnV0dG9uJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIGJ5IHRoZSBGbG9hdGluZ0xhYmVsIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZURyYWdIYW5kbGUocG9zaXRpb25YLCBwb3NpdGlvblkpIHtcbiAgICAgICAgY29uc3QgZ3JhZGllbnRSZWN0ID0gdGhpcy5ncmFkaWVudFJlY3Q7XG4gICAgICAgIGNvbnN0IGdyYWRpZW50UmVjdFdpZHRoID0gZ3JhZGllbnRSZWN0LndpZHRoO1xuICAgICAgICBjb25zdCBncmFkaWVudFJlY3RIZWlnaHQgPSBncmFkaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgICBjb25zdCB0b3AgPSBmaXRJbnRvQm91bmRzKHBvc2l0aW9uWSwgMCwgZ3JhZGllbnRSZWN0SGVpZ2h0KTtcbiAgICAgICAgY29uc3QgbGVmdCA9IGZpdEludG9Cb3VuZHMocG9zaXRpb25YLCAwLCBncmFkaWVudFJlY3RXaWR0aCk7XG4gICAgICAgIHRoaXMuc2V0RHJhZ0hhbmRsZUVsZW1lbnRQb3NpdGlvbih0b3AsIGxlZnQpO1xuICAgICAgICBjb25zdCBoc3ZhID0gdGhpcy5oc3ZhLnZhbHVlO1xuICAgICAgICBoc3ZhLnMgPSBsZWZ0IC8gZ3JhZGllbnRSZWN0V2lkdGg7XG4gICAgICAgIGhzdmEudiA9IDEgLSB0b3AgLyBncmFkaWVudFJlY3RIZWlnaHQ7XG4gICAgICAgIHRoaXMuaHN2YS5uZXh0KGhzdmEpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlcy5uZXh0KGdldENvbG9yRnJvbUhTVih0aGlzLmhzdmEudmFsdWUsIHRoaXMuZm9ybWF0LCB0aGlzLm9wYWNpdHkpKTtcbiAgICAgICAgdGhpcy5zZXRBbHBoYVNsaWRlckJhY2tncm91bmQoZ2V0Q29sb3JGcm9tSFNWKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaHN2YS52YWx1ZSwgeyBhOiAxIH0pLCB0aGlzLmZvcm1hdCwgdGhpcy5vcGFjaXR5KSk7XG4gICAgfVxuICAgIGhhbmRsZVZhbHVlQ2hhbmdlKGNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KGNvbG9yKTtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ0NoYW5nZWQoY29sb3IpO1xuICAgICAgICB0aGlzLnNldEhvc3RFbGVtZW50QXJpYUxhYmVsKCk7XG4gICAgfVxuICAgIHNldERyYWdIYW5kbGVFbGVtZW50UG9zaXRpb24odG9wLCBsZWZ0KSB7XG4gICAgICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0aGlzLmdyYWRpZW50RHJhZ0hhbmRsZS5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGRyYWdIYW5kbGUsICd0b3AnLCBgJHt0b3B9cHhgKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShkcmFnSGFuZGxlLCAnbGVmdCcsIGAke2xlZnR9cHhgKTtcbiAgICB9XG4gICAgc2V0QWxwaGFTbGlkZXJCYWNrZ3JvdW5kKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLmFscGhhU2xpZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsaWRlclRyYWNrID0gdGhpcy5hbHBoYVNsaWRlci50cmFjay5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHNsaWRlclRyYWNrLCAnYmFja2dyb3VuZCcsIGBsaW5lYXItZ3JhZGllbnQodG8gdG9wLCB0cmFuc3BhcmVudCwgJHtiYWNrZ3JvdW5kQ29sb3J9KWApO1xuICAgIH1cbiAgICBzZXRIb3N0RWxlbWVudEFyaWFMYWJlbCgpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VDb2xvciQxKHRoaXMudmFsdWUsIHRoaXMuZm9ybWF0LCB0aGlzLm9wYWNpdHkpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmhvc3QubmF0aXZlRWxlbWVudCwgJ2FyaWEtbGFiZWwnLCBgJHt0aGlzLnZhbHVlID8gcGFyc2VkIDogdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmdldCgnY29sb3JHcmFkaWVudE5vQ29sb3InKX1gKTtcbiAgICB9XG4gICAgc2V0QmFja2dyb3VuZENvbG9yKGNvbG9yKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5oc3ZSZWN0YW5nbGUubmF0aXZlRWxlbWVudCwgJ2JhY2tncm91bmQnLCBjb2xvcik7XG4gICAgfVxuICAgIHVwZGF0ZVVJKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmh1ZVNsaWRlclRvdWNoZWQgfHwgdGhpcy5hbHBoYVNsaWRlclRvdWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaHVlU2xpZGVyVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hbHBoYVNsaWRlclRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhzdmEubmV4dCh0aGlzLnZhbHVlID8gZ2V0SFNWKHRoaXMudmFsdWUpIDogeyBoOiAwLCBzOiAwLCB2OiAxLCBhOiAxIH0pO1xuICAgICAgICBjb25zdCBncmFkaWVudFJlY3QgPSB0aGlzLmdyYWRpZW50UmVjdDtcbiAgICAgICAgY29uc3QgdG9wID0gKDEgLSB0aGlzLmhzdmEudmFsdWUudikgKiBncmFkaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5oc3ZhLnZhbHVlLnMgKiBncmFkaWVudFJlY3Qud2lkdGg7XG4gICAgICAgIHRoaXMuc2V0RHJhZ0hhbmRsZUVsZW1lbnRQb3NpdGlvbih0b3AsIGxlZnQpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGdldENvbG9yRnJvbUh1ZSh0aGlzLmhzdmEudmFsdWUuaCk7XG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMuYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgdGhpcy5zZXRBbHBoYVNsaWRlckJhY2tncm91bmQodGhpcy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICB0aGlzLnNldEhvc3RFbGVtZW50QXJpYUxhYmVsKCk7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb2N1c091dExpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQsICdmb2N1c291dCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY29udGFpbnNGb2N1cyh0aGlzLmhvc3QubmF0aXZlRWxlbWVudCwgZXZlbnQucmVsYXRlZFRhcmdldCkgJiYgaXNVbnRvdWNoZWQodGhpcy5ob3N0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5ub3RpZnlOZ1RvdWNoZWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBrZXlkb3duTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmdyYWRpZW50RHJhZ0hhbmRsZS5uYXRpdmVFbGVtZW50LCAna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25LZXlib2FyZEFjdGlvbihldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGtleXVwTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmdyYWRpZW50RHJhZ0hhbmRsZS5uYXRpdmVFbGVtZW50LCAna2V5dXAnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmdyYWRpZW50V3JhcHBlci5uYXRpdmVFbGVtZW50LCAnay1kcmFnZ2luZycpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZWFkb25seSAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZShnZXRDb2xvckZyb21IU1YodGhpcy5oc3ZhLnZhbHVlLCB0aGlzLmZvcm1hdCwgdGhpcy5vcGFjaXR5KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZHJhZ0hhbmRsZUZvY3VzSW5MaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZ3JhZGllbnREcmFnSGFuZGxlLm5hdGl2ZUVsZW1lbnQsICdmb2N1c2luJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5ncmFkaWVudERyYWdIYW5kbGUubmF0aXZlRWxlbWVudCwgJ2stc3RhdGUtZm9jdXMnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZHJhZ0hhbmRsZUZvY3VzT3V0TGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmdyYWRpZW50RHJhZ0hhbmRsZS5uYXRpdmVFbGVtZW50LCAnZm9jdXNvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmdyYWRpZW50RHJhZ0hhbmRsZS5uYXRpdmVFbGVtZW50LCAnay1zdGF0ZS1mb2N1cycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGZvY3VzT3V0TGlzdGVuZXIsIGtleWRvd25MaXN0ZW5lciwga2V5dXBMaXN0ZW5lciwgZHJhZ0hhbmRsZUZvY3VzSW5MaXN0ZW5lciwgZHJhZ0hhbmRsZUZvY3VzT3V0TGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VSZXF1ZXN0c1N1YnNjcmlwdGlvbiA9IHRoaXMudXBkYXRlVmFsdWVzLnBpcGUodGhyb3R0bGVUaW1lKHRoaXMuZGVsYXkpKS5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZUNoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5nZVJlcXVlc3RzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVJlcXVlc3RzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY29sb3JncmFkaWVudCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sb3JHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtcmVhZG9ubHknKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ29sb3JHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwicmVhZG9ubHlBdHRyaWJ1dGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDb2xvckdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuaWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDb2xvckdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudElkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbG9yR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDb2xvckdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0VGFiaW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvckdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbG9yR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2xvckdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbG9yR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sb3JHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xlYXJCdXR0b25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENvbG9yR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcImRlbGF5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIENvbG9yR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBDb2xvckdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250cmFzdFRvb2xcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcbl0sIENvbG9yR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sb3JHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnZ3JhZGllbnREcmFnSGFuZGxlJywgeyByZWFkOiBFbGVtZW50UmVmLCBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgQ29sb3JHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnREcmFnSGFuZGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2lucHV0cycsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ29sb3JJbnB1dENvbXBvbmVudClcbl0sIENvbG9yR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdhbHBoYVNsaWRlcicsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU2xpZGVyQ29tcG9uZW50KVxuXSwgQ29sb3JHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWxwaGFTbGlkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnZ3JhZGllbnRXcmFwcGVyJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgQ29sb3JHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRXcmFwcGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2hzdlJlY3RhbmdsZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIENvbG9yR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcImhzdlJlY3RhbmdsZVwiLCB2b2lkIDApO1xuQ29sb3JHcmFkaWVudENvbXBvbmVudCA9IENvbG9yR3JhZGllbnRDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9Db2xvckdyYWRpZW50JyxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jb2xvcmdyYWRpZW50JyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sb3JHcmFkaWVudENvbXBvbmVudF8xKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBLZW5kb0lucHV0LFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENvbG9yR3JhZGllbnRDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDb2xvckdyYWRpZW50TG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBDb2xvckdyYWRpZW50TG9jYWxpemF0aW9uU2VydmljZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmNvbG9yZ3JhZGllbnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIga2VuZG9Db2xvckdyYWRpZW50TG9jYWxpemVkTWVzc2FnZXNcbiAgICAgICAgICAgIGkxOG4tY29sb3JHcmFkaWVudE5vQ29sb3I9XCJrZW5kby5jb2xvcmdyYWRpZW50LmNvbG9yR3JhZGllbnROb0NvbG9yfFRoZSBhcmlhLWxhYmVsIGFwcGxpZWQgdG8gdGhlIENvbG9yR3JhZGllbnQgY29tcG9uZW50IHdoZW4gdGhlIHZhbHVlIGlzIGVtcHR5LlwiXG4gICAgICAgICAgICBjb2xvckdyYWRpZW50Tm9Db2xvcj1cIkNvbG9yZ3JhZGllbnQgbm8gY29sb3IgY2hvc2VuXCJcbiAgICAgICAgICAgIGkxOG4tY29sb3JHcmFkaWVudEhhbmRsZT1cImtlbmRvLmNvbG9yZ3JhZGllbnQuY29sb3JHcmFkaWVudEhhbmRsZXxUaGUgdGl0bGUgZm9yIHRoZSBncmFkaWVudCBjb2xvciBkcmFnIGhhbmRsZSBjaG9vc2VyLlwiXG4gICAgICAgICAgICBjb2xvckdyYWRpZW50SGFuZGxlPVwiQ2hvb3NlIGNvbG9yXCJcbiAgICAgICAgICAgIGkxOG4tY2xlYXJCdXR0b249XCJrZW5kby5jb2xvcmdyYWRpZW50LmNsZWFyQnV0dG9ufFRoZSB0aXRsZSBmb3IgdGhlIGNsZWFyIGJ1dHRvbi5cIlxuICAgICAgICAgICAgY2xlYXJCdXR0b249XCJDbGVhciB2YWx1ZVwiXG4gICAgICAgICAgICBpMThuLWh1ZVNsaWRlckhhbmRsZT1cImtlbmRvLmNvbG9yZ3JhZGllbnQuaHVlU2xpZGVySGFuZGxlfFRoZSB0aXRsZSBmb3IgdGhlIGh1ZSBzbGlkZXIgaGFuZGxlLlwiXG4gICAgICAgICAgICBodWVTbGlkZXJIYW5kbGU9XCJTZXQgaHVlXCJcbiAgICAgICAgICAgIGkxOG4tb3BhY2l0eVNsaWRlckhhbmRsZT1cImtlbmRvLmNvbG9yZ3JhZGllbnQub3BhY2l0eVNsaWRlckhhbmRsZXxUaGUgdGl0bGUgZm9yIHRoZSBvcGFjaXR5IHNsaWRlciBoYW5kbGUuXCJcbiAgICAgICAgICAgIG9wYWNpdHlTbGlkZXJIYW5kbGU9XCJTZXQgb3BhY2l0eVwiXG4gICAgICAgICAgICBpMThuLXBhc3NDb250cmFzdD1cImtlbmRvLmNvbG9yZ3JhZGllbnQucGFzc0NvbnRyYXN0fFRoZSBwYXNzIG1lc3NhZ2UgZm9yIHRoZSBjb250cmFzdCB0b29sLlwiXG4gICAgICAgICAgICBwYXNzQ29udHJhc3Q9XCJQYXNzXCJcbiAgICAgICAgICAgIGkxOG4tZmFpbENvbnRyYXN0PVwia2VuZG8uY29sb3JncmFkaWVudC5mYWlsQ29udHJhc3R8VGhlIGZhaWwgbWVzc2FnZSBmb3IgdGhlIGNvbnRyYXN0IHRvb2wuXCJcbiAgICAgICAgICAgIGZhaWxDb250cmFzdD1cIkZhaWxcIlxuICAgICAgICAgICAgaTE4bi1jb250cmFzdFJhdGlvPVwia2VuZG8uY29sb3JncmFkaWVudC5jb250cmFzdFJhdGlvfFRoZSBjb250cmFzdCByYXRpbyBtZXNzYWdlIGZvciB0aGUgY29udHJhc3QgdG9vbC5cIlxuICAgICAgICAgICAgY29udHJhc3RSYXRpbz1cIkNvbnRyYXN0IHJhdGlvXCJcbiAgICAgICAgICAgIGkxOG4tZm9ybWF0QnV0dG9uPVwia2VuZG8uY29sb3JncmFkaWVudC5mb3JtYXRCdXR0b258VGhlIG1lc3NhZ2UgZm9yIHRoZSBpbnB1dCBmb3JtYXQgdG9nZ2xlIGJ1dHRvbi5cIlxuICAgICAgICAgICAgZm9ybWF0QnV0dG9uPVwiQ2hhbmdlIGNvbG9yIGZvcm1hdFwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImstY29sb3JncmFkaWVudC1jYW52YXMgay1oc3RhY2tcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJrLWhzdi1yZWN0YW5nbGVcIiAjaHN2UmVjdGFuZ2xlPlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgI2dyYWRpZW50V3JhcHBlclxuICAgICAgICAgICAgICAgICAgICBrZW5kb0RyYWdnYWJsZVxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstaHN2LWdyYWRpZW50XCJcbiAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImNoYW5nZVBvc2l0aW9uKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAoa2VuZG9QcmVzcyk9XCJoYW5kbGVEcmFnUHJlc3MoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChrZW5kb0RyYWcpPVwib25IYW5kbGVEcmFnKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAoa2VuZG9SZWxlYXNlKT1cIm9uSGFuZGxlUmVsZWFzZSgpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICNncmFkaWVudERyYWdIYW5kbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1oc3YtZHJhZ2hhbmRsZSBrLWRyYWdoYW5kbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImNvbG9yR3JhZGllbnRIYW5kbGVUaXRsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImNvbG9yR3JhZGllbnRIYW5kbGVBcmlhTGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxzdmcga2VuZG9Db2xvckNvbnRyYXN0U3ZnXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiY29udHJhc3RUb29sVmlzaWJsZSAmJiBncmFkaWVudFdyYXBwZXJcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstY29sb3ItY29udHJhc3Qtc3ZnXCJcbiAgICAgICAgICAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgICAgICAgICAgICAgIFt3cmFwcGVyXT1cImdyYWRpZW50V3JhcHBlciA/IGdyYWRpZW50V3JhcHBlciA6IHVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgIFtoc3ZhXT1cImhzdmFcIlxuICAgICAgICAgICAgICAgICAgICBbYmFja2dyb3VuZENvbG9yXT1cImNvbnRyYXN0VG9vbFwiPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1oc3YtY29udHJvbHMgay1oc3RhY2sge3sgY2xlYXJCdXR0b24gPyAnay1zbGlkZXJzLXdyYXAtY2xlYXJhYmxlJyA6ICcnIH19XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWNsZWFyLWNvbG9yIGstYnV0dG9uIGstYnV0dG9uLW1kIGstYnV0dG9uLWZsYXQgay1idXR0b24tZmxhdC1iYXNlIGstYnV0dG9uLWljb25cIlxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImNsZWFyQnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInJlc2V0KClcIlxuICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJyZXNldCgpXCJcbiAgICAgICAgICAgICAgICAgICAgKGtleWRvd24uc3BhY2UpPVwicmVzZXQoKVwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY2xlYXJCdXR0b25UaXRsZVwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImNsZWFyQnV0dG9uVGl0bGVcIlxuICAgICAgICAgICAgICAgICAgICB0YWJpbmRleD1cIjBcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1pLXJlc2V0LWNvbG9yXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8a2VuZG8tc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsnay1hbGlnbi1zZWxmLWVuZCc6IGNsZWFyQnV0dG9ufVwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1odWUtc2xpZGVyIGstY29sb3JncmFkaWVudC1zbGlkZXJcIlxuICAgICAgICAgICAgICAgICAgICBbZHJhZ0hhbmRsZVRpdGxlXT1cImh1ZVNsaWRlclRpdGxlXCJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgW3Nob3dCdXR0b25zXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW3RpY2tQbGFjZW1lbnRdPVwiJ25vbmUnXCJcbiAgICAgICAgICAgICAgICAgICAgW3ZlcnRpY2FsXT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICBbbWluXT1cIjBcIlxuICAgICAgICAgICAgICAgICAgICBbbWF4XT1cIjM2MFwiXG4gICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJoc3ZhLnZhbHVlLmhcIlxuICAgICAgICAgICAgICAgICAgICBbc21hbGxTdGVwXT1cIjVcIlxuICAgICAgICAgICAgICAgICAgICBbbGFyZ2VTdGVwXT1cIjEwXCJcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZUh1ZVNsaWRlckNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC9rZW5kby1zbGlkZXI+XG4gICAgICAgICAgICAgICAgPGtlbmRvLXNsaWRlclxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cIm9wYWNpdHlcIlxuICAgICAgICAgICAgICAgICAgICAjYWxwaGFTbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwieydrLWFsaWduLXNlbGYtZW5kJzogY2xlYXJCdXR0b259XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWFscGhhLXNsaWRlciBrLWNvbG9yZ3JhZGllbnQtc2xpZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2RyYWdIYW5kbGVUaXRsZV09XCJvcGFjaXR5U2xpZGVyVGl0bGVcIlxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICBbcmVhZG9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgICBbc2hvd0J1dHRvbnNdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICBbdGlja1BsYWNlbWVudF09XCInbm9uZSdcIlxuICAgICAgICAgICAgICAgICAgICBbdmVydGljYWxdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgIFttaW5dPVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIFttYXhdPVwiMTAwXCJcbiAgICAgICAgICAgICAgICAgICAgW3NtYWxsU3RlcF09XCIxXCJcbiAgICAgICAgICAgICAgICAgICAgW2xhcmdlU3RlcF09XCIxMFwiXG4gICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJhbHBoYVNsaWRlclZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZUFscGhhU2xpZGVyQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLXNsaWRlcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGtlbmRvLWNvbG9yaW5wdXQgICNpbnB1dHNcbiAgICAgICAgICAgIFtvcGFjaXR5XT1cIm9wYWNpdHlcIlxuICAgICAgICAgICAgW2Zvcm1hdFZpZXddPVwiZm9ybWF0XCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVJbnB1dHNWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgPlxuICAgICAgICA8L2tlbmRvLWNvbG9yaW5wdXQ+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLWNvbG9yZ3JhZGllbnQtY29sb3ItY29udHJhc3Qgay12Ym94XCJcbiAgICAgICAgICAgICpuZ0lmPVwiY29udHJhc3RUb29sVmlzaWJsZVwiXG4gICAgICAgICAgICBrZW5kb0NvbnRyYXN0VG9vbFxuICAgICAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgICAgIFtyYXRpb109XCJjb250cmFzdFRvb2xcIj5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgICAgICAgc3R5bGVzOiBbYFxuICAgICAgICAuay1jbGVhci1jb2xvciB7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICBsZWZ0OiA1MCU7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICAgIH1cbiAgICAgICAgLmstY29sb3JncmFkaWVudC1zbGlkZXIuay1hbGlnbi1zZWxmLWVuZCB7XG4gICAgICAgICAgICBoZWlnaHQ6IDE0MHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgLmstY29sb3ItY29udHJhc3Qtc3ZnIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgfVxuICAgIGBdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgQ29sb3JHcmFkaWVudENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ29sb3JQYWxldHRlTG9jYWxpemF0aW9uU2VydmljZSA9IGNsYXNzIENvbG9yUGFsZXR0ZUxvY2FsaXphdGlvblNlcnZpY2UgZXh0ZW5kcyBMb2NhbGl6YXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG1lc3NhZ2VTZXJ2aWNlLCBfcnRsLCBmbGF0Q29sb3JQaWNrZXJMb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIocHJlZml4LCBtZXNzYWdlU2VydmljZSwgX3J0bCk7XG4gICAgICAgIHRoaXMuZmxhdENvbG9yUGlja2VyTG9jYWxpemF0aW9uID0gZmxhdENvbG9yUGlja2VyTG9jYWxpemF0aW9uO1xuICAgIH1cbiAgICBnZXQoc2hvcnRLZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhdENvbG9yUGlja2VyTG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbGF0Q29sb3JQaWNrZXJMb2NhbGl6YXRpb24uZ2V0KHNob3J0S2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KHNob3J0S2V5KTtcbiAgICB9XG59O1xuQ29sb3JQYWxldHRlTG9jYWxpemF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgSW5qZWN0KEwxME5fUFJFRklYKSksXG4gICAgX19wYXJhbSgxLCBPcHRpb25hbCgpKSxcbiAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDIsIEluamVjdChSVEwpKSxcbiAgICBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIEluamVjdChGbGF0Q29sb3JQaWNrZXJMb2NhbGl6YXRpb25TZXJ2aWNlKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmcsIE1lc3NhZ2VTZXJ2aWNlLCBCb29sZWFuLCBGbGF0Q29sb3JQaWNrZXJMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIENvbG9yUGFsZXR0ZUxvY2FsaXphdGlvblNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENvbG9yUGFsZXR0ZVNlcnZpY2UgPSBjbGFzcyBDb2xvclBhbGV0dGVTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29sb3JSb3dzID0gW107XG4gICAgfVxuICAgIHNldENvbG9yTWF0cml4KHBhbGV0dGUsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5jb2xvclJvd3MgPSBbXTtcbiAgICAgICAgaWYgKCEoaXNQcmVzZW50KHBhbGV0dGUpICYmIHBhbGV0dGUubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zIHx8IHBhbGV0dGUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBzdGFydCA9IDA7IHN0YXJ0IDwgcGFsZXR0ZS5sZW5ndGg7IHN0YXJ0ICs9IGNvbHVtbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IHBhbGV0dGUuc2xpY2Uoc3RhcnQsIGNvbHVtbnMgKyBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yUm93cy5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2VsbENvb3Jkc0Zvcihjb2xvcikge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChjb2xvcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLmNvbG9yUm93cy5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbG9yUm93c1tyb3ddLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvclJvd3Nbcm93XVtjb2xdID09PSBjb2xvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByb3csIGNvbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb2xvckF0KGNlbGxDb29yZHMpIHtcbiAgICAgICAgaWYgKCEoaXNQcmVzZW50KGNlbGxDb29yZHMpICYmIGlzUHJlc2VudCh0aGlzLmNvbG9yUm93c1tjZWxsQ29vcmRzLnJvd10pKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yUm93c1tjZWxsQ29vcmRzLnJvd11bY2VsbENvb3Jkcy5jb2xdO1xuICAgIH1cbiAgICBnZXROZXh0Q2VsbChjdXJyZW50LCBob3Jpem9udGFsU3RlcCwgdmVydGljYWxTdGVwKSB7XG4gICAgICAgIGlmICghKGlzUHJlc2VudChjdXJyZW50KSAmJiBpc1ByZXNlbnQoY3VycmVudC5yb3cpICYmIGlzUHJlc2VudChjdXJyZW50LmNvbCkpKSB7XG4gICAgICAgICAgICByZXR1cm4geyByb3c6IDAsIGNvbDogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuY2xhbXBJbmRleChjdXJyZW50LnJvdyArIHZlcnRpY2FsU3RlcCwgdGhpcy5jb2xvclJvd3MubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY2xhbXBJbmRleChjdXJyZW50LmNvbCArIGhvcml6b250YWxTdGVwLCB0aGlzLmNvbG9yUm93c1tyb3ddLmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4geyByb3csIGNvbCB9O1xuICAgIH1cbiAgICBjbGFtcEluZGV4KGluZGV4LCBtYXgpIHtcbiAgICAgICAgY29uc3QgbWluQXJyYXlJbmRleCA9IDA7XG4gICAgICAgIGlmIChpbmRleCA8IG1pbkFycmF5SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW5BcnJheUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+IG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufTtcbkNvbG9yUGFsZXR0ZVNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIENvbG9yUGFsZXR0ZVNlcnZpY2UpO1xuXG52YXIgQ29sb3JQYWxldHRlQ29tcG9uZW50XzE7XG5jb25zdCBERUZBVUxUX1RJTEVfU0laRSA9IDI0O1xuY29uc3QgREVGQVVMVF9DT0xVTU5TX0NPVU5UID0gMTA7XG5jb25zdCBERUZBVUxUX1BSRVNFVCQxID0gJ29mZmljZSc7XG5jb25zdCBERUZBVUxUX0FDQ0VTU0lCTEVfUFJFU0VUJDEgPSAnYWNjZXNzaWJsZSc7XG5sZXQgc2VyaWFsJDEgPSAwO1xuLyoqXG4gKiBUaGUgQ29sb3JQYWxldHRlIGNvbXBvbmVudCBwcm92aWRlcyBhIHNldCBvZiBwcmVkZWZpbmVkIHBhbGV0dGUgcHJlc2V0cyBhbmQgZW5hYmxlcyB5b3UgdG8gaW1wbGVtZW50IGEgY3VzdG9tIGNvbG9yIHBhbGV0dGUuXG4gKiBUaGUgQ29sb3JQYWxldHRlIGlzIGluZGVwZW5kZW50bHkgdXNlZCBieSBga2VuZG8tY29sb3JwaWNrZXJgIGFuZCBjYW4gYmUgZGlyZWN0bHkgYWRkZWQgdG8gdGhlIHBhZ2UuXG4gKi9cbmxldCBDb2xvclBhbGV0dGVDb21wb25lbnQgPSBDb2xvclBhbGV0dGVDb21wb25lbnRfMSA9IGNsYXNzIENvbG9yUGFsZXR0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoaG9zdCwgc2VydmljZSwgY2RyLCByZW5kZXJlciwgbG9jYWxpemF0aW9uU2VydmljZSwgbmdab25lKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGBrLWNvbG9ycGFsZXR0ZS0ke3NlcmlhbCQxKyt9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgb3V0cHV0IGZvcm1hdCBvZiB0aGUgQ29sb3JQYWxldHRlQ29tcG9uZW50LlxuICAgICAgICAgKiBUaGUgaW5wdXQgdmFsdWUgbWF5IGJlIGluIGEgZGlmZmVyZW50IGZvcm1hdC4gSG93ZXZlciwgaXQgd2lsbCBiZSBwYXJzZWQgaW50byB0aGUgb3V0cHV0IGBmb3JtYXRgXG4gICAgICAgICAqIGFmdGVyIHRoZSBjb21wb25lbnQgcHJvY2Vzc2VzIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgc3VwcG9ydGVkIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICogKERlZmF1bHQpIGBoZXhgXG4gICAgICAgICAqICogYHJnYmFgXG4gICAgICAgICAqICogYG5hbWVgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvcm1hdCA9ICdoZXgnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhlIENvbG9yUGFsZXR0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHJlYWQtb25seSBzdGF0ZSBvZiB0aGUgQ29sb3JQYWxldHRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBzaXplIG9mIGEgY29sb3IgY2VsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICogKERlZmF1bHQpIGB0aWxlU2l6ZSA9IDI0YFxuICAgICAgICAgKiAqIGB7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH1gXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbGVTaXplID0geyB3aWR0aDogREVGQVVMVF9USUxFX1NJWkUsIGhlaWdodDogREVGQVVMVF9USUxFX1NJWkUgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgY29sb3Igc2VsZWN0aW9uIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgc2VsZWN0cyBhIGNlbGwgd2l0aCB0aGUgbW91c2Ugb3IgcHJlc3NlcyBgRW50ZXJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNlbGxTZWxlY3Rpb24gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5pcXVlSWQgPSBndWlkKCk7XG4gICAgICAgIHRoaXMuX3RhYmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkID0gKCkgPT4geyB9O1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uID0gbG9jYWxpemF0aW9uU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBwYWxldHRlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHZhbHVlIG9mIHRoZSBpbml0aWFsbHkgc2VsZWN0ZWQgY29sb3IuXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gcGFyc2VDb2xvciQxKHZhbHVlLCB0aGlzLmZvcm1hdCk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciBvZiBjb2x1bW5zIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgICogRGVmYXVsdHMgdG8gYDEwYC5cbiAgICAgKi9cbiAgICBzZXQgY29sdW1ucyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtaW5Db2x1bW5zQ291bnQgPSAxO1xuICAgICAgICB0aGlzLl9jb2x1bW5zID0gdmFsdWUgPiBtaW5Db2x1bW5zQ291bnQgPyB2YWx1ZSA6IG1pbkNvbHVtbnNDb3VudDtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29sb3IgcGFsZXR0ZSB0aGF0IHdpbGwgYmUgZGlzcGxheWVkLlxuICAgICAqXG4gICAgICogVGhlIHN1cHBvcnRlZCB2YWx1ZXMgYXJlOlxuICAgICAqICogVGhlIG5hbWUgb2YgdGhlIHByZWRlZmluZWQgcGFsZXR0ZSBwcmVzZXQgKGZvciBleGFtcGxlLCBgb2ZmaWNlYCwgYGJhc2ljYCwgYW5kIGBhcGV4YCkuXG4gICAgICogKiBBIHN0cmluZyB3aXRoIGNvbW1hLXNlcGFyYXRlZCBjb2xvcnMuXG4gICAgICogKiBBIHN0cmluZyBhcnJheS5cbiAgICAgKi9cbiAgICBzZXQgcGFsZXR0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gREVGQVVMVF9QUkVTRVQkMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBpc1ByZXNlbnQoUEFMRVRURVBSRVNFVFNbdmFsdWVdKSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gdGhpcy5jb2x1bW5zIHx8IFBBTEVUVEVQUkVTRVRTW3ZhbHVlXS5jb2x1bW5zO1xuICAgICAgICAgICAgdmFsdWUgPSBQQUxFVFRFUFJFU0VUU1t2YWx1ZV0uY29sb3JzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSA/IHZhbHVlLnNwbGl0KCcsJykgOiB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcGFsZXR0ZSA9IGNvbG9ycy5tYXAoY29sb3IgPT4gcGFyc2VDb2xvciQxKGNvbG9yLCB0aGlzLmZvcm1hdCwgZmFsc2UsIGZhbHNlKSk7XG4gICAgfVxuICAgIGdldCBwYWxldHRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFsZXR0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBbdGFiaW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2V0IHRhYmluZGV4KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRhYmluZGV4ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5fdGFiaW5kZXggPSAhaXNOYU4odGFiaW5kZXgpID8gdGFiaW5kZXggOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGdldCB0YWJpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRpc2FibGVkID8gdGhpcy5fdGFiaW5kZXggOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdGlsZUxheW91dCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRpbGVTaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHRoaXMudGlsZVNpemUsIGhlaWdodDogdGhpcy50aWxlU2l6ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbG9yUm93cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5jb2xvclJvd3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaG9zdFRhYmluZGV4KCkgeyByZXR1cm4gdGhpcy50YWJpbmRleDsgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWRDbGFzcygpIHsgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7IH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHJlYWRvbmx5QXR0cmlidXRlKCkgeyByZXR1cm4gdGhpcy5yZWFkb25seTsgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5jb2xvclJvd3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0UHJlc2V0ID0gKHRoaXMuZm9ybWF0ICE9PSAnbmFtZScpID8gREVGQVVMVF9QUkVTRVQkMSA6IERFRkFVTFRfQUNDRVNTSUJMRV9QUkVTRVQkMTtcbiAgICAgICAgICAgIHRoaXMucGFsZXR0ZSA9IHRoaXMucGFsZXR0ZSB8fCBkZWZhdWx0UHJlc2V0O1xuICAgICAgICAgICAgdGhpcy5zZXRSb3dzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnNldEhvc3RFbGVtZW50QXJpYUxhYmVsKCk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5vblN0YWJsZS5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RDZWxsKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMucGFsZXR0ZSB8fCBjaGFuZ2VzLmNvbHVtbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Um93cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnBhbGV0dGUgfHwgY2hhbmdlcy52YWx1ZSB8fCBjaGFuZ2VzLmNvbHVtbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Q2VsbCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SG9zdEVsZW1lbnRBcmlhTGFiZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgICAgICBjb25zdCBpc1JUTCA9IHRoaXMuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEtleXMuQXJyb3dEb3duOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2VsbE5hdmlnYXRpb24oMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuQXJyb3dVcDpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNlbGxOYXZpZ2F0aW9uKDAsIC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS2V5cy5BcnJvd1JpZ2h0OlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2VsbE5hdmlnYXRpb24oaXNSVEwgPyAtMSA6IDEsIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkFycm93TGVmdDpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNlbGxOYXZpZ2F0aW9uKGlzUlRMID8gMSA6IC0xLCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS2V5cy5FbnRlcjpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVudGVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUhvc3RCbHVyKCkge1xuICAgICAgICB0aGlzLm5vdGlmeU5nVG91Y2hlZCgpO1xuICAgICAgICB0aGlzLmhhbmRsZUNlbGxGb2N1c09uQmx1cigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQ2VsbFNlbGVjdGlvbih2YWx1ZSwgZm9jdXNlZENlbGwpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGVkQ2VsbCA9IGZvY3VzZWRDZWxsO1xuICAgICAgICB0aGlzLmZvY3VzZWRDZWxsID0gdGhpcy5zZWxlY3RlZENlbGw7XG4gICAgICAgIHRoaXMuZm9jdXNJbkNvbXBvbmVudCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHBhcnNlZENvbG9yID0gcGFyc2VDb2xvciQxKHZhbHVlLCB0aGlzLmZvcm1hdCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jZWxsU2VsZWN0aW9uLmVtaXQocGFyc2VkQ29sb3IpO1xuICAgICAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKHBhcnNlZENvbG9yKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICE9PSBwYXJzZWRDb2xvcikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBwYXJzZWRDb2xvcjtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQocGFyc2VkQ29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb2N1c2VkQ2VsbCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsSWQgPSBgay0ke3RoaXMuc2VsZWN0ZWRDZWxsLnJvd30tJHt0aGlzLnNlbGVjdGVkQ2VsbC5jb2x9LSR7dGhpcy51bmlxdWVJZH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3RDZWxsKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ0NoYW5nZWQgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMubm90aWZ5TmdUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXNlZCBieSB0aGUgRmxvYXRpbmdMYWJlbCB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY29sb3IgdmFsdWUgb2YgdGhlIENvbG9yUGFsZXR0ZS5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkQ2VsbCA9IG51bGw7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGVkQ2VsbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFuZGxlVmFsdWVDaGFuZ2UoY29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQoY29sb3IpO1xuICAgICAgICB0aGlzLm5vdGlmeU5nQ2hhbmdlZChjb2xvcik7XG4gICAgICAgIHRoaXMuc2V0SG9zdEVsZW1lbnRBcmlhTGFiZWwoKTtcbiAgICB9XG4gICAgaGFuZGxlQ2VsbEZvY3VzT25CbHVyKCkge1xuICAgICAgICB0aGlzLmZvY3VzSW5Db21wb25lbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb2N1c2VkQ2VsbCA9IHRoaXMuc2VsZWN0ZWRDZWxsO1xuICAgIH1cbiAgICBzZWxlY3RDZWxsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDZWxsID0gdGhpcy5zZXJ2aWNlLmdldENlbGxDb29yZHNGb3IodmFsdWUpO1xuICAgICAgICB0aGlzLmZvY3VzZWRDZWxsID0gdGhpcy5zZWxlY3RlZENlbGw7XG4gICAgfVxuICAgIHNldFJvd3MoKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMucGFsZXR0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbnMgPSB0aGlzLmNvbHVtbnMgfHwgREVGQVVMVF9DT0xVTU5TX0NPVU5UO1xuICAgICAgICB0aGlzLnNlcnZpY2Uuc2V0Q29sb3JNYXRyaXgodGhpcy5wYWxldHRlLCB0aGlzLmNvbHVtbnMpO1xuICAgIH1cbiAgICBoYW5kbGVDZWxsTmF2aWdhdGlvbihob3Jpem9udGFsU3RlcCwgdmVydGljYWxTdGVwKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2N1c2VkQ2VsbCA9IHRoaXMuc2VydmljZS5nZXROZXh0Q2VsbCh0aGlzLmZvY3VzZWRDZWxsLCBob3Jpem9udGFsU3RlcCwgdmVydGljYWxTdGVwKTtcbiAgICAgICAgdGhpcy5mb2N1c0luQ29tcG9uZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgc2V0SG9zdEVsZW1lbnRBcmlhTGFiZWwoKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQ29sb3IkMSh0aGlzLnZhbHVlLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50LCAnYXJpYS1sYWJlbCcsIGAke3RoaXMudmFsdWUgPyBwYXJzZWQgOiB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KCdjb2xvclBhbGV0dGVOb0NvbG9yJyl9YCk7XG4gICAgfVxuICAgIGhhbmRsZUVudGVyKCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLmZvY3VzZWRDZWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ29sb3IgPSB0aGlzLnNlcnZpY2UuZ2V0Q29sb3JBdCh0aGlzLmZvY3VzZWRDZWxsKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDZWxsU2VsZWN0aW9uKHNlbGVjdGVkQ29sb3IsIHRoaXMuZm9jdXNlZENlbGwpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5kaXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQYWxldHRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmlkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ29sb3JQYWxldHRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWxldHRlSWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBhbGV0dGVDb21wb25lbnQucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBhbGV0dGVDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBDb2xvclBhbGV0dGVDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBDb2xvclBhbGV0dGVDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbnNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIENvbG9yUGFsZXR0ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGFsZXR0ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgQ29sb3JQYWxldHRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2xvclBhbGV0dGVDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sb3JQYWxldHRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sb3JQYWxldHRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWxlU2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENvbG9yUGFsZXR0ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0aW9uQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sb3JQYWxldHRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENvbG9yUGFsZXR0ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFNlbGVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBDb2xvclBhbGV0dGVDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RUYWJpbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWNvbG9ycGFsZXR0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sb3JQYWxldHRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0Q2xhc3Nlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1kaXNhYmxlZCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXN0YXRlLWRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIENvbG9yUGFsZXR0ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtcmVhZG9ubHknKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ29sb3JQYWxldHRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkb25seUF0dHJpYnV0ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgQ29sb3JQYWxldHRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYW5kbGVLZXlkb3duXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCdibHVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBDb2xvclBhbGV0dGVDb21wb25lbnQucHJvdG90eXBlLCBcImhhbmRsZUhvc3RCbHVyXCIsIG51bGwpO1xuQ29sb3JQYWxldHRlQ29tcG9uZW50ID0gQ29sb3JQYWxldHRlQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvQ29sb3JQYWxldHRlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jb2xvcnBhbGV0dGUnLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDb2xvclBhbGV0dGVDb21wb25lbnRfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtlbmRvSW5wdXQsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sb3JQYWxldHRlQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ29sb3JQYWxldHRlU2VydmljZSxcbiAgICAgICAgICAgIENvbG9yUGFsZXR0ZUxvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogQ29sb3JQYWxldHRlTG9jYWxpemF0aW9uU2VydmljZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmNvbG9ycGFsZXR0ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBrZW5kb0NvbG9yUGFsZXR0ZUxvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLWNvbG9yUGFsZXR0ZU5vQ29sb3I9XCJrZW5kby5jb2xvcnBhbGV0dGUuY29sb3JQYWxldHRlTm9Db2xvcnxUaGUgYXJpYS1sYWJlbCBhcHBsaWVkIHRvIHRoZSBDb2xvclBhbGV0dGUgY29tcG9uZW50IHdoZW4gdGhlIHZhbHVlIGlzIGVtcHR5LlwiXG4gICAgICAgICAgICBjb2xvclBhbGV0dGVOb0NvbG9yPVwiQ29sb3JwYWxldHRlIG5vIGNvbG9yIGNob3NlblwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPGRpdiByb2xlPVwibGlzdGJveFwiIGNsYXNzPVwiay1jb2xvcnBhbGV0dGUtdGFibGUtd3JhcFwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiYWN0aXZlQ2VsbElkXCI+XG4gICAgICAgICAgICA8dGFibGUgY2xhc3M9XCJrLWNvbG9ycGFsZXR0ZS10YWJsZSBrLXBhbGV0dGVcIj5cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgIDx0ciAqbmdGb3I9XCJsZXQgcm93IG9mIGNvbG9yUm93czsgbGV0IHJvd0luZGV4ID0gaW5kZXhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCAqbmdGb3I9XCJsZXQgY29sb3Igb2Ygcm93OyBsZXQgY29sSW5kZXggPSBpbmRleFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cIm9wdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstc3RhdGUtc2VsZWN0ZWRdPVwic2VsZWN0ZWRDZWxsPy5yb3cgPT09IHJvd0luZGV4ICYmIHNlbGVjdGVkQ2VsbD8uY29sID09PSBjb2xJbmRleFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstc3RhdGUtZm9jdXNdPVwiZm9jdXNJbkNvbXBvbmVudCAmJiBmb2N1c2VkQ2VsbD8ucm93ID09PSByb3dJbmRleCAmJiBmb2N1c2VkQ2VsbD8uY29sID09PSBjb2xJbmRleFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJzZWxlY3RlZENlbGw/LnJvdyA9PT0gcm93SW5kZXggJiYgc2VsZWN0ZWRDZWxsPy5jb2wgPT09IGNvbEluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImNvbG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstY29sb3JwYWxldHRlLXRpbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpZF09XCInay0nICsgcm93SW5kZXggKyAnLScgKyBjb2xJbmRleCArICctJyArIHVuaXF1ZUlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci52YWx1ZV09XCJjb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImhhbmRsZUNlbGxTZWxlY3Rpb24oY29sb3IsIHsgcm93OiByb3dJbmRleCwgY29sOiBjb2xJbmRleCB9KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nU3R5bGVdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGlsZUxheW91dC53aWR0aCArICdweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGlsZUxheW91dC5oZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogdGlsZUxheW91dC53aWR0aCArICdweCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICA8L2Rpdj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBDb2xvclBhbGV0dGVTZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmVdKVxuXSwgQ29sb3JQYWxldHRlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBGbGF0Q29sb3JQaWNrZXJIZWFkZXJDb21wb25lbnQgPSBjbGFzcyBGbGF0Q29sb3JQaWNrZXJIZWFkZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIHRoaXMudmlld0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZVBhbmVDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jbGVhckJ1dHRvbkNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBvblZpZXdCdXR0b25DbGljayh2aWV3KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudmlld0NoYW5nZS5lbWl0KHZpZXcpO1xuICAgIH1cbiAgICBnZXQgdmlld0J1dHRvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzICYmIHRoaXMudmlld3MuaW5kZXhPZignZ3JhZGllbnQnKSA+PSAwICYmIHRoaXMudmlld3MuaW5kZXhPZigncGFsZXR0ZScpID49IDA7XG4gICAgfVxuICAgIGdldFZpZXdCdXR0b25JY29uKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcgPT09ICdncmFkaWVudCcgPyAnay1pLWNvbG9yLWNhbnZhcycgOiAnay1pLXBhbGV0dGUnO1xuICAgIH1cbiAgICBnZXRUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQodGV4dCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWNvbG9yZWRpdG9yLWhlYWRlcicpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWhzdGFjaycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRmxhdENvbG9yUGlja2VySGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0Q2xhc3Nlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEZsYXRDb2xvclBpY2tlckhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xlYXJCdXR0b25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZsYXRDb2xvclBpY2tlckhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBGbGF0Q29sb3JQaWNrZXJIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZpZXdzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRmxhdENvbG9yUGlja2VySGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmV2aWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGbGF0Q29sb3JQaWNrZXJIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGbGF0Q29sb3JQaWNrZXJIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEZsYXRDb2xvclBpY2tlckhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmlld0NoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEZsYXRDb2xvclBpY2tlckhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVQYW5lQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBGbGF0Q29sb3JQaWNrZXJIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNsZWFyQnV0dG9uQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZHJlbigndmlld0J1dHRvbnMnLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIEZsYXRDb2xvclBpY2tlckhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmlld0J1dHRvbnNDb2xsZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2NsZWFyQnV0dG9uJywgeyByZWFkOiBFbGVtZW50UmVmLCBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgRmxhdENvbG9yUGlja2VySGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbGVhckJ1dHRvbkVsZW1lbnRcIiwgdm9pZCAwKTtcbkZsYXRDb2xvclBpY2tlckhlYWRlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRmxhdENvbG9yUGlja2VySGVhZGVyXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLWNvbG9yZWRpdG9yLWhlYWRlci1hY3Rpb25zIGstaHN0YWNrXCI+XG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwidmlld0J1dHRvbnNcIiBjbGFzcz1cImstYnV0dG9uLWdyb3VwIGstYnV0dG9uLWdyb3VwLWZsYXRcIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uICpuZ0Zvcj1cImxldCB2aWV3IG9mIHZpZXdzXCJcbiAgICAgICAgICAgICAgICAgICAgI3ZpZXdCdXR0b25zXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwib25WaWV3QnV0dG9uQ2xpY2sodmlldylcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uIGstYnV0dG9uLW1kIGstYnV0dG9uLWZsYXQgay1idXR0b24tZmxhdC1iYXNlIGstaWNvbi1idXR0b25cIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJnZXRUZXh0KHZpZXcgPT09ICdncmFkaWVudCcgPyAnZ3JhZGllbnRWaWV3JyA6ICdwYWxldHRlVmlldycpXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJnZXRUZXh0KHZpZXcgPT09ICdncmFkaWVudCcgPyAnZ3JhZGllbnRWaWV3JyA6ICdwYWxldHRlVmlldycpXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1wcmVzc2VkXT1cImFjdGl2ZVZpZXcgPT09IHZpZXdcIlxuICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJhY3RpdmVWaWV3ID09PSB2aWV3ID8gJ2stc3RhdGUtc2VsZWN0ZWQnIDogJydcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1idXR0b24taWNvbiBrLWljb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiZ2V0Vmlld0J1dHRvbkljb24odmlldylcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1zcGFjZXJcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImstY29sb3JlZGl0b3ItaGVhZGVyLWFjdGlvbnMgay1oc3RhY2tcIj5cbiAgICAgICAgICAgIDxidXR0b24gKm5nSWY9XCJjbGVhckJ1dHRvblwiXG4gICAgICAgICAgICAgICAgI2NsZWFyQnV0dG9uXG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvbiBrLWJ1dHRvbi1tZCBrLWJ1dHRvbi1mbGF0IGstYnV0dG9uLWZsYXQtYmFzZSBrLWljb24tYnV0dG9uIGstY29sb3JlZGl0b3ItcmVzZXRcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiZ2V0VGV4dCgnY2xlYXJCdXR0b24nKVwiXG4gICAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwiZ2V0VGV4dCgnY2xlYXJCdXR0b24nKVwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cImNsZWFyQnV0dG9uQ2xpY2suZW1pdCgpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1idXR0b24taWNvbiBrLWljb24gay1pLXJlc2V0LWNvbG9yXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1jb2xvcmVkaXRvci1wcmV2aWV3IGstdnN0YWNrXCIgKm5nSWY9XCJwcmV2aWV3XCI+XG4gICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWNvbG9yZWRpdG9yLXByZXZpZXctY29sb3Igay1jb2xvci1wcmV2aWV3XCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwiZ2V0VGV4dCgncHJldmlld0NvbG9yJylcIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUuYmFja2dyb3VuZC1jb2xvcl09XCJzZWxlY3Rpb25cIj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWNvbG9yZWRpdG9yLWN1cnJlbnQtY29sb3Igay1jb2xvci1wcmV2aWV3XCJcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmJhY2tncm91bmQtY29sb3JdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJnZXRUZXh0KCdyZXZlcnRTZWxlY3Rpb24nKVwiXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJ2YWx1ZVBhbmVDbGljay5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBGbGF0Q29sb3JQaWNrZXJIZWFkZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEZsYXRDb2xvclBpY2tlckFjdGlvbkJ1dHRvbnNDb21wb25lbnQgPSBjbGFzcyBGbGF0Q29sb3JQaWNrZXJBY3Rpb25CdXR0b25zQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmFjdGlvbkJ1dHRvbkNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBnZXRUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQodGV4dCk7XG4gICAgfVxuICAgIG9uQWN0aW9uQnV0dG9uQ2xpY2sodHlwZSwgZXYpIHtcbiAgICAgICAgbGV0IGFyZ3MgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHR5cGUsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjdGlvbkJ1dHRvbkNsaWNrLmVtaXQoYXJncyk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWNvbG9yZWRpdG9yLWZvb3RlcicpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWFjdGlvbnMnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1oc3RhY2snKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEZsYXRDb2xvclBpY2tlckFjdGlvbkJ1dHRvbnNDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRmxhdENvbG9yUGlja2VyQWN0aW9uQnV0dG9uc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aW9uQnV0dG9uQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnbGFzdCcsIHsgcmVhZDogRWxlbWVudFJlZiwgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIEZsYXRDb2xvclBpY2tlckFjdGlvbkJ1dHRvbnNDb21wb25lbnQucHJvdG90eXBlLCBcImxhc3RCdXR0b25cIiwgdm9pZCAwKTtcbkZsYXRDb2xvclBpY2tlckFjdGlvbkJ1dHRvbnNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0ZsYXRDb2xvclBpY2tlckFjdGlvbkJ1dHRvbnNdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3M9XCJrLWNvbG9yZWRpdG9yLWNhbmNlbCBrLWJ1dHRvbiBrLWJ1dHRvbi1tZCBrLWJ1dHRvbi1zb2xpZCBrLWJ1dHRvbi1zb2xpZC1iYXNlXCJcbiAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImdldFRleHQoJ2NhbmNlbEJ1dHRvbicpXCJcbiAgICAgICAgICAgIChjbGljayk9XCJvbkFjdGlvbkJ1dHRvbkNsaWNrKCdjYW5jZWwnLCAkZXZlbnQpXCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICA+e3tnZXRUZXh0KCdjYW5jZWxCdXR0b24nKX19PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gI2xhc3RcbiAgICAgICAgICAgIGNsYXNzPVwiay1jb2xvcmVkaXRvci1hcHBseSBrLWJ1dHRvbiBrLWJ1dHRvbi1tZCBrLWJ1dHRvbi1zb2xpZCBrLWJ1dHRvbi1zb2xpZC1wcmltYXJ5XCJcbiAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImdldFRleHQoJ2FwcGx5QnV0dG9uJylcIlxuICAgICAgICAgICAgKGNsaWNrKT1cIm9uQWN0aW9uQnV0dG9uQ2xpY2soJ2FwcGx5JywgJGV2ZW50KVwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgPnt7Z2V0VGV4dCgnYXBwbHlCdXR0b24nKX19PC9idXR0b24+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBGbGF0Q29sb3JQaWNrZXJBY3Rpb25CdXR0b25zQ29tcG9uZW50KTtcblxudmFyIEZsYXRDb2xvclBpY2tlckNvbXBvbmVudF8xO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgRmxhdENvbG9yUGlja2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19mbGF0Y29sb3JwaWNrZXIgJX0pLlxuICpcbiAqIFRoZSBGbGF0Q29sb3JQaWNrZXIgaXMgYSBwb3dlcmZ1bCB0b29sIHdoaWNoIGFsbG93cyB0aGUgdXNlciB0byBjaG9vc2UgY29sb3JzIHRocm91Z2ggcGFsZXR0ZXMgd2l0aCBwcmVkZWZpbmVkIHNldHMgb2YgY29sb3JzIGFuZFxuICogdGhyb3VnaCBhIGdyYWRpZW50IHRoYXQgcmVuZGVycyBhbiBoc3YgY2FudmFzLiBJdCBzdXBwb3J0cyBwcmV2aWV3aW5nIHRoZSBzZWxlY3RlZCBjb2xvciwgcmV2ZXJ0aW5nIGl0IHRvIGl0cyBwcmV2aW91cyBzdGF0ZSBvciBjbGVhcmluZyBpdCBjb21wbGV0ZWx5LlxuICovXG5sZXQgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50ID0gRmxhdENvbG9yUGlja2VyQ29tcG9uZW50XzEgPSBjbGFzcyBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QsIHNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UsIGNkciwgcmVuZGVyZXIsIG5nWm9uZSkge1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIEZsYXRDb2xvclBpY2tlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBGbGF0Q29sb3JQaWNrZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG91dHB1dCBmb3JtYXQgb2YgdGhlIEZsYXRDb2xvclBpY2tlci5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGlucHV0IHZhbHVlIGlzIGluIGEgZGlmZmVyZW50IGZvcm1hdCwgaXQgd2lsbCBiZSBwYXJzZWQgaW50byB0aGUgc3BlY2lmaWVkIG91dHB1dCBgZm9ybWF0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHN1cHBvcnRlZCB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIGByZ2JhYCAoZGVmYXVsdClcbiAgICAgICAgICogKiBgaGV4YFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSAncmdiYSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgRmxhdENvbG9yUGlja2VyIHNob3VsZCBkaXNwbGF5IGEgJ0NsZWFyIGNvbG9yJyBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJCdXR0b24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheXMgYEFwcGx5YCBhbmQgYENhbmNlbGAgYWN0aW9uIGJ1dHRvbnMgYW5kIGEgY29sb3IgcHJldmlldyBwYW5lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIGVuYWJsZWQsIHRoZSBjb21wb25lbnQgdmFsdWUgd2lsbCBub3QgY2hhbmdlIGltbWVkaWF0ZWx5IHVwb25cbiAgICAgICAgICogY29sb3Igc2VsZWN0aW9uLCBidXQgb25seSBhZnRlciB0aGUgYEFwcGx5YCBidXR0b24gaXMgY2xpY2tlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGBDYW5jZWxgIGJ1dHRvbiByZXZlcnRzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0byBpdHNcbiAgICAgICAgICogaW5pdGlhbCBzdGF0ZSBpLmUuIHRvIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZpZXcgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJlcyB0aGUgbGF5b3V0IG9mIHRoZSBgQXBwbHlgIGFuZCBgQ2FuY2VsYCBhY3Rpb24gYnV0dG9ucy5cbiAgICAgICAgICogKiBgc3RhcnRgXG4gICAgICAgICAqICogYGNlbnRlcmBcbiAgICAgICAgICogKiBgZW5kYCAoZGVmYXVsdClcbiAgICAgICAgICogKiBgc3RyZXRjaGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aW9uc0xheW91dCA9ICdlbmQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSB2aWV3cyB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuIERlZmF1bHQgdmFsdWUgaXMgZ3JhZGllbnQgYW5kIHBhbGV0dGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpZXdzID0gWydncmFkaWVudCcsICdwYWxldHRlJ107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGNvbXBvbmVudCB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2FuY2VscyB0aGUgY3VycmVudCBjb2xvciBzZWxlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBldmVudCBpcyBlbWl0dGVkIG9uIHByZXZpZXcgcGFuZSBvciBvbiAnQ2FuY2VsJyBidXR0b24gY2xpY2suXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdmlldyBpcyBhYm91dCB0byBjaGFuZ2UuXG4gICAgICAgICAqIFVzZWQgdG8gcHJvdmlkZSBhIHR3by13YXkgYmluZGluZyBmb3IgdGhlIGBhY3RpdmVWaWV3YCBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlVmlld0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aW9uQnV0dG9uQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX3RhYmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fZ3JhZGllbnRTZXR0aW5ncyA9IHsgb3BhY2l0eTogdHJ1ZSwgZGVsYXk6IDAgfTtcbiAgICAgICAgdGhpcy5fcGFsZXR0ZVNldHRpbmdzID0ge307XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ0NoYW5nZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMubm90aWZ5TmdUb3VjaGVkID0gKCkgPT4geyB9O1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIGdldCBhcmlhUmVhZG9ubHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRvbmx5O1xuICAgIH1cbiAgICBnZXQgaG9zdFRhYmluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBpbml0aWFsbHkgc2VsZWN0ZWQgY29sb3IuXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gcGFyc2VDb2xvciQxKHZhbHVlLCB0aGlzLmZvcm1hdCwgdGhpcy5ncmFkaWVudFNldHRpbmdzLm9wYWNpdHkpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBbdGFiaW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc2V0IHRhYmluZGV4KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRhYmluZGV4ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5fdGFiaW5kZXggPSAhaXNOYU4odGFiaW5kZXgpID8gdGFiaW5kZXggOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGdldCB0YWJpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRpc2FibGVkID8gdGhpcy5fdGFiaW5kZXggOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGdyYWRpZW50IHZpZXcuXG4gICAgICovXG4gICAgc2V0IGdyYWRpZW50U2V0dGluZ3ModmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9ncmFkaWVudFNldHRpbmdzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBncmFkaWVudFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhZGllbnRTZXR0aW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgcGFsZXR0ZSB2aWV3LlxuICAgICAqL1xuICAgIHNldCBwYWxldHRlU2V0dGluZ3ModmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9wYWxldHRlU2V0dGluZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHBhbGV0dGVTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhbGV0dGVTZXR0aW5ncztcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy5fcGFsZXR0ZVNldHRpbmdzID0gdGhpcy5zZXJ2aWNlLmdldFBhbGV0dGVTZXR0aW5ncyh0aGlzLl9wYWxldHRlU2V0dGluZ3MsIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVWaWV3KCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXRIb3N0RWxlbWVudEFyaWFMYWJlbCgpO1xuICAgICAgICB0aGlzLmluaXREb21FdmVudHMoKTtcbiAgICAgICAgdGhpcy5zZXRTaXppbmdWYXJpYWJsZXMoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNDaGFuZ2VkKCd2YWx1ZScsIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNldEhvc3RFbGVtZW50QXJpYUxhYmVsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2hhbmdlZCgncGFsZXR0ZVNldHRpbmdzJywgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2l6aW5nVmFyaWFibGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhlYWRlckhhc0NvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpZXcgfHwgdGhpcy52aWV3cy5sZW5ndGggPiAxIHx8IHRoaXMuY2xlYXJCdXR0b247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIGJ5IHRoZSBGbG9hdGluZ0xhYmVsIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgd3JhcHBlciBvZiB0aGUgRmxhdENvbG9yUGlja2VyLlxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCAmJiB0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvc3QubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgd3JhcHBlciBvZiB0aGUgRmxhdENvbG9yUGlja2VyLlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQoKTtcbiAgICAgICAgdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSB2YWx1ZSBvZiB0aGUgRmxhdENvbG9yUGlja2VyLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2V0SG9zdEVsZW1lbnRBcmlhTGFiZWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uVmlld0NoYW5nZSh2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVZpZXcgPT09IHZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXdDaGFuZ2UuZW1pdCh2aWV3KTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlVmlldyA9PT0gJ2dyYWRpZW50Jykge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYWRpZW50LmdyYWRpZW50RHJhZ0hhbmRsZS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25DbGVhckJ1dHRvbkNsaWNrKCkge1xuICAgICAgICB0aGlzLnJlc2V0SW5uZXJDb21wb25lbnRWYWx1ZSgpO1xuICAgICAgICB0aGlzLmhvc3QubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlVmFsdWVDaGFuZ2UoY29sb3IpIHtcbiAgICAgICAgdGhpcy5wcmV2aWV3ID8gdGhpcy5jaGFuZ2VDdXJyZW50VmFsdWUoY29sb3IpIDogdGhpcy5zZXRGbGF0Q29sb3JQaWNrZXJWYWx1ZShjb2xvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkFjdGlvbihldikge1xuICAgICAgICBldi50YXJnZXQgPT09ICdhcHBseScgPyB0aGlzLnNldEZsYXRDb2xvclBpY2tlclZhbHVlKHRoaXMuc2VsZWN0aW9uKSA6IHRoaXMucmVzZXRTZWxlY3Rpb24oZXYub3JpZ2luYWxFdmVudCk7XG4gICAgICAgIHRoaXMuYWN0aW9uQnV0dG9uQ2xpY2suZW1pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm5vdGlmeU5nVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlc2V0U2VsZWN0aW9uKGV2KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IG5ldyBDb2xvclBpY2tlckNhbmNlbEV2ZW50KGV2KTtcbiAgICAgICAgdGhpcy5jYW5jZWwuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICBpZiAoIWV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5TmdUb3VjaGVkKCk7XG4gICAgfVxuICAgIHNldEhvc3RFbGVtZW50QXJpYUxhYmVsKCkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvbG9yJDEodGhpcy52YWx1ZSwgdGhpcy5mb3JtYXQsIHRoaXMuZ3JhZGllbnRTZXR0aW5ncy5vcGFjaXR5KTtcbiAgICAgICAgY29uc3QgYXJpYUxhYmVsVmFsdWUgPSBgJHt0aGlzLnZhbHVlID8gcGFyc2VkIDogdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmdldCgnZmxhdENvbG9yUGlja2VyTm9Db2xvcicpfWA7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50LCAnYXJpYS1sYWJlbCcsIGFyaWFMYWJlbFZhbHVlKTtcbiAgICB9XG4gICAgc2V0U2l6aW5nVmFyaWFibGVzKCkge1xuICAgICAgICBjb25zdCBwYWxldHRlVGlsZVNpemUgPSB0aGlzLnNlcnZpY2UucGFsZXR0ZVRpbGVMYXlvdXQodGhpcy5wYWxldHRlU2V0dGluZ3MudGlsZVNpemUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGAtLWtlbmRvLWNvbG9yLXByZXZpZXctY29sdW1uczogJHt0aGlzLnBhbGV0dGVTZXR0aW5ncy5jb2x1bW5zfTtcbiAgICAgICAgICAgIC0ta2VuZG8tY29sb3ItcHJldmlldy13aWR0aDogJHtwYWxldHRlVGlsZVNpemUud2lkdGh9cHg7XG4gICAgICAgICAgICAtLWtlbmRvLWNvbG9yLXByZXZpZXctaGVpZ2h0OiAke3BhbGV0dGVUaWxlU2l6ZS5oZWlnaHR9cHg7YDtcbiAgICAgICAgdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmstY29sb3JlZGl0b3Itdmlld3Muay12c3RhY2snKS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdmFsdWUpO1xuICAgIH1cbiAgICBjaGFuZ2VDdXJyZW50VmFsdWUoY29sb3IpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBjb2xvcjtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQoKTtcbiAgICB9XG4gICAgcmVzZXRJbm5lckNvbXBvbmVudFZhbHVlKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmdyYWRpZW50KSB7XG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50LnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYWxldHRlLnJlc2V0KCk7XG4gICAgfVxuICAgIHNldEZsYXRDb2xvclBpY2tlclZhbHVlKGNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KGNvbG9yKTtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ0NoYW5nZWQoY29sb3IpO1xuICAgICAgICB0aGlzLnNldEhvc3RFbGVtZW50QXJpYUxhYmVsKCk7XG4gICAgfVxuICAgIHNldEFjdGl2ZVZpZXcoKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuYWN0aXZlVmlldykpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IHRoaXMudmlld3NbMF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpICYmIHRoaXMudmlld3MuaW5kZXhPZih0aGlzLmFjdGl2ZVZpZXcpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uOiBUaGUgY3VycmVudCBhY3RpdmVWaWV3IGlzIG5vdCBwcmVzZW50IGluIHRoZSB2aWV3cyBjb2xsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXREb21FdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5ob3N0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhvc3RFbGVtZW50ID0gdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1cycsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbihob3N0RWxlbWVudCwgJ2JsdXInLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWZsYXRjb2xvcnBpY2tlcicpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWNvbG9yZWRpdG9yJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcpLFxuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1yZWFkb25seScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFyaWFSZWFkb25seVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmRpcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RUYWJpbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNsZWFyQnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmV2aWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGlvbnNMYXlvdXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZsYXRDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZpZXdzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIEZsYXRDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRTZXR0aW5nc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWxldHRlU2V0dGluZ3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEZsYXRDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2FuY2VsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3Q2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3Rpb25CdXR0b25DbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdoZWFkZXInLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZsYXRDb2xvclBpY2tlckhlYWRlckNvbXBvbmVudClcbl0sIEZsYXRDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVhZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2dyYWRpZW50JywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2xvckdyYWRpZW50Q29tcG9uZW50KVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdwYWxldHRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2xvclBhbGV0dGVDb21wb25lbnQpXG5dLCBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBhbGV0dGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnZm9vdGVyJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGbGF0Q29sb3JQaWNrZXJBY3Rpb25CdXR0b25zQ29tcG9uZW50KVxuXSwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb290ZXJcIiwgdm9pZCAwKTtcbkZsYXRDb2xvclBpY2tlckNvbXBvbmVudCA9IEZsYXRDb2xvclBpY2tlckNvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb0ZsYXRDb2xvclBpY2tlcicsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZmxhdGNvbG9ycGlja2VyJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRmxhdENvbG9yUGlja2VyQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtlbmRvSW5wdXQsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRmxhdENvbG9yUGlja2VyQ29tcG9uZW50XzEpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgRmxhdENvbG9yUGlja2VyU2VydmljZSxcbiAgICAgICAgICAgIEZsYXRDb2xvclBpY2tlckxvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogRmxhdENvbG9yUGlja2VyTG9jYWxpemF0aW9uU2VydmljZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmZsYXRjb2xvcnBpY2tlcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBrZW5kb0ZsYXRDb2xvclBpY2tlckxvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLWZsYXRDb2xvclBpY2tlck5vQ29sb3I9XCJrZW5kby5mbGF0Y29sb3JwaWNrZXIuZmxhdENvbG9yUGlja2VyTm9Db2xvcnxUaGUgYXJpYS1sYWJlbCBhcHBsaWVkIHRvIHRoZSBGbGF0Q29sb3JQaWNrZXIgY29tcG9uZW50IHdoZW4gdGhlIHZhbHVlIGlzIGVtcHR5LlwiXG4gICAgICAgICAgICBmbGF0Q29sb3JQaWNrZXJOb0NvbG9yPVwiRmxhdGNvbG9ycGlja2VyIG5vIGNvbG9yIGNob3NlblwiXG4gICAgICAgICAgICBpMThuLWNvbG9yR3JhZGllbnROb0NvbG9yPVwia2VuZG8uZmxhdGNvbG9ycGlja2VyLmNvbG9yR3JhZGllbnROb0NvbG9yfFRoZSBhcmlhLWxhYmVsIGFwcGxpZWQgdG8gdGhlIENvbG9yR3JhZGllbnQgY29tcG9uZW50IHdoZW4gdGhlIHZhbHVlIGlzIGVtcHR5LlwiXG4gICAgICAgICAgICBjb2xvckdyYWRpZW50Tm9Db2xvcj1cIkNvbG9yZ3JhZGllbnQgbm8gY29sb3IgY2hvc2VuXCJcbiAgICAgICAgICAgIGkxOG4tY29sb3JQYWxldHRlTm9Db2xvcj1cImtlbmRvLmZsYXRjb2xvcnBpY2tlci5jb2xvclBhbGV0dGVOb0NvbG9yfFRoZSBhcmlhLWxhYmVsIGFwcGxpZWQgdG8gdGhlIENvbG9yUGFsZXR0ZSBjb21wb25lbnQgd2hlbiB0aGUgdmFsdWUgaXMgZW1wdHkuXCJcbiAgICAgICAgICAgIGNvbG9yUGFsZXR0ZU5vQ29sb3I9XCJDb2xvcnBhbGV0dGUgbm8gY29sb3IgY2hvc2VuXCJcbiAgICAgICAgICAgIGkxOG4tY29sb3JHcmFkaWVudEhhbmRsZT1cImtlbmRvLmZsYXRjb2xvcnBpY2tlci5jb2xvckdyYWRpZW50SGFuZGxlfFRoZSB0aXRsZSBmb3IgdGhlIGdyYWRpZW50IGNvbG9yIGRyYWcgaGFuZGxlIGNob29zZXIuXCJcbiAgICAgICAgICAgIGNvbG9yR3JhZGllbnRIYW5kbGU9XCJDaG9vc2UgY29sb3JcIlxuICAgICAgICAgICAgaTE4bi1jbGVhckJ1dHRvbj1cImtlbmRvLmZsYXRjb2xvcnBpY2tlci5jbGVhckJ1dHRvbnxUaGUgdGl0bGUgZm9yIHRoZSBjbGVhciBidXR0b24uXCJcbiAgICAgICAgICAgIGNsZWFyQnV0dG9uPVwiQ2xlYXIgdmFsdWVcIlxuICAgICAgICAgICAgaTE4bi1odWVTbGlkZXJIYW5kbGU9XCJrZW5kby5mbGF0Y29sb3JwaWNrZXIuaHVlU2xpZGVySGFuZGxlfFRoZSB0aXRsZSBmb3IgdGhlIGh1ZSBzbGlkZXIgaGFuZGxlLlwiXG4gICAgICAgICAgICBodWVTbGlkZXJIYW5kbGU9XCJTZXQgaHVlXCJcbiAgICAgICAgICAgIGkxOG4tb3BhY2l0eVNsaWRlckhhbmRsZT1cImtlbmRvLmZsYXRjb2xvcnBpY2tlci5vcGFjaXR5U2xpZGVySGFuZGxlfFRoZSB0aXRsZSBmb3IgdGhlIG9wYWNpdHkgc2xpZGVyIGhhbmRsZS5cIlxuICAgICAgICAgICAgb3BhY2l0eVNsaWRlckhhbmRsZT1cIlNldCBvcGFjaXR5XCJcbiAgICAgICAgICAgIGkxOG4tY29udHJhc3RSYXRpbz1cImtlbmRvLmZsYXRjb2xvcnBpY2tlci5jb250cmFzdFJhdGlvfFRoZSBjb250cmFzdCByYXRpbyBtZXNzYWdlIGZvciB0aGUgY29udHJhc3QgdG9vbC5cIlxuICAgICAgICAgICAgY29udHJhc3RSYXRpbz1cIkNvbnRyYXN0IHJhdGlvXCJcbiAgICAgICAgICAgIGkxOG4tcHJldmlld0NvbG9yPVwia2VuZG8uZmxhdGNvbG9ycGlja2VyLnByZXZpZXdDb2xvcnxUaGUgbWVzc2FnZSBmb3IgdGhlIGNvbG9yIHByZXZpZXcgcGFuZS5cIlxuICAgICAgICAgICAgcHJldmlld0NvbG9yPVwiQ29sb3IgcHJldmlld1wiXG4gICAgICAgICAgICBpMThuLXJldmVydFNlbGVjdGlvbj1cImtlbmRvLmZsYXRjb2xvcnBpY2tlci5yZXZlcnRTZWxlY3Rpb258VGhlIG1lc3NhZ2UgZm9yIHRoZSBzZWxlY3RlZCBjb2xvciBwYW5lLlwiXG4gICAgICAgICAgICByZXZlcnRTZWxlY3Rpb249XCJSZXZlcnQgc2VsZWN0aW9uXCJcbiAgICAgICAgICAgIGkxOG4tZ3JhZGllbnRWaWV3PVwia2VuZG8uZmxhdGNvbG9ycGlja2VyLmdyYWRpZW50Vmlld3xUaGUgbWVzc2FnZSBmb3IgdGhlIGdyYWRpZW50IHZpZXcgYnV0dG9uLlwiXG4gICAgICAgICAgICBncmFkaWVudFZpZXc9XCJHcmFkaWVudCB2aWV3XCJcbiAgICAgICAgICAgIGkxOG4tcGFsZXR0ZVZpZXc9XCJrZW5kby5mbGF0Y29sb3JwaWNrZXIucGFsZXR0ZVZpZXd8VGhlIG1lc3NhZ2UgZm9yIHRoZSBwYWxldHRlIHZpZXcgYnV0dG9uLlwiXG4gICAgICAgICAgICBwYWxldHRlVmlldz1cIlBhbGV0dGUgdmlld1wiXG4gICAgICAgICAgICBpMThuLWZvcm1hdEJ1dHRvbj1cImtlbmRvLmZsYXRjb2xvcnBpY2tlci5mb3JtYXRCdXR0b258VGhlIG1lc3NhZ2UgZm9yIHRoZSBpbnB1dCBmb3JtYXQgdG9nZ2xlIGJ1dHRvbi5cIlxuICAgICAgICAgICAgZm9ybWF0QnV0dG9uPVwiQ2hhbmdlIGNvbG9yIGZvcm1hdFwiXG4gICAgICAgICAgICBpMThuLWFwcGx5QnV0dG9uPVwia2VuZG8uZmxhdGNvbG9ycGlja2VyLmFwcGx5QnV0dG9ufFRoZSBtZXNzYWdlIGZvciB0aGUgQXBwbHkgYWN0aW9uIGJ1dHRvbi5cIlxuICAgICAgICAgICAgYXBwbHlCdXR0b249XCJBcHBseVwiXG4gICAgICAgICAgICBpMThuLWNhbmNlbEJ1dHRvbj1cImtlbmRvLmZsYXRjb2xvcnBpY2tlci5jYW5jZWxCdXR0b258VGhlIG1lc3NhZ2UgZm9yIHRoZSBDYW5jZWwgYWN0aW9uIGJ1dHRvbi5cIlxuICAgICAgICAgICAgY2FuY2VsQnV0dG9uPVwiQ2FuY2VsXCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8ZGl2IGtlbmRvRmxhdENvbG9yUGlja2VySGVhZGVyXG4gICAgICAgICAgICAqbmdJZj1cImhlYWRlckhhc0NvbnRlbnRcIlxuICAgICAgICAgICAgI2hlYWRlclxuICAgICAgICAgICAgW2NsZWFyQnV0dG9uXT1cImNsZWFyQnV0dG9uXCJcbiAgICAgICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdcIlxuICAgICAgICAgICAgW3ZpZXdzXT1cInZpZXdzXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICBbc2VsZWN0aW9uXT1cInNlbGVjdGlvblwiXG4gICAgICAgICAgICBbcHJldmlld109XCJwcmV2aWV3XCJcbiAgICAgICAgICAgIChjbGVhckJ1dHRvbkNsaWNrKT1cIm9uQ2xlYXJCdXR0b25DbGljaygpXCJcbiAgICAgICAgICAgICh2aWV3Q2hhbmdlKT1cIm9uVmlld0NoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICh2YWx1ZVBhbmVDbGljayk9XCJyZXNldFNlbGVjdGlvbigkZXZlbnQpXCI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1jb2xvcmVkaXRvci12aWV3cyBrLXZzdGFja1wiPlxuICAgICAgICAgICAgPGtlbmRvLWNvbG9yZ3JhZGllbnQgI2dyYWRpZW50XG4gICAgICAgICAgICAgICAgKm5nSWY9XCJhY3RpdmVWaWV3ID09PSAnZ3JhZGllbnQnXCJcbiAgICAgICAgICAgICAgICBbdGFiaW5kZXhdPVwibnVsbFwiXG4gICAgICAgICAgICAgICAgW3ZhbHVlXT1cInNlbGVjdGlvblwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgICAgIFtvcGFjaXR5XT1cImdyYWRpZW50U2V0dGluZ3Mub3BhY2l0eVwiXG4gICAgICAgICAgICAgICAgW2RlbGF5XT1cImdyYWRpZW50U2V0dGluZ3MuZGVsYXlcIlxuICAgICAgICAgICAgICAgIFtjb250cmFzdFRvb2xdPVwiZ3JhZGllbnRTZXR0aW5ncy5jb250cmFzdFRvb2xcIlxuICAgICAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZVZhbHVlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9rZW5kby1jb2xvcmdyYWRpZW50PlxuICAgICAgICAgICAgPGtlbmRvLWNvbG9ycGFsZXR0ZSAjcGFsZXR0ZVxuICAgICAgICAgICAgICAgICpuZ0lmPVwiYWN0aXZlVmlldyA9PT0gJ3BhbGV0dGUnXCJcbiAgICAgICAgICAgICAgICBrZW5kb0ZvY3VzT25Eb21SZWFkeVxuICAgICAgICAgICAgICAgIFtwYWxldHRlXT1cInBhbGV0dGVTZXR0aW5ncy5wYWxldHRlXCJcbiAgICAgICAgICAgICAgICBbY29sdW1uc109XCJwYWxldHRlU2V0dGluZ3MuY29sdW1uc1wiXG4gICAgICAgICAgICAgICAgW3RpbGVTaXplXT1cInBhbGV0dGVTZXR0aW5ncy50aWxlU2l6ZVwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJzZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwva2VuZG8tY29sb3JwYWxldHRlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBrZW5kb0ZsYXRDb2xvclBpY2tlckFjdGlvbkJ1dHRvbnMgKm5nSWY9XCJwcmV2aWV3XCJcbiAgICAgICAgICAgICNmb290ZXJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cIidrLWp1c3RpZnktY29udGVudC0nICsgYWN0aW9uc0xheW91dFwiXG4gICAgICAgICAgICAoYWN0aW9uQnV0dG9uQ2xpY2spPVwib25BY3Rpb24oJGV2ZW50KVwiPlxuICAgICAgICA8L2Rpdj5cbmBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIEZsYXRDb2xvclBpY2tlclNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQpO1xuXG52YXIgQ29sb3JQaWNrZXJDb21wb25lbnRfMTtcbmNvbnN0IERPTV9GT0NVU19FVkVOVFMgPSBbJ2ZvY3VzJywgJ2JsdXInXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIENvbG9yUGlja2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19jb2xvcnBpY2tlciAlfSkuXG4gKlxuICogVGhlIENvbG9yUGlja2VyIGlzIGEgcG93ZXJmdWwgdG9vbCBmb3IgY2hvb3NpbmcgY29sb3JzIGZyb20gR3JhZGllbnQgYW5kIFBhbGV0dGUgdmlld3NcbiAqIHdoaWNoIGFyZSByZW5kZXJlZCBpbiBpdHMgcG9wdXAuIEl0IHN1cHBvcnRzIHByZXZpZXdpbmcgdGhlIHNlbGVjdGVkIGNvbG9yLCByZXZlcnRpbmcgaXQgdG8gaXRzIHByZXZpb3VzIHN0YXRlIG9yIGNsZWFyaW5nIGl0IGNvbXBsZXRlbHkuXG4gKi9cbmxldCBDb2xvclBpY2tlckNvbXBvbmVudCA9IENvbG9yUGlja2VyQ29tcG9uZW50XzEgPSBjbGFzcyBDb2xvclBpY2tlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoaG9zdCwgcG9wdXBTZXJ2aWNlLCBjZHIsIGxvY2FsaXphdGlvblNlcnZpY2UsIG5nWm9uZSwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UgPSBwb3B1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb2xlID0gJ2xpc3Rib3gnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSB2aWV3cyB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgaW4gdGhlIHBvcHVwLlxuICAgICAgICAgKiBCeSBkZWZhdWx0IGJvdGggdGhlIGdyYWRpZW50IGFuZCBwYWxldHRlIHZpZXdzIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpZXdzID0gWydncmFkaWVudCcsICdwYWxldHRlJ107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIENvbG9yUGlja2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhlIENvbG9yUGlja2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBvdXRwdXQgZm9ybWF0IG9mIHRoZSBDb2xvclBpY2tlci5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGlucHV0IHZhbHVlIGlzIGluIGEgZGlmZmVyZW50IGZvcm1hdCwgaXQgd2lsbCBiZSBwYXJzZWQgaW50byB0aGUgc3BlY2lmaWVkIG91dHB1dCBgZm9ybWF0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHN1cHBvcnRlZCB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIGByZ2JhYCAoZGVmYXVsdClcbiAgICAgICAgICogKiBgaGV4YFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSAncmdiYSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgQ29sb3JQaWNrZXIgc2hvdWxkIGRpc3BsYXkgYSAnQ2xlYXIgY29sb3InIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhckJ1dHRvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5cyBgQXBwbHlgIGFuZCBgQ2FuY2VsYCBhY3Rpb24gYnV0dG9ucyBhbmQgY29sb3IgcHJldmlldyBwYW5lcy5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBlbmFibGVkLCB0aGUgY29tcG9uZW50IHZhbHVlIHdpbGwgbm90IGNoYW5nZSBpbW1lZGlhdGVseSB1cG9uXG4gICAgICAgICAqIGNvbG9yIHNlbGVjdGlvbiwgYnV0IG9ubHkgYWZ0ZXIgdGhlIGBBcHBseWAgYnV0dG9uIGlzIGNsaWNrZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBgQ2FuY2VsYCBidXR0b24gcmV2ZXJ0cyB0aGUgY3VycmVudCBzZWxlY3Rpb24gdG8gaXRzXG4gICAgICAgICAqIHByZXZpb3VzIHN0YXRlIGkuZS4gdG8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZpZXcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyZXMgdGhlIGxheW91dCBvZiB0aGUgYEFwcGx5YCBhbmQgYENhbmNlbGAgYWN0aW9uIGJ1dHRvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIGBzdGFydGBcbiAgICAgICAgICogKiBgY2VudGVyYFxuICAgICAgICAgKiAqIGBlbmRgIChkZWZhdWx0KVxuICAgICAgICAgKiAqIGBzdHJldGNoYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3Rpb25zTGF5b3V0ID0gJ2VuZCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBvcGVuLlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgY2FuY2VsIGl0LCB0aGUgcG9wdXAgd2lsbCByZW1haW4gY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBjbG9zZS5cbiAgICAgICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCBpdCwgdGhlIHBvcHVwIHdpbGwgcmVtYWluIG9wZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIENvbG9yUGlja2VyIGlzIGZvY3VzZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIENvbG9yUGlja2VyIGlzIGJsdXJyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2FuY2VscyB0aGUgY3VycmVudCBjb2xvciBzZWxlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpcmVzIG9uIHByZXZpZXcgcGFuZSBvciAnQ2FuY2VsJyBidXR0b24gY2xpY2suXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgbGVmdCBzaWRlIG9mIHRoZSBDb2xvclBpY2tlciB3cmFwcGVyIGlzIGNsaWNrZWQuXG4gICAgICAgICAqIFRoZSBldmVudCBpcyB0cmlnZ2VyZWQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGEgQ29sb3JQaWNrZXIgaWNvbiBpcyBzZXQgb3Igbm90LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgW0FjdGl2ZUNvbG9yQ2xpY2tFdmVudF0oeyUgc2x1ZyBhcGlfaW5wdXRzX2FjdGl2ZWNvbG9yY2xpY2tldmVudCAlfSkgZXZlbnQgcHJvdmlkZXMgdGhlIG9wdGlvbiB0byBwcmV2ZW50IHRoZSBwb3B1cCBvcGVuaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVDb2xvckNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB2aWV3IGlzIGFib3V0IHRvIGNoYW5nZS5cbiAgICAgICAgICogVXNlZCB0byBwcm92aWRlIGEgdHdvLXdheSBiaW5kaW5nIGZvciB0aGUgYGFjdGl2ZVZpZXdgIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIENvbG9yUGlja2VyIHdyYXBwZXIgaXMgZm9jdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RhYmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IHsgYW5pbWF0ZTogdHJ1ZSB9O1xuICAgICAgICB0aGlzLl9wYWxldHRlU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5fZ3JhZGllbnRTZXR0aW5ncyA9IHsgb3BhY2l0eTogdHJ1ZSwgZGVsYXk6IDAgfTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICB0aGlzLl9yb3VuZGVkID0gJ21lZGl1bSc7XG4gICAgICAgIHRoaXMuX2ZpbGxNb2RlID0gJ3NvbGlkJztcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLm5vdGlmeU5nVG91Y2hlZCA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ0NoYW5nZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuZG9tRm9jdXNMaXN0ZW5lciA9IChldmVudCkgPT4gZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBmb2N1c2VkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRm9jdXNlZDtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICBnZXQgYXJpYVJlYWRvbmx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkb25seTtcbiAgICB9XG4gICAgZ2V0IGFyaWFFeHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPcGVuO1xuICAgIH1cbiAgICBnZXQgaG9zdFRhYmluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB2aWV3KHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3cyA9IFt2aWV3XTtcbiAgICB9XG4gICAgZ2V0IHZpZXcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52aWV3cyAmJiB0aGlzLnZpZXdzLmxlbmd0aCA+IDApID8gdGhpcy52aWV3c1swXSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgdmFsdWUgb2YgdGhlIGluaXRpYWxseSBzZWxlY3RlZCBjb2xvci5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBwYXJzZUNvbG9yJDEodmFsdWUsIHRoaXMuZm9ybWF0LCB0aGlzLmdyYWRpZW50U2V0dGluZ3Mub3BhY2l0eSk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBwb3B1cCBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICovXG4gICAgc2V0IHBvcHVwU2V0dGluZ3ModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24odGhpcy5fcG9wdXBTZXR0aW5ncywgdmFsdWUpO1xuICAgIH1cbiAgICBnZXQgcG9wdXBTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVwU2V0dGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHBhbGV0dGUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIENvbG9yUGlja2VyIHBvcHVwLlxuICAgICAqL1xuICAgIHNldCBwYWxldHRlU2V0dGluZ3ModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcGFsZXR0ZVNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih0aGlzLl9wYWxldHRlU2V0dGluZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHBhbGV0dGVTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhbGV0dGVTZXR0aW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgZ3JhZGllbnQgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIENvbG9yUGlja2VyIHBvcHVwLlxuICAgICAqL1xuICAgIHNldCBncmFkaWVudFNldHRpbmdzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2dyYWRpZW50U2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHRoaXMuX2dyYWRpZW50U2V0dGluZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGdyYWRpZW50U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncmFkaWVudFNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIFt0YWJpbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy90YWJpbmRleCkgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzZXQgdGFiaW5kZXgodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGFiaW5kZXggPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl90YWJpbmRleCA9ICFpc05hTih0YWJpbmRleCkgPyB0YWJpbmRleCA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgZ2V0IHRhYmluZGV4KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQgPyB0aGlzLl90YWJpbmRleCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNpemUgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBwYWRkaW5nIG9mIHRoZSBDb2xvclBpY2tlciBpbnRlcm5hbCBlbGVtZW50c1xuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBwZWFyYW5jZV9jb2xvcnBpY2tlciAlfSN0b2Mtc2l6ZSkpLlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgJ3NtYWxsJ2BcbiAgICAgKiAqIGAnbWVkaXVtJ2AgKGRlZmF1bHQpXG4gICAgICogKiBgJ2xhcmdlJ2BcbiAgICAgKiAqIGBudWxsYFxuICAgICAqL1xuICAgIHNldCBzaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGFzc2VzKHNpemUsICdzaXplJyk7XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByb3VuZGVkIHByb3BlcnR5IHNwZWNpZmllcyB0aGUgYm9yZGVyIHJhZGl1cyBvZiB0aGUgQ29sb3JQaWNrZXJcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwcGVhcmFuY2VfY29sb3JwaWNrZXIgJX0jdG9jLXJvdW5kZWQpKS5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzbWFsbCdgXG4gICAgICogKiBgJ21lZGl1bSdgIChkZWZhdWx0KVxuICAgICAqICogYCdsYXJnZSdgXG4gICAgICogKiBgJ2Z1bGwnYFxuICAgICAqICogYG51bGxgXG4gICAgICovXG4gICAgc2V0IHJvdW5kZWQocm91bmRlZCkge1xuICAgICAgICB0aGlzLmhhbmRsZUNsYXNzZXMocm91bmRlZCwgJ3JvdW5kZWQnKTtcbiAgICAgICAgdGhpcy5fcm91bmRlZCA9IHJvdW5kZWQ7XG4gICAgfVxuICAgIGdldCByb3VuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm91bmRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGxNb2RlIHByb3BlcnR5IHNwZWNpZmllcyB0aGUgYmFja2dyb3VuZCBhbmQgYm9yZGVyIHN0eWxlcyBvZiB0aGUgQ29sb3JQaWNrZXJcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwcGVhcmFuY2VfY29sb3JwaWNrZXIgJX0jdG9jLWZpbGxNb2RlKSkuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGAnZmxhdCdgXG4gICAgICogKiBgJ3NvbGlkJ2AgKGRlZmF1bHQpXG4gICAgICogKiBgJ291dGxpbmUnYFxuICAgICAqICogYG51bGxgXG4gICAgICovXG4gICAgc2V0IGZpbGxNb2RlKGZpbGxNb2RlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xhc3NlcyhmaWxsTW9kZSwgJ2ZpbGxNb2RlJyk7XG4gICAgICAgIHRoaXMuX2ZpbGxNb2RlID0gZmlsbE1vZGU7XG4gICAgfVxuICAgIGdldCBmaWxsTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxNb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgQ29sb3JQaWNrZXIgcG9wdXAgaXMgb3Blbi5cbiAgICAgKi9cbiAgICBnZXQgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMucG9wdXBSZWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGljb25TdHlsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmljb25DbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWNvbkNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmljb24pIHtcbiAgICAgICAgICAgIHJldHVybiBgay1pY29uIGstaS0ke3RoaXMuaWNvbn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0UHJlc2V0ID0gKHRoaXMuZm9ybWF0ICE9PSAnbmFtZScpID8gREVGQVVMVF9QUkVTRVQgOiBERUZBVUxUX0FDQ0VTU0lCTEVfUFJFU0VUO1xuICAgICAgICBjb25zdCBzZXR0aW5nc1BhbGV0dGUgPSB0aGlzLl9wYWxldHRlU2V0dGluZ3MucGFsZXR0ZTtcbiAgICAgICAgY29uc3QgcHJlc2V0Q29sdW1ucyA9IHR5cGVvZiBzZXR0aW5nc1BhbGV0dGUgPT09ICdzdHJpbmcnICYmIFBBTEVUVEVQUkVTRVRTW3NldHRpbmdzUGFsZXR0ZV0gP1xuICAgICAgICAgICAgUEFMRVRURVBSRVNFVFNbc2V0dGluZ3NQYWxldHRlXS5jb2x1bW5zIDpcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcGFsZXR0ZVNldHRpbmdzID0ge1xuICAgICAgICAgICAgcGFsZXR0ZTogc2V0dGluZ3NQYWxldHRlIHx8IGRlZmF1bHRQcmVzZXQsXG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy5fcGFsZXR0ZVNldHRpbmdzLnRpbGVTaXplIHx8IDI0LFxuICAgICAgICAgICAgY29sdW1uczogdGhpcy5fcGFsZXR0ZVNldHRpbmdzLmNvbHVtbnMgfHwgcHJlc2V0Q29sdW1ucyB8fCAxMFxuICAgICAgICB9O1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGNvbnN0IHN0eWxpbmdJbnB1dHMgPSBbJ3NpemUnLCAncm91bmRlZCcsICdmaWxsTW9kZSddO1xuICAgICAgICBzdHlsaW5nSW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGFzc2VzKHRoaXNbaW5wdXRdLCBpbnB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldEhvc3RFbGVtZW50QXJpYUxhYmVsKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlSG9zdElkKCk7XG4gICAgICAgIHRoaXMuaW5pdERvbUV2ZW50cygpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmZvcm1hdCAmJiBjaGFuZ2VzLmZvcm1hdC5jdXJyZW50VmFsdWUgPT09ICduYW1lJykge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVWaWV3ID0gJ3BhbGV0dGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVZpZXcgPT09ICdncmFkaWVudCcgJiYgdGhpcy5ncmFkaWVudFNldHRpbmdzLm9wYWNpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gJ3JnYmEnO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlQ29sb3IkMSh0aGlzLnZhbHVlLCB0aGlzLmZvcm1hdCwgdGhpcy5ncmFkaWVudFNldHRpbmdzLm9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ3ZhbHVlJywgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SG9zdEVsZW1lbnRBcmlhTGFiZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZVBvcHVwKCk7XG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmhhbmRsZURvbUV2ZW50cygncmVtb3ZlJywgRE9NX0ZPQ1VTX0VWRU5UUyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVDYW5jZWxFdmVudChldikge1xuICAgICAgICB0aGlzLmNhbmNlbC5lbWl0KGV2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvZ2dsZVBvcHVwKCkge1xuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlV2l0aEV2ZW50cyghdGhpcy5pc09wZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlV3JhcHBlckNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICBpZiAoY2xvc2VzdChldmVudC50YXJnZXQsIChlbGVtZW50KSA9PiBlbGVtZW50ID09PSB0aGlzLmFjdGl2ZUNvbG9yLm5hdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBBY3RpdmVDb2xvckNsaWNrRXZlbnQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNvbG9yQ2xpY2suZW1pdChldmVudCk7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LmlzT3BlblByZXZlbnRlZCgpIHx8IHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVXaXRoRXZlbnRzKCF0aGlzLmlzT3Blbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2dnbGVXaXRoRXZlbnRzKCF0aGlzLmlzT3Blbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIHdyYXBwZXIgb2YgdGhlIENvbG9yUGlja2VyLlxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVXcmFwcGVyRm9jdXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLm9uRm9jdXMuZW1pdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIENvbG9yUGlja2VyLlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVdyYXBwZXJCbHVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkJsdXIuZW1pdCgpO1xuICAgICAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgdmFsdWUgb2YgdGhlIENvbG9yUGlja2VyLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNldEhvc3RFbGVtZW50QXJpYUxhYmVsKCk7XG4gICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHBvcHVwIG9mIHRoZSBDb2xvclBpY2tlci5cbiAgICAgKiBEb2VzIG5vdCB0cmlnZ2VyIHRoZSBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3BlbiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIuIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBwb3B1cCB3aWxsIGJlIG9wZW5lZCBvciBjbG9zZWQuXG4gICAgICovXG4gICAgdG9nZ2xlKG9wZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLmNsb3NlUG9wdXAoKTtcbiAgICAgICAgb3BlbiA9IGlzUHJlc2VudChvcGVuKSA/IG9wZW4gOiAhdGhpcy5pc09wZW47XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5Qb3B1cCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVWYWx1ZUNoYW5nZShjb2xvcikge1xuICAgICAgICBjb25zdCBwYXJzZWRDb2xvciA9IHBhcnNlQ29sb3IkMShjb2xvciwgdGhpcy5mb3JtYXQsIHRoaXMuZ3JhZGllbnRTZXR0aW5ncy5vcGFjaXR5KTtcbiAgICAgICAgY29uc3QgdmFsdWVDaGFuZ2UgPSBwYXJzZWRDb2xvciAhPT0gdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gcGFyc2VkQ29sb3I7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQocGFyc2VkQ29sb3IpO1xuICAgICAgICAgICAgdGhpcy5zZXRIb3N0RWxlbWVudEFyaWFMYWJlbCgpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlOZ0NoYW5nZWQocGFyc2VkQ29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVQb3B1cEJsdXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBCbHVySW52YWxpZChldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KCk7XG4gICAgICAgIHRoaXMubm90aWZ5TmdUb3VjaGVkKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlV2l0aEV2ZW50cyhmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ0NoYW5nZWQgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMubm90aWZ5TmdUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlV3JhcHBlcktleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtleXMuQXJyb3dEb3duIHx8IGV2ZW50LmtleUNvZGUgPT09IEtleXMuRW50ZXIpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlV2l0aEV2ZW50cyh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVQb3B1cEtleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtleXMuRXNjYXBlKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVdpdGhFdmVudHMoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5UYWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gZXZlbnQuc2hpZnRLZXkgPyB0aGlzLmZpcnN0Rm9jdXNhYmxlRWxlbWVudC5uYXRpdmVFbGVtZW50IDogdGhpcy5sYXN0Rm9jdXNhYmxlRWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgbmV4dEVsZW1lbnQgPSBldmVudC5zaGlmdEtleSA/IHRoaXMubGFzdEZvY3VzYWJsZUVsZW1lbnQubmF0aXZlRWxlbWVudCA6IHRoaXMuZmlyc3RGb2N1c2FibGVFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBjdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbmV4dEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXNlZCBieSB0aGUgRmxvYXRpbmdMYWJlbCB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldEhvc3RFbGVtZW50QXJpYUxhYmVsKCkge1xuICAgICAgICBjb25zdCBhcmlhTGFiZWxWYWx1ZSA9IGAke3RoaXMudmFsdWUgPyB0aGlzLnZhbHVlIDogdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmdldCgnY29sb3JQaWNrZXJOb0NvbG9yJyl9YDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQsICdhcmlhLWxhYmVsJywgYXJpYUxhYmVsVmFsdWUpO1xuICAgIH1cbiAgICBoYW5kbGVDbGFzc2VzKHZhbHVlLCBpbnB1dCkge1xuICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBnZXRTdHlsaW5nQ2xhc3NlcygncGlja2VyJywgaW5wdXQsIHRoaXNbaW5wdXRdLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjbGFzc2VzLnRvUmVtb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzZXMudG9SZW1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc2VzLnRvQWRkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW0sIGNsYXNzZXMudG9BZGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvcHVwQmx1ckludmFsaWQoZXYpIHtcbiAgICAgICAgY29uc3QgZm9jdXNJbkZsYXRDb2xvclBpY2tlckVsZW1lbnQgPSB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudC5jb250YWlucyhldi5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaG9zdENsaWNrZWQgPSBjbG9zZXN0KGV2LnJlbGF0ZWRUYXJnZXQsIChlbGVtZW50KSA9PiBlbGVtZW50ID09PSB0aGlzLmhvc3QubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHJldHVybiBob3N0Q2xpY2tlZCB8fCBmb2N1c0luRmxhdENvbG9yUGlja2VyRWxlbWVudDtcbiAgICB9XG4gICAgdG9nZ2xlV2l0aEV2ZW50cyhvcGVuKSB7XG4gICAgICAgIGNvbnN0IHNhbWVTdGF0ZSA9IHRoaXMuaXNPcGVuID09PSBvcGVuO1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5IHx8IHNhbWVTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudEFyZ3M7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBldmVudEFyZ3MgPSBuZXcgQ29sb3JQaWNrZXJPcGVuRXZlbnQoKTtcbiAgICAgICAgICAgIHRoaXMub3Blbi5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudEFyZ3MgPSBuZXcgQ29sb3JQaWNrZXJDbG9zZUV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUob3Blbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNGaXJzdEVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb2N1c0ZpcnN0RWxlbWVudCgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUub25TdGFibGUucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxhdENvbG9yUGlja2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JhZGllbnQgPSB0aGlzLmZsYXRDb2xvclBpY2tlci5ncmFkaWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50VG9Gb2N1cyA9IGdyYWRpZW50ID8gZ3JhZGllbnQuZ3JhZGllbnREcmFnSGFuZGxlIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGF0Q29sb3JQaWNrZXIucGFsZXR0ZS5ob3N0O1xuICAgICAgICAgICAgICAgIGVsZW1lbnRUb0ZvY3VzLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9wZW5Qb3B1cCgpIHtcbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbEFsaWduID0gdGhpcy5kaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcbiAgICAgICAgY29uc3QgYW5jaG9yUG9zaXRpb24gPSB7IGhvcml6b250YWw6IGhvcml6b250YWxBbGlnbiwgdmVydGljYWw6IFwiYm90dG9tXCIgfTtcbiAgICAgICAgY29uc3QgcG9wdXBQb3NpdGlvbiA9IHsgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbDogXCJ0b3BcIiB9O1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICAgICAgICBhbmNob3I6IHRoaXMuYWN0aXZlQ29sb3IsXG4gICAgICAgICAgICBhbmltYXRlOiB0aGlzLnBvcHVwU2V0dGluZ3MuYW5pbWF0ZSxcbiAgICAgICAgICAgIGFwcGVuZFRvOiB0aGlzLnBvcHVwU2V0dGluZ3MuYXBwZW5kVG8sXG4gICAgICAgICAgICBwb3B1cEFsaWduOiBwb3B1cFBvc2l0aW9uLFxuICAgICAgICAgICAgYW5jaG9yQWxpZ246IGFuY2hvclBvc2l0aW9uLFxuICAgICAgICAgICAgcG9wdXBDbGFzczogJ2stY29sb3JwaWNrZXItcG9wdXAnLFxuICAgICAgICAgICAgY29udGVudDogdGhpcy5wb3B1cFRlbXBsYXRlLFxuICAgICAgICAgICAgcG9zaXRpb25Nb2RlOiAnYWJzb2x1dGUnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvcHVwUmVmLnBvcHVwQW5jaG9yVmlld3BvcnRMZWF2ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVXaXRoRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3QubmF0aXZlRWxlbWVudC5mb2N1cyh7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlUG9wdXAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcHVwUmVmLmNsb3NlKCk7XG4gICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgZmlyc3RGb2N1c2FibGVFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuZmxhdENvbG9yUGlja2VyLmhlYWRlciB8fCAodGhpcy52aWV3cy5sZW5ndGggPD0gMSAmJiAhdGhpcy5mbGF0Q29sb3JQaWNrZXIuY2xlYXJCdXR0b24pKSB7XG4gICAgICAgICAgICBjb25zdCBncmFkaWVudCA9IHRoaXMuZmxhdENvbG9yUGlja2VyLmdyYWRpZW50O1xuICAgICAgICAgICAgcmV0dXJuIGdyYWRpZW50ID8gZ3JhZGllbnQuZ3JhZGllbnREcmFnSGFuZGxlIDogdGhpcy5mbGF0Q29sb3JQaWNrZXIucGFsZXR0ZS5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzLmxlbmd0aCA+IDEgPyB0aGlzLmZsYXRDb2xvclBpY2tlci5oZWFkZXIudmlld0J1dHRvbnNDb2xsZWN0aW9uLnRvQXJyYXkoKVswXSA6IHRoaXMuZmxhdENvbG9yUGlja2VyLmhlYWRlci5jbGVhckJ1dHRvbkVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBsYXN0Rm9jdXNhYmxlRWxlbWVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJldmlldykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxhdENvbG9yUGlja2VyLmZvb3Rlci5sYXN0QnV0dG9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZsYXRDb2xvclBpY2tlci5wYWxldHRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbGF0Q29sb3JQaWNrZXIucGFsZXR0ZS5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyYWRpZW50ID0gdGhpcy5mbGF0Q29sb3JQaWNrZXIuZ3JhZGllbnQ7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IGdyYWRpZW50ICYmIGdyYWRpZW50LmlucHV0cztcbiAgICAgICAgaWYgKGdyYWRpZW50ICYmIGlucHV0cyAmJiBpbnB1dHMuZm9ybWF0VmlldyA9PT0gJ2hleCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dHMuaGV4SW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhZGllbnRTZXR0aW5ncy5vcGFjaXR5ID8gaW5wdXRzLm9wYWNpdHlJbnB1dC5udW1lcmljSW5wdXQgOiBpbnB1dHMuYmx1ZUlucHV0O1xuICAgIH1cbiAgICBoYW5kbGVEb21FdmVudHMoYWN0aW9uLCBldmVudHMpIHtcbiAgICAgICAgY29uc3QgaG9zdEVsZW1lbnQgPSB0aGlzLmhvc3QubmF0aXZlRWxlbWVudDtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goZXYgPT4gaG9zdEVsZW1lbnRbYCR7YWN0aW9ufUV2ZW50TGlzdGVuZXJgXShldiwgdGhpcy5kb21Gb2N1c0xpc3RlbmVyLCB0cnVlKSk7XG4gICAgfVxuICAgIGluaXREb21FdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5ob3N0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhvc3RFbGVtZW50ID0gdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1c2luJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlV3JhcHBlckZvY3VzKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucmVuZGVyZXIubGlzdGVuKGhvc3RFbGVtZW50LCAnZm9jdXNvdXQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0UG9wdXAgPSB0aGlzLnBvcHVwUmVmID9cbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdChldmVudC5yZWxhdGVkVGFyZ2V0LCAoZWxlbWVudCkgPT4gZWxlbWVudCA9PT0gdGhpcy5mbGF0Q29sb3JQaWNrZXIuaG9zdC5uYXRpdmVFbGVtZW50KSA6XG4gICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RXcmFwcGVyID0gY2xvc2VzdChldmVudC5yZWxhdGVkVGFyZ2V0LCAoZWxlbWVudCkgPT4gZWxlbWVudCA9PT0gdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICghY2xvc2VzdFBvcHVwICYmICFjbG9zZXN0V3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVdyYXBwZXJCbHVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEb21FdmVudHMoJ2FkZCcsIERPTV9GT0NVU19FVkVOVFMpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbihob3N0RWxlbWVudCwgJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVdyYXBwZXJLZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlV3JhcHBlckNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUhvc3RJZCgpIHtcbiAgICAgICAgY29uc3QgaG9zdEVsZW1lbnQgPSB0aGlzLmhvc3QubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJZCA9IGhvc3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nSWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNhYmxlSWQgPSBleGlzdGluZ0lkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBgay0ke2d1aWQoKX1gO1xuICAgICAgICAgICAgaG9zdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNhYmxlSWQgPSBpZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jb2xvcnBpY2tlcicpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWljb24tcGlja2VyJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstcGlja2VyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWZvY3VzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c2VkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLWRpc2FibGVkJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLXJlYWRvbmx5JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhUmVhZG9ubHlcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLWV4cGFuZGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhRXhwYW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0VGFiaW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5kaXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicm9sZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmlld3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZpZXdcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cFNldHRpbmdzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicGFsZXR0ZVNldHRpbmdzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRTZXR0aW5nc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNsZWFyQnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicHJldmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGlvbnNMYXlvdXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbE1vZGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9wZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xvc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnZm9jdXMnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnYmx1cicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwib25CbHVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNhbmNlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVDb2xvckNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVZpZXdDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnY29udGFpbmVyJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmLCBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpZXdDb250YWluZXJSZWYpXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGFpbmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2FjdGl2ZUNvbG9yJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBDb2xvclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlQ29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgncG9wdXBUZW1wbGF0ZScsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2ZsYXRDb2xvclBpY2tlcicsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRmxhdENvbG9yUGlja2VyQ29tcG9uZW50KVxuXSwgQ29sb3JQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZsYXRDb2xvclBpY2tlclwiLCB2b2lkIDApO1xuQ29sb3JQaWNrZXJDb21wb25lbnQgPSBDb2xvclBpY2tlckNvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb0NvbG9yUGlja2VyJyxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jb2xvcnBpY2tlcicsXG4gICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDb2xvclBpY2tlckNvbXBvbmVudF8xKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtlbmRvSW5wdXQsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sb3JQaWNrZXJDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDb2xvclBpY2tlckxvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogQ29sb3JQaWNrZXJMb2NhbGl6YXRpb25TZXJ2aWNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uY29sb3JwaWNrZXInXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIga2VuZG9Db2xvclBpY2tlckxvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLWNvbG9yUGlja2VyTm9Db2xvcj1cImtlbmRvLmNvbG9ycGlja2VyLmNvbG9yUGlja2VyTm9Db2xvcnxUaGUgYXJpYS1sYWJlbCBhcHBsaWVkIHRvIHRoZSBDb2xvclBpY2tlciBjb21wb25lbnQgd2hlbiB0aGUgdmFsdWUgaXMgZW1wdHkuXCJcbiAgICAgICAgICAgIGNvbG9yUGlja2VyTm9Db2xvcj1cIkNvbG9ycGlja2VyIG5vIGNvbG9yIGNob3NlblwiXG4gICAgICAgICAgICBpMThuLWZsYXRDb2xvclBpY2tlck5vQ29sb3I9XCJrZW5kby5jb2xvcnBpY2tlci5mbGF0Q29sb3JQaWNrZXJOb0NvbG9yfFRoZSBhcmlhLWxhYmVsIGFwcGxpZWQgdG8gdGhlIEZsYXRDb2xvclBpY2tlciBjb21wb25lbnQgd2hlbiB0aGUgdmFsdWUgaXMgZW1wdHkuXCJcbiAgICAgICAgICAgIGZsYXRDb2xvclBpY2tlck5vQ29sb3I9XCJGbGF0Y29sb3JwaWNrZXIgbm8gY29sb3IgY2hvc2VuXCJcbiAgICAgICAgICAgIGkxOG4tY29sb3JHcmFkaWVudE5vQ29sb3I9XCJrZW5kby5jb2xvcnBpY2tlci5jb2xvckdyYWRpZW50Tm9Db2xvcnxUaGUgYXJpYS1sYWJlbCBhcHBsaWVkIHRvIHRoZSBDb2xvckdyYWRpZW50IGNvbXBvbmVudCB3aGVuIHRoZSB2YWx1ZSBpcyBlbXB0eS5cIlxuICAgICAgICAgICAgY29sb3JHcmFkaWVudE5vQ29sb3I9XCJDb2xvcmdyYWRpZW50IG5vIGNvbG9yIGNob3NlblwiXG4gICAgICAgICAgICBpMThuLWNvbG9yUGFsZXR0ZU5vQ29sb3I9XCJrZW5kby5jb2xvcnBpY2tlci5jb2xvclBhbGV0dGVOb0NvbG9yfFRoZSBhcmlhLWxhYmVsIGFwcGxpZWQgdG8gdGhlIENvbG9yUGFsZXR0ZSBjb21wb25lbnQgd2hlbiB0aGUgdmFsdWUgaXMgZW1wdHkuXCJcbiAgICAgICAgICAgIGNvbG9yUGFsZXR0ZU5vQ29sb3I9XCJDb2xvcnBhbGV0dGUgbm8gY29sb3IgY2hvc2VuXCJcbiAgICAgICAgICAgIGkxOG4tY29sb3JHcmFkaWVudEhhbmRsZT1cImtlbmRvLmNvbG9ycGlja2VyLmNvbG9yR3JhZGllbnRIYW5kbGV8VGhlIHRpdGxlIGZvciB0aGUgZ3JhZGllbnQgY29sb3IgZHJhZyBoYW5kbGUgY2hvb3Nlci5cIlxuICAgICAgICAgICAgY29sb3JHcmFkaWVudEhhbmRsZT1cIkNob29zZSBjb2xvclwiXG4gICAgICAgICAgICBpMThuLWNsZWFyQnV0dG9uPVwia2VuZG8uY29sb3JwaWNrZXIuY2xlYXJCdXR0b258VGhlIHRpdGxlIGZvciB0aGUgY2xlYXIgYnV0dG9uLlwiXG4gICAgICAgICAgICBjbGVhckJ1dHRvbj1cIkNsZWFyIHZhbHVlXCJcbiAgICAgICAgICAgIGkxOG4taHVlU2xpZGVySGFuZGxlPVwia2VuZG8uY29sb3JwaWNrZXIuaHVlU2xpZGVySGFuZGxlfFRoZSB0aXRsZSBmb3IgdGhlIGh1ZSBzbGlkZXIgaGFuZGxlLlwiXG4gICAgICAgICAgICBodWVTbGlkZXJIYW5kbGU9XCJTZXQgaHVlXCJcbiAgICAgICAgICAgIGkxOG4tb3BhY2l0eVNsaWRlckhhbmRsZT1cImtlbmRvLmNvbG9ycGlja2VyLm9wYWNpdHlTbGlkZXJIYW5kbGV8VGhlIHRpdGxlIGZvciB0aGUgb3BhY2l0eSBzbGlkZXIgaGFuZGxlLlwiXG4gICAgICAgICAgICBvcGFjaXR5U2xpZGVySGFuZGxlPVwiU2V0IG9wYWNpdHlcIlxuICAgICAgICAgICAgaTE4bi1jb250cmFzdFJhdGlvPVwia2VuZG8uY29sb3JwaWNrZXIuY29udHJhc3RSYXRpb3xUaGUgY29udHJhc3QgcmF0aW8gbWVzc2FnZSBmb3IgdGhlIGNvbnRyYXN0IHRvb2wuXCJcbiAgICAgICAgICAgIGNvbnRyYXN0UmF0aW89XCJDb250cmFzdCByYXRpb1wiXG4gICAgICAgICAgICBpMThuLXByZXZpZXdDb2xvcj1cImtlbmRvLmNvbG9ycGlja2VyLnByZXZpZXdDb2xvcnxUaGUgbWVzc2FnZSBmb3IgdGhlIGNvbG9yIHByZXZpZXcgcGFuZS5cIlxuICAgICAgICAgICAgcHJldmlld0NvbG9yPVwiQ29sb3IgcHJldmlld1wiXG4gICAgICAgICAgICBpMThuLXJldmVydFNlbGVjdGlvbj1cImtlbmRvLmNvbG9ycGlja2VyLnJldmVydFNlbGVjdGlvbnxUaGUgbWVzc2FnZSBmb3IgdGhlIHNlbGVjdGVkIGNvbG9yIHBhbmUuXCJcbiAgICAgICAgICAgIHJldmVydFNlbGVjdGlvbj1cIlJldmVydCBzZWxlY3Rpb25cIlxuICAgICAgICAgICAgaTE4bi1ncmFkaWVudFZpZXc9XCJrZW5kby5jb2xvcnBpY2tlci5ncmFkaWVudFZpZXd8VGhlIG1lc3NhZ2UgZm9yIHRoZSBncmFkaWVudCB2aWV3IGJ1dHRvbi5cIlxuICAgICAgICAgICAgZ3JhZGllbnRWaWV3PVwiR3JhZGllbnQgdmlld1wiXG4gICAgICAgICAgICBpMThuLXBhbGV0dGVWaWV3PVwia2VuZG8uY29sb3JwaWNrZXIucGFsZXR0ZVZpZXd8VGhlIG1lc3NhZ2UgZm9yIHRoZSBwYWxldHRlIHZpZXcgYnV0dG9uLlwiXG4gICAgICAgICAgICBwYWxldHRlVmlldz1cIlBhbGV0dGUgdmlld1wiXG4gICAgICAgICAgICBpMThuLWZvcm1hdEJ1dHRvbj1cImtlbmRvLmNvbG9ycGlja2VyLmZvcm1hdEJ1dHRvbnxUaGUgbWVzc2FnZSBmb3IgdGhlIGlucHV0IGZvcm1hdCB0b2dnbGUgYnV0dG9uLlwiXG4gICAgICAgICAgICBmb3JtYXRCdXR0b249XCJDaGFuZ2UgY29sb3IgZm9ybWF0XCJcbiAgICAgICAgICAgIGkxOG4tYXBwbHlCdXR0b249XCJrZW5kby5jb2xvcnBpY2tlci5hcHBseUJ1dHRvbnxUaGUgbWVzc2FnZSBmb3IgdGhlIEFwcGx5IGFjdGlvbiBidXR0b24uXCJcbiAgICAgICAgICAgIGFwcGx5QnV0dG9uPVwiQXBwbHlcIlxuICAgICAgICAgICAgaTE4bi1jYW5jZWxCdXR0b249XCJrZW5kby5jb2xvcnBpY2tlci5jYW5jZWxCdXR0b258VGhlIG1lc3NhZ2UgZm9yIHRoZSBDYW5jZWwgYWN0aW9uIGJ1dHRvbi5cIlxuICAgICAgICAgICAgY2FuY2VsQnV0dG9uPVwiQ2FuY2VsXCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8c3BhbiAjYWN0aXZlQ29sb3IgY2xhc3M9XCJrLWlucHV0LWlubmVyXCI+XG4gICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay12YWx1ZS1pY29uIGstY29sb3ItcHJldmlld1wiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwieydrLWljb24tY29sb3ItcHJldmlldyc6IGljb25TdHlsZXMsICdrLW5vLWNvbG9yJzogIXZhbHVlfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiaWNvbkNsYXNzIHx8IGljb25cIiBjbGFzcz1cImstY29sb3ItcHJldmlldy1pY29uIGstaWNvblwiIFtuZ0NsYXNzXT1cImljb25TdHlsZXNcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWNvbG9yLXByZXZpZXctbWFza1wiIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cInZhbHVlXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzcz1cImstaW5wdXQtYnV0dG9uIGstYnV0dG9uIGstYnV0dG9uLW1kIGstYnV0dG9uLXNvbGlkIGstYnV0dG9uLXNvbGlkLWJhc2Ugay1pY29uLWJ1dHRvblwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1idXR0b24taWNvbiBrLWljb24gay1pLWFycm93LXNcIj48L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8bmctdGVtcGxhdGUgI3BvcHVwVGVtcGxhdGU+XG4gICAgICAgICAgICA8a2VuZG8tZmxhdGNvbG9ycGlja2VyXG4gICAgICAgICAgICAgICAgI2ZsYXRDb2xvclBpY2tlclxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgICAgIFt2aWV3c109XCJ2aWV3c1wiXG4gICAgICAgICAgICAgICAgW2FjdGl2ZVZpZXddPVwiYWN0aXZlVmlld1wiXG4gICAgICAgICAgICAgICAgW2FjdGlvbnNMYXlvdXRdPVwiYWN0aW9uc0xheW91dFwiXG4gICAgICAgICAgICAgICAgW3ByZXZpZXddPVwicHJldmlld1wiXG4gICAgICAgICAgICAgICAgW2dyYWRpZW50U2V0dGluZ3NdPVwiZ3JhZGllbnRTZXR0aW5nc1wiXG4gICAgICAgICAgICAgICAgW3BhbGV0dGVTZXR0aW5nc109XCJwYWxldHRlU2V0dGluZ3NcIlxuICAgICAgICAgICAgICAgIFtjbGVhckJ1dHRvbl09XCJjbGVhckJ1dHRvblwiXG4gICAgICAgICAgICAgICAgKGNhbmNlbCk9XCJoYW5kbGVDYW5jZWxFdmVudCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAoZm9jdXNvdXQpPVwiaGFuZGxlUG9wdXBCbHVyKCRldmVudClcIlxuICAgICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAoa2V5ZG93bik9XCJoYW5kbGVQb3B1cEtleURvd24oJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgKGFjdGl2ZVZpZXdDaGFuZ2UpPVwiYWN0aXZlVmlld0NoYW5nZS5lbWl0KCRldmVudClcIlxuICAgICAgICAgICAgICAgIChhY3Rpb25CdXR0b25DbGljayk9XCJ0b2dnbGVQb3B1cCgpXCI+XG4gICAgICAgICAgICA8L2tlbmRvLWZsYXRjb2xvcnBpY2tlcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAjY29udGFpbmVyPjwvbmctY29udGFpbmVyPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIFBvcHVwU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgUmVuZGVyZXIyXSlcbl0sIENvbG9yUGlja2VyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENvbG9yUGlja2VyTWVzc2FnZXMgZXh0ZW5kcyBDb21wb25lbnRNZXNzYWdlcyB7XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJjb2xvclBhbGV0dGVOb0NvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJjb2xvckdyYWRpZW50Tm9Db2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiZmxhdENvbG9yUGlja2VyTm9Db2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiY29sb3JQaWNrZXJOb0NvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJjb2xvckdyYWRpZW50SGFuZGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJjbGVhckJ1dHRvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiaHVlU2xpZGVySGFuZGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJvcGFjaXR5U2xpZGVySGFuZGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJoZXhJbnB1dFBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJyZWRJbnB1dFBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJncmVlbklucHV0UGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbG9yUGlja2VyTWVzc2FnZXMucHJvdG90eXBlLCBcImJsdWVJbnB1dFBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJhbHBoYUlucHV0UGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbG9yUGlja2VyTWVzc2FnZXMucHJvdG90eXBlLCBcInBhc3NDb250cmFzdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiZmFpbENvbnRyYXN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJjb250cmFzdFJhdGlvXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJwcmV2aWV3Q29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbG9yUGlja2VyTWVzc2FnZXMucHJvdG90eXBlLCBcInJldmVydFNlbGVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiZ3JhZGllbnRWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJwYWxldHRlVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiZm9ybWF0QnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJhcHBseUJ1dHRvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiY2FuY2VsQnV0dG9uXCIsIHZvaWQgMCk7XG5cbnZhciBDb2xvclBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzE7XG4vKipcbiAqIEN1c3RvbSBjb21wb25lbnQgbWVzc2FnZXMgb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnQgbWVzc2FnZXMuXG4gKi9cbmxldCBDb2xvclBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gQ29sb3JQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gY2xhc3MgQ29sb3JQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIENvbG9yUGlja2VyTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuQ29sb3JQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IENvbG9yUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbG9yUGlja2VyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sb3JQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY29sb3JwaWNrZXItbWVzc2FnZXMsIGtlbmRvLWZsYXRjb2xvcnBpY2tlci1tZXNzYWdlcywga2VuZG8tY29sb3JncmFkaWVudC1tZXNzYWdlcywga2VuZG8tY29sb3JwYWxldHRlLW1lc3NhZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIENvbG9yUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQpO1xuXG52YXIgTG9jYWxpemVkQ29sb3JQaWNrZXJNZXNzYWdlc0RpcmVjdGl2ZV8xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBMb2NhbGl6ZWRDb2xvclBpY2tlck1lc3NhZ2VzRGlyZWN0aXZlID0gTG9jYWxpemVkQ29sb3JQaWNrZXJNZXNzYWdlc0RpcmVjdGl2ZV8xID0gY2xhc3MgTG9jYWxpemVkQ29sb3JQaWNrZXJNZXNzYWdlc0RpcmVjdGl2ZSBleHRlbmRzIENvbG9yUGlja2VyTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG59O1xuTG9jYWxpemVkQ29sb3JQaWNrZXJNZXNzYWdlc0RpcmVjdGl2ZSA9IExvY2FsaXplZENvbG9yUGlja2VyTWVzc2FnZXNEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbG9yUGlja2VyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTG9jYWxpemVkQ29sb3JQaWNrZXJNZXNzYWdlc0RpcmVjdGl2ZV8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ29sb3JQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc10sIFtrZW5kb0ZsYXRDb2xvclBpY2tlckxvY2FsaXplZE1lc3NhZ2VzXSwgW2tlbmRvQ29sb3JHcmFkaWVudExvY2FsaXplZE1lc3NhZ2VzXSwgW2tlbmRvQ29sb3JQYWxldHRlTG9jYWxpemVkTWVzc2FnZXNdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBMb2NhbGl6ZWRDb2xvclBpY2tlck1lc3NhZ2VzRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBGb2N1c09uRG9tUmVhZHlEaXJlY3RpdmUgPSBjbGFzcyBGb2N1c09uRG9tUmVhZHlEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QsIG5nWm9uZSkge1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLmZvY3VzT25OZXh0VGljaygpO1xuICAgIH1cbiAgICBmb2N1c09uTmV4dFRpY2soKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKSkpO1xuICAgIH1cbn07XG5Gb2N1c09uRG9tUmVhZHlEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0ZvY3VzT25Eb21SZWFkeV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBOZ1pvbmVdKVxuXSwgRm9jdXNPbkRvbVJlYWR5RGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDb250cmFzdFZhbGlkYXRpb25Db21wb25lbnQgPSBjbGFzcyBDb250cmFzdFZhbGlkYXRpb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICB9XG4gICAgZ2V0IHBhc3NNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdwYXNzQ29udHJhc3QnKTtcbiAgICB9XG4gICAgZ2V0IGZhaWxNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdmYWlsQ29udHJhc3QnKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRyYXN0VGV4dCgpIHtcbiAgICAgICAgbGV0IHJhdGlvID0gdGhpcy50eXBlID09PSAnQUEnID8gQUFfUkFUSU8gOiBBQUFfUkFUSU87XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnR5cGV9OiAke3JhdGlvLnRvRml4ZWQoMSl9YDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29udHJhc3RWYWxpZGF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29udHJhc3RWYWxpZGF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb250cmFzdFZhbGlkYXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5Db250cmFzdFZhbGlkYXRpb25Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NvbnRyYXN0VmFsaWRhdGlvbl0nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8c3Bhbj57e2NvbnRyYXN0VGV4dH19PC9zcGFuPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwidmFsdWVcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1jb250cmFzdC12YWxpZGF0aW9uIGstdGV4dC1zdWNjZXNzXCIgKm5nSWY9XCJwYXNzXCI+XG4gICAgICAgICAgICAgICAge3twYXNzTWVzc2FnZX19XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1pLWNoZWNrXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWNvbnRyYXN0LXZhbGlkYXRpb24gay10ZXh0LWVycm9yXCIgKm5nSWY9XCIhcGFzc1wiPlxuICAgICAgICAgICAgICAgIHt7ZmFpbE1lc3NhZ2V9fVxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1jbG9zZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBDb250cmFzdFZhbGlkYXRpb25Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENvbnRyYXN0Q29tcG9uZW50ID0gY2xhc3MgQ29udHJhc3RDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICB9XG4gICAgZ2V0IGZvcm1hdGVkUmF0aW8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyYXN0UmF0aW8udG9GaXhlZCgyKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRyYXN0UmF0aW9UZXh0KCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdjb250cmFzdFJhdGlvJyl9OiAke3RoaXMudmFsdWUgPyB0aGlzLmZvcm1hdGVkUmF0aW8gOiAnbi9hJ31gO1xuICAgIH1cbiAgICBnZXQgc2F0aXNmaWVzQUFDb25kaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyYXN0UmF0aW8gPj0gQUFfUkFUSU87XG4gICAgfVxuICAgIGdldCBzYXRpc2ZpZXNBQUFDb25kaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyYXN0UmF0aW8gPj0gQUFBX1JBVElPO1xuICAgIH1cbiAgICBnZXQgY29udHJhc3RSYXRpbygpIHtcbiAgICAgICAgbGV0IGNvbnRyYXN0ID0gZ2V0Q29udHJhc3RGcm9tVHdvUkdCQXMoZ2V0UkdCQSh0aGlzLnZhbHVlKSwgZ2V0UkdCQSh0aGlzLnJhdGlvKSk7XG4gICAgICAgIHJldHVybiBjb250cmFzdDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29udHJhc3RDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb250cmFzdENvbXBvbmVudC5wcm90b3R5cGUsIFwicmF0aW9cIiwgdm9pZCAwKTtcbkNvbnRyYXN0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9Db250cmFzdFRvb2xdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImstY29udHJhc3QtcmF0aW9cIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1jb250cmFzdC1yYXRpby10ZXh0XCI+e3tjb250cmFzdFJhdGlvVGV4dH19PC9zcGFuPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInZhbHVlXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWNvbnRyYXN0LXZhbGlkYXRpb24gay10ZXh0LXN1Y2Nlc3NcIiAqbmdJZj1cInNhdGlzZmllc0FBQ29uZGl0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1jaGVja1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1pLWNoZWNrXCIgKm5nSWY9XCJzYXRpc2ZpZXNBQUFDb25kaXRpb25cIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1jb250cmFzdC12YWxpZGF0aW9uIGstdGV4dC1lcnJvclwiICpuZ0lmPVwiIXNhdGlzZmllc0FBQ29uZGl0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1jbG9zZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYga2VuZG9Db250cmFzdFZhbGlkYXRpb25cbiAgICAgICAgICAgIHR5cGU9XCJBQVwiXG4gICAgICAgICAgICBbdmFsdWVdPVwidmFsdWVcIlxuICAgICAgICAgICAgW3Bhc3NdPVwic2F0aXNmaWVzQUFDb25kaXRpb25cIj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYga2VuZG9Db250cmFzdFZhbGlkYXRpb25cbiAgICAgICAgICAgIHR5cGU9XCJBQUFcIlxuICAgICAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgICAgIFtwYXNzXT1cInNhdGlzZmllc0FBQUNvbmRpdGlvblwiPlxuICAgICAgICA8L2Rpdj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIENvbnRyYXN0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDb2xvckNvbnRyYXN0U3ZnQ29tcG9uZW50ID0gY2xhc3MgQ29sb3JDb250cmFzdFN2Z0NvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5tZXRyaWNzID0gdGhpcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLm9sZEEgPSB0aGlzLmhzdmEudmFsdWUuYTtcbiAgICAgICAgdGhpcy5vbGRIID0gdGhpcy5oc3ZhLnZhbHVlLmg7XG4gICAgICAgIHRoaXMuaHN2YS5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUuaCAhPT0gdGhpcy5vbGRIIHx8IHZhbHVlLmEgIT09IHRoaXMub2xkQSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2xkSCA9IHZhbHVlLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGRBID0gdmFsdWUuYTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhdGhzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoY2hhbmdlcy5iYWNrZ3JvdW5kQ29sb3IpICYmIHRoaXMubWV0cmljcykge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXRocygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhdGhzKCkge1xuICAgICAgICBjb25zdCBiZXppZXJDb21tYW5kQ2FsYyA9IGJlemllckNvbW1hbmQoY29udHJvbFBvaW50KGxpbmUpKTtcbiAgICAgICAgdGhpcy5wYXRocyA9IFtzdmdQYXRoKHRoaXMuZ2V0UGF0aHMoQUFfUkFUSU8sIFNURVBfQ09VTlQpLCBiZXppZXJDb21tYW5kQ2FsYyksXG4gICAgICAgICAgICBzdmdQYXRoKHRoaXMuZ2V0UGF0aHMoQUFfUkFUSU8sIFNURVBfQ09VTlQsIHRydWUpLCBiZXppZXJDb21tYW5kQ2FsYyksXG4gICAgICAgICAgICBzdmdQYXRoKHRoaXMuZ2V0UGF0aHMoQUFBX1JBVElPLCBTVEVQX0NPVU5UKSwgYmV6aWVyQ29tbWFuZENhbGMpLFxuICAgICAgICAgICAgc3ZnUGF0aCh0aGlzLmdldFBhdGhzKEFBQV9SQVRJTywgU1RFUF9DT1VOVCwgdHJ1ZSksIGJlemllckNvbW1hbmRDYWxjKV07XG4gICAgfVxuICAgIGZpbmRWYWx1ZShjb250cmFzdCwgc2F0dXJhdGlvbiwgbG93LCBoaWdoLCBjb21wYXJlcikge1xuICAgICAgICBjb25zdCBtaWQgPSAobG93ICsgaGlnaCkgLyAyO1xuICAgICAgICBjb25zdCBoc3ZhID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oc3ZhLnZhbHVlLCB7IHM6IHNhdHVyYXRpb24gLyB0aGlzLm1ldHJpY3Mud2lkdGgsIHY6IDEgLSBtaWQgLyB0aGlzLm1ldHJpY3MuaGVpZ2h0IH0pO1xuICAgICAgICBjb25zdCBjdXJyZW50Q29udHJhc3QgPSBnZXRDb250cmFzdEZyb21Ud29SR0JBcyhnZXRSR0JBKGdldENvbG9yRnJvbUhTVihoc3ZhKSksIGdldFJHQkEodGhpcy5iYWNrZ3JvdW5kQ29sb3IgfHwgJycpKTtcbiAgICAgICAgaWYgKGxvdyArIDAuNSA+IGhpZ2gpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29udHJhc3QgPCBjb250cmFzdCArIDEgJiYgY3VycmVudENvbnRyYXN0ID4gY29udHJhc3QgLSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlcihjdXJyZW50Q29udHJhc3QsIGNvbnRyYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZFZhbHVlKGNvbnRyYXN0LCBzYXR1cmF0aW9uLCBsb3csIGhpZ2ggLSAoaGlnaCAtIGxvdykgLyAyLCBjb21wYXJlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFZhbHVlKGNvbnRyYXN0LCBzYXR1cmF0aW9uLCBsb3cgKyAoaGlnaCAtIGxvdykgLyAyLCBoaWdoLCBjb21wYXJlcik7XG4gICAgfVxuICAgIGdldFBhdGhzKGNvbnRyYXN0LCBzdGVwQ291bnQsIHJldmVyc2VkID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMubWV0cmljcy53aWR0aDsgaSArPSB0aGlzLm1ldHJpY3Mud2lkdGggLyBzdGVwQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5maW5kVmFsdWUoY29udHJhc3QsIGksIDAsIHRoaXMubWV0cmljcy5oZWlnaHQsIHJldmVyc2VkID8gKChhLCBiKSA9PiBhIDwgYikgOiAoKGEsIGIpID0+IGEgPiBiKSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbaSwgdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jb2xvci1jb250cmFzdC1zdmcnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbG9yQ29udHJhc3RTdmdDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sb3JDb250cmFzdFN2Z0NvbXBvbmVudC5wcm90b3R5cGUsIFwid3JhcHBlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQmVoYXZpb3JTdWJqZWN0KVxuXSwgQ29sb3JDb250cmFzdFN2Z0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaHN2YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JDb250cmFzdFN2Z0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZENvbG9yXCIsIHZvaWQgMCk7XG5Db2xvckNvbnRyYXN0U3ZnQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9Db2xvckNvbnRyYXN0U3ZnXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxzdmc6cGF0aCAqbmdGb3I9XCJsZXQgcGF0aCBvZiBwYXRoc1wiIFthdHRyLmRdPVwicGF0aFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwid2hpdGVcIiBzdHJva2Utd2lkdGg9XCIxXCI+PC9zdmc6cGF0aD5cbiAgICBgXG4gICAgfSlcbl0sIENvbG9yQ29udHJhc3RTdmdDb21wb25lbnQpO1xuXG5jb25zdCBQVUJMSUNfRElSRUNUSVZFUyA9IFtcbiAgICBDb2xvclBpY2tlckNvbXBvbmVudCxcbiAgICBDb2xvclBhbGV0dGVDb21wb25lbnQsXG4gICAgQ29sb3JHcmFkaWVudENvbXBvbmVudCxcbiAgICBGbGF0Q29sb3JQaWNrZXJDb21wb25lbnQsXG4gICAgTG9jYWxpemVkQ29sb3JQaWNrZXJNZXNzYWdlc0RpcmVjdGl2ZSxcbiAgICBDb2xvclBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XG5dO1xuY29uc3QgSU5URVJOQUxfRElSRUNUSVZFUyA9IFtcbiAgICBDb2xvcklucHV0Q29tcG9uZW50LFxuICAgIEZvY3VzT25Eb21SZWFkeURpcmVjdGl2ZSxcbiAgICBDb250cmFzdENvbXBvbmVudCxcbiAgICBDb250cmFzdFZhbGlkYXRpb25Db21wb25lbnQsXG4gICAgRmxhdENvbG9yUGlja2VySGVhZGVyQ29tcG9uZW50LFxuICAgIEZsYXRDb2xvclBpY2tlckFjdGlvbkJ1dHRvbnNDb21wb25lbnQsXG4gICAgQ29sb3JDb250cmFzdFN2Z0NvbXBvbmVudFxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIENvbG9yUGlja2VyLlxuICovXG5sZXQgQ29sb3JQaWNrZXJNb2R1bGUgPSBjbGFzcyBDb2xvclBpY2tlck1vZHVsZSB7XG59O1xuQ29sb3JQaWNrZXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgUFVCTElDX0RJUkVDVElWRVMsXG4gICAgICAgICAgICBJTlRFUk5BTF9ESVJFQ1RJVkVTXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtQVUJMSUNfRElSRUNUSVZFU10sXG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIFNsaWRlck1vZHVsZSxcbiAgICAgICAgICAgIE51bWVyaWNUZXh0Qm94TW9kdWxlLFxuICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgUG9wdXBNb2R1bGUsXG4gICAgICAgICAgICBEcmFnZ2FibGVNb2R1bGVcbiAgICAgICAgXVxuICAgIH0pXG5dLCBDb2xvclBpY2tlck1vZHVsZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGlyZWN0aXZlIHRoYXQgcmVuZGVycyB0aGUgW0tlbmRvIFVJIENoZWNrQm94XSh7JSBzbHVnIG92ZXJ2aWV3X2NoZWNrYm94ICV9KSBpbnB1dCBjb21wb25lbnQuXG4gKiBUaGUgZGlyZWN0aXZlIGlzIHBsYWNlZCBvbiBpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBlbGVtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIga2VuZG9DaGVja0JveCAvPlxuICogYGBgXG4gKi9cbmxldCBDaGVja0JveERpcmVjdGl2ZSA9IGNsYXNzIENoZWNrQm94RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMua2VuZG9DbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NpemUgPSAnbWVkaXVtJztcbiAgICAgICAgdGhpcy5fcm91bmRlZCA9ICdtZWRpdW0nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIENoZWNrQm94XG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcHBlYXJhbmNlX2NoZWNrYm94ZGlyZWN0aXZlICV9I3RvYy1zaXplKSkuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGAnc21hbGwnYFxuICAgICAqICogYCdtZWRpdW0nYCAoZGVmYXVsdClcbiAgICAgKiAqIGAnbGFyZ2UnYFxuICAgICAqICogYG51bGxgXG4gICAgICovXG4gICAgc2V0IHNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUNsYXNzZXMoc2l6ZSwgJ3NpemUnKTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJvdW5kZWQgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBib3JkZXIgcmFkaXVzIG9mIHRoZSBDaGVja0JveFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBwZWFyYW5jZV9jaGVja2JveGRpcmVjdGl2ZSAlfSN0b2Mtcm91bmRlZCkpLlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgJ3NtYWxsJ2BcbiAgICAgKiAqIGAnbWVkaXVtJ2AgKGRlZmF1bHQpXG4gICAgICogKiBgJ2xhcmdlJ2BcbiAgICAgKiAqIGBudWxsYFxuICAgICAqL1xuICAgIHNldCByb3VuZGVkKHJvdW5kZWQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGFzc2VzKHJvdW5kZWQsICdyb3VuZGVkJyk7XG4gICAgICAgIHRoaXMuX3JvdW5kZWQgPSByb3VuZGVkO1xuICAgIH1cbiAgICBnZXQgcm91bmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdW5kZWQ7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgY29uc3Qgc3R5bGluZ0lucHV0cyA9IFsnc2l6ZScsICdyb3VuZGVkJ107XG4gICAgICAgIHN0eWxpbmdJbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsYXNzZXModGhpc1tpbnB1dF0sIGlucHV0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUNsYXNzZXModmFsdWUsIGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBnZXRTdHlsaW5nQ2xhc3NlcygnY2hlY2tib3gnLCBpbnB1dCwgdGhpc1tpbnB1dF0sIHZhbHVlKTtcbiAgICAgICAgaWYgKGNsYXNzZXMudG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbSwgY2xhc3Nlcy50b1JlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzZXMudG9BZGQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbSwgY2xhc3Nlcy50b0FkZCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY2hlY2tib3gnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENoZWNrQm94RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJrZW5kb0NsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIENoZWNrQm94RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaXplXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBDaGVja0JveERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicm91bmRlZFwiLCBudWxsKTtcbkNoZWNrQm94RGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFtrZW5kb0NoZWNrQm94XSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JlbmRlcmVyMixcbiAgICAgICAgRWxlbWVudFJlZl0pXG5dLCBDaGVja0JveERpcmVjdGl2ZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIENoZWNrQm94IGRpcmVjdGl2ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBDaGVja0JveCBtb2R1bGVcbiAqIGltcG9ydCB7IENoZWNrQm94TW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItaW5wdXRzJztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgQ2hlY2tCb3hNb2R1bGVdLCAvLyBpbXBvcnQgQ2hlY2tCb3ggbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5sZXQgQ2hlY2tCb3hNb2R1bGUgPSBjbGFzcyBDaGVja0JveE1vZHVsZSB7XG59O1xuQ2hlY2tCb3hNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0NoZWNrQm94RGlyZWN0aXZlXSxcbiAgICAgICAgZXhwb3J0czogW0NoZWNrQm94RGlyZWN0aXZlXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICB9KVxuXSwgQ2hlY2tCb3hNb2R1bGUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRpcmVjdGl2ZSB0aGF0IHJlbmRlcnMgdGhlIFtLZW5kbyBVSSBSYWRpb0J1dHRvbl0oeyUgc2x1ZyBvdmVydmlld19jaGVja2JveCAlfSkgaW5wdXQgY29tcG9uZW50LlxuICogVGhlIGRpcmVjdGl2ZSBpcyBwbGFjZWQgb24gaW5wdXQgdHlwZT1cInJhZGlvXCIgZWxlbWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogPGlucHV0IHR5cGU9XCJyYWRpb1wiIGtlbmRvUmFkaW9CdXR0b24gLz5cbiAqIGBgYFxuICovXG5sZXQgUmFkaW9CdXR0b25EaXJlY3RpdmUgPSBjbGFzcyBSYWRpb0J1dHRvbkRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLmtlbmRvQ2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zaXplID0gJ21lZGl1bSc7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIFJhZGlvQnV0dG9uXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcHBlYXJhbmNlX3JhZGlvYnV0dG9uZGlyZWN0aXZlICV9I3RvYy1zaXplKSkuXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgJ3NtYWxsJ2BcbiAgICAgKiAqIGAnbWVkaXVtJ2AgKGRlZmF1bHQpXG4gICAgICogKiBgJ2xhcmdlJ2BcbiAgICAgKiAqIGBudWxsYFxuICAgICAqL1xuICAgIHNldCBzaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGFzc2VzKHNpemUsICdzaXplJyk7XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgLy8ga2VwdCBpbiBzeW5jIHdpdGggb3RoZXIgaW5wdXRzIGZvciBlYXNpZXIgcmVmYWN0b3JpbmdcbiAgICAgICAgLy8gdG8gYSBjb21tb24gYmFzZSBjbGFzc1xuICAgICAgICBjb25zdCBzdHlsaW5nSW5wdXRzID0gWydzaXplJ107XG4gICAgICAgIHN0eWxpbmdJbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsYXNzZXModGhpc1tpbnB1dF0sIGlucHV0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUNsYXNzZXModmFsdWUsIGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBnZXRTdHlsaW5nQ2xhc3NlcygncmFkaW8nLCBpbnB1dCwgdGhpc1tpbnB1dF0sIHZhbHVlKTtcbiAgICAgICAgaWYgKGNsYXNzZXMudG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbSwgY2xhc3Nlcy50b1JlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzZXMudG9BZGQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbSwgY2xhc3Nlcy50b0FkZCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstcmFkaW8nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFJhZGlvQnV0dG9uRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJrZW5kb0NsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIFJhZGlvQnV0dG9uRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaXplXCIsIG51bGwpO1xuUmFkaW9CdXR0b25EaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ2lucHV0W2tlbmRvUmFkaW9CdXR0b25dJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUmVuZGVyZXIyLCBFbGVtZW50UmVmXSlcbl0sIFJhZGlvQnV0dG9uRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgUmFkaW9CdXR0b24gZGlyZWN0aXZlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIFJhZGlvQnV0dG9uIG1vZHVsZVxuICogaW1wb3J0IHsgUmFkaW9CdXR0b25Nb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBSYWRpb0J1dHRvbk1vZHVsZV0sIC8vIGltcG9ydCBSYWRpb0J1dHRvbiBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBSYWRpb0J1dHRvbk1vZHVsZSA9IGNsYXNzIFJhZGlvQnV0dG9uTW9kdWxlIHtcbn07XG5SYWRpb0J1dHRvbk1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbUmFkaW9CdXR0b25EaXJlY3RpdmVdLFxuICAgICAgICBleHBvcnRzOiBbUmFkaW9CdXR0b25EaXJlY3RpdmVdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxuICAgIH0pXG5dLCBSYWRpb0J1dHRvbk1vZHVsZSk7XG5cbmxldCBzZXJpYWwkMiA9IDA7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgYmUgc2hvd24gdW5kZXJuZWF0aFxuICogYSBLZW5kbyBjb250cm9sIG9yIG5hdGl2ZSBIVE1MIGZvcm0tYm91bmQgY29tcG9uZW50IGFmdGVyIGEgdmFsaWRhdGlvbi5cbiAqL1xubGV0IEVycm9yQ29tcG9uZW50ID0gY2xhc3MgRXJyb3JDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgYmUgc2hvd24gdW5kZXJuZWF0aFxuICAgICAqIGEgS2VuZG8gY29udHJvbCBvciBuYXRpdmUgSFRNTCBmb3JtLWJvdW5kIGNvbXBvbmVudCBhZnRlciBhIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgYWxpZ25tZW50IG9mIHRoZSBFcnJvciBtZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiAoRGVmYXVsdCkgYHN0YXJ0YFxuICAgICAgICAgKiAqIGBlbmRgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsaWduID0gJ3N0YXJ0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBga2VuZG8tZXJyb3ItJHtzZXJpYWwkMisrfWA7XG4gICAgICAgIHRoaXMucm9sZUF0dHJpYnV0ZSA9ICdhbGVydCc7XG4gICAgfVxuICAgIGdldCBzdGFydENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGlnbiA9PT0gJ3N0YXJ0JztcbiAgICB9XG4gICAgZ2V0IGVuZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGlnbiA9PT0gJ2VuZCc7XG4gICAgfVxuICAgIGdldCBpZEF0dHJpYnV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWZvcm0tZXJyb3InKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEVycm9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0Q2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEVycm9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbGlnblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBFcnJvckNvbXBvbmVudC5wcm90b3R5cGUsIFwicm9sZUF0dHJpYnV0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdGV4dC1zdGFydCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBFcnJvckNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXRleHQtZW5kJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEVycm9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlbmRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmlkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRXJyb3JDb21wb25lbnQucHJvdG90eXBlLCBcImlkQXR0cmlidXRlXCIsIG51bGwpO1xuRXJyb3JDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZvcm1lcnJvcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgXG4gICAgfSlcbl0sIEVycm9yQ29tcG9uZW50KTtcblxubGV0IHNlcmlhbCQzID0gMDtcbi8qKlxuICogUmVwcmVzZW50cyBhIGhpbnQgbWVzc2FnZSB0aGF0IHdpbGwgYmUgc2hvd24gdW5kZXJuZWF0aCBhIGZvcm0tYm91bmQgY29tcG9uZW50LlxuICovXG5sZXQgSGludENvbXBvbmVudCA9IGNsYXNzIEhpbnRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBoaW50IG1lc3NhZ2UgdGhhdCB3aWxsIGJlIHNob3duIHVuZGVybmVhdGggYSBmb3JtLWJvdW5kIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgYWxpZ25tZW50IG9mIHRoZSBIaW50IG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgc3RhcnRgXG4gICAgICAgICAqICogYGVuZGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGBrZW5kby1oaW50LSR7c2VyaWFsJDMrK31gO1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgfVxuICAgIGdldCBzdGFydENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGlnbiA9PT0gJ3N0YXJ0JztcbiAgICB9XG4gICAgZ2V0IGVuZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGlnbiA9PT0gJ2VuZCc7XG4gICAgfVxuICAgIGdldCBpZEF0dHJpYnV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEhpbnRDb21wb25lbnQucHJvdG90eXBlLCBcImFsaWduXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1mb3JtLWhpbnQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEhpbnRDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdGV4dC1zdGFydCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBIaW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstdGV4dC1lbmQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgSGludENvbXBvbmVudC5wcm90b3R5cGUsIFwiZW5kQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5pZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEhpbnRDb21wb25lbnQucHJvdG90eXBlLCBcImlkQXR0cmlidXRlXCIsIG51bGwpO1xuSGludENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZm9ybWhpbnQnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYFxuICAgIH0pXG5dLCBIaW50Q29tcG9uZW50KTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBjb250YWluZXIgZm9yIGZvcm0tYm91bmQgY29udHJvbHMgKEtlbmRvIGNvbnRyb2xzIG9yIG5hdGl2ZSBIVE1MIGNvbnRyb2xzKS5cbiAqIEFwcGxpZXMgc3R5bGluZyBhbmQgYmVoYXZpb3IgcnVsZXMuXG4gKi9cbmxldCBGb3JtRmllbGRDb21wb25lbnQgPSBjbGFzcyBGb3JtRmllbGRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBsb2NhbGl6YXRpb25TZXJ2aWNlLCBob3N0RWxlbWVudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZW4gdGhlIEhpbnQgbWVzc2FnZXMgd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqXG4gICAgICAgICAqICogKERlZmF1bHQpIGBpbml0aWFsYCZtZGFzaDtBbGxvd3MgZGlzcGxheWluZyBoaW50cyB3aGVuIHRoZSBmb3JtLWJvdW5kIGNvbXBvbmVudCBzdGF0ZSBpc1xuICAgICAgICAgKiBgdmFsaWRgIG9yIGB1bnRvdWNoZWRgIGFuZCBgcHJpc3RpbmVgLlxuICAgICAgICAgKiAqIGBhbHdheXNgJm1kYXNoO0FsbG93cyBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgaGludHMuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dIaW50cyA9ICdpbml0aWFsJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbGF5b3V0IG9yaWVudGF0aW9uIG9mIHRoZSBmb3JtIGZpZWxkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgdmVydGljYWxgXG4gICAgICAgICAqICogYGhvcml6b250YWxgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGVuIHRoZSBFcnJvciBtZXNzYWdlcyB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICpcbiAgICAgICAgICogKiAoRGVmYXVsdCkgYGluaXRpYWxgJm1kYXNoO0FsbG93cyBkaXNwbGF5aW5nIGVycm9ycyB3aGVuIHRoZSBmb3JtLWJvdW5kIGNvbXBvbmVudCBzdGF0ZSBpc1xuICAgICAgICAgKiBgaW52YWxpZGAgYW5kIGB0b3VjaGVkYCBvciBgZGlydHlgLlxuICAgICAgICAgKiAqIGBhbHdheXNgJm1kYXNoO0FsbG93cyBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZXJyb3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93RXJyb3JzID0gJ2luaXRpYWwnO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMucnRsID0gZmFsc2U7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ydGwgPSBydGw7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMucnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBnZXQgZXJyb3JDbGFzcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sLmludmFsaWQgJiYgKHRoaXMuY29udHJvbC50b3VjaGVkIHx8IHRoaXMuY29udHJvbC5kaXJ0eSk7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJhZGlvYnV0dG9uIGdyb3VwXG4gICAgICAgIGlmICh0aGlzLmlzUmFkaW9Db250cm9sKHRoaXMuY29udHJvbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZENvbnRyb2woKSB8fFxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZEVsZW1lbnQoKSB8fFxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZEtlbmRvSW5wdXQoKTtcbiAgICB9XG4gICAgc2V0IGZvcm1Db250cm9scyhmb3JtQ29udHJvbHMpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUZvcm1Db250cm9sKGZvcm1Db250cm9scyk7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IGZvcm1Db250cm9scy5maXJzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBob3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhhc0hpbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93SGludHMgPT09ICdhbHdheXMnID8gdHJ1ZSA6IHRoaXMuc2hvd0hpbnRzSW5pdGlhbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhhc0Vycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvd0Vycm9ycyA9PT0gJ2Fsd2F5cycgPyB0cnVlIDogdGhpcy5zaG93RXJyb3JzSW5pdGlhbCgpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuc2V0RGVzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBkaXNhYmxlZEtlbmRvSW5wdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtlbmRvSW5wdXQgJiYgdGhpcy5rZW5kb0lucHV0LmRpc2FibGVkO1xuICAgIH1cbiAgICBkaXNhYmxlZENvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wuZGlzYWJsZWQ7XG4gICAgfVxuICAgIGRpc2FibGVkRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmNvbnRyb2xFbGVtZW50UmVmcy50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiBlbGVtZW50cy5ldmVyeShlID0+IGUubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUZvcm1Db250cm9sKGZvcm1Db250cm9scykge1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgZm9ybUNvbnRyb2xzLmxlbmd0aCAhPT0gMSAmJiAhdGhpcy5pc0NvbnRyb2xHcm91cChmb3JtQ29udHJvbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBga2VuZG8tZm9ybWZpZWxkYCBjb21wb25lbnQgc2hvdWxkIGNvbnRhaW4gJyArXG4gICAgICAgICAgICAgICAgJ29ubHkgb25lIGNvbnRyb2wgb2YgdHlwZSBOZ0NvbnRyb2wgd2l0aCBhIGZvcm1Db250cm9sTmFtZShodHRwczovL2FuZ3VsYXIuaW8vYXBpL2Zvcm1zL0Zvcm1Db250cm9sTmFtZSknICtcbiAgICAgICAgICAgICAgICAnb3IgYW4gbmdNb2RlbChodHRwczovL2FuZ3VsYXIuaW8vYXBpL2Zvcm1zL05nTW9kZWwpIGJpbmRpbmcuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNDb250cm9sR3JvdXAoZm9ybUNvbnRyb2xzKSB7XG4gICAgICAgIGlmICghZm9ybUNvbnRyb2xzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmb3JtQ29udHJvbHMuZmlyc3QubmFtZTtcbiAgICAgICAgcmV0dXJuIGZvcm1Db250cm9scy50b0FycmF5KCkuZXZlcnkoYyA9PiBjLm5hbWUgPT09IG5hbWUgJiYgKHRoaXMuaXNSYWRpb0NvbnRyb2woYykpKTtcbiAgICB9XG4gICAgaXNSYWRpb0NvbnRyb2woY29udHJvbCkge1xuICAgICAgICByZXR1cm4gY29udHJvbC52YWx1ZUFjY2Vzc29yIGluc3RhbmNlb2YgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9XG4gICAgdXBkYXRlRGVzY3JpcHRpb24oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpcy5maW5kQ29udHJvbEVsZW1lbnRzKCk7XG4gICAgICAgIGlmICghY29udHJvbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9scy5mb3JFYWNoKChjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvckNoaWxkcmVuLmxlbmd0aCA+IDAgfHwgdGhpcy5oaW50Q2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyaWFJZHMgPSB0aGlzLmdlbmVyYXRlRGVzY3JpcHRpb25JZHMoY29udHJvbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoY29udHJvbCwgJ2FyaWEtZGVzY3JpYmVkYnknLCBhcmlhSWRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbmRDb250cm9sRWxlbWVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250cm9sRWxlbWVudFJlZnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgY29udHJvbCBpcyBLZW5kb0lucHV0IGFuZCBoYXMgZm9jdXNhYmxlSWQgLSBkcm9wZG93bnMsIGRhdGVpbnB1dHNcbiAgICAgICAgaWYgKHRoaXMua2VuZG9JbnB1dCAmJiB0aGlzLmtlbmRvSW5wdXQuZm9jdXNhYmxlSWQgJiYgaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKGAjJHt0aGlzLmtlbmRvSW5wdXQuZm9jdXNhYmxlSWR9YCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xFbGVtZW50UmVmcy5tYXAoZWwgPT4gZWwubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuICAgIGdlbmVyYXRlRGVzY3JpcHRpb25JZHMoY29udHJvbCkge1xuICAgICAgICBjb25zdCBpZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChjb250cm9sLmhhc0F0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY29udHJvbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIuaW5jbHVkZXMoJ2tlbmRvLWhpbnQtJykgfHwgYXR0ci5pbmNsdWRlcygna2VuZG8tZXJyb3ItJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHMuYWRkKGF0dHIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaW50Q2hpbGRyZW4uZm9yRWFjaCgoaGludCkgPT4ge1xuICAgICAgICAgICAgaWRzLmFkZChoaW50LmlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXJyb3JDaGlsZHJlbi5mb3JFYWNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWRzLmFkZChlcnJvci5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShpZHMpLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgc2hvd0hpbnRzSW5pdGlhbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdmFsaWQsIHVudG91Y2hlZCwgcHJpc3RpbmUgfSA9IHRoaXMuY29udHJvbDtcbiAgICAgICAgcmV0dXJuIHZhbGlkIHx8ICh1bnRvdWNoZWQgJiYgcHJpc3RpbmUpO1xuICAgIH1cbiAgICBzaG93RXJyb3JzSW5pdGlhbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGludmFsaWQsIGRpcnR5LCB0b3VjaGVkIH0gPSB0aGlzLmNvbnRyb2w7XG4gICAgICAgIHJldHVybiBpbnZhbGlkICYmIChkaXJ0eSB8fCB0b3VjaGVkKTtcbiAgICB9XG4gICAgc2V0RGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRGVzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmVycm9yQ2hpbGRyZW4uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGVEZXNjcmlwdGlvbigpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5oaW50Q2hpbGRyZW4uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGVEZXNjcmlwdGlvbigpKSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWZvcm0tZmllbGQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEZvcm1GaWVsZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5kaXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRm9ybUZpZWxkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWZvcm0tZmllbGQtZXJyb3InKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRm9ybUZpZWxkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvckNsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZm9ybS1maWVsZC1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBGb3JtRmllbGRDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oTmdDb250cm9sLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUXVlcnlMaXN0XSlcbl0sIEZvcm1GaWVsZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybUNvbnRyb2xzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKE5nQ29udHJvbCwgeyByZWFkOiBFbGVtZW50UmVmLCBkZXNjZW5kYW50czogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgRm9ybUZpZWxkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250cm9sRWxlbWVudFJlZnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChLZW5kb0lucHV0LCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRm9ybUZpZWxkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJrZW5kb0lucHV0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oRXJyb3JDb21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIEZvcm1GaWVsZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JDaGlsZHJlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKEhpbnRDb21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIEZvcm1GaWVsZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGludENoaWxkcmVuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGb3JtRmllbGRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dIaW50c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRm9ybUZpZWxkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcmllbnRhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRm9ybUZpZWxkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93RXJyb3JzXCIsIHZvaWQgMCk7XG5Gb3JtRmllbGRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZvcm1maWVsZCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsLCBrZW5kby1sYWJlbFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPGRpdiBbY2xhc3Muay1mb3JtLWZpZWxkLXdyYXBdPVwiaG9yaXpvbnRhbFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwia2VuZG8tZm9ybWhpbnRcIiAqbmdJZj1cImhhc0hpbnRzXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwia2VuZG8tZm9ybWVycm9yXCIgKm5nSWY9XCJoYXNFcnJvcnNcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmZvcm1maWVsZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUmVuZGVyZXIyLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmXSlcbl0sIEZvcm1GaWVsZENvbXBvbmVudCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIEZvcm1GaWVsZCwgRXJyb3IgYW5kIEhpbnQgY29tcG9uZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBGb3JtRmllbGQgbW9kdWxlXG4gKiBpbXBvcnQgeyBGb3JtRmllbGRNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBGb3JtRmllbGRNb2R1bGVdLCAvLyBpbXBvcnQgRm9ybUZpZWxkIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xubGV0IEZvcm1GaWVsZE1vZHVsZSA9IGNsYXNzIEZvcm1GaWVsZE1vZHVsZSB7XG59O1xuRm9ybUZpZWxkTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtIaW50Q29tcG9uZW50LCBFcnJvckNvbXBvbmVudCwgRm9ybUZpZWxkQ29tcG9uZW50XSxcbiAgICAgICAgZXhwb3J0czogW0hpbnRDb21wb25lbnQsIEVycm9yQ29tcG9uZW50LCBGb3JtRmllbGRDb21wb25lbnRdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxuICAgIH0pXG5dLCBGb3JtRmllbGRNb2R1bGUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBJbnB1dHMgY29tcG9uZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBJbnB1dHMgbW9kdWxlXG4gKiBpbXBvcnQgeyBJbnB1dHNNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKiBpbXBvcnQgeyBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSwgSW5wdXRzTW9kdWxlXSwgLy8gaW1wb3J0IElucHV0cyBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBJbnB1dHNNb2R1bGUgPSBjbGFzcyBJbnB1dHNNb2R1bGUge1xufTtcbklucHV0c01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgVGV4dEFyZWFNb2R1bGUsXG4gICAgICAgICAgICBUZXh0Qm94TW9kdWxlLFxuICAgICAgICAgICAgU2xpZGVyTW9kdWxlLFxuICAgICAgICAgICAgUmFuZ2VTbGlkZXJNb2R1bGUsXG4gICAgICAgICAgICBTd2l0Y2hNb2R1bGUsXG4gICAgICAgICAgICBOdW1lcmljVGV4dEJveE1vZHVsZSxcbiAgICAgICAgICAgIE1hc2tlZFRleHRCb3hNb2R1bGUsXG4gICAgICAgICAgICBDb2xvclBpY2tlck1vZHVsZSxcbiAgICAgICAgICAgIENoZWNrQm94TW9kdWxlLFxuICAgICAgICAgICAgUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgICAgICBGb3JtRmllbGRNb2R1bGVcbiAgICAgICAgXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICB9KVxuXSwgSW5wdXRzTW9kdWxlKTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBDb2xvckNvbnRyYXN0U3ZnQ29tcG9uZW50LCBDb2xvcklucHV0Q29tcG9uZW50LCBDb250cmFzdFZhbGlkYXRpb25Db21wb25lbnQsIENvbnRyYXN0Q29tcG9uZW50LCBGbGF0Q29sb3JQaWNrZXJBY3Rpb25CdXR0b25zQ29tcG9uZW50LCBGbGF0Q29sb3JQaWNrZXJIZWFkZXJDb21wb25lbnQsIEZvY3VzT25Eb21SZWFkeURpcmVjdGl2ZSwgQ29sb3JHcmFkaWVudExvY2FsaXphdGlvblNlcnZpY2UsIENvbG9yUGFsZXR0ZUxvY2FsaXphdGlvblNlcnZpY2UsIENvbG9yUGlja2VyTG9jYWxpemF0aW9uU2VydmljZSwgQ29sb3JQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCwgRmxhdENvbG9yUGlja2VyTG9jYWxpemF0aW9uU2VydmljZSwgQ29sb3JQaWNrZXJNZXNzYWdlcywgQ29sb3JQYWxldHRlU2VydmljZSwgRmxhdENvbG9yUGlja2VyU2VydmljZSwgTWFza2luZ1NlcnZpY2UsIE51bWVyaWNUZXh0Qm94TWVzc2FnZXMsIFJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsIFJhbmdlU2xpZGVyTWVzc2FnZXMsIFNIQVJFRF9ESVJFQ1RJVkVTLCBTbGlkZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCwgU2xpZGVyTWVzc2FnZXMsIFNsaWRlckJhc2UsIFNsaWRlcnNDb21tb25Nb2R1bGUsIFN3aXRjaEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LCBNZXNzYWdlcywgVGV4dEZpZWxkc0Jhc2UsIFRleHRCb3hDdXN0b21NZXNzYWdlc0NvbXBvbmVudCwgVGV4dEJveE1lc3NhZ2VzLCBTbGlkZXJDb21wb25lbnQsIFJhbmdlU2xpZGVyQ29tcG9uZW50LCBMYWJlbFRlbXBsYXRlRGlyZWN0aXZlLCBTd2l0Y2hDb21wb25lbnQsIFRleHRCb3hEaXJlY3RpdmUsIFRleHRBcmVhRGlyZWN0aXZlLCBOdW1lcmljVGV4dEJveENvbXBvbmVudCwgTnVtZXJpY1RleHRCb3hDdXN0b21NZXNzYWdlc0NvbXBvbmVudCwgTWFza2VkVGV4dEJveENvbXBvbmVudCwgSW5wdXRzTW9kdWxlLCBTbGlkZXJUaWNrc0NvbXBvbmVudCwgU2xpZGVyTW9kdWxlLCBSYW5nZVNsaWRlck1vZHVsZSwgU3dpdGNoTW9kdWxlLCBOdW1lcmljVGV4dEJveE1vZHVsZSwgTWFza2VkVGV4dEJveE1vZHVsZSwgVGV4dEJveE1vZHVsZSwgVGV4dEFyZWFNb2R1bGUsIENoZWNrQm94TW9kdWxlLCBSYWRpb0J1dHRvbk1vZHVsZSwgQ29sb3JQaWNrZXJDb21wb25lbnQsIENvbG9yUGFsZXR0ZUNvbXBvbmVudCwgQ29sb3JHcmFkaWVudENvbXBvbmVudCwgQ29sb3JQaWNrZXJNb2R1bGUsIEZsYXRDb2xvclBpY2tlckNvbXBvbmVudCwgQ2hlY2tCb3hEaXJlY3RpdmUsIFJhZGlvQnV0dG9uRGlyZWN0aXZlLCBIaW50Q29tcG9uZW50LCBFcnJvckNvbXBvbmVudCwgRm9ybUZpZWxkQ29tcG9uZW50LCBGb3JtRmllbGRNb2R1bGUsIFRleHRCb3hDb21wb25lbnQsIFRleHRCb3hQcmVmaXhUZW1wbGF0ZURpcmVjdGl2ZSwgVGV4dEJveFN1ZmZpeFRlbXBsYXRlRGlyZWN0aXZlLCBUZXh0QXJlYUNvbXBvbmVudCwgVGV4dEFyZWFTdWZmaXhDb21wb25lbnQsIElucHV0U2VwYXJhdG9yQ29tcG9uZW50LCBTaGFyZWRNb2R1bGUsIExvY2FsaXplZENvbG9yUGlja2VyTWVzc2FnZXNEaXJlY3RpdmUsIExvY2FsaXplZE51bWVyaWNUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmUsIExvY2FsaXplZFRleHRCb3hNZXNzYWdlc0RpcmVjdGl2ZSwgTG9jYWxpemVkU2xpZGVyTWVzc2FnZXNEaXJlY3RpdmUsIExvY2FsaXplZFJhbmdlU2xpZGVyTWVzc2FnZXNEaXJlY3RpdmUsIExvY2FsaXplZFN3aXRjaE1lc3NhZ2VzRGlyZWN0aXZlLCBDb2xvclBpY2tlckNhbmNlbEV2ZW50LCBDb2xvclBpY2tlckNsb3NlRXZlbnQsIENvbG9yUGlja2VyT3BlbkV2ZW50LCBBY3RpdmVDb2xvckNsaWNrRXZlbnQgfTtcbiJdfQ==