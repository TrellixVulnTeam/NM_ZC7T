/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Component, HostBinding, Input } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { isPresent } from '../common/utils';
import { AA_RATIO, STEP_COUNT, AAA_RATIO } from './constants';
import { bezierCommand, getContrastFromTwoRGBAs, getRGBA, getColorFromHSV, svgPath, controlPoint, line } from './utils';
/**
 * @hidden
 */
let ColorContrastSvgComponent = class ColorContrastSvgComponent {
    /**
     * @hidden
     */
    constructor() {
        this.hostClass = true;
    }
    ngAfterViewInit() {
        this.metrics = this.wrapper.getBoundingClientRect();
        this.oldA = this.hsva.value.a;
        this.oldH = this.hsva.value.h;
        this.hsva.subscribe((value) => {
            if (value.h !== this.oldH || value.a !== this.oldA) {
                this.oldH = value.h;
                this.oldA = value.a;
                this.setPaths();
            }
        });
    }
    ngOnChanges(changes) {
        if (isPresent(changes.backgroundColor) && this.metrics) {
            this.setPaths();
        }
    }
    setPaths() {
        const bezierCommandCalc = bezierCommand(controlPoint(line));
        this.paths = [svgPath(this.getPaths(AA_RATIO, STEP_COUNT), bezierCommandCalc),
            svgPath(this.getPaths(AA_RATIO, STEP_COUNT, true), bezierCommandCalc),
            svgPath(this.getPaths(AAA_RATIO, STEP_COUNT), bezierCommandCalc),
            svgPath(this.getPaths(AAA_RATIO, STEP_COUNT, true), bezierCommandCalc)];
    }
    findValue(contrast, saturation, low, high, comparer) {
        const mid = (low + high) / 2;
        const hsva = Object.assign({}, this.hsva.value, { s: saturation / this.metrics.width, v: 1 - mid / this.metrics.height });
        const currentContrast = getContrastFromTwoRGBAs(getRGBA(getColorFromHSV(hsva)), getRGBA(this.backgroundColor || ''));
        if (low + 0.5 > high) {
            if (currentContrast < contrast + 1 && currentContrast > contrast - 1) {
                return mid;
            }
            else {
                return null;
            }
        }
        if (comparer(currentContrast, contrast)) {
            return this.findValue(contrast, saturation, low, high - (high - low) / 2, comparer);
        }
        return this.findValue(contrast, saturation, low + (high - low) / 2, high, comparer);
    }
    getPaths(contrast, stepCount, reversed = false) {
        const points = [];
        for (let i = 0; i <= this.metrics.width; i += this.metrics.width / stepCount) {
            const value = this.findValue(contrast, i, 0, this.metrics.height, reversed ? ((a, b) => a < b) : ((a, b) => a > b));
            if (value !== null) {
                points.push([i, value]);
            }
        }
        return points;
    }
};
tslib_1.__decorate([
    HostBinding('class.k-color-contrast-svg'),
    tslib_1.__metadata("design:type", Boolean)
], ColorContrastSvgComponent.prototype, "hostClass", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], ColorContrastSvgComponent.prototype, "wrapper", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", BehaviorSubject)
], ColorContrastSvgComponent.prototype, "hsva", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorContrastSvgComponent.prototype, "backgroundColor", void 0);
ColorContrastSvgComponent = tslib_1.__decorate([
    Component({
        selector: '[kendoColorContrastSvg]',
        template: `
        <svg:path *ngFor="let path of paths" [attr.d]="path" fill="none" stroke="white" stroke-width="1"></svg:path>
    `
    })
], ColorContrastSvgComponent);
export { ColorContrastSvgComponent };
