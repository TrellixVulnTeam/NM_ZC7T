/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Component, Input, Output, EventEmitter, ElementRef, HostBinding, ViewChild, Renderer2 } from '@angular/core';
import { getRGBA, parseColor, getColorFromRGBA } from './utils';
import { isPresent } from '../common/utils';
import { guid, isDocumentAvailable } from '@progress/kendo-angular-common';
import { Subscription } from 'rxjs';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { NumericTextBoxComponent } from './../numerictextbox/numerictextbox.component';
/**
 * @hidden
 */
let ColorInputComponent = class ColorInputComponent {
    constructor(host, renderer, localizationService) {
        this.host = host;
        this.renderer = renderer;
        this.localizationService = localizationService;
        /**
         * The id of the hex input.
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Sets whether the alpha slider will be shown.
         */
        this.opacity = true;
        /**
         * Sets the disabled state of the ColorInput.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorInput.
         */
        this.readonly = false;
        /**
         * Emits a parsed rgba string color.
         */
        this.valueChange = new EventEmitter();
        this.colorInputClass = true;
        /**
         * The rgba inputs values.
         */
        this.rgba = {};
        this.subscriptions = new Subscription();
    }
    /**
     * Indicates whether any of the inputs are focused.
     */
    get isFocused() {
        if (!(isDocumentAvailable() && isPresent(this.host))) {
            return false;
        }
        const activeElement = document.activeElement;
        return this.host.nativeElement.contains(activeElement);
    }
    /**
     * Indicates whether any of the rgba inputs have value.
     */
    get rgbaInputValid() {
        return Object.keys(this.rgba).every(key => isPresent(this.rgba[key]));
    }
    ngAfterViewInit() {
        this.initDomEvents();
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        if (isPresent(changes.value) && !this.isFocused) {
            this.hex = parseColor(this.value, 'hex', this.opacity);
            this.rgba = getRGBA(this.value);
            this.rgba.a = parseColor(this.value, 'rgba', this.opacity) ? this.rgba.a : 1;
        }
    }
    get formatButtonTitle() {
        return this.localizationService.get('formatButton');
    }
    handleRgbaValueChange() {
        const color = getColorFromRGBA(this.rgba);
        if (!this.rgbaInputValid || color === this.value) {
            return;
        }
        this.value = color;
        this.rgba = getRGBA(this.value);
        this.hex = parseColor(color, 'hex', this.opacity);
        this.valueChange.emit(color);
    }
    handleHexValueChange(hex) {
        this.hex = hex;
        const color = parseColor(hex, 'rgba', this.opacity);
        if (!isPresent(color) || color === this.value) {
            return;
        }
        this.value = color;
        this.rgba = getRGBA(color);
        this.valueChange.emit(color);
    }
    handleRgbaInputBlur() {
        if (!this.rgbaInputValid) {
            this.rgba = getRGBA(this.value);
        }
    }
    handleHexInputBlur() {
        this.hex = parseColor(this.value, 'hex', this.opacity);
    }
    toggleFormatView() {
        this.formatView = this.formatView === 'hex' ? 'rgba' : 'hex';
    }
    initDomEvents() {
        if (!this.host) {
            return;
        }
        this.subscriptions.add(this.renderer.listen(this.toggleFormatButton.nativeElement, 'click', () => this.toggleFormatView()));
    }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorInputComponent.prototype, "focusableId", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorInputComponent.prototype, "formatView", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorInputComponent.prototype, "value", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorInputComponent.prototype, "opacity", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorInputComponent.prototype, "disabled", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorInputComponent.prototype, "readonly", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorInputComponent.prototype, "valueChange", void 0);
tslib_1.__decorate([
    HostBinding('class.k-colorgradient-inputs'),
    HostBinding('class.k-hstack'),
    tslib_1.__metadata("design:type", Boolean)
], ColorInputComponent.prototype, "colorInputClass", void 0);
tslib_1.__decorate([
    ViewChild('opacityInput', { static: false }),
    tslib_1.__metadata("design:type", NumericTextBoxComponent)
], ColorInputComponent.prototype, "opacityInput", void 0);
tslib_1.__decorate([
    ViewChild('hexInput', { read: ElementRef, static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], ColorInputComponent.prototype, "hexInput", void 0);
tslib_1.__decorate([
    ViewChild('blueInput', { read: ElementRef, static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], ColorInputComponent.prototype, "blueInput", void 0);
tslib_1.__decorate([
    ViewChild('toggleFormatButton', { static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], ColorInputComponent.prototype, "toggleFormatButton", void 0);
ColorInputComponent = tslib_1.__decorate([
    Component({
        selector: 'kendo-colorinput',
        template: `
        <div class="k-vstack">
            <button #toggleFormatButton
                class="k-colorgradient-toggle-mode k-button k-button-md k-button-flat k-button-flat-base k-icon-button"
                [attr.aria-label]="formatButtonTitle"
                [attr.title]="formatButtonTitle"
                type="button"
            >
                <span class="k-button-icon k-icon k-i-arrows-kpi"></span>
            </button>
        </div>
        <div *ngIf="formatView === 'hex'" class="k-vstack">
            <input
                #hexInput
                [id]="focusableId"
                class="k-input k-textbox k-input-solid k-input-md k-rounded-md k-hex-value"
                [disabled]="disabled"
                [readonly]="readonly"
                [value]="hex || ''"
                (blur)="handleHexInputBlur()"
                (input)="handleHexValueChange(hexInput.value)"
            />
            <label [for]="focusableId" class="k-colorgradient-input-label">HEX</label>
        </div>
        <ng-container *ngIf="formatView === 'rgba'">
            <div class="k-vstack">
                <kendo-numerictextbox
                    #red
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.r"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="red.focusableId" class="k-colorgradient-input-label">R</label>
            </div>
            <div class="k-vstack">
                <kendo-numerictextbox
                    #green
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.g"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="green.focusableId" class="k-colorgradient-input-label">G</label>
            </div>
            <div class="k-vstack">
                <kendo-numerictextbox
                    #blue
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.b"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="blue.focusableId" class="k-colorgradient-input-label">B</label>
            </div>
            <div class="k-vstack" *ngIf="opacity">
                <kendo-numerictextbox  #opacityInput
                    #alpha
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="1"
                    [(value)]="rgba.a"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [step]="0.01"
                    [format]="'n2'"
                    [decimals]="2"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="alpha.focusableId" class="k-colorgradient-input-label">A</label>
            </div>
        </ng-container>
    `
    }),
    tslib_1.__metadata("design:paramtypes", [ElementRef,
        Renderer2,
        LocalizationService])
], ColorInputComponent);
export { ColorInputComponent };
