/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param } from 'tslib';
import { Injectable, NgZone, EventEmitter, Directive, Optional, TemplateRef, Input, ContentChildren, QueryList, Component, Output, HostBinding, forwardRef, Renderer2, ElementRef, ViewChild, ChangeDetectorRef, isDevMode, NgModule, ViewContainerRef, ContentChild } from '@angular/core';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { validatePackage } from '@progress/kendo-licensing';
import { hasObservers, isDocumentAvailable, Keys } from '@progress/kendo-angular-common';
import { PopupService, POPUP_CONTAINER, PopupModule } from '@progress/kendo-angular-popup';
import { CommonModule } from '@angular/common';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@progress/kendo-angular-popup';

const _c0 = ["kendoMenuList", ""];
function ListComponent_ng_container_0_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "li", 3);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    const idx_r2 = ctx_r5.index;
    const item_r1 = ctx_r5.$implicit;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-first", idx_r2 === 0)("k-last", idx_r2 === ctx_r3.items.length - 1)("k-state-disabled", item_r1.disabled);
    ɵngcc0.ɵɵproperty("item", item_r1)("level", ctx_r3.level)("vertical", ctx_r3.vertical)("animate", ctx_r3.animate)("rtl", ctx_r3.rtl)("itemTemplate", ctx_r3.itemTemplate)("itemLinkTemplate", ctx_r3.itemLinkTemplate)("openOnClick", ctx_r3.openOnClick)("index", ctx_r3.hierarchyIndex(idx_r2))("siblingIndex", idx_r2)("ngClass", item_r1.cssClass)("ngStyle", item_r1.cssStyle);
    ɵngcc0.ɵɵattribute("data-kendo-menu-index", ctx_r3.hierarchyIndex(idx_r2));
} }
function ListComponent_ng_container_0_li_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 4);
    ɵngcc0.ɵɵtext(1, " \u00A0 ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("ngClass", item_r1.cssClass)("ngStyle", item_r1.cssStyle);
} }
function ListComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ListComponent_ng_container_0_li_1_Template, 1, 19, "li", 1);
    ɵngcc0.ɵɵtemplate(2, ListComponent_ng_container_0_li_2_Template, 2, 2, "li", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r1.separator);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r1.separator);
} }
const _c1 = ["link"];
const _c2 = ["popupTemplate"];
const _c3 = ["kendoMenuItem", ""];
function ItemComponent_span_0_ng_template_2_Template(rf, ctx) { }
function ItemComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6, 7);
    ɵngcc0.ɵɵtemplate(2, ItemComponent_span_0_ng_template_2_Template, 0, 0, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    const _r6 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵclassProp("k-state-active", ctx_r0.opened);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
} }
function ItemComponent_a_1_ng_template_2_Template(rf, ctx) { }
function ItemComponent_a_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 9, 7);
    ɵngcc0.ɵɵtemplate(2, ItemComponent_a_1_ng_template_2_Template, 0, 0, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    const _r6 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵclassProp("k-state-active", ctx_r1.opened);
    ɵngcc0.ɵɵattribute("href", ctx_r1.item.url, ɵngcc0.ɵɵsanitizeUrl);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
} }
function ItemComponent_2_ng_template_0_Template(rf, ctx) { }
const _c4 = function (a0, a1) { return { item: a0, index: a1 }; };
function ItemComponent_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ItemComponent_2_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.linkTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c4, ctx_r2.item, ctx_r2.index));
} }
function ItemComponent_div_3_ng_template_1_Template(rf, ctx) { }
function ItemComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtemplate(1, ItemComponent_div_3_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.item.content)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c4, ctx_r3.item.owner, ctx_r3.item.ownerIndex));
} }
function ItemComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", 12);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("animate", ctx_r5.animate)("rtl", ctx_r5.rtl)("vertical", ctx_r5.vertical)("openOnClick", ctx_r5.openOnClick)("items", ctx_r5.children)("level", ctx_r5.level + 1)("index", ctx_r5.index)("itemTemplate", ctx_r5.itemTemplate)("itemLinkTemplate", ctx_r5.itemLinkTemplate);
    ɵngcc0.ɵɵattribute("id", ctx_r5.childId);
} }
function ItemComponent_ng_template_6_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 15);
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r14.iconClass);
} }
function ItemComponent_ng_template_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 16);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r15.item.text);
} }
function ItemComponent_ng_template_6_2_ng_template_0_Template(rf, ctx) { }
function ItemComponent_ng_template_6_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ItemComponent_ng_template_6_2_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r16.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c4, ctx_r16.item, ctx_r16.index));
} }
function ItemComponent_ng_template_6_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 17);
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassProp("k-i-arrow-60-down", !ctx_r17.horizontal)("k-i-arrow-60-right", ctx_r17.horizontal && !ctx_r17.rtl)("k-i-arrow-60-left", ctx_r17.horizontal && ctx_r17.rtl);
} }
function ItemComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ItemComponent_ng_template_6_span_0_Template, 1, 1, "span", 13);
    ɵngcc0.ɵɵtemplate(1, ItemComponent_ng_template_6_ng_container_1_Template, 3, 1, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(2, ItemComponent_ng_template_6_2_Template, 1, 5, null, 2);
    ɵngcc0.ɵɵtemplate(3, ItemComponent_ng_template_6_span_3_Template, 1, 6, "span", 14);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.item.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r7.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.hasContent);
} }
const _c5 = ["default"];
function ContextMenuComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-menu", 1);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("items", ctx_r1.rootItems)("vertical", ctx_r1.vertical)("openOnClick", ctx_r1.openOnClick)("hoverDelay", ctx_r1.hoverDelay)("animate", ctx_r1.animate)("menuItemTemplate", ctx_r1.itemTemplate.first == null ? null : ctx_r1.itemTemplate.first.templateRef)("menuItemLinkTemplate", ctx_r1.itemLinkTemplate.first == null ? null : ctx_r1.itemLinkTemplate.first.templateRef);
} }
const packageMetadata = {
    name: '@progress/kendo-angular-menu',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1647359300,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

const PARENT_REGEX = /_?\d+$/;
const SEPARATOR = '_';
let id = 0;
const itemIndexComparer = (a, b) => a.siblingIndex - b.siblingIndex;
const next = (idx, items, dir) => {
    let current = items[idx + dir];
    while (!current) {
        if (idx < 0) {
            idx = items.length - 1;
        }
        else if (idx >= items.length) {
            idx = 0;
        }
        else {
            idx += dir;
        }
        current = items[idx];
    }
    return current;
};
/**
 * @hidden
 */
let ItemsService = class ItemsService {
    /**
     * @hidden
     */
    constructor() {
        this.items = {};
        this.lists = [];
        this.idPrefix = `k-menu${id++}`;
    }
    get hasItems() {
        return Object.keys(this.items).length > 0;
    }
    childId(index) {
        return `${this.idPrefix}-child${index}`;
    }
    itemIndex(parentIndex, index) {
        return (parentIndex ? parentIndex + SEPARATOR : '') + index;
    }
    get(index) {
        return this.items[index];
    }
    add(item) {
        this.items[item.index] = item;
    }
    remove(item) {
        if (this.items[item.index] === item) {
            delete this.items[item.index];
        }
    }
    addList(list) {
        this.lists.push(list);
    }
    removeList(list) {
        const index = this.lists.indexOf(list);
        if (index >= 0) {
            this.lists.splice(index, 1);
        }
    }
    containsList(element) {
        return Boolean(this.lists.find(list => list.element.nativeElement === element));
    }
    siblings(item) {
        const parentIndex = this.parentIndex(item.index);
        return this.filter((index) => this.parentIndex(index) === parentIndex);
    }
    otherSiblings(item) {
        const parentIndex = this.parentIndex(item.index);
        return this.filter((index) => this.parentIndex(index) === parentIndex && index !== item.index);
    }
    children(item) {
        return this.filter((index) => this.parentIndex(index) === item.index);
    }
    parent(item) {
        return this.items[this.parentIndex(item.index)];
    }
    root(item) {
        return this.items[this.indices(item.index)[0]];
    }
    indices(index) {
        return index.split(SEPARATOR);
    }
    filter(predicate) {
        const result = [];
        const items = this.items;
        for (let index in items) {
            if (predicate(index, items[index])) {
                result.push(items[index]);
            }
        }
        return result.sort(itemIndexComparer);
    }
    previous(item) {
        const siblings = this.siblings(item);
        const itemIndex = siblings.indexOf(item);
        return next(itemIndex, siblings, -1);
    }
    next(item) {
        const siblings = this.siblings(item);
        const itemIndex = siblings.indexOf(item);
        return next(itemIndex, siblings, 1);
    }
    hasParent(item, parent) {
        return item.index.startsWith(parent.index);
    }
    areSiblings(item1, item2) {
        return item1 !== item2 && this.parent(item1) === this.parent(item2);
    }
    forEach(callback) {
        const items = this.items;
        for (let index in items) {
            if (items.hasOwnProperty(index)) {
                callback(items[index]);
            }
        }
    }
    parentIndex(index) {
        return index.replace(PARENT_REGEX, '');
    }
};
ItemsService.ɵfac = function ItemsService_Factory(t) { return new (t || ItemsService)(); };
ItemsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ItemsService, factory: function (t) { return ItemsService.ɵfac(t); } });

/**
 * @hidden
 */
class PreventableEvent {
    /**
     * @hidden
     */
    constructor(args) {
        this.prevented = false;
        Object.assign(this, args);
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `open` and `close` events of the Menu.
 */
class MenuEvent extends PreventableEvent {
}

const canPerformAction = (item, action) => !((action === 'open' && item.opened) || (action === 'close' && !item.opened));
/**
 * @hidden
 */
let ActionsService = class ActionsService {
    constructor(ngZone, items) {
        this.ngZone = ngZone;
        this.items = items;
        this.actions = [];
    }
    open(item, finished) {
        if (item.disabled) {
            return;
        }
        if (item.hasContent && !item.opened) {
            this.actions.push({
                name: 'open',
                requiresZone: item.hasContentTemplates(),
                item,
                finished
            });
        }
        else if (finished) {
            finished();
        }
    }
    close(item) {
        this.closeChildren(item);
        this.closeItem(item);
    }
    closeItem(item) {
        if (item.opened) {
            this.actions.push({
                name: 'close',
                item
            });
        }
    }
    closeToRoot(item) {
        this.closeChildren(item);
        let current = item;
        do {
            this.closeItem(current);
            current = this.items.parent(current);
        } while (current);
    }
    closeOthers(item) {
        this.closeChildren(item);
        let current = item;
        while (current) {
            const siblings = this.items.otherSiblings(current);
            this.closeItems(siblings);
            current = this.items.parent(current);
        }
    }
    closeAll() {
        this.items.forEach((item) => {
            if (item.opened && item.level === 0) {
                this.close(item);
            }
        });
    }
    select(item, domEvent, prevented, finished) {
        this.actions.push({
            name: 'select',
            item,
            prevented,
            finished,
            domEvent
        });
    }
    emit(name, item, domEvent) {
        const owner = this.owner;
        const eventArgs = new MenuEvent({
            sender: owner,
            item: item.item,
            index: item.index,
            originalEvent: domEvent,
            hasContent: item.hasContent
        });
        owner[name].emit(eventArgs);
        if (owner.contextService) {
            owner.contextService.emit(name, eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    get hasPending() {
        return this.actions.length > 0;
    }
    execute(toExecute) {
        if (!this.hasPending && !toExecute) {
            return;
        }
        const actions = toExecute || this.clear();
        if (!NgZone.isInAngularZone() && this.requiresZone(actions)) {
            this.ngZone.run(() => {
                this.executeActions(actions);
            });
        }
        else {
            this.executeActions(actions);
        }
    }
    clear() {
        const actions = this.actions;
        this.actions = [];
        return actions;
    }
    executeActions(actions) {
        for (let idx = 0; idx < actions.length; idx++) {
            const { item, name, prevented, finished, domEvent } = actions[idx];
            if (!canPerformAction(item, name)) {
                continue;
            }
            if (!this.emit(name, item, domEvent)) {
                if (item[name]) {
                    item[name]();
                }
                if (finished) {
                    finished();
                }
            }
            else if (prevented) {
                prevented();
            }
        }
    }
    requiresZone(toExecute) {
        const actions = toExecute || this.actions;
        const owner = this.owner;
        const contextService = owner.contextService;
        for (let idx = 0; idx < actions.length; idx++) {
            const action = actions[idx];
            const name = action.name;
            if (action.requiresZone || (name && (hasObservers(owner[name]) || (contextService && contextService.hasObservers(name))))) {
                return true;
            }
        }
        return false;
    }
    closeChildren(item) {
        if (!item.opened) {
            return;
        }
        const children = this.items.children(item);
        this.closeItems(children);
    }
    closeItems(items) {
        for (let idx = 0; idx < items.length; idx++) {
            this.close(items[idx]);
        }
    }
};
ActionsService.ɵfac = function ActionsService_Factory(t) { return new (t || ActionsService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ItemsService)); };
ActionsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ActionsService, factory: function (t) { return ActionsService.ɵfac(t); } });
ActionsService = __decorate([ __metadata("design:paramtypes", [NgZone, ItemsService])
], ActionsService);

const DEFAULT_ACTIVE = '0';
const NO_SPACE_REGEX = /\S/;
const handlers = {};
handlers['37'] = 'left';
handlers['39'] = 'right';
handlers['38'] = 'up';
handlers['40'] = 'down';
handlers['36'] = 'home';
handlers['35'] = 'end';
handlers['32'] = 'enter';
handlers['13'] = 'enter';
handlers['27'] = 'esc';
handlers['9'] = 'tab';
const handlersRTL = Object.assign({}, handlers, {
    '37': 'right',
    '39': 'left'
});
function isPrintableCharacter(key) {
    return key.length === 1 && NO_SPACE_REGEX.test(key);
}
const resolvedPromise = Promise.resolve(null);
/**
 * @hidden
 */
let NavigationService = class NavigationService {
    constructor(items, actions, localization, ngZone) {
        this.items = items;
        this.actions = actions;
        this.localization = localization;
        this.ngZone = ngZone;
        this.vertical = false;
        this.activeIndex = DEFAULT_ACTIVE;
    }
    get focusedItem() {
        return this.items.get(this.focusedIdx);
    }
    get activeItem() {
        return this.items.get(this.activeIndex);
    }
    get handlers() {
        return this.localization.rtl ? handlersRTL : handlers;
    }
    focus(item) {
        if (item.index === this.focusedIdx) {
            return;
        }
        if (!this.activeItem || !this.items.hasParent(item, this.activeItem)) {
            this.setActive(item);
        }
        this.setFocus(item);
    }
    setFocus(item) {
        this.focusedIdx = item.index;
        item.focus();
    }
    focusLeave() {
        const focused = this.focusedItem;
        if (focused) {
            this.actions.closeToRoot(focused);
            this.actions.execute();
        }
        this.focusedIdx = null;
    }
    updateActive() {
        if (!this.activeItem && this.items.hasItems) {
            const firstItem = this.items.get(DEFAULT_ACTIVE);
            firstItem.toggleActive(true);
            this.ngZone.runOutsideAngular(() => {
                resolvedPromise.then(() => {
                    this.activeIndex = DEFAULT_ACTIVE;
                });
            });
        }
    }
    keydown(e) {
        const current = this.focusedItem || this.activeItem;
        const handler = this.handlers[e.keyCode];
        if (!current) {
            return;
        }
        if (handler) {
            if (handler !== 'tab') {
                e.preventDefault();
            }
            this[handler](current, e);
        }
        else if (isPrintableCharacter(e.key)) {
            this.search(current, e.key);
        }
        this.actions.execute();
    }
    focusIndex(index) {
        if (!index && this.activeItem) {
            this.setFocus(this.activeItem);
        }
        else if (index === 'first') {
            this.focusFirst();
        }
        else if (index === 'last') {
            this.focusLast();
        }
        else {
            const item = this.items.get(index);
            if (item) {
                this.focus(item);
            }
        }
    }
    focusFirst() {
        const items = this.items.siblings(this.items.get('0'));
        this.focus(items[0]);
    }
    focusLast() {
        const items = this.items.siblings(this.items.get('0'));
        this.focus(items[items.length - 1]);
    }
    search(current, key) {
        const siblings = this.items.siblings(current);
        const startIndex = siblings.indexOf(current);
        const items = siblings.slice(startIndex + 1).concat(siblings.slice(0, startIndex));
        for (let idx = 0; idx < items.length; idx++) {
            const sibling = items[idx];
            const text = sibling.item.text || "";
            if (text.toLowerCase().startsWith(key.toLowerCase())) {
                this.focus(sibling);
                break;
            }
        }
    }
    down(current) {
        if (current.level === 0 && !this.vertical) {
            if (current.hasContent) {
                this.actions.open(current, this.focusChild(current, 0));
            }
        }
        else {
            this.focus(this.items.next(current));
        }
    }
    up(current) {
        if (current.level === 0 && !this.vertical) {
            if (current.hasContent) {
                this.actions.open(current, this.focusChild(current, current.children.length - 1));
            }
        }
        else {
            this.focus(this.items.previous(current));
        }
    }
    left(current) {
        if (this.vertical && current.level === 0 && current.disabled) {
            return;
        }
        if (current.level > 1 || (this.vertical && current.level > 0)) {
            const parent = this.items.parent(current);
            this.focus(parent);
            this.actions.close(parent);
        }
        else if (this.vertical && current.level === 0 && !current.disabled) {
            if (current.hasContent) {
                this.actions.open(current, this.focusChild(current, current.children.length - 1));
            }
        }
        else {
            this.focus(this.items.previous(this.activeItem));
        }
    }
    right(current) {
        if (this.vertical && current.level === 0 && current.disabled) {
            return;
        }
        if (current.horizontal && !current.disabled) {
            if (current.hasContent) {
                this.actions.open(current, this.focusChild(current, 0));
            }
            else if (!this.vertical || current.level > 0) {
                this.focus(this.items.next(this.activeItem));
            }
        }
        else {
            this.focus(this.items.next(this.activeItem));
        }
    }
    home(current) {
        const siblings = this.items.siblings(current);
        this.focus(siblings[0]);
    }
    end(current) {
        const siblings = this.items.siblings(current);
        this.focus(siblings[siblings.length - 1]);
    }
    enter(current, domEvent) {
        const actions = this.actions;
        if (current.disabled) {
            return;
        }
        if (current.hasContent) {
            actions.select(current, domEvent);
            actions.open(current, this.focusChild(current, 0));
        }
        else {
            actions.select(current, domEvent, null, () => {
                current.navigate();
            });
            this.focus(this.items.root(current));
            actions.closeToRoot(current);
        }
    }
    esc(current) {
        if (current.level > 0) {
            const parent = this.items.parent(current);
            this.actions.close(parent);
            this.focus(parent);
        }
    }
    tab(current) {
        if (current.level > 0) {
            this.activeItem.focus();
        }
    }
    focusChild(item, index) {
        return () => {
            const child = this.items.children(item)[index];
            this.setFocus(child);
        };
    }
    setActive(item) {
        const focused = this.focusedItem;
        const active = this.items.root(item);
        if (this.activeItem) {
            this.activeItem.toggleActive(false);
        }
        this.activeIndex = active.index;
        active.toggleActive(true);
        if (focused) {
            this.actions.closeToRoot(focused);
            if (focused.level > 0) {
                this.actions.open(active);
            }
        }
    }
};
NavigationService.ɵfac = function NavigationService_Factory(t) { return new (t || NavigationService)(ɵngcc0.ɵɵinject(ItemsService), ɵngcc0.ɵɵinject(ActionsService), ɵngcc0.ɵɵinject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
NavigationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NavigationService, factory: function (t) { return NavigationService.ɵfac(t); } });
NavigationService = __decorate([ __metadata("design:paramtypes", [ItemsService,
        ActionsService,
        LocalizationService,
        NgZone])
], NavigationService);

const DISABLE_OPEN_ON_OVER_DELAY = 500;
/**
 * @hidden
 */
let HoverService = class HoverService {
    constructor(actions, items) {
        this.actions = actions;
        this.items = items;
        this.delay = 100;
        this._openOnOver = true;
        this.scheduled = [];
    }
    get openOnOver() {
        return this._openOnOver;
    }
    set openOnOver(value) {
        this.cancelActions();
        this._openOnOver = value;
    }
    get hovered() {
        return this.items.get(this.hoveredIdx);
    }
    set hovered(item) {
        this.hoveredIdx = item ? item.index : null;
    }
    ngOnDestroy() {
        this.cancelActions();
    }
    over(item) {
        this.cancelActions((action) => action.name === 'openOnOver');
        if (!this.hovered || this.hovered !== item) {
            this.actions.closeOthers(item);
            this.hovered = item;
            if ((item.level > 0 || this.openOnOver) && !item.disabled) {
                this.actions.open(item);
                this.cancelActions((action) => (action.name === 'close' && (item === action.item || this.items.hasParent(item, action.item))) ||
                    (action.name === 'open' && !this.items.hasParent(item, action.item)));
            }
            this.scheduleActions();
        }
    }
    leave(disableOpenOnOver) {
        const hovered = this.hovered;
        if (hovered) {
            this.actions.closeToRoot(hovered);
            this.cancelActions(action => action.name === 'open');
            this.scheduleActions();
        }
        if (disableOpenOnOver && this._openOnOver) {
            this.scheduleDisableOpenOnOver();
        }
        this.hovered = null;
    }
    closeCurrent() {
        const hovered = this.hovered;
        if (hovered) {
            this.actions.closeToRoot(hovered);
            this.hovered = null;
        }
    }
    scheduleActions() {
        if (this.actions.hasPending) {
            const item = {};
            item.actions = this.actions.clear();
            item.id = setTimeout(() => {
                this.actions.execute(item.actions);
                this.removeScheduled(item);
            }, this.delay);
            this.scheduled.push(item);
        }
    }
    scheduleDisableOpenOnOver() {
        const item = {
            actions: [{ name: 'openOnOver' }]
        };
        item.id = setTimeout(() => {
            this._openOnOver = false;
            this.removeScheduled(item);
        }, Math.max(this.delay, DISABLE_OPEN_ON_OVER_DELAY));
        this.scheduled.push(item);
    }
    removeScheduled(item) {
        const scheduled = this.scheduled;
        for (let idx = 0; idx < scheduled.length; idx++) {
            if (scheduled[idx] === item) {
                scheduled.splice(idx, 1);
                return;
            }
        }
    }
    cancelActions(predicate) {
        const scheduled = this.scheduled;
        for (let idx = scheduled.length - 1; idx >= 0; idx--) {
            const item = scheduled[idx];
            const actions = item.actions;
            if (predicate) {
                for (let actionIdx = actions.length - 1; actionIdx >= 0; actionIdx--) {
                    if (predicate(actions[actionIdx])) {
                        actions.splice(actionIdx, 1);
                    }
                }
            }
            if (!predicate || actions.length === 0) {
                clearTimeout(item.id);
                scheduled.splice(idx, 1);
            }
        }
    }
};
HoverService.ɵfac = function HoverService_Factory(t) { return new (t || HoverService)(ɵngcc0.ɵɵinject(ActionsService), ɵngcc0.ɵɵinject(ItemsService)); };
HoverService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: HoverService, factory: function (t) { return HoverService.ɵfac(t); } });
HoverService = __decorate([ __metadata("design:paramtypes", [ActionsService, ItemsService])
], HoverService);

/* tslint:disable:max-line-length */
/**
 * @hidden
 */
const normalize = (settings) => settings && Object.assign({
    toggle: 'select'
}, settings);

/**
 * @hidden
 */
const NODE_INDEX = 'data-kendo-menu-index';

const DEFAULT_ID = 'kendo-matches-container';
const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
const matches = (element, selector) => (element.matches || element.msMatchesSelector).call(element, selector);
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
const closestInScope = (node, predicate, scope) => {
    while (node && node !== scope && !predicate(node)) {
        node = node.parentNode;
    }
    if (node !== scope) {
        return node;
    }
};
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabIndex');
        const skipTab = tabIndex === '-1';
        let focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClass = (element, name) => {
    return toClassList(element.className).indexOf(name) >= 0;
};
/**
 * @hidden
 */
const matchesClasses = (classes) => {
    const list = toClassList(classes);
    return (element) => {
        const classList = toClassList(element.className);
        return Boolean(list.find(name => classList.indexOf(name) >= 0));
    };
};
/**
 * @hidden
 */
const nodeIndex = (node) => node.getAttribute(NODE_INDEX);
/**
 * @hidden
 */
const closestItem = (node, scope) => closestInScope(node, nodeIndex, scope);
/**
 * @hidden
 */
const closestList = (node) => {
    let list = closest(node, matchesClasses('k-menu-popup k-menu k-menu-group'));
    if (list && hasClass(list, 'k-menu-popup')) {
        list = list.querySelector('.k-menu-group');
    }
    return list;
};
/**
 * @hidden
 */
const inMenu = (node, itemsService) => {
    if (node === itemsService.lists[0].element.nativeElement) {
        return false;
    }
    const list = closestList(node);
    return list && itemsService.containsList(list);
};
/**
 * @hidden
 */
const findInContainer = (element, selector, container) => {
    const id = container.getAttribute('id');
    if (!id) {
        container.setAttribute('id', DEFAULT_ID);
    }
    const contextSelector = `#${id || DEFAULT_ID} ${selector}`;
    const match = closestInScope(element, node => matches(node, contextSelector), container);
    if (!id) {
        container.removeAttribute('id');
    }
    return match;
};

/**
 * @hidden
 */
let ContextMenuService = class ContextMenuService {
    /**
     * @hidden
     */
    constructor() {
        this.keydown = new EventEmitter();
    }
    emit(name, args) {
        this.owner.emitMenuEvent(name, args);
    }
    hasObservers(name) {
        return this.owner && hasObservers(this.owner[name]);
    }
    leaveMenu(e) {
        return this.items ? !inMenu(e.target, this.items) : true;
    }
};
ContextMenuService.ɵfac = function ContextMenuService_Factory(t) { return new (t || ContextMenuService)(); };
ContextMenuService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ContextMenuService, factory: function (t) { return ContextMenuService.ɵfac(t); } });

/**
 * Represents a template for the Menu items ([see example]({% slug templates_menu %})). To define a template
 * for an item, nest an `<ng-template>` tag with the `kendoMenuItemTemplate` directive inside a `<kendo-menu-item>`
 * component. To define a template for all Menu items, nest the template inside the `<kendo-menu>` component.
 *
 * The available fields in the template context are:
 * - `item`&mdash;The item data.
 * - `index`&mdash;The item index.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-menu>
 *          <kendo-menu-item text="item2">
 *              <ng-template kendoMenuItemTemplate let-item="item" let-index="index">
 *                  <div style="padding: 10px;">
 *                      My Template for: {{ item.text }} at index: {{ index }}
 *                  </div>
 *              </ng-template>
 *          </kendo-menu-item>
 *        </kendo-menu>
 *    `
 * })
 *
 * class AppComponent {
 * }
 * ```
 */
let ItemTemplateDirective = class ItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
ItemTemplateDirective.ɵfac = function ItemTemplateDirective_Factory(t) { return new (t || ItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ItemTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ItemTemplateDirective, selectors: [["", "kendoMenuItemTemplate", ""]] });
ItemTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], ItemTemplateDirective);

/**
 * Represents a template for the links of the Menu items ([see example]({% slug templates_menu %})). To define a template
 * for an item, nest an `<ng-template>` tag with the `kendoMenuItemLinkTemplate` directive inside a `<kendo-menu-item>`
 * component. To define a template for all Menu items, nest the template inside the `<kendo-menu>` component.
 *
 * The available fields in the template context are:
 * - `item`&mdash;The item data.
 * - `index`&mdash;The item index.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-menu>
 *          <kendo-menu-item text="item2">
 *              <ng-template kendoMenuItemLinkTemplate let-item="item" let-index="index">
 *                  <span [kendoMenuItemLink]="index">
 *                      {{ item.text }}
 *                      <span *ngIf="item.items && item.items.length" [kendoMenuExpandArrow]="index"></span>
 *                  </span>
 *              </ng-template>
 *          </kendo-menu-item>
 *        </kendo-menu>
 *    `
 * })
 *
 * class AppComponent {
 * }
 * ```
 */
let ItemLinkTemplateDirective = class ItemLinkTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
ItemLinkTemplateDirective.ɵfac = function ItemLinkTemplateDirective_Factory(t) { return new (t || ItemLinkTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ItemLinkTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ItemLinkTemplateDirective, selectors: [["", "kendoMenuItemLinkTemplate", ""]] });
ItemLinkTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], ItemLinkTemplateDirective);

/**
 * Represents a template for the content of the Menu items ([see example]({% slug templates_menu %})). To define the template,
 * nest an `<ng-template>` tag with the `kendoMenuItemContentTemplate` directive inside a `<kendo-menu-item>` component.
 *
 * The available fields in the template context are:
 * - `item`&mdash;The item data.
 * - `index`&mdash;The item index.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-menu>
 *          <kendo-menu-item text="item2">
 *              <ng-template kendoMenuItemContentTemplate let-item="item" let-index="index">
 *                  <div style="padding: 10px;">
 *                      My Content Template for: {{ item.text }} at index: {{ index }}
 *                  </div>
 *              </ng-template>
 *          </kendo-menu-item>
 *        </kendo-menu>
 *    `
 * })
 *
 * class AppComponent {
 * }
 * ```
 */
let ItemContentTemplateDirective = class ItemContentTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
ItemContentTemplateDirective.ɵfac = function ItemContentTemplateDirective_Factory(t) { return new (t || ItemContentTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ItemContentTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ItemContentTemplateDirective, selectors: [["", "kendoMenuItemContentTemplate", ""]] });
ItemContentTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], ItemContentTemplateDirective);

var MenuItemComponent_1;
/**
 * A component that can be used to specify the Menu items
 * ([more information and examples]({% slug items_menu %})).
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-menu>
 *          <kendo-menu-item text="item1">
 *              <kendo-menu-item text="item1.1" url="https://example.com">
 *              </kendo-menu-item>
 *              <kendo-menu-item text="item1.2" [disabled]="true">
 *              </kendo-menu-item>
 *          </kendo-menu-item>
 *          <kendo-menu-item text="item2">
 *              <ng-template kendoMenuItemContentTemplate let-item="item">
 *                  <div style="padding: 10px;">
 *                      My Content Template: {{ item.text }}
 *                  </div>
 *              </ng-template>
 *              <ng-template kendoMenuItemTemplate let-item="item">
 *                  <div style="padding: 10px;">
 *                      My Template: {{ item.text }}
 *                  </div>
 *              </ng-template>
 *          </kendo-menu-item>
 *          <kendo-menu-item text="item3">
 *              <ng-template kendoMenuItemLinkTemplate let-item="item" let-index="index">
 *                  <span [kendoMenuItemLink]="index">
 *                      {{ item.text }}
 *                      <span *ngIf="item.items && item.items.length" [kendoMenuExpandArrow]="index"></span>
 *                  </span>
 *              </ng-template>
 *          </kendo-menu-item>
 *        </kendo-menu>
 *    `
 * })
 *
 * class AppComponent {
 * }
 * ```
 */
let MenuItemComponent = MenuItemComponent_1 = class MenuItemComponent {
    /**
     * @hidden
     */
    get template() {
        if (this.itemTemplate && this.itemTemplate.length) {
            return this.itemTemplate.first.templateRef;
        }
    }
    /**
     * @hidden
     */
    get linkTemplate() {
        if (this.itemLinkTemplate && this.itemLinkTemplate.length) {
            return this.itemLinkTemplate.first.templateRef;
        }
    }
    /**
     * @hidden
     */
    get contentTemplate() {
        if (this.itemContentTemplate && this.itemContentTemplate.length) {
            return this.itemContentTemplate.first.templateRef;
        }
    }
    /**
     * @hidden
     */
    get items() {
        if (this.children.length) {
            return this.children.toArray().filter(c => c !== this);
        }
    }
};
MenuItemComponent.ɵfac = function MenuItemComponent_Factory(t) { return new (t || MenuItemComponent)(); };
MenuItemComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MenuItemComponent, selectors: [["kendo-menu-item"]], contentQueries: function MenuItemComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemLinkTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemContentTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MenuItemComponent_1, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemLinkTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemContentTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, inputs: { text: "text", url: "url", disabled: "disabled", cssClass: "cssClass", cssStyle: "cssStyle", icon: "icon", data: "data", separator: "separator" }, decls: 0, vars: 0, template: function MenuItemComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], MenuItemComponent.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MenuItemComponent.prototype, "url", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MenuItemComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], MenuItemComponent.prototype, "cssClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], MenuItemComponent.prototype, "cssStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MenuItemComponent.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], MenuItemComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MenuItemComponent.prototype, "separator", void 0);
__decorate([
    ContentChildren(ItemTemplateDirective),
    __metadata("design:type", QueryList)
], MenuItemComponent.prototype, "itemTemplate", void 0);
__decorate([
    ContentChildren(ItemLinkTemplateDirective),
    __metadata("design:type", QueryList)
], MenuItemComponent.prototype, "itemLinkTemplate", void 0);
__decorate([
    ContentChildren(ItemContentTemplateDirective),
    __metadata("design:type", QueryList)
], MenuItemComponent.prototype, "itemContentTemplate", void 0);
__decorate([
    ContentChildren(MenuItemComponent_1),
    __metadata("design:type", QueryList)
], MenuItemComponent.prototype, "children", void 0);

/**
 * @hidden
 */
class MenuBase {
    constructor() {
        /**
         * Specifies if the Menu will be vertical ([see example]({% slug vertical_menu %})).
         */
        this.vertical = false;
        /**
         * Specifies that the root items can be opened only on click
         * ([see example]({% slug openclose_menu %}#toc-opening-on-click)).
         */
        this.openOnClick = false;
        /**
         * Specifies the delay in milliseconds before the Menu items are opened or closed on item hover
         * or leave ([see example]({% slug openclose_menu %}#toc-delay-on-hover)). Used to avoid the accidental
         * opening or closing of the items.
         */
        this.hoverDelay = 100;
        /**
         * Sets the Menu animation.
         */
        this.animate = true;
    }
    /**
     * @hidden
     */
    get rootItems() {
        return this.items || (this.children ? this.children.toArray() : []);
    }
}
MenuBase.ɵfac = function MenuBase_Factory(t) { return new (t || MenuBase)(); };
MenuBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MenuBase, contentQueries: function MenuBase_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemLinkTemplateDirective, 4);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MenuItemComponent, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemLinkTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, inputs: { vertical: "vertical", openOnClick: "openOnClick", hoverDelay: "hoverDelay", animate: "animate", items: "items" } });
__decorate([
    Input(),
    __metadata("design:type", Array)
], MenuBase.prototype, "items", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MenuBase.prototype, "vertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], MenuBase.prototype, "openOnClick", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], MenuBase.prototype, "hoverDelay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], MenuBase.prototype, "animate", void 0);
__decorate([
    ContentChildren(ItemTemplateDirective),
    __metadata("design:type", QueryList)
], MenuBase.prototype, "itemTemplate", void 0);
__decorate([
    ContentChildren(ItemLinkTemplateDirective),
    __metadata("design:type", QueryList)
], MenuBase.prototype, "itemLinkTemplate", void 0);
__decorate([
    ContentChildren(MenuItemComponent),
    __metadata("design:type", QueryList)
], MenuBase.prototype, "children", void 0);

var MenuComponent_1;
/**
 * Represents the [Kendo UI Menu component for Angular]({% slug overview_menu %}).
 *
 * @example
 * ```ts
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-menu [items]="items">
 *        </kendo-menu>
 *    `
 * })
 * class AppComponent {
 *    public items: any[] = [{ text: 'item1', items: [{ text: 'item1.1' }] }, { text: 'item2', disabled: true }];
 * }
 * ```
 */
let MenuComponent = MenuComponent_1 = class MenuComponent extends MenuBase {
    constructor(itemsService, hover, actions, navigation, localization, ngZone, renderer, contextService) {
        super();
        this.itemsService = itemsService;
        this.hover = hover;
        this.actions = actions;
        this.navigation = navigation;
        this.localization = localization;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.contextService = contextService;
        /**
         * Fires when a Menu item is selected ([see example]({% slug routing_menu %})).
         */
        this.select = new EventEmitter();
        /**
         * Fires when a Menu item is opened.
         */
        this.open = new EventEmitter();
        /**
         * Fires when a Menu item is closed.
         */
        this.close = new EventEmitter();
        validatePackage(packageMetadata);
        this.actions.owner = this;
        if (contextService) {
            contextService.items = this.itemsService;
            this.contextKeyDownSubscription = contextService.keydown.subscribe(this.contextKeyDown.bind(this));
        }
    }
    /**
     * @hidden
     */
    get ariaOrientation() {
        if (this.vertical) {
            return 'vertical';
        }
    }
    /**
     * @hidden
     */
    get contextMenuClass() {
        return Boolean(this.contextService);
    }
    get direction() {
        return this.rtl;
    }
    get rtl() {
        return this.localization.rtl;
    }
    /**
     * Opens or closes the specified Menu items.
     *
     * @param open - A Boolean value which indicates if the items will be opened or closed.
     * @param indices - One or more values which represent the hierarchical indices of the items that will be opened or closed.
     */
    toggle(open, ...indices) {
        for (let idx = 0; idx < indices.length; idx++) {
            const item = this.itemsService.get(indices[idx]);
            if (item && !item.disabled) {
                if (open) {
                    item.open();
                }
                else {
                    item.close();
                }
            }
        }
    }
    /**
     * @hidden
     */
    focus(index) {
        this.navigation.focusIndex(index);
    }
    ngOnChanges(changes) {
        this.navigation.vertical = this.vertical;
        this.hover.delay = this.hoverDelay;
        if (changes.openOnClick) {
            const openOnClick = this.openOnClick = normalize(this.openOnClick);
            this.hover.openOnOver = !openOnClick;
            if (openOnClick && openOnClick.toggle === 'click') {
                this.attachCloseClick();
            }
            else {
                this.unsubscribeClick();
            }
        }
    }
    ngAfterViewChecked() {
        this.navigation.updateActive();
    }
    ngOnDestroy() {
        this.unsubscribeClick();
        if (this.contextService) {
            this.contextService.items = null;
            this.contextKeyDownSubscription.unsubscribe();
        }
    }
    attachCloseClick() {
        if (!this.closeClickSubscription && isDocumentAvailable()) {
            this.ngZone.runOutsideAngular(() => {
                this.closeClickSubscription = this.renderer.listen('document', 'click', (e) => {
                    if (!inMenu(e.target, this.itemsService)) {
                        this.hover.openOnOver = false;
                        this.actions.closeAll();
                        this.actions.execute();
                    }
                });
            });
        }
    }
    unsubscribeClick() {
        if (this.closeClickSubscription) {
            this.closeClickSubscription();
        }
    }
    contextKeyDown(e) {
        if (!this.itemsService.hasItems) {
            return;
        }
        const keyCode = e.keyCode;
        const rtl = this.localization.rtl;
        const first = keyCode === Keys.ArrowDown || keyCode === Keys.ArrowRight;
        const last = keyCode === Keys.ArrowUp || keyCode === Keys.ArrowLeft;
        let index;
        if ((first && !rtl) || (last && rtl)) {
            index = 'first';
        }
        else if ((first && rtl) || (last && !rtl)) {
            index = 'last';
        }
        if (index) {
            e.preventDefault();
            this.focus(index);
        }
    }
};
MenuComponent.ɵfac = function MenuComponent_Factory(t) { return new (t || MenuComponent)(ɵngcc0.ɵɵdirectiveInject(ItemsService), ɵngcc0.ɵɵdirectiveInject(HoverService), ɵngcc0.ɵɵdirectiveInject(ActionsService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ContextMenuService, 8)); };
MenuComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MenuComponent, selectors: [["kendo-menu"]], hostVars: 2, hostBindings: function MenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-rtl", ctx.direction);
    } }, inputs: { menuItemTemplate: "menuItemTemplate", menuItemLinkTemplate: "menuItemLinkTemplate" }, outputs: { select: "select", open: "open", close: "close" }, exportAs: ["kendoMenu"], features: [ɵngcc0.ɵɵProvidersFeature([
            ItemsService,
            ActionsService,
            NavigationService,
            HoverService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.menu'
            },
            {
                provide: MenuBase,
                useExisting: forwardRef(() => MenuComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 15, consts: [["role", "menubar", "kendoMenuList", "", 1, "k-widget", "k-reset", "k-header", "k-menu", 3, "items", "level", "vertical", "rtl", "animate", "openOnClick", "itemTemplate", "itemLinkTemplate"]], template: function MenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "ul", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-menu-horizontal", !ctx.vertical)("k-menu-vertical", ctx.vertical)("k-context-menu", ctx.contextMenuClass);
        ɵngcc0.ɵɵproperty("items", ctx.rootItems)("level", 0)("vertical", ctx.vertical)("rtl", ctx.rtl)("animate", ctx.animate)("openOnClick", ctx.openOnClick)("itemTemplate", (ctx.itemTemplate.first == null ? null : ctx.itemTemplate.first.templateRef) || ctx.menuItemTemplate)("itemLinkTemplate", (ctx.itemLinkTemplate.first == null ? null : ctx.itemLinkTemplate.first.templateRef) || ctx.menuItemLinkTemplate);
        ɵngcc0.ɵɵattribute("aria-orientation", ctx.ariaOrientation);
    } }, directives: function () { return [ListComponent]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], MenuComponent.prototype, "menuItemTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], MenuComponent.prototype, "menuItemLinkTemplate", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MenuComponent.prototype, "select", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MenuComponent.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MenuComponent.prototype, "close", void 0);
__decorate([
    HostBinding('class.k-rtl'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], MenuComponent.prototype, "direction", null);
MenuComponent = MenuComponent_1 = __decorate([ __param(7, Optional()),
    __metadata("design:paramtypes", [ItemsService,
        HoverService,
        ActionsService,
        NavigationService,
        LocalizationService,
        NgZone,
        Renderer2,
        ContextMenuService])
], MenuComponent);

/* tslint:disable:component-selector */
/**
 * @hidden
 */
let ListComponent = class ListComponent {
    constructor(itemsService, hover, actions, navigation, renderer, ngZone, element) {
        this.itemsService = itemsService;
        this.hover = hover;
        this.actions = actions;
        this.navigation = navigation;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.element = element;
        this.animate = true;
    }
    hierarchyIndex(index) {
        return this.itemsService.itemIndex(this.index, index);
    }
    ngOnInit() {
        this.itemsService.addList(this);
        this.initDomEvents();
    }
    ngOnDestroy() {
        this.itemsService.removeList(this);
        if (this.domSubscriptions) {
            this.domSubscriptions();
        }
    }
    initDomEvents() {
        if (!isDocumentAvailable() || !this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            const element = this.element.nativeElement;
            const container = this.level > 0 ? closest(element, (node) => hasClass(node, 'k-popup')) : element;
            const overSubscription = this.renderer.listen(element, 'mouseover', (e) => {
                if (e.target === element && this.level === 0) {
                    this.onLeave();
                }
                else {
                    const item = this.nodeItem(e.target) || this.itemsService.get(this.index);
                    if (item && !(this.openOnClick && this.openOnClick.toggle === 'click' && item.level === 0 && !item.hasContent)) {
                        this.hover.over(item);
                    }
                }
            });
            const leaveSubscription = this.renderer.listen(container, 'mouseleave', (e) => {
                if (this.leavesMenu(e)) {
                    this.onLeave();
                }
            });
            const keydownSubscription = this.renderer.listen(element, 'keydown', (e) => {
                if (hasClass(e.target, 'k-menu-item')) {
                    this.navigation.keydown(e);
                }
            });
            const blurSubscription = this.renderer.listen(element, 'focusout', (e) => {
                if (this.leavesMenu(e)) {
                    this.navigation.focusLeave();
                }
            });
            /**
             * Handle focus/blur open/close for iOS devices since it behaves inconsistently with the rest
             * Refer to: https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html
             */
            const touchSubscription = this.renderer.listen(document, 'touchstart', (e) => {
                if (inMenu(e.target, this.itemsService)) {
                    const item = this.nodeItem(e.target);
                    // Needs to be called because the 'click' handler will be called only on secondary tap and the item will remain unfocused
                    this.navigation.focus(item);
                    // This is needed since the 'mouseover' event is not always dispatched
                    if (!item.opened) {
                        this.hover.over(item);
                    }
                }
                else if (this.navigation.focusedIdx) {
                    // If the touch is outside of the menu and the menu is not currently in focus
                    const activeItem = this.itemsService.get(this.navigation.activeIndex);
                    this.onLeave(); // needs to be called explicitly since mouseleave event is not triggered
                    activeItem.blur(); // needs to be called explicitly otherwise the item remains focused => triggers focusout
                }
            });
            const clickSubscription = this.renderer.listen(element, 'click', this.clickHandler.bind(this));
            this.domSubscriptions = () => {
                overSubscription();
                leaveSubscription();
                keydownSubscription();
                blurSubscription();
                clickSubscription();
                touchSubscription();
            };
        });
    }
    leavesMenu(e) {
        if (!e.relatedTarget) {
            return true;
        }
        return !inMenu(e.relatedTarget, this.itemsService);
    }
    onLeave() {
        const openOnClick = this.openOnClick;
        if (!openOnClick || openOnClick.toggle !== 'click') {
            this.hover.leave(openOnClick && openOnClick.toggle === 'leave');
        }
    }
    nodeItem(target) {
        const node = closestItem(target, this.element.nativeElement);
        if (node) {
            const index = nodeIndex(node);
            return this.itemsService.get(index);
        }
    }
    clickHandler(e) {
        if (isFocusable(e.target) && !hasClass(e.target, 'k-menu-item')) {
            return;
        }
        const item = this.nodeItem(e.target);
        if (!item || item.isContent || item.navigating) {
            return;
        }
        if (item.disabled) {
            e.preventDefault();
            return;
        }
        this.actions.select(item, e, () => {
            e.preventDefault();
        });
        this.navigation.focus(item);
        if (item.level > 0 && !item.hasContent) {
            this.actions.closeToRoot(item);
        }
        if (this.openOnClick) {
            const hover = this.hover;
            if (item.opened) {
                if (item.level === 0) {
                    hover.openOnOver = false;
                    this.actions.close(item);
                }
            }
            else if (item.hasContent) {
                hover.openOnOver = true;
                this.actions.closeOthers(item);
                this.actions.open(item);
            }
            else {
                hover.openOnOver = false;
                if (item.level === 0 && this.openOnClick.toggle === 'click') {
                    this.hover.closeCurrent();
                }
            }
        }
        this.actions.execute();
    }
};
ListComponent.ɵfac = function ListComponent_Factory(t) { return new (t || ListComponent)(ɵngcc0.ɵɵdirectiveInject(ItemsService), ɵngcc0.ɵɵdirectiveInject(HoverService), ɵngcc0.ɵɵdirectiveInject(ActionsService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ListComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ListComponent, selectors: [["", "kendoMenuList", ""]], inputs: { animate: "animate", items: "items", level: "level", index: "index", vertical: "vertical", rtl: "rtl", openOnClick: "openOnClick", itemTemplate: "itemTemplate", itemLinkTemplate: "itemLinkTemplate" }, attrs: _c0, decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["kendoMenuItem", "", "role", "menuitem", "class", "k-item k-menu-item", 3, "item", "level", "vertical", "animate", "rtl", "itemTemplate", "itemLinkTemplate", "openOnClick", "index", "siblingIndex", "ngClass", "ngStyle", "k-first", "k-last", "k-state-disabled", 4, "ngIf"], ["class", "k-separator k-item", "role", "separator", 3, "ngClass", "ngStyle", 4, "ngIf"], ["kendoMenuItem", "", "role", "menuitem", 1, "k-item", "k-menu-item", 3, "item", "level", "vertical", "animate", "rtl", "itemTemplate", "itemLinkTemplate", "openOnClick", "index", "siblingIndex", "ngClass", "ngStyle"], ["role", "separator", 1, "k-separator", "k-item", 3, "ngClass", "ngStyle"]], template: function ListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ListComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: function () { return [ɵngcc2.NgForOf, ɵngcc2.NgIf, ItemComponent, ɵngcc2.NgClass, ɵngcc2.NgStyle]; }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], ListComponent.prototype, "items", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ListComponent.prototype, "level", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ListComponent.prototype, "index", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ListComponent.prototype, "animate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ListComponent.prototype, "vertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ListComponent.prototype, "rtl", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ListComponent.prototype, "openOnClick", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ListComponent.prototype, "itemTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ListComponent.prototype, "itemLinkTemplate", void 0);
ListComponent = __decorate([ __metadata("design:paramtypes", [ItemsService,
        HoverService,
        ActionsService,
        NavigationService,
        Renderer2,
        NgZone,
        ElementRef])
], ListComponent);

const POPUP_ALIGN = {
    vertical: 'top',
    horizontal: 'left'
};
const POPUP_ALIGN_RTL = {
    vertical: 'top',
    horizontal: 'right'
};
const VERTICAL_COLLISION = {
    vertical: 'flip',
    horizontal: 'fit'
};
const HORIZONTAL_COLLISION = {
    vertical: 'fit',
    horizontal: 'flip'
};
/**
 * @hidden
 */
const POPUP_SETTINGS_RTL = {
    vertical: {
        anchor: {
            vertical: 'bottom',
            horizontal: 'right'
        },
        popup: POPUP_ALIGN_RTL,
        collision: VERTICAL_COLLISION,
        animate: 'down'
    },
    horizontal: {
        anchor: {
            vertical: 'top',
            horizontal: 'left'
        },
        popup: POPUP_ALIGN_RTL,
        collision: HORIZONTAL_COLLISION,
        animate: 'left'
    }
};
/**
 * @hidden
 */
const POPUP_SETTINGS = {
    vertical: {
        anchor: {
            vertical: 'bottom',
            horizontal: 'left'
        },
        popup: POPUP_ALIGN,
        collision: VERTICAL_COLLISION,
        animate: 'down'
    },
    horizontal: {
        anchor: {
            vertical: 'top',
            horizontal: 'right'
        },
        popup: POPUP_ALIGN,
        collision: HORIZONTAL_COLLISION,
        animate: 'right'
    }
};

/**
 * @hidden
 */
const defined = (value) => typeof value !== 'undefined';
/**
 * @hidden
 */
const bodyFactory = () => {
    if (isDocumentAvailable()) {
        return new ElementRef(document.body);
    }
};

const ɵ0$3 = bodyFactory;
/* tslint:disable:component-selector */
/**
 * @hidden
 */
let ItemComponent = class ItemComponent {
    constructor(itemsService, navigation, changeDetector, renderer, popupService, element) {
        this.itemsService = itemsService;
        this.navigation = navigation;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.popupService = popupService;
        this.element = element;
        this.animate = true;
        this.openOnClick = false;
        this.opened = false;
        this.navigating = false;
        this.destroyed = false;
    }
    set index(index) {
        if (this._index && this._index !== index) {
            this.itemsService.remove(this);
            this._index = index;
            this.itemsService.add(this);
        }
        else {
            this._index = index;
        }
        this.childId = this.itemsService.childId(index);
    }
    get index() {
        return this._index;
    }
    get disabled() {
        return this.item.disabled;
    }
    get hasPopup() {
        return this.hasContent ? true : null;
    }
    get expanded() {
        return this.hasContent ? this.opened : null;
    }
    get label() {
        return this.item.text ? this.item.text : null;
    }
    get activeId() {
        return this.index === this.navigation.activeIndex ? '0' : '-1';
    }
    get popupSettings() {
        const settings = this.rtl ? POPUP_SETTINGS_RTL : POPUP_SETTINGS;
        return this.horizontal ? settings.horizontal : settings.vertical;
    }
    get horizontal() {
        return this.vertical || this.level > 0;
    }
    get hasLink() {
        return Boolean(this.item.url);
    }
    get linkTemplate() {
        return this.item.linkTemplate || this.itemLinkTemplate;
    }
    get hasContent() {
        const items = this.item.items;
        return items && items.length || this.item.contentTemplate;
    }
    get isContent() {
        return Boolean(this.item.content);
    }
    get iconClass() {
        return `k-i-${this.item.icon}`;
    }
    get children() {
        const item = this.item;
        if (item.contentTemplate) {
            if (!this.contentItems) {
                this.contentItems = [{
                        content: item.contentTemplate,
                        owner: item,
                        ownerIndex: this.index
                    }];
            }
            return this.contentItems;
        }
        return item.items;
    }
    get template() {
        return this.item.template || this.itemTemplate;
    }
    hasContentTemplates() {
        const item = this.item;
        return this.itemTemplate || item.contentTemplate || this.itemLinkTemplate ||
            (item.items && item.items.find(current => current.template || current.linkTemplate));
    }
    ngOnInit() {
        this.itemsService.add(this);
    }
    ngOnDestroy() {
        this.itemsService.remove(this);
        this.destroyed = true;
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    focus() {
        this.element.nativeElement.focus();
    }
    blur() {
        this.element.nativeElement.blur();
    }
    toggleActive(isActive) {
        if (isActive) {
            this.setAttribute('tabindex', '0');
        }
        else {
            this.setAttribute('tabindex', '-1');
        }
    }
    open() {
        if (!this.destroyed && this.hasContent && !this.opened) {
            const popupSettings = this.popupSettings;
            const animate = this.animate ? Object.assign({}, this.animate, {
                direction: popupSettings.animate
            }) : false;
            this.opened = true;
            this.popupRef = this.popupService.open({
                popupAlign: popupSettings.popup,
                anchorAlign: popupSettings.anchor,
                collision: popupSettings.collision,
                anchor: this.element,
                positionMode: 'absolute',
                content: this.popupTemplate,
                popupClass: {
                    'k-rtl': this.rtl,
                    'k-menu-popup': true
                },
                animate: animate
            });
            this.setAttribute('aria-expanded', 'true');
            this.setAttribute('aria-owns', this.childId);
            this.changeDetector.detectChanges();
        }
    }
    close() {
        if (!this.destroyed && this.opened) {
            this.opened = false;
            if (this.popupRef) {
                this.popupRef.close();
                this.popupRef = null;
            }
            this.changeDetector.detectChanges();
            this.setAttribute('aria-expanded', 'false');
            this.renderer.removeAttribute(this.element.nativeElement, 'aria-owns');
        }
    }
    navigate() {
        let link;
        if (this.linkTemplate) {
            link = this.element.nativeElement.querySelector('a.k-menu-link');
        }
        else if (this.hasLink) {
            link = this.link.nativeElement;
        }
        if (link) {
            this.navigating = true;
            link.click();
            this.navigating = false;
        }
    }
    setAttribute(name, value) {
        this.renderer.setAttribute(this.element.nativeElement, name, value);
    }
};
ItemComponent.ɵfac = function ItemComponent_Factory(t) { return new (t || ItemComponent)(ɵngcc0.ɵɵdirectiveInject(ItemsService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ItemComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ItemComponent, selectors: [["", "kendoMenuItem", ""]], viewQuery: function ItemComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, 5);
        ɵngcc0.ɵɵviewQuery(_c2, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.link = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
    } }, hostVars: 5, hostBindings: function ItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabled)("aria-haspopup", ctx.hasPopup)("aria-expanded", ctx.expanded)("aria-label", ctx.label)("tabindex", ctx.activeId);
    } }, inputs: { animate: "animate", openOnClick: "openOnClick", index: "index", item: "item", level: "level", siblingIndex: "siblingIndex", vertical: "vertical", rtl: "rtl", itemTemplate: "itemTemplate", itemLinkTemplate: "itemLinkTemplate" }, features: [ɵngcc0.ɵɵProvidersFeature([PopupService, {
                provide: POPUP_CONTAINER,
                useFactory: ɵ0$3
            }])], attrs: _c3, decls: 8, vars: 4, consts: [["class", "k-link k-menu-link", "role", "presentation", 3, "k-state-active", 4, "ngIf"], ["class", "k-link k-menu-link", "tabindex", "-1", "role", "presentation", 3, "k-state-active", 4, "ngIf"], [4, "ngIf"], ["class", "k-content", "role", "presentation", 4, "ngIf"], ["popupTemplate", ""], ["itemcontent", ""], ["role", "presentation", 1, "k-link", "k-menu-link"], ["link", ""], [3, "ngTemplateOutlet"], ["tabindex", "-1", "role", "presentation", 1, "k-link", "k-menu-link"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "presentation", 1, "k-content"], ["kendoMenuList", "", "role", "menu", 1, "k-group", "k-menu-group", "k-reset", 3, "animate", "rtl", "vertical", "openOnClick", "items", "level", "index", "itemTemplate", "itemLinkTemplate"], ["class", "k-icon", "role", "presentation", 3, "ngClass", 4, "ngIf"], ["class", "k-icon k-menu-expand-arrow", "role", "presentation", 3, "k-i-arrow-60-down", "k-i-arrow-60-right", "k-i-arrow-60-left", 4, "ngIf"], ["role", "presentation", 1, "k-icon", 3, "ngClass"], [1, "k-menu-link-text"], ["role", "presentation", 1, "k-icon", "k-menu-expand-arrow"]], template: function ItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ItemComponent_span_0_Template, 3, 3, "span", 0);
        ɵngcc0.ɵɵtemplate(1, ItemComponent_a_1_Template, 3, 4, "a", 1);
        ɵngcc0.ɵɵtemplate(2, ItemComponent_2_Template, 1, 5, null, 2);
        ɵngcc0.ɵɵtemplate(3, ItemComponent_div_3_Template, 2, 5, "div", 3);
        ɵngcc0.ɵɵtemplate(4, ItemComponent_ng_template_4_Template, 1, 10, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, ItemComponent_ng_template_6_Template, 4, 4, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hasLink && !ctx.item.content && !ctx.linkTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.item.url && !ctx.linkTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.linkTemplate && !ctx.item.content);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.item.content);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, ListComponent, ɵngcc2.NgClass], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], ItemComponent.prototype, "item", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ItemComponent.prototype, "level", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ItemComponent.prototype, "index", null);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ItemComponent.prototype, "siblingIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ItemComponent.prototype, "animate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ItemComponent.prototype, "vertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ItemComponent.prototype, "rtl", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ItemComponent.prototype, "openOnClick", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ItemComponent.prototype, "itemTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ItemComponent.prototype, "itemLinkTemplate", void 0);
__decorate([
    ViewChild('link', { static: false }),
    __metadata("design:type", ElementRef)
], ItemComponent.prototype, "link", void 0);
__decorate([
    ViewChild('popupTemplate', { static: true }),
    __metadata("design:type", TemplateRef)
], ItemComponent.prototype, "popupTemplate", void 0);
__decorate([
    HostBinding('attr.aria-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ItemComponent.prototype, "disabled", null);
__decorate([
    HostBinding('attr.aria-haspopup'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ItemComponent.prototype, "hasPopup", null);
__decorate([
    HostBinding('attr.aria-expanded'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ItemComponent.prototype, "expanded", null);
__decorate([
    HostBinding('attr.aria-label'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ItemComponent.prototype, "label", null);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ItemComponent.prototype, "activeId", null);
ItemComponent = __decorate([ __metadata("design:paramtypes", [ItemsService,
        NavigationService,
        ChangeDetectorRef,
        Renderer2,
        PopupService,
        ElementRef])
], ItemComponent);

/**
 * Represents a directive that can be used in the [`linkTemplate`]({% slug api_menu_itemlinktemplatedirective %})
 * of the items to apply the default styling and behavior.
 */
let LinkDirective = class LinkDirective {
    constructor(itemsService) {
        this.itemsService = itemsService;
        this.hostClasses = true;
        this.role = 'presentation';
        this.tabindex = '-1';
    }
    get activeClass() {
        return this.item.opened;
    }
    ngOnInit() {
        if (isDevMode() && !this.index) {
            throw new Error('The kendoMenuItemLink directive requires the item index to be set.');
        }
        this.item = this.itemsService.get(this.index) || {};
    }
};
LinkDirective.ɵfac = function LinkDirective_Factory(t) { return new (t || LinkDirective)(ɵngcc0.ɵɵdirectiveInject(ItemsService)); };
LinkDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LinkDirective, selectors: [["", "kendoMenuItemLink", ""]], hostVars: 8, hostBindings: function LinkDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("k-link", ctx.hostClasses)("k-menu-link", ctx.hostClasses)("k-state-active", ctx.activeClass);
    } }, inputs: { index: ["kendoMenuItemLink", "index"] } });
__decorate([
    Input('kendoMenuItemLink'),
    __metadata("design:type", String)
], LinkDirective.prototype, "index", void 0);
__decorate([
    HostBinding('class.k-link'),
    HostBinding('class.k-menu-link'),
    __metadata("design:type", Boolean)
], LinkDirective.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String)
], LinkDirective.prototype, "role", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", String)
], LinkDirective.prototype, "tabindex", void 0);
__decorate([
    HostBinding('class.k-state-active'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], LinkDirective.prototype, "activeClass", null);
LinkDirective = __decorate([ __metadata("design:paramtypes", [ItemsService])
], LinkDirective);

/**
 * Represents a directive that can be used in the [`linkTemplate`]({% slug api_menu_itemlinktemplatedirective %})
 * of the items to render the default expand arrow.
 */
let ExpandArrowDirective = class ExpandArrowDirective {
    constructor(itemsService) {
        this.itemsService = itemsService;
        this.hostClasses = true;
        this.role = 'presentation';
    }
    get arrowDown() {
        return !this.item.horizontal;
    }
    get arrowRight() {
        return this.item.horizontal && !this.item.rtl;
    }
    get arrowLeft() {
        return this.item.horizontal && this.item.rtl;
    }
    ngOnInit() {
        if (isDevMode() && !this.index) {
            throw new Error('The kendoMenuExpandArrow directive requires the item index to be set.');
        }
        this.item = this.itemsService.get(this.index) || {};
    }
};
ExpandArrowDirective.ɵfac = function ExpandArrowDirective_Factory(t) { return new (t || ExpandArrowDirective)(ɵngcc0.ɵɵdirectiveInject(ItemsService)); };
ExpandArrowDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ExpandArrowDirective, selectors: [["", "kendoMenuExpandArrow", ""]], hostVars: 11, hostBindings: function ExpandArrowDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("k-icon", ctx.hostClasses)("k-menu-expand-arrow", ctx.hostClasses)("k-i-arrow-60-down", ctx.arrowDown)("k-i-arrow-60-right", ctx.arrowRight)("k-i-arrow-60-left", ctx.arrowLeft);
    } }, inputs: { index: ["kendoMenuExpandArrow", "index"] } });
__decorate([
    Input('kendoMenuExpandArrow'),
    __metadata("design:type", String)
], ExpandArrowDirective.prototype, "index", void 0);
__decorate([
    HostBinding('class.k-icon'),
    HostBinding('class.k-menu-expand-arrow'),
    __metadata("design:type", Boolean)
], ExpandArrowDirective.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String)
], ExpandArrowDirective.prototype, "role", void 0);
__decorate([
    HostBinding('class.k-i-arrow-60-down'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ExpandArrowDirective.prototype, "arrowDown", null);
__decorate([
    HostBinding('class.k-i-arrow-60-right'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ExpandArrowDirective.prototype, "arrowRight", null);
__decorate([
    HostBinding('class.k-i-arrow-60-left'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ExpandArrowDirective.prototype, "arrowLeft", null);
ExpandArrowDirective = __decorate([ __metadata("design:paramtypes", [ItemsService])
], ExpandArrowDirective);

/**
 * Arguments for the `select` event of the Menu.
 */
class MenuSelectEvent extends MenuEvent {
}

const ITEM_FIELDS = ['textField', 'urlField', 'iconField', 'disabledField', 'cssClassField', 'cssStyleField', 'separatorField'];
/**
 * @hidden
 */
class BindingDirectiveBase {
    constructor(menu) {
        this.menu = menu;
    }
    ngOnChanges() {
        this.rebind();
    }
    /**
     *  Rebinds the Menu items.
     */
    rebind() {
        const fields = this.fields = [];
        for (let idx = 0; idx < ITEM_FIELDS.length; idx++) {
            const inputName = ITEM_FIELDS[idx];
            const inputValue = this[inputName];
            if (inputValue) {
                fields.push({ target: inputName.replace('Field', ''), source: inputValue });
            }
        }
        this.menu.items = this.data ? this.mapItems(this.data) : [];
    }
}
BindingDirectiveBase.ɵfac = function BindingDirectiveBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
BindingDirectiveBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: BindingDirectiveBase, features: [ɵngcc0.ɵɵNgOnChangesFeature] });

const FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
const getterCache = {};
// tslint:disable-next-line:no-string-literal
getterCache['undefined'] = (obj) => obj;
/**
 * @hidden
 */
const getter = (field) => {
    if (getterCache[field]) {
        return getterCache[field];
    }
    const fields = [];
    field.replace(FIELD_REGEX, (_match, index, indexAccessor, name) => {
        fields.push(index !== undefined ? index : (indexAccessor || name));
    });
    getterCache[field] = (obj) => {
        let result = obj;
        for (let idx = 0; idx < fields.length && result; idx++) {
            result = result[fields[idx]];
        }
        return result;
    };
    return getterCache[field];
};
/**
 * @hidden
 */
const last = (arr) => arr[arr.length - 1];

const getField = (field, level) => Array.isArray(field) ? field[level] || last(field) : field;
/* tslint:disable:no-input-rename */
/**
 * A directive that converts the provided hierarchical data to [MenuItems]({% slug api_menu_menuitem %}) and binds them to the Menu.
 */
let HierarchyBindingDirective = class HierarchyBindingDirective extends BindingDirectiveBase {
    constructor(menu) {
        super(menu);
    }
    mapItems(items, level = 0) {
        return items.map((item) => {
            const menuItem = this.createItem(item, level);
            const children = this.getChildren(item, level);
            if (children) {
                menuItem.items = this.mapItems(children, level + 1);
            }
            return menuItem;
        });
    }
    createItem(item, level) {
        const result = { data: item };
        const fields = this.fields;
        for (let idx = 0; idx < fields.length; idx++) {
            const { target, source } = fields[idx];
            result[target] = getter(getField(source, level))(item);
        }
        return result;
    }
    getChildren(item, level) {
        if (this.childrenField) {
            const field = getField(this.childrenField, level);
            return item[field];
        }
    }
};
HierarchyBindingDirective.ɵfac = function HierarchyBindingDirective_Factory(t) { return new (t || HierarchyBindingDirective)(ɵngcc0.ɵɵdirectiveInject(MenuBase)); };
HierarchyBindingDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: HierarchyBindingDirective, selectors: [["", "kendoMenuHierarchyBinding", ""]], inputs: { data: ["kendoMenuHierarchyBinding", "data"], textField: "textField", urlField: "urlField", iconField: "iconField", disabledField: "disabledField", cssClassField: "cssClassField", cssStyleField: "cssStyleField", separatorField: "separatorField", childrenField: "childrenField" }, exportAs: ["kendoMenuHierarchyBinding"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input("kendoMenuHierarchyBinding"),
    __metadata("design:type", Array)
], HierarchyBindingDirective.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HierarchyBindingDirective.prototype, "textField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HierarchyBindingDirective.prototype, "urlField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HierarchyBindingDirective.prototype, "iconField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HierarchyBindingDirective.prototype, "disabledField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HierarchyBindingDirective.prototype, "cssClassField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HierarchyBindingDirective.prototype, "cssStyleField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HierarchyBindingDirective.prototype, "separatorField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HierarchyBindingDirective.prototype, "childrenField", void 0);
HierarchyBindingDirective = __decorate([ __metadata("design:paramtypes", [MenuBase])
], HierarchyBindingDirective);

/* tslint:disable:no-input-rename */
/**
 * A directive that converts the provided flat data to [MenuItems]({% slug api_menu_menuitem %}) and binds them to the Menu.
 */
let FlatBindingDirective = class FlatBindingDirective extends BindingDirectiveBase {
    constructor(menu) {
        super(menu);
    }
    mapItems(items) {
        if (!this.idField || !this.parentIdField) {
            return items.map(item => this.createItem(item));
        }
        const result = [];
        const map = {};
        for (let idx = 0; idx < items.length; idx++) {
            const item = items[idx];
            const menuItem = this.createItem(item);
            const id = getter(this.idField)(item);
            const parentId = getter(this.parentIdField)(item);
            if (parentId === null || parentId === undefined) {
                result.push(menuItem);
            }
            else {
                const parent = map[parentId] = map[parentId] || {};
                parent.items = parent.items || [];
                parent.items.push(menuItem);
            }
            if (map[id]) {
                menuItem.items = map[id].items;
            }
            map[id] = menuItem;
        }
        return result;
    }
    createItem(dataItem) {
        const result = { data: dataItem };
        const fields = this.fields;
        for (let idx = 0; idx < fields.length; idx++) {
            const { source, target } = fields[idx];
            result[target] = getter(source)(dataItem);
        }
        return result;
    }
};
FlatBindingDirective.ɵfac = function FlatBindingDirective_Factory(t) { return new (t || FlatBindingDirective)(ɵngcc0.ɵɵdirectiveInject(MenuBase)); };
FlatBindingDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FlatBindingDirective, selectors: [["", "kendoMenuFlatBinding", ""]], inputs: { data: ["kendoMenuFlatBinding", "data"], textField: "textField", urlField: "urlField", iconField: "iconField", disabledField: "disabledField", cssClassField: "cssClassField", cssStyleField: "cssStyleField", separatorField: "separatorField", idField: "idField", parentIdField: "parentIdField" }, exportAs: ["kendoMenuFlatBinding"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input("kendoMenuFlatBinding"),
    __metadata("design:type", Array)
], FlatBindingDirective.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatBindingDirective.prototype, "textField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatBindingDirective.prototype, "urlField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FlatBindingDirective.prototype, "iconField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatBindingDirective.prototype, "disabledField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatBindingDirective.prototype, "cssClassField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatBindingDirective.prototype, "cssStyleField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatBindingDirective.prototype, "separatorField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatBindingDirective.prototype, "idField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FlatBindingDirective.prototype, "parentIdField", void 0);
FlatBindingDirective = __decorate([ __metadata("design:paramtypes", [MenuBase])
], FlatBindingDirective);

const COMPONENT_EXPORTS = [
    MenuComponent,
    MenuItemComponent,
    ItemTemplateDirective,
    ItemLinkTemplateDirective,
    ItemContentTemplateDirective,
    HierarchyBindingDirective,
    FlatBindingDirective,
    LinkDirective,
    ExpandArrowDirective
];
const COMPONENT_DIRECTIVES = [
    ...COMPONENT_EXPORTS,
    ListComponent,
    ItemComponent
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Menu component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Menu module
 * import { MenuModule } from '@progress/kendo-angular-menu';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, MenuModule], // import Menu module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let MenuModule = class MenuModule {
};
MenuModule.ɵfac = function MenuModule_Factory(t) { return new (t || MenuModule)(); };
MenuModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MenuModule });
MenuModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[PopupModule, CommonModule]] });

/**
 * Arguments for the `open` and `close` events of the ContextMenu.
 */
class ContextMenuEvent {
}

/**
 * Arguments for the `select` event of the ContextMenu.
 */
class ContextMenuSelectEvent extends ContextMenuEvent {
}

/**
 * Arguments for the `popupOpen` and `popupClose` events of the ContextMenu.
 */
class ContextMenuPopupEvent extends PreventableEvent {
}

/**
 * Represents a template for the content of the ContextMenu. To define a template, nest an `<ng-template>`
 * tag with the `kendoContextMenuTemplate` directive inside a `<kendo-contextmenu>` component
 * ([more information and examples]({% slug templates_contextmenu %})).
 *
 * {% meta height:200 %}
 * {% embed_file context-menu/template/app.component.ts preview %}
 * {% embed_file shared/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% endmeta %}
 */
let ContextMenuTemplateDirective = class ContextMenuTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
ContextMenuTemplateDirective.ɵfac = function ContextMenuTemplateDirective_Factory(t) { return new (t || ContextMenuTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ContextMenuTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ContextMenuTemplateDirective, selectors: [["", "kendoContextMenuTemplate", ""]] });
ContextMenuTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], ContextMenuTemplateDirective);

/**
 * @hidden
 */
let ContextMenuItemsService = class ContextMenuItemsService {
    constructor(contextService) {
        this.contextService = contextService;
    }
    get(index) {
        if (this.contextService.items) {
            return this.contextService.items.get(index);
        }
    }
};
ContextMenuItemsService.ɵfac = function ContextMenuItemsService_Factory(t) { return new (t || ContextMenuItemsService)(ɵngcc0.ɵɵinject(ContextMenuService)); };
ContextMenuItemsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ContextMenuItemsService, factory: function (t) { return ContextMenuItemsService.ɵfac(t); } });
ContextMenuItemsService = __decorate([ __metadata("design:paramtypes", [ContextMenuService])
], ContextMenuItemsService);

/**
 * @hidden
 */
let ContextMenuTargetService = class ContextMenuTargetService {
    /**
     * @hidden
     */
    constructor() {
        this.targets = [];
    }
    add(target) {
        this.targets.push(target);
    }
    remove(target) {
        const index = this.targets.indexOf(target);
        this.targets.splice(index, 1);
    }
    find(targetElement) {
        return this.targets.find(target => target.element === targetElement);
    }
};
ContextMenuTargetService.ɵfac = function ContextMenuTargetService_Factory(t) { return new (t || ContextMenuTargetService)(); };
ContextMenuTargetService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ContextMenuTargetService, factory: function (t) { return ContextMenuTargetService.ɵfac(t); } });

/**
 * Specifies a container for the [targets]({% slug api_menu_contextmenutargetdirective %}) of the ContextMenu.
 */
let ContextMenuTargetContainerDirective = class ContextMenuTargetContainerDirective {
    /**
     * @hidden
     */
    constructor(elementRef, targetService) {
        this.targetService = targetService;
        if (elementRef) {
            this.element = elementRef.nativeElement;
        }
    }
};
ContextMenuTargetContainerDirective.ɵfac = function ContextMenuTargetContainerDirective_Factory(t) { return new (t || ContextMenuTargetContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ContextMenuTargetService)); };
ContextMenuTargetContainerDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ContextMenuTargetContainerDirective, selectors: [["", "kendoContextMenuTargetContainer", ""]], exportAs: ["kendoContextMenuTargetContainer"], features: [ɵngcc0.ɵɵProvidersFeature([ContextMenuTargetService])] });
ContextMenuTargetContainerDirective = __decorate([ __metadata("design:paramtypes", [ElementRef, ContextMenuTargetService])
], ContextMenuTargetContainerDirective);

/**
 * @hidden
 */
const TARGET_CLASS = 'k-contextmenu-target';
/**
 * Specifies a [target]({% slug api_menu_contextmenutargetdirective %}) for the ContextMenu
 * ([see example]({% slug target_contextmenu %}#toc-directives)).
 */
let ContextMenuTargetDirective = class ContextMenuTargetDirective {
    constructor(elementRef, targetService) {
        this.targetService = targetService;
        /**
         * @hidden
         */
        this.hostClass = true;
        if (elementRef) {
            this.element = elementRef.nativeElement;
        }
        targetService.add(this);
    }
    ngOnDestroy() {
        this.targetService.remove(this);
    }
};
ContextMenuTargetDirective.ɵfac = function ContextMenuTargetDirective_Factory(t) { return new (t || ContextMenuTargetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ContextMenuTargetService)); };
ContextMenuTargetDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ContextMenuTargetDirective, selectors: [["", "kendoContextMenuTarget", ""]], hostVars: 2, hostBindings: function ContextMenuTargetDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-contextmenu-target", ctx.hostClass);
    } }, inputs: { data: ["kendoContextMenuTarget", "data"] }, exportAs: ["kendoContextMenuTarget"] });
__decorate([
    Input('kendoContextMenuTarget'),
    __metadata("design:type", Object)
], ContextMenuTargetDirective.prototype, "data", void 0);
__decorate([
    HostBinding(`class.${TARGET_CLASS}`),
    __metadata("design:type", Boolean)
], ContextMenuTargetDirective.prototype, "hostClass", void 0);
ContextMenuTargetDirective = __decorate([ __metadata("design:paramtypes", [ElementRef, ContextMenuTargetService])
], ContextMenuTargetDirective);

var ContextMenuComponent_1;
const CONTEXT_MENU = 'contextmenu';
const DEFAULT_ANCHOR_ALIGN = { horizontal: 'left', vertical: 'bottom' };
const DEFAULT_POPUP_ALIGN = { horizontal: 'left', vertical: 'top' };
const DEFAULT_COLLISION = { horizontal: 'fit', vertical: 'flip' };
const preventDefault = e => e.preventDefault();
const ɵ1$2 = bodyFactory;
/**
 * Represents the [Kendo UI ContextMenu component for Angular]({% slug overview_contextmenu %}).
 *
 * @example
 * ```ts
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *    <div #target>
 *        Right-click to open Context menu</p>
 *    </div>
 *    <kendo-contextmenu [target]="target" [items]="items"> </kendo-contextmenu>
 *    `
 * })
 * class AppComponent {
 *    public items: any[] = [{ text: 'item1', items: [{ text: 'item1.1' }] }, { text: 'item2', disabled: true }];
 * }
 * ```
 */
let ContextMenuComponent = ContextMenuComponent_1 = class ContextMenuComponent extends MenuBase {
    constructor(popupService, service, ngZone, renderer) {
        super();
        this.popupService = popupService;
        this.service = service;
        this.ngZone = ngZone;
        this.renderer = renderer;
        /**
         * Specifies the event on which the ContextMenu will open ([see example]({% slug showon_contextmenu %})).
         * Accepts the name of a native DOM event. Defaults to `contextmenu` which opens the ContextMenu for the target element.
         */
        this.showOn = CONTEXT_MENU;
        /**
         * Indicates that the ContextMenu will be aligned to the target or to the `filter` element (if specified).
         */
        this.alignToAnchor = false;
        /**
         * Specifies if the Menu will be vertically rendered ([see example]({% slug orientation_contextmenu %})).
         * @default true
         */
        this.vertical = true;
        /**
         * Fires when the Menu is opened ([see example]({% slug target_contextmenu %}#toc-changing-items-for-specified-targets)).
         */
        this.popupOpen = new EventEmitter();
        /**
         * Fires when the Menu is closed.
         */
        this.popupClose = new EventEmitter();
        /**
         * Fires when a Menu item is selected.
         */
        this.select = new EventEmitter();
        /**
         * Fires when a Menu item is opened.
         */
        this.open = new EventEmitter();
        /**
         * Fires when a Menu item is closed.
         */
        this.close = new EventEmitter();
        this.service.owner = this;
        this.popupKeyDownHandler = this.popupKeyDownHandler.bind(this);
    }
    /**
     * Hides the ContextMenu.
     */
    hide() {
        this.removePopup();
    }
    /**
     * Shows the ContextMenu for the specified target.
     * @param target - The offset or the target element for which the ContextMenu will open.
     */
    show(target) {
        if (!target) {
            return;
        }
        const showTarget = target;
        this.removePopup();
        if (defined(showTarget.left) && defined(showTarget.top)) {
            this.createPopup({ offset: showTarget });
        }
        else {
            this.currentTarget = showTarget.nativeElement || showTarget;
            this.createPopup({ anchor: this.currentTarget });
        }
    }
    ngOnChanges(changes) {
        if (changes.target || changes.showOn) {
            this.bindShowHandler();
        }
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            const closeClickSubscription = this.renderer.listen('document', 'mousedown', (e) => {
                if (this.popupRef && !closest(e.target, node => node === this.popupRef.popupElement) && this.service.leaveMenu(e)) {
                    this.closePopup(e);
                }
            });
            const closeBlurSubscription = this.renderer.listen('window', 'blur', (e) => {
                if (this.popupRef) {
                    this.closePopup(e);
                }
            });
            this.closeSubscription = () => {
                closeClickSubscription();
                closeBlurSubscription();
            };
        });
    }
    ngOnDestroy() {
        if (this.closeSubscription) {
            this.closeSubscription();
            this.closeSubscription = null;
        }
        this.unbindShowHandler();
        this.removePopup();
    }
    /**
     * @hidden
     */
    emitMenuEvent(name, args) {
        args.target = this.currentTarget;
        args.sender = this;
        this[name].emit(args);
        if (name === 'select' && !args.hasContent) {
            this.closeAndFocus(args.originalEvent);
        }
    }
    bindShowHandler() {
        this.unbindShowHandler();
        this.ngZone.runOutsideAngular(() => {
            const element = this.targetElement();
            if (!element) {
                return;
            }
            const eventName = this.showOn || CONTEXT_MENU;
            this.showSubscription = this.renderer.listen(element, this.showOn || CONTEXT_MENU, (e) => {
                this.showContextMenu(e, element);
            });
            if (eventName === CONTEXT_MENU) {
                this.keydownSubscription = this.renderer.listen(element, 'keydown', (e) => {
                    if (e.shiftKey && e.keyCode === Keys.F10) {
                        this.showContextMenu(e, element);
                    }
                });
            }
        });
    }
    showContextMenu(e, element) {
        const filter = this.targetFilter();
        let currentTarget = element;
        if (filter) {
            currentTarget = findInContainer(e.target, filter, element);
            if (currentTarget && currentTarget !== e.target && isFocusable(e.target)) {
                return;
            }
            if (currentTarget && this.directiveTarget) {
                currentTarget = this.target.targetService.find(currentTarget);
            }
        }
        if (!currentTarget) {
            this.closePopup(e);
            return;
        }
        this.ngZone.run(() => {
            if (!this.closePopup(e)) {
                this.currentTarget = currentTarget;
                this.openPopup(e);
            }
        });
    }
    unbindShowHandler() {
        if (this.showSubscription) {
            this.showSubscription();
            this.showSubscription = null;
        }
        if (this.keydownSubscription) {
            this.keydownSubscription();
            this.keydownSubscription = null;
        }
    }
    targetElement() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.directiveTarget = false;
        let target = this.target;
        if (typeof target === 'string') {
            target = document.querySelector(target); // maybe querySelectorAll?
        }
        else if (target && target.nativeElement) {
            target = target.nativeElement;
        }
        else if (target instanceof ContextMenuTargetContainerDirective) {
            target = target.element;
            this.directiveTarget = true;
        }
        return target;
    }
    targetFilter() {
        if (this.directiveTarget) {
            return `.${TARGET_CLASS}`;
        }
        return this.filter;
    }
    closePopup(e) {
        if (!this.popupRef) {
            return;
        }
        return this.popupAction('popupClose', e, () => {
            this.removePopup();
        });
    }
    removePopup() {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
            this.currentTarget = null;
        }
        if (this.popupSubscriptions) {
            this.popupSubscriptions();
            this.popupSubscriptions = null;
        }
    }
    openPopup(e) {
        this.popupAction('popupOpen', e, () => {
            e.preventDefault();
            let anchor, offset;
            if (this.alignToAnchor || e.type === 'keydown') {
                anchor = this.currentTargetElement;
            }
            else {
                offset = { left: e.pageX, top: e.pageY };
            }
            this.createPopup({ anchor, offset });
        });
    }
    createPopup(options) {
        this.popupRef = this.popupService.open(Object.assign({
            animate: defined(this.popupAnimate) ? this.popupAnimate : true,
            appendTo: this.appendTo,
            collision: this.collision || DEFAULT_COLLISION,
            popupAlign: this.popupAlign || DEFAULT_POPUP_ALIGN,
            anchorAlign: this.anchorAlign || DEFAULT_ANCHOR_ALIGN,
            content: this.contentTemplate ? this.contentTemplate.templateRef : this.defaultContentTemplate,
            popupClass: 'k-menu-popup'
        }, options));
        const element = this.popupRef.popupElement;
        this.renderer.addClass(element, 'k-context-menu-popup');
        this.renderer.setAttribute(element, 'tabindex', '-1');
        this.renderer.setStyle(element, 'outline', '0'); //possibly move to styles
        if (this.ariaLabel) {
            this.renderer.setAttribute(element, 'aria-label', this.ariaLabel);
        }
        this.activeTarget = this.currentTargetElement === document.activeElement;
        this.ngZone.runOutsideAngular(() => {
            const unbindKeyDown = this.renderer.listen(element, 'keydown', this.popupKeyDownHandler);
            const unbindContextmenu = this.renderer.listen(element, 'contextmenu', preventDefault);
            this.popupSubscriptions = () => {
                unbindKeyDown();
                unbindContextmenu();
            };
        });
        element.focus();
    }
    closeAndFocus(e) {
        const currentTarget = this.currentTargetElement;
        if (!this.closePopup(e) && this.activeTarget) {
            currentTarget.focus();
        }
    }
    popupKeyDownHandler(e) {
        const element = this.popupRef.popupElement;
        if (e.keyCode === Keys.Escape && (hasClass(e.target, 'k-menu-item') || e.target === element)) {
            this.closeAndFocus(e);
        }
        else if (e.target === element) {
            this.service.keydown.emit(e);
        }
    }
    popupAction(name, originalEvent, callback) {
        const emitter = this[name];
        let prevented = false;
        if (hasObservers(emitter)) {
            this.ngZone.run(() => {
                const args = new ContextMenuPopupEvent({
                    originalEvent: originalEvent,
                    sender: this,
                    target: this.currentTarget
                });
                emitter.emit(args);
                if (!args.isDefaultPrevented()) {
                    callback();
                }
                prevented = args.isDefaultPrevented();
            });
        }
        else {
            callback();
        }
        return prevented;
    }
    get currentTargetElement() {
        return this.directiveTarget && this.currentTarget ? this.currentTarget.element : this.currentTarget;
    }
};
ContextMenuComponent.ɵfac = function ContextMenuComponent_Factory(t) { return new (t || ContextMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.PopupService), ɵngcc0.ɵɵdirectiveInject(ContextMenuService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ContextMenuComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ContextMenuComponent, selectors: [["kendo-contextmenu"]], contentQueries: function ContextMenuComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ContextMenuTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
    } }, viewQuery: function ContextMenuComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c5, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultContentTemplate = _t.first);
    } }, inputs: { showOn: "showOn", alignToAnchor: "alignToAnchor", vertical: "vertical", target: "target", filter: "filter", popupAnimate: "popupAnimate", popupAlign: "popupAlign", anchorAlign: "anchorAlign", collision: "collision", appendTo: "appendTo", ariaLabel: "ariaLabel" }, outputs: { popupOpen: "popupOpen", popupClose: "popupClose", select: "select", open: "open", close: "close" }, exportAs: ["kendoContextMenu"], features: [ɵngcc0.ɵɵProvidersFeature([
            ContextMenuService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.contextmenu'
            },
            {
                provide: ItemsService,
                useClass: ContextMenuItemsService
            },
            {
                provide: MenuBase,
                useExisting: forwardRef(() => ContextMenuComponent_1)
            },
            PopupService,
            {
                provide: POPUP_CONTAINER,
                useFactory: ɵ1$2
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 0, consts: [["default", ""], [3, "items", "vertical", "openOnClick", "hoverDelay", "animate", "menuItemTemplate", "menuItemLinkTemplate"]], template: function ContextMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ContextMenuComponent_ng_template_0_Template, 1, 7, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, directives: [MenuComponent], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], ContextMenuComponent.prototype, "showOn", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ContextMenuComponent.prototype, "target", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ContextMenuComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ContextMenuComponent.prototype, "alignToAnchor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ContextMenuComponent.prototype, "vertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ContextMenuComponent.prototype, "popupAnimate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ContextMenuComponent.prototype, "popupAlign", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ContextMenuComponent.prototype, "anchorAlign", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ContextMenuComponent.prototype, "collision", void 0);
__decorate([
    Input(),
    __metadata("design:type", ViewContainerRef)
], ContextMenuComponent.prototype, "appendTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ContextMenuComponent.prototype, "ariaLabel", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ContextMenuComponent.prototype, "popupOpen", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ContextMenuComponent.prototype, "popupClose", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ContextMenuComponent.prototype, "select", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ContextMenuComponent.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ContextMenuComponent.prototype, "close", void 0);
__decorate([
    ContentChild(ContextMenuTemplateDirective, { static: false }),
    __metadata("design:type", ContextMenuTemplateDirective)
], ContextMenuComponent.prototype, "contentTemplate", void 0);
__decorate([
    ViewChild('default', { static: false }),
    __metadata("design:type", TemplateRef)
], ContextMenuComponent.prototype, "defaultContentTemplate", void 0);
ContextMenuComponent = ContextMenuComponent_1 = __decorate([ __metadata("design:paramtypes", [PopupService,
        ContextMenuService,
        NgZone,
        Renderer2])
], ContextMenuComponent);

const COMPONENT_DIRECTIVES$1 = [
    ContextMenuComponent,
    ContextMenuTemplateDirective,
    ContextMenuTargetDirective,
    ContextMenuTargetContainerDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the ContextMenu component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the ContextMenu module
 * import { ContextMenuModule } from '@progress/kendo-angular-menu';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, ContextMenuModule], // import ContextMenuModule module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let ContextMenuModule = class ContextMenuModule {
};
ContextMenuModule.ɵfac = function ContextMenuModule_Factory(t) { return new (t || ContextMenuModule)(); };
ContextMenuModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ContextMenuModule });
ContextMenuModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[PopupModule, CommonModule, MenuModule], MenuModule] });

/**
 * A [module]({{ site.data.urls.angular['ngmoduleapi'] }}) that includes the Menu and ContextMenu components and directives.
 * Imports the MenusModule into your application [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity)
 * or any other sub-module that will use the Menu and ContextMenu components.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 * import { MenusModule } from '@progress/kendo-angular-menu';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, BrowserAnimationsModule, MenusModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
let MenusModule = class MenusModule {
};
MenusModule.ɵfac = function MenusModule_Factory(t) { return new (t || MenusModule)(); };
MenusModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MenusModule });
MenusModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [MenuModule, ContextMenuModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ItemsService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ActionsService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ItemsService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigationService, [{
        type: Injectable
    }], function () { return [{ type: ItemsService }, { type: ActionsService }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HoverService, [{
        type: Injectable
    }], function () { return [{ type: ActionsService }, { type: ItemsService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMenuItemTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ItemLinkTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMenuItemLinkTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ItemContentTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMenuItemContentTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MenuItemComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-menu-item',
                template: ``
            }]
    }], null, { text: [{
            type: Input
        }], url: [{
            type: Input
        }], disabled: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], cssStyle: [{
            type: Input
        }], icon: [{
            type: Input
        }], data: [{
            type: Input
        }], separator: [{
            type: Input
        }], itemTemplate: [{
            type: ContentChildren,
            args: [ItemTemplateDirective]
        }], itemLinkTemplate: [{
            type: ContentChildren,
            args: [ItemLinkTemplateDirective]
        }], itemContentTemplate: [{
            type: ContentChildren,
            args: [ItemContentTemplateDirective]
        }], children: [{
            type: ContentChildren,
            args: [MenuItemComponent_1]
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MenuComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoMenu',
                providers: [
                    ItemsService,
                    ActionsService,
                    NavigationService,
                    HoverService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.menu'
                    },
                    {
                        provide: MenuBase,
                        useExisting: forwardRef(() => MenuComponent_1)
                    }
                ],
                selector: 'kendo-menu',
                template: `
        <ul role="menubar"
            [attr.aria-orientation]="ariaOrientation"
            kendoMenuList [items]="rootItems" [level]="0" class="k-widget k-reset k-header k-menu"
            [vertical]="vertical" [rtl]="rtl" [animate]="animate" [openOnClick]="openOnClick"
            [itemTemplate]="itemTemplate.first?.templateRef || menuItemTemplate"
            [itemLinkTemplate]="itemLinkTemplate.first?.templateRef || menuItemLinkTemplate"
            [class.k-menu-horizontal]="!vertical"
            [class.k-menu-vertical]="vertical"
            [class.k-context-menu]="contextMenuClass">
        </ul>
    `
            }]
    }], function () { return [{ type: ItemsService }, { type: HoverService }, { type: ActionsService }, { type: NavigationService }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ContextMenuService, decorators: [{
                type: Optional
            }] }]; }, { select: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['class.k-rtl']
        }], menuItemTemplate: [{
            type: Input
        }], menuItemLinkTemplate: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ListComponent, [{
        type: Component,
        args: [{
                selector: '[kendoMenuList]',
                template: `
        <ng-container *ngFor="let item of items; let idx = index">
            <li *ngIf="!item.separator" kendoMenuItem
                [item]="item" [level]="level" [vertical]="vertical" [animate]="animate" [rtl]="rtl"
                [itemTemplate]="itemTemplate" [itemLinkTemplate]="itemLinkTemplate" [openOnClick]="openOnClick"
                [index]="hierarchyIndex(idx)" [siblingIndex]="idx" [attr.${NODE_INDEX}]="hierarchyIndex(idx)"
                [ngClass]="item.cssClass" [ngStyle]="item.cssStyle"
                role="menuitem"
                class="k-item k-menu-item"
                [class.k-first]="idx === 0" [class.k-last]="idx === items.length - 1"
                [class.k-state-disabled]="item.disabled"></li>
            <li *ngIf="item.separator" class="k-separator k-item"
                role="separator" [ngClass]="item.cssClass" [ngStyle]="item.cssStyle">
                &nbsp;
            </li>
        </ng-container>
    `
            }]
    }], function () { return [{ type: ItemsService }, { type: HoverService }, { type: ActionsService }, { type: NavigationService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }]; }, { animate: [{
            type: Input
        }], items: [{
            type: Input
        }], level: [{
            type: Input
        }], index: [{
            type: Input
        }], vertical: [{
            type: Input
        }], rtl: [{
            type: Input
        }], openOnClick: [{
            type: Input
        }], itemTemplate: [{
            type: Input
        }], itemLinkTemplate: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ItemComponent, [{
        type: Component,
        args: [{
                providers: [PopupService, {
                        provide: POPUP_CONTAINER,
                        useFactory: ɵ0$3
                    }],
                selector: '[kendoMenuItem]',
                template: `
    <span *ngIf="!hasLink && !item.content && !linkTemplate" class="k-link k-menu-link" #link
        [class.k-state-active]="opened" role="presentation">
        <ng-template [ngTemplateOutlet]="itemcontent">
        </ng-template>
    </span>
    <a *ngIf="item.url && !linkTemplate" class="k-link k-menu-link" #link [attr.href]="item.url"
        [class.k-state-active]="opened" tabindex="-1" role="presentation">
        <ng-template [ngTemplateOutlet]="itemcontent">
        </ng-template>
    </a>
    <ng-template *ngIf="linkTemplate && !item.content" [ngTemplateOutlet]="linkTemplate"
        [ngTemplateOutletContext]="{ item: item, index: index }">
    </ng-template>

    <div class="k-content" *ngIf="item.content" role="presentation">
        <ng-template [ngTemplateOutlet]="item.content" [ngTemplateOutletContext]="{ item: item.owner, index: item.ownerIndex }">
        </ng-template>
    </div>

    <ng-template #popupTemplate>
        <ul kendoMenuList
            [attr.id]="childId"
            [animate]="animate"
            [rtl]="rtl"
            [vertical]="vertical"
            [openOnClick]="openOnClick"
            [items]="children"
            [level]="level + 1"
            [index]="index"
            [itemTemplate]="itemTemplate"
            [itemLinkTemplate]="itemLinkTemplate"
            role="menu"
            class="k-group k-menu-group k-reset">
        </ul>
    </ng-template>

    <ng-template #itemcontent>
        <span *ngIf="item.icon" class="k-icon" [ngClass]="iconClass" role="presentation"></span>
        <ng-container *ngIf="!template">
            <span class="k-menu-link-text">{{ item.text }}</span>
        </ng-container>
        <ng-template *ngIf="template" [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{ item: item, index: index }">
        </ng-template>
        <span class="k-icon k-menu-expand-arrow" *ngIf="hasContent"
            role="presentation"
            [class.k-i-arrow-60-down]="!horizontal"
            [class.k-i-arrow-60-right]="horizontal && !rtl"
            [class.k-i-arrow-60-left]="horizontal && rtl">
        </span>
    </ng-template>
  `
            }]
    }], function () { return [{ type: ItemsService }, { type: NavigationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc3.PopupService }, { type: ɵngcc0.ElementRef }]; }, { animate: [{
            type: Input
        }], openOnClick: [{
            type: Input
        }], index: [{
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], hasPopup: [{
            type: HostBinding,
            args: ['attr.aria-haspopup']
        }], expanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], label: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], activeId: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], item: [{
            type: Input
        }], level: [{
            type: Input
        }], siblingIndex: [{
            type: Input
        }], vertical: [{
            type: Input
        }], rtl: [{
            type: Input
        }], itemTemplate: [{
            type: Input
        }], itemLinkTemplate: [{
            type: Input
        }], link: [{
            type: ViewChild,
            args: ['link', { static: false }]
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinkDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMenuItemLink]'
            }]
    }], function () { return [{ type: ItemsService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-link']
        }, {
            type: HostBinding,
            args: ['class.k-menu-link']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], activeClass: [{
            type: HostBinding,
            args: ['class.k-state-active']
        }], index: [{
            type: Input,
            args: ['kendoMenuItemLink']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExpandArrowDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMenuExpandArrow]'
            }]
    }], function () { return [{ type: ItemsService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-icon']
        }, {
            type: HostBinding,
            args: ['class.k-menu-expand-arrow']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], arrowDown: [{
            type: HostBinding,
            args: ['class.k-i-arrow-60-down']
        }], arrowRight: [{
            type: HostBinding,
            args: ['class.k-i-arrow-60-right']
        }], arrowLeft: [{
            type: HostBinding,
            args: ['class.k-i-arrow-60-left']
        }], index: [{
            type: Input,
            args: ['kendoMenuExpandArrow']
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HierarchyBindingDirective, [{
        type: Directive,
        args: [{
                exportAs: 'kendoMenuHierarchyBinding',
                selector: '[kendoMenuHierarchyBinding]'
            }]
    }], function () { return [{ type: MenuBase }]; }, { data: [{
            type: Input,
            args: ["kendoMenuHierarchyBinding"]
        }], textField: [{
            type: Input
        }], urlField: [{
            type: Input
        }], iconField: [{
            type: Input
        }], disabledField: [{
            type: Input
        }], cssClassField: [{
            type: Input
        }], cssStyleField: [{
            type: Input
        }], separatorField: [{
            type: Input
        }], childrenField: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FlatBindingDirective, [{
        type: Directive,
        args: [{
                exportAs: 'kendoMenuFlatBinding',
                selector: '[kendoMenuFlatBinding]'
            }]
    }], function () { return [{ type: MenuBase }]; }, { data: [{
            type: Input,
            args: ["kendoMenuFlatBinding"]
        }], textField: [{
            type: Input
        }], urlField: [{
            type: Input
        }], iconField: [{
            type: Input
        }], disabledField: [{
            type: Input
        }], cssClassField: [{
            type: Input
        }], cssStyleField: [{
            type: Input
        }], separatorField: [{
            type: Input
        }], idField: [{
            type: Input
        }], parentIdField: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MenuModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES],
                exports: [COMPONENT_EXPORTS],
                imports: [PopupModule, CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MenuModule, { declarations: function () { return [MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowDirective, ListComponent, ItemComponent]; }, imports: function () { return [PopupModule, CommonModule]; }, exports: function () { return [MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoContextMenuTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuItemsService, [{
        type: Injectable
    }], function () { return [{ type: ContextMenuService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuTargetService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuTargetContainerDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoContextMenuTargetContainer]',
                exportAs: 'kendoContextMenuTargetContainer',
                providers: [ContextMenuTargetService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ContextMenuTargetService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuTargetDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoContextMenuTarget]',
                exportAs: 'kendoContextMenuTarget'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ContextMenuTargetService }]; }, { hostClass: [{
            type: HostBinding,
            args: [`class.${TARGET_CLASS}`]
        }], data: [{
            type: Input,
            args: ['kendoContextMenuTarget']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoContextMenu',
                providers: [
                    ContextMenuService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.contextmenu'
                    },
                    {
                        provide: ItemsService,
                        useClass: ContextMenuItemsService
                    },
                    {
                        provide: MenuBase,
                        useExisting: forwardRef(() => ContextMenuComponent_1)
                    },
                    PopupService,
                    {
                        provide: POPUP_CONTAINER,
                        useFactory: ɵ1$2
                    }
                ],
                selector: 'kendo-contextmenu',
                template: `
        <ng-template #default>
            <kendo-menu [items]="rootItems"
                [vertical]="vertical"
                [openOnClick]="openOnClick"
                [hoverDelay]="hoverDelay"
                [animate]="animate"
                [menuItemTemplate]="itemTemplate.first?.templateRef"
                [menuItemLinkTemplate]="itemLinkTemplate.first?.templateRef"
                ></kendo-menu>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc3.PopupService }, { type: ContextMenuService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { showOn: [{
            type: Input
        }], alignToAnchor: [{
            type: Input
        }], vertical: [{
            type: Input
        }], popupOpen: [{
            type: Output
        }], popupClose: [{
            type: Output
        }], select: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], target: [{
            type: Input
        }], filter: [{
            type: Input
        }], popupAnimate: [{
            type: Input
        }], popupAlign: [{
            type: Input
        }], anchorAlign: [{
            type: Input
        }], collision: [{
            type: Input
        }], appendTo: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], contentTemplate: [{
            type: ContentChild,
            args: [ContextMenuTemplateDirective, { static: false }]
        }], defaultContentTemplate: [{
            type: ViewChild,
            args: ['default', { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES$1],
                exports: [COMPONENT_DIRECTIVES$1, MenuModule],
                imports: [PopupModule, CommonModule, MenuModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ContextMenuModule, { declarations: function () { return [ContextMenuComponent, ContextMenuTemplateDirective, ContextMenuTargetDirective, ContextMenuTargetContainerDirective]; }, imports: function () { return [PopupModule, CommonModule, MenuModule]; }, exports: function () { return [ContextMenuComponent, ContextMenuTemplateDirective, ContextMenuTargetDirective, ContextMenuTargetContainerDirective, MenuModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MenusModule, [{
        type: NgModule,
        args: [{
                exports: [MenuModule, ContextMenuModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MenusModule, { exports: [MenuModule, ContextMenuModule] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { NODE_INDEX, ContextMenuItemsService, ContextMenuTargetContainerDirective, ContextMenuTargetDirective, ContextMenuTargetService, BindingDirectiveBase, MenuBase, PreventableEvent, ActionsService, HoverService, ItemsService, NavigationService, bodyFactory, MenuComponent, ListComponent, ItemComponent, LinkDirective, ExpandArrowDirective, MenuItemComponent, MenuEvent, MenuSelectEvent, ItemContentTemplateDirective, ItemTemplateDirective, ItemLinkTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, MenuModule, ContextMenuEvent, ContextMenuSelectEvent, ContextMenuPopupEvent, ContextMenuTemplateDirective, ContextMenuComponent, ContextMenuModule, ContextMenuService, MenusModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4SUFHaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b0pBQUU7QUFDRiw2QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2SkFBRTtBQUNGLGdDQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4SUFBRTtBQUNGLDJCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnS0FHdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FKQUFFO0FBQ0Ysb0NBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aUtBQUU7QUFDRix3Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBLQUFFO0FBQ0YsMkNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O3dRQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQU1zQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O3VJQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQWdDRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzsrSUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQXFCRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dIQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQTRERztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs4REFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7aUVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRJQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MGhCQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBS0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cWhCQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FLRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7b0dBT2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzS0FBRTtBQUNGLDJDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytLQUFFO0FBQ0Ysc0NBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrTEFHNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2U0FBRTtBQUNGLGtEQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozt1R0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FLRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBEQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBc0NHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7bUlBT3NCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2SkFLZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjEgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgX19kZWNvcmF0ZSwgX19tZXRhZGF0YSwgX19wYXJhbSB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSwgRXZlbnRFbWl0dGVyLCBEaXJlY3RpdmUsIE9wdGlvbmFsLCBUZW1wbGF0ZVJlZiwgSW5wdXQsIENvbnRlbnRDaGlsZHJlbiwgUXVlcnlMaXN0LCBDb21wb25lbnQsIE91dHB1dCwgSG9zdEJpbmRpbmcsIGZvcndhcmRSZWYsIFJlbmRlcmVyMiwgRWxlbWVudFJlZiwgVmlld0NoaWxkLCBDaGFuZ2VEZXRlY3RvclJlZiwgaXNEZXZNb2RlLCBOZ01vZHVsZSwgVmlld0NvbnRhaW5lclJlZiwgQ29udGVudENoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWwxMG4nO1xuaW1wb3J0IHsgdmFsaWRhdGVQYWNrYWdlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWxpY2Vuc2luZyc7XG5pbXBvcnQgeyBoYXNPYnNlcnZlcnMsIGlzRG9jdW1lbnRBdmFpbGFibGUsIEtleXMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jb21tb24nO1xuaW1wb3J0IHsgUG9wdXBTZXJ2aWNlLCBQT1BVUF9DT05UQUlORVIsIFBvcHVwTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcG9wdXAnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhY2thZ2VNZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbWVudScsXG4gICAgcHJvZHVjdE5hbWU6ICdLZW5kbyBVSSBmb3IgQW5ndWxhcicsXG4gICAgcHJvZHVjdENvZGVzOiBbJ0tFTkRPVUlBTkdVTEFSJywgJ0tFTkRPVUlDT01QTEVURSddLFxuICAgIHB1Ymxpc2hEYXRlOiAxNjQ3MzU5MzAwLFxuICAgIHZlcnNpb246ICcnLFxuICAgIGxpY2Vuc2luZ0RvY3NVcmw6ICdodHRwczovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL215LWxpY2Vuc2UvP3V0bV9tZWRpdW09cHJvZHVjdCZ1dG1fc291cmNlPWtlbmRvYW5ndWxhciZ1dG1fY2FtcGFpZ249a2VuZG8tdWktYW5ndWxhci1wdXJjaGFzZS1saWNlbnNlLWtleXMtd2FybmluZydcbn07XG5cbmNvbnN0IFBBUkVOVF9SRUdFWCA9IC9fP1xcZCskLztcbmNvbnN0IFNFUEFSQVRPUiA9ICdfJztcbmxldCBpZCA9IDA7XG5jb25zdCBpdGVtSW5kZXhDb21wYXJlciA9IChhLCBiKSA9PiBhLnNpYmxpbmdJbmRleCAtIGIuc2libGluZ0luZGV4O1xuY29uc3QgbmV4dCA9IChpZHgsIGl0ZW1zLCBkaXIpID0+IHtcbiAgICBsZXQgY3VycmVudCA9IGl0ZW1zW2lkeCArIGRpcl07XG4gICAgd2hpbGUgKCFjdXJyZW50KSB7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICBpZHggPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlkeCA+PSBpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlkeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZHggKz0gZGlyO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBpdGVtc1tpZHhdO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEl0ZW1zU2VydmljZSA9IGNsYXNzIEl0ZW1zU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLml0ZW1zID0ge307XG4gICAgICAgIHRoaXMubGlzdHMgPSBbXTtcbiAgICAgICAgdGhpcy5pZFByZWZpeCA9IGBrLW1lbnUke2lkKyt9YDtcbiAgICB9XG4gICAgZ2V0IGhhc0l0ZW1zKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5pdGVtcykubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgY2hpbGRJZChpbmRleCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZFByZWZpeH0tY2hpbGQke2luZGV4fWA7XG4gICAgfVxuICAgIGl0ZW1JbmRleChwYXJlbnRJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIChwYXJlbnRJbmRleCA/IHBhcmVudEluZGV4ICsgU0VQQVJBVE9SIDogJycpICsgaW5kZXg7XG4gICAgfVxuICAgIGdldChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgfVxuICAgIGFkZChpdGVtKSB7XG4gICAgICAgIHRoaXMuaXRlbXNbaXRlbS5pbmRleF0gPSBpdGVtO1xuICAgIH1cbiAgICByZW1vdmUoaXRlbSkge1xuICAgICAgICBpZiAodGhpcy5pdGVtc1tpdGVtLmluZGV4XSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaXRlbXNbaXRlbS5pbmRleF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTGlzdChsaXN0KSB7XG4gICAgICAgIHRoaXMubGlzdHMucHVzaChsaXN0KTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdChsaXN0KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5saXN0cy5pbmRleE9mKGxpc3QpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5saXN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnRhaW5zTGlzdChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMubGlzdHMuZmluZChsaXN0ID0+IGxpc3QuZWxlbWVudC5uYXRpdmVFbGVtZW50ID09PSBlbGVtZW50KSk7XG4gICAgfVxuICAgIHNpYmxpbmdzKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgcGFyZW50SW5kZXggPSB0aGlzLnBhcmVudEluZGV4KGl0ZW0uaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoKGluZGV4KSA9PiB0aGlzLnBhcmVudEluZGV4KGluZGV4KSA9PT0gcGFyZW50SW5kZXgpO1xuICAgIH1cbiAgICBvdGhlclNpYmxpbmdzKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgcGFyZW50SW5kZXggPSB0aGlzLnBhcmVudEluZGV4KGl0ZW0uaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoKGluZGV4KSA9PiB0aGlzLnBhcmVudEluZGV4KGluZGV4KSA9PT0gcGFyZW50SW5kZXggJiYgaW5kZXggIT09IGl0ZW0uaW5kZXgpO1xuICAgIH1cbiAgICBjaGlsZHJlbihpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcigoaW5kZXgpID0+IHRoaXMucGFyZW50SW5kZXgoaW5kZXgpID09PSBpdGVtLmluZGV4KTtcbiAgICB9XG4gICAgcGFyZW50KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbdGhpcy5wYXJlbnRJbmRleChpdGVtLmluZGV4KV07XG4gICAgfVxuICAgIHJvb3QoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1t0aGlzLmluZGljZXMoaXRlbS5pbmRleClbMF1dO1xuICAgIH1cbiAgICBpbmRpY2VzKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleC5zcGxpdChTRVBBUkFUT1IpO1xuICAgIH1cbiAgICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGluZGV4LCBpdGVtc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbXNbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnNvcnQoaXRlbUluZGV4Q29tcGFyZXIpO1xuICAgIH1cbiAgICBwcmV2aW91cyhpdGVtKSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy5zaWJsaW5ncyhpdGVtKTtcbiAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gc2libGluZ3MuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgcmV0dXJuIG5leHQoaXRlbUluZGV4LCBzaWJsaW5ncywgLTEpO1xuICAgIH1cbiAgICBuZXh0KGl0ZW0pIHtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLnNpYmxpbmdzKGl0ZW0pO1xuICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBzaWJsaW5ncy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICByZXR1cm4gbmV4dChpdGVtSW5kZXgsIHNpYmxpbmdzLCAxKTtcbiAgICB9XG4gICAgaGFzUGFyZW50KGl0ZW0sIHBhcmVudCkge1xuICAgICAgICByZXR1cm4gaXRlbS5pbmRleC5zdGFydHNXaXRoKHBhcmVudC5pbmRleCk7XG4gICAgfVxuICAgIGFyZVNpYmxpbmdzKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICByZXR1cm4gaXRlbTEgIT09IGl0ZW0yICYmIHRoaXMucGFyZW50KGl0ZW0xKSA9PT0gdGhpcy5wYXJlbnQoaXRlbTIpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtcy5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpdGVtc1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmVudEluZGV4KGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleC5yZXBsYWNlKFBBUkVOVF9SRUdFWCwgJycpO1xuICAgIH1cbn07XG5JdGVtc1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIEl0ZW1zU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIGEgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIEluIHRoaXMgd2F5LCB0aGUgc291cmNlIGNvbXBvbmVudCBzdXBwcmVzc2VzXG4gICAgICogdGhlIGJ1aWx0LWluIGJlaGF2aW9yIHRoYXQgZm9sbG93cyB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHRoaXMucHJldmVudGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGV2ZW50IHdhcyBwcmV2ZW50ZWRcbiAgICAgKiBieSBhbnkgb2YgaXRzIHN1YnNjcmliZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBkZWZhdWx0IGFjdGlvbiB3YXMgcHJldmVudGVkLlxuICAgICAqIE90aGVyd2lzZSwgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqL1xuICAgIGlzRGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudGVkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIG9mIHRoZSBNZW51LlxuICovXG5jbGFzcyBNZW51RXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbn1cblxuY29uc3QgY2FuUGVyZm9ybUFjdGlvbiA9IChpdGVtLCBhY3Rpb24pID0+ICEoKGFjdGlvbiA9PT0gJ29wZW4nICYmIGl0ZW0ub3BlbmVkKSB8fCAoYWN0aW9uID09PSAnY2xvc2UnICYmICFpdGVtLm9wZW5lZCkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBBY3Rpb25zU2VydmljZSA9IGNsYXNzIEFjdGlvbnNTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihuZ1pvbmUsIGl0ZW1zKSB7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBvcGVuKGl0ZW0sIGZpbmlzaGVkKSB7XG4gICAgICAgIGlmIChpdGVtLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0uaGFzQ29udGVudCAmJiAhaXRlbS5vcGVuZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnb3BlbicsXG4gICAgICAgICAgICAgICAgcmVxdWlyZXNab25lOiBpdGVtLmhhc0NvbnRlbnRUZW1wbGF0ZXMoKSxcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgZmluaXNoZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZShpdGVtKSB7XG4gICAgICAgIHRoaXMuY2xvc2VDaGlsZHJlbihpdGVtKTtcbiAgICAgICAgdGhpcy5jbG9zZUl0ZW0oaXRlbSk7XG4gICAgfVxuICAgIGNsb3NlSXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLm9wZW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjbG9zZScsXG4gICAgICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2VUb1Jvb3QoaXRlbSkge1xuICAgICAgICB0aGlzLmNsb3NlQ2hpbGRyZW4oaXRlbSk7XG4gICAgICAgIGxldCBjdXJyZW50ID0gaXRlbTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUl0ZW0oY3VycmVudCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5pdGVtcy5wYXJlbnQoY3VycmVudCk7XG4gICAgICAgIH0gd2hpbGUgKGN1cnJlbnQpO1xuICAgIH1cbiAgICBjbG9zZU90aGVycyhpdGVtKSB7XG4gICAgICAgIHRoaXMuY2xvc2VDaGlsZHJlbihpdGVtKTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBpdGVtO1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLml0ZW1zLm90aGVyU2libGluZ3MoY3VycmVudCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlSXRlbXMoc2libGluZ3MpO1xuICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuaXRlbXMucGFyZW50KGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlQWxsKCkge1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLm9wZW5lZCAmJiBpdGVtLmxldmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbGVjdChpdGVtLCBkb21FdmVudCwgcHJldmVudGVkLCBmaW5pc2hlZCkge1xuICAgICAgICB0aGlzLmFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiAnc2VsZWN0JyxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBwcmV2ZW50ZWQsXG4gICAgICAgICAgICBmaW5pc2hlZCxcbiAgICAgICAgICAgIGRvbUV2ZW50XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbWl0KG5hbWUsIGl0ZW0sIGRvbUV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG93bmVyID0gdGhpcy5vd25lcjtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzID0gbmV3IE1lbnVFdmVudCh7XG4gICAgICAgICAgICBzZW5kZXI6IG93bmVyLFxuICAgICAgICAgICAgaXRlbTogaXRlbS5pdGVtLFxuICAgICAgICAgICAgaW5kZXg6IGl0ZW0uaW5kZXgsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBkb21FdmVudCxcbiAgICAgICAgICAgIGhhc0NvbnRlbnQ6IGl0ZW0uaGFzQ29udGVudFxuICAgICAgICB9KTtcbiAgICAgICAgb3duZXJbbmFtZV0uZW1pdChldmVudEFyZ3MpO1xuICAgICAgICBpZiAob3duZXIuY29udGV4dFNlcnZpY2UpIHtcbiAgICAgICAgICAgIG93bmVyLmNvbnRleHRTZXJ2aWNlLmVtaXQobmFtZSwgZXZlbnRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRBcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuICAgIH1cbiAgICBnZXQgaGFzUGVuZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBleGVjdXRlKHRvRXhlY3V0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzUGVuZGluZyAmJiAhdG9FeGVjdXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHRvRXhlY3V0ZSB8fCB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGlmICghTmdab25lLmlzSW5Bbmd1bGFyWm9uZSgpICYmIHRoaXMucmVxdWlyZXNab25lKGFjdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0ZUFjdGlvbnMoYWN0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZUFjdGlvbnMoYWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9XG4gICAgZXhlY3V0ZUFjdGlvbnMoYWN0aW9ucykge1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhY3Rpb25zLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXRlbSwgbmFtZSwgcHJldmVudGVkLCBmaW5pc2hlZCwgZG9tRXZlbnQgfSA9IGFjdGlvbnNbaWR4XTtcbiAgICAgICAgICAgIGlmICghY2FuUGVyZm9ybUFjdGlvbihpdGVtLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmVtaXQobmFtZSwgaXRlbSwgZG9tRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVtuYW1lXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1aXJlc1pvbmUodG9FeGVjdXRlKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB0b0V4ZWN1dGUgfHwgdGhpcy5hY3Rpb25zO1xuICAgICAgICBjb25zdCBvd25lciA9IHRoaXMub3duZXI7XG4gICAgICAgIGNvbnN0IGNvbnRleHRTZXJ2aWNlID0gb3duZXIuY29udGV4dFNlcnZpY2U7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGFjdGlvbnMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uID0gYWN0aW9uc1tpZHhdO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGFjdGlvbi5uYW1lO1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5yZXF1aXJlc1pvbmUgfHwgKG5hbWUgJiYgKGhhc09ic2VydmVycyhvd25lcltuYW1lXSkgfHwgKGNvbnRleHRTZXJ2aWNlICYmIGNvbnRleHRTZXJ2aWNlLmhhc09ic2VydmVycyhuYW1lKSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2xvc2VDaGlsZHJlbihpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5vcGVuZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXMuY2hpbGRyZW4oaXRlbSk7XG4gICAgICAgIHRoaXMuY2xvc2VJdGVtcyhjaGlsZHJlbik7XG4gICAgfVxuICAgIGNsb3NlSXRlbXMoaXRlbXMpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgaXRlbXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZShpdGVtc1tpZHhdKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5BY3Rpb25zU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05nWm9uZSwgSXRlbXNTZXJ2aWNlXSlcbl0sIEFjdGlvbnNTZXJ2aWNlKTtcblxuY29uc3QgREVGQVVMVF9BQ1RJVkUgPSAnMCc7XG5jb25zdCBOT19TUEFDRV9SRUdFWCA9IC9cXFMvO1xuY29uc3QgaGFuZGxlcnMgPSB7fTtcbmhhbmRsZXJzWyczNyddID0gJ2xlZnQnO1xuaGFuZGxlcnNbJzM5J10gPSAncmlnaHQnO1xuaGFuZGxlcnNbJzM4J10gPSAndXAnO1xuaGFuZGxlcnNbJzQwJ10gPSAnZG93bic7XG5oYW5kbGVyc1snMzYnXSA9ICdob21lJztcbmhhbmRsZXJzWyczNSddID0gJ2VuZCc7XG5oYW5kbGVyc1snMzInXSA9ICdlbnRlcic7XG5oYW5kbGVyc1snMTMnXSA9ICdlbnRlcic7XG5oYW5kbGVyc1snMjcnXSA9ICdlc2MnO1xuaGFuZGxlcnNbJzknXSA9ICd0YWInO1xuY29uc3QgaGFuZGxlcnNSVEwgPSBPYmplY3QuYXNzaWduKHt9LCBoYW5kbGVycywge1xuICAgICczNyc6ICdyaWdodCcsXG4gICAgJzM5JzogJ2xlZnQnXG59KTtcbmZ1bmN0aW9uIGlzUHJpbnRhYmxlQ2hhcmFjdGVyKGtleSkge1xuICAgIHJldHVybiBrZXkubGVuZ3RoID09PSAxICYmIE5PX1NQQUNFX1JFR0VYLnRlc3Qoa2V5KTtcbn1cbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTmF2aWdhdGlvblNlcnZpY2UgPSBjbGFzcyBOYXZpZ2F0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMsIGFjdGlvbnMsIGxvY2FsaXphdGlvbiwgbmdab25lKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gYWN0aW9ucztcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBERUZBVUxUX0FDVElWRTtcbiAgICB9XG4gICAgZ2V0IGZvY3VzZWRJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5nZXQodGhpcy5mb2N1c2VkSWR4KTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZUl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmdldCh0aGlzLmFjdGl2ZUluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGhhbmRsZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gaGFuZGxlcnNSVEwgOiBoYW5kbGVycztcbiAgICB9XG4gICAgZm9jdXMoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5pbmRleCA9PT0gdGhpcy5mb2N1c2VkSWR4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUl0ZW0gfHwgIXRoaXMuaXRlbXMuaGFzUGFyZW50KGl0ZW0sIHRoaXMuYWN0aXZlSXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0Rm9jdXMoaXRlbSk7XG4gICAgfVxuICAgIHNldEZvY3VzKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkSWR4ID0gaXRlbS5pbmRleDtcbiAgICAgICAgaXRlbS5mb2N1cygpO1xuICAgIH1cbiAgICBmb2N1c0xlYXZlKCkge1xuICAgICAgICBjb25zdCBmb2N1c2VkID0gdGhpcy5mb2N1c2VkSXRlbTtcbiAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5jbG9zZVRvUm9vdChmb2N1c2VkKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5leGVjdXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2N1c2VkSWR4ID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlQWN0aXZlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlSXRlbSAmJiB0aGlzLml0ZW1zLmhhc0l0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEl0ZW0gPSB0aGlzLml0ZW1zLmdldChERUZBVUxUX0FDVElWRSk7XG4gICAgICAgICAgICBmaXJzdEl0ZW0udG9nZ2xlQWN0aXZlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IERFRkFVTFRfQUNUSVZFO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bihlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmZvY3VzZWRJdGVtIHx8IHRoaXMuYWN0aXZlSXRlbTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnNbZS5rZXlDb2RlXTtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSAndGFiJykge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbaGFuZGxlcl0oY3VycmVudCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQcmludGFibGVDaGFyYWN0ZXIoZS5rZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaChjdXJyZW50LCBlLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zLmV4ZWN1dGUoKTtcbiAgICB9XG4gICAgZm9jdXNJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoIWluZGV4ICYmIHRoaXMuYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5zZXRGb2N1cyh0aGlzLmFjdGl2ZUl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSAnZmlyc3QnKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzRmlyc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gJ2xhc3QnKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzTGFzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cyhpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb2N1c0ZpcnN0KCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXMuc2libGluZ3ModGhpcy5pdGVtcy5nZXQoJzAnKSk7XG4gICAgICAgIHRoaXMuZm9jdXMoaXRlbXNbMF0pO1xuICAgIH1cbiAgICBmb2N1c0xhc3QoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcy5zaWJsaW5ncyh0aGlzLml0ZW1zLmdldCgnMCcpKTtcbiAgICAgICAgdGhpcy5mb2N1cyhpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSk7XG4gICAgfVxuICAgIHNlYXJjaChjdXJyZW50LCBrZXkpIHtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLml0ZW1zLnNpYmxpbmdzKGN1cnJlbnQpO1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gc2libGluZ3MuaW5kZXhPZihjdXJyZW50KTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBzaWJsaW5ncy5zbGljZShzdGFydEluZGV4ICsgMSkuY29uY2F0KHNpYmxpbmdzLnNsaWNlKDAsIHN0YXJ0SW5kZXgpKTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgaXRlbXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IGl0ZW1zW2lkeF07XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gc2libGluZy5pdGVtLnRleHQgfHwgXCJcIjtcbiAgICAgICAgICAgIGlmICh0ZXh0LnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChrZXkudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRvd24oY3VycmVudCkge1xuICAgICAgICBpZiAoY3VycmVudC5sZXZlbCA9PT0gMCAmJiAhdGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuaGFzQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5vcGVuKGN1cnJlbnQsIHRoaXMuZm9jdXNDaGlsZChjdXJyZW50LCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKHRoaXMuaXRlbXMubmV4dChjdXJyZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXAoY3VycmVudCkge1xuICAgICAgICBpZiAoY3VycmVudC5sZXZlbCA9PT0gMCAmJiAhdGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuaGFzQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5vcGVuKGN1cnJlbnQsIHRoaXMuZm9jdXNDaGlsZChjdXJyZW50LCBjdXJyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXModGhpcy5pdGVtcy5wcmV2aW91cyhjdXJyZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGVmdChjdXJyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsICYmIGN1cnJlbnQubGV2ZWwgPT09IDAgJiYgY3VycmVudC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50LmxldmVsID4gMSB8fCAodGhpcy52ZXJ0aWNhbCAmJiBjdXJyZW50LmxldmVsID4gMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuaXRlbXMucGFyZW50KGN1cnJlbnQpO1xuICAgICAgICAgICAgdGhpcy5mb2N1cyhwYXJlbnQpO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmNsb3NlKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy52ZXJ0aWNhbCAmJiBjdXJyZW50LmxldmVsID09PSAwICYmICFjdXJyZW50LmRpc2FibGVkKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5oYXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLm9wZW4oY3VycmVudCwgdGhpcy5mb2N1c0NoaWxkKGN1cnJlbnQsIGN1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb2N1cyh0aGlzLml0ZW1zLnByZXZpb3VzKHRoaXMuYWN0aXZlSXRlbSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJpZ2h0KGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWwgJiYgY3VycmVudC5sZXZlbCA9PT0gMCAmJiBjdXJyZW50LmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQuaG9yaXpvbnRhbCAmJiAhY3VycmVudC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuaGFzQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5vcGVuKGN1cnJlbnQsIHRoaXMuZm9jdXNDaGlsZChjdXJyZW50LCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy52ZXJ0aWNhbCB8fCBjdXJyZW50LmxldmVsID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXModGhpcy5pdGVtcy5uZXh0KHRoaXMuYWN0aXZlSXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb2N1cyh0aGlzLml0ZW1zLm5leHQodGhpcy5hY3RpdmVJdGVtKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaG9tZShjdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy5pdGVtcy5zaWJsaW5ncyhjdXJyZW50KTtcbiAgICAgICAgdGhpcy5mb2N1cyhzaWJsaW5nc1swXSk7XG4gICAgfVxuICAgIGVuZChjdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy5pdGVtcy5zaWJsaW5ncyhjdXJyZW50KTtcbiAgICAgICAgdGhpcy5mb2N1cyhzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXSk7XG4gICAgfVxuICAgIGVudGVyKGN1cnJlbnQsIGRvbUV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIGlmIChjdXJyZW50LmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQuaGFzQ29udGVudCkge1xuICAgICAgICAgICAgYWN0aW9ucy5zZWxlY3QoY3VycmVudCwgZG9tRXZlbnQpO1xuICAgICAgICAgICAgYWN0aW9ucy5vcGVuKGN1cnJlbnQsIHRoaXMuZm9jdXNDaGlsZChjdXJyZW50LCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3Rpb25zLnNlbGVjdChjdXJyZW50LCBkb21FdmVudCwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQubmF2aWdhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5mb2N1cyh0aGlzLml0ZW1zLnJvb3QoY3VycmVudCkpO1xuICAgICAgICAgICAgYWN0aW9ucy5jbG9zZVRvUm9vdChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlc2MoY3VycmVudCkge1xuICAgICAgICBpZiAoY3VycmVudC5sZXZlbCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuaXRlbXMucGFyZW50KGN1cnJlbnQpO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmNsb3NlKHBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFiKGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQubGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb2N1c0NoaWxkKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuaXRlbXMuY2hpbGRyZW4oaXRlbSlbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXRGb2N1cyhjaGlsZCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldEFjdGl2ZShpdGVtKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzZWQgPSB0aGlzLmZvY3VzZWRJdGVtO1xuICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLml0ZW1zLnJvb3QoaXRlbSk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbS50b2dnbGVBY3RpdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBhY3RpdmUuaW5kZXg7XG4gICAgICAgIGFjdGl2ZS50b2dnbGVBY3RpdmUodHJ1ZSk7XG4gICAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuY2xvc2VUb1Jvb3QoZm9jdXNlZCk7XG4gICAgICAgICAgICBpZiAoZm9jdXNlZC5sZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMub3BlbihhY3RpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbk5hdmlnYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSXRlbXNTZXJ2aWNlLFxuICAgICAgICBBY3Rpb25zU2VydmljZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgTmdab25lXSlcbl0sIE5hdmlnYXRpb25TZXJ2aWNlKTtcblxuY29uc3QgRElTQUJMRV9PUEVOX09OX09WRVJfREVMQVkgPSA1MDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEhvdmVyU2VydmljZSA9IGNsYXNzIEhvdmVyU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoYWN0aW9ucywgaXRlbXMpIHtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gYWN0aW9ucztcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmRlbGF5ID0gMTAwO1xuICAgICAgICB0aGlzLl9vcGVuT25PdmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSBbXTtcbiAgICB9XG4gICAgZ2V0IG9wZW5Pbk92ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVuT25PdmVyO1xuICAgIH1cbiAgICBzZXQgb3Blbk9uT3Zlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmNhbmNlbEFjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5fb3Blbk9uT3ZlciA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaG92ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZ2V0KHRoaXMuaG92ZXJlZElkeCk7XG4gICAgfVxuICAgIHNldCBob3ZlcmVkKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5ob3ZlcmVkSWR4ID0gaXRlbSA/IGl0ZW0uaW5kZXggOiBudWxsO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxBY3Rpb25zKCk7XG4gICAgfVxuICAgIG92ZXIoaXRlbSkge1xuICAgICAgICB0aGlzLmNhbmNlbEFjdGlvbnMoKGFjdGlvbikgPT4gYWN0aW9uLm5hbWUgPT09ICdvcGVuT25PdmVyJyk7XG4gICAgICAgIGlmICghdGhpcy5ob3ZlcmVkIHx8IHRoaXMuaG92ZXJlZCAhPT0gaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmNsb3NlT3RoZXJzKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5ob3ZlcmVkID0gaXRlbTtcbiAgICAgICAgICAgIGlmICgoaXRlbS5sZXZlbCA+IDAgfHwgdGhpcy5vcGVuT25PdmVyKSAmJiAhaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5vcGVuKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsQWN0aW9ucygoYWN0aW9uKSA9PiAoYWN0aW9uLm5hbWUgPT09ICdjbG9zZScgJiYgKGl0ZW0gPT09IGFjdGlvbi5pdGVtIHx8IHRoaXMuaXRlbXMuaGFzUGFyZW50KGl0ZW0sIGFjdGlvbi5pdGVtKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIChhY3Rpb24ubmFtZSA9PT0gJ29wZW4nICYmICF0aGlzLml0ZW1zLmhhc1BhcmVudChpdGVtLCBhY3Rpb24uaXRlbSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVBY3Rpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGVhdmUoZGlzYWJsZU9wZW5Pbk92ZXIpIHtcbiAgICAgICAgY29uc3QgaG92ZXJlZCA9IHRoaXMuaG92ZXJlZDtcbiAgICAgICAgaWYgKGhvdmVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5jbG9zZVRvUm9vdChob3ZlcmVkKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQWN0aW9ucyhhY3Rpb24gPT4gYWN0aW9uLm5hbWUgPT09ICdvcGVuJyk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQWN0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNhYmxlT3Blbk9uT3ZlciAmJiB0aGlzLl9vcGVuT25PdmVyKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlRGlzYWJsZU9wZW5Pbk92ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvdmVyZWQgPSBudWxsO1xuICAgIH1cbiAgICBjbG9zZUN1cnJlbnQoKSB7XG4gICAgICAgIGNvbnN0IGhvdmVyZWQgPSB0aGlzLmhvdmVyZWQ7XG4gICAgICAgIGlmIChob3ZlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuY2xvc2VUb1Jvb3QoaG92ZXJlZCk7XG4gICAgICAgICAgICB0aGlzLmhvdmVyZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjaGVkdWxlQWN0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aW9ucy5oYXNQZW5kaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0ge307XG4gICAgICAgICAgICBpdGVtLmFjdGlvbnMgPSB0aGlzLmFjdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgICAgIGl0ZW0uaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMuZXhlY3V0ZShpdGVtLmFjdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2NoZWR1bGVkKGl0ZW0pO1xuICAgICAgICAgICAgfSwgdGhpcy5kZWxheSk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlZC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjaGVkdWxlRGlzYWJsZU9wZW5Pbk92ZXIoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICBhY3Rpb25zOiBbeyBuYW1lOiAnb3Blbk9uT3ZlcicgfV1cbiAgICAgICAgfTtcbiAgICAgICAgaXRlbS5pZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb3Blbk9uT3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTY2hlZHVsZWQoaXRlbSk7XG4gICAgICAgIH0sIE1hdGgubWF4KHRoaXMuZGVsYXksIERJU0FCTEVfT1BFTl9PTl9PVkVSX0RFTEFZKSk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJlbW92ZVNjaGVkdWxlZChpdGVtKSB7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZCA9IHRoaXMuc2NoZWR1bGVkO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzY2hlZHVsZWQubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlZFtpZHhdID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxBY3Rpb25zKHByZWRpY2F0ZSkge1xuICAgICAgICBjb25zdCBzY2hlZHVsZWQgPSB0aGlzLnNjaGVkdWxlZDtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gc2NoZWR1bGVkLmxlbmd0aCAtIDE7IGlkeCA+PSAwOyBpZHgtLSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVkdWxlZFtpZHhdO1xuICAgICAgICAgICAgY29uc3QgYWN0aW9ucyA9IGl0ZW0uYWN0aW9ucztcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3Rpb25JZHggPSBhY3Rpb25zLmxlbmd0aCAtIDE7IGFjdGlvbklkeCA+PSAwOyBhY3Rpb25JZHgtLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKGFjdGlvbnNbYWN0aW9uSWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMuc3BsaWNlKGFjdGlvbklkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZSB8fCBhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpdGVtLmlkKTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWQuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuSG92ZXJTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQWN0aW9uc1NlcnZpY2UsIEl0ZW1zU2VydmljZV0pXG5dLCBIb3ZlclNlcnZpY2UpO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub3JtYWxpemUgPSAoc2V0dGluZ3MpID0+IHNldHRpbmdzICYmIE9iamVjdC5hc3NpZ24oe1xuICAgIHRvZ2dsZTogJ3NlbGVjdCdcbn0sIHNldHRpbmdzKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE5PREVfSU5ERVggPSAnZGF0YS1rZW5kby1tZW51LWluZGV4JztcblxuY29uc3QgREVGQVVMVF9JRCA9ICdrZW5kby1tYXRjaGVzLWNvbnRhaW5lcic7XG5jb25zdCBmb2N1c2FibGVSZWdleCA9IC9eKD86YXxpbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC9pO1xuY29uc3QgbWF0Y2hlcyA9IChlbGVtZW50LCBzZWxlY3RvcikgPT4gKGVsZW1lbnQubWF0Y2hlcyB8fCBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0ID0gKG5vZGUsIHByZWRpY2F0ZSkgPT4ge1xuICAgIHdoaWxlIChub2RlICYmICFwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3RJblNjb3BlID0gKG5vZGUsIHByZWRpY2F0ZSwgc2NvcGUpID0+IHtcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBzY29wZSAmJiAhcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlICE9PSBzY29wZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzRm9jdXNhYmxlID0gKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoZWxlbWVudC50YWdOYW1lKSB7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICAgICAgY29uc3Qgc2tpcFRhYiA9IHRhYkluZGV4ID09PSAnLTEnO1xuICAgICAgICBsZXQgZm9jdXNhYmxlID0gdGFiSW5kZXggIT09IG51bGwgJiYgIXNraXBUYWI7XG4gICAgICAgIGlmIChmb2N1c2FibGVSZWdleC50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICBmb2N1c2FibGUgPSAhZWxlbWVudC5kaXNhYmxlZCAmJiAhc2tpcFRhYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9jdXNhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgdG9DbGFzc0xpc3QgPSAoY2xhc3NOYW1lcykgPT4gU3RyaW5nKGNsYXNzTmFtZXMpLnRyaW0oKS5zcGxpdCgnICcpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc0NsYXNzID0gKGVsZW1lbnQsIG5hbWUpID0+IHtcbiAgICByZXR1cm4gdG9DbGFzc0xpc3QoZWxlbWVudC5jbGFzc05hbWUpLmluZGV4T2YobmFtZSkgPj0gMDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbWF0Y2hlc0NsYXNzZXMgPSAoY2xhc3NlcykgPT4ge1xuICAgIGNvbnN0IGxpc3QgPSB0b0NsYXNzTGlzdChjbGFzc2VzKTtcbiAgICByZXR1cm4gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgY29uc3QgY2xhc3NMaXN0ID0gdG9DbGFzc0xpc3QoZWxlbWVudC5jbGFzc05hbWUpO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihsaXN0LmZpbmQobmFtZSA9PiBjbGFzc0xpc3QuaW5kZXhPZihuYW1lKSA+PSAwKSk7XG4gICAgfTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgbm9kZUluZGV4ID0gKG5vZGUpID0+IG5vZGUuZ2V0QXR0cmlidXRlKE5PREVfSU5ERVgpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3RJdGVtID0gKG5vZGUsIHNjb3BlKSA9PiBjbG9zZXN0SW5TY29wZShub2RlLCBub2RlSW5kZXgsIHNjb3BlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0TGlzdCA9IChub2RlKSA9PiB7XG4gICAgbGV0IGxpc3QgPSBjbG9zZXN0KG5vZGUsIG1hdGNoZXNDbGFzc2VzKCdrLW1lbnUtcG9wdXAgay1tZW51IGstbWVudS1ncm91cCcpKTtcbiAgICBpZiAobGlzdCAmJiBoYXNDbGFzcyhsaXN0LCAnay1tZW51LXBvcHVwJykpIHtcbiAgICAgICAgbGlzdCA9IGxpc3QucXVlcnlTZWxlY3RvcignLmstbWVudS1ncm91cCcpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaW5NZW51ID0gKG5vZGUsIGl0ZW1zU2VydmljZSkgPT4ge1xuICAgIGlmIChub2RlID09PSBpdGVtc1NlcnZpY2UubGlzdHNbMF0uZWxlbWVudC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbGlzdCA9IGNsb3Nlc3RMaXN0KG5vZGUpO1xuICAgIHJldHVybiBsaXN0ICYmIGl0ZW1zU2VydmljZS5jb250YWluc0xpc3QobGlzdCk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZpbmRJbkNvbnRhaW5lciA9IChlbGVtZW50LCBzZWxlY3RvciwgY29udGFpbmVyKSA9PiB7XG4gICAgY29uc3QgaWQgPSBjb250YWluZXIuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgIGlmICghaWQpIHtcbiAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCBERUZBVUxUX0lEKTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dFNlbGVjdG9yID0gYCMke2lkIHx8IERFRkFVTFRfSUR9ICR7c2VsZWN0b3J9YDtcbiAgICBjb25zdCBtYXRjaCA9IGNsb3Nlc3RJblNjb3BlKGVsZW1lbnQsIG5vZGUgPT4gbWF0Y2hlcyhub2RlLCBjb250ZXh0U2VsZWN0b3IpLCBjb250YWluZXIpO1xuICAgIGlmICghaWQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoO1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDb250ZXh0TWVudVNlcnZpY2UgPSBjbGFzcyBDb250ZXh0TWVudVNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5rZXlkb3duID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBlbWl0KG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy5vd25lci5lbWl0TWVudUV2ZW50KG5hbWUsIGFyZ3MpO1xuICAgIH1cbiAgICBoYXNPYnNlcnZlcnMobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vd25lciAmJiBoYXNPYnNlcnZlcnModGhpcy5vd25lcltuYW1lXSk7XG4gICAgfVxuICAgIGxlYXZlTWVudShlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zID8gIWluTWVudShlLnRhcmdldCwgdGhpcy5pdGVtcykgOiB0cnVlO1xuICAgIH1cbn07XG5Db250ZXh0TWVudVNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIENvbnRleHRNZW51U2VydmljZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRlbXBsYXRlIGZvciB0aGUgTWVudSBpdGVtcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRlbXBsYXRlc19tZW51ICV9KSkuIFRvIGRlZmluZSBhIHRlbXBsYXRlXG4gKiBmb3IgYW4gaXRlbSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnIHdpdGggdGhlIGBrZW5kb01lbnVJdGVtVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYSBgPGtlbmRvLW1lbnUtaXRlbT5gXG4gKiBjb21wb25lbnQuIFRvIGRlZmluZSBhIHRlbXBsYXRlIGZvciBhbGwgTWVudSBpdGVtcywgbmVzdCB0aGUgdGVtcGxhdGUgaW5zaWRlIHRoZSBgPGtlbmRvLW1lbnU+YCBjb21wb25lbnQuXG4gKlxuICogVGhlIGF2YWlsYWJsZSBmaWVsZHMgaW4gdGhlIHRlbXBsYXRlIGNvbnRleHQgYXJlOlxuICogLSBgaXRlbWAmbWRhc2g7VGhlIGl0ZW0gZGF0YS5cbiAqIC0gYGluZGV4YCZtZGFzaDtUaGUgaXRlbSBpbmRleC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgPGtlbmRvLW1lbnU+XG4gKiAgICAgICAgICA8a2VuZG8tbWVudS1pdGVtIHRleHQ9XCJpdGVtMlwiPlxuICogICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb01lbnVJdGVtVGVtcGxhdGUgbGV0LWl0ZW09XCJpdGVtXCIgbGV0LWluZGV4PVwiaW5kZXhcIj5cbiAqICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cInBhZGRpbmc6IDEwcHg7XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICBNeSBUZW1wbGF0ZSBmb3I6IHt7IGl0ZW0udGV4dCB9fSBhdCBpbmRleDoge3sgaW5kZXggfX1cbiAqICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgIDwva2VuZG8tbWVudS1pdGVtPlxuICogICAgICAgIDwva2VuZG8tbWVudT5cbiAqICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgSXRlbVRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgSXRlbVRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvTWVudUl0ZW1UZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIEl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRlbXBsYXRlIGZvciB0aGUgbGlua3Mgb2YgdGhlIE1lbnUgaXRlbXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0ZW1wbGF0ZXNfbWVudSAlfSkpLiBUbyBkZWZpbmUgYSB0ZW1wbGF0ZVxuICogZm9yIGFuIGl0ZW0sIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9NZW51SXRlbUxpbmtUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSBhIGA8a2VuZG8tbWVudS1pdGVtPmBcbiAqIGNvbXBvbmVudC4gVG8gZGVmaW5lIGEgdGVtcGxhdGUgZm9yIGFsbCBNZW51IGl0ZW1zLCBuZXN0IHRoZSB0ZW1wbGF0ZSBpbnNpZGUgdGhlIGA8a2VuZG8tbWVudT5gIGNvbXBvbmVudC5cbiAqXG4gKiBUaGUgYXZhaWxhYmxlIGZpZWxkcyBpbiB0aGUgdGVtcGxhdGUgY29udGV4dCBhcmU6XG4gKiAtIGBpdGVtYCZtZGFzaDtUaGUgaXRlbSBkYXRhLlxuICogLSBgaW5kZXhgJm1kYXNoO1RoZSBpdGVtIGluZGV4LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tbWVudT5cbiAqICAgICAgICAgIDxrZW5kby1tZW51LWl0ZW0gdGV4dD1cIml0ZW0yXCI+XG4gKiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvTWVudUl0ZW1MaW5rVGVtcGxhdGUgbGV0LWl0ZW09XCJpdGVtXCIgbGV0LWluZGV4PVwiaW5kZXhcIj5cbiAqICAgICAgICAgICAgICAgICAgPHNwYW4gW2tlbmRvTWVudUl0ZW1MaW5rXT1cImluZGV4XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICB7eyBpdGVtLnRleHQgfX1cbiAqICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiaXRlbS5pdGVtcyAmJiBpdGVtLml0ZW1zLmxlbmd0aFwiIFtrZW5kb01lbnVFeHBhbmRBcnJvd109XCJpbmRleFwiPjwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICogICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8L2tlbmRvLW1lbnUtaXRlbT5cbiAqICAgICAgICA8L2tlbmRvLW1lbnU+XG4gKiAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IEl0ZW1MaW5rVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBJdGVtTGlua1RlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkl0ZW1MaW5rVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb01lbnVJdGVtTGlua1RlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgSXRlbUxpbmtUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRlbXBsYXRlIGZvciB0aGUgY29udGVudCBvZiB0aGUgTWVudSBpdGVtcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRlbXBsYXRlc19tZW51ICV9KSkuIFRvIGRlZmluZSB0aGUgdGVtcGxhdGUsXG4gKiBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvTWVudUl0ZW1Db250ZW50VGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYSBgPGtlbmRvLW1lbnUtaXRlbT5gIGNvbXBvbmVudC5cbiAqXG4gKiBUaGUgYXZhaWxhYmxlIGZpZWxkcyBpbiB0aGUgdGVtcGxhdGUgY29udGV4dCBhcmU6XG4gKiAtIGBpdGVtYCZtZGFzaDtUaGUgaXRlbSBkYXRhLlxuICogLSBgaW5kZXhgJm1kYXNoO1RoZSBpdGVtIGluZGV4LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tbWVudT5cbiAqICAgICAgICAgIDxrZW5kby1tZW51LWl0ZW0gdGV4dD1cIml0ZW0yXCI+XG4gKiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvTWVudUl0ZW1Db250ZW50VGVtcGxhdGUgbGV0LWl0ZW09XCJpdGVtXCIgbGV0LWluZGV4PVwiaW5kZXhcIj5cbiAqICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cInBhZGRpbmc6IDEwcHg7XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICBNeSBDb250ZW50IFRlbXBsYXRlIGZvcjoge3sgaXRlbS50ZXh0IH19IGF0IGluZGV4OiB7eyBpbmRleCB9fVxuICogICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgPC9rZW5kby1tZW51LWl0ZW0+XG4gKiAgICAgICAgPC9rZW5kby1tZW51PlxuICogICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogfVxuICogYGBgXG4gKi9cbmxldCBJdGVtQ29udGVudFRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgSXRlbUNvbnRlbnRUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5JdGVtQ29udGVudFRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIEl0ZW1Db250ZW50VGVtcGxhdGVEaXJlY3RpdmUpO1xuXG52YXIgTWVudUl0ZW1Db21wb25lbnRfMTtcbi8qKlxuICogQSBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBNZW51IGl0ZW1zXG4gKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzXSh7JSBzbHVnIGl0ZW1zX21lbnUgJX0pKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgPGtlbmRvLW1lbnU+XG4gKiAgICAgICAgICA8a2VuZG8tbWVudS1pdGVtIHRleHQ9XCJpdGVtMVwiPlxuICogICAgICAgICAgICAgIDxrZW5kby1tZW51LWl0ZW0gdGV4dD1cIml0ZW0xLjFcIiB1cmw9XCJodHRwczovL2V4YW1wbGUuY29tXCI+XG4gKiAgICAgICAgICAgICAgPC9rZW5kby1tZW51LWl0ZW0+XG4gKiAgICAgICAgICAgICAgPGtlbmRvLW1lbnUtaXRlbSB0ZXh0PVwiaXRlbTEuMlwiIFtkaXNhYmxlZF09XCJ0cnVlXCI+XG4gKiAgICAgICAgICAgICAgPC9rZW5kby1tZW51LWl0ZW0+XG4gKiAgICAgICAgICA8L2tlbmRvLW1lbnUtaXRlbT5cbiAqICAgICAgICAgIDxrZW5kby1tZW51LWl0ZW0gdGV4dD1cIml0ZW0yXCI+XG4gKiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvTWVudUl0ZW1Db250ZW50VGVtcGxhdGUgbGV0LWl0ZW09XCJpdGVtXCI+XG4gKiAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJwYWRkaW5nOiAxMHB4O1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgTXkgQ29udGVudCBUZW1wbGF0ZToge3sgaXRlbS50ZXh0IH19XG4gKiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvTWVudUl0ZW1UZW1wbGF0ZSBsZXQtaXRlbT1cIml0ZW1cIj5cbiAqICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cInBhZGRpbmc6IDEwcHg7XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICBNeSBUZW1wbGF0ZToge3sgaXRlbS50ZXh0IH19XG4gKiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8L2tlbmRvLW1lbnUtaXRlbT5cbiAqICAgICAgICAgIDxrZW5kby1tZW51LWl0ZW0gdGV4dD1cIml0ZW0zXCI+XG4gKiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvTWVudUl0ZW1MaW5rVGVtcGxhdGUgbGV0LWl0ZW09XCJpdGVtXCIgbGV0LWluZGV4PVwiaW5kZXhcIj5cbiAqICAgICAgICAgICAgICAgICAgPHNwYW4gW2tlbmRvTWVudUl0ZW1MaW5rXT1cImluZGV4XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICB7eyBpdGVtLnRleHQgfX1cbiAqICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiaXRlbS5pdGVtcyAmJiBpdGVtLml0ZW1zLmxlbmd0aFwiIFtrZW5kb01lbnVFeHBhbmRBcnJvd109XCJpbmRleFwiPjwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICogICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICA8L2tlbmRvLW1lbnUtaXRlbT5cbiAqICAgICAgICA8L2tlbmRvLW1lbnU+XG4gKiAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IE1lbnVJdGVtQ29tcG9uZW50ID0gTWVudUl0ZW1Db21wb25lbnRfMSA9IGNsYXNzIE1lbnVJdGVtQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5pdGVtVGVtcGxhdGUgJiYgdGhpcy5pdGVtVGVtcGxhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtVGVtcGxhdGUuZmlyc3QudGVtcGxhdGVSZWY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBsaW5rVGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1MaW5rVGVtcGxhdGUgJiYgdGhpcy5pdGVtTGlua1RlbXBsYXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbUxpbmtUZW1wbGF0ZS5maXJzdC50ZW1wbGF0ZVJlZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbnRlbnRUZW1wbGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbUNvbnRlbnRUZW1wbGF0ZSAmJiB0aGlzLml0ZW1Db250ZW50VGVtcGxhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtQ29udGVudFRlbXBsYXRlLmZpcnN0LnRlbXBsYXRlUmVmO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4udG9BcnJheSgpLmZpbHRlcihjID0+IGMgIT09IHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lbnVJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZW51SXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwidXJsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBNZW51SXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY3NzQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE1lbnVJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjc3NTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE1lbnVJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInNlcGFyYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKEl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIE1lbnVJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihJdGVtTGlua1RlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1MaW5rVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihJdGVtQ29udGVudFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1Db250ZW50VGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihNZW51SXRlbUNvbXBvbmVudF8xKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHZvaWQgMCk7XG5NZW51SXRlbUNvbXBvbmVudCA9IE1lbnVJdGVtQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLW1lbnUtaXRlbScsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pXG5dLCBNZW51SXRlbUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBNZW51QmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIE1lbnUgd2lsbCBiZSB2ZXJ0aWNhbCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHZlcnRpY2FsX21lbnUgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVydGljYWwgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IHRoZSByb290IGl0ZW1zIGNhbiBiZSBvcGVuZWQgb25seSBvbiBjbGlja1xuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG9wZW5jbG9zZV9tZW51ICV9I3RvYy1vcGVuaW5nLW9uLWNsaWNrKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW5PbkNsaWNrID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIE1lbnUgaXRlbXMgYXJlIG9wZW5lZCBvciBjbG9zZWQgb24gaXRlbSBob3ZlclxuICAgICAgICAgKiBvciBsZWF2ZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG9wZW5jbG9zZV9tZW51ICV9I3RvYy1kZWxheS1vbi1ob3ZlcikpLiBVc2VkIHRvIGF2b2lkIHRoZSBhY2NpZGVudGFsXG4gICAgICAgICAqIG9wZW5pbmcgb3IgY2xvc2luZyBvZiB0aGUgaXRlbXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvdmVyRGVsYXkgPSAxMDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBNZW51IGFuaW1hdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcyB8fCAodGhpcy5jaGlsZHJlbiA/IHRoaXMuY2hpbGRyZW4udG9BcnJheSgpIDogW10pO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgTWVudUJhc2UucHJvdG90eXBlLCBcIml0ZW1zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTWVudUJhc2UucHJvdG90eXBlLCBcInZlcnRpY2FsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBNZW51QmFzZS5wcm90b3R5cGUsIFwib3Blbk9uQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE1lbnVCYXNlLnByb3RvdHlwZSwgXCJob3ZlckRlbGF5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBNZW51QmFzZS5wcm90b3R5cGUsIFwiYW5pbWF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKEl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIE1lbnVCYXNlLnByb3RvdHlwZSwgXCJpdGVtVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihJdGVtTGlua1RlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgTWVudUJhc2UucHJvdG90eXBlLCBcIml0ZW1MaW5rVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihNZW51SXRlbUNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIE1lbnVCYXNlLnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuXG52YXIgTWVudUNvbXBvbmVudF8xO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgTWVudSBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfbWVudSAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1tZW51IFtpdGVtc109XCJpdGVtc1wiPlxuICogICAgICAgIDwva2VuZG8tbWVudT5cbiAqICAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgcHVibGljIGl0ZW1zOiBhbnlbXSA9IFt7IHRleHQ6ICdpdGVtMScsIGl0ZW1zOiBbeyB0ZXh0OiAnaXRlbTEuMScgfV0gfSwgeyB0ZXh0OiAnaXRlbTInLCBkaXNhYmxlZDogdHJ1ZSB9XTtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgTWVudUNvbXBvbmVudCA9IE1lbnVDb21wb25lbnRfMSA9IGNsYXNzIE1lbnVDb21wb25lbnQgZXh0ZW5kcyBNZW51QmFzZSB7XG4gICAgY29uc3RydWN0b3IoaXRlbXNTZXJ2aWNlLCBob3ZlciwgYWN0aW9ucywgbmF2aWdhdGlvbiwgbG9jYWxpemF0aW9uLCBuZ1pvbmUsIHJlbmRlcmVyLCBjb250ZXh0U2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLml0ZW1zU2VydmljZSA9IGl0ZW1zU2VydmljZTtcbiAgICAgICAgdGhpcy5ob3ZlciA9IGhvdmVyO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBhY3Rpb25zO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0U2VydmljZSA9IGNvbnRleHRTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhIE1lbnUgaXRlbSBpcyBzZWxlY3RlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJvdXRpbmdfbWVudSAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIGEgTWVudSBpdGVtIGlzIG9wZW5lZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYSBNZW51IGl0ZW0gaXMgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgICAgIHRoaXMuYWN0aW9ucy5vd25lciA9IHRoaXM7XG4gICAgICAgIGlmIChjb250ZXh0U2VydmljZSkge1xuICAgICAgICAgICAgY29udGV4dFNlcnZpY2UuaXRlbXMgPSB0aGlzLml0ZW1zU2VydmljZTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dEtleURvd25TdWJzY3JpcHRpb24gPSBjb250ZXh0U2VydmljZS5rZXlkb3duLnN1YnNjcmliZSh0aGlzLmNvbnRleHRLZXlEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgYXJpYU9yaWVudGF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgcmV0dXJuICd2ZXJ0aWNhbCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBjb250ZXh0TWVudUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmNvbnRleHRTZXJ2aWNlKTtcbiAgICB9XG4gICAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnRsO1xuICAgIH1cbiAgICBnZXQgcnRsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24ucnRsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBvciBjbG9zZXMgdGhlIHNwZWNpZmllZCBNZW51IGl0ZW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wZW4gLSBBIEJvb2xlYW4gdmFsdWUgd2hpY2ggaW5kaWNhdGVzIGlmIHRoZSBpdGVtcyB3aWxsIGJlIG9wZW5lZCBvciBjbG9zZWQuXG4gICAgICogQHBhcmFtIGluZGljZXMgLSBPbmUgb3IgbW9yZSB2YWx1ZXMgd2hpY2ggcmVwcmVzZW50IHRoZSBoaWVyYXJjaGljYWwgaW5kaWNlcyBvZiB0aGUgaXRlbXMgdGhhdCB3aWxsIGJlIG9wZW5lZCBvciBjbG9zZWQuXG4gICAgICovXG4gICAgdG9nZ2xlKG9wZW4sIC4uLmluZGljZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgaW5kaWNlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtc1NlcnZpY2UuZ2V0KGluZGljZXNbaWR4XSk7XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiAhaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ub3BlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZm9jdXMoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLmZvY3VzSW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi52ZXJ0aWNhbCA9IHRoaXMudmVydGljYWw7XG4gICAgICAgIHRoaXMuaG92ZXIuZGVsYXkgPSB0aGlzLmhvdmVyRGVsYXk7XG4gICAgICAgIGlmIChjaGFuZ2VzLm9wZW5PbkNsaWNrKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVuT25DbGljayA9IHRoaXMub3Blbk9uQ2xpY2sgPSBub3JtYWxpemUodGhpcy5vcGVuT25DbGljayk7XG4gICAgICAgICAgICB0aGlzLmhvdmVyLm9wZW5Pbk92ZXIgPSAhb3Blbk9uQ2xpY2s7XG4gICAgICAgICAgICBpZiAob3Blbk9uQ2xpY2sgJiYgb3Blbk9uQ2xpY2sudG9nZ2xlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hDbG9zZUNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi51cGRhdGVBY3RpdmUoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDbGljaygpO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0U2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0U2VydmljZS5pdGVtcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRLZXlEb3duU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoQ2xvc2VDbGljaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NlQ2xpY2tTdWJzY3JpcHRpb24gJiYgaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUNsaWNrU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbk1lbnUoZS50YXJnZXQsIHRoaXMuaXRlbXNTZXJ2aWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3Zlci5vcGVuT25PdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMuY2xvc2VBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5leGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlQ2xpY2tTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDbGlja1N1YnNjcmlwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnRleHRLZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLml0ZW1zU2VydmljZS5oYXNJdGVtcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgIGNvbnN0IHJ0bCA9IHRoaXMubG9jYWxpemF0aW9uLnJ0bDtcbiAgICAgICAgY29uc3QgZmlyc3QgPSBrZXlDb2RlID09PSBLZXlzLkFycm93RG93biB8fCBrZXlDb2RlID09PSBLZXlzLkFycm93UmlnaHQ7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBrZXlDb2RlID09PSBLZXlzLkFycm93VXAgfHwga2V5Q29kZSA9PT0gS2V5cy5BcnJvd0xlZnQ7XG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgaWYgKChmaXJzdCAmJiAhcnRsKSB8fCAobGFzdCAmJiBydGwpKSB7XG4gICAgICAgICAgICBpbmRleCA9ICdmaXJzdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGZpcnN0ICYmIHJ0bCkgfHwgKGxhc3QgJiYgIXJ0bCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gJ2xhc3QnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5mb2N1cyhpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtZW51SXRlbVRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIE1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcIm1lbnVJdGVtTGlua1RlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3BlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImNsb3NlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1ydGwnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlyZWN0aW9uXCIsIG51bGwpO1xuTWVudUNvbXBvbmVudCA9IE1lbnVDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9NZW51JyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBJdGVtc1NlcnZpY2UsXG4gICAgICAgICAgICBBY3Rpb25zU2VydmljZSxcbiAgICAgICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgSG92ZXJTZXJ2aWNlLFxuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLm1lbnUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1lbnVCYXNlLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1lbnVDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1tZW51JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHVsIHJvbGU9XCJtZW51YmFyXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtb3JpZW50YXRpb25dPVwiYXJpYU9yaWVudGF0aW9uXCJcbiAgICAgICAgICAgIGtlbmRvTWVudUxpc3QgW2l0ZW1zXT1cInJvb3RJdGVtc1wiIFtsZXZlbF09XCIwXCIgY2xhc3M9XCJrLXdpZGdldCBrLXJlc2V0IGstaGVhZGVyIGstbWVudVwiXG4gICAgICAgICAgICBbdmVydGljYWxdPVwidmVydGljYWxcIiBbcnRsXT1cInJ0bFwiIFthbmltYXRlXT1cImFuaW1hdGVcIiBbb3Blbk9uQ2xpY2tdPVwib3Blbk9uQ2xpY2tcIlxuICAgICAgICAgICAgW2l0ZW1UZW1wbGF0ZV09XCJpdGVtVGVtcGxhdGUuZmlyc3Q/LnRlbXBsYXRlUmVmIHx8IG1lbnVJdGVtVGVtcGxhdGVcIlxuICAgICAgICAgICAgW2l0ZW1MaW5rVGVtcGxhdGVdPVwiaXRlbUxpbmtUZW1wbGF0ZS5maXJzdD8udGVtcGxhdGVSZWYgfHwgbWVudUl0ZW1MaW5rVGVtcGxhdGVcIlxuICAgICAgICAgICAgW2NsYXNzLmstbWVudS1ob3Jpem9udGFsXT1cIiF2ZXJ0aWNhbFwiXG4gICAgICAgICAgICBbY2xhc3Muay1tZW51LXZlcnRpY2FsXT1cInZlcnRpY2FsXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLWNvbnRleHQtbWVudV09XCJjb250ZXh0TWVudUNsYXNzXCI+XG4gICAgICAgIDwvdWw+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oNywgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtJdGVtc1NlcnZpY2UsXG4gICAgICAgIEhvdmVyU2VydmljZSxcbiAgICAgICAgQWN0aW9uc1NlcnZpY2UsXG4gICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgQ29udGV4dE1lbnVTZXJ2aWNlXSlcbl0sIE1lbnVDb21wb25lbnQpO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpjb21wb25lbnQtc2VsZWN0b3IgKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTGlzdENvbXBvbmVudCA9IGNsYXNzIExpc3RDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGl0ZW1zU2VydmljZSwgaG92ZXIsIGFjdGlvbnMsIG5hdmlnYXRpb24sIHJlbmRlcmVyLCBuZ1pvbmUsIGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5pdGVtc1NlcnZpY2UgPSBpdGVtc1NlcnZpY2U7XG4gICAgICAgIHRoaXMuaG92ZXIgPSBob3ZlcjtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gYWN0aW9ucztcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gbmF2aWdhdGlvbjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5hbmltYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaGllcmFyY2h5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNTZXJ2aWNlLml0ZW1JbmRleCh0aGlzLmluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLml0ZW1zU2VydmljZS5hZGRMaXN0KHRoaXMpO1xuICAgICAgICB0aGlzLmluaXREb21FdmVudHMoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaXRlbXNTZXJ2aWNlLnJlbW92ZUxpc3QodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmRvbVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXREb21FdmVudHMoKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpIHx8ICF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmxldmVsID4gMCA/IGNsb3Nlc3QoZWxlbWVudCwgKG5vZGUpID0+IGhhc0NsYXNzKG5vZGUsICdrLXBvcHVwJykpIDogZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJTdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnbW91c2VvdmVyJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVsZW1lbnQgJiYgdGhpcy5sZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTGVhdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm5vZGVJdGVtKGUudGFyZ2V0KSB8fCB0aGlzLml0ZW1zU2VydmljZS5nZXQodGhpcy5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtICYmICEodGhpcy5vcGVuT25DbGljayAmJiB0aGlzLm9wZW5PbkNsaWNrLnRvZ2dsZSA9PT0gJ2NsaWNrJyAmJiBpdGVtLmxldmVsID09PSAwICYmICFpdGVtLmhhc0NvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdmVyLm92ZXIoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxlYXZlU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oY29udGFpbmVyLCAnbW91c2VsZWF2ZScsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzTWVudShlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTGVhdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGtleWRvd25TdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKGUudGFyZ2V0LCAnay1tZW51LWl0ZW0nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb24ua2V5ZG93bihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGJsdXJTdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnZm9jdXNvdXQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlc01lbnUoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLmZvY3VzTGVhdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSGFuZGxlIGZvY3VzL2JsdXIgb3Blbi9jbG9zZSBmb3IgaU9TIGRldmljZXMgc2luY2UgaXQgYmVoYXZlcyBpbmNvbnNpc3RlbnRseSB3aXRoIHRoZSByZXN0XG4gICAgICAgICAgICAgKiBSZWZlciB0bzogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0FwcGxlQXBwbGljYXRpb25zL1JlZmVyZW5jZS9TYWZhcmlXZWJDb250ZW50L0hhbmRsaW5nRXZlbnRzL0hhbmRsaW5nRXZlbnRzLmh0bWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgdG91Y2hTdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbihkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbk1lbnUoZS50YXJnZXQsIHRoaXMuaXRlbXNTZXJ2aWNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5ub2RlSXRlbShlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5lZWRzIHRvIGJlIGNhbGxlZCBiZWNhdXNlIHRoZSAnY2xpY2snIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgb25seSBvbiBzZWNvbmRhcnkgdGFwIGFuZCB0aGUgaXRlbSB3aWxsIHJlbWFpbiB1bmZvY3VzZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLmZvY3VzKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBzaW5jZSB0aGUgJ21vdXNlb3ZlcicgZXZlbnQgaXMgbm90IGFsd2F5cyBkaXNwYXRjaGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5vcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaG92ZXIub3ZlcihpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm5hdmlnYXRpb24uZm9jdXNlZElkeCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdG91Y2ggaXMgb3V0c2lkZSBvZiB0aGUgbWVudSBhbmQgdGhlIG1lbnUgaXMgbm90IGN1cnJlbnRseSBpbiBmb2N1c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVJdGVtID0gdGhpcy5pdGVtc1NlcnZpY2UuZ2V0KHRoaXMubmF2aWdhdGlvbi5hY3RpdmVJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25MZWF2ZSgpOyAvLyBuZWVkcyB0byBiZSBjYWxsZWQgZXhwbGljaXRseSBzaW5jZSBtb3VzZWxlYXZlIGV2ZW50IGlzIG5vdCB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlSXRlbS5ibHVyKCk7IC8vIG5lZWRzIHRvIGJlIGNhbGxlZCBleHBsaWNpdGx5IG90aGVyd2lzZSB0aGUgaXRlbSByZW1haW5zIGZvY3VzZWQgPT4gdHJpZ2dlcnMgZm9jdXNvdXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWNrU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmRvbVN1YnNjcmlwdGlvbnMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgb3ZlclN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIGxlYXZlU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAga2V5ZG93blN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIGJsdXJTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBjbGlja1N1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIHRvdWNoU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmVzTWVudShlKSB7XG4gICAgICAgIGlmICghZS5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWluTWVudShlLnJlbGF0ZWRUYXJnZXQsIHRoaXMuaXRlbXNTZXJ2aWNlKTtcbiAgICB9XG4gICAgb25MZWF2ZSgpIHtcbiAgICAgICAgY29uc3Qgb3Blbk9uQ2xpY2sgPSB0aGlzLm9wZW5PbkNsaWNrO1xuICAgICAgICBpZiAoIW9wZW5PbkNsaWNrIHx8IG9wZW5PbkNsaWNrLnRvZ2dsZSAhPT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgdGhpcy5ob3Zlci5sZWF2ZShvcGVuT25DbGljayAmJiBvcGVuT25DbGljay50b2dnbGUgPT09ICdsZWF2ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vZGVJdGVtKHRhcmdldCkge1xuICAgICAgICBjb25zdCBub2RlID0gY2xvc2VzdEl0ZW0odGFyZ2V0LCB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG5vZGVJbmRleChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zU2VydmljZS5nZXQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgICAgIGlmIChpc0ZvY3VzYWJsZShlLnRhcmdldCkgJiYgIWhhc0NsYXNzKGUudGFyZ2V0LCAnay1tZW51LWl0ZW0nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm5vZGVJdGVtKGUudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFpdGVtIHx8IGl0ZW0uaXNDb250ZW50IHx8IGl0ZW0ubmF2aWdhdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zLnNlbGVjdChpdGVtLCBlLCAoKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24uZm9jdXMoaXRlbSk7XG4gICAgICAgIGlmIChpdGVtLmxldmVsID4gMCAmJiAhaXRlbS5oYXNDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuY2xvc2VUb1Jvb3QoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3Blbk9uQ2xpY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyID0gdGhpcy5ob3ZlcjtcbiAgICAgICAgICAgIGlmIChpdGVtLm9wZW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmxldmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvdmVyLm9wZW5Pbk92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmNsb3NlKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uaGFzQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGhvdmVyLm9wZW5Pbk92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5jbG9zZU90aGVycyhpdGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMub3BlbihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhvdmVyLm9wZW5Pbk92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5sZXZlbCA9PT0gMCAmJiB0aGlzLm9wZW5PbkNsaWNrLnRvZ2dsZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdmVyLmNsb3NlQ3VycmVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMuZXhlY3V0ZSgpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZXZlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInJ0bFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwib3Blbk9uQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbVRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIExpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1MaW5rVGVtcGxhdGVcIiwgdm9pZCAwKTtcbkxpc3RDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb01lbnVMaXN0XScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXM7IGxldCBpZHggPSBpbmRleFwiPlxuICAgICAgICAgICAgPGxpICpuZ0lmPVwiIWl0ZW0uc2VwYXJhdG9yXCIga2VuZG9NZW51SXRlbVxuICAgICAgICAgICAgICAgIFtpdGVtXT1cIml0ZW1cIiBbbGV2ZWxdPVwibGV2ZWxcIiBbdmVydGljYWxdPVwidmVydGljYWxcIiBbYW5pbWF0ZV09XCJhbmltYXRlXCIgW3J0bF09XCJydGxcIlxuICAgICAgICAgICAgICAgIFtpdGVtVGVtcGxhdGVdPVwiaXRlbVRlbXBsYXRlXCIgW2l0ZW1MaW5rVGVtcGxhdGVdPVwiaXRlbUxpbmtUZW1wbGF0ZVwiIFtvcGVuT25DbGlja109XCJvcGVuT25DbGlja1wiXG4gICAgICAgICAgICAgICAgW2luZGV4XT1cImhpZXJhcmNoeUluZGV4KGlkeClcIiBbc2libGluZ0luZGV4XT1cImlkeFwiIFthdHRyLiR7Tk9ERV9JTkRFWH1dPVwiaGllcmFyY2h5SW5kZXgoaWR4KVwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiaXRlbS5jc3NDbGFzc1wiIFtuZ1N0eWxlXT1cIml0ZW0uY3NzU3R5bGVcIlxuICAgICAgICAgICAgICAgIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWl0ZW0gay1tZW51LWl0ZW1cIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLWZpcnN0XT1cImlkeCA9PT0gMFwiIFtjbGFzcy5rLWxhc3RdPVwiaWR4ID09PSBpdGVtcy5sZW5ndGggLSAxXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGF0ZS1kaXNhYmxlZF09XCJpdGVtLmRpc2FibGVkXCI+PC9saT5cbiAgICAgICAgICAgIDxsaSAqbmdJZj1cIml0ZW0uc2VwYXJhdG9yXCIgY2xhc3M9XCJrLXNlcGFyYXRvciBrLWl0ZW1cIlxuICAgICAgICAgICAgICAgIHJvbGU9XCJzZXBhcmF0b3JcIiBbbmdDbGFzc109XCJpdGVtLmNzc0NsYXNzXCIgW25nU3R5bGVdPVwiaXRlbS5jc3NTdHlsZVwiPlxuICAgICAgICAgICAgICAgICZuYnNwO1xuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSXRlbXNTZXJ2aWNlLFxuICAgICAgICBIb3ZlclNlcnZpY2UsXG4gICAgICAgIEFjdGlvbnNTZXJ2aWNlLFxuICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIEVsZW1lbnRSZWZdKVxuXSwgTGlzdENvbXBvbmVudCk7XG5cbmNvbnN0IFBPUFVQX0FMSUdOID0ge1xuICAgIHZlcnRpY2FsOiAndG9wJyxcbiAgICBob3Jpem9udGFsOiAnbGVmdCdcbn07XG5jb25zdCBQT1BVUF9BTElHTl9SVEwgPSB7XG4gICAgdmVydGljYWw6ICd0b3AnLFxuICAgIGhvcml6b250YWw6ICdyaWdodCdcbn07XG5jb25zdCBWRVJUSUNBTF9DT0xMSVNJT04gPSB7XG4gICAgdmVydGljYWw6ICdmbGlwJyxcbiAgICBob3Jpem9udGFsOiAnZml0J1xufTtcbmNvbnN0IEhPUklaT05UQUxfQ09MTElTSU9OID0ge1xuICAgIHZlcnRpY2FsOiAnZml0JyxcbiAgICBob3Jpem9udGFsOiAnZmxpcCdcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUE9QVVBfU0VUVElOR1NfUlRMID0ge1xuICAgIHZlcnRpY2FsOiB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgdmVydGljYWw6ICdib3R0b20nLFxuICAgICAgICAgICAgaG9yaXpvbnRhbDogJ3JpZ2h0J1xuICAgICAgICB9LFxuICAgICAgICBwb3B1cDogUE9QVVBfQUxJR05fUlRMLFxuICAgICAgICBjb2xsaXNpb246IFZFUlRJQ0FMX0NPTExJU0lPTixcbiAgICAgICAgYW5pbWF0ZTogJ2Rvd24nXG4gICAgfSxcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgdmVydGljYWw6ICd0b3AnLFxuICAgICAgICAgICAgaG9yaXpvbnRhbDogJ2xlZnQnXG4gICAgICAgIH0sXG4gICAgICAgIHBvcHVwOiBQT1BVUF9BTElHTl9SVEwsXG4gICAgICAgIGNvbGxpc2lvbjogSE9SSVpPTlRBTF9DT0xMSVNJT04sXG4gICAgICAgIGFuaW1hdGU6ICdsZWZ0J1xuICAgIH1cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUE9QVVBfU0VUVElOR1MgPSB7XG4gICAgdmVydGljYWw6IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICB2ZXJ0aWNhbDogJ2JvdHRvbScsXG4gICAgICAgICAgICBob3Jpem9udGFsOiAnbGVmdCdcbiAgICAgICAgfSxcbiAgICAgICAgcG9wdXA6IFBPUFVQX0FMSUdOLFxuICAgICAgICBjb2xsaXNpb246IFZFUlRJQ0FMX0NPTExJU0lPTixcbiAgICAgICAgYW5pbWF0ZTogJ2Rvd24nXG4gICAgfSxcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgdmVydGljYWw6ICd0b3AnLFxuICAgICAgICAgICAgaG9yaXpvbnRhbDogJ3JpZ2h0J1xuICAgICAgICB9LFxuICAgICAgICBwb3B1cDogUE9QVVBfQUxJR04sXG4gICAgICAgIGNvbGxpc2lvbjogSE9SSVpPTlRBTF9DT0xMSVNJT04sXG4gICAgICAgIGFuaW1hdGU6ICdyaWdodCdcbiAgICB9XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBib2R5RmFjdG9yeSA9ICgpID0+IHtcbiAgICBpZiAoaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudFJlZihkb2N1bWVudC5ib2R5KTtcbiAgICB9XG59O1xuXG5jb25zdCDJtTAkMyA9IGJvZHlGYWN0b3J5O1xuLyogdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LXNlbGVjdG9yICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEl0ZW1Db21wb25lbnQgPSBjbGFzcyBJdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtc1NlcnZpY2UsIG5hdmlnYXRpb24sIGNoYW5nZURldGVjdG9yLCByZW5kZXJlciwgcG9wdXBTZXJ2aWNlLCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaXRlbXNTZXJ2aWNlID0gaXRlbXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UgPSBwb3B1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub3Blbk9uQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgfVxuICAgIHNldCBpbmRleChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5faW5kZXggJiYgdGhpcy5faW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zU2VydmljZS5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5pdGVtc1NlcnZpY2UuYWRkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkSWQgPSB0aGlzLml0ZW1zU2VydmljZS5jaGlsZElkKGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5kaXNhYmxlZDtcbiAgICB9XG4gICAgZ2V0IGhhc1BvcHVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNDb250ZW50ID8gdHJ1ZSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBleHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ29udGVudCA/IHRoaXMub3BlbmVkIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtLnRleHQgPyB0aGlzLml0ZW0udGV4dCA6IG51bGw7XG4gICAgfVxuICAgIGdldCBhY3RpdmVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPT09IHRoaXMubmF2aWdhdGlvbi5hY3RpdmVJbmRleCA/ICcwJyA6ICctMSc7XG4gICAgfVxuICAgIGdldCBwb3B1cFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMucnRsID8gUE9QVVBfU0VUVElOR1NfUlRMIDogUE9QVVBfU0VUVElOR1M7XG4gICAgICAgIHJldHVybiB0aGlzLmhvcml6b250YWwgPyBzZXR0aW5ncy5ob3Jpem9udGFsIDogc2V0dGluZ3MudmVydGljYWw7XG4gICAgfVxuICAgIGdldCBob3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbCB8fCB0aGlzLmxldmVsID4gMDtcbiAgICB9XG4gICAgZ2V0IGhhc0xpbmsoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaXRlbS51cmwpO1xuICAgIH1cbiAgICBnZXQgbGlua1RlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtLmxpbmtUZW1wbGF0ZSB8fCB0aGlzLml0ZW1MaW5rVGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBoYXNDb250ZW50KCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbS5pdGVtcztcbiAgICAgICAgcmV0dXJuIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCB8fCB0aGlzLml0ZW0uY29udGVudFRlbXBsYXRlO1xuICAgIH1cbiAgICBnZXQgaXNDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLml0ZW0uY29udGVudCk7XG4gICAgfVxuICAgIGdldCBpY29uQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiBgay1pLSR7dGhpcy5pdGVtLmljb259YDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtO1xuICAgICAgICBpZiAoaXRlbS5jb250ZW50VGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50SXRlbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRJdGVtcyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBpdGVtLmNvbnRlbnRUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJJbmRleDogdGhpcy5pbmRleFxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRJdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS5pdGVtcztcbiAgICB9XG4gICAgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtLnRlbXBsYXRlIHx8IHRoaXMuaXRlbVRlbXBsYXRlO1xuICAgIH1cbiAgICBoYXNDb250ZW50VGVtcGxhdGVzKCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtO1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtVGVtcGxhdGUgfHwgaXRlbS5jb250ZW50VGVtcGxhdGUgfHwgdGhpcy5pdGVtTGlua1RlbXBsYXRlIHx8XG4gICAgICAgICAgICAoaXRlbS5pdGVtcyAmJiBpdGVtLml0ZW1zLmZpbmQoY3VycmVudCA9PiBjdXJyZW50LnRlbXBsYXRlIHx8IGN1cnJlbnQubGlua1RlbXBsYXRlKSk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLml0ZW1zU2VydmljZS5hZGQodGhpcyk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLml0ZW1zU2VydmljZS5yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICBibHVyKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICAgIHRvZ2dsZUFjdGl2ZShpc0FjdGl2ZSkge1xuICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcGVuKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVzdHJveWVkICYmIHRoaXMuaGFzQ29udGVudCAmJiAhdGhpcy5vcGVuZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcHVwU2V0dGluZ3MgPSB0aGlzLnBvcHVwU2V0dGluZ3M7XG4gICAgICAgICAgICBjb25zdCBhbmltYXRlID0gdGhpcy5hbmltYXRlID8gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5hbmltYXRlLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBwb3B1cFNldHRpbmdzLmFuaW1hdGVcbiAgICAgICAgICAgIH0pIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICAgICAgICAgICAgcG9wdXBBbGlnbjogcG9wdXBTZXR0aW5ncy5wb3B1cCxcbiAgICAgICAgICAgICAgICBhbmNob3JBbGlnbjogcG9wdXBTZXR0aW5ncy5hbmNob3IsXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uOiBwb3B1cFNldHRpbmdzLmNvbGxpc2lvbixcbiAgICAgICAgICAgICAgICBhbmNob3I6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk1vZGU6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5wb3B1cFRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHBvcHVwQ2xhc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2stcnRsJzogdGhpcy5ydGwsXG4gICAgICAgICAgICAgICAgICAgICdrLW1lbnUtcG9wdXAnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbmltYXRlOiBhbmltYXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLW93bnMnLCB0aGlzLmNoaWxkSWQpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5vcGVuZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1cFJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnYXJpYS1vd25zJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmF2aWdhdGUoKSB7XG4gICAgICAgIGxldCBsaW5rO1xuICAgICAgICBpZiAodGhpcy5saW5rVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGxpbmsgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhLmstbWVudS1saW5rJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNMaW5rKSB7XG4gICAgICAgICAgICBsaW5rID0gdGhpcy5saW5rLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGluZyA9IHRydWU7XG4gICAgICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgSXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgSXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwibGV2ZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgSXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaWJsaW5nSW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInJ0bFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcIm9wZW5PbkNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1UZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtTGlua1RlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2xpbmsnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsaW5rXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3BvcHVwVGVtcGxhdGUnLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLWRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1oYXNwb3B1cCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYXNQb3B1cFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZXhwYW5kZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgSXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLWxhYmVsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVJZFwiLCBudWxsKTtcbkl0ZW1Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtQb3B1cFNlcnZpY2UsIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBQT1BVUF9DT05UQUlORVIsXG4gICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogybUwJDNcbiAgICAgICAgICAgIH1dLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb01lbnVJdGVtXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHNwYW4gKm5nSWY9XCIhaGFzTGluayAmJiAhaXRlbS5jb250ZW50ICYmICFsaW5rVGVtcGxhdGVcIiBjbGFzcz1cImstbGluayBrLW1lbnUtbGlua1wiICNsaW5rXG4gICAgICAgIFtjbGFzcy5rLXN0YXRlLWFjdGl2ZV09XCJvcGVuZWRcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJpdGVtY29udGVudFwiPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvc3Bhbj5cbiAgICA8YSAqbmdJZj1cIml0ZW0udXJsICYmICFsaW5rVGVtcGxhdGVcIiBjbGFzcz1cImstbGluayBrLW1lbnUtbGlua1wiICNsaW5rIFthdHRyLmhyZWZdPVwiaXRlbS51cmxcIlxuICAgICAgICBbY2xhc3Muay1zdGF0ZS1hY3RpdmVdPVwib3BlbmVkXCIgdGFiaW5kZXg9XCItMVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIml0ZW1jb250ZW50XCI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9hPlxuICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImxpbmtUZW1wbGF0ZSAmJiAhaXRlbS5jb250ZW50XCIgW25nVGVtcGxhdGVPdXRsZXRdPVwibGlua1RlbXBsYXRlXCJcbiAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgaXRlbTogaXRlbSwgaW5kZXg6IGluZGV4IH1cIj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cImstY29udGVudFwiICpuZ0lmPVwiaXRlbS5jb250ZW50XCIgcm9sZT1cInByZXNlbnRhdGlvblwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiaXRlbS5jb250ZW50XCIgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgaXRlbTogaXRlbS5vd25lciwgaW5kZXg6IGl0ZW0ub3duZXJJbmRleCB9XCI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG5cbiAgICA8bmctdGVtcGxhdGUgI3BvcHVwVGVtcGxhdGU+XG4gICAgICAgIDx1bCBrZW5kb01lbnVMaXN0XG4gICAgICAgICAgICBbYXR0ci5pZF09XCJjaGlsZElkXCJcbiAgICAgICAgICAgIFthbmltYXRlXT1cImFuaW1hdGVcIlxuICAgICAgICAgICAgW3J0bF09XCJydGxcIlxuICAgICAgICAgICAgW3ZlcnRpY2FsXT1cInZlcnRpY2FsXCJcbiAgICAgICAgICAgIFtvcGVuT25DbGlja109XCJvcGVuT25DbGlja1wiXG4gICAgICAgICAgICBbaXRlbXNdPVwiY2hpbGRyZW5cIlxuICAgICAgICAgICAgW2xldmVsXT1cImxldmVsICsgMVwiXG4gICAgICAgICAgICBbaW5kZXhdPVwiaW5kZXhcIlxuICAgICAgICAgICAgW2l0ZW1UZW1wbGF0ZV09XCJpdGVtVGVtcGxhdGVcIlxuICAgICAgICAgICAgW2l0ZW1MaW5rVGVtcGxhdGVdPVwiaXRlbUxpbmtUZW1wbGF0ZVwiXG4gICAgICAgICAgICByb2xlPVwibWVudVwiXG4gICAgICAgICAgICBjbGFzcz1cImstZ3JvdXAgay1tZW51LWdyb3VwIGstcmVzZXRcIj5cbiAgICAgICAgPC91bD5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlICNpdGVtY29udGVudD5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJpdGVtLmljb25cIiBjbGFzcz1cImstaWNvblwiIFtuZ0NsYXNzXT1cImljb25DbGFzc1wiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L3NwYW4+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhdGVtcGxhdGVcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1tZW51LWxpbmstdGV4dFwiPnt7IGl0ZW0udGV4dCB9fTwvc3Bhbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cInRlbXBsYXRlXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwidGVtcGxhdGVcIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyBpdGVtOiBpdGVtLCBpbmRleDogaW5kZXggfVwiPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImstaWNvbiBrLW1lbnUtZXhwYW5kLWFycm93XCIgKm5nSWY9XCJoYXNDb250ZW50XCJcbiAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAgICAgW2NsYXNzLmstaS1hcnJvdy02MC1kb3duXT1cIiFob3Jpem9udGFsXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLWktYXJyb3ctNjAtcmlnaHRdPVwiaG9yaXpvbnRhbCAmJiAhcnRsXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLWktYXJyb3ctNjAtbGVmdF09XCJob3Jpem9udGFsICYmIHJ0bFwiPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSXRlbXNTZXJ2aWNlLFxuICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgUG9wdXBTZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmXSlcbl0sIEl0ZW1Db21wb25lbnQpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBkaXJlY3RpdmUgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgW2BsaW5rVGVtcGxhdGVgXSh7JSBzbHVnIGFwaV9tZW51X2l0ZW1saW5rdGVtcGxhdGVkaXJlY3RpdmUgJX0pXG4gKiBvZiB0aGUgaXRlbXMgdG8gYXBwbHkgdGhlIGRlZmF1bHQgc3R5bGluZyBhbmQgYmVoYXZpb3IuXG4gKi9cbmxldCBMaW5rRGlyZWN0aXZlID0gY2xhc3MgTGlua0RpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoaXRlbXNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaXRlbXNTZXJ2aWNlID0gaXRlbXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb2xlID0gJ3ByZXNlbnRhdGlvbic7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSAnLTEnO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0ub3BlbmVkO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpICYmICF0aGlzLmluZGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBrZW5kb01lbnVJdGVtTGluayBkaXJlY3RpdmUgcmVxdWlyZXMgdGhlIGl0ZW0gaW5kZXggdG8gYmUgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbSA9IHRoaXMuaXRlbXNTZXJ2aWNlLmdldCh0aGlzLmluZGV4KSB8fCB7fTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2tlbmRvTWVudUl0ZW1MaW5rJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIExpbmtEaXJlY3RpdmUucHJvdG90eXBlLCBcImluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1saW5rJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstbWVudS1saW5rJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBMaW5rRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJob3N0Q2xhc3Nlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMaW5rRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJyb2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMaW5rRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc3RhdGUtYWN0aXZlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIExpbmtEaXJlY3RpdmUucHJvdG90eXBlLCBcImFjdGl2ZUNsYXNzXCIsIG51bGwpO1xuTGlua0RpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvTWVudUl0ZW1MaW5rXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0l0ZW1zU2VydmljZV0pXG5dLCBMaW5rRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGlyZWN0aXZlIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIFtgbGlua1RlbXBsYXRlYF0oeyUgc2x1ZyBhcGlfbWVudV9pdGVtbGlua3RlbXBsYXRlZGlyZWN0aXZlICV9KVxuICogb2YgdGhlIGl0ZW1zIHRvIHJlbmRlciB0aGUgZGVmYXVsdCBleHBhbmQgYXJyb3cuXG4gKi9cbmxldCBFeHBhbmRBcnJvd0RpcmVjdGl2ZSA9IGNsYXNzIEV4cGFuZEFycm93RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtc1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5pdGVtc1NlcnZpY2UgPSBpdGVtc1NlcnZpY2U7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLnJvbGUgPSAncHJlc2VudGF0aW9uJztcbiAgICB9XG4gICAgZ2V0IGFycm93RG93bigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLml0ZW0uaG9yaXpvbnRhbDtcbiAgICB9XG4gICAgZ2V0IGFycm93UmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0uaG9yaXpvbnRhbCAmJiAhdGhpcy5pdGVtLnJ0bDtcbiAgICB9XG4gICAgZ2V0IGFycm93TGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5ob3Jpem9udGFsICYmIHRoaXMuaXRlbS5ydGw7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgIXRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGtlbmRvTWVudUV4cGFuZEFycm93IGRpcmVjdGl2ZSByZXF1aXJlcyB0aGUgaXRlbSBpbmRleCB0byBiZSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtID0gdGhpcy5pdGVtc1NlcnZpY2UuZ2V0KHRoaXMuaW5kZXgpIHx8IHt9O1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgna2VuZG9NZW51RXhwYW5kQXJyb3cnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRXhwYW5kQXJyb3dEaXJlY3RpdmUucHJvdG90eXBlLCBcImluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1pY29uJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstbWVudS1leHBhbmQtYXJyb3cnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEV4cGFuZEFycm93RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJob3N0Q2xhc3Nlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBFeHBhbmRBcnJvd0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwicm9sZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstaS1hcnJvdy02MC1kb3duJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEV4cGFuZEFycm93RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhcnJvd0Rvd25cIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1pLWFycm93LTYwLXJpZ2h0JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEV4cGFuZEFycm93RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhcnJvd1JpZ2h0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstaS1hcnJvdy02MC1sZWZ0JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEV4cGFuZEFycm93RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhcnJvd0xlZnRcIiwgbnVsbCk7XG5FeHBhbmRBcnJvd0RpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvTWVudUV4cGFuZEFycm93XSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0l0ZW1zU2VydmljZV0pXG5dLCBFeHBhbmRBcnJvd0RpcmVjdGl2ZSk7XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHNlbGVjdGAgZXZlbnQgb2YgdGhlIE1lbnUuXG4gKi9cbmNsYXNzIE1lbnVTZWxlY3RFdmVudCBleHRlbmRzIE1lbnVFdmVudCB7XG59XG5cbmNvbnN0IElURU1fRklFTERTID0gWyd0ZXh0RmllbGQnLCAndXJsRmllbGQnLCAnaWNvbkZpZWxkJywgJ2Rpc2FibGVkRmllbGQnLCAnY3NzQ2xhc3NGaWVsZCcsICdjc3NTdHlsZUZpZWxkJywgJ3NlcGFyYXRvckZpZWxkJ107XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQmluZGluZ0RpcmVjdGl2ZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKG1lbnUpIHtcbiAgICAgICAgdGhpcy5tZW51ID0gbWVudTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMucmViaW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZWJpbmRzIHRoZSBNZW51IGl0ZW1zLlxuICAgICAqL1xuICAgIHJlYmluZCgpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgSVRFTV9GSUVMRFMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3QgaW5wdXROYW1lID0gSVRFTV9GSUVMRFNbaWR4XTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSB0aGlzW2lucHV0TmFtZV07XG4gICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKHsgdGFyZ2V0OiBpbnB1dE5hbWUucmVwbGFjZSgnRmllbGQnLCAnJyksIHNvdXJjZTogaW5wdXRWYWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lbnUuaXRlbXMgPSB0aGlzLmRhdGEgPyB0aGlzLm1hcEl0ZW1zKHRoaXMuZGF0YSkgOiBbXTtcbiAgICB9XG59XG5cbmNvbnN0IEZJRUxEX1JFR0VYID0gL1xcWyg/OihcXGQrKXxbJ1wiXSguKj8pWydcIl0pXFxdfCgoPzooPyFcXFsuKj9cXF18XFwuKS4pKykvZztcbmNvbnN0IGdldHRlckNhY2hlID0ge307XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3RyaW5nLWxpdGVyYWxcbmdldHRlckNhY2hlWyd1bmRlZmluZWQnXSA9IChvYmopID0+IG9iajtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBnZXR0ZXIgPSAoZmllbGQpID0+IHtcbiAgICBpZiAoZ2V0dGVyQ2FjaGVbZmllbGRdKSB7XG4gICAgICAgIHJldHVybiBnZXR0ZXJDYWNoZVtmaWVsZF07XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGZpZWxkLnJlcGxhY2UoRklFTERfUkVHRVgsIChfbWF0Y2gsIGluZGV4LCBpbmRleEFjY2Vzc29yLCBuYW1lKSA9PiB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGluZGV4ICE9PSB1bmRlZmluZWQgPyBpbmRleCA6IChpbmRleEFjY2Vzc29yIHx8IG5hbWUpKTtcbiAgICB9KTtcbiAgICBnZXR0ZXJDYWNoZVtmaWVsZF0gPSAob2JqKSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBvYmo7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGZpZWxkcy5sZW5ndGggJiYgcmVzdWx0OyBpZHgrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0W2ZpZWxkc1tpZHhdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIGdldHRlckNhY2hlW2ZpZWxkXTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbGFzdCA9IChhcnIpID0+IGFyclthcnIubGVuZ3RoIC0gMV07XG5cbmNvbnN0IGdldEZpZWxkID0gKGZpZWxkLCBsZXZlbCkgPT4gQXJyYXkuaXNBcnJheShmaWVsZCkgPyBmaWVsZFtsZXZlbF0gfHwgbGFzdChmaWVsZCkgOiBmaWVsZDtcbi8qIHRzbGludDpkaXNhYmxlOm5vLWlucHV0LXJlbmFtZSAqL1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGNvbnZlcnRzIHRoZSBwcm92aWRlZCBoaWVyYXJjaGljYWwgZGF0YSB0byBbTWVudUl0ZW1zXSh7JSBzbHVnIGFwaV9tZW51X21lbnVpdGVtICV9KSBhbmQgYmluZHMgdGhlbSB0byB0aGUgTWVudS5cbiAqL1xubGV0IEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUgPSBjbGFzcyBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlIGV4dGVuZHMgQmluZGluZ0RpcmVjdGl2ZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKG1lbnUpIHtcbiAgICAgICAgc3VwZXIobWVudSk7XG4gICAgfVxuICAgIG1hcEl0ZW1zKGl0ZW1zLCBsZXZlbCA9IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVudUl0ZW0gPSB0aGlzLmNyZWF0ZUl0ZW0oaXRlbSwgbGV2ZWwpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKGl0ZW0sIGxldmVsKTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIG1lbnVJdGVtLml0ZW1zID0gdGhpcy5tYXBJdGVtcyhjaGlsZHJlbiwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW51SXRlbTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUl0ZW0oaXRlbSwgbGV2ZWwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBkYXRhOiBpdGVtIH07XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZmllbGRzO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBmaWVsZHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3QgeyB0YXJnZXQsIHNvdXJjZSB9ID0gZmllbGRzW2lkeF07XG4gICAgICAgICAgICByZXN1bHRbdGFyZ2V0XSA9IGdldHRlcihnZXRGaWVsZChzb3VyY2UsIGxldmVsKSkoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4oaXRlbSwgbGV2ZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5GaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZCh0aGlzLmNoaWxkcmVuRmllbGQsIGxldmVsKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dChcImtlbmRvTWVudUhpZXJhcmNoeUJpbmRpbmdcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwidGV4dEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ1cmxGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaWNvbkZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXNhYmxlZEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjc3NDbGFzc0ZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjc3NTdHlsZUZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzZXBhcmF0b3JGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2hpbGRyZW5GaWVsZFwiLCB2b2lkIDApO1xuSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9NZW51SGllcmFyY2h5QmluZGluZycsXG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvTWVudUhpZXJhcmNoeUJpbmRpbmddJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTWVudUJhc2VdKVxuXSwgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSk7XG5cbi8qIHRzbGludDpkaXNhYmxlOm5vLWlucHV0LXJlbmFtZSAqL1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGNvbnZlcnRzIHRoZSBwcm92aWRlZCBmbGF0IGRhdGEgdG8gW01lbnVJdGVtc10oeyUgc2x1ZyBhcGlfbWVudV9tZW51aXRlbSAlfSkgYW5kIGJpbmRzIHRoZW0gdG8gdGhlIE1lbnUuXG4gKi9cbmxldCBGbGF0QmluZGluZ0RpcmVjdGl2ZSA9IGNsYXNzIEZsYXRCaW5kaW5nRGlyZWN0aXZlIGV4dGVuZHMgQmluZGluZ0RpcmVjdGl2ZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKG1lbnUpIHtcbiAgICAgICAgc3VwZXIobWVudSk7XG4gICAgfVxuICAgIG1hcEl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5pZEZpZWxkIHx8ICF0aGlzLnBhcmVudElkRmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLmNyZWF0ZUl0ZW0oaXRlbSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgaXRlbXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2lkeF07XG4gICAgICAgICAgICBjb25zdCBtZW51SXRlbSA9IHRoaXMuY3JlYXRlSXRlbShpdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZ2V0dGVyKHRoaXMuaWRGaWVsZCkoaXRlbSk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGdldHRlcih0aGlzLnBhcmVudElkRmllbGQpKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKHBhcmVudElkID09PSBudWxsIHx8IHBhcmVudElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtZW51SXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBtYXBbcGFyZW50SWRdID0gbWFwW3BhcmVudElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaXRlbXMgPSBwYXJlbnQuaXRlbXMgfHwgW107XG4gICAgICAgICAgICAgICAgcGFyZW50Lml0ZW1zLnB1c2gobWVudUl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcFtpZF0pIHtcbiAgICAgICAgICAgICAgICBtZW51SXRlbS5pdGVtcyA9IG1hcFtpZF0uaXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXBbaWRdID0gbWVudUl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY3JlYXRlSXRlbShkYXRhSXRlbSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGRhdGE6IGRhdGFJdGVtIH07XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZmllbGRzO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBmaWVsZHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UsIHRhcmdldCB9ID0gZmllbGRzW2lkeF07XG4gICAgICAgICAgICByZXN1bHRbdGFyZ2V0XSA9IGdldHRlcihzb3VyY2UpKGRhdGFJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dChcImtlbmRvTWVudUZsYXRCaW5kaW5nXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIEZsYXRCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGbGF0QmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwidGV4dEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGbGF0QmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwidXJsRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEZsYXRCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpY29uRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZsYXRCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXNhYmxlZEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGbGF0QmluZGluZ0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY3NzQ2xhc3NGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmxhdEJpbmRpbmdEaXJlY3RpdmUucHJvdG90eXBlLCBcImNzc1N0eWxlRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZsYXRCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzZXBhcmF0b3JGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmxhdEJpbmRpbmdEaXJlY3RpdmUucHJvdG90eXBlLCBcImlkRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZsYXRCaW5kaW5nRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXJlbnRJZEZpZWxkXCIsIHZvaWQgMCk7XG5GbGF0QmluZGluZ0RpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9NZW51RmxhdEJpbmRpbmcnLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb01lbnVGbGF0QmluZGluZ10nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtNZW51QmFzZV0pXG5dLCBGbGF0QmluZGluZ0RpcmVjdGl2ZSk7XG5cbmNvbnN0IENPTVBPTkVOVF9FWFBPUlRTID0gW1xuICAgIE1lbnVDb21wb25lbnQsXG4gICAgTWVudUl0ZW1Db21wb25lbnQsXG4gICAgSXRlbVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIEl0ZW1MaW5rVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSXRlbUNvbnRlbnRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLFxuICAgIEZsYXRCaW5kaW5nRGlyZWN0aXZlLFxuICAgIExpbmtEaXJlY3RpdmUsXG4gICAgRXhwYW5kQXJyb3dEaXJlY3RpdmVcbl07XG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyA9IFtcbiAgICAuLi5DT01QT05FTlRfRVhQT1JUUyxcbiAgICBMaXN0Q29tcG9uZW50LFxuICAgIEl0ZW1Db21wb25lbnRcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBNZW51IGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBNZW51IG1vZHVsZVxuICogaW1wb3J0IHsgTWVudU1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLW1lbnUnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKiBpbXBvcnQgeyBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSwgTWVudU1vZHVsZV0sIC8vIGltcG9ydCBNZW51IG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xubGV0IE1lbnVNb2R1bGUgPSBjbGFzcyBNZW51TW9kdWxlIHtcbn07XG5NZW51TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDT01QT05FTlRfRElSRUNUSVZFU10sXG4gICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRVhQT1JUU10sXG4gICAgICAgIGltcG9ydHM6IFtQb3B1cE1vZHVsZSwgQ29tbW9uTW9kdWxlXVxuICAgIH0pXG5dLCBNZW51TW9kdWxlKTtcblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIG9mIHRoZSBDb250ZXh0TWVudS5cbiAqL1xuY2xhc3MgQ29udGV4dE1lbnVFdmVudCB7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHNlbGVjdGAgZXZlbnQgb2YgdGhlIENvbnRleHRNZW51LlxuICovXG5jbGFzcyBDb250ZXh0TWVudVNlbGVjdEV2ZW50IGV4dGVuZHMgQ29udGV4dE1lbnVFdmVudCB7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHBvcHVwT3BlbmAgYW5kIGBwb3B1cENsb3NlYCBldmVudHMgb2YgdGhlIENvbnRleHRNZW51LlxuICovXG5jbGFzcyBDb250ZXh0TWVudVBvcHVwRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdGVtcGxhdGUgZm9yIHRoZSBjb250ZW50IG9mIHRoZSBDb250ZXh0TWVudS4gVG8gZGVmaW5lIGEgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gXG4gKiB0YWcgd2l0aCB0aGUgYGtlbmRvQ29udGV4dE1lbnVUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSBhIGA8a2VuZG8tY29udGV4dG1lbnU+YCBjb21wb25lbnRcbiAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXNdKHslIHNsdWcgdGVtcGxhdGVzX2NvbnRleHRtZW51ICV9KSkuXG4gKlxuICogeyUgbWV0YSBoZWlnaHQ6MjAwICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbnRleHQtbWVudS90ZW1wbGF0ZS9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2FwcC5tb2R1bGUudHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL21haW4udHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqL1xubGV0IENvbnRleHRNZW51VGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBDb250ZXh0TWVudVRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkNvbnRleHRNZW51VGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NvbnRleHRNZW51VGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBDb250ZXh0TWVudVRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDb250ZXh0TWVudUl0ZW1zU2VydmljZSA9IGNsYXNzIENvbnRleHRNZW51SXRlbXNTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0U2VydmljZSkge1xuICAgICAgICB0aGlzLmNvbnRleHRTZXJ2aWNlID0gY29udGV4dFNlcnZpY2U7XG4gICAgfVxuICAgIGdldChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0U2VydmljZS5pdGVtcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFNlcnZpY2UuaXRlbXMuZ2V0KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5Db250ZXh0TWVudUl0ZW1zU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbnRleHRNZW51U2VydmljZV0pXG5dLCBDb250ZXh0TWVudUl0ZW1zU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ29udGV4dE1lbnVUYXJnZXRTZXJ2aWNlID0gY2xhc3MgQ29udGV4dE1lbnVUYXJnZXRTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgIH1cbiAgICBhZGQodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gICAgfVxuICAgIHJlbW92ZSh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnRhcmdldHMuaW5kZXhPZih0YXJnZXQpO1xuICAgICAgICB0aGlzLnRhcmdldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgZmluZCh0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldHMuZmluZCh0YXJnZXQgPT4gdGFyZ2V0LmVsZW1lbnQgPT09IHRhcmdldEVsZW1lbnQpO1xuICAgIH1cbn07XG5Db250ZXh0TWVudVRhcmdldFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIENvbnRleHRNZW51VGFyZ2V0U2VydmljZSk7XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgY29udGFpbmVyIGZvciB0aGUgW3RhcmdldHNdKHslIHNsdWcgYXBpX21lbnVfY29udGV4dG1lbnV0YXJnZXRkaXJlY3RpdmUgJX0pIG9mIHRoZSBDb250ZXh0TWVudS5cbiAqL1xubGV0IENvbnRleHRNZW51VGFyZ2V0Q29udGFpbmVyRGlyZWN0aXZlID0gY2xhc3MgQ29udGV4dE1lbnVUYXJnZXRDb250YWluZXJEaXJlY3RpdmUge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCB0YXJnZXRTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0U2VydmljZSA9IHRhcmdldFNlcnZpY2U7XG4gICAgICAgIGlmIChlbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuQ29udGV4dE1lbnVUYXJnZXRDb250YWluZXJEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NvbnRleHRNZW51VGFyZ2V0Q29udGFpbmVyXScsXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9Db250ZXh0TWVudVRhcmdldENvbnRhaW5lcicsXG4gICAgICAgIHByb3ZpZGVyczogW0NvbnRleHRNZW51VGFyZ2V0U2VydmljZV1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIENvbnRleHRNZW51VGFyZ2V0U2VydmljZV0pXG5dLCBDb250ZXh0TWVudVRhcmdldENvbnRhaW5lckRpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBUQVJHRVRfQ0xBU1MgPSAnay1jb250ZXh0bWVudS10YXJnZXQnO1xuLyoqXG4gKiBTcGVjaWZpZXMgYSBbdGFyZ2V0XSh7JSBzbHVnIGFwaV9tZW51X2NvbnRleHRtZW51dGFyZ2V0ZGlyZWN0aXZlICV9KSBmb3IgdGhlIENvbnRleHRNZW51XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRhcmdldF9jb250ZXh0bWVudSAlfSN0b2MtZGlyZWN0aXZlcykpLlxuICovXG5sZXQgQ29udGV4dE1lbnVUYXJnZXREaXJlY3RpdmUgPSBjbGFzcyBDb250ZXh0TWVudVRhcmdldERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZiwgdGFyZ2V0U2VydmljZSkge1xuICAgICAgICB0aGlzLnRhcmdldFNlcnZpY2UgPSB0YXJnZXRTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICBpZiAoZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFNlcnZpY2UuYWRkKHRoaXMpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50YXJnZXRTZXJ2aWNlLnJlbW92ZSh0aGlzKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2tlbmRvQ29udGV4dE1lbnVUYXJnZXQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29udGV4dE1lbnVUYXJnZXREaXJlY3RpdmUucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKGBjbGFzcy4ke1RBUkdFVF9DTEFTU31gKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbnRleHRNZW51VGFyZ2V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJob3N0Q2xhc3NcIiwgdm9pZCAwKTtcbkNvbnRleHRNZW51VGFyZ2V0RGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9Db250ZXh0TWVudVRhcmdldF0nLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvQ29udGV4dE1lbnVUYXJnZXQnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBDb250ZXh0TWVudVRhcmdldFNlcnZpY2VdKVxuXSwgQ29udGV4dE1lbnVUYXJnZXREaXJlY3RpdmUpO1xuXG52YXIgQ29udGV4dE1lbnVDb21wb25lbnRfMTtcbmNvbnN0IENPTlRFWFRfTUVOVSA9ICdjb250ZXh0bWVudSc7XG5jb25zdCBERUZBVUxUX0FOQ0hPUl9BTElHTiA9IHsgaG9yaXpvbnRhbDogJ2xlZnQnLCB2ZXJ0aWNhbDogJ2JvdHRvbScgfTtcbmNvbnN0IERFRkFVTFRfUE9QVVBfQUxJR04gPSB7IGhvcml6b250YWw6ICdsZWZ0JywgdmVydGljYWw6ICd0b3AnIH07XG5jb25zdCBERUZBVUxUX0NPTExJU0lPTiA9IHsgaG9yaXpvbnRhbDogJ2ZpdCcsIHZlcnRpY2FsOiAnZmxpcCcgfTtcbmNvbnN0IHByZXZlbnREZWZhdWx0ID0gZSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XG5jb25zdCDJtTEkMiA9IGJvZHlGYWN0b3J5O1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgQ29udGV4dE1lbnUgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2NvbnRleHRtZW51ICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICA8ZGl2ICN0YXJnZXQ+XG4gKiAgICAgICAgUmlnaHQtY2xpY2sgdG8gb3BlbiBDb250ZXh0IG1lbnU8L3A+XG4gKiAgICA8L2Rpdj5cbiAqICAgIDxrZW5kby1jb250ZXh0bWVudSBbdGFyZ2V0XT1cInRhcmdldFwiIFtpdGVtc109XCJpdGVtc1wiPiA8L2tlbmRvLWNvbnRleHRtZW51PlxuICogICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICBwdWJsaWMgaXRlbXM6IGFueVtdID0gW3sgdGV4dDogJ2l0ZW0xJywgaXRlbXM6IFt7IHRleHQ6ICdpdGVtMS4xJyB9XSB9LCB7IHRleHQ6ICdpdGVtMicsIGRpc2FibGVkOiB0cnVlIH1dO1xuICogfVxuICogYGBgXG4gKi9cbmxldCBDb250ZXh0TWVudUNvbXBvbmVudCA9IENvbnRleHRNZW51Q29tcG9uZW50XzEgPSBjbGFzcyBDb250ZXh0TWVudUNvbXBvbmVudCBleHRlbmRzIE1lbnVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3B1cFNlcnZpY2UsIHNlcnZpY2UsIG5nWm9uZSwgcmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UgPSBwb3B1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGV2ZW50IG9uIHdoaWNoIHRoZSBDb250ZXh0TWVudSB3aWxsIG9wZW4gKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzaG93b25fY29udGV4dG1lbnUgJX0pKS5cbiAgICAgICAgICogQWNjZXB0cyB0aGUgbmFtZSBvZiBhIG5hdGl2ZSBET00gZXZlbnQuIERlZmF1bHRzIHRvIGBjb250ZXh0bWVudWAgd2hpY2ggb3BlbnMgdGhlIENvbnRleHRNZW51IGZvciB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dPbiA9IENPTlRFWFRfTUVOVTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBDb250ZXh0TWVudSB3aWxsIGJlIGFsaWduZWQgdG8gdGhlIHRhcmdldCBvciB0byB0aGUgYGZpbHRlcmAgZWxlbWVudCAoaWYgc3BlY2lmaWVkKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxpZ25Ub0FuY2hvciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSBNZW51IHdpbGwgYmUgdmVydGljYWxseSByZW5kZXJlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG9yaWVudGF0aW9uX2NvbnRleHRtZW51ICV9KSkuXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVydGljYWwgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgTWVudSBpcyBvcGVuZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0YXJnZXRfY29udGV4dG1lbnUgJX0jdG9jLWNoYW5naW5nLWl0ZW1zLWZvci1zcGVjaWZpZWQtdGFyZ2V0cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3B1cE9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBNZW51IGlzIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9wdXBDbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYSBNZW51IGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYSBNZW51IGl0ZW0gaXMgb3BlbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhIE1lbnUgaXRlbSBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2Uub3duZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLnBvcHVwS2V5RG93bkhhbmRsZXIgPSB0aGlzLnBvcHVwS2V5RG93bkhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIENvbnRleHRNZW51LlxuICAgICAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUG9wdXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIENvbnRleHRNZW51IGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIG9mZnNldCBvciB0aGUgdGFyZ2V0IGVsZW1lbnQgZm9yIHdoaWNoIHRoZSBDb250ZXh0TWVudSB3aWxsIG9wZW4uXG4gICAgICovXG4gICAgc2hvdyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG93VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnJlbW92ZVBvcHVwKCk7XG4gICAgICAgIGlmIChkZWZpbmVkKHNob3dUYXJnZXQubGVmdCkgJiYgZGVmaW5lZChzaG93VGFyZ2V0LnRvcCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUG9wdXAoeyBvZmZzZXQ6IHNob3dUYXJnZXQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBzaG93VGFyZ2V0Lm5hdGl2ZUVsZW1lbnQgfHwgc2hvd1RhcmdldDtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUG9wdXAoeyBhbmNob3I6IHRoaXMuY3VycmVudFRhcmdldCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLnRhcmdldCB8fCBjaGFuZ2VzLnNob3dPbikge1xuICAgICAgICAgICAgdGhpcy5iaW5kU2hvd0hhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xvc2VDbGlja1N1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdtb3VzZWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwUmVmICYmICFjbG9zZXN0KGUudGFyZ2V0LCBub2RlID0+IG5vZGUgPT09IHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50KSAmJiB0aGlzLnNlcnZpY2UubGVhdmVNZW51KGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQb3B1cChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlQmx1clN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCd3aW5kb3cnLCAnYmx1cicsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVBvcHVwKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jbG9zZVN1YnNjcmlwdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbG9zZUNsaWNrU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgY2xvc2VCbHVyU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuYmluZFNob3dIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlUG9wdXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGVtaXRNZW51RXZlbnQobmFtZSwgYXJncykge1xuICAgICAgICBhcmdzLnRhcmdldCA9IHRoaXMuY3VycmVudFRhcmdldDtcbiAgICAgICAgYXJncy5zZW5kZXIgPSB0aGlzO1xuICAgICAgICB0aGlzW25hbWVdLmVtaXQoYXJncyk7XG4gICAgICAgIGlmIChuYW1lID09PSAnc2VsZWN0JyAmJiAhYXJncy5oYXNDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQW5kRm9jdXMoYXJncy5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kU2hvd0hhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMudW5iaW5kU2hvd0hhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMudGFyZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gdGhpcy5zaG93T24gfHwgQ09OVEVYVF9NRU5VO1xuICAgICAgICAgICAgdGhpcy5zaG93U3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgdGhpcy5zaG93T24gfHwgQ09OVEVYVF9NRU5VLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRleHRNZW51KGUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBDT05URVhUX01FTlUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleWRvd25TdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5ICYmIGUua2V5Q29kZSA9PT0gS2V5cy5GMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRleHRNZW51KGUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaG93Q29udGV4dE1lbnUoZSwgZWxlbWVudCkge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLnRhcmdldEZpbHRlcigpO1xuICAgICAgICBsZXQgY3VycmVudFRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBmaW5kSW5Db250YWluZXIoZS50YXJnZXQsIGZpbHRlciwgZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRhcmdldCAmJiBjdXJyZW50VGFyZ2V0ICE9PSBlLnRhcmdldCAmJiBpc0ZvY3VzYWJsZShlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFRhcmdldCAmJiB0aGlzLmRpcmVjdGl2ZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSB0aGlzLnRhcmdldC50YXJnZXRTZXJ2aWNlLmZpbmQoY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlUG9wdXAoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jbG9zZVBvcHVwKGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Qb3B1cChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVuYmluZFNob3dIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5zaG93U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMua2V5ZG93blN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5rZXlkb3duU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmtleWRvd25TdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhcmdldEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJlY3RpdmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gbWF5YmUgcXVlcnlTZWxlY3RvckFsbD9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgJiYgdGFyZ2V0Lm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIENvbnRleHRNZW51VGFyZ2V0Q29udGFpbmVyRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICB0YXJnZXRGaWx0ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZVRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGAuJHtUQVJHRVRfQ0xBU1N9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XG4gICAgfVxuICAgIGNsb3NlUG9wdXAoZSkge1xuICAgICAgICBpZiAoIXRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3B1cEFjdGlvbigncG9wdXBDbG9zZScsIGUsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUG9wdXAoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZVBvcHVwKCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cFJlZikge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcHVwU3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBTdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcGVuUG9wdXAoZSkge1xuICAgICAgICB0aGlzLnBvcHVwQWN0aW9uKCdwb3B1cE9wZW4nLCBlLCAoKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsZXQgYW5jaG9yLCBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGlnblRvQW5jaG9yIHx8IGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gdGhpcy5jdXJyZW50VGFyZ2V0RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHsgbGVmdDogZS5wYWdlWCwgdG9wOiBlLnBhZ2VZIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVBvcHVwKHsgYW5jaG9yLCBvZmZzZXQgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVQb3B1cChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucG9wdXBSZWYgPSB0aGlzLnBvcHVwU2VydmljZS5vcGVuKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYW5pbWF0ZTogZGVmaW5lZCh0aGlzLnBvcHVwQW5pbWF0ZSkgPyB0aGlzLnBvcHVwQW5pbWF0ZSA6IHRydWUsXG4gICAgICAgICAgICBhcHBlbmRUbzogdGhpcy5hcHBlbmRUbyxcbiAgICAgICAgICAgIGNvbGxpc2lvbjogdGhpcy5jb2xsaXNpb24gfHwgREVGQVVMVF9DT0xMSVNJT04sXG4gICAgICAgICAgICBwb3B1cEFsaWduOiB0aGlzLnBvcHVwQWxpZ24gfHwgREVGQVVMVF9QT1BVUF9BTElHTixcbiAgICAgICAgICAgIGFuY2hvckFsaWduOiB0aGlzLmFuY2hvckFsaWduIHx8IERFRkFVTFRfQU5DSE9SX0FMSUdOLFxuICAgICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50VGVtcGxhdGUgPyB0aGlzLmNvbnRlbnRUZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IHRoaXMuZGVmYXVsdENvbnRlbnRUZW1wbGF0ZSxcbiAgICAgICAgICAgIHBvcHVwQ2xhc3M6ICdrLW1lbnUtcG9wdXAnXG4gICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLWNvbnRleHQtbWVudS1wb3B1cCcpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShlbGVtZW50LCAndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbGVtZW50LCAnb3V0bGluZScsICcwJyk7IC8vcG9zc2libHkgbW92ZSB0byBzdHlsZXNcbiAgICAgICAgaWYgKHRoaXMuYXJpYUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnYXJpYS1sYWJlbCcsIHRoaXMuYXJpYUxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldCA9IHRoaXMuY3VycmVudFRhcmdldEVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVuYmluZEtleURvd24gPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAna2V5ZG93bicsIHRoaXMucG9wdXBLZXlEb3duSGFuZGxlcik7XG4gICAgICAgICAgICBjb25zdCB1bmJpbmRDb250ZXh0bWVudSA9IHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBTdWJzY3JpcHRpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuYmluZEtleURvd24oKTtcbiAgICAgICAgICAgICAgICB1bmJpbmRDb250ZXh0bWVudSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gICAgY2xvc2VBbmRGb2N1cyhlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXRFbGVtZW50O1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2VQb3B1cChlKSAmJiB0aGlzLmFjdGl2ZVRhcmdldCkge1xuICAgICAgICAgICAgY3VycmVudFRhcmdldC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvcHVwS2V5RG93bkhhbmRsZXIoZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQ7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtleXMuRXNjYXBlICYmIChoYXNDbGFzcyhlLnRhcmdldCwgJ2stbWVudS1pdGVtJykgfHwgZS50YXJnZXQgPT09IGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQW5kRm9jdXMoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS50YXJnZXQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS5rZXlkb3duLmVtaXQoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9wdXBBY3Rpb24obmFtZSwgb3JpZ2luYWxFdmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IHRoaXNbbmFtZV07XG4gICAgICAgIGxldCBwcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyhlbWl0dGVyKSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gbmV3IENvbnRleHRNZW51UG9wdXBFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IG9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHNlbmRlcjogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmN1cnJlbnRUYXJnZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZlbnRlZCA9IGFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXZlbnRlZDtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUYXJnZXRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RpdmVUYXJnZXQgJiYgdGhpcy5jdXJyZW50VGFyZ2V0ID8gdGhpcy5jdXJyZW50VGFyZ2V0LmVsZW1lbnQgOiB0aGlzLmN1cnJlbnRUYXJnZXQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbnRleHRNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93T25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbnRleHRNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YXJnZXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbnRleHRNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb250ZXh0TWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWxpZ25Ub0FuY2hvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbnRleHRNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29udGV4dE1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwQW5pbWF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29udGV4dE1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwQWxpZ25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbnRleHRNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmNob3JBbGlnblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29udGV4dE1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImNvbGxpc2lvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVmlld0NvbnRhaW5lclJlZilcbl0sIENvbnRleHRNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhcHBlbmRUb1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29udGV4dE1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImFyaWFMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENvbnRleHRNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cE9wZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDb250ZXh0TWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwicG9wdXBDbG9zZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENvbnRleHRNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDb250ZXh0TWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3BlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENvbnRleHRNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjbG9zZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKENvbnRleHRNZW51VGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ29udGV4dE1lbnVUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIENvbnRleHRNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250ZW50VGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnZGVmYXVsdCcsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBDb250ZXh0TWVudUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVmYXVsdENvbnRlbnRUZW1wbGF0ZVwiLCB2b2lkIDApO1xuQ29udGV4dE1lbnVDb21wb25lbnQgPSBDb250ZXh0TWVudUNvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb0NvbnRleHRNZW51JyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBDb250ZXh0TWVudVNlcnZpY2UsXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uY29udGV4dG1lbnUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEl0ZW1zU2VydmljZSxcbiAgICAgICAgICAgICAgICB1c2VDbGFzczogQ29udGV4dE1lbnVJdGVtc1NlcnZpY2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTWVudUJhc2UsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29udGV4dE1lbnVDb21wb25lbnRfMSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBQb3B1cFNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogUE9QVVBfQ09OVEFJTkVSLFxuICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IMm1MSQyXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY29udGV4dG1lbnUnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHQ+XG4gICAgICAgICAgICA8a2VuZG8tbWVudSBbaXRlbXNdPVwicm9vdEl0ZW1zXCJcbiAgICAgICAgICAgICAgICBbdmVydGljYWxdPVwidmVydGljYWxcIlxuICAgICAgICAgICAgICAgIFtvcGVuT25DbGlja109XCJvcGVuT25DbGlja1wiXG4gICAgICAgICAgICAgICAgW2hvdmVyRGVsYXldPVwiaG92ZXJEZWxheVwiXG4gICAgICAgICAgICAgICAgW2FuaW1hdGVdPVwiYW5pbWF0ZVwiXG4gICAgICAgICAgICAgICAgW21lbnVJdGVtVGVtcGxhdGVdPVwiaXRlbVRlbXBsYXRlLmZpcnN0Py50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgW21lbnVJdGVtTGlua1RlbXBsYXRlXT1cIml0ZW1MaW5rVGVtcGxhdGUuZmlyc3Q/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICA+PC9rZW5kby1tZW51PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1BvcHVwU2VydmljZSxcbiAgICAgICAgQ29udGV4dE1lbnVTZXJ2aWNlLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBDb250ZXh0TWVudUNvbXBvbmVudCk7XG5cbmNvbnN0IENPTVBPTkVOVF9ESVJFQ1RJVkVTJDEgPSBbXG4gICAgQ29udGV4dE1lbnVDb21wb25lbnQsXG4gICAgQ29udGV4dE1lbnVUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBDb250ZXh0TWVudVRhcmdldERpcmVjdGl2ZSxcbiAgICBDb250ZXh0TWVudVRhcmdldENvbnRhaW5lckRpcmVjdGl2ZVxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIENvbnRleHRNZW51IGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBDb250ZXh0TWVudSBtb2R1bGVcbiAqIGltcG9ydCB7IENvbnRleHRNZW51TW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbWVudSc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqIGltcG9ydCB7IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9hbmltYXRpb25zJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlLCBDb250ZXh0TWVudU1vZHVsZV0sIC8vIGltcG9ydCBDb250ZXh0TWVudU1vZHVsZSBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBDb250ZXh0TWVudU1vZHVsZSA9IGNsYXNzIENvbnRleHRNZW51TW9kdWxlIHtcbn07XG5Db250ZXh0TWVudU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NUE9ORU5UX0RJUkVDVElWRVMkMV0sXG4gICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFUyQxLCBNZW51TW9kdWxlXSxcbiAgICAgICAgaW1wb3J0czogW1BvcHVwTW9kdWxlLCBDb21tb25Nb2R1bGUsIE1lbnVNb2R1bGVdXG4gICAgfSlcbl0sIENvbnRleHRNZW51TW9kdWxlKTtcblxuLyoqXG4gKiBBIFttb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pIHRoYXQgaW5jbHVkZXMgdGhlIE1lbnUgYW5kIENvbnRleHRNZW51IGNvbXBvbmVudHMgYW5kIGRpcmVjdGl2ZXMuXG4gKiBJbXBvcnRzIHRoZSBNZW51c01vZHVsZSBpbnRvIHlvdXIgYXBwbGljYXRpb24gW3Jvb3QgbW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZXMnXSB9fSNhbmd1bGFyLW1vZHVsYXJpdHkpXG4gKiBvciBhbnkgb3RoZXIgc3ViLW1vZHVsZSB0aGF0IHdpbGwgdXNlIHRoZSBNZW51IGFuZCBDb250ZXh0TWVudSBjb21wb25lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1uby1ydW5cbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG4gKiBpbXBvcnQgeyBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG4gKiBpbXBvcnQgeyBNZW51c01vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLW1lbnUnO1xuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdLFxuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sXG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUsIE1lbnVzTW9kdWxlXVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge1xuICogfVxuICogYGBgXG4gKi9cbmxldCBNZW51c01vZHVsZSA9IGNsYXNzIE1lbnVzTW9kdWxlIHtcbn07XG5NZW51c01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZXhwb3J0czogW01lbnVNb2R1bGUsIENvbnRleHRNZW51TW9kdWxlXVxuICAgIH0pXG5dLCBNZW51c01vZHVsZSk7XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgTk9ERV9JTkRFWCwgQ29udGV4dE1lbnVJdGVtc1NlcnZpY2UsIENvbnRleHRNZW51VGFyZ2V0Q29udGFpbmVyRGlyZWN0aXZlLCBDb250ZXh0TWVudVRhcmdldERpcmVjdGl2ZSwgQ29udGV4dE1lbnVUYXJnZXRTZXJ2aWNlLCBCaW5kaW5nRGlyZWN0aXZlQmFzZSwgTWVudUJhc2UsIFByZXZlbnRhYmxlRXZlbnQsIEFjdGlvbnNTZXJ2aWNlLCBIb3ZlclNlcnZpY2UsIEl0ZW1zU2VydmljZSwgTmF2aWdhdGlvblNlcnZpY2UsIGJvZHlGYWN0b3J5LCBNZW51Q29tcG9uZW50LCBMaXN0Q29tcG9uZW50LCBJdGVtQ29tcG9uZW50LCBMaW5rRGlyZWN0aXZlLCBFeHBhbmRBcnJvd0RpcmVjdGl2ZSwgTWVudUl0ZW1Db21wb25lbnQsIE1lbnVFdmVudCwgTWVudVNlbGVjdEV2ZW50LCBJdGVtQ29udGVudFRlbXBsYXRlRGlyZWN0aXZlLCBJdGVtVGVtcGxhdGVEaXJlY3RpdmUsIEl0ZW1MaW5rVGVtcGxhdGVEaXJlY3RpdmUsIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUsIEZsYXRCaW5kaW5nRGlyZWN0aXZlLCBNZW51TW9kdWxlLCBDb250ZXh0TWVudUV2ZW50LCBDb250ZXh0TWVudVNlbGVjdEV2ZW50LCBDb250ZXh0TWVudVBvcHVwRXZlbnQsIENvbnRleHRNZW51VGVtcGxhdGVEaXJlY3RpdmUsIENvbnRleHRNZW51Q29tcG9uZW50LCBDb250ZXh0TWVudU1vZHVsZSwgQ29udGV4dE1lbnVTZXJ2aWNlLCBNZW51c01vZHVsZSB9O1xuIl19