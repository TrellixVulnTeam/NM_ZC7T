/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param } from 'tslib';
import { Injectable, EventEmitter, Injector, Input, TemplateRef, Output, HostBinding, Component, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, Renderer2, isDevMode, Directive, forwardRef, ContentChild, ViewChild, HostListener, Optional, NgZone, InjectionToken, Inject, ViewContainerRef, ViewChildren, QueryList, ContentChildren, IterableDiffers, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, NgControl } from '@angular/forms';
import { LocalizationService, L10N_PREFIX, RTL, ComponentMessages } from '@progress/kendo-angular-l10n';
import { getDate, isEqual, cloneDate, addDays, addDecades, addCenturies, firstDecadeOfCentury, lastDecadeOfCentury, firstYearOfDecade, createDate, lastYearOfDecade, lastMonthOfYear, lastDayOfMonth, durationInCenturies, addYears, durationInDecades, addWeeks, addMonths, firstDayOfMonth, dayOfWeek, durationInMonths, firstMonthOfYear, durationInYears, weekInYear } from '@progress/kendo-date-math';
import { isDocumentAvailable, guid, Keys, hasObservers, KendoInput, EventsModule, ResizeSensorModule } from '@progress/kendo-angular-common';
import { validatePackage } from '@progress/kendo-licensing';
import { IntlService, IntlModule } from '@progress/kendo-angular-intl';
import { Subject, Subscription, ReplaySubject, Observable, combineLatest, of, interval, animationFrameScheduler, fromEvent, EMPTY, from, BehaviorSubject, merge } from 'rxjs';
import { map, scan, takeWhile, tap, filter, debounceTime } from 'rxjs/operators';
import { PopupService, PopupModule } from '@progress/kendo-angular-popup';
import { CommonModule } from '@angular/common';
import { touchEnabled } from '@progress/kendo-common';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-intl';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@progress/kendo-angular-l10n';
import * as ɵngcc4 from '@progress/kendo-angular-common';
import * as ɵngcc5 from '@progress/kendo-angular-popup';

function HorizontalViewListComponent_ng_template_0_caption_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "caption", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const date_r5 = ɵngcc0.ɵɵnextContext().date;
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r7.getCaptionClass());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r7.getCaptionTitle(date_r5));
} }
function HorizontalViewListComponent_ng_template_0_thead_2_th_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "th", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const name_r11 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(name_r11);
} }
function HorizontalViewListComponent_ng_template_0_thead_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "thead", 8)(1, "tr", 9);
    ɵngcc0.ɵɵtemplate(2, HorizontalViewListComponent_ng_template_0_thead_2_th_2_Template, 2, 1, "th", 10);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r8.weekNames);
} }
function HorizontalViewListComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "table", 3);
    ɵngcc0.ɵɵtemplate(1, HorizontalViewListComponent_ng_template_0_caption_1_Template, 2, 2, "caption", 4);
    ɵngcc0.ɵɵtemplate(2, HorizontalViewListComponent_ng_template_0_thead_2_Template, 3, 1, "thead", 5);
    ɵngcc0.ɵɵelementStart(3, "tbody", 6);
    ɵngcc0.ɵɵlistener("cellClick", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellClick_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.cellClick.emit($event); })("weekNumberCellClick", function HorizontalViewListComponent_ng_template_0_Template_tbody_weekNumberCellClick_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.weekNumberCellClick.emit($event); })("cellEnter", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellEnter_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.cellEnter.emit($event); })("cellLeave", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellLeave_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.cellLeave.emit($event); });
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const date_r5 = ctx.date;
    const class_r6 = ctx.className;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", class_r6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.showViewHeader);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.isMonthView());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("activeView", ctx_r1.activeView)("isActive", ctx_r1.isActive)("min", ctx_r1.min)("max", ctx_r1.max)("cellUID", ctx_r1.cellUID)("focusedDate", ctx_r1.focusedDate)("selectedDates", ctx_r1.selectedDates)("selectionRange", ctx_r1.selectionRange)("activeRangeEnd", ctx_r1.activeRangeEnd)("weekNumber", ctx_r1.weekNumber)("templateRef", ctx_r1.cellTemplateRef)("weekNumberTemplateRef", ctx_r1.weekNumberTemplateRef)("viewDate", date_r5);
} }
function HorizontalViewListComponent_2_ng_template_0_Template(rf, ctx) { }
const _c0 = function (a0) { return { date: a0, className: "k-pointer-events-none" }; };
function HorizontalViewListComponent_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, HorizontalViewListComponent_2_ng_template_0_Template, 0, 0, "ng-template", 12);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r0)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c0, ctx_r2.nextAnimationDate));
} }
function HorizontalViewListComponent_3_ng_template_0_Template(rf, ctx) { }
const _c1 = function (a0) { return { date: a0 }; };
function HorizontalViewListComponent_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, HorizontalViewListComponent_3_ng_template_0_Template, 0, 0, "ng-template", 12);
} if (rf & 2) {
    const date_r18 = ctx.$implicit;
    ɵngcc0.ɵɵnextContext();
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r0)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c1, date_r18));
} }
function HorizontalViewListComponent_4_ng_template_0_Template(rf, ctx) { }
function HorizontalViewListComponent_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, HorizontalViewListComponent_4_ng_template_0_Template, 0, 0, "ng-template", 12);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r0)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c0, ctx_r4.prevAnimationDate));
} }
function HeaderComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);
} }
function HeaderComponent_ng_template_2_Template(rf, ctx) { }
function HeaderComponent_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 8);
    ɵngcc0.ɵɵlistener("click", function HeaderComponent_button_5_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.prevButtonClick.emit(); });
    ɵngcc0.ɵɵelement(1, "span", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r2.isPrevDisabled)("title", ctx_r2.prevButtonTitle);
    ɵngcc0.ɵɵattribute("aria-disabled", ctx_r2.isPrevDisabled);
} }
function HeaderComponent_button_8_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 10);
    ɵngcc0.ɵɵlistener("click", function HeaderComponent_button_8_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.nextButtonClick.emit(); });
    ɵngcc0.ɵɵelement(1, "span", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r3.isNextDisabled)("title", ctx_r3.nextButtonTitle);
    ɵngcc0.ɵɵattribute("aria-disabled", ctx_r3.isNextDisabled);
} }
const _c2 = function (a0) { return { click: a0 }; };
const _c3 = function (a0, a1, a2) { return { $implicit: a0, activeView: a1, date: a2 }; };
const _c10 = function (a0) { return { focusin: a0 }; };
const _c11 = ["*"];
const _c12 = ["list"];
function NavigationComponent_li_4_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const date_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.service.navigationTitle(date_r2));
} }
function NavigationComponent_li_4_ng_template_3_Template(rf, ctx) { }
function NavigationComponent_li_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li")(1, "span");
    ɵngcc0.ɵɵtemplate(2, NavigationComponent_li_4_ng_template_2_Template, 1, 1, "ng-template", 5);
    ɵngcc0.ɵɵtemplate(3, NavigationComponent_li_4_ng_template_3_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const date_r2 = ctx.$implicit;
    const index_r3 = ctx.index;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("data-date-index", index_r3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("k-calendar-navigation-marker", ctx_r1.service.isRangeStart(date_r2));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.templateRef)("ngTemplateOutlet", ctx_r1.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction3(7, _c3, ctx_r1.service.navigationTitle(date_r2), ctx_r1.activeViewValue, date_r2));
} }
function ViewListComponent_table_1_th_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "th", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const name_r5 = ctx.$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r4.colWidth, "%");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(name_r5);
} }
function ViewListComponent_table_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "table", 7)(1, "thead", 8)(2, "tr", 9);
    ɵngcc0.ɵɵtemplate(3, ViewListComponent_table_1_th_3_Template, 2, 3, "th", 10);
    ɵngcc0.ɵɵelementEnd()()();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.weekNames);
} }
function ViewListComponent_col_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "col");
} }
function ViewListComponent_tbody_7_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tbody", 12);
    ɵngcc0.ɵɵlistener("cellClick", function ViewListComponent_tbody_7_Template_tbody_cellClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.cellClick.emit($event); })("weekNumberCellClick", function ViewListComponent_tbody_7_Template_tbody_weekNumberCellClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.weekNumberCellClick.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const date_r7 = ctx.$implicit;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("activeView", ctx_r3.activeView)("isActive", ctx_r3.isActive)("min", ctx_r3.min)("max", ctx_r3.max)("cellUID", ctx_r3.cellUID)("focusedDate", ctx_r3.focusedDate)("selectedDates", ctx_r3.selectedDates)("weekNumber", ctx_r3.weekNumber)("templateRef", ctx_r3.cellTemplateRef)("weekNumberTemplateRef", ctx_r3.weekNumberTemplateRef)("viewDate", date_r7);
} }
function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-calendar-navigation", 5);
    ɵngcc0.ɵɵlistener("valueChange", function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template_kendo_calendar_navigation_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(2); return ctx_r3.handleNavigation($event); })("pageChange", function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template_kendo_calendar_navigation_pageChange_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.onPageChange(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("activeView", ctx_r2.activeViewEnum)("focusedDate", ctx_r2.focusedDate)("min", ctx_r2.min)("max", ctx_r2.max)("templateRef", ctx_r2.navigationItemTemplateRef == null ? null : ctx_r2.navigationItemTemplateRef.templateRef);
} }
function CalendarComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template, 1, 5, "kendo-calendar-navigation", 2);
    ɵngcc0.ɵɵelementStart(2, "kendo-calendar-viewlist", 3);
    ɵngcc0.ɵɵlistener("todayButtonClick", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_todayButtonClick_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.handleDateChange({ selectedDates: [$event], focusedDate: $event }); })("cellClick", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_cellClick_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.handleCellClick($event); })("weekNumberCellClick", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_weekNumberCellClick_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.handleWeekNumberClick($event); })("activeDateChange", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_activeDateChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.handleActiveDateChange($event); })("pageChange", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_pageChange_2_listener() { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onPageChange(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "kendo-resize-sensor", 4);
    ɵngcc0.ɵɵlistener("resize", function CalendarComponent_ng_container_1_Template_kendo_resize_sensor_resize_3_listener() { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onResize(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    let tmp_3_0;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.navigation);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("activeView", ctx_r0.activeViewEnum)("isActive", ctx_r0.isActive)("cellTemplateRef", (tmp_3_0 = ctx_r0.activeCellTemplate()) == null ? null : tmp_3_0.templateRef)("headerTitleTemplateRef", ctx_r0.headerTitleTemplateRef == null ? null : ctx_r0.headerTitleTemplateRef.templateRef)("weekNumberTemplateRef", ctx_r0.weekNumberTemplateRef == null ? null : ctx_r0.weekNumberTemplateRef.templateRef)("cellUID", ctx_r0.cellUID)("min", ctx_r0.min)("max", ctx_r0.max)("focusedDate", ctx_r0.focusedDate)("weekNumber", ctx_r0.weekNumber)("selectedDates", ctx_r0.selectedDates);
} }
function CalendarComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "kendo-multiviewcalendar", 6, 7);
    ɵngcc0.ɵɵlistener("activeViewChange", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_activeViewChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.handleActiveViewChange($event); })("navigate", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_navigate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.handleNavigate($event); })("valueChange", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const _r13 = ɵngcc0.ɵɵreference(2); const ctx_r17 = ɵngcc0.ɵɵnextContext(); return ctx_r17.handleMultiViewCalendarValueChange($event, _r13.focusedDate); })("focus", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_focus_1_listener() { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.handleFocus(); })("blur", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_blur_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r19 = ɵngcc0.ɵɵnextContext(); return ctx_r19.handleBlur($event); });
    ɵngcc0.ɵɵelement(3, "kendo-multiviewcalendar-messages", 8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("views", 1)("min", ctx_r1.min)("max", ctx_r1.max)("isActive", ctx_r1.isActive)("activeView", ctx_r1.activeView)("bottomView", ctx_r1.bottomView)("topView", ctx_r1.topView)("weekNumber", ctx_r1.weekNumber)("animateNavigation", ctx_r1.animateNavigation)("cellTemplate", ctx_r1.activeCellTemplate())("monthCellTemplate", ctx_r1.monthCellTemplateRef)("yearCellTemplate", ctx_r1.yearCellTemplateRef)("decadeCellTemplate", ctx_r1.decadeCellTemplateRef)("centuryCellTemplate", ctx_r1.centuryCellTemplateRef)("headerTitleTemplate", ctx_r1.headerTitleTemplateRef)("weekNumberTemplate", ctx_r1.weekNumberTemplateRef)("focusedDate", ctx_r1.focusedDate)("selection", ctx_r1.selection)("value", ctx_r1.value)("disabledDates", ctx_r1.disabledDates);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("today", ctx_r1.localization.get("today"))("prevButtonTitle", ctx_r1.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r1.localization.get("nextButtonTitle"));
} }
const _c19 = ["dateInput"];
const _c20 = ["spinup"];
const _c21 = ["spindown"];
function DateInputComponent_span_3_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵlistener("mousedown", function DateInputComponent_span_3_Template_span_mousedown_0_listener($event) { return $event.preventDefault(); });
    ɵngcc0.ɵɵelementStart(1, "button", 5, 6);
    ɵngcc0.ɵɵlistener("mousedown", function DateInputComponent_span_3_Template_button_mousedown_1_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.arrowDirection = ctx_r5.arrow.Up; })("mouseleave", function DateInputComponent_span_3_Template_button_mouseleave_1_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.arrowDirection = ctx_r7.arrow.None; })("click", function DateInputComponent_span_3_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.handleButtonClick(1); });
    ɵngcc0.ɵɵelement(3, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "button", 8, 9);
    ɵngcc0.ɵɵlistener("click", function DateInputComponent_span_3_Template_button_click_4_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.handleButtonClick(-1); })("mousedown", function DateInputComponent_span_3_Template_button_mousedown_4_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.arrowDirection = ctx_r10.arrow.Down; })("mouseleave", function DateInputComponent_span_3_Template_button_mouseleave_4_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.arrowDirection = ctx_r11.arrow.None; });
    ɵngcc0.ɵɵelement(6, "span", 10);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.arrow.Up);
    ɵngcc0.ɵɵproperty("title", ctx_r1.localization.get("increment"));
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.localization.get("increment"));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.arrow.Down);
    ɵngcc0.ɵɵproperty("title", ctx_r1.localization.get("decrement"));
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.localization.get("decrement"));
} }
const _c26 = function (a0, a1, a2, a3, a4, a5, a6) { return { click: a0, focus: a1, mousedown: a2, touchstart: a3, dragstart: a4, drop: a5, blur: a6 }; };
const _c27 = ["container"];
const _c28 = ["popupTemplate"];
const _c29 = ["toggleButton"];
function DatePickerComponent_ng_template_8_ng_template_3_Template(rf, ctx) { }
const _c38 = function (a0) { return { keydown: a0 }; };
function DatePickerComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-calendar", 8, 9);
    ɵngcc0.ɵɵlistener("valueChange", function DatePickerComponent_ng_template_8_Template_kendo_calendar_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.handleChange(ctx_r7.mergeTime($event)); });
    ɵngcc0.ɵɵelement(2, "kendo-calendar-messages", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, DatePickerComponent_ng_template_8_ng_template_3_Template, 0, 0, "ng-template");
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("type", ctx_r4.calendarType)("min", ctx_r4.min)("max", ctx_r4.max)("navigation", ctx_r4.navigation)("animateNavigation", ctx_r4.animateCalendarNavigation)("activeView", ctx_r4.activeView)("bottomView", ctx_r4.bottomView)("topView", ctx_r4.topView)("weekNumber", ctx_r4.weekNumber)("cellTemplate", ctx_r4.cellTemplate)("monthCellTemplate", ctx_r4.monthCellTemplate)("yearCellTemplate", ctx_r4.yearCellTemplate)("decadeCellTemplate", ctx_r4.decadeCellTemplate)("centuryCellTemplate", ctx_r4.centuryCellTemplate)("weekNumberTemplate", ctx_r4.weekNumberTemplate)("headerTitleTemplate", ctx_r4.headerTitleTemplate)("navigationItemTemplate", ctx_r4.navigationItemTemplate)("focusedDate", ctx_r4.focusedDate)("value", ctx_r4.value)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(25, _c38, ctx_r4.handleKeydown))("scope", ctx_r4)("disabledDates", ctx_r4.disabledDates);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("today", ctx_r4.localization.get("today"))("prevButtonTitle", ctx_r4.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r4.localization.get("nextButtonTitle"));
} }
const _c39 = function (a0, a1) { return { click: a0, mousedown: a1 }; };
const _c54 = function (a0, a1) { return { keydown: a0, mousedown: a1 }; };
function TimePickerComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-timeselector", 8, 9);
    ɵngcc0.ɵɵlistener("valueChange", function TimePickerComponent_ng_template_6_Template_kendo_timeselector_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.handleChange($event); })("valueReject", function TimePickerComponent_ng_template_6_Template_kendo_timeselector_valueReject_0_listener() { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.handleReject(); });
    ɵngcc0.ɵɵelement(2, "kendo-timeselector-messages", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cancelButton", ctx_r3.cancelButton)("nowButton", ctx_r3.nowButton)("format", ctx_r3.format)("min", ctx_r3.min)("max", ctx_r3.max)("steps", ctx_r3.steps)("value", ctx_r3.value)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(15, _c54, ctx_r3.handleKeydown, ctx_r3.handleMousedown))("scope", ctx_r3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("acceptLabel", ctx_r3.localization.get("acceptLabel"))("accept", ctx_r3.localization.get("accept"))("cancelLabel", ctx_r3.localization.get("cancelLabel"))("cancel", ctx_r3.localization.get("cancel"))("nowLabel", ctx_r3.localization.get("nowLabel"))("now", ctx_r3.localization.get("now"));
} }
function DateTimePickerComponent_ng_template_7_button_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 23);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r5.popupButtonsClasses())("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(6, _c2, ctx_r5.handleCancel))("scope", ctx_r5);
    ɵngcc0.ɵɵattribute("title", ctx_r5.localization.get("cancelLabel"))("aria-label", ctx_r5.localization.get("cancelLabel"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.localization.get("cancel"), " ");
} }
const _c83 = function (a0, a1) { return { mousedown: a0, keydown: a1 }; };
const _c84 = function (a0, a1) { return { focusin: a0, focusout: a1 }; };
const _c85 = function (a0, a1) { return { click: a0, keydown: a1 }; };
const _c86 = function (a0) { return { transitionend: a0 }; };
const _c87 = function (a0, a1, a2) { return { keydown: a0, focusin: a1, focusout: a2 }; };
function DateTimePickerComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 7)(1, "div", 8)(2, "div", 9)(3, "button", 10);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "button", 11);
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd()()();
    ɵngcc0.ɵɵelementStart(7, "div", 12, 13)(9, "div", 14)(10, "kendo-calendar", 15);
    ɵngcc0.ɵɵlistener("valueChange", function DateTimePickerComponent_ng_template_7_Template_kendo_calendar_valueChange_10_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.calendarValue = $event; })("valueChange", function DateTimePickerComponent_ng_template_7_Template_kendo_calendar_valueChange_10_listener() { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.handleCalendarValueChange(); });
    ɵngcc0.ɵɵelement(11, "kendo-calendar-messages", 16);
    ɵngcc0.ɵɵelementEnd()();
    ɵngcc0.ɵɵelementStart(12, "div", 17)(13, "kendo-timeselector", 18);
    ɵngcc0.ɵɵelement(14, "kendo-timeselector-messages", 19);
    ɵngcc0.ɵɵelementEnd()()();
    ɵngcc0.ɵɵelementStart(15, "div", 20);
    ɵngcc0.ɵɵtemplate(16, DateTimePickerComponent_ng_template_7_button_16_Template, 2, 8, "button", 21);
    ɵngcc0.ɵɵelementStart(17, "button", 22);
    ɵngcc0.ɵɵtext(18);
    ɵngcc0.ɵɵelementEnd()()();
} if (rf & 2) {
    const _r4 = ɵngcc0.ɵɵreference(8);
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate1("k-datetime-wrap k-", ctx_r3.activeTab, "-tab");
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(65, _c83, ctx_r3.preventMouseDown, ctx_r3.handleKeyDown))("scope", ctx_r3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(68, _c84, ctx_r3.handleFocus, ctx_r3.handleBlur))("scope", ctx_r3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("k-active", ctx_r3.activeTab === "date");
    ɵngcc0.ɵɵproperty("ngClass", ctx_r3.popupButtonsClasses())("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(71, _c85, ctx_r3.changeActiveTab.bind(ctx_r3, "date"), ctx_r3.handleBackTabOut))("scope", ctx_r3);
    ɵngcc0.ɵɵattribute("title", ctx_r3.localization.get("dateTabLabel"))("aria-label", ctx_r3.localization.get("dateTabLabel"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.localization.get("dateTab"), " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("k-active", ctx_r3.activeTab === "time");
    ɵngcc0.ɵɵproperty("ngClass", ctx_r3.popupButtonsClasses())("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(74, _c2, ctx_r3.changeActiveTab.bind(ctx_r3, "time")));
    ɵngcc0.ɵɵattribute("title", ctx_r3.localization.get("timeTabLabel"))("aria-label", ctx_r3.localization.get("timeTabLabel"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.localization.get("timeTab"), " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("transition", ctx_r3.tabSwitchTransition);
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(76, _c86, ctx_r3.handleTabChangeTransitionEnd.bind(ctx_r3, _r4)));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("value", ctx_r3.calendarValue)("type", ctx_r3.calendarType)("min", ctx_r3.calendarMin)("max", ctx_r3.calendarMax)("focusedDate", ctx_r3.focusedDate)("weekNumber", ctx_r3.weekNumber)("navigation", false)("animateNavigation", ctx_r3.animateCalendarNavigation)("cellTemplate", ctx_r3.cellTemplate)("monthCellTemplate", ctx_r3.monthCellTemplate)("yearCellTemplate", ctx_r3.yearCellTemplate)("decadeCellTemplate", ctx_r3.decadeCellTemplate)("centuryCellTemplate", ctx_r3.centuryCellTemplate)("weekNumberTemplate", ctx_r3.weekNumberTemplate)("headerTitleTemplate", ctx_r3.headerTitleTemplate)("disabled", ctx_r3.disableCalendar)("disabledDates", ctx_r3.disabledDates);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("today", ctx_r3.localization.get("today"))("prevButtonTitle", ctx_r3.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r3.localization.get("nextButtonTitle"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("value", ctx_r3.value)("format", ctx_r3.timeSelectorFormat)("min", ctx_r3.timeSelectorMin)("max", ctx_r3.timeSelectorMax)("setButton", false)("cancelButton", false)("steps", ctx_r3.steps)("disabled", ctx_r3.disableTimeSelector);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("now", ctx_r3.localization.get("now"))("nowLabel", ctx_r3.localization.get("nowLabel"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(78, _c87, ctx_r3.handleTabOut, ctx_r3.handleFocus, ctx_r3.handleBlur))("scope", ctx_r3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.cancelButton);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r3.popupButtonsClasses("primary"))("disabled", !ctx_r3.calendarValue)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(82, _c2, ctx_r3.handleAccept))("scope", ctx_r3);
    ɵngcc0.ɵɵattribute("title", ctx_r3.localization.get("acceptLabel"))("aria-label", ctx_r3.localization.get("acceptLabel"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.localization.get("accept"), " ");
} }
const _c88 = function (a0, a1) { return { mousedown: a0, click: a1 }; };
const _c89 = function (a0, a1) { return { "k-i-calendar": a0, "k-i-clock": a1 }; };
const _c90 = ["defaultTemplate"];
function DateRangePopupComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-multiviewcalendar", 2);
} }
function DateRangeComponent_kendo_daterange_popup_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-daterange-popup");
} }
const _c91 = ["kendoCalendarView", ""];
function ViewComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 3);
    ɵngcc0.ɵɵtext(1, "\u00A0");
    ɵngcc0.ɵɵelementEnd();
} }
function ViewComponent_tr_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 4)(1, "th", 5);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("colSpan", ctx_r2.colSpan);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.title);
} }
function ViewComponent_tr_3_ng_template_1_td_0_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const row_r4 = ɵngcc0.ɵɵnextContext(3).$implicit;
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r9.getWeekNumber(ctx_r9.firstDate(row_r4)), " ");
} }
function ViewComponent_tr_3_ng_template_1_td_0_ng_template_2_Template(rf, ctx) { }
const _c92 = function (a0, a1) { return { $implicit: a0, cellContext: a1 }; };
function ViewComponent_tr_3_ng_template_1_td_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 9);
    ɵngcc0.ɵɵtemplate(1, ViewComponent_tr_3_ng_template_1_td_0_ng_template_1_Template, 1, 1, "ng-template", 6);
    ɵngcc0.ɵɵtemplate(2, ViewComponent_tr_3_ng_template_1_td_0_ng_template_2_Template, 0, 0, "ng-template", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const row_r4 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(5, _c2, ctx_r8.handleWeekNumberClick.bind(ctx_r8, row_r4)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r8.weekNumberTemplateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r8.weekNumberTemplateRef)("ngTemplateOutlet", ctx_r8.weekNumberTemplateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(7, _c92, ctx_r8.firstDate(row_r4), ctx_r8.getWeekNumberContext(row_r4)));
} }
function ViewComponent_tr_3_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ViewComponent_tr_3_ng_template_1_td_0_Template, 3, 10, "td", 8);
} if (rf & 2) {
    const row_r4 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.firstDate(row_r4))("ngIfElse", _r0);
} }
function ViewComponent_tr_3_ng_container_2_td_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const cell_r14 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵtextInterpolate(cell_r14.formattedValue);
} }
function ViewComponent_tr_3_ng_container_2_td_1_3_ng_template_0_Template(rf, ctx) { }
function ViewComponent_tr_3_ng_container_2_td_1_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ViewComponent_tr_3_ng_container_2_td_1_3_ng_template_0_Template, 0, 0, "ng-template", 15);
} if (rf & 2) {
    const cell_r14 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r18 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r18.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c92, cell_r14.value, cell_r14));
} }
function ViewComponent_tr_3_ng_container_2_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 12)(1, "span", 13);
    ɵngcc0.ɵɵtemplate(2, ViewComponent_tr_3_ng_container_2_td_1_ng_template_2_Template, 1, 1, "ng-template", 6);
    ɵngcc0.ɵɵtemplate(3, ViewComponent_tr_3_ng_container_2_td_1_3_Template, 1, 5, null, 14);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r22 = ɵngcc0.ɵɵnextContext();
    const cell_r14 = ctx_r22.$implicit;
    const cellIndex_r15 = ctx_r22.index;
    const rowIndex_r5 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r16 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r16.getStyles(cell_r14))("title", cell_r14.title);
    ɵngcc0.ɵɵattribute("id", cell_r14.id)("data-cell-index", ctx_r16.tableCellIndex(rowIndex_r5, cellIndex_r15))("aria-selected", cell_r14.isSelected || cell_r14.isRangeStart || cell_r14.isRangeMid || cell_r14.isRangeEnd)("aria-disabled", cell_r14.isDisabled);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r16.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r16.templateRef);
} }
function ViewComponent_tr_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ViewComponent_tr_3_ng_container_2_td_1_Template, 4, 8, "td", 11);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const cell_r14 = ctx.$implicit;
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.shouldRenderCellContent(cell_r14))("ngIfElse", _r0);
} }
function ViewComponent_tr_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 4);
    ɵngcc0.ɵɵtemplate(1, ViewComponent_tr_3_ng_template_1_Template, 1, 2, "ng-template", 6);
    ɵngcc0.ɵɵtemplate(2, ViewComponent_tr_3_ng_container_2_Template, 2, 2, "ng-container", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const row_r4 = ctx.$implicit;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.weekNumber);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("kForOf", row_r4);
} }
function TimeListComponent_li_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 3)(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const index_r2 = ctx.index;
    ɵngcc0.ɵɵattribute("data-timelist-item-index", index_r2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(item_r1.text);
} }
const _c93 = ["accept"];
const _c94 = ["cancel"];
const _c95 = ["now"];
const _c96 = ["listWrapper"];
const _c109 = function (a0, a1, a2) { return { click: a0, focus: a1, blur: a2 }; };
function TimeSelectorComponent_button_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 8, 9);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(6, _c109, ctx_r0.handleNow, ctx_r0.handleFocus, ctx_r0.handleBlur))("scope", ctx_r0)("disabled", ctx_r0.disabled);
    ɵngcc0.ɵɵattribute("title", ctx_r0.localization.get("nowLabel"))("aria-label", ctx_r0.localization.get("nowLabel"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.localization.get("now"));
} }
const _c110 = function (a0, a1) { return { focus: a0, blur: a1 }; };
function TimeSelectorComponent_ng_template_7_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 12, 13)(2, "span", 2);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "kendo-timelist", 14);
    ɵngcc0.ɵɵlistener("valueChange", function TimeSelectorComponent_ng_template_7_div_0_Template_kendo_timelist_valueChange_4_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(2); return ctx_r9.current = $event; });
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext();
    const part_r4 = ctx_r11.$implicit;
    const idx_r5 = ctx_r11.index;
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r6.intl.dateFieldName(part_r4));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("min", ctx_r6.min)("max", ctx_r6.max)("part", part_r4)("step", ctx_r6.partStep(part_r4))("disabled", ctx_r6.disabled)("value", ctx_r6.current)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(10, _c110, ctx_r6.handleListFocus, ctx_r6.handleBlur))("scope", ctx_r6);
    ɵngcc0.ɵɵattribute("data-timelist-index", idx_r5);
} }
function TimeSelectorComponent_ng_template_7_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const part_r4 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", part_r4.pattern, " ");
} }
function TimeSelectorComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TimeSelectorComponent_ng_template_7_div_0_Template, 5, 13, "div", 10);
    ɵngcc0.ɵɵtemplate(1, TimeSelectorComponent_ng_template_7_div_1_Template, 2, 1, "div", 11);
} if (rf & 2) {
    const part_r4 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngIf", part_r4.type !== "literal");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", part_r4.type === "literal");
} }
function TimeSelectorComponent_div_8_button_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 19, 20);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(6, _c109, ctx_r13.handleReject, ctx_r13.handleFocus, ctx_r13.handleBlur))("scope", ctx_r13)("disabled", ctx_r13.disabled);
    ɵngcc0.ɵɵattribute("title", ctx_r13.localization.get("cancelLabel"))("aria-label", ctx_r13.localization.get("cancelLabel"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r13.localization.get("cancel"));
} }
function TimeSelectorComponent_div_8_button_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 21, 22);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(6, _c109, ctx_r14.handleAccept, ctx_r14.handleFocus, ctx_r14.handleBlur))("scope", ctx_r14)("disabled", ctx_r14.disabled);
    ɵngcc0.ɵɵattribute("title", ctx_r14.localization.get("acceptLabel"))("aria-label", ctx_r14.localization.get("acceptLabel"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r14.localization.get("accept"));
} }
function TimeSelectorComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 16);
    ɵngcc0.ɵɵtemplate(1, TimeSelectorComponent_div_8_button_1_Template, 3, 10, "button", 17);
    ɵngcc0.ɵɵtemplate(2, TimeSelectorComponent_div_8_button_2_Template, 3, 10, "button", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.cancelButton);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.setButton);
} }
const packageMetadata = {
    name: '@progress/kendo-angular-dateinputs',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1647358649,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * @hidden
 */
var Action;
(function (Action) {
    Action[Action["Left"] = 0] = "Left";
    Action[Action["Right"] = 1] = "Right";
    Action[Action["Up"] = 2] = "Up";
    Action[Action["Down"] = 3] = "Down";
    Action[Action["PrevView"] = 4] = "PrevView";
    Action[Action["NextView"] = 5] = "NextView";
    Action[Action["FirstInView"] = 6] = "FirstInView";
    Action[Action["LastInView"] = 7] = "LastInView";
    Action[Action["LowerView"] = 8] = "LowerView";
    Action[Action["UpperView"] = 9] = "UpperView";
})(Action || (Action = {}));

/**
 * @hidden
 */
const EMPTY_SELECTIONRANGE = { start: null, end: null };

/**
 * @hidden
 */
const MIDNIGHT_DATE = new Date(1980, 0, 1);
/**
 * @hidden
 */
const MIN_DATE = new Date(1900, 0, 1);
/**
 * @hidden
 */
const MAX_DATE = new Date(2099, 11, 31);
/**
 * @hidden
 */
const MIN_TIME = new Date(1980, 0, 1);
/**
 * @hidden
 */
const MAX_TIME = new Date(1980, 0, 1, 23, 59, 59);

/**
 * @hidden
 */
const requiresZoneOnBlur = (ngControl) => ngControl &&
    (!ngControl.touched || (ngControl.control && ngControl.control.updateOn === 'blur'));
/**
 * @hidden
 */
const preventDefault = (args) => args.preventDefault();
/**
 * @hidden
 */
const currentFocusTarget = (blurArgs) => blurArgs.relatedTarget || document.activeElement;
/**
 * @hidden
 */
const isPresent = (value) => value !== undefined && value !== null;
/**
 * @hidden
 *
 * If the provided parameter is an array with at least one item
 * and all items in the array are numbers, returns `true.
 */
const isNumberArray = (value) => Array.isArray(value) && value.length > 0 && value.every(item => typeof item === 'number');
/**
 * @hidden
 *
 * If the provided parameter is an array with at least one item
 * and all items in the array are dates, returns `true`.
 */
const isDateArray = (value) => Array.isArray(value) && value.length > 0 && value.every(item => item instanceof Date);

/* tslint:disable:no-bitwise max-line-length */
const isSet = (value) => value !== null && value !== undefined;
const setter = (method) => (date, value) => {
    const clone = cloneDate(date);
    clone[method](value);
    return clone;
};
/**
 * @hidden
 */
const setTime = (origin, candidate) => {
    const date = cloneDate(origin);
    date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());
    return date;
};
const normalizeTimes = (candidate, min, max) => ({
    candidateValue: setTime(MIDNIGHT_DATE, candidate),
    maxValue: addDays(setTime(MIDNIGHT_DATE, max), min.getHours() < max.getHours() ||
        (min.getHours() === max.getHours() && min.getMinutes() < max.getMinutes()) ? 0 : 1),
    minValue: setTime(MIDNIGHT_DATE, min)
});
/**
 * @hidden
 */
const setYears = setter('setFullYear');
/**
 * @hidden
 */
const setHours = setter('setHours');
/**
 * @hidden
 */
const setMinutes = setter('setMinutes');
/**
 * @hidden
 */
const setSeconds = setter('setSeconds');
/**
 * @hidden
 */
const setMilliseconds = setter('setMilliseconds');
/**
 * @hidden
 */
const range = (start, end, step = 1) => {
    const result = [];
    for (let i = start; i < end; i = i + step) {
        result.push(i);
    }
    return result;
};
/**
 * @hidden
 */
const isInRange = (candidate, min, max) => (!candidate || !((min && min > candidate) || (max && max < candidate)));
/**
 * @hidden
 */
const isInTimeRange = (candidate, min, max) => {
    if (!candidate || !min || !max) {
        return true;
    }
    const { candidateValue, minValue, maxValue } = normalizeTimes(candidate, min, max);
    return minValue <= candidateValue && candidateValue <= maxValue;
};
/**
 * @hidden
 */
const isValidRange = (min, max) => (!isSet(min) || !isSet(max) || min <= max);
/**
 * @hidden
 */
const dateInRange = (candidate, min, max) => {
    if (!candidate) {
        return candidate;
    }
    if (min && candidate < min) {
        return cloneDate(min);
    }
    if (max && candidate > max) {
        return cloneDate(max);
    }
    return candidate;
};
/**
 * @hidden
 */
const timeInRange = (candidate, min, max) => {
    if (!candidate || !min || !max) {
        return candidate;
    }
    const { candidateValue, minValue, maxValue } = normalizeTimes(candidate, min, max);
    if (candidateValue < minValue) {
        return setTime(candidate, min);
    }
    if (candidateValue > maxValue) {
        return setTime(candidate, max);
    }
    return candidate;
};
/**
 * @hidden
 */
const getNow = () => new Date();
/**
 * @hidden
 */
const getToday = () => getDate(new Date());
/**
 * @hidden
 */
const noop = (_) => { }; // tslint:disable-line:no-empty
/**
 * @hidden
 */
const isWindowAvailable = () => {
    return typeof window !== 'undefined';
};
/**
 * @hidden
 */
const stringifyClassObject = (classes) => {
    const pushToAcc = (acc, cls) => classes[cls] ? acc.concat(cls) : acc;
    return Object.keys(classes).reduce(pushToAcc, []).join(' ');
};
/**
 * @hidden
 */
const shiftWeekNames = (names, offset) => (names.slice(offset).concat(names.slice(0, offset)));
/**
 * @hidden
 */
const approximateStringMatching = (oldTextOrigin, oldFormat, newTextOrigin, caret) => {
    // Remove the right part of the cursor.
    //oldFormat = oldFormat.substring(0, caret + oldText.length - newText.length);
    const oldIndex = caret + oldTextOrigin.length - newTextOrigin.length;
    const oldTextSeparator = oldTextOrigin[oldIndex];
    const oldText = oldTextOrigin.substring(0, caret + oldTextOrigin.length - newTextOrigin.length);
    const newText = newTextOrigin.substring(0, caret);
    const diff = [];
    // Handle typing a single character over the same selection.
    if (oldText === newText && caret > 0) {
        diff.push([oldFormat[caret - 1], newText[caret - 1]]);
        return diff;
    }
    if (oldText.indexOf(newText) === 0 && (newText.length === 0 || oldFormat[newText.length - 1] !== oldFormat[newText.length])) {
        // Handle Delete/Backspace.
        let deletedSymbol = "";
        //XXX:
        // Whole text is replaced with a same char
        // Nasty patch required to keep the selection in the first segment
        if (newText.length === 1) {
            diff.push([oldFormat[0], newText[0]]);
        }
        for (let i = newText.length; i < oldText.length; i++) {
            if (oldFormat[i] !== deletedSymbol && oldFormat[i] !== "_") {
                deletedSymbol = oldFormat[i];
                diff.push([deletedSymbol, ""]);
            }
        }
        return diff;
    }
    // Handle inserting text (the new text is longer than the previous one).
    // Handle typing over a literal as well.
    if (newText.indexOf(oldText) === 0 || oldFormat[caret - 1] === "_") {
        let symbol = oldFormat[0];
        for (let i = Math.max(0, oldText.length - 1); i < oldFormat.length; i++) {
            if (oldFormat[i] !== "_") {
                symbol = oldFormat[i];
                break;
            }
        }
        return [[symbol, newText[caret - 1]]];
    }
    // Handle entering a space or a separator, for navigation to the next item.
    if (newText[newText.length - 1] === " " || (newText[newText.length - 1] === oldTextSeparator && oldFormat[oldIndex] === '_')) {
        return [[oldFormat[caret - 1], "_"]];
    }
    // Handle typing over a correctly selected part.
    return [[oldFormat[caret - 1], newText[caret - 1]]];
};
/**
 * @hidden
 */
const domContainerFactory = (type) => (children, classes = "", styles = {}) => {
    const container = document.createElement(type);
    container.className = classes;
    Object.keys(styles).map(key => container.style[key] = styles[key]);
    if (typeof children === 'string') {
        container.innerHTML = children || '';
    }
    else {
        (children || []).forEach(child => child && container.appendChild(child));
    }
    return container;
};
/**
 * @hidden
 */
const hasChange = (changes, field) => changes[field] !== undefined;
/**
 * @hidden
 */
const hasExistingValue = (changes, field) => changes[field] && changes[field].currentValue !== undefined && changes[field].currentValue !== null;
/**
 * @hidden
 */
const last = (list = []) => list && list[list.length - 1];
/**
 * @hidden
 */
const isInSelectionRange = (value, selectionRange) => {
    const { start, end } = selectionRange || EMPTY_SELECTIONRANGE;
    if (!start || !end) {
        return false;
    }
    return start < value && value < end;
};
/**
 * @hidden
 */
const either = (value1, value2) => value1 || value2;
/**
 * @hidden
 */
const clampRange = (value) => ({ start: value, end: value });
/**
 * @hidden
 */
const isEqualRange = (initial, updated) => {
    const { start: initialStart, end: initialEnd } = initial || EMPTY_SELECTIONRANGE;
    const { start: updatedStart, end: updatedEnd } = updated || EMPTY_SELECTIONRANGE;
    return isEqual(initialStart, updatedStart) && isEqual(initialEnd, updatedEnd);
};
/**
 * @hidden
 */
const areDatesEqual = (first, second) => {
    first = first || [];
    second = second || [];
    return first.length === second.length && first.every((date, index) => isEqual(date, second[index]));
};
/**
 * @hidden
 */
const sortDates = (dates) => {
    return dates.filter(date => isPresent(date)).sort((a, b) => a.getTime() - b.getTime());
};
/**
 * @hidden
 *
 * Creates a new date based on the date information from the specified date portion
 * and the time information from the time portion.
 * If a parameter is not provided, returns `null`.
 */
const mergeDateAndTime = (date, time) => {
    if (!(date && time)) {
        return null;
    }
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
};
/**
 * @hidden
 */
const lastMillisecondOfDate = (date) => {
    if (!date) {
        return null;
    }
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);
};
/**
 * @hidden
 *
 * Returns an array with dates ranging between and including the specified start and
 * end dates that are evaluated as disabled.
 */
const disabledDatesInRange = (start, end, isDateDisabled) => {
    if (!(start && end && isDateDisabled) || (start > end)) {
        return [];
    }
    const dates = [];
    let current = start;
    while (current <= end) {
        if (isDateDisabled(current)) {
            dates.push(current);
        }
        current = addDays(current, 1);
    }
    return dates;
};
/**
 * @hidden
 *
 * Crops the last two digits from the year of the provided date value.
 */
const cropTwoDigitYear = (date) => {
    if (!isPresent(date) || isNaN(date.getTime())) {
        return 0;
    }
    return Number(date
        .getFullYear()
        .toString()
        .slice(-2));
};
/**
 * @hidden
 *
 * Used when resetting millisecond segment value in the DateInput
 */
const msPaddingFromFormat = (format) => {
    return Array(format.match(/S+(\1)/)[0].length).join("0");
};
/**
 * @hidden
 */
const millisecondDigitsInFormat = (format) => {
    const result = format && format.match(/S+(\1)/);
    return result ? result[0].length : 0;
};
/**
 * @hidden
 */
const millisecondStepFor = (digits) => {
    return Math.pow(10, 3 - digits);
};
/**
 * @hidden
 *
 * Checks if a tab keydown would would move the focus outside of the calendar.
 */
const isTabExitingCalendar = (calendarType, focusedElement, shiftKey) => {
    if (!isPresent(focusedElement)) {
        return false;
    }
    return calendarType === 'infinite' || ( // infinte calendar is always exited on first tab keydown
    calendarType === 'classic' &&
        (shiftKey && focusedElement.classList.contains('k-calendar')) || // exited on main calendar element focused and back-tab
        (!shiftKey && focusedElement.classList.contains('k-next-view')) // exited on next button focused and regular tab
    );
};
/**
 * @hidden
 * Returns the size class based on the component and size input.
 */
const getSizeClass = (component, size) => {
    const SIZE_CLASSES = {
        'small': `k-${component}-sm`,
        'medium': `k-${component}-md`,
        'large': `k-${component}-lg`
    };
    return SIZE_CLASSES[size];
};
/**
 * @hidden
 * Returns the rounded class based on the rounded input.
 */
const getRoundedClass = (rounded) => {
    const ROUNDED_CLASSES = {
        'small': 'k-rounded-sm',
        'medium': 'k-rounded-md',
        'large': 'k-rounded-lg',
        'full': 'k-rounded-full'
    };
    return ROUNDED_CLASSES[rounded];
};
/**
 * @hidden
 * Return the fillMode class based on the component and fillMode input.
 */
const getFillModeClass = (component, fillMode) => {
    const FILLMODE_CLASSES = {
        'solid': `k-${component}-solid`,
        'flat': `k-${component}-flat`,
        'outline': `k-${component}-outline`
    };
    return FILLMODE_CLASSES[fillMode];
};

const EMPTY_DATA = [[]];
const CELLS_LENGTH = 4;
const ROWS_LENGTH = 3;
const ACTIONS = {
    [Action.Left]: (date) => addDecades(date, -1),
    [Action.Up]: (date) => addDecades(date, -5),
    [Action.Right]: (date) => addDecades(date, 1),
    [Action.Down]: (date) => addDecades(date, 5),
    [Action.PrevView]: (date) => addCenturies(date, -1),
    [Action.NextView]: (date) => addCenturies(date, 1),
    [Action.FirstInView]: (date) => firstDecadeOfCentury(date),
    [Action.LastInView]: (date) => lastDecadeOfCentury(date)
};
/**
 * @hidden
 */
let CenturyViewService = class CenturyViewService {
    /**
     * @hidden
     */
    constructor() {
        this.dateRange = (start, end) => {
            if (!isPresent(start) || !isPresent(end)) {
                return [];
            }
            const result = [];
            let current = start;
            while (current <= end) {
                result.push(current);
                current = addDecades(current, 1);
            }
            return result;
        };
    }
    addToDate(min, skip) {
        return addCenturies(min, skip);
    }
    datesList(start, count) {
        return range(0, count).map(i => addCenturies(start, i));
    }
    data(options) {
        const { cellUID, focusedDate, isActiveView, max, min, selectedDates, selectionRange = EMPTY_SELECTIONRANGE, viewDate } = options;
        if (!viewDate) {
            return EMPTY_DATA;
        }
        const cells = range(0, CELLS_LENGTH);
        const firstDate = firstDecadeOfCentury(viewDate);
        const lastDate = lastDecadeOfCentury(viewDate);
        const today = getToday();
        return range(0, ROWS_LENGTH).map(rowOffset => {
            const baseDate = addDecades(firstDate, rowOffset * CELLS_LENGTH);
            return cells.map(cellOffset => {
                const cellDate = this.normalize(addDecades(baseDate, cellOffset), min, max);
                const nextCentury = cellDate.getFullYear() > lastDate.getFullYear();
                if (!this.isInRange(cellDate, min, max) || nextCentury) {
                    return null;
                }
                const isRangeStart = this.isEqual(cellDate, selectionRange.start);
                const isRangeEnd = this.isEqual(cellDate, selectionRange.end);
                const isInMiddle = !isRangeStart && !isRangeEnd;
                const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
                return {
                    formattedValue: this.value(cellDate),
                    id: `${cellUID}${cellDate.getTime()}`,
                    isFocused: this.isEqual(cellDate, focusedDate),
                    isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),
                    isWeekend: false,
                    isRangeStart: isRangeStart,
                    isRangeMid: isRangeMid,
                    isRangeEnd: isRangeEnd,
                    isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
                    isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
                    isToday: this.isEqual(cellDate, today),
                    title: this.cellTitle(cellDate),
                    value: cellDate
                };
            });
        });
    }
    isEqual(candidate, expected) {
        if (!candidate || !expected) {
            return false;
        }
        return firstYearOfDecade(candidate).getFullYear() === firstYearOfDecade(expected).getFullYear();
    }
    isInArray(date, dates) {
        if (!dates.length) {
            return false;
        }
        const year = date.getFullYear();
        return dates[0].getFullYear() <= year && year <= (dates[dates.length - 1].getFullYear() + 99);
    }
    isInRange(candidate, min, max) {
        const year = firstYearOfDecade(candidate).getFullYear();
        const aboveMin = !min || firstYearOfDecade(min).getFullYear() <= year;
        const belowMax = !max || year <= firstYearOfDecade(max).getFullYear();
        return aboveMin && belowMax;
    }
    beginningOfPeriod(date) {
        if (!date) {
            return date;
        }
        const firstYear = firstYearOfDecade(firstDecadeOfCentury(date));
        return createDate(firstYear.getFullYear(), 0, 1);
    }
    lastDayOfPeriod(date) {
        const decade = lastDecadeOfCentury(date);
        const year = lastYearOfDecade(decade);
        const month = lastMonthOfYear(year);
        return lastDayOfMonth(month);
    }
    isRangeStart(value) {
        return value.getFullYear() % 1000 === 0;
    }
    move(value, action) {
        const modifier = ACTIONS[action];
        if (!modifier) {
            return value;
        }
        return modifier(value);
    }
    cellTitle(value) {
        return firstYearOfDecade(value).getFullYear().toString();
    }
    navigationTitle(value) {
        return value ? firstDecadeOfCentury(value).getFullYear().toString() : '';
    }
    title(value) {
        if (!value) {
            return '';
        }
        return `${firstDecadeOfCentury(value).getFullYear()} - ${lastDecadeOfCentury(value).getFullYear()}`;
    }
    rowLength() {
        return CELLS_LENGTH;
    }
    skip(value, min) {
        return durationInCenturies(min, value);
    }
    total(min, max) {
        return durationInCenturies(min, max) + 1;
    }
    value(current) {
        return current ? firstYearOfDecade(current).getFullYear().toString() : '';
    }
    viewDate(date, max, viewsCount = 1) {
        const viewsInRange = this.total(date, max);
        if (viewsInRange < viewsCount) {
            const centuriesToSubtract = viewsCount - viewsInRange;
            return addCenturies(date, -1 * centuriesToSubtract);
        }
        return date;
    }
    normalize(cellDate, min, max) {
        if (cellDate < min && this.isEqual(cellDate, min)) {
            return cloneDate(min);
        }
        if (cellDate > max && this.isEqual(cellDate, max)) {
            return cloneDate(max);
        }
        return cellDate;
    }
};
CenturyViewService.ɵfac = function CenturyViewService_Factory(t) { return new (t || CenturyViewService)(); };
CenturyViewService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: CenturyViewService, factory: function (t) { return CenturyViewService.ɵfac(t); } });

const EMPTY_DATA$1 = [[]];
const CELLS_LENGTH$1 = 4;
const ROWS_LENGTH$1 = 3;
const ACTIONS$1 = {
    [Action.Left]: (date) => addYears(date, -1),
    [Action.Up]: (date) => addYears(date, -5),
    [Action.Right]: (date) => addYears(date, 1),
    [Action.Down]: (date) => addYears(date, 5),
    [Action.PrevView]: (date) => addDecades(date, -1),
    [Action.NextView]: (date) => addDecades(date, 1),
    [Action.FirstInView]: (date) => firstYearOfDecade(date),
    [Action.LastInView]: (date) => lastYearOfDecade(date)
};
/**
 * @hidden
 */
let DecadeViewService = class DecadeViewService {
    /**
     * @hidden
     */
    constructor() {
        this.dateRange = (start, end) => {
            if (!isPresent(start) || !isPresent(end)) {
                return [];
            }
            const result = [];
            let current = start;
            while (current <= end) {
                result.push(current);
                current = addYears(current, 1);
            }
            return result;
        };
    }
    addToDate(min, skip) {
        return addDecades(min, skip);
    }
    datesList(start, count) {
        return range(0, count).map(i => addDecades(start, i));
    }
    data(options) {
        const { cellUID, focusedDate, isActiveView, max, min, selectedDates, selectionRange = EMPTY_SELECTIONRANGE, viewDate } = options;
        if (!viewDate) {
            return EMPTY_DATA$1;
        }
        const cells = range(0, CELLS_LENGTH$1);
        const firstDate = firstYearOfDecade(viewDate);
        const lastDate = lastYearOfDecade(viewDate);
        const today = getToday();
        return range(0, ROWS_LENGTH$1).map(rowOffset => {
            const baseDate = addYears(firstDate, rowOffset * CELLS_LENGTH$1);
            return cells.map(cellOffset => {
                const cellDate = this.normalize(addYears(baseDate, cellOffset), min, max);
                const nextDecade = cellDate.getFullYear() > lastDate.getFullYear();
                if (!this.isInRange(cellDate, min, max) || nextDecade) {
                    return null;
                }
                const isRangeStart = this.isEqual(cellDate, selectionRange.start);
                const isRangeEnd = this.isEqual(cellDate, selectionRange.end);
                const isInMiddle = !isRangeStart && !isRangeEnd;
                const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
                return {
                    formattedValue: this.value(cellDate),
                    id: `${cellUID}${cellDate.getTime()}`,
                    isFocused: this.isEqual(cellDate, focusedDate),
                    isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),
                    isWeekend: false,
                    isRangeStart: isRangeStart,
                    isRangeMid: isRangeMid,
                    isRangeEnd: isRangeEnd,
                    isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
                    isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
                    isToday: this.isEqual(cellDate, today),
                    title: this.cellTitle(cellDate),
                    value: cellDate
                };
            });
        });
    }
    isEqual(candidate, expected) {
        if (!candidate || !expected) {
            return false;
        }
        return candidate.getFullYear() === expected.getFullYear();
    }
    isInArray(date, dates) {
        if (!dates.length) {
            return false;
        }
        const year = date.getFullYear();
        return dates[0].getFullYear() <= year && year <= (dates[dates.length - 1].getFullYear() + 9);
    }
    isInRange(candidate, min, max) {
        const year = candidate.getFullYear();
        const aboveMin = !min || min.getFullYear() <= year;
        const belowMax = !max || year <= max.getFullYear();
        return aboveMin && belowMax;
    }
    beginningOfPeriod(date) {
        if (!date) {
            return date;
        }
        const firstYear = firstYearOfDecade(date);
        return createDate(firstYear.getFullYear(), 0, 1);
    }
    lastDayOfPeriod(date) {
        const year = lastYearOfDecade(date);
        const month = lastMonthOfYear(year);
        return lastDayOfMonth(month);
    }
    isRangeStart(value) {
        return value.getFullYear() % 100 === 0;
    }
    move(value, action) {
        const modifier = ACTIONS$1[action];
        if (!modifier) {
            return value;
        }
        return modifier(value);
    }
    cellTitle(value) {
        return value.getFullYear().toString();
    }
    navigationTitle(value) {
        return value ? firstYearOfDecade(value).getFullYear().toString() : '';
    }
    title(value) {
        if (!value) {
            return '';
        }
        return `${firstYearOfDecade(value).getFullYear()} - ${lastYearOfDecade(value).getFullYear()}`;
    }
    rowLength() {
        return CELLS_LENGTH$1;
    }
    skip(value, min) {
        return durationInDecades(min, value);
    }
    total(min, max) {
        return durationInDecades(min, max) + 1;
    }
    value(current) {
        return current ? current.getFullYear().toString() : '';
    }
    viewDate(date, max, viewsCount = 1) {
        const viewsInRange = this.total(date, max);
        if (viewsInRange < viewsCount) {
            const decadesToSubtract = viewsCount - viewsInRange;
            return addDecades(date, -1 * decadesToSubtract);
        }
        return date;
    }
    normalize(cellDate, min, max) {
        if (cellDate < min && this.isEqual(cellDate, min)) {
            return cloneDate(min);
        }
        if (cellDate > max && this.isEqual(cellDate, max)) {
            return cloneDate(max);
        }
        return cellDate;
    }
};
DecadeViewService.ɵfac = function DecadeViewService_Factory(t) { return new (t || DecadeViewService)(); };
DecadeViewService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DecadeViewService, factory: function (t) { return DecadeViewService.ɵfac(t); } });

const EMPTY_DATA$2 = [[]];
const CELLS_LENGTH$2 = 7;
const ROWS_LENGTH$2 = 6;
const ACTIONS$2 = {
    [Action.Left]: (date) => addDays(date, -1),
    [Action.Up]: (date) => addWeeks(date, -1),
    [Action.Right]: (date) => addDays(date, 1),
    [Action.Down]: (date) => addWeeks(date, 1),
    [Action.PrevView]: (date) => addMonths(date, -1),
    [Action.NextView]: (date) => addMonths(date, 1),
    [Action.FirstInView]: (date) => firstDayOfMonth(date),
    [Action.LastInView]: (date) => lastDayOfMonth(date)
};
/**
 * @hidden
 */
let MonthViewService = class MonthViewService {
    constructor(_intlService) {
        this._intlService = _intlService;
        this.dateRange = (start, end) => {
            if (!isPresent(start) || !isPresent(end)) {
                return [];
            }
            const result = [];
            let current = start;
            while (current <= end) {
                result.push(current);
                current = addDays(current, 1);
            }
            return result;
        };
    }
    addToDate(min, skip) {
        return addMonths(min, skip);
    }
    datesList(start, count) {
        return range(0, count).map(i => addMonths(start, i));
    }
    data(options) {
        const { cellUID, focusedDate, isActiveView, max, min, selectedDates, selectionRange = EMPTY_SELECTIONRANGE, viewDate, isDateDisabled = () => false } = options;
        if (!viewDate) {
            return EMPTY_DATA$2;
        }
        const firstMonthDate = firstDayOfMonth(viewDate);
        const firstMonthDay = getDate(firstMonthDate);
        const lastMonthDate = lastDayOfMonth(viewDate);
        const lastMonthDay = getDate(lastMonthDate);
        const backward = -1;
        const date = dayOfWeek(firstMonthDate, this._intlService.firstDay(), backward);
        const cells = range(0, CELLS_LENGTH$2);
        const today = getToday();
        return range(0, ROWS_LENGTH$2).map(rowOffset => {
            const baseDate = addDays(date, rowOffset * CELLS_LENGTH$2);
            return cells.map(cellOffset => {
                const cellDate = this.normalize(addDays(baseDate, cellOffset), min, max);
                const cellDay = getDate(cellDate);
                const otherMonth = cellDay < firstMonthDay || cellDay > lastMonthDay;
                const outOfRange = cellDate < min || cellDate > max;
                if (outOfRange) {
                    return null;
                }
                const isRangeStart = this.isEqual(cellDate, selectionRange.start);
                const isRangeEnd = this.isEqual(cellDate, selectionRange.end);
                const isInMiddle = !isRangeStart && !isRangeEnd;
                const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
                return {
                    formattedValue: this.value(cellDate),
                    id: `${cellUID}${cellDate.getTime()}`,
                    isFocused: this.isEqual(cellDate, focusedDate),
                    isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),
                    isWeekend: this.isWeekend(cellDate),
                    isRangeStart: isRangeStart,
                    isRangeMid: isRangeMid,
                    isRangeEnd: isRangeEnd,
                    isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstMonthDate),
                    isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastMonthDate),
                    isToday: this.isEqual(cellDate, today),
                    title: this.cellTitle(cellDate),
                    value: cellDate,
                    isDisabled: isDateDisabled(cellDate),
                    isOtherMonth: otherMonth
                };
            });
        });
    }
    isEqual(candidate, expected) {
        if (!candidate || !expected) {
            return false;
        }
        return getDate(candidate).getTime() === getDate(expected).getTime();
    }
    isInArray(date, dates) {
        if (dates.length === 0) {
            return false;
        }
        const lowerBound = this.beginningOfPeriod(dates[0]);
        const upperBound = this.beginningOfPeriod(addMonths(dates[dates.length - 1], 1));
        return lowerBound <= date && date < upperBound;
    }
    isInRange(candidate, min, max) {
        const value = getDate(candidate);
        const aboveMin = !min || getDate(min) <= value;
        const belowMax = !max || value <= getDate(max);
        return aboveMin && belowMax;
    }
    beginningOfPeriod(date) {
        if (!date) {
            return date;
        }
        return createDate(date.getFullYear(), date.getMonth(), 1);
    }
    lastDayOfPeriod(date) {
        return lastDayOfMonth(date);
    }
    isRangeStart(value) {
        return !value.getMonth();
    }
    move(value, action) {
        const modifier = ACTIONS$2[action];
        if (!modifier) {
            return value;
        }
        return modifier(value);
    }
    cellTitle(value) {
        return this._intlService.formatDate(value, 'D');
    }
    navigationTitle(value) {
        if (!value) {
            return '';
        }
        return this.isRangeStart(value) ? value.getFullYear().toString() : this.abbrMonthNames()[value.getMonth()];
    }
    title(current) {
        return `${this.wideMonthNames()[current.getMonth()]} ${current.getFullYear()}`;
    }
    rowLength(options = {}) {
        return CELLS_LENGTH$2 + (options.prependCell ? 1 : 0);
    }
    skip(value, min) {
        return durationInMonths(min, value);
    }
    total(min, max) {
        return durationInMonths(min, max) + 1;
    }
    value(current) {
        return current ? current.getDate().toString() : "";
    }
    viewDate(date, max, viewsCount = 1) {
        const viewsInRange = this.total(date, max);
        if (viewsInRange < viewsCount) {
            const monthsToSubtract = viewsCount - viewsInRange;
            return addMonths(date, -1 * monthsToSubtract);
        }
        return date;
    }
    isWeekend(date) {
        const { start, end } = this._intlService.weekendRange();
        const day = date.getDay();
        if (end < start) {
            return day <= end || start <= day;
        }
        return start <= day && day <= end;
    }
    abbrMonthNames() {
        return this._intlService.dateFormatNames({ nameType: 'abbreviated', type: 'months' });
    }
    normalize(cellDate, min, max) {
        if (cellDate < min && this.isEqual(cellDate, min)) {
            return cloneDate(min);
        }
        if (cellDate > max && this.isEqual(cellDate, max)) {
            return cloneDate(max);
        }
        return cellDate;
    }
    wideMonthNames() {
        return this._intlService.dateFormatNames({ nameType: 'wide', type: 'months' });
    }
};
MonthViewService.ɵfac = function MonthViewService_Factory(t) { return new (t || MonthViewService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService)); };
MonthViewService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MonthViewService, factory: function (t) { return MonthViewService.ɵfac(t); } });
MonthViewService = __decorate([ __metadata("design:paramtypes", [IntlService])
], MonthViewService);

const EMPTY_DATA$3 = [[]];
const CELLS_LENGTH$3 = 4;
const ROWS_LENGTH$3 = 3;
const upStep = (month) => {
    if (month > 4) {
        return -5;
    }
    if (month < 2) {
        return -2;
    }
    return -7;
};
const downStep = (month) => {
    if (month < 7) {
        return 5;
    }
    if (month < 10) {
        return 7;
    }
    return 2;
};
const ACTIONS$3 = {
    [Action.Left]: (date) => addMonths(date, -1),
    [Action.Up]: (date) => addMonths(date, upStep(date.getMonth())),
    [Action.Right]: (date) => addMonths(date, 1),
    [Action.Down]: (date) => addMonths(date, downStep(date.getMonth())),
    [Action.PrevView]: (date) => addYears(date, -1),
    [Action.NextView]: (date) => addYears(date, 1),
    [Action.FirstInView]: (date) => firstMonthOfYear(date),
    [Action.LastInView]: (date) => lastMonthOfYear(date)
};
/**
 * @hidden
 */
let YearViewService = class YearViewService {
    constructor(_intlService) {
        this._intlService = _intlService;
        this.dateRange = (start, end) => {
            if (!isPresent(start) || !isPresent(end)) {
                return [];
            }
            const result = [];
            let current = start;
            while (current <= end) {
                result.push(current);
                current = addMonths(current, 1);
            }
            return result;
        };
    }
    addToDate(min, skip) {
        return addYears(min, skip);
    }
    datesList(start, count) {
        return range(0, count).map(i => addYears(start, i));
    }
    data(options) {
        const { cellUID, focusedDate, isActiveView, max, min, selectedDates, selectionRange = EMPTY_SELECTIONRANGE, viewDate } = options;
        if (!viewDate) {
            return EMPTY_DATA$3;
        }
        const months = this.abbrMonthNames();
        const firstDate = firstMonthOfYear(viewDate);
        const lastDate = lastMonthOfYear(viewDate);
        const currentYear = firstDate.getFullYear();
        const cells = range(0, CELLS_LENGTH$3);
        const today = getToday();
        return range(0, ROWS_LENGTH$3).map(rowOffset => {
            const baseDate = addMonths(firstDate, rowOffset * CELLS_LENGTH$3);
            return cells.map(cellOffset => {
                const cellDate = this.normalize(addMonths(baseDate, cellOffset), min, max);
                const changedYear = currentYear < cellDate.getFullYear();
                if (!this.isInRange(cellDate, min, max) || changedYear) {
                    return null;
                }
                const isRangeStart = this.isEqual(cellDate, selectionRange.start);
                const isRangeEnd = this.isEqual(cellDate, selectionRange.end);
                const isInMiddle = !isRangeStart && !isRangeEnd;
                const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
                return {
                    formattedValue: months[cellDate.getMonth()],
                    id: `${cellUID}${cellDate.getTime()}`,
                    isFocused: this.isEqual(cellDate, focusedDate),
                    isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),
                    isWeekend: false,
                    isRangeStart: isRangeStart,
                    isRangeMid: isRangeMid,
                    isRangeEnd: isRangeEnd,
                    isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
                    isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
                    isToday: this.isEqual(cellDate, today),
                    title: this.cellTitle(cellDate),
                    value: cellDate
                };
            });
        });
    }
    isEqual(candidate, expected) {
        if (!candidate || !expected) {
            return false;
        }
        return candidate.getFullYear() === expected.getFullYear() &&
            candidate.getMonth() === expected.getMonth();
    }
    isInArray(date, dates) {
        if (!dates.length) {
            return false;
        }
        const year = date.getFullYear();
        return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear();
    }
    isInRange(candidate, min, max) {
        const candidateValue = createDate(candidate.getFullYear(), candidate.getMonth(), 1);
        const aboveMin = !min || createDate(min.getFullYear(), min.getMonth(), 1) <= candidateValue;
        const belowMax = !max || candidateValue <= createDate(max.getFullYear(), max.getMonth(), 1);
        return aboveMin && belowMax;
    }
    beginningOfPeriod(date) {
        if (!date) {
            return date;
        }
        return createDate(date.getFullYear(), 0, 1);
    }
    lastDayOfPeriod(date) {
        const month = lastMonthOfYear(date);
        return lastDayOfMonth(month);
    }
    isRangeStart(value) {
        return value.getFullYear() % 10 === 0;
    }
    move(value, action) {
        const modifier = ACTIONS$3[action];
        if (!modifier) {
            return value;
        }
        return modifier(value);
    }
    cellTitle(value) {
        return `${value.getFullYear()} ${this.value(value)}`;
    }
    navigationTitle(value) {
        return this.title(value);
    }
    title(current) {
        return current ? current.getFullYear().toString() : '';
    }
    rowLength() {
        return CELLS_LENGTH$3;
    }
    skip(value, min) {
        return durationInYears(min, value);
    }
    total(min, max) {
        return durationInYears(min, max) + 1;
    }
    value(current) {
        return current ? this.abbrMonthNames()[current.getMonth()] : '';
    }
    viewDate(date, max, viewsCount = 1) {
        const viewsInRange = this.total(date, max);
        if (viewsInRange < viewsCount) {
            const yearsToSubtract = viewsCount - viewsInRange;
            return addYears(date, -1 * yearsToSubtract);
        }
        return date;
    }
    abbrMonthNames() {
        return this._intlService.dateFormatNames({ nameType: 'abbreviated', type: 'months' });
    }
    normalize(cellDate, min, max) {
        if (cellDate < min && this.isEqual(cellDate, min)) {
            return cloneDate(min);
        }
        if (cellDate > max && this.isEqual(cellDate, max)) {
            return cloneDate(max);
        }
        return cellDate;
    }
};
YearViewService.ɵfac = function YearViewService_Factory(t) { return new (t || YearViewService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService)); };
YearViewService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: YearViewService, factory: function (t) { return YearViewService.ɵfac(t); } });
YearViewService = __decorate([ __metadata("design:paramtypes", [IntlService])
], YearViewService);

/**
 * @hidden
 *
 * The Enum which defines all possible Calendar view types.
 */
var CalendarViewEnum;
(function (CalendarViewEnum) {
    CalendarViewEnum[CalendarViewEnum["month"] = 0] = "month";
    CalendarViewEnum[CalendarViewEnum["year"] = 1] = "year";
    CalendarViewEnum[CalendarViewEnum["decade"] = 2] = "decade";
    CalendarViewEnum[CalendarViewEnum["century"] = 3] = "century";
})(CalendarViewEnum || (CalendarViewEnum = {}));

const services = {
    [CalendarViewEnum.month]: MonthViewService,
    [CalendarViewEnum.year]: YearViewService,
    [CalendarViewEnum.decade]: DecadeViewService,
    [CalendarViewEnum.century]: CenturyViewService
};
const viewOffset = (view, offset) => {
    const candidate = CalendarViewEnum[CalendarViewEnum[view + offset]];
    return candidate !== undefined ? candidate : view;
};
/**
 * @hidden
 */
let BusViewService = class BusViewService {
    constructor(injector) {
        this.injector = injector;
        this.viewChanged = new EventEmitter();
        this.bottom = CalendarViewEnum.month;
        this.top = CalendarViewEnum.century;
    }
    configure(bottom, top) {
        this.bottom = bottom;
        this.top = top;
    }
    service(view) {
        const serviceType = services[view];
        return serviceType ? this.injector.get(serviceType) : null;
    }
    moveDown(view) {
        this.move(view, -1);
    }
    moveUp(view) {
        this.move(view, 1);
    }
    moveToBottom(activeView) {
        if (activeView === this.bottom) {
            return;
        }
        this.viewChanged.emit({ view: this.bottom });
    }
    canMoveDown(view) {
        return this.bottom < view;
    }
    canMoveUp(view) {
        return view < this.top;
    }
    clamp(view) {
        if (view < this.bottom) {
            return this.bottom;
        }
        if (view > this.top) {
            return this.top;
        }
        return view;
    }
    move(view, offset) {
        const candidate = this.clamp(viewOffset(view, offset));
        if (candidate === view) {
            return;
        }
        this.viewChanged.emit({ view: candidate });
    }
};
BusViewService.ɵfac = function BusViewService_Factory(t) { return new (t || BusViewService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
BusViewService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: BusViewService, factory: function (t) { return BusViewService.ɵfac(t); } });
BusViewService = __decorate([ __metadata("design:paramtypes", [Injector])
], BusViewService);

/**
 * @hidden
 */
let WeekNamesService = class WeekNamesService {
    constructor(intl) {
        this.intl = intl;
    }
    getWeekNames(includeWeekNumber = false) {
        const weekNames = shiftWeekNames(this.intl.dateFormatNames({ nameType: 'short', type: 'days' }), this.intl.firstDay());
        return includeWeekNumber ? [''].concat(weekNames) : weekNames;
    }
};
WeekNamesService.ɵfac = function WeekNamesService_Factory(t) { return new (t || WeekNamesService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService)); };
WeekNamesService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: WeekNamesService, factory: function (t) { return WeekNamesService.ɵfac(t); } });
WeekNamesService = __decorate([ __metadata("design:paramtypes", [IntlService])
], WeekNamesService);

const DEFAULT_VIEWS_LENGTH = 2;
/**
 * @hidden
 */
let HorizontalViewListComponent = class HorizontalViewListComponent {
    constructor(bus, intl, weekService, cdr, element, renderer) {
        this.bus = bus;
        this.intl = intl;
        this.weekService = weekService;
        this.cdr = cdr;
        this.element = element;
        this.renderer = renderer;
        this.activeView = CalendarViewEnum.month;
        this.isActive = true;
        this.min = new Date(MIN_DATE);
        this.max = new Date(MAX_DATE);
        this.selectedDates = [];
        this.views = DEFAULT_VIEWS_LENGTH;
        this.showViewHeader = false;
        this.animateNavigation = false;
        this.cellClick = new EventEmitter();
        this.weekNumberCellClick = new EventEmitter();
        this.cellEnter = new EventEmitter();
        this.cellLeave = new EventEmitter();
        this.activeDateChange = new EventEmitter();
        this.getComponentClass = true;
        this.weekNames = [];
        this.dates = [];
        this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
    }
    get weekNumber() {
        return this.showWeekNumbers && this.isMonthView();
    }
    set weekNumber(showWeekNumbers) {
        this.showWeekNumbers = showWeekNumbers;
    }
    get getComponentMonthClass() {
        return this.activeView === CalendarViewEnum.month;
    }
    get getComponentYearClass() {
        return this.activeView === CalendarViewEnum.year;
    }
    get getComponentDecadeClass() {
        return this.activeView === CalendarViewEnum.decade;
    }
    get getComponentCenturyClass() {
        return this.activeView === CalendarViewEnum.century;
    }
    ngOnChanges(changes) {
        this.initService();
        if (this.weekNames.length === 0 || changes.weekNumber) {
            this.weekNames = this.weekService.getWeekNames(this.weekNumber);
        }
        if (!this.service) {
            return;
        }
        this.views = this.views || DEFAULT_VIEWS_LENGTH;
        const focusedDate = this.focusedDate;
        const viewDate = this.clampDate(this.service.viewDate(focusedDate, this.max, this.views));
        this.skip = this.service.skip(viewDate, this.min);
        this.total = this.service.total(this.min, this.max);
        const activeViewChanged = hasChange(changes, 'activeView');
        const viewsHasChanged = this.views > 0 && hasChange(changes, 'views');
        if (activeViewChanged || !this.isInDates(focusedDate) || viewsHasChanged || !this.activeDate) {
            this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
            this.activeDate = cloneDate(this.dates[0]);
            this.activeDateChange.emit(this.activeDate);
        }
    }
    ngAfterViewInit() {
        // make the calendar look the same in the different browsers
        // which also smoothens the navigation animation
        if (this.views === 1) {
            this.setTableMinWidth();
        }
    }
    ngOnDestroy() {
        this.intlSubscription.unsubscribe();
    }
    initService() {
        this.service = this.bus.service(this.activeView);
    }
    isMonthView() {
        return this.activeView === CalendarViewEnum.month;
    }
    getCaptionTitle(date) {
        return this.service.title(date);
    }
    getCaptionClass() {
        return this.isMonthView() ? 'k-month-header' : 'k-meta-header';
    }
    animateView(action) {
        const container = this.element.nativeElement;
        const table = container.querySelector('table');
        // the whole width excluding padding/margin
        const initialContainerWidth = parseFloat(getComputedStyle(container).width);
        // table width
        const tableWidth = parseFloat(getComputedStyle(table).width);
        this.renderer.setStyle(container, 'width', `${initialContainerWidth}px`);
        this.renderer.setStyle(container, 'overflow', 'visible');
        // initialize an additional view for the animation
        if (action === Action.NextView) {
            // animating Action.NextView requires adding an additional view before the rendered views
            this.nextAnimationDate = cloneDate(this.dates[0]);
        }
        else {
            // animating Action.PrevView requires adding an additional view after the rendered views
            this.prevAnimationDate = cloneDate(this.dates[this.dates.length - 1]);
        }
        // run cdr to render the additional view
        this.cdr.detectChanges();
        container.querySelectorAll('table').forEach(table => {
            this.renderer.setStyle(table, 'width', `${tableWidth}px`);
            if (this.views === 1) {
                this.renderer.setStyle(table, 'min-width', `${initialContainerWidth}px`);
            }
        });
        // we always slide by the width of 1 table
        // cross-browser compatibility is ensured by measuring the client rectangle and substracting the gap
        const tabRect = table.getBoundingClientRect();
        const containerGap = parseFloat(getComputedStyle(container).columnGap);
        const start = action === Action.NextView ? 'translateX(0)' : `translateX(-${tabRect.width + containerGap}px)`;
        const end = action === Action.NextView ? `translateX(-${tabRect.width + containerGap}px)` : 'translateX(0)';
        if (!this.animation) {
            this.animation = container.animate([
                { transform: start },
                { transform: end }
            ], {
                duration: 500,
                easing: 'ease-out'
            });
            this.animation.oncancel = this.animation.onfinish = () => {
                // clear all inline styles
                this.renderer.removeStyle(container, 'width');
                this.renderer.removeStyle(container, 'overflow');
                container.querySelectorAll('table').forEach(table => {
                    this.renderer.removeStyle(table, 'width');
                });
                // clear the animation and the animation view
                this.animation = null;
                this.nextAnimationDate = null;
                this.prevAnimationDate = null;
                // run cdr to remove additional animation view from the markup
                this.cdr.detectChanges();
            };
        }
        else {
            // if animation is already running, cancel it and show the end navigation result on multiple prev/next button clicks
            this.animation.cancel();
        }
    }
    navigate(action) {
        if (this.animateNavigation && isDocumentAvailable() && isPresent(this.element.nativeElement.animate)) {
            this.animateView(action);
        }
        const candidate = this.move(action);
        const list = this.service.datesList(candidate, this.getTake(this.skip));
        if (this.isListInRange(list)) {
            this.dates = list;
        }
        this.activeDate = cloneDate(this.dates[0]);
        this.focusedDate = cloneDate(candidate);
        this.cdr.markForCheck();
        this.activeDateChange.emit(this.activeDate);
        return cloneDate(candidate);
    }
    canNavigate(action) {
        if (!this.service) {
            return false;
        }
        return this.isListInRange(this.service.datesList(this.move(action), this.getTake(this.skip)));
    }
    setTableMinWidth() {
        const container = this.element.nativeElement;
        const table = container.querySelector('table');
        if (table) {
            const containerWidth = parseFloat(getComputedStyle(container).width);
            this.renderer.setStyle(table, 'min-width', `${containerWidth}px`);
        }
    }
    intlChange() {
        this.weekNames = this.weekService.getWeekNames(this.weekNumber);
        this.cdr.markForCheck();
    }
    clampDate(value) {
        return dateInRange(value, this.min, this.max);
    }
    move(action) {
        return this.service.move(this.dates[0] || this.focusedDate, action);
    }
    isListInRange(list) {
        const lowerBound = this.service.beginningOfPeriod(this.min);
        const upperBound = this.service.beginningOfPeriod(this.service.addToDate(this.max, 1));
        return lowerBound <= list[0] && list[list.length - 1] < upperBound;
    }
    isInDates(value) {
        return this.service.isInArray(value, this.dates);
    }
    getTake(skip) {
        return Math.min(this.total - skip, this.views);
    }
};
HorizontalViewListComponent.ɵfac = function HorizontalViewListComponent_Factory(t) { return new (t || HorizontalViewListComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(WeekNamesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
HorizontalViewListComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: HorizontalViewListComponent, selectors: [["kendo-calendar-horizontal"]], hostVars: 16, hostBindings: function HorizontalViewListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-calendar-view", ctx.getComponentClass)("k-hstack", ctx.getComponentClass)("k-align-items-start", ctx.getComponentClass)("k-justify-content-center", ctx.getComponentClass)("k-calendar-monthview", ctx.getComponentMonthClass)("k-calendar-yearview", ctx.getComponentYearClass)("k-calendar-decadeview", ctx.getComponentDecadeClass)("k-calendar-centuryview", ctx.getComponentCenturyClass);
    } }, inputs: { activeView: "activeView", isActive: "isActive", min: "min", max: "max", selectedDates: "selectedDates", views: "views", showViewHeader: "showViewHeader", animateNavigation: "animateNavigation", weekNumber: "weekNumber", focusedDate: "focusedDate", cellTemplateRef: "cellTemplateRef", weekNumberTemplateRef: "weekNumberTemplateRef", activeRangeEnd: "activeRangeEnd", cellUID: "cellUID", selectionRange: "selectionRange" }, outputs: { cellClick: "cellClick", weekNumberCellClick: "weekNumberCellClick", cellEnter: "cellEnter", cellLeave: "cellLeave", activeDateChange: "activeDateChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 3, consts: [["tableTemplate", ""], [4, "ngIf"], [4, "kFor", "kForOf"], ["role", "grid", 1, "k-content", "k-calendar-content", "k-calendar-table", 3, "ngClass"], [3, "ngClass", 4, "ngIf"], ["class", "k-calendar-thead", 4, "ngIf"], ["kendoCalendarView", "", "role", "rowgroup", "direction", "horizontal", 1, "k-calendar-tbody", 3, "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "selectionRange", "activeRangeEnd", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate", "cellClick", "weekNumberCellClick", "cellEnter", "cellLeave"], [3, "ngClass"], [1, "k-calendar-thead"], ["role", "row", 1, "k-calendar-tr"], ["class", "k-calendar-th", 4, "ngFor", "ngForOf"], [1, "k-calendar-th"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function HorizontalViewListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, HorizontalViewListComponent_ng_template_0_Template, 4, 16, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, HorizontalViewListComponent_2_Template, 1, 4, null, 1);
        ɵngcc0.ɵɵtemplate(3, HorizontalViewListComponent_3_Template, 1, 4, null, 2);
        ɵngcc0.ɵɵtemplate(4, HorizontalViewListComponent_4_Template, 1, 4, null, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.nextAnimationDate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("kForOf", ctx.dates);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.prevAnimationDate);
    } }, directives: function () { return [ɵngcc2.NgClass, ɵngcc2.NgIf, ɵngcc2.NgForOf, ViewComponent, ɵngcc2.NgTemplateOutlet, KForOf]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], HorizontalViewListComponent.prototype, "cellTemplateRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], HorizontalViewListComponent.prototype, "weekNumberTemplateRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], HorizontalViewListComponent.prototype, "activeRangeEnd", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], HorizontalViewListComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], HorizontalViewListComponent.prototype, "cellUID", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], HorizontalViewListComponent.prototype, "focusedDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HorizontalViewListComponent.prototype, "isActive", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], HorizontalViewListComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], HorizontalViewListComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HorizontalViewListComponent.prototype, "selectionRange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], HorizontalViewListComponent.prototype, "selectedDates", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], HorizontalViewListComponent.prototype, "views", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HorizontalViewListComponent.prototype, "showViewHeader", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HorizontalViewListComponent.prototype, "animateNavigation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], HorizontalViewListComponent.prototype, "weekNumber", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], HorizontalViewListComponent.prototype, "cellClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], HorizontalViewListComponent.prototype, "weekNumberCellClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], HorizontalViewListComponent.prototype, "cellEnter", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], HorizontalViewListComponent.prototype, "cellLeave", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], HorizontalViewListComponent.prototype, "activeDateChange", void 0);
__decorate([
    HostBinding("class.k-calendar-view"),
    HostBinding("class.k-hstack"),
    HostBinding("class.k-align-items-start"),
    HostBinding("class.k-justify-content-center"),
    __metadata("design:type", Boolean)
], HorizontalViewListComponent.prototype, "getComponentClass", void 0);
__decorate([
    HostBinding("class.k-calendar-monthview"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], HorizontalViewListComponent.prototype, "getComponentMonthClass", null);
__decorate([
    HostBinding("class.k-calendar-yearview"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], HorizontalViewListComponent.prototype, "getComponentYearClass", null);
__decorate([
    HostBinding("class.k-calendar-decadeview"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], HorizontalViewListComponent.prototype, "getComponentDecadeClass", null);
__decorate([
    HostBinding("class.k-calendar-centuryview"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], HorizontalViewListComponent.prototype, "getComponentCenturyClass", null);
HorizontalViewListComponent = __decorate([ __metadata("design:paramtypes", [BusViewService,
        IntlService,
        WeekNamesService,
        ChangeDetectorRef,
        ElementRef,
        Renderer2])
], HorizontalViewListComponent);

const noop$1 = () => false;
const DISABLED_DATES_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/disabled-dates/';
/**
 * @hidden
 */
let DisabledDatesService = class DisabledDatesService {
    /**
     * @hidden
     */
    constructor() {
        /**
         * Emits every time the `isDateDisabled` method changes.
         */
        this.changes = new Subject();
        /**
         * Based on the user-defined `disabledDates` input evaluates if the date is disabled.
         * If not set, returns `false`.
         */
        this.isDateDisabled = noop$1;
    }
    /**
     * Configures the `isDateDisabled` function.
     *
     * * If a function is provided, uses it as-is and passes each date to it for evaluation.
     * The time part is set to `midnight`.
     * * If a `Date[]` is provided, creates a function that checks the targeted date against
     * the listed dates and, if the targeted date is listed, marks it as disabled.
     * * If a `Day[]` is provided, creates a function that evaluates the provided days of the
     * week as disabled.
     */
    initialize(disabledDates) {
        if (typeof disabledDates === 'function') {
            this.isDateDisabled = (date) => disabledDates(getDate(date));
        }
        else if (isNumberArray(disabledDates)) {
            const disabledWeekDays = new Set(disabledDates);
            this.isDateDisabled = (date) => disabledWeekDays.has(date.getDay());
        }
        else if (isDateArray(disabledDates)) {
            const normalizedDisabledDates = new Set(disabledDates.map(date => getDate(date).getTime()));
            this.isDateDisabled = (date) => normalizedDisabledDates.has(getDate(date).getTime());
        }
        else {
            this.isDateDisabled = noop$1;
            this.notifyInvalidInput(disabledDates);
        }
        this.notifyServiceChange();
    }
    notifyInvalidInput(disabledDates) {
        if (isPresent(disabledDates) && isDevMode()) {
            throw new Error(`The 'disabledDates' value should be a function, a Day array or a Date array. Check ${DISABLED_DATES_DOC_LINK} for more information.`);
        }
    }
    notifyServiceChange() {
        this.changes.next();
    }
};
DisabledDatesService.ɵfac = function DisabledDatesService_Factory(t) { return new (t || DisabledDatesService)(); };
DisabledDatesService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DisabledDatesService, factory: function (t) { return DisabledDatesService.ɵfac(t); } });

/**
 * @hidden
 */
let HeaderComponent = class HeaderComponent {
    constructor(bus, cdr, localization, intl, disabledDatesService) {
        this.bus = bus;
        this.cdr = cdr;
        this.localization = localization;
        this.intl = intl;
        this.disabledDatesService = disabledDatesService;
        this.navigate = true;
        this.todayAvailable = true;
        this.min = new Date(MIN_DATE);
        this.max = new Date(MAX_DATE);
        this.rangeLength = 1;
        this.isPrevDisabled = true;
        this.isNextDisabled = true;
        this.showNavigationButtons = false;
        this.todayButtonClick = new EventEmitter();
        this.prevButtonClick = new EventEmitter();
        this.nextButtonClick = new EventEmitter();
        this.getComponentClass = true;
        this.subscriptions = new Subscription();
    }
    ngOnInit() {
        this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
        this.subscriptions.add(this.localization.changes.subscribe(this.l10nChange.bind(this)));
        this.subscriptions.add(this.disabledDatesService.changes.subscribe(this.setTodayAvailability.bind(this)));
    }
    ngOnChanges(_) {
        const service = this.bus.service(this.activeView);
        if (!service) {
            return;
        }
        this.activeViewValue = CalendarViewEnum[this.activeView];
        this.todayMessage = this.localization.get('today');
        this.setTodayAvailability();
        this.navigate = this.bus.canMoveUp(this.activeView);
        this.title = this.getTitle();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    handleTodayClick() {
        if (!this.todayAvailable) {
            return;
        }
        this.bus.moveToBottom(this.activeView);
        this.todayButtonClick.emit(dateInRange(getToday(), this.min, this.max));
    }
    handleNavigation() {
        if (!this.navigate) {
            return;
        }
        this.bus.moveUp(this.activeView);
    }
    intlChange() {
        if (this.currentDate && this.bus.service(this.activeView)) {
            this.title = this.getTitle();
            this.cdr.markForCheck();
        }
    }
    l10nChange() {
        this.prevButtonTitle = this.localization.get('prevButtonTitle');
        this.nextButtonTitle = this.localization.get('nextButtonTitle');
        this.todayMessage = this.localization.get('today');
        this.cdr.markForCheck();
    }
    getTitle() {
        if (!this.currentDate) {
            return '';
        }
        const service = this.bus.service(this.activeView);
        const take = this.rangeLength - 1;
        const title = service.title(this.currentDate);
        const nextDate = service.addToDate(this.currentDate, take);
        if (take < 1 || !service.isInRange(nextDate, this.min, this.max)) {
            return title;
        }
        return `${title} - ${service.title(nextDate)}`;
    }
    setTodayAvailability() {
        const today = getToday();
        const isTodayInRange = isInRange(today, getDate(this.min), getDate(this.max));
        const isDisabled = this.disabledDatesService.isDateDisabled(today);
        this.todayAvailable = isTodayInRange && !isDisabled;
        this.cdr.markForCheck();
    }
};
HeaderComponent.ɵfac = function HeaderComponent_Factory(t) { return new (t || HeaderComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService)); };
HeaderComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: HeaderComponent, selectors: [["kendo-calendar-header"]], hostVars: 4, hostBindings: function HeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-calendar-header", ctx.getComponentClass)("k-hstack", ctx.getComponentClass);
    } }, inputs: { min: "min", max: "max", rangeLength: "rangeLength", isPrevDisabled: "isPrevDisabled", isNextDisabled: "isNextDisabled", showNavigationButtons: "showNavigationButtons", activeView: "activeView", currentDate: "currentDate", templateRef: "templateRef" }, outputs: { todayButtonClick: "todayButtonClick", prevButtonClick: "prevButtonClick", nextButtonClick: "nextButtonClick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 9, vars: 23, consts: [[1, "k-button", "k-button-md", "k-rounded-md", "k-button-flat", "k-button-flat-base", "k-calendar-title", 3, "kendoEventsOutsideAngular", "scope"], [3, "ngIf"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-spacer"], [1, "k-calendar-nav", "k-hstack"], ["class", "k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-icon-button k-prev-view", "type", "button", 3, "disabled", "title", "click", 4, "ngIf"], [1, "k-today", "k-nav-today", 3, "kendoEventsOutsideAngular", "scope"], ["class", "k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-icon-button k-next-view", "type", "button", 3, "disabled", "title", "click", 4, "ngIf"], ["type", "button", 1, "k-button", "k-button-md", "k-rounded-md", "k-button-flat", "k-button-flat-base", "k-icon-button", "k-prev-view", 3, "disabled", "title", "click"], [1, "k-icon", "k-i-arrow-60-left"], ["type", "button", 1, "k-button", "k-button-md", "k-rounded-md", "k-button-flat", "k-button-flat-base", "k-icon-button", "k-next-view", 3, "disabled", "title", "click"], [1, "k-icon", "k-i-arrow-60-right"]], template: function HeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtemplate(1, HeaderComponent_ng_template_1_Template, 1, 1, "ng-template", 1);
        ɵngcc0.ɵɵtemplate(2, HeaderComponent_ng_template_2_Template, 0, 0, "ng-template", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "span", 3);
        ɵngcc0.ɵɵelementStart(4, "span", 4);
        ɵngcc0.ɵɵtemplate(5, HeaderComponent_button_5_Template, 2, 3, "button", 5);
        ɵngcc0.ɵɵelementStart(6, "span", 6);
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, HeaderComponent_button_8_Template, 2, 3, "button", 7);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-disabled", !ctx.navigate);
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(15, _c2, ctx.handleNavigation))("scope", ctx);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.templateRef);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.templateRef)("ngTemplateOutlet", ctx.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction3(17, _c3, ctx.title, ctx.activeViewValue, ctx.currentDate));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showNavigationButtons);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("k-disabled", !ctx.todayAvailable);
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(21, _c2, ctx.handleTodayClick))("scope", ctx);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.todayMessage, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showNavigationButtons);
    } }, directives: [ɵngcc4.EventsOutsideAngularDirective, ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], HeaderComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], HeaderComponent.prototype, "currentDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], HeaderComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], HeaderComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], HeaderComponent.prototype, "rangeLength", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], HeaderComponent.prototype, "templateRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HeaderComponent.prototype, "isPrevDisabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HeaderComponent.prototype, "isNextDisabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], HeaderComponent.prototype, "showNavigationButtons", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], HeaderComponent.prototype, "todayButtonClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], HeaderComponent.prototype, "prevButtonClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], HeaderComponent.prototype, "nextButtonClick", void 0);
__decorate([
    HostBinding("class.k-calendar-header"),
    HostBinding("class.k-hstack"),
    __metadata("design:type", Boolean)
], HeaderComponent.prototype, "getComponentClass", void 0);
HeaderComponent = __decorate([ __metadata("design:paramtypes", [BusViewService,
        ChangeDetectorRef,
        LocalizationService,
        IntlService,
        DisabledDatesService])
], HeaderComponent);

const KEY_TO_ACTION = {
    '33': Action.PrevView,
    '34': Action.NextView,
    '35': Action.LastInView,
    '36': Action.FirstInView,
    '37': Action.Left,
    '38': Action.Up,
    '39': Action.Right,
    '40': Action.Down,
    'meta+38': Action.UpperView,
    'meta+40': Action.LowerView
};
/**
 * @hidden
 */
let NavigationService = class NavigationService {
    constructor(bus) {
        this.bus = bus;
    }
    action(event) {
        const action = `${event.ctrlKey || event.metaKey ? 'meta+' : ''}${event.keyCode}`;
        return KEY_TO_ACTION[action];
    }
    move(value, action, activeView) {
        const service = this.bus.service(activeView);
        if (!service) {
            return value;
        }
        if (action === Action.UpperView && this.bus.canMoveUp(activeView)) {
            this.bus.moveUp(activeView);
            return value;
        }
        if (action === Action.LowerView && this.bus.canMoveDown(activeView)) {
            this.bus.moveDown(activeView);
            return value;
        }
        return service.move(value, action);
    }
};
NavigationService.ɵfac = function NavigationService_Factory(t) { return new (t || NavigationService)(ɵngcc0.ɵɵinject(BusViewService)); };
NavigationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NavigationService, factory: function (t) { return NavigationService.ɵfac(t); } });
NavigationService = __decorate([ __metadata("design:paramtypes", [BusViewService])
], NavigationService);

/**
 * @hidden
 */
let SelectionService = class SelectionService {
    constructor(bus) {
        this.bus = bus;
    }
    performSelection(args) {
        let { date, modifiers, selectionMode, activeViewEnum, rangePivot } = args;
        let selectedDates = args.selectedDates.slice();
        if (selectionMode === 'multiple') {
            if (modifiers.ctrlKey || modifiers.metaKey) {
                if (this.isDateSelected(selectedDates, date)) {
                    selectedDates = selectedDates.filter(item => !isEqual(item, date));
                }
                else {
                    selectedDates.push(date);
                }
                rangePivot = date;
            }
            else if (modifiers.shiftKey) {
                const [start, end] = sortDates([rangePivot || date, date]);
                selectedDates = this.bus.service(activeViewEnum).dateRange(start, end);
                rangePivot = date > selectedDates[0] ? selectedDates[0] : last(selectedDates);
            }
            else {
                selectedDates = [date];
                rangePivot = date;
            }
        }
        else {
            selectedDates = [date];
            rangePivot = date;
        }
        return { selectedDates, rangePivot };
    }
    isDateSelected(selectedDates, date) {
        return selectedDates.some(item => isEqual(item, date));
    }
};
SelectionService.ɵfac = function SelectionService_Factory(t) { return new (t || SelectionService)(ɵngcc0.ɵɵinject(BusViewService)); };
SelectionService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SelectionService, factory: function (t) { return SelectionService.ɵfac(t); } });
SelectionService = __decorate([ __metadata("design:paramtypes", [BusViewService])
], SelectionService);

/**
 * Used for rendering the cell content of the Calendar. To define the cell template, nest an `<ng-template>` tag
 * with the `kendoCalendarCellTemplate` directive inside the component tag. The template context is set to the
 * current component. To get a reference to the current date, use the `let-date` directive. To provide more details
 * about the current cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.
 *
 * For more examples, refer to the article on [templates]({% slug templates_calendar %}).
 *
 * > `kendoCalendarCellTemplate` is equivalent to
 * > [`kendoCalendarMonthCellTemplate`]({% slug api_dateinputs_monthcelltemplatedirective %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * styles: ['.custom { color: red; }'],
 * template: `
 *  <kendo-calendar>
 *    <ng-template kendoCalendarCellTemplate let-date>
 *      <span class="custom">{{date.getDate()}}</span>
 *    </ng-template>
 *  </kendo-calendar>
 * `
 * })
 * export class AppComponent { }
 * ```
 */
let CellTemplateDirective = class CellTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
CellTemplateDirective.ɵfac = function CellTemplateDirective_Factory(t) { return new (t || CellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
CellTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CellTemplateDirective, selectors: [["", "kendoCalendarCellTemplate", ""]] });
CellTemplateDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], CellTemplateDirective);

/**
 * Used for rendering the month cell content of the Calendar. To define the month cell template, nest an `<ng-template>` tag
 * with the `kendoCalendarMonthCellTemplate` directive inside the component tag. The template context is set to the current
 * component. To get a reference to the current date, use the `let-date` directive. To provide more details about the current
 * month cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.
 *
 * For more examples, refer to the article on [templates]({% slug templates_calendar %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * styles: ['.custom { color: red; }'],
 * template: `
 *  <kendo-calendar>
 *    <ng-template kendoCalendarMonthCellTemplate let-context="cellContext">
 *      <span class="custom">{{context.formattedValue}}</span>
 *    </ng-template>
 *  </kendo-calendar>
 * `
 * })
 * export class AppComponent { }
 * ```
 */
let MonthCellTemplateDirective = class MonthCellTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
MonthCellTemplateDirective.ɵfac = function MonthCellTemplateDirective_Factory(t) { return new (t || MonthCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
MonthCellTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MonthCellTemplateDirective, selectors: [["", "kendoCalendarMonthCellTemplate", ""]] });
MonthCellTemplateDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], MonthCellTemplateDirective);

/**
 * Used for rendering the year cell content of the Calendar. To define the year cell template, nest an
 * `<ng-template>` tag with the `kendoCalendarYearCellTemplate` directive inside the component tag.
 * The template context is set to the current component. To get a reference to the current date, use
 * the `let-date` directive. To provide more details about the current year cell, get a reference to the
 * current `cellContext` by using the `let-cellContext` directive.
 *
 * For more examples, refer to the article on [templates]({% slug templates_calendar %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * styles: ['.custom { color: red; }'],
 * template: `
 *  <kendo-calendar [activeView]="activeView">
 *    <ng-template kendoCalendarYearCellTemplate let-context="cellContext">
 *      <span class="custom">{{context.formattedValue}}</span>
 *    </ng-template>
 *  </kendo-calendar>
 * `
 * })
 * export class AppComponent {
 *  public activeView: CalendarView = 'year';
 * }
 * ```
 */
let YearCellTemplateDirective = class YearCellTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
YearCellTemplateDirective.ɵfac = function YearCellTemplateDirective_Factory(t) { return new (t || YearCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
YearCellTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: YearCellTemplateDirective, selectors: [["", "kendoCalendarYearCellTemplate", ""]] });
YearCellTemplateDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], YearCellTemplateDirective);

/**
 * Used for rendering the decade cell content of the Calendar. To define the decade cell template, nest an `<ng-template>`
 * tag with the `kendoCalendarDecadeCellTemplate` directive inside the component tag. The template context is set to the
 * current component. To get a reference to the current date, use the `let-date` directive. To provide more details about
 * the current decade cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.
 *
 * For more examples, refer to the article on [templates]({% slug templates_calendar %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * styles: ['.custom { color: red; }'],
 * template: `
 *  <kendo-calendar [activeView]="activeView">
 *    <ng-template kendoCalendarDecadeCellTemplate let-context="cellContext">
 *      <span class="custom">{{context.formattedValue}}</span>
 *    </ng-template>
 *  </kendo-calendar>
 * `
 * })
 * export class AppComponent {
 *  public activeView: CalendarView = 'decade';
 * }
 * ```
 */
let DecadeCellTemplateDirective = class DecadeCellTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
DecadeCellTemplateDirective.ɵfac = function DecadeCellTemplateDirective_Factory(t) { return new (t || DecadeCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
DecadeCellTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DecadeCellTemplateDirective, selectors: [["", "kendoCalendarDecadeCellTemplate", ""]] });
DecadeCellTemplateDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], DecadeCellTemplateDirective);

/**
 * Used for rendering the century cell content of the Calendar. To define the century cell template, nest an `<ng-template>`
 * tag with the `kendoCalendarCenturyCellTemplate` directive inside the component tag. The template context is set to the
 * current component. To get a reference to the current date, use the `let-date` directive. To provide more details about
 * the current century cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.
 *
 * For more examples, refer to the article on [templates]({% slug templates_calendar %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * styles: ['.custom { color: red; }'],
 * template: `
 *  <kendo-calendar [activeView]="activeView">
 *    <ng-template kendoCalendarCenturyCellTemplate let-context="cellContext">
 *      <span class="custom">{{context.formattedValue}}</span>
 *    </ng-template>
 *  </kendo-calendar>
 * `
 * })
 * export class AppComponent {
 *  public activeView: CalendarView = 'century';
 * }
 * ```
 */
let CenturyCellTemplateDirective = class CenturyCellTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
CenturyCellTemplateDirective.ɵfac = function CenturyCellTemplateDirective_Factory(t) { return new (t || CenturyCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
CenturyCellTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CenturyCellTemplateDirective, selectors: [["", "kendoCalendarCenturyCellTemplate", ""]] });
CenturyCellTemplateDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], CenturyCellTemplateDirective);

/**
 * Used for rendering the week number cell content in the month view of the Calendar. To define the month week number cell template,
 * nest an `<ng-template>` tag with the `kendoCalendarWeekNumberCellTemplate` directive inside the component tag. The template
 * context is set to the current component. To get a reference to the current date, use the `let-date` directive. To provide more
 * details about the current week number cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.
 *
 * For more examples, refer to the article on [templates]({% slug templates_calendar %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * styles: ['.custom { color: red; }'],
 * template: `
 *  <kendo-calendar [weekNumber]="true">
 *    <ng-template kendoCalendarWeekNumberCellTemplate let-context="cellContext">
 *      <span class="custom">{{context.formattedValue}}</span>
 *    </ng-template>
 *  </kendo-calendar>
 * `
 * })
 * export class AppComponent { }
 * ```
 */
let WeekNumberCellTemplateDirective = class WeekNumberCellTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
WeekNumberCellTemplateDirective.ɵfac = function WeekNumberCellTemplateDirective_Factory(t) { return new (t || WeekNumberCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
WeekNumberCellTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: WeekNumberCellTemplateDirective, selectors: [["", "kendoCalendarWeekNumberCellTemplate", ""]] });
WeekNumberCellTemplateDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], WeekNumberCellTemplateDirective);

/**
 * Used for rendering the header title of the Calendar. To define the header title template, nest an `<ng-template>` tag
 * with the `kendoCalendarHeaderTitleTemplate` directive inside the component tag. The template context is set to the
 * current component. To get a reference to the current title, use the `let-title` directive. To provide more details about
 * the current title, get a reference to the current `date` by using the `let-date` directive or get a reference to the
 * current active view  by using the `let-activeView` directive.
 *
 * For more examples, refer to the article on [templates]({% slug templates_calendar %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * styles: ['.custom { color: red; }'],
 * template: `
 *  <kendo-calendar>
 *    <ng-template kendoCalendarHeaderTitleTemplate let-title>
 *      <span class="custom">{{title}}</span>
 *    </ng-template>
 *  </kendo-calendar>
 * `
 * })
 * export class AppComponent { }
 * ```
 */
let HeaderTitleTemplateDirective = class HeaderTitleTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
HeaderTitleTemplateDirective.ɵfac = function HeaderTitleTemplateDirective_Factory(t) { return new (t || HeaderTitleTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
HeaderTitleTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: HeaderTitleTemplateDirective, selectors: [["", "kendoCalendarHeaderTitleTemplate", ""]] });
HeaderTitleTemplateDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], HeaderTitleTemplateDirective);

/**
 * @hidden
 */
const minValidator = (minValue) => {
    return (control) => {
        const err = {
            minError: {
                minValue: minValue,
                value: control.value
            }
        };
        if (!minValue || !control.value) {
            return null;
        }
        return control.value < minValue ? err : null;
    };
};

/**
 * @hidden
 */
const maxValidator = (maxValue) => {
    return (control) => {
        const err = {
            maxError: {
                maxValue: maxValue,
                value: control.value
            }
        };
        if (!maxValue || !control.value) {
            return null;
        }
        return control.value > maxValue ? err : null;
    };
};

const noop$2 = () => null;
/**
 * @hidden
 */
const disabledDatesRangeValidator = (isDateDisabled) => {
    if (!isPresent(isDateDisabled)) {
        return noop$2;
    }
    return (selectedRange) => {
        const isRangeComplete = isPresent(selectedRange) && isPresent(selectedRange.start) && isPresent(selectedRange.end);
        if (!isRangeComplete || selectedRange.start > selectedRange.end) {
            return null;
        }
        const disabledDates = disabledDatesInRange(selectedRange.start, selectedRange.end, isDateDisabled);
        const error = {
            disabledDatesInRange: disabledDates
        };
        return disabledDates.length ? error : null;
    };
};

/**
 * @hidden
 */
class PickerService {
    constructor() {
        this.onFocus = new EventEmitter();
        this.onBlur = new EventEmitter();
        this.sameDateSelected = new EventEmitter();
        this.dateCompletenessChange = new EventEmitter();
    }
}
PickerService.ɵfac = function PickerService_Factory(t) { return new (t || PickerService)(); };
PickerService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: PickerService, factory: PickerService.ɵfac });

const BOTTOM_VIEW_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview';
const TOP_VIEW_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview';
const MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min';
const MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max';
const VALUE_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json';
/**
 * @hidden
 */
const RANGE_CALENDAR_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => MultiViewCalendarComponent) //tslint:disable-line:no-use-before-declare
};
/**
 * @hidden
 */
const RANGE_CALENDAR_RANGE_VALIDATORS = {
    multi: true,
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => MultiViewCalendarComponent) //tslint:disable-line:no-use-before-declare
};
/**
 * Represents the Kendo UI MultiViewCalendar component for Angular.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-multiviewcalendar></kendo-multiviewcalendar>
 * `
 * })
 * export class AppComponent { }
 * ```
 */
let MultiViewCalendarComponent = class MultiViewCalendarComponent {
    constructor(bus, element, navigator, renderer, cdr, zone, disabledDatesService, selectionService, pickerService) {
        this.bus = bus;
        this.element = element;
        this.navigator = navigator;
        this.renderer = renderer;
        this.cdr = cdr;
        this.zone = zone;
        this.disabledDatesService = disabledDatesService;
        this.selectionService = selectionService;
        this.pickerService = pickerService;
        /**
         * @hidden
         */
        this.id = guid();
        /**
         * Determines whether the built-in min or max validators are enforced when validating a form.
         */
        this.rangeValidation = false;
        /**
         * Determines whether the built-in validator for disabled
         * date ranges is enforced when validating a form
         * ([see example]({% slug disabled_dates_multiviewcalendar %}#toc-validation)).
         */
        this.disabledDatesRangeValidation = false;
        /**
         * Sets the Calendar selection mode
         * ([see example]({% slug multiple_selection_multiviewcalendar %})).
         *
         * The available values are:
         * * `single` (default)
         * * `multiple`
         */
        this.selection = 'single';
        /**
         * Sets or gets the `disabled` property of the Calendar and
         * determines whether the component is active
         * ([see example]({% slug disabled_multiviewcalendar %})).
         */
        this.disabled = false;
        /**
         * Sets or gets the `tabindex` property of the Calendar. Based on the
         * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,
         * it determines whether the component is focusable.
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.isActive = false;
        /**
         * @hidden
         */
        this.isHeaderActive = false;
        /**
         * Defines the active view that the Calendar initially renders
         * ([see example]({% slug activeview_multiviewcalendar %})).
         * By default, the active view is `month`.
         *
         * > You have to set `activeView` within the `topView`-`bottomView` range.
         */
        this.activeView = CalendarViewEnum[CalendarViewEnum.month];
        /**
         * Defines the bottommost view, to which the user can navigate
         * ([see example]({% slug dates_multiviewcalendar %}#toc-partial-dates)).
         */
        this.bottomView = CalendarViewEnum[CalendarViewEnum.month];
        /**
         * Defines the topmost view, to which the user can navigate.
         */
        this.topView = CalendarViewEnum[CalendarViewEnum.century];
        /**
         * Determines whether to display a header for every view (for example the month name).
         */
        this.showViewHeader = false;
        /**
         * Determines whether to enable animation when navigating to previous/next view.
         *
         * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
         *
         * @default false
         */
        this.animateNavigation = false;
        /**
         * Determines whether to display a week number column in the `month` view
         * ([see example]({% slug weeknumcolumn_multiviewcalendar %})).
         */
        this.weekNumber = false;
        /**
         * Sets or gets the `views` property of the Calendar and
         * defines the number of rendered months.
         */
        this.views = 2;
        /**
         * Fires when the active view is changed
         * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).
         */
        this.activeViewChange = new EventEmitter();
        /**
         * Fires when navigating in the currently active view
         * ([more information and example]({% slug events_multiviewcalendar %})).
         */
        this.navigate = new EventEmitter();
        /**
         * Fires when a view cell is entered
         * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).
         */
        this.cellEnter = new EventEmitter();
        /**
         * Fires when a view cell is leaved
         * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).
         */
        this.cellLeave = new EventEmitter();
        /**
         * Fires when the value is changed
         * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.blurEvent = new EventEmitter();
        this.cellUID = guid();
        this.isHovered = false;
        this.isPrevDisabled = true;
        this.isNextDisabled = true;
        this.prevView = Action.PrevView;
        this.nextView = Action.NextView;
        this.selectedDates = [];
        this._min = new Date(MIN_DATE);
        this._max = new Date(MAX_DATE);
        this._focusedDate = getToday();
        this.resolvedPromise = Promise.resolve();
        this.onControlChange = noop;
        this.onControlTouched = noop;
        this.onValidatorChange = noop;
        this.minValidateFn = noop;
        this.maxValidateFn = noop;
        this.disabledDatesRangeValidateFn = noop;
        this.subscriptions = new Subscription();
        this.setClasses(element.nativeElement);
    }
    /**
     * Sets or gets the `focusedDate` property of the Calendar and
     * defines the focused date of the component
     * ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).
     *
     * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.
     */
    set focusedDate(focusedDate) {
        this._focusedDate = focusedDate || getToday();
    }
    get focusedDate() {
        return this._focusedDate;
    }
    /**
     * Sets or gets the `min` property of the Calendar and
     * defines the minimum allowed date value.
     * By default, the `min` value is `1900-1-1`.
     */
    set min(min) {
        this._min = min || new Date(MIN_DATE);
    }
    get min() {
        return this._min;
    }
    /**
     * Sets or gets the `max` property of the Calendar and
     * defines the maximum allowed date value.
     * By default, the `max` value is `2099-12-31`.
     */
    set max(max) {
        this._max = max || new Date(MAX_DATE);
    }
    get max() {
        return this._max;
    }
    /**
     * Sets or gets the `value` property of the Calendar and defines the selected value of the component.
     *
     * > The `value` has to be a valid
     * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)
     * instance when in `single` selection mode or an array of valid JavaScript Date instances when in `multiple` selection mode.
     */
    get value() {
        return this._value;
    }
    set value(candidate) {
        this.verifyValue(candidate);
        this._value = Array.isArray(candidate) ?
            candidate.filter(date => isPresent(date)).map(element => cloneDate(element)) :
            cloneDate(candidate);
        const selection = [].concat(candidate).filter(date => isPresent(date)).map(date => cloneDate(date));
        if (!areDatesEqual(selection, this.selectedDates)) {
            const lastSelected = last(selection);
            this.rangePivot = cloneDate(lastSelected);
            this.focusedDate = cloneDate(lastSelected) || this.focusedDate;
            this.selectedDates = selection;
        }
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Sets the dates of the MultiViewCalendar that will be disabled
     * ([see example]({% slug disabled_dates_multiviewcalendar %})).
     */
    set disabledDates(value) {
        this.disabledDatesService.initialize(value);
    }
    /**
     * Sets or gets the `selectionRange` property of the Calendar and
     * defines the selection range of the component
     * ([see example]({% slug dates_multiviewcalendar %}#toc-selection-range)).
     */
    set selectionRange(range$$1) {
        this._selectionRange = range$$1;
        if (this.disabledDatesRangeValidation) {
            this.onValidatorChange();
        }
    }
    get selectionRange() {
        return this._selectionRange;
    }
    /**
     * @hidden
     *
     * Defines the template for each cell.
     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
     */
    set cellTemplateRef(template) {
        this._cellTemplateRef = template;
    }
    get cellTemplateRef() {
        return this._cellTemplateRef || this.cellTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for each month cell.
     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
     */
    set monthCellTemplateRef(template) {
        this._monthCellTemplateRef = template;
    }
    get monthCellTemplateRef() {
        return this._monthCellTemplateRef || this.monthCellTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for each year cell.
     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
     */
    set yearCellTemplateRef(template) {
        this._yearCellTemplateRef = template;
    }
    get yearCellTemplateRef() {
        return this._yearCellTemplateRef || this.yearCellTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for each decade cell.
     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
     */
    set decadeCellTemplateRef(template) {
        this._decadeCellTemplateRef = template;
    }
    get decadeCellTemplateRef() {
        return this._decadeCellTemplateRef || this.decadeCellTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for each century cell.
     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
     */
    set centuryCellTemplateRef(template) {
        this._centuryCellTemplateRef = template;
    }
    get centuryCellTemplateRef() {
        return this._centuryCellTemplateRef || this.centuryCellTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for the week cell.
     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
     */
    set weekNumberTemplateRef(template) {
        this._weekNumberTemplateRef = template;
    }
    get weekNumberTemplateRef() {
        return this._weekNumberTemplateRef || this.weekNumberTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for the header title.
     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
     */
    set headerTitleTemplateRef(template) {
        this._headerTitleTemplateRef = template;
    }
    get headerTitleTemplateRef() {
        return this._headerTitleTemplateRef || this.headerTitleTemplate;
    }
    get activeViewEnum() {
        const activeView = CalendarViewEnum[this.activeView];
        return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;
    }
    get bottomViewEnum() {
        return CalendarViewEnum[this.bottomView];
    }
    get topViewEnum() {
        return CalendarViewEnum[this.topView];
    }
    get widgetId() {
        return this.id;
    }
    get calendarTabIndex() {
        return this.disabled ? undefined : this.tabIndex;
    }
    get ariaDisabled() {
        return this.disabled;
    }
    get ariaActivedescendant() {
        return this.cellUID + this.focusedDate.getTime();
    }
    /**
     * @hidden
     */
    handleFocusout(event) {
        const relatedTarget = event.relatedTarget;
        if (!this.element.nativeElement.contains(relatedTarget)) {
            this.blurEvent.emit(event);
            this.onControlTouched();
        }
        this.isActive = false;
        this.isHovered = false; //ensure that hovered is also not active
        this.isHeaderActive = this.headerElement.nativeElement.contains(relatedTarget);
    }
    /**
     * @hidden
     */
    handleFocus() {
        this.isActive = true;
        this.isHeaderActive = false;
    }
    /**
     * @hidden
     */
    handleMouseEnter() {
        this.isHovered = true;
    }
    /**
     * @hidden
     */
    handleMouseLeave() {
        this.isHovered = false;
    }
    /**
     * @hidden
     */
    handleMousedown(event) {
        event.preventDefault();
    }
    /**
     * @hidden
     */
    handleClick() {
        if (this.isActive) {
            return;
        }
        this.focus();
    }
    /**
     * @hidden
     */
    keydown(event) {
        if (this.isHeaderActive) {
            return;
        }
        if (event.keyCode === Keys.Enter) {
            if (isPresent(this.pickerService)) {
                event.preventDefault(); // Don't submit form from Datepicker popup
            }
            this.performSelection(this.focusedDate, event);
        }
        const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(event), this.activeViewEnum), this.min, this.max);
        if (isEqual(this.focusedDate, candidate)) {
            return;
        }
        this.focusedDate = candidate;
        event.preventDefault();
        const isSameView = this.bus.service(this.activeViewEnum).isInArray(this.focusedDate, this.viewList.dates);
        if (!isSameView) {
            this.emitNavigate(this.focusedDate);
        }
    }
    ngOnInit() {
        this.subscriptions.add(this.bus.viewChanged.subscribe(({ view }) => {
            this.activeView = CalendarViewEnum[view];
            this.activeViewChange.emit(this.activeView);
            this.cdr.detectChanges();
            this.updateButtonState();
        }));
    }
    ngOnChanges(changes) {
        this.verifyChanges();
        this.bus.configure(this.bottomViewEnum, this.topViewEnum);
        if (hasExistingValue(changes, 'focusedDate')) {
            const focusedDate = changes.focusedDate.currentValue;
            this.focusedDate = dateInRange(focusedDate, this.min, this.max);
        }
        if (changes.min || changes.max || changes.rangeValidation || changes.disabledDates || changes.disabledDatesRangeValidation) {
            this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;
            this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;
            this.disabledDatesRangeValidateFn = this.disabledDatesRangeValidation ? disabledDatesRangeValidator(this.disabledDatesService.isDateDisabled) : noop;
            this.onValidatorChange();
        }
        if (changes.min || changes.max || changes.focusedDate || changes.activeView) {
            this.updateButtonState();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    ngAfterViewInit() {
        this.updateButtonState();
    }
    /**
     * Focuses the host element of the Calendar.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="multiviewcalendar.focus()">Focus calendar</button>
     *  <kendo-multiviewcalendar #multiviewcalendar></kendo-multiviewcalendar>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    focus() {
        if (!this.element) {
            return;
        }
        this.element.nativeElement.focus();
    }
    /**
     * Blurs the Calendar component.
     */
    blur() {
        if (!this.element) {
            return;
        }
        this.element.nativeElement.blur();
    }
    /**
     * @hidden
     */
    handleHeaderFocus() {
        this.isHeaderActive = true;
    }
    /**
     * @hidden
     */
    handleDateChange(args) {
        const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);
        const availableDates = args.selectedDates.filter(date => !this.disabledDatesService.isDateDisabled(date));
        this.focusedDate = args.focusedDate || this.focusedDate;
        const sameDates = !canNavigateDown && areDatesEqual(availableDates, this.selectedDates);
        if (this.disabled || sameDates) {
            return;
        }
        if (canNavigateDown) {
            this.bus.moveDown(this.activeViewEnum);
            return;
        }
        if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {
            return;
        }
        this.selectedDates = availableDates.map(date => cloneDate(date));
        this.value = this.parseSelectionToValue(availableDates);
        this.onControlChange(this.parseSelectionToValue(availableDates));
        this.valueChange.emit(this.parseSelectionToValue(availableDates));
    }
    /**
     * @hidden
     */
    handleTodayButtonClick(args) {
        const todayDate = args.focusedDate;
        const isSameView = this.bus.service(this.activeViewEnum).isInArray(todayDate, this.viewList.dates);
        const isBottomView = !this.bus.canMoveDown(this.activeViewEnum);
        if (!isSameView && isBottomView) {
            this.emitNavigate(todayDate);
        }
        this.handleDateChange(args);
    }
    /**
     * @hidden
     */
    setActiveDate(date) {
        this.activeDate = cloneDate(date);
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    writeValue(candidate) {
        this.verifyValue(candidate);
        this.value = candidate;
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onControlChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onControlTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    validate(control) {
        return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesRangeValidateFn(this.selectionRange);
    }
    /**
     * @hidden
     */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /**
     * @hidden
     */
    activeCellTemplate() {
        switch (this.activeViewEnum) {
            case CalendarViewEnum.month:
                return this.monthCellTemplateRef || this.cellTemplateRef;
            case CalendarViewEnum.year:
                return this.yearCellTemplateRef;
            case CalendarViewEnum.decade:
                return this.decadeCellTemplateRef;
            case CalendarViewEnum.century:
                return this.centuryCellTemplateRef;
            default:
                return null;
        }
    }
    /**
     * @hidden
     */
    navigateView(action) {
        this.focusedDate = this.viewList.navigate(action);
        this.updateButtonState();
        this.emitNavigate(this.focusedDate);
    }
    /**
     * @hidden
     */
    emitNavigate(focusedDate) {
        const activeView = CalendarViewEnum[this.activeViewEnum];
        this.navigate.emit({ activeView, focusedDate });
    }
    /**
     * @hidden
     */
    emitCellEvent(emitter, args) {
        if (hasObservers(emitter)) {
            this.zone.run(() => {
                emitter.emit(args);
            });
        }
    }
    /**
     * @hidden
     */
    handleCellClick({ date, modifiers }) {
        this.performSelection(date, modifiers);
        const isSameView = this.bus.service(this.activeViewEnum).isInArray(this.focusedDate, this.viewList.dates);
        if (!isSameView) {
            this.emitNavigate(this.focusedDate);
        }
    }
    /**
     * @hidden
     */
    handleWeekNumberClick(dates) {
        if (this.selection === 'single') {
            return;
        }
        this.zone.run(() => {
            this.handleDateChange({
                selectedDates: dates,
                focusedDate: last(dates)
            });
        });
    }
    setClasses(element) {
        this.renderer.addClass(element, 'k-widget');
        this.renderer.addClass(element, 'k-calendar');
        this.renderer.addClass(element, 'k-calendar-range');
    }
    verifyChanges() {
        if (!isDevMode()) {
            return;
        }
        if (this.min > this.max) {
            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);
        }
        if (this.bottomViewEnum > this.topViewEnum) {
            throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK} and ${TOP_VIEW_DOC_LINK}.`);
        }
    }
    verifyValue(candidate) {
        if (!isDevMode()) {
            return;
        }
        if (this.selection === 'single' && candidate && !(candidate instanceof Date)) {
            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK} for possible resolution.`);
        }
        else if (this.selection === 'multiple' && candidate && Array.isArray(candidate)) {
            const onlyDates = candidate.every(value => value instanceof Date);
            if (!onlyDates) {
                throw new Error(`The 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK} for possible resolution.`);
            }
        }
    }
    updateButtonState() {
        this.resolvedPromise.then(() => {
            this.isPrevDisabled = !this.viewList.canNavigate(this.prevView);
            this.isNextDisabled = !this.viewList.canNavigate(this.nextView);
            this.cdr.markForCheck();
        });
    }
    parseSelectionToValue(selection) {
        selection = selection || [];
        return this.selection === 'single' ? cloneDate(last(selection)) : selection.map(date => cloneDate(date));
    }
    performSelection(date, selectionModifiers) {
        const selection = this.selectionService.performSelection({
            date: date,
            modifiers: selectionModifiers,
            selectionMode: this.selection,
            activeViewEnum: this.activeViewEnum,
            rangePivot: this.rangePivot,
            selectedDates: this.selectedDates
        });
        this.rangePivot = selection.rangePivot;
        this.handleDateChange({
            selectedDates: selection.selectedDates,
            focusedDate: date
        });
    }
};
MultiViewCalendarComponent.ɵfac = function MultiViewCalendarComponent_Factory(t) { return new (t || MultiViewCalendarComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(PickerService, 8)); };
MultiViewCalendarComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MultiViewCalendarComponent, selectors: [["kendo-multiviewcalendar"]], contentQueries: function MultiViewCalendarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
    } }, viewQuery: function MultiViewCalendarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(HeaderComponent, 5, ElementRef);
        ɵngcc0.ɵɵviewQuery(HorizontalViewListComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewList = _t.first);
    } }, hostVars: 6, hostBindings: function MultiViewCalendarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusout", function MultiViewCalendarComponent_focusout_HostBindingHandler($event) { return ctx.handleFocusout($event); })("focus", function MultiViewCalendarComponent_focus_HostBindingHandler() { return ctx.handleFocus(); })("mouseenter", function MultiViewCalendarComponent_mouseenter_HostBindingHandler() { return ctx.handleMouseEnter(); })("mouseleave", function MultiViewCalendarComponent_mouseleave_HostBindingHandler() { return ctx.handleMouseLeave(); })("mousedown", function MultiViewCalendarComponent_mousedown_HostBindingHandler($event) { return ctx.handleMousedown($event); })("click", function MultiViewCalendarComponent_click_HostBindingHandler() { return ctx.handleClick(); })("keydown", function MultiViewCalendarComponent_keydown_HostBindingHandler($event) { return ctx.keydown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.widgetId)("tabindex", ctx.calendarTabIndex)("aria-disabled", ctx.ariaDisabled)("aria-activedescendant", ctx.ariaActivedescendant);
        ɵngcc0.ɵɵclassProp("k-disabled", ctx.ariaDisabled);
    } }, inputs: { id: "id", rangeValidation: "rangeValidation", disabledDatesRangeValidation: "disabledDatesRangeValidation", selection: "selection", disabled: "disabled", tabindex: "tabindex", isActive: "isActive", activeView: "activeView", bottomView: "bottomView", topView: "topView", showViewHeader: "showViewHeader", animateNavigation: "animateNavigation", weekNumber: "weekNumber", views: "views", focusedDate: "focusedDate", min: "min", max: "max", value: "value", tabIndex: "tabIndex", disabledDates: "disabledDates", selectionRange: "selectionRange", cellTemplateRef: ["cellTemplate", "cellTemplateRef"], monthCellTemplateRef: ["monthCellTemplate", "monthCellTemplateRef"], yearCellTemplateRef: ["yearCellTemplate", "yearCellTemplateRef"], decadeCellTemplateRef: ["decadeCellTemplate", "decadeCellTemplateRef"], centuryCellTemplateRef: ["centuryCellTemplate", "centuryCellTemplateRef"], weekNumberTemplateRef: ["weekNumberTemplate", "weekNumberTemplateRef"], headerTitleTemplateRef: ["headerTitleTemplate", "headerTitleTemplateRef"], activeRangeEnd: "activeRangeEnd" }, outputs: { activeViewChange: "activeViewChange", navigate: "navigate", cellEnter: "cellEnter", cellLeave: "cellLeave", valueChange: "valueChange", blurEvent: "blur" }, exportAs: ["kendo-multiviewcalendar"], features: [ɵngcc0.ɵɵProvidersFeature([
            BusViewService,
            RANGE_CALENDAR_VALUE_ACCESSOR,
            RANGE_CALENDAR_RANGE_VALIDATORS,
            LocalizationService,
            DisabledDatesService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.multiviewcalendar'
            },
            NavigationService,
            SelectionService
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 28, consts: function () { let i18n_4; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the today button in the calendar header
         * @meaning kendo.multiviewcalendar.today
         */
        const MSG_EXTERNAL_7780927771207785084$$DIST_FESM2015_INDEX_JS_5 = goog.getMsg("Today");
        i18n_4 = MSG_EXTERNAL_7780927771207785084$$DIST_FESM2015_INDEX_JS_5;
    }
    else {
        i18n_4 = $localize `:kendo.multiviewcalendar.today|The label for the today button in the calendar header␟c237cef31a55d762ecfdcac701d283313f30bbfc␟7780927771207785084:Today`;
    } let i18n_6; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the previous button in the Multiview calendar
         * @meaning kendo.multiviewcalendar.prevButtonTitle
         */
        const MSG_EXTERNAL_9101635325676663492$$DIST_FESM2015_INDEX_JS_7 = goog.getMsg("Navigate to previous view");
        i18n_6 = MSG_EXTERNAL_9101635325676663492$$DIST_FESM2015_INDEX_JS_7;
    }
    else {
        i18n_6 = $localize `:kendo.multiviewcalendar.prevButtonTitle|The label for the previous button in the Multiview calendar␟e783e2af4828224b846fa92148ea1cc52b21bb13␟9101635325676663492:Navigate to previous view`;
    } let i18n_8; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the next button in the Multiview calendar
         * @meaning kendo.multiviewcalendar.nextButtonTitle
         */
        const MSG_EXTERNAL_3994336778698343633$$DIST_FESM2015_INDEX_JS_9 = goog.getMsg("Navigate to next view");
        i18n_8 = MSG_EXTERNAL_3994336778698343633$$DIST_FESM2015_INDEX_JS_9;
    }
    else {
        i18n_8 = $localize `:kendo.multiviewcalendar.nextButtonTitle|The label for the next button in the Multiview calendar␟3e3a529a242f39d22f841c3bd8045ec75b696b7a␟3994336778698343633:Navigate to next view`;
    } return [["kendoMultiViewCalendarLocalizedMessages", "", "today", i18n_4, "prevButtonTitle", i18n_6, "nextButtonTitle", i18n_8], [3, "activeView", "currentDate", "min", "max", "rangeLength", "templateRef", "isPrevDisabled", "isNextDisabled", "showNavigationButtons", "kendoEventsOutsideAngular", "scope", "todayButtonClick", "prevButtonClick", "nextButtonClick"], [3, "activeView", "isActive", "cellTemplateRef", "weekNumberTemplateRef", "cellUID", "views", "min", "max", "focusedDate", "animateNavigation", "showViewHeader", "weekNumber", "activeRangeEnd", "selectionRange", "selectedDates", "valueChange", "cellClick", "weekNumberCellClick", "cellEnter", "cellLeave", "activeDateChange"]]; }, template: function MultiViewCalendarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementStart(1, "kendo-calendar-header", 1);
        ɵngcc0.ɵɵlistener("todayButtonClick", function MultiViewCalendarComponent_Template_kendo_calendar_header_todayButtonClick_1_listener($event) { return ctx.handleTodayButtonClick({ selectedDates: [$event], focusedDate: $event }); })("prevButtonClick", function MultiViewCalendarComponent_Template_kendo_calendar_header_prevButtonClick_1_listener() { return ctx.navigateView(ctx.prevView); })("nextButtonClick", function MultiViewCalendarComponent_Template_kendo_calendar_header_nextButtonClick_1_listener() { return ctx.navigateView(ctx.nextView); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "kendo-calendar-horizontal", 2);
        ɵngcc0.ɵɵlistener("valueChange", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_valueChange_2_listener($event) { return ctx.handleDateChange($event); })("cellClick", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellClick_2_listener($event) { return ctx.handleCellClick($event); })("weekNumberCellClick", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_weekNumberCellClick_2_listener($event) { return ctx.handleWeekNumberClick($event); })("cellEnter", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellEnter_2_listener($event) { return ctx.emitCellEvent(ctx.cellEnter, $event); })("cellLeave", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellLeave_2_listener($event) { return ctx.emitCellEvent(ctx.cellLeave, $event); })("activeDateChange", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_activeDateChange_2_listener($event) { return ctx.setActiveDate($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        let tmp_13_0;
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("activeView", ctx.activeViewEnum)("currentDate", ctx.activeDate)("min", ctx.min)("max", ctx.max)("rangeLength", ctx.views)("templateRef", ctx.headerTitleTemplateRef == null ? null : ctx.headerTitleTemplateRef.templateRef)("isPrevDisabled", ctx.isPrevDisabled)("isNextDisabled", ctx.isNextDisabled)("showNavigationButtons", true)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(26, _c10, ctx.handleHeaderFocus))("scope", ctx);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("activeView", ctx.activeViewEnum)("isActive", ctx.isActive || ctx.isHovered && !ctx.isHeaderActive)("cellTemplateRef", (tmp_13_0 = ctx.activeCellTemplate()) == null ? null : tmp_13_0.templateRef)("weekNumberTemplateRef", ctx.weekNumberTemplateRef == null ? null : ctx.weekNumberTemplateRef.templateRef)("cellUID", ctx.cellUID)("views", ctx.views)("min", ctx.min)("max", ctx.max)("focusedDate", ctx.focusedDate)("animateNavigation", ctx.animateNavigation)("showViewHeader", ctx.showViewHeader)("weekNumber", ctx.weekNumber)("activeRangeEnd", ctx.activeRangeEnd)("selectionRange", ctx.selectionRange)("selectedDates", ctx.selectedDates);
    } }, directives: function () { return [MultiViewCalendarLocalizedMessagesDirective, HeaderComponent, ɵngcc4.EventsOutsideAngularDirective, HorizontalViewListComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], MultiViewCalendarComponent.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], MultiViewCalendarComponent.prototype, "focusedDate", null);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], MultiViewCalendarComponent.prototype, "min", null);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], MultiViewCalendarComponent.prototype, "max", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MultiViewCalendarComponent.prototype, "rangeValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MultiViewCalendarComponent.prototype, "disabledDatesRangeValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MultiViewCalendarComponent.prototype, "selection", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MultiViewCalendarComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MultiViewCalendarComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], MultiViewCalendarComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], MultiViewCalendarComponent.prototype, "tabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MultiViewCalendarComponent.prototype, "isActive", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MultiViewCalendarComponent.prototype, "disabledDates", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], MultiViewCalendarComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MultiViewCalendarComponent.prototype, "bottomView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MultiViewCalendarComponent.prototype, "topView", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MultiViewCalendarComponent.prototype, "showViewHeader", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MultiViewCalendarComponent.prototype, "animateNavigation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MultiViewCalendarComponent.prototype, "weekNumber", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MultiViewCalendarComponent.prototype, "activeRangeEnd", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MultiViewCalendarComponent.prototype, "selectionRange", null);
__decorate([
    Input(),
    __metadata("design:type", Number)
], MultiViewCalendarComponent.prototype, "views", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MultiViewCalendarComponent.prototype, "activeViewChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MultiViewCalendarComponent.prototype, "navigate", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MultiViewCalendarComponent.prototype, "cellEnter", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MultiViewCalendarComponent.prototype, "cellLeave", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MultiViewCalendarComponent.prototype, "valueChange", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], MultiViewCalendarComponent.prototype, "blurEvent", void 0);
__decorate([
    ContentChild(CellTemplateDirective, { static: false }),
    __metadata("design:type", CellTemplateDirective)
], MultiViewCalendarComponent.prototype, "cellTemplate", void 0);
__decorate([
    Input('cellTemplate'),
    __metadata("design:type", CellTemplateDirective),
    __metadata("design:paramtypes", [CellTemplateDirective])
], MultiViewCalendarComponent.prototype, "cellTemplateRef", null);
__decorate([
    ContentChild(MonthCellTemplateDirective, { static: false }),
    __metadata("design:type", MonthCellTemplateDirective)
], MultiViewCalendarComponent.prototype, "monthCellTemplate", void 0);
__decorate([
    Input('monthCellTemplate'),
    __metadata("design:type", MonthCellTemplateDirective),
    __metadata("design:paramtypes", [MonthCellTemplateDirective])
], MultiViewCalendarComponent.prototype, "monthCellTemplateRef", null);
__decorate([
    ContentChild(YearCellTemplateDirective, { static: false }),
    __metadata("design:type", YearCellTemplateDirective)
], MultiViewCalendarComponent.prototype, "yearCellTemplate", void 0);
__decorate([
    Input('yearCellTemplate'),
    __metadata("design:type", YearCellTemplateDirective),
    __metadata("design:paramtypes", [YearCellTemplateDirective])
], MultiViewCalendarComponent.prototype, "yearCellTemplateRef", null);
__decorate([
    ContentChild(DecadeCellTemplateDirective, { static: false }),
    __metadata("design:type", DecadeCellTemplateDirective)
], MultiViewCalendarComponent.prototype, "decadeCellTemplate", void 0);
__decorate([
    Input('decadeCellTemplate'),
    __metadata("design:type", DecadeCellTemplateDirective),
    __metadata("design:paramtypes", [DecadeCellTemplateDirective])
], MultiViewCalendarComponent.prototype, "decadeCellTemplateRef", null);
__decorate([
    ContentChild(CenturyCellTemplateDirective, { static: false }),
    __metadata("design:type", CenturyCellTemplateDirective)
], MultiViewCalendarComponent.prototype, "centuryCellTemplate", void 0);
__decorate([
    Input('centuryCellTemplate'),
    __metadata("design:type", CenturyCellTemplateDirective),
    __metadata("design:paramtypes", [CenturyCellTemplateDirective])
], MultiViewCalendarComponent.prototype, "centuryCellTemplateRef", null);
__decorate([
    ContentChild(WeekNumberCellTemplateDirective, { static: false }),
    __metadata("design:type", WeekNumberCellTemplateDirective)
], MultiViewCalendarComponent.prototype, "weekNumberTemplate", void 0);
__decorate([
    Input('weekNumberTemplate'),
    __metadata("design:type", WeekNumberCellTemplateDirective),
    __metadata("design:paramtypes", [WeekNumberCellTemplateDirective])
], MultiViewCalendarComponent.prototype, "weekNumberTemplateRef", null);
__decorate([
    ContentChild(HeaderTitleTemplateDirective, { static: false }),
    __metadata("design:type", HeaderTitleTemplateDirective)
], MultiViewCalendarComponent.prototype, "headerTitleTemplate", void 0);
__decorate([
    Input('headerTitleTemplate'),
    __metadata("design:type", HeaderTitleTemplateDirective),
    __metadata("design:paramtypes", [HeaderTitleTemplateDirective])
], MultiViewCalendarComponent.prototype, "headerTitleTemplateRef", null);
__decorate([
    ViewChild(HeaderComponent, { static: false, read: ElementRef }),
    __metadata("design:type", ElementRef)
], MultiViewCalendarComponent.prototype, "headerElement", void 0);
__decorate([
    ViewChild(HorizontalViewListComponent, { static: false }),
    __metadata("design:type", HorizontalViewListComponent)
], MultiViewCalendarComponent.prototype, "viewList", void 0);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], MultiViewCalendarComponent.prototype, "widgetId", null);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], MultiViewCalendarComponent.prototype, "calendarTabIndex", null);
__decorate([
    HostBinding('attr.aria-disabled'),
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], MultiViewCalendarComponent.prototype, "ariaDisabled", null);
__decorate([
    HostBinding('attr.aria-activedescendant'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], MultiViewCalendarComponent.prototype, "ariaActivedescendant", null);
__decorate([
    HostListener('focusout', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], MultiViewCalendarComponent.prototype, "handleFocusout", null);
__decorate([
    HostListener("focus"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], MultiViewCalendarComponent.prototype, "handleFocus", null);
__decorate([
    HostListener("mouseenter"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], MultiViewCalendarComponent.prototype, "handleMouseEnter", null);
__decorate([
    HostListener("mouseleave"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], MultiViewCalendarComponent.prototype, "handleMouseLeave", null);
__decorate([
    HostListener("mousedown", ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], MultiViewCalendarComponent.prototype, "handleMousedown", null);
__decorate([
    HostListener("click"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], MultiViewCalendarComponent.prototype, "handleClick", null);
__decorate([
    HostListener("keydown", ["$event"]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], MultiViewCalendarComponent.prototype, "keydown", null);
MultiViewCalendarComponent = __decorate([ __param(8, Optional()),
    __metadata("design:paramtypes", [BusViewService,
        ElementRef,
        NavigationService,
        Renderer2,
        ChangeDetectorRef,
        NgZone,
        DisabledDatesService,
        SelectionService,
        PickerService])
], MultiViewCalendarComponent);

const div = domContainerFactory('div');
const ul = domContainerFactory('ul');
const li = domContainerFactory('li');
const td = domContainerFactory('td');
const th = domContainerFactory('th');
const tr = domContainerFactory('tr');
const tbody = domContainerFactory('tbody');
const thead = domContainerFactory('thead');
const table = domContainerFactory('table');
const monthHeader = () => (div(`
            <span class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-calendar-title">March 2017</span>
            <span class="k-spacer"></span>
            <span class="k-calendar-nav k-hstack">
                <span class="k-today k-nav-today">TODAY</span>
            </span>
        `, 'k-calendar-header k-hstack'));
const monthWeekHeader = () => (table([
    thead([
        tr([th('MO', 'k-calendar-th')], 'k-calendar-tr')
    ], 'k-calendar-thead')
], 'k-calendar-weekdays k-calendar-table'));
const repeat = (count, mapper) => new Array(count).fill('1').map(mapper);
const content = (rows, cells = 1) => (table([
    tbody([tr([th('1', 'k-calendar-th')], 'k-calendar-tr')].concat(repeat(rows, () => tr(repeat(cells, c => td(`<span class="k-link">${c}</span>`, 'k-calendar-td')), 'k-calendar-tr'))), 'k-calendar-tbody')
], 'k-calendar-table'));
const scrollable = (children) => div(children, 'k-flex k-content k-calendar-content k-scrollable');
const view = (contentElement, className, renderWeekHeader) => (div([
    monthHeader(),
    renderWeekHeader ? monthWeekHeader() : null,
    scrollable([contentElement, contentElement])
], className, { left: '-10000px', position: 'absolute' }));
const ɵ6 = () => {
    let navElement;
    return () => {
        if (!isDocumentAvailable) {
            return null;
        }
        if (!navElement) {
            navElement = div([scrollable([ul([li('<span>FEB</span>')])])], 'k-calendar-navigation', { left: '0px', position: 'absolute' });
        }
        return navElement;
    };
};
const navigationList = (ɵ6)();
const viewFactory = ({ cells, rows }, className, renderWeekHeader) => {
    let viewElement;
    return () => {
        if (!isDocumentAvailable) {
            return null;
        }
        if (!viewElement) {
            viewElement = view(content(rows, cells), className, renderWeekHeader);
        }
        return viewElement;
    };
};
const getScrollable = (element) => element.querySelector('.k-scrollable');
const horizontal = element => {
    const scrollableElement = getScrollable(element);
    scrollableElement.classList.add('k-scrollable-horizontal');
    return element;
};
const monthView = viewFactory({ cells: 7, rows: 6 }, 'k-vstack k-calendar-view k-calendar-monthview', true);
const yearView = viewFactory({ cells: 4, rows: 3 }, 'k-vstack k-calendar-view k-calendar-yearview', false);
const decadeView = viewFactory({ cells: 4, rows: 3 }, 'k-vstack k-calendar-view k-calendar-decadeview', false);
const horzMonthView = () => horizontal(monthView());
const horzYearView = () => horizontal(yearView());
const horzDecadeView = () => horizontal(decadeView());
const height = (element) => (parseFloat(window.getComputedStyle(element).height) || element.offsetHeight);
const width = (element) => {
    const styles = window.getComputedStyle(element);
    const computed = parseFloat(styles.width)
        + parseFloat(styles.paddingLeft)
        + parseFloat(styles.paddingRight);
    return computed || element.offsetWidth;
};
const getBody = (element) => element.querySelector('tbody');
/**
 * @hidden
 */
let CalendarDOMService = class CalendarDOMService {
    ensureHeights() {
        if (this.calendarHeight !== undefined) {
            return;
        }
        this.calculateHeights();
    }
    calculateHeights(container) {
        if (!isDocumentAvailable()) {
            return;
        }
        this.hostContainer = container;
        this.batch(monthView(), (contentElement) => {
            const viewElement = getBody(contentElement);
            this.calendarHeight = height(contentElement);
            this.monthViewHeight = height(viewElement);
            this.headerHeight = height(viewElement.children[0]);
            this.scrollableContentHeight = height(getScrollable(contentElement));
        });
        this.batch(horzMonthView(), (contentElement) => {
            const viewElement = getBody(contentElement);
            this.calendarWidth = width(contentElement);
            this.monthViewWidth = width(viewElement);
            this.scrollableContentWidth = width(getScrollable(contentElement));
        });
        this.batch(yearView(), (contentElement) => {
            this.yearViewHeight = height(getBody(contentElement));
            this.scrollableYearContentHeight = height(getScrollable(contentElement));
        });
        this.batch(horzYearView(), (contentElement) => {
            this.yearViewWidth = width(getBody(contentElement));
        });
        this.batch(decadeView(), (contentElement) => {
            this.decadeViewHeight = height(getBody(contentElement));
            this.centuryViewHeight = this.decadeViewHeight;
        });
        this.batch(horzDecadeView(), (contentElement) => {
            this.decadeViewWidth = width(getBody(contentElement));
            this.centuryViewWidth = this.decadeViewWidth;
        });
        this.batch(navigationList(), (contentElement) => {
            this.navigationItemHeight = height(contentElement.querySelector('li'));
        });
    }
    viewHeight(viewType) {
        return this.viewDimension(viewType, 'height');
    }
    viewWidth(viewType) {
        return this.viewDimension(viewType, 'width');
    }
    viewDimension(viewType, dimension) {
        const viewProp = dimension === 'height' ? 'ViewHeight' : 'ViewWidth';
        switch (viewType) {
            case CalendarViewEnum.month:
                return this[`month${viewProp}`];
            case CalendarViewEnum.year:
                return this[`year${viewProp}`];
            case CalendarViewEnum.decade:
                return this[`decade${viewProp}`];
            case CalendarViewEnum.century:
                return this[`century${viewProp}`];
            default:
                return 1;
        }
    }
    batch(contentElement, action) {
        if (!isPresent(this.hostContainer)) {
            return;
        }
        const hostClone = this.hostContainer.cloneNode();
        document.body.appendChild(hostClone);
        try {
            const appendedContent = hostClone.appendChild(contentElement);
            action(appendedContent);
        }
        catch (error) {
            throw error;
        }
        finally {
            document.body.removeChild(hostClone);
        }
    }
};
CalendarDOMService.ɵfac = function CalendarDOMService_Factory(t) { return new (t || CalendarDOMService)(); };
CalendarDOMService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: CalendarDOMService, factory: function (t) { return CalendarDOMService.ɵfac(t); } });

/**
 * @hidden
 */
const update = (arr, idx, value) => ([
    ...arr.slice(0, idx + 1),
    ...(arr.slice(idx + 1).map(x => x + value))
]);
/**
 * @hidden
 */
class RowHeightService {
    constructor(total = 0, rowHeight, detailRowHeight) {
        this.total = total;
        this.rowHeight = rowHeight;
        this.detailRowHeight = detailRowHeight;
        this.offsets = [];
        this.heights = [];
        let agg = 0;
        for (let idx = 0; idx < total; idx++) {
            this.offsets.push(agg);
            agg += rowHeight;
            this.heights.push(rowHeight);
        }
    }
    height(rowIndex) {
        return this.heights[rowIndex];
    }
    expandDetail(rowIndex) {
        if (this.height(rowIndex) === this.rowHeight) {
            this.updateRowHeight(rowIndex, this.detailRowHeight);
        }
    }
    collapseDetail(rowIndex) {
        if (this.height(rowIndex) > this.rowHeight) {
            this.updateRowHeight(rowIndex, this.detailRowHeight * -1);
        }
    }
    index(position) {
        if (position < 0) {
            return undefined;
        }
        const result = this.offsets.reduce((prev, current, idx) => {
            if (prev !== undefined) {
                return prev;
            }
            else if (current === position) {
                return idx;
            }
            else if (current > position) {
                return idx - 1;
            }
            return undefined;
        }, undefined); // tslint:disable-line:align
        return result === undefined ? this.total - 1 : result;
    }
    offset(rowIndex) {
        return this.offsets[rowIndex];
    }
    totalHeight() {
        return this.heights.reduce((prev, curr) => prev + curr, 0);
    }
    updateRowHeight(rowIndex, value) {
        this.heights[rowIndex] += value;
        this.offsets = update(this.offsets, rowIndex, value);
    }
}

const normalize = x => Math.max(x, 0);
/**
 * @hidden
 */
class ScrollAction {
    constructor(offset) {
        this.offset = offset;
    }
}
/**
 * @hidden
 */
class PageAction {
    constructor(skip) {
        this.skip = skip;
    }
}
/**
 * @hidden
 */
class ScrollerService {
    constructor(scrollObservable) {
        this.scrollObservable = scrollObservable;
        this.firstLoaded = 0;
        this.bottomOffset = 0;
        this.topOffset = 0;
    }
    create(rowHeightService, skip, take, total, topOffset = 0, bottomOffset = 0, direction = 'vertical') {
        this.rowHeightService = rowHeightService;
        this.firstLoaded = skip;
        this.lastLoaded = skip + take;
        this.take = take;
        this.total = total;
        this.lastScroll = 0;
        this.topOffset = topOffset;
        this.bottomOffset = bottomOffset;
        this.direction = direction;
        const subject = new ReplaySubject(2);
        const offsetBufferRows = this.rowsForHeight(topOffset);
        const skipWithOffset = normalize(skip - offsetBufferRows);
        subject.next(new ScrollAction(this.rowOffset(skipWithOffset)));
        if (offsetBufferRows) {
            subject.next(new PageAction(skipWithOffset));
        }
        this.subscription = new Observable(observer => {
            this.unsubscribe();
            this.scrollSubscription = this.scrollObservable.subscribe(x => this.onScroll(x, observer));
        }).subscribe((x) => subject.next(x));
        return subject;
    }
    destroy() {
        this.unsubscribe();
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    onScroll({ scrollLeft, scrollTop, offsetHeight, offsetWidth }, observer) {
        const scrollPosition = this.direction === 'vertical' ? scrollTop : scrollLeft;
        const offsetSize = this.direction === 'vertical' ? offsetHeight : offsetWidth;
        if (this.lastScroll === scrollPosition) {
            return;
        }
        const up = this.lastScroll >= scrollPosition;
        this.lastScroll = scrollPosition;
        const firstItemIndex = this.rowHeightService.index(normalize(scrollPosition - this.topOffset));
        const lastItemIndex = this.rowHeightService.index(normalize(scrollPosition + offsetSize - this.bottomOffset));
        if (!up && lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {
            this.firstLoaded = firstItemIndex;
            observer.next(new ScrollAction(this.rowOffset(firstItemIndex)));
            this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
            observer.next(new PageAction(this.firstLoaded));
        }
        if (up && firstItemIndex <= this.firstLoaded) {
            const nonVisibleBuffer = Math.floor(this.take * 0.3);
            this.firstLoaded = normalize(firstItemIndex - nonVisibleBuffer);
            observer.next(new ScrollAction(this.rowOffset(this.firstLoaded)));
            this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
            observer.next(new PageAction(this.firstLoaded));
        }
    }
    rowOffset(index) {
        return this.rowHeightService.offset(index) + this.topOffset;
    }
    rowsForHeight(height) {
        return Math.ceil(height / this.rowHeightService.height(0));
    }
    unsubscribe() {
        if (this.scrollSubscription) {
            this.scrollSubscription.unsubscribe();
            this.scrollSubscription = null;
        }
    }
}

/**
 * @hidden
 */
const SCROLLER_FACTORY_TOKEN = new InjectionToken('dateinputs-scroll-service-factory');
/**
 * @hidden
 */
function DEFAULT_SCROLLER_FACTORY(observable) {
    return new ScrollerService(observable);
}
/**
 * @hidden
 */
var ScrollDirection;
(function (ScrollDirection) {
    ScrollDirection[ScrollDirection["Backward"] = 0] = "Backward";
    ScrollDirection[ScrollDirection["Forward"] = 1] = "Forward";
})(ScrollDirection || (ScrollDirection = {}));
const FRAME_DURATION = 17;
const scrollModifiers = {
    [ScrollDirection.Forward]: (step) => value => value + step,
    [ScrollDirection.Backward]: (step) => value => value - step
};
const scrollNormalizers = {
    [ScrollDirection.Forward]: (end) => value => Math.min(value, end),
    [ScrollDirection.Backward]: (end) => value => Math.max(value, end)
};
const scrollValidators = {
    [ScrollDirection.Forward]: end => start => start < end,
    [ScrollDirection.Backward]: end => start => start > end
};
const differenceToScroll = (scrollTop, staticOffset, maxScrollDifference) => {
    return Math.min(Math.abs(staticOffset - scrollTop), maxScrollDifference);
};
/**
 * @hidden
 */
let VirtualizationComponent = class VirtualizationComponent {
    constructor(scrollerFactory, container, renderer, zone) {
        this.container = container;
        this.renderer = renderer;
        this.zone = zone;
        this.direction = 'vertical';
        this.itemHeight = 1;
        this.itemWidth = 1;
        this.topOffset = 0;
        this.bottomOffset = 0;
        this.maxScrollDifference = 100;
        this.scrollOffsetSize = 0;
        this.scrollDuration = 150;
        this.activeIndexChange = new EventEmitter();
        this.pageChange = new EventEmitter();
        this.scrollChange = new EventEmitter();
        this.wrapperClasses = true;
        this.resolvedPromise = Promise.resolve(null);
        this.dispatcher = new Subject();
        this.scroller = scrollerFactory(this.dispatcher);
    }
    get horizontalClass() {
        return this.direction === 'horizontal';
    }
    get totalVertexLength() {
        const value = `${this.totalSize}px`;
        return this.direction === 'vertical' ? { height: value } : { width: value };
    }
    get containerOffsetSize() {
        return this.getContainerProperty(this.direction === 'vertical' ? 'offsetHeight' : 'offsetWidth');
    }
    get containerScrollSize() {
        return this.getContainerProperty(this.direction === 'vertical' ? 'scrollHeight' : 'scrollWidth');
    }
    get containerScrollPosition() {
        return this.getContainerProperty(this.direction === 'vertical' ? 'scrollTop' : 'scrollLeft');
    }
    ngOnChanges(changes) {
        if (changes.direction || changes.take || changes.total) {
            this.initServices();
            this.totalSize = this.rowHeightService.totalHeight() + this.bottomOffset;
        }
    }
    ngOnInit() {
        if (!this.rowHeightService) {
            this.rowHeightService = this.createRowHeightService();
        }
    }
    ngAfterViewInit() {
        this.zone.runOutsideAngular(() => {
            this.containerScrollSubscription = this.scroll$()
                .pipe(map((event) => event.target))
                .subscribe(t => {
                this.dispatcher.next(t);
                this.emitActiveIndex();
            });
        });
    }
    ngOnDestroy() {
        if (this.containerScrollSubscription) {
            this.containerScrollSubscription.unsubscribe();
        }
        if (this.scrollSubscription) {
            this.scrollSubscription.unsubscribe();
        }
        if (this.animationSubscription) {
            this.animationSubscription.unsubscribe();
        }
    }
    getContainerProperty(propertyName) {
        return this.container.nativeElement[propertyName];
    }
    activeIndex() {
        return this.itemIndex(Math.ceil(this.containerScrollPosition)); //handle subpixeling
    }
    itemIndex(offset) {
        return this.rowHeightService.index(offset);
    }
    itemOffset(index) {
        return this.rowHeightService.offset(index);
    }
    isIndexVisible(index) {
        if (!this.rowHeightService) {
            return false;
        }
        const containerTop = this.containerScrollPosition;
        const containerBottom = containerTop + this.containerOffsetSize;
        const top = this.rowHeightService.offset(index);
        const bottom = top + this.rowHeightService.height(index);
        return top >= containerTop && bottom <= containerBottom;
    }
    isListScrolled(index) {
        return this.containerScrollPosition !== this.rowHeightService.offset(index);
    }
    scrollTo(value) {
        const scrollProperty = this.direction === "vertical" ? 'scrollTop' : 'scrollLeft';
        this.renderer.setProperty(this.container.nativeElement, scrollProperty, value);
    }
    scrollToIndex(index) {
        //XXX: scrolling with tick is required to prevent list jump in Chrome.
        //Original issue: focus first day in the month and press LEFT arrow.
        //Notice how the view jumps on every day change.
        //
        this.zone.runOutsideAngular(() => {
            this.resolvedPromise.then(() => {
                this.scrollTo(this.rowHeightService.offset(index));
            });
        });
    }
    scrollToBottom() {
        this.scrollTo(this.totalSize);
    }
    animateToIndex(index) {
        if (this.animationSubscription) {
            this.animationSubscription.unsubscribe();
        }
        const indexOffset = this.rowHeightService.offset(index);
        const direction = this.getContainerScrollDirection(indexOffset);
        const { start, end } = this.scrollRange(indexOffset, direction);
        if (start === end) {
            return;
        }
        const step = this.scrollStep(start, end);
        const modifyScroll = scrollModifiers[direction](step);
        const normalizeScroll = scrollNormalizers[direction](end);
        const isScrollValid = scrollValidators[direction](modifyScroll(end));
        this.zone.runOutsideAngular(() => {
            this.animationSubscription =
                combineLatest(of(start), interval(0, animationFrameScheduler)).pipe(map(stream => stream[0]), scan(modifyScroll), takeWhile(isScrollValid), map(normalizeScroll)).subscribe((x) => this.scrollTo(x));
        });
    }
    scrollRange(indexOffset, direction) {
        const containerScroll = this.containerScrollPosition;
        if (parseInt(indexOffset, 10) === parseInt(containerScroll, 10)) {
            return { start: indexOffset, end: indexOffset };
        }
        const maxScroll = this.containerMaxScroll();
        const sign = direction === ScrollDirection.Backward ? 1 : -1;
        const difference = differenceToScroll(containerScroll, indexOffset, this.maxScrollDifference);
        const end = Math.min(indexOffset, maxScroll);
        const start = Math.min(Math.max(end + (sign * difference), 0), maxScroll);
        return { start, end };
    }
    scrollStep(start, end) {
        return Math.abs(end - start) / (this.scrollDuration / FRAME_DURATION);
    }
    scroll$() {
        return isDocumentAvailable() ? fromEvent(this.container.nativeElement, 'scroll') : EMPTY;
    }
    initServices() {
        this.rowHeightService = this.createRowHeightService();
        if (this.scrollSubscription) {
            this.scrollSubscription.unsubscribe();
        }
        this.scrollSubscription = this.scroller
            .create(this.rowHeightService, this.skip, this.take, this.total, this.topOffset, this.scrollOffsetSize, this.direction)
            .subscribe((x) => {
            if (x instanceof PageAction) {
                this.pageChange.emit(x);
            }
            else {
                this.scrollChange.emit(x);
            }
        });
    }
    createRowHeightService() {
        const dimension = this.direction === 'vertical' ? this.itemHeight : this.itemWidth;
        return new RowHeightService(this.total, dimension, 0);
    }
    emitActiveIndex() {
        const index = this.rowHeightService.index(this.containerScrollPosition - this.topOffset);
        if (this.lastActiveIndex !== index) {
            this.lastActiveIndex = index;
            this.activeIndexChange.emit(index);
        }
    }
    containerMaxScroll() {
        return this.containerScrollSize - this.containerOffsetSize;
    }
    getContainerScrollDirection(indexOffset) {
        return indexOffset < this.containerScrollPosition ? ScrollDirection.Backward : ScrollDirection.Forward;
    }
};
VirtualizationComponent.ɵfac = function VirtualizationComponent_Factory(t) { return new (t || VirtualizationComponent)(ɵngcc0.ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
VirtualizationComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: VirtualizationComponent, selectors: [["kendo-virtualization"]], hostVars: 10, hostBindings: function VirtualizationComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-flex", ctx.wrapperClasses)("k-content", ctx.wrapperClasses)("k-calendar-content", ctx.wrapperClasses)("k-scrollable", ctx.wrapperClasses)("k-scrollable-horizontal", ctx.horizontalClass);
    } }, inputs: { direction: "direction", itemHeight: "itemHeight", itemWidth: "itemWidth", topOffset: "topOffset", bottomOffset: "bottomOffset", maxScrollDifference: "maxScrollDifference", scrollOffsetSize: "scrollOffsetSize", scrollDuration: "scrollDuration", skip: "skip", take: "take", total: "total" }, outputs: { activeIndexChange: "activeIndexChange", pageChange: "pageChange", scrollChange: "scrollChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: SCROLLER_FACTORY_TOKEN,
                useValue: DEFAULT_SCROLLER_FACTORY
            }]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c11, decls: 2, vars: 3, consts: [[1, "k-scrollable-placeholder", 3, "ngStyle"]], template: function VirtualizationComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelement(1, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("k-scrollable-horizontal-placeholder", ctx.direction === "horizontal");
        ɵngcc0.ɵɵproperty("ngStyle", ctx.totalVertexLength);
    } }, directives: [ɵngcc2.NgStyle], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], VirtualizationComponent.prototype, "direction", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], VirtualizationComponent.prototype, "itemHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], VirtualizationComponent.prototype, "itemWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], VirtualizationComponent.prototype, "topOffset", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], VirtualizationComponent.prototype, "bottomOffset", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], VirtualizationComponent.prototype, "maxScrollDifference", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], VirtualizationComponent.prototype, "scrollOffsetSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], VirtualizationComponent.prototype, "scrollDuration", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], VirtualizationComponent.prototype, "skip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], VirtualizationComponent.prototype, "take", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], VirtualizationComponent.prototype, "total", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], VirtualizationComponent.prototype, "activeIndexChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], VirtualizationComponent.prototype, "pageChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], VirtualizationComponent.prototype, "scrollChange", void 0);
__decorate([
    HostBinding('class.k-flex'),
    HostBinding('class.k-content'),
    HostBinding('class.k-calendar-content'),
    HostBinding('class.k-scrollable'),
    __metadata("design:type", Boolean)
], VirtualizationComponent.prototype, "wrapperClasses", void 0);
__decorate([
    HostBinding('class.k-scrollable-horizontal'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], VirtualizationComponent.prototype, "horizontalClass", null);
VirtualizationComponent = __decorate([ __param(0, Inject(SCROLLER_FACTORY_TOKEN)),
    __metadata("design:paramtypes", [Object, ElementRef,
        Renderer2,
        NgZone])
], VirtualizationComponent);

/**
 * @hidden
 */
const closestInScope = (node, predicate, scope) => {
    while (node && node !== scope && !predicate(node)) {
        node = node.parentNode;
    }
    if (node !== scope) {
        return node;
    }
};
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};

const ITEMS_COUNT = 30;
/**
 * @hidden
 */
let NavigationComponent = class NavigationComponent {
    constructor(bus, dom, intl, cdr, renderer) {
        this.bus = bus;
        this.dom = dom;
        this.intl = intl;
        this.cdr = cdr;
        this.renderer = renderer;
        this.min = new Date(MIN_DATE);
        this.max = new Date(MAX_DATE);
        this.focusedDate = new Date();
        this.valueChange = new EventEmitter();
        this.pageChange = new EventEmitter();
        this.dates = [];
        this.take = ITEMS_COUNT;
        this.indexToScroll = -1;
    }
    get getComponentClass() {
        return true;
    }
    ngOnInit() {
        this.dom.ensureHeights();
        const calendarHeight = this.dom.calendarHeight;
        this.itemHeight = this.dom.navigationItemHeight;
        this.maxViewHeight = this.dom.monthViewHeight;
        this.topOffset = (calendarHeight - this.itemHeight) / 2;
        this.bottomOffset = calendarHeight - this.itemHeight;
        this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
    }
    ngOnChanges(changes) {
        this.service = this.bus.service(this.activeView);
        if (!this.service) {
            return;
        }
        this.activeViewValue = CalendarViewEnum[this.activeView];
        const viewDate = dateInRange(this.focusedDate, this.min, this.max);
        const total = this.service.total(this.min, this.max);
        const totalChanged = this.total && this.total !== total;
        this.skip = this.service.skip(viewDate, this.min);
        this.total = total;
        if (totalChanged || !this.service.isInArray(viewDate, this.dates)) {
            this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
        }
        if (!!changes.focusedDate || totalChanged) {
            this.indexToScroll = this.service.skip(this.focusedDate, this.min);
        }
    }
    ngOnDestroy() {
        if (this.intlSubscription) {
            this.intlSubscription.unsubscribe();
        }
    }
    ngAfterViewInit() {
        if (this.indexToScroll === -1) {
            return;
        }
        this.virtualization.scrollToIndex(this.indexToScroll);
        this.indexToScroll = -1;
    }
    ngAfterViewChecked() {
        if (this.indexToScroll === -1) {
            return;
        }
        this.virtualization.scrollToIndex(this.indexToScroll);
        this.indexToScroll = -1;
    }
    onPageChange({ skip }) {
        this.dates = this.service.datesList(this.service.addToDate(this.min, skip), this.getTake(skip));
        this.pageChange.emit();
    }
    scrollChange({ offset }) {
        const el = this.list.nativeElement;
        const translate = `translateY(${offset}px)`;
        this.renderer.setStyle(el, 'transform', translate);
        this.renderer.setStyle(el, '-ms-transform', translate);
    }
    handleDateChange(args) {
        const item = closestInScope(args.target, node => node.hasAttribute('data-date-index'), this.list.nativeElement);
        if (item) {
            const index = parseInt(item.getAttribute('data-date-index'), 10);
            const candidate = this.dates[index];
            this.valueChange.emit(cloneDate(candidate));
        }
    }
    getTake(skip) {
        return Math.min(this.total - skip, this.take);
    }
    intlChange() {
        if (this.activeView === CalendarViewEnum.month) {
            this.cdr.markForCheck();
        }
    }
};
NavigationComponent.ɵfac = function NavigationComponent_Factory(t) { return new (t || NavigationComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(CalendarDOMService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NavigationComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NavigationComponent, selectors: [["kendo-calendar-navigation"]], viewQuery: function NavigationComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(VirtualizationComponent, 5);
        ɵngcc0.ɵɵviewQuery(_c12, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtualization = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.list = _t.first);
    } }, hostVars: 2, hostBindings: function NavigationComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-calendar-navigation", ctx.getComponentClass);
    } }, inputs: { min: "min", max: "max", focusedDate: "focusedDate", activeView: "activeView", templateRef: "templateRef" }, outputs: { valueChange: "valueChange", pageChange: "pageChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 12, consts: [[1, "k-calendar-navigation-highlight"], [3, "skip", "take", "total", "itemHeight", "topOffset", "bottomOffset", "maxScrollDifference", "pageChange", "scrollChange"], [1, "k-reset", 3, "kendoEventsOutsideAngular", "scope"], ["list", ""], [4, "kFor", "kForOf"], [3, "ngIf"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function NavigationComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
        ɵngcc0.ɵɵelementStart(1, "kendo-virtualization", 1);
        ɵngcc0.ɵɵlistener("pageChange", function NavigationComponent_Template_kendo_virtualization_pageChange_1_listener($event) { return ctx.onPageChange($event); })("scrollChange", function NavigationComponent_Template_kendo_virtualization_scrollChange_1_listener($event) { return ctx.scrollChange($event); });
        ɵngcc0.ɵɵelementStart(2, "ul", 2, 3);
        ɵngcc0.ɵɵtemplate(4, NavigationComponent_li_4_Template, 4, 11, "li", 4);
        ɵngcc0.ɵɵelementEnd()();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("skip", ctx.skip)("take", ctx.take)("total", ctx.total)("itemHeight", ctx.itemHeight)("topOffset", ctx.topOffset)("bottomOffset", ctx.bottomOffset)("maxScrollDifference", ctx.maxViewHeight);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(10, _c2, ctx.handleDateChange))("scope", ctx);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("kForOf", ctx.dates);
    } }, directives: function () { return [VirtualizationComponent, ɵngcc4.EventsOutsideAngularDirective, KForOf, ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], NavigationComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NavigationComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NavigationComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NavigationComponent.prototype, "focusedDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], NavigationComponent.prototype, "templateRef", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], NavigationComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], NavigationComponent.prototype, "pageChange", void 0);
__decorate([
    ViewChild(VirtualizationComponent, { static: false }),
    __metadata("design:type", VirtualizationComponent)
], NavigationComponent.prototype, "virtualization", void 0);
__decorate([
    ViewChild('list', { static: true }),
    __metadata("design:type", ElementRef)
], NavigationComponent.prototype, "list", void 0);
__decorate([
    HostBinding("class.k-calendar-navigation"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NavigationComponent.prototype, "getComponentClass", null);
NavigationComponent = __decorate([ __metadata("design:paramtypes", [BusViewService,
        CalendarDOMService,
        IntlService,
        ChangeDetectorRef,
        Renderer2])
], NavigationComponent);

const VIEWS_COUNT = 5;
const isEqualMonthYear = (date1, date2) => (date1 && date2 &&
    date1.getFullYear() === date2.getFullYear() &&
    date1.getMonth() === date2.getMonth());
/**
 * @hidden
 */
let ViewListComponent = class ViewListComponent {
    constructor(bus, cdr, intl, dom, renderer) {
        this.bus = bus;
        this.cdr = cdr;
        this.intl = intl;
        this.dom = dom;
        this.renderer = renderer;
        this.isActive = true;
        this.min = new Date(MIN_DATE);
        this.max = new Date(MAX_DATE);
        this.selectedDates = [];
        this.cellClick = new EventEmitter();
        this.weekNumberCellClick = new EventEmitter();
        this.activeDateChange = new EventEmitter();
        this.todayButtonClick = new EventEmitter();
        this.pageChange = new EventEmitter();
        this.getComponentClass = true;
        this.dates = [];
        this.cols = [];
        this.weekNames = [];
        this.take = VIEWS_COUNT;
        this.animateToIndex = true;
        this.indexToScroll = -1;
        this.minViewsToRender = 1;
    }
    get weekNumber() {
        return this.showWeekNumbers && this.isMonthView();
    }
    set weekNumber(showWeekNumbers) {
        this.showWeekNumbers = showWeekNumbers;
    }
    get getComponentMonthClass() {
        return this.activeView === CalendarViewEnum.month;
    }
    get getComponentYearClass() {
        return this.activeView === CalendarViewEnum.year;
    }
    get getComponentDecadeClass() {
        return this.activeView === CalendarViewEnum.decade;
    }
    get getComponentCenturyClass() {
        return this.activeView === CalendarViewEnum.century;
    }
    ngOnInit() {
        this.weekNames = this.getWeekNames();
        this.bottomOffset = this.getBottomOffset();
        this.viewOffset = -1 * this.dom.headerHeight;
        this.viewHeight = this.dom.viewHeight(this.activeView);
        this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
    }
    ngOnChanges(changes) {
        this.service = this.bus.service(this.activeView);
        if (!this.service) {
            return;
        }
        this.cols = new Array(this.service.rowLength({ prependCell: this.weekNumber })).fill('');
        this.colWidth = Math.round(100 / this.cols.length);
        this.weekNames = hasChange(changes, 'weekNumber') && this.weekNumber ? this.getWeekNames() : this.weekNames;
        const activeViewChanged = hasChange(changes, 'activeView');
        const focusedDate = this.focusedDate;
        const viewDate = dateInRange(this.service.viewDate(focusedDate, this.max, this.minViewsToRender), this.min, this.max);
        const total = this.service.total(this.min, this.max);
        const totalChanged = this.total && this.total !== total;
        const generateDates = totalChanged || !this.service.isInArray(focusedDate, this.dates);
        this.skip = this.service.skip(viewDate, this.min);
        this.total = total;
        this.animateToIndex = !activeViewChanged;
        this.bottomOffset = this.getBottomOffset();
        this.viewHeight = this.dom.viewHeight(this.activeView);
        if (generateDates) {
            this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
        }
        if (!isEqualMonthYear(this.activeDate, focusedDate)) {
            this.activeDate = cloneDate(focusedDate);
        }
        const updateIndex = hasChange(changes, 'focusedDate') || activeViewChanged;
        if (generateDates || updateIndex || this.virtualization.isIndexVisible(this.skip)) {
            this.indexToScroll = this.service.skip(focusedDate, this.min);
        }
    }
    ngOnDestroy() {
        if (this.intlSubscription) {
            this.intlSubscription.unsubscribe();
        }
    }
    ngAfterViewInit() {
        if (this.indexToScroll === -1) {
            return;
        }
        this.virtualization.scrollToIndex(this.indexToScroll);
        this.indexToScroll = -1;
    }
    ngAfterViewChecked() {
        if (this.indexToScroll === -1) {
            return;
        }
        this.virtualization[this.animateToIndex ? 'animateToIndex' : 'scrollToIndex'](this.indexToScroll);
        this.animateToIndex = true;
        this.indexToScroll = -1;
    }
    onPageChange({ skip }) {
        this.dates = this.service.datesList(this.service.addToDate(this.min, skip), this.getTake(skip));
        this.pageChange.emit();
    }
    scrollChange({ offset }) {
        const el = this.list.nativeElement;
        const translate = `translateY(${offset}px)`;
        this.renderer.setStyle(el, 'transform', translate);
        this.renderer.setStyle(el, '-ms-transform', translate);
    }
    setActiveDate(index) {
        const candidate = this.service.addToDate(this.min, index);
        this.activeDate = candidate;
        this.activeDateChange.emit(candidate);
        this.cdr.detectChanges();
    }
    isMonthView() {
        return this.activeView === CalendarViewEnum.month;
    }
    isScrolled() {
        return this.virtualization.isListScrolled(this.service.skip(this.focusedDate, this.min));
    }
    getBottomOffset() {
        return this.getScrollableHeight() - this.dom.viewHeight(this.activeView);
    }
    getScrollableHeight() {
        return this.activeView === CalendarViewEnum.month ?
            this.dom.scrollableContentHeight :
            this.dom.scrollableYearContentHeight;
    }
    getTake(skip) {
        return Math.min(this.total - skip, this.take);
    }
    getWeekNames() {
        const weekNames = shiftWeekNames(this.intl.dateFormatNames({ nameType: 'short', type: 'days' }), this.intl.firstDay());
        return this.weekNumber ? [''].concat(weekNames) : weekNames;
    }
    intlChange() {
        this.weekNames = this.getWeekNames();
        if (this.isMonthView()) {
            this.cdr.markForCheck();
        }
    }
};
ViewListComponent.ɵfac = function ViewListComponent_Factory(t) { return new (t || ViewListComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(CalendarDOMService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ViewListComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ViewListComponent, selectors: [["kendo-calendar-viewlist"]], viewQuery: function ViewListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(VirtualizationComponent, 5);
        ɵngcc0.ɵɵviewQuery(_c12, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtualization = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.list = _t.first);
    } }, hostVars: 12, hostBindings: function ViewListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-vstack", ctx.getComponentClass)("k-calendar-view", ctx.getComponentClass)("k-calendar-monthview", ctx.getComponentMonthClass)("k-calendar-yearview", ctx.getComponentYearClass)("k-calendar-decadeview", ctx.getComponentDecadeClass)("k-calendar-centuryview", ctx.getComponentCenturyClass);
    } }, inputs: { isActive: "isActive", min: "min", max: "max", selectedDates: "selectedDates", weekNumber: "weekNumber", cellTemplateRef: "cellTemplateRef", weekNumberTemplateRef: "weekNumberTemplateRef", headerTitleTemplateRef: "headerTitleTemplateRef", activeView: "activeView", cellUID: "cellUID", focusedDate: "focusedDate" }, outputs: { cellClick: "cellClick", weekNumberCellClick: "weekNumberCellClick", activeDateChange: "activeDateChange", todayButtonClick: "todayButtonClick", pageChange: "pageChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 17, consts: [[3, "currentDate", "min", "max", "activeView", "templateRef", "todayButtonClick"], ["class", "k-calendar-weekdays k-calendar-table", "style", "table-layout: auto;", 4, "ngIf"], [3, "tabindex", "skip", "take", "total", "itemHeight", "topOffset", "bottomOffset", "scrollOffsetSize", "maxScrollDifference", "pageChange", "scrollChange", "activeIndexChange"], ["role", "grid", 1, "k-calendar-table"], ["list", ""], [4, "ngFor", "ngForOf"], ["class", "k-calendar-tbody", "kendoCalendarView", "", "role", "rowgroup", 3, "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate", "cellClick", "weekNumberCellClick", 4, "kFor", "kForOf"], [1, "k-calendar-weekdays", "k-calendar-table", 2, "table-layout", "auto"], [1, "k-calendar-thead"], [1, "k-calendar-tr"], ["class", "k-calendar-th", 3, "width", 4, "ngFor", "ngForOf"], [1, "k-calendar-th"], ["kendoCalendarView", "", "role", "rowgroup", 1, "k-calendar-tbody", 3, "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate", "cellClick", "weekNumberCellClick"]], template: function ViewListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-calendar-header", 0);
        ɵngcc0.ɵɵlistener("todayButtonClick", function ViewListComponent_Template_kendo_calendar_header_todayButtonClick_0_listener($event) { return ctx.todayButtonClick.emit($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(1, ViewListComponent_table_1_Template, 4, 1, "table", 1);
        ɵngcc0.ɵɵelementStart(2, "kendo-virtualization", 2);
        ɵngcc0.ɵɵlistener("pageChange", function ViewListComponent_Template_kendo_virtualization_pageChange_2_listener($event) { return ctx.onPageChange($event); })("scrollChange", function ViewListComponent_Template_kendo_virtualization_scrollChange_2_listener($event) { return ctx.scrollChange($event); })("activeIndexChange", function ViewListComponent_Template_kendo_virtualization_activeIndexChange_2_listener($event) { return ctx.setActiveDate($event); });
        ɵngcc0.ɵɵelementStart(3, "table", 3, 4)(5, "colgroup");
        ɵngcc0.ɵɵtemplate(6, ViewListComponent_col_6_Template, 1, 0, "col", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, ViewListComponent_tbody_7_Template, 1, 11, "tbody", 6);
        ɵngcc0.ɵɵelementEnd()();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("currentDate", ctx.activeDate)("min", ctx.min)("max", ctx.max)("activeView", ctx.activeView)("templateRef", ctx.headerTitleTemplateRef);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isMonthView());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("tabindex", -1)("skip", ctx.skip)("take", ctx.take)("total", ctx.total)("itemHeight", ctx.viewHeight)("topOffset", ctx.viewOffset)("bottomOffset", ctx.bottomOffset)("scrollOffsetSize", ctx.viewOffset)("maxScrollDifference", ctx.viewHeight);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cols);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("kForOf", ctx.dates);
    } }, directives: function () { return [HeaderComponent, ɵngcc2.NgIf, ɵngcc2.NgForOf, VirtualizationComponent, KForOf, ViewComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ViewListComponent.prototype, "cellTemplateRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ViewListComponent.prototype, "weekNumberTemplateRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ViewListComponent.prototype, "headerTitleTemplateRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ViewListComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ViewListComponent.prototype, "cellUID", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], ViewListComponent.prototype, "focusedDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ViewListComponent.prototype, "isActive", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], ViewListComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], ViewListComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ViewListComponent.prototype, "selectedDates", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], ViewListComponent.prototype, "weekNumber", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ViewListComponent.prototype, "cellClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ViewListComponent.prototype, "weekNumberCellClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ViewListComponent.prototype, "activeDateChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ViewListComponent.prototype, "todayButtonClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ViewListComponent.prototype, "pageChange", void 0);
__decorate([
    ViewChild(VirtualizationComponent, { static: false }),
    __metadata("design:type", VirtualizationComponent)
], ViewListComponent.prototype, "virtualization", void 0);
__decorate([
    ViewChild('list', { static: true }),
    __metadata("design:type", ElementRef)
], ViewListComponent.prototype, "list", void 0);
__decorate([
    HostBinding("class.k-vstack"),
    HostBinding("class.k-calendar-view"),
    __metadata("design:type", Boolean)
], ViewListComponent.prototype, "getComponentClass", void 0);
__decorate([
    HostBinding("class.k-calendar-monthview"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ViewListComponent.prototype, "getComponentMonthClass", null);
__decorate([
    HostBinding("class.k-calendar-yearview"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ViewListComponent.prototype, "getComponentYearClass", null);
__decorate([
    HostBinding("class.k-calendar-decadeview"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ViewListComponent.prototype, "getComponentDecadeClass", null);
__decorate([
    HostBinding("class.k-calendar-centuryview"),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ViewListComponent.prototype, "getComponentCenturyClass", null);
ViewListComponent = __decorate([ __metadata("design:paramtypes", [BusViewService,
        ChangeDetectorRef,
        IntlService,
        CalendarDOMService,
        Renderer2])
], ViewListComponent);

const divideByMagnitude = (magnitude) => x => Math.floor(x / magnitude);
const powerByMagnitude = (magnitude) => x => x * magnitude;
/**
 * @hidden
 */
let ScrollSyncService = class ScrollSyncService {
    constructor(dom, zone) {
        this.dom = dom;
        this.zone = zone;
    }
    configure(activeView) {
        const magnitude = Math.max(this.dom.viewHeight(activeView) / this.dom.navigationItemHeight, 1);
        this.divideByMagnitude = divideByMagnitude(magnitude);
        this.powerByMagnitude = powerByMagnitude(magnitude);
    }
    sync(navigator, view) {
        this.unsubscribe();
        if (!navigator || !view) {
            return;
        }
        this.navigator = navigator;
        this.view = view;
        this.zone.runOutsideAngular(() => {
            let navScrolled, monthScrolled;
            this.navSubscription = navigator.scroll$()
                .subscribe((e) => {
                if (monthScrolled) {
                    monthScrolled = false;
                    return;
                }
                navScrolled = true;
                this.scrollSiblingOf(e.target);
            });
            this.viewSubscription = view.scroll$()
                .subscribe((e) => {
                if (navScrolled) {
                    navScrolled = false;
                    return;
                }
                monthScrolled = true;
                this.scrollSiblingOf(e.target);
            });
        });
    }
    scrollSiblingOf(scrolledElement) {
        const component = this.siblingComponent(scrolledElement);
        const scrollTop = this.calculateScroll(component, scrolledElement.scrollTop);
        component.scrollTo(scrollTop);
    }
    siblingComponent(scrollableElement) {
        return this.navigator.container.nativeElement === scrollableElement ? this.view : this.navigator;
    }
    calculateScroll(component, scrollTop) {
        const modifier = component === this.navigator ? this.divideByMagnitude : this.powerByMagnitude;
        return modifier(scrollTop);
    }
    destroy() {
        this.unsubscribe();
    }
    unsubscribe() {
        if (this.navSubscription) {
            this.navSubscription.unsubscribe();
        }
        if (this.viewSubscription) {
            this.viewSubscription.unsubscribe();
        }
    }
};
ScrollSyncService.ɵfac = function ScrollSyncService_Factory(t) { return new (t || ScrollSyncService)(ɵngcc0.ɵɵinject(CalendarDOMService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ScrollSyncService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ScrollSyncService, factory: function (t) { return ScrollSyncService.ɵfac(t); } });
ScrollSyncService = __decorate([ __metadata("design:paramtypes", [CalendarDOMService, NgZone])
], ScrollSyncService);

/**
 * Used for rendering the navigation item of the Calendar. To define the navigation item template, nest an `<ng-template>`
 * tag with the `kendoCalendarNavigationItemTemplate` directive inside the component tag. The template context is set to the
 * current component. To get a reference to the current item value, use the `let-title` directive. To provide more details
 * about the current title, get a reference to the current `date` by using the `let-date='date'` directive or get a reference
 * to the current active view by using the `let-activeView='activeView'` directive.
 *
 * For more examples, refer to the article on [templates]({% slug templates_calendar %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * styles: ['.custom { color: red; }'],
 * template: `
 *  <kendo-calendar>
 *    <ng-template kendoCalendarNavigationItemTemplate let-title>
 *      <span class="custom">{{title}}</span>
 *    </ng-template>
 *  </kendo-calendar>
 * `
 * })
 * export class AppComponent { }
 * ```
 */
let NavigationItemTemplateDirective = class NavigationItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NavigationItemTemplateDirective.ɵfac = function NavigationItemTemplateDirective_Factory(t) { return new (t || NavigationItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NavigationItemTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NavigationItemTemplateDirective, selectors: [["", "kendoCalendarNavigationItemTemplate", ""]] });
NavigationItemTemplateDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NavigationItemTemplateDirective);

const BOTTOM_VIEW_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview';
const TOP_VIEW_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview';
const MIN_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min';
const MAX_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max';
const VALUE_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json';
const virtualizationProp = x => x ? x.virtualization : null;
/**
 * @hidden
 */
const CALENDAR_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => CalendarComponent) //tslint:disable-line:no-use-before-declare
};
/**
 * @hidden
 */
const CALENDAR_RANGE_VALIDATORS = {
    multi: true,
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => CalendarComponent) //tslint:disable-line:no-use-before-declare
};
/**
 * @hidden
 */
const KENDO_INPUT_PROVIDER = {
    provide: KendoInput,
    useExisting: forwardRef(() => CalendarComponent) //tslint:disable-line:no-use-before-declare
};
/**
 * Represents the [Kendo UI Calendar component for Angular]({% slug overview_calendar %}#toc-basic-usage).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-calendar></kendo-calendar>
 * `
 * })
 * export class AppComponent { }
 * ```
 */
let CalendarComponent = class CalendarComponent {
    constructor(bus, dom, element, navigator, renderer, cdr, ngZone, injector, scrollSyncService, disabledDatesService, localization, selectionService, pickerService) {
        this.bus = bus;
        this.dom = dom;
        this.element = element;
        this.navigator = navigator;
        this.renderer = renderer;
        this.cdr = cdr;
        this.ngZone = ngZone;
        this.injector = injector;
        this.scrollSyncService = scrollSyncService;
        this.disabledDatesService = disabledDatesService;
        this.localization = localization;
        this.selectionService = selectionService;
        this.pickerService = pickerService;
        /**
         * @hidden
         */
        this.id = guid();
        /**
         * Determines whether the built-in min or max validators are enforced when validating a form.
         */
        this.rangeValidation = false;
        /**
         * Sets the Calendar selection mode
         * ([see example]({% slug multiple_selection_calendar %})).
         *
         * The available values are:
         * * `single` (default)
         * * `multiple`
         */
        this.selection = 'single';
        /**
         * Sets or gets the `disabled` property of the Calendar and
         * determines whether the component is active
         * ([see example]({% slug disabled_calendar %})).
         */
        this.disabled = false;
        /**
         * Sets or gets the `tabindex` property of the Calendar. Based on the
         * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,
         * it determines whether the component is focusable.
         */
        this.tabindex = 0;
        /**
         * Sets or gets the `navigation` property of the Calendar
         * and determines whether the navigation side-bar will be displayed
         * ([see example]({% slug sidebar_calendar %})).
         * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
         */
        this.navigation = true;
        /**
         * Defines the active view that the Calendar initially renders
         * ([see example]({% slug activeview_calendar %})).
         * By default, the active view is `month`.
         *
         * > You have to set `activeView` within the `topView`-`bottomView` range.
         */
        this.activeView = CalendarViewEnum[CalendarViewEnum.month];
        /**
         * Defines the bottommost view to which the user can navigate
         * ([see example]({% slug dates_calendar %}#toc-partial-dates)).
         */
        this.bottomView = CalendarViewEnum[CalendarViewEnum.month];
        /**
         * Defines the topmost view to which the user can navigate
         * ([see example]({% slug sidebar_calendar %}#toc-partial-dates)).
         */
        this.topView = CalendarViewEnum[CalendarViewEnum.century];
        /**
         * Determines whether to enable animation when navigating to previous/next view.
         * Applies to the [`classic`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
         *
         * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
         *
         * @default false
         */
        this.animateNavigation = false;
        /**
         * Determines whether to display a week number column in the `month` view
         * ([see example]({% slug weeknumcolumn_calendar %})).
         */
        this.weekNumber = false;
        /**
         * Fires when the active view is changed
         * ([more information and example]({% slug overview_calendar %}#toc-events)).
         */
        this.activeViewChange = new EventEmitter();
        /**
         * Fires when navigating in the currently active view
         * ([more information and example]({% slug events_calendar %})).
         */
        this.navigate = new EventEmitter();
        /**
         * Fires when the active view date is changed
         * ([more information and example]({% slug overview_calendar %}#toc-events)).
         * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
         */
        this.activeViewDateChange = new EventEmitter();
        /**
         * Fires when the value is changed
         * ([more information and example]({% slug overview_calendar %}#toc-events)).
         */
        this.valueChange = new EventEmitter();
        this.isActive = false;
        this.cellUID = guid();
        this.selectedDates = [];
        this._min = new Date(MIN_DATE);
        this._max = new Date(MAX_DATE);
        this._focusedDate = getToday();
        this.onControlChange = noop;
        this.onControlTouched = noop;
        this.onValidatorChange = noop;
        this.minValidateFn = noop;
        this.maxValidateFn = noop;
        this.syncNavigation = true;
        this._type = 'infinite';
        this.domEvents = [];
        this.resolvedPromise = Promise.resolve(null);
        this.destroyed = false;
        validatePackage(packageMetadata);
        this.setClasses(element.nativeElement);
        if (this.pickerService) {
            this.pickerService.calendar = this;
        }
    }
    /**
     * Sets or gets the `focusedDate` property of the Calendar and
     * defines the focused date of the component
     * ([see example]({% slug dates_calendar %}#toc-focused-dates)).
     *
     * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.
     */
    set focusedDate(focusedDate) {
        if (this.activeViewDate && !isEqual(this._focusedDate, focusedDate)) {
            const service = this.bus.service(this.activeViewEnum);
            const lastDayInPeriod = service.lastDayOfPeriod(this.activeViewDate);
            const isFocusedDateInRange = service.isInRange(focusedDate, this.activeViewDate, lastDayInPeriod);
            if (!isFocusedDateInRange) {
                this.emitNavigate(focusedDate);
            }
        }
        this._focusedDate = focusedDate || getToday();
        this.setAriaActivedescendant();
    }
    get focusedDate() {
        return this._focusedDate;
    }
    /**
     * Sets or gets the `min` property of the Calendar and
     * defines the minimum allowed date value
     * ([see example]({% slug dateranges_calendar %})).
     * By default, the `min` value is `1900-1-1`.
     */
    set min(min) {
        this._min = min || new Date(MIN_DATE);
    }
    get min() {
        return this._min;
    }
    /**
     * Sets or gets the `max` property of the Calendar and
     * defines the maximum allowed date value
     * ([see example]({% slug dateranges_calendar %})).
     * By default, the `max` value is `2099-12-31`.
     */
    set max(max) {
        this._max = max || new Date(MAX_DATE);
    }
    get max() {
        return this._max;
    }
    /**
     * Sets or gets the `value` property of the Calendar and defines the selected value of the component.
     *
     * > The `value` has to be a valid
     * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)
     * instance when in `single` selection mode or an array of valid JavaScript Date instances when in `multiple` selection mode.
     */
    get value() {
        return this._value;
    }
    set value(candidate) {
        this.verifyValue(candidate);
        this._value = Array.isArray(candidate) ?
            candidate.filter(date => isPresent(date)).map(element => cloneDate(element)) :
            cloneDate(candidate);
        const selection = [].concat(candidate).filter(date => isPresent(date)).map(date => cloneDate(date));
        if (!areDatesEqual(selection, this.selectedDates)) {
            const lastSelected = last(selection);
            this.rangePivot = cloneDate(lastSelected);
            this.focusedDate = cloneDate(lastSelected) || this.focusedDate;
            this.selectedDates = selection;
        }
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Sets the dates of the Calendar that will be disabled
     * ([see example]({% slug disabled_dates_calendar %})).
     */
    set disabledDates(value) {
        this.disabledDatesService.initialize(value);
        this._disabledDates = value;
    }
    get disabledDates() {
        return this._disabledDates;
    }
    /**
     * Specifies the Calendar type.
     *
     * The possible values are:
     * - `infinite` (default)
     * - `classic`
     *
     */
    set type(type) {
        this.renderer.removeClass(this.element.nativeElement, `k-calendar-${this.type}`);
        this.renderer.addClass(this.element.nativeElement, `k-calendar-${type}`);
        this._type = type;
    }
    get type() {
        return this._type;
    }
    /**
     * @hidden
     *
     * Defines the template for each cell.
     * Takes precedence over nested templates in the KendoCalendar tag.
     */
    set cellTemplateRef(template) {
        this._cellTemplateRef = template;
    }
    get cellTemplateRef() {
        return this._cellTemplateRef || this.cellTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for each month cell.
     * Takes precedence over nested templates in the KendoCalendar tag.
     */
    set monthCellTemplateRef(template) {
        this._monthCellTemplateRef = template;
    }
    get monthCellTemplateRef() {
        return this._monthCellTemplateRef || this.monthCellTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for each year cell.
     * Takes precedence over nested templates in the KendoCalendar tag.
     */
    set yearCellTemplateRef(template) {
        this._yearCellTemplateRef = template;
    }
    get yearCellTemplateRef() {
        return this._yearCellTemplateRef || this.yearCellTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for each decade cell.
     * Takes precedence over nested templates in the KendoCalendar tag.
     */
    set decadeCellTemplateRef(template) {
        this._decadeCellTemplateRef = template;
    }
    get decadeCellTemplateRef() {
        return this._decadeCellTemplateRef || this.decadeCellTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for each century cell.
     * Takes precedence over nested templates in the KendoCalendar tag.
     */
    set centuryCellTemplateRef(template) {
        this._centuryCellTemplateRef = template;
    }
    get centuryCellTemplateRef() {
        return this._centuryCellTemplateRef || this.centuryCellTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for the week cell.
     * Takes precedence over nested templates in the KendoCalendar tag.
     */
    set weekNumberTemplateRef(template) {
        this._weekNumberTemplateRef = template;
    }
    get weekNumberTemplateRef() {
        return this._weekNumberTemplateRef || this.weekNumberTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for the header title.
     * Takes precedence over nested templates in the KendoCalendar tag.
     */
    set headerTitleTemplateRef(template) {
        this._headerTitleTemplateRef = template;
    }
    get headerTitleTemplateRef() {
        return this._headerTitleTemplateRef || this.headerTitleTemplate;
    }
    /**
     * @hidden
     *
     * Defines the template for the navigation item.
     * Takes precedence over nested templates in the KendoCalendar tag.
     */
    set navigationItemTemplateRef(template) {
        this._navigationItemTemplateRef = template;
    }
    get navigationItemTemplateRef() {
        return this._navigationItemTemplateRef || this.navigationItemTemplate;
    }
    get activeViewEnum() {
        const activeView = CalendarViewEnum[this.activeView];
        return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;
    }
    get bottomViewEnum() {
        return CalendarViewEnum[this.bottomView];
    }
    get topViewEnum() {
        return CalendarViewEnum[this.topView];
    }
    get widgetId() {
        return this.id;
    }
    get calendarTabIndex() {
        // in Classic mode, the inner MultiViewCalendar is the focusable element
        return this.disabled || this.type === 'classic' ? undefined : this.tabIndex;
    }
    get ariaDisabled() {
        // in Classic mode, the inner MultiViewCalendar should handle the disabled class and aria attr
        return this.type === 'classic' ? undefined : this.disabled;
    }
    ngOnInit() {
        this.dom.calculateHeights(this.element.nativeElement);
        this.scrollSyncService.configure(this.activeViewEnum);
        this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());
        this.viewChangeSubscription = this.bus.viewChanged.subscribe(({ view }) => this.handleActiveViewChange(CalendarViewEnum[view]));
        this.control = this.injector.get(NgControl, null);
        if (this.element) {
            this.ngZone.runOutsideAngular(() => {
                this.bindEvents();
            });
        }
    }
    ngOnChanges(changes) {
        this.verifyChanges();
        this.bus.configure(this.bottomViewEnum, this.topViewEnum);
        this.scrollSyncService.configure(this.activeViewEnum);
        if (hasExistingValue(changes, 'focusedDate')) {
            const focusedDate = changes.focusedDate.currentValue;
            this.focusedDate = dateInRange(focusedDate, this.min, this.max);
        }
        if (changes.navigation) {
            this.syncNavigation = true;
        }
        if (changes.min || changes.max || changes.rangeValidation) {
            this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;
            this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;
            this.onValidatorChange();
        }
    }
    ngAfterViewInit() {
        this.setAriaActivedescendant();
    }
    ngAfterViewChecked() {
        if (!this.syncNavigation) {
            return;
        }
        this.syncNavigation = false;
        this.scrollSyncService.sync(virtualizationProp(this.navigationView), virtualizationProp(this.monthView));
    }
    ngOnDestroy() {
        this.scrollSyncService.destroy();
        this.domEvents.forEach(unbindCallback => unbindCallback());
        if (this.pickerService) {
            this.pickerService.calendar = null;
        }
        if (this.viewChangeSubscription) {
            this.viewChangeSubscription.unsubscribe();
        }
        if (this.pageChangeSubscription) {
            this.pageChangeSubscription.unsubscribe();
        }
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
        this.destroyed = true;
    }
    /**
     * @hidden
     */
    onResize() {
        this.focusedDate = new Date(this.focusedDate);
        this.cdr.detectChanges();
    }
    /**
     * Focuses the host element of the Calendar.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="calendar.focus()">Focus calendar</button>
     *  <kendo-calendar #calendar></kendo-calendar>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    focus() {
        const focusTarget = this.type === 'infinite' ?
            this.element && this.element.nativeElement :
            this.multiViewCalendar;
        if (isPresent(focusTarget)) {
            focusTarget.focus();
        }
    }
    /**
     * Blurs the Calendar component.
     */
    blur() {
        const blurTarget = this.type === 'infinite' ?
            this.element && this.element.nativeElement :
            this.multiViewCalendar;
        if (isPresent(blurTarget)) {
            blurTarget.blur();
        }
    }
    /**
     * @hidden
     */
    containsElement(element) {
        return Boolean(closest(element, node => node === this.element.nativeElement));
    }
    /**
     * @hidden
     */
    handleNavigation(candidate) {
        if (this.disabled) {
            return;
        }
        const focusTarget = candidate ? new Date(cloneDate(candidate).setDate(1)) : this.focusedDate;
        this.focusedDate = dateInRange(focusTarget, this.min, this.max);
        this.detectChanges();
    }
    /**
     * @hidden
     */
    onPageChange() {
        if (!NgZone.isInAngularZone()) {
            if (this.pageChangeSubscription) {
                this.pageChangeSubscription.unsubscribe();
            }
            this.pageChangeSubscription = from(this.resolvedPromise)
                .subscribe(() => {
                this.detectChanges(); // requires zone if templates
            });
        }
    }
    /**
     * @hidden
     */
    handleMultiViewCalendarValueChange(date, focusedDate) {
        const selectedDates = Array.isArray(date) ? date : [date];
        this.handleDateChange({ selectedDates, focusedDate });
    }
    /**
     * @hidden
     */
    handleDateChange(args) {
        const selectedDates = Array.isArray(args.selectedDates) ? args.selectedDates : [args.selectedDates];
        const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);
        const availableDates = selectedDates.filter(date => !this.disabledDatesService.isDateDisabled(date));
        this.focusedDate = args.focusedDate || this.focusedDate;
        if (this.disabled) {
            return;
        }
        if (!canNavigateDown && areDatesEqual(availableDates, this.selectedDates)) {
            this.emitSameDate();
            return;
        }
        if (canNavigateDown) {
            this.bus.moveDown(this.activeViewEnum);
            return;
        }
        if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {
            return;
        }
        this.ngZone.run(() => {
            this.selectedDates = availableDates.map(date => cloneDate(date));
            this.value = this.parseSelectionToValue(availableDates);
            this.onControlChange(this.parseSelectionToValue(availableDates));
            this.valueChange.emit(this.parseSelectionToValue(availableDates));
            this.cdr.markForCheck();
        });
    }
    /**
     * @hidden
     */
    writeValue(candidate) {
        this.verifyValue(candidate);
        this.value = candidate;
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onControlChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onControlTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    validate(control) {
        return this.minValidateFn(control) || this.maxValidateFn(control);
    }
    /**
     * @hidden
     */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /**
     * @hidden
     */
    activeCellTemplate() {
        switch (this.activeViewEnum) {
            case CalendarViewEnum.month:
                return this.monthCellTemplateRef || this.cellTemplateRef;
            case CalendarViewEnum.year:
                return this.yearCellTemplateRef;
            case CalendarViewEnum.decade:
                return this.decadeCellTemplateRef;
            case CalendarViewEnum.century:
                return this.centuryCellTemplateRef;
            default:
                return null;
        }
    }
    /**
     * @hidden
     */
    handleNavigate(event) {
        this.focusedDate = event.focusedDate;
        this.activeView = event.activeView;
        this.emitNavigate(this.focusedDate);
    }
    /**
     * @hidden
     */
    emitNavigate(focusedDate) {
        const activeView = CalendarViewEnum[this.activeViewEnum];
        this.navigate.emit({ activeView, focusedDate });
    }
    /**
     * @hidden
     */
    emitEvent(emitter, args) {
        if (hasObservers(emitter)) {
            this.ngZone.run(() => {
                emitter.emit(args);
            });
        }
    }
    /**
     * @hidden
     */
    handleActiveDateChange(date) {
        this.activeViewDate = date;
        this.emitEvent(this.activeViewDateChange, date);
    }
    /**
     * @hidden
     */
    handleActiveViewChange(view) {
        this.activeView = view;
        this.emitEvent(this.activeViewChange, view);
        if (this.type === 'infinite') {
            this.scrollSyncService.configure(this.activeViewEnum);
        }
        this.detectChanges(); // requires zone if templates
    }
    handleCellClick({ date, modifiers }) {
        this.performSelection(date, modifiers);
    }
    /**
     * @hidden
     */
    handleWeekNumberClick(dates) {
        if (this.selection === 'single') {
            return;
        }
        this.ngZone.run(() => {
            this.handleDateChange({
                selectedDates: dates,
                focusedDate: last(dates)
            });
        });
    }
    /**
     * @hidden
     */
    handleBlur(args) {
        if (this.element.nativeElement.contains(args.relatedTarget)) {
            return;
        }
        this.isActive = false;
        // the injector can get the NgControl instance of the parent component (for example, the DateTimePicker)
        // and enters the zone for no reason because the parent component is still untouched
        if (!this.pickerService && requiresZoneOnBlur(this.control)) {
            this.ngZone.run(() => {
                this.onControlTouched();
                this.emitBlur(args);
                this.cdr.markForCheck();
            });
        }
        else {
            this.emitBlur(args);
            this.detectChanges();
        }
    }
    /**
     * @hidden
     */
    handleFocus() {
        this.isActive = true;
        if (!NgZone.isInAngularZone()) {
            this.detectChanges();
        }
        this.emitFocus();
    }
    setClasses(element) {
        this.renderer.addClass(element, 'k-widget');
        this.renderer.addClass(element, 'k-calendar');
        this.renderer.addClass(element, `k-calendar-${this.type}`);
    }
    verifyChanges() {
        if (!isDevMode()) {
            return;
        }
        if (this.min > this.max) {
            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$1} and ${MAX_DOC_LINK$1}.`);
        }
        if (this.bottomViewEnum > this.topViewEnum) {
            throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK$1} and ${TOP_VIEW_DOC_LINK$1}.`);
        }
    }
    verifyValue(candidate) {
        if (!isDevMode()) {
            return;
        }
        if (this.selection === 'single' && candidate && !(candidate instanceof Date)) {
            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$1} for possible resolution.`);
        }
        else if (this.selection === 'multiple' && candidate && Array.isArray(candidate)) {
            const onlyDates = candidate.every(value => value instanceof Date);
            if (!onlyDates) {
                throw new Error(`The 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$1} for possible resolution.`);
            }
        }
    }
    bindEvents() {
        const element = this.element.nativeElement;
        this.domEvents.push(this.renderer.listen(element, 'blur', this.handleBlur.bind(this)), this.renderer.listen(element, 'focus', this.handleFocus.bind(this)), this.renderer.listen(element, 'mousedown', preventDefault), this.renderer.listen(element, 'click', this.handleComponentClick.bind(this)), this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));
    }
    emitBlur(args) {
        if (this.pickerService) {
            this.pickerService.onBlur.emit(args);
        }
    }
    emitFocus() {
        if (this.pickerService) {
            this.pickerService.onFocus.emit();
        }
    }
    handleComponentClick() {
        if (!this.isActive) {
            if (this.type === 'infinite' && this.monthView.isScrolled()) {
                this.focusedDate = cloneDate(this.focusedDate); //XXX: forces change detect
                this.detectChanges();
            }
            this.focus();
        }
    }
    handleKeydown(args) {
        const headerActive = this.type === 'classic' && this.multiViewCalendar.isHeaderActive;
        if (headerActive) {
            return;
        }
        // reserve the alt + arrow key commands for the picker
        const arrowKeyPressed = [Keys.ArrowUp, Keys.ArrowRight, Keys.ArrowDown, Keys.ArrowLeft].indexOf(args.keyCode) !== -1;
        if (isPresent(this.pickerService) && arrowKeyPressed && args.altKey) {
            return;
        }
        const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(args), this.activeViewEnum), this.min, this.max);
        if (!isEqual(this.focusedDate, candidate)) {
            this.focusedDate = candidate;
            this.detectChanges();
            args.preventDefault();
        }
        if (args.keyCode === Keys.Enter) {
            this.performSelection(this.focusedDate, args);
        }
    }
    detectChanges() {
        if (!this.destroyed) {
            this.cdr.detectChanges();
        }
    }
    emitSameDate() {
        if (this.pickerService) {
            this.pickerService.sameDateSelected.emit();
        }
    }
    setAriaActivedescendant() {
        // in Classic mode, the inner MultiViewCalendar handles the activedescendant
        if (!isPresent(this.element) || (this.type === 'classic' && !this.element.nativeElement.hasAttribute('aria-activedescendant'))) {
            return;
        }
        if (this.type === 'classic') {
            this.renderer.removeAttribute(this.element.nativeElement, 'aria-activedescendant');
            return;
        }
        const focusedCellId = this.cellUID + this.focusedDate.getTime();
        this.renderer.setAttribute(this.element.nativeElement, 'aria-activedescendant', focusedCellId);
    }
    parseSelectionToValue(selection) {
        selection = selection || [];
        return this.selection === 'single' ? cloneDate(last(selection)) : selection.map(date => cloneDate(date));
    }
    performSelection(date, selectionModifiers) {
        const selection = this.selectionService.performSelection({
            date: date,
            modifiers: selectionModifiers,
            selectionMode: this.selection,
            activeViewEnum: this.activeViewEnum,
            rangePivot: this.rangePivot,
            selectedDates: this.selectedDates
        });
        this.rangePivot = selection.rangePivot;
        this.handleDateChange({
            selectedDates: selection.selectedDates,
            focusedDate: date
        });
    }
};
CalendarComponent.ɵfac = function CalendarComponent_Factory(t) { return new (t || CalendarComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(CalendarDOMService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ScrollSyncService), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(PickerService, 8)); };
CalendarComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CalendarComponent, selectors: [["kendo-calendar"]], contentQueries: function CalendarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NavigationItemTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);
    } }, viewQuery: function CalendarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NavigationComponent, 5);
        ɵngcc0.ɵɵviewQuery(ViewListComponent, 5);
        ɵngcc0.ɵɵviewQuery(MultiViewCalendarComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.navigationView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.multiViewCalendar = _t.first);
    } }, hostVars: 7, hostBindings: function CalendarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.widgetId)("tabindex", ctx.calendarTabIndex)("aria-disabled", ctx.ariaDisabled);
        ɵngcc0.ɵɵclassProp("k-week-number", ctx.weekNumber)("k-disabled", ctx.ariaDisabled);
    } }, inputs: { id: "id", rangeValidation: "rangeValidation", selection: "selection", disabled: "disabled", tabindex: "tabindex", navigation: "navigation", activeView: "activeView", bottomView: "bottomView", topView: "topView", animateNavigation: "animateNavigation", weekNumber: "weekNumber", focusedDate: "focusedDate", min: "min", max: "max", value: "value", tabIndex: "tabIndex", disabledDates: "disabledDates", type: "type", cellTemplateRef: ["cellTemplate", "cellTemplateRef"], monthCellTemplateRef: ["monthCellTemplate", "monthCellTemplateRef"], yearCellTemplateRef: ["yearCellTemplate", "yearCellTemplateRef"], decadeCellTemplateRef: ["decadeCellTemplate", "decadeCellTemplateRef"], centuryCellTemplateRef: ["centuryCellTemplate", "centuryCellTemplateRef"], weekNumberTemplateRef: ["weekNumberTemplate", "weekNumberTemplateRef"], headerTitleTemplateRef: ["headerTitleTemplate", "headerTitleTemplateRef"], navigationItemTemplateRef: ["navigationItemTemplate", "navigationItemTemplateRef"] }, outputs: { activeViewChange: "activeViewChange", navigate: "navigate", activeViewDateChange: "activeViewDateChange", valueChange: "valueChange" }, exportAs: ["kendo-calendar"], features: [ɵngcc0.ɵɵProvidersFeature([
            BusViewService,
            CALENDAR_VALUE_ACCESSOR,
            CALENDAR_RANGE_VALIDATORS,
            KENDO_INPUT_PROVIDER,
            LocalizationService,
            DisabledDatesService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.calendar'
            },
            NavigationService,
            ScrollSyncService,
            SelectionService
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 2, consts: function () { let i18n_13; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the today button in the calendar header
         * @meaning kendo.calendar.today
         */
        const MSG_EXTERNAL_4715594042078324085$$DIST_FESM2015_INDEX_JS_14 = goog.getMsg("Today");
        i18n_13 = MSG_EXTERNAL_4715594042078324085$$DIST_FESM2015_INDEX_JS_14;
    }
    else {
        i18n_13 = $localize `:kendo.calendar.today|The label for the today button in the calendar header␟7a8b7961a5c754397897f39a824bdec621719040␟4715594042078324085:Today`;
    } let i18n_15; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the previous button in the Classic calendar
         * @meaning kendo.calendar.prevButtonTitle
         */
        const MSG_EXTERNAL_9114031309296786030$$DIST_FESM2015_INDEX_JS_16 = goog.getMsg("Navigate to previous view");
        i18n_15 = MSG_EXTERNAL_9114031309296786030$$DIST_FESM2015_INDEX_JS_16;
    }
    else {
        i18n_15 = $localize `:kendo.calendar.prevButtonTitle|The title of the previous button in the Classic calendar␟031715cd6a995d5dd1f62365cfe1b9e6226ca185␟9114031309296786030:Navigate to previous view`;
    } let i18n_17; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the next button in the Classic calendar
         * @meaning kendo.calendar.nextButtonTitle
         */
        const MSG_EXTERNAL_7248948899360601102$$DIST_FESM2015_INDEX_JS_18 = goog.getMsg("Navigate to next view");
        i18n_17 = MSG_EXTERNAL_7248948899360601102$$DIST_FESM2015_INDEX_JS_18;
    }
    else {
        i18n_17 = $localize `:kendo.calendar.nextButtonTitle|The title of the next button in the Classic calendar␟cd8c0952c72306cccf0973c8fd1957ef9da1f569␟7248948899360601102:Navigate to next view`;
    } return [["kendoCalendarLocalizedMessages", "", "today", i18n_13, "prevButtonTitle", i18n_15, "nextButtonTitle", i18n_17], [4, "ngIf"], [3, "activeView", "focusedDate", "min", "max", "templateRef", "valueChange", "pageChange", 4, "ngIf"], [3, "activeView", "isActive", "cellTemplateRef", "headerTitleTemplateRef", "weekNumberTemplateRef", "cellUID", "min", "max", "focusedDate", "weekNumber", "selectedDates", "todayButtonClick", "cellClick", "weekNumberCellClick", "activeDateChange", "pageChange"], [3, "resize"], [3, "activeView", "focusedDate", "min", "max", "templateRef", "valueChange", "pageChange"], [3, "views", "min", "max", "isActive", "activeView", "bottomView", "topView", "weekNumber", "animateNavigation", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "headerTitleTemplate", "weekNumberTemplate", "focusedDate", "selection", "value", "disabledDates", "activeViewChange", "navigate", "valueChange", "focus", "blur"], ["multiviewcalendar", ""], [3, "today", "prevButtonTitle", "nextButtonTitle"]]; }, template: function CalendarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵtemplate(1, CalendarComponent_ng_container_1_Template, 4, 12, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, CalendarComponent_ng_container_2_Template, 4, 23, "ng-container", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "infinite");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "classic");
    } }, directives: function () { return [CalendarLocalizedMessagesDirective, ɵngcc2.NgIf, NavigationComponent, ViewListComponent, ɵngcc4.ResizeSensorComponent, MultiViewCalendarComponent, MultiViewCalendarCustomMessagesComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], CalendarComponent.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], CalendarComponent.prototype, "focusedDate", null);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], CalendarComponent.prototype, "min", null);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], CalendarComponent.prototype, "max", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CalendarComponent.prototype, "rangeValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CalendarComponent.prototype, "selection", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], CalendarComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CalendarComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CalendarComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], CalendarComponent.prototype, "tabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], CalendarComponent.prototype, "disabledDates", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CalendarComponent.prototype, "navigation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CalendarComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CalendarComponent.prototype, "bottomView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CalendarComponent.prototype, "topView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], CalendarComponent.prototype, "type", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CalendarComponent.prototype, "animateNavigation", void 0);
__decorate([
    Input(),
    HostBinding('class.k-week-number'),
    __metadata("design:type", Boolean)
], CalendarComponent.prototype, "weekNumber", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], CalendarComponent.prototype, "activeViewChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], CalendarComponent.prototype, "navigate", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], CalendarComponent.prototype, "activeViewDateChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], CalendarComponent.prototype, "valueChange", void 0);
__decorate([
    ContentChild(CellTemplateDirective, { static: false }),
    __metadata("design:type", CellTemplateDirective)
], CalendarComponent.prototype, "cellTemplate", void 0);
__decorate([
    Input('cellTemplate'),
    __metadata("design:type", CellTemplateDirective),
    __metadata("design:paramtypes", [CellTemplateDirective])
], CalendarComponent.prototype, "cellTemplateRef", null);
__decorate([
    ContentChild(MonthCellTemplateDirective, { static: false }),
    __metadata("design:type", MonthCellTemplateDirective)
], CalendarComponent.prototype, "monthCellTemplate", void 0);
__decorate([
    Input('monthCellTemplate'),
    __metadata("design:type", MonthCellTemplateDirective),
    __metadata("design:paramtypes", [MonthCellTemplateDirective])
], CalendarComponent.prototype, "monthCellTemplateRef", null);
__decorate([
    ContentChild(YearCellTemplateDirective, { static: false }),
    __metadata("design:type", YearCellTemplateDirective)
], CalendarComponent.prototype, "yearCellTemplate", void 0);
__decorate([
    Input('yearCellTemplate'),
    __metadata("design:type", YearCellTemplateDirective),
    __metadata("design:paramtypes", [YearCellTemplateDirective])
], CalendarComponent.prototype, "yearCellTemplateRef", null);
__decorate([
    ContentChild(DecadeCellTemplateDirective, { static: false }),
    __metadata("design:type", DecadeCellTemplateDirective)
], CalendarComponent.prototype, "decadeCellTemplate", void 0);
__decorate([
    Input('decadeCellTemplate'),
    __metadata("design:type", DecadeCellTemplateDirective),
    __metadata("design:paramtypes", [DecadeCellTemplateDirective])
], CalendarComponent.prototype, "decadeCellTemplateRef", null);
__decorate([
    ContentChild(CenturyCellTemplateDirective, { static: false }),
    __metadata("design:type", CenturyCellTemplateDirective)
], CalendarComponent.prototype, "centuryCellTemplate", void 0);
__decorate([
    Input('centuryCellTemplate'),
    __metadata("design:type", CenturyCellTemplateDirective),
    __metadata("design:paramtypes", [CenturyCellTemplateDirective])
], CalendarComponent.prototype, "centuryCellTemplateRef", null);
__decorate([
    ContentChild(WeekNumberCellTemplateDirective, { static: false }),
    __metadata("design:type", WeekNumberCellTemplateDirective)
], CalendarComponent.prototype, "weekNumberTemplate", void 0);
__decorate([
    Input('weekNumberTemplate'),
    __metadata("design:type", WeekNumberCellTemplateDirective),
    __metadata("design:paramtypes", [WeekNumberCellTemplateDirective])
], CalendarComponent.prototype, "weekNumberTemplateRef", null);
__decorate([
    ContentChild(HeaderTitleTemplateDirective, { static: false }),
    __metadata("design:type", HeaderTitleTemplateDirective)
], CalendarComponent.prototype, "headerTitleTemplate", void 0);
__decorate([
    Input('headerTitleTemplate'),
    __metadata("design:type", HeaderTitleTemplateDirective),
    __metadata("design:paramtypes", [HeaderTitleTemplateDirective])
], CalendarComponent.prototype, "headerTitleTemplateRef", null);
__decorate([
    ContentChild(NavigationItemTemplateDirective, { static: false }),
    __metadata("design:type", NavigationItemTemplateDirective)
], CalendarComponent.prototype, "navigationItemTemplate", void 0);
__decorate([
    Input('navigationItemTemplate'),
    __metadata("design:type", NavigationItemTemplateDirective),
    __metadata("design:paramtypes", [NavigationItemTemplateDirective])
], CalendarComponent.prototype, "navigationItemTemplateRef", null);
__decorate([
    ViewChild(NavigationComponent, { static: false }),
    __metadata("design:type", NavigationComponent)
], CalendarComponent.prototype, "navigationView", void 0);
__decorate([
    ViewChild(ViewListComponent, { static: false }),
    __metadata("design:type", ViewListComponent)
], CalendarComponent.prototype, "monthView", void 0);
__decorate([
    ViewChild(MultiViewCalendarComponent, { static: false }),
    __metadata("design:type", MultiViewCalendarComponent)
], CalendarComponent.prototype, "multiViewCalendar", void 0);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], CalendarComponent.prototype, "widgetId", null);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], CalendarComponent.prototype, "calendarTabIndex", null);
__decorate([
    HostBinding('attr.aria-disabled'),
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CalendarComponent.prototype, "ariaDisabled", null);
CalendarComponent = __decorate([ __param(12, Optional()),
    __metadata("design:paramtypes", [BusViewService,
        CalendarDOMService,
        ElementRef,
        NavigationService,
        Renderer2,
        ChangeDetectorRef,
        NgZone,
        Injector,
        ScrollSyncService,
        DisabledDatesService,
        LocalizationService,
        SelectionService,
        PickerService])
], CalendarComponent);

/**
 * @hidden
 */
const incompleteDateValidator = () => {
    return (control, incomplete) => {
        if (!isPresent(control.value) && incomplete) {
            return { incompleteDate: true };
        }
        else {
            return null;
        }
    };
};

/**
 * @hidden
 */
var Arrow;
(function (Arrow) {
    Arrow[Arrow["Up"] = 0] = "Up";
    Arrow[Arrow["Down"] = 1] = "Down";
    Arrow[Arrow["None"] = 2] = "None";
})(Arrow || (Arrow = {}));

var DateInputComponent_1;
const MIN_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-min';
const MAX_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-max';
const VALUE_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/dateinput/#toc-using-with-json';
const DATE_PART_REGEXP = /year|month|<day>/;
const TIME_PART_REGEXP = /hour|minute|second|millisecond/;
const SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;
const TWO_DIGIT_YEAR_MAX = 68;
const PREVIOUS_CENTURY_BASE = 1900;
const CURRENT_CENTURY_BASE = 2000;
const DEFAULT_FORMAT = 'd';
const padZero = (length) => new Array(Math.max(length, 0)).fill('0').join('');
const unpadZero = (value) => value.replace(/^0*/, '');
class Mask {
    constructor() {
        this.symbols = "";
    }
}
class KendoDate {
    constructor(intl, formatPlaceholder, format, value, twoDigitYearMax = TWO_DIGIT_YEAR_MAX) {
        this.intl = intl;
        this.formatPlaceholder = formatPlaceholder;
        this.format = format;
        this.twoDigitYearMax = twoDigitYearMax;
        this.year = true;
        this.month = true;
        this.date = true;
        this.hours = true;
        this.minutes = true;
        this.seconds = true;
        this.milliseconds = true;
        this.leadingZero = null;
        this.monthNames = null;
        this.typedMonthPart = "";
        this.value = getDate(new Date());
        this.knownParts = "adHhmMsSEy";
        this.symbols = {
            "E": "E",
            "H": "H",
            "M": "M",
            "a": "a",
            "d": "d",
            "h": "h",
            "m": "m",
            "s": "s",
            "S": "S",
            "y": "y"
        };
        validatePackage(packageMetadata);
        this.monthNames = this.allFormatedMonths();
        this.dayPeriods = this.allDayPeriods();
        if (!value) {
            this.value = getDate(new Date());
            const sampleFormat = this.dateFormatString(this.value, this.format).symbols;
            for (let i = 0; i < sampleFormat.length; i++) {
                this.setExisting(sampleFormat[i], false);
            }
        }
        else {
            this.value = cloneDate(value);
        }
    }
    hasValue() {
        const pred = (a, p) => a || p.type !== 'literal' && p.type !== 'dayperiod' && this.getExisting(p.pattern[0]);
        return this.intl.splitDateFormat(this.format).reduce(pred, false);
    }
    shouldNormalizeCentury() {
        return this.intl.splitDateFormat(this.format).some(part => part.pattern === 'yy');
    }
    getDateObject() {
        for (let i = 0; i < this.knownParts.length; i++) {
            if (!this.getExisting(this.knownParts[i])) {
                return null;
            }
        }
        return cloneDate(this.value);
    }
    getTextAndFormat(format) {
        return this.merge(this.intl.formatDate(this.value, format), this.dateFormatString(this.value, format));
    }
    getExisting(symbol) {
        switch (symbol) {
            case "y": return this.year;
            case "M":
            case "L": return this.month;
            case "d": return this.date;
            case "E": return this.date && this.month && this.year;
            case "h":
            case "H": return this.hours;
            case "m": return this.minutes;
            case "s": return this.seconds;
            case "S": return this.milliseconds;
            default: return true;
        }
    }
    setExisting(symbol, value) {
        switch (symbol) {
            case "y":
                this.year = value;
                if (value === false) {
                    this.value.setFullYear(2000);
                }
                break; //allow 2/29 dates
            case "M":
                this.month = value;
                if (value === false) {
                    this.value.setMonth(0);
                }
                break; //make sure you can type 31 at day part
            case "d":
                this.date = value;
                break;
            case "h":
            case "H":
                this.hours = value;
                break;
            case "m":
                this.minutes = value;
                break;
            case "s":
                this.seconds = value;
                break;
            case "S":
                this.milliseconds = value;
                break;
            default: return;
        }
    }
    modifyPart(symbol, offset) {
        let newValue = cloneDate(this.value);
        switch (symbol) {
            case "y":
                newValue.setFullYear(newValue.getFullYear() + offset);
                break;
            case "M":
                newValue = addMonths(this.value, offset);
                break;
            case "d":
            case "E":
                newValue.setDate(newValue.getDate() + offset);
                break;
            case "h":
            case "H":
                newValue.setHours(newValue.getHours() + offset);
                break;
            case "m":
                newValue.setMinutes(newValue.getMinutes() + offset);
                break;
            case "s":
                newValue.setSeconds(newValue.getSeconds() + offset);
                break;
            case "S":
                newValue.setMilliseconds(newValue.getMilliseconds() + offset);
                break;
            case "a":
                newValue.setHours(newValue.getHours() + (12 * offset));
                break;
            default: break;
        }
        if (this.shouldNormalizeCentury()) {
            newValue = this.normalizeCentury(newValue);
        }
        if (newValue.getFullYear() > 0) {
            this.setExisting(symbol, true);
            this.value = newValue;
        }
    }
    parsePart(symbol, currentChar, resetSegmentValue) {
        if (!currentChar) {
            this.resetLeadingZero();
            this.setExisting(symbol, false);
            return { value: null, switchToNext: false };
        }
        let baseDate = this.intl.formatDate(this.value, this.format);
        let dateParts = this.dateFormatString(this.value, this.format);
        let baseFormat = dateParts.symbols;
        let replaced = false;
        let prefix = "";
        let current = "";
        let suffix = "";
        for (let i = 0; i < baseDate.length; i++) {
            if (baseFormat[i] === symbol) {
                current += this.getExisting(symbol) ? baseDate[i] : "0";
                replaced = true;
            }
            else if (!replaced) {
                prefix += baseDate[i];
            }
            else {
                suffix += baseDate[i];
            }
        }
        let currentMaxLength = current.length - 3;
        let parsedDate = null;
        const month = this.matchMonth(currentChar);
        const dayPeriod = this.matchDayPeriod(currentChar, symbol);
        const isZeroCurrentChar = currentChar === '0';
        const leadingZero = (this.leadingZero || {})[symbol] || 0;
        if (isZeroCurrentChar) {
            let valueNumber = parseInt(resetSegmentValue ? currentChar : current + currentChar, 10);
            if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol)) {
                this.incrementLeadingZero(symbol);
            }
        }
        else {
            this.resetLeadingZero();
        }
        for (let i = Math.max(0, currentMaxLength); i <= current.length; i++) {
            let middle = resetSegmentValue ? currentChar : (current.substring(i) + currentChar);
            if (symbol === "S" && resetSegmentValue) {
                // The "S" parser in intl parses "1" as 100ms in order to handle ISOString dates correctly, so to get 1ms, we need to pass "001"
                const padding = msPaddingFromFormat(baseFormat);
                middle = padding + middle;
            }
            let middleNumber = parseInt(middle, 10);
            parsedDate = this.intl.parseDate(prefix + middle + suffix, this.format);
            if (!parsedDate && !isNaN(middleNumber) && !isNaN(parseInt(currentChar, 10))) {
                if (symbol === 'M' && !month) {
                    const monthNumber = middleNumber - 1;
                    if (monthNumber > -1 && monthNumber < 12) {
                        parsedDate = cloneDate(this.value);
                        parsedDate.setMonth(monthNumber);
                        if (parsedDate.getMonth() !== monthNumber) {
                            parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));
                        }
                    }
                }
                if (symbol === 'y') {
                    parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);
                    if (this.date && parsedDate.getDate() !== this.value.getDate()) {
                        parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));
                    }
                }
            }
            if (parsedDate) {
                //move to next segment if the part will overflow with next char
                //when start from empty date (01, then 010), padded zeros should be trimmed
                const patternValue = this.partPattern(dateParts.partMap, symbol).pattern;
                const peekDate = this.intl.parseDate(`${prefix}${this.peek(middle, patternValue)}${suffix}`, this.format);
                const patternLength = this.patternLength(patternValue) || patternValue.length;
                const patternSatisfied = (leadingZero + (unpadZero(middle) || currentChar).length) >= patternLength;
                const switchToNext = peekDate === null || patternSatisfied;
                if (this.shouldNormalizeCentury()) {
                    parsedDate = this.normalizeCentury(parsedDate);
                }
                this.value = parsedDate;
                this.setExisting(symbol, true);
                return { value: this.value, switchToNext: switchToNext };
            }
        }
        if (month) {
            parsedDate = this.intl.parseDate(prefix + month + suffix, this.format);
            if (parsedDate) {
                this.value = parsedDate;
                this.setExisting(symbol, true);
                return { value: this.value, switchToNext: false };
            }
        }
        if (dayPeriod) {
            parsedDate = this.intl.parseDate(prefix + dayPeriod + suffix, this.format);
            if (parsedDate) {
                this.value = parsedDate;
                return { value: this.value, switchToNext: true };
            }
        }
        if (isZeroCurrentChar) {
            this.setExisting(symbol, false);
        }
        return { value: null, switchToNext: false };
    }
    resetLeadingZero() {
        const hasLeadingZero = this.leadingZero !== null;
        this.setLeadingZero(null);
        return hasLeadingZero;
    }
    setLeadingZero(leadingZero) {
        this.leadingZero = leadingZero;
    }
    normalizeCentury(date) {
        if (!isPresent(date)) {
            return date;
        }
        const twoDigitYear = cropTwoDigitYear(date);
        const centuryBase = this.getNormalizedCenturyBase(twoDigitYear);
        const normalizedDate = setYears(date, centuryBase + twoDigitYear);
        return normalizedDate;
    }
    incrementLeadingZero(symbol) {
        const leadingZero = this.leadingZero || {};
        leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;
        this.leadingZero = leadingZero;
    }
    isAbbrMonth(parts, symbol) {
        const pattern = this.partPattern(parts, symbol);
        return pattern.type === 'month' && pattern.names;
    }
    partPattern(parts, symbol) {
        return parts.filter((part) => part.pattern.indexOf(symbol) !== -1)[0];
    }
    peek(value, pattern) {
        const peekValue = unpadZero(value) + '0';
        return padZero(pattern.length - peekValue.length) + peekValue;
    }
    matchMonth(typedChar) {
        this.typedMonthPart += typedChar.toLowerCase();
        if (!this.monthNames) {
            return "";
        }
        while (this.typedMonthPart.length > 0) {
            for (let i = 0; i < this.monthNames.length; i++) {
                if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {
                    return this.monthNames[i];
                }
            }
            const monthAsNum = parseInt(this.typedMonthPart, 10);
            if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart /*ensure they exact match*/) {
                return this.monthNames[monthAsNum - 1];
            }
            this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);
        }
        return "";
    }
    matchDayPeriod(typedChar, symbol) {
        const lowerChart = String(typedChar).toLowerCase();
        if (symbol === 'a' && this.dayPeriods) {
            if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {
                return this.dayPeriods.am;
            }
            else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {
                return this.dayPeriods.pm;
            }
        }
        return '';
    }
    allFormatedMonths() {
        const dateFormatParts = this.intl.splitDateFormat(this.format);
        for (let i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].type === "month" && dateFormatParts[i].names) {
                return this.intl.dateFormatNames(dateFormatParts[i].names);
            }
        }
        return null;
    }
    allDayPeriods() {
        const dateFormatParts = this.intl.splitDateFormat(this.format);
        for (let i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].type === "dayperiod" && dateFormatParts[i].names) {
                return this.intl.dateFormatNames(dateFormatParts[i].names);
            }
        }
        return null;
    }
    patternLength(pattern) {
        if (pattern[0] === 'y') {
            return 4;
        }
        if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {
            return 2;
        }
        return 0;
    }
    //TODO: REMOVE!
    dateFormatString(date, format) {
        const dateFormatParts = this.intl.splitDateFormat(format);
        const parts = [];
        const partMap = [];
        for (let i = 0; i < dateFormatParts.length; i++) {
            let partLength = this.intl.formatDate(date, { pattern: dateFormatParts[i].pattern }).length;
            while (partLength > 0) {
                parts.push(this.symbols[dateFormatParts[i].pattern[0]] || "_");
                partMap.push(dateFormatParts[i]);
                partLength--;
            }
        }
        const returnValue = new Mask();
        returnValue.symbols = parts.join("");
        returnValue.partMap = partMap;
        return returnValue;
    }
    merge(text, mask) {
        // Important: right to left.
        let resultText = "";
        let resultFormat = "";
        let format = mask.symbols;
        for (let r = format.length - 1; r >= 0; r--) {
            if (this.knownParts.indexOf(format[r]) === -1 || this.getExisting(format[r])) {
                resultText = text[r] + resultText;
                resultFormat = format[r] + resultFormat;
            }
            else {
                const currentSymbol = format[r];
                while (r >= 0 && currentSymbol === format[r]) {
                    r--;
                }
                r++;
                if (this.leadingZero && this.leadingZero[currentSymbol]) {
                    resultText = '0' + resultText;
                }
                else {
                    resultText = this.dateFieldName(mask.partMap[r]) + resultText;
                }
                while (resultFormat.length < resultText.length) {
                    resultFormat = format[r] + resultFormat;
                }
            }
        }
        return [resultText, resultFormat];
    }
    dateFieldName(part) {
        const formatPlaceholder = this.formatPlaceholder || 'wide';
        if (formatPlaceholder[part.type]) {
            return formatPlaceholder[part.type];
        }
        if (formatPlaceholder === 'formatPattern') {
            return part.pattern;
        }
        return this.intl.dateFieldName(Object.assign(part, { nameType: formatPlaceholder }));
    }
    getNormalizedCenturyBase(twoDigitYear) {
        return twoDigitYear > this.twoDigitYearMax ?
            PREVIOUS_CENTURY_BASE :
            CURRENT_CENTURY_BASE;
    }
}
/**
 * Represents the [Kendo UI DateInput component for Angular]({% slug overview_dateinput %}#toc-basic-usage).
 */
let DateInputComponent = DateInputComponent_1 = class DateInputComponent {
    constructor(cdr, intl, renderer, wrapper, ngZone, injector, localization, pickerService) {
        this.cdr = cdr;
        this.intl = intl;
        this.renderer = renderer;
        this.wrapper = wrapper;
        this.ngZone = ngZone;
        this.injector = injector;
        this.localization = localization;
        this.pickerService = pickerService;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Sets or gets the `disabled` property of the DateInput and
         * determines whether the component is active
         * ([see example]({% slug disabled_dateinput %})).
         */
        this.disabled = false;
        /**
         * Sets or gets the read-only state of the DateInput
         * ([see example]({% slug readonly_dateinput %})).
         */
        this.readonly = false;
        /**
         * Sets the title of the input element of the DateInput.
         */
        this.title = "";
        /**
         * Sets or gets the `tabIndex` property of the DateInput.
         * .
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.role = 'spinbutton';
        /**
         * @hidden
         */
        this.ariaReadOnly = false;
        /**
         * Specifies the date format that is used to display the input value
         * ([see example]({% slug formats_dateinput %})).
         *
         * Format value options:
         * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.
         * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.
         */
        this.format = DEFAULT_FORMAT;
        /**
         * Specifies the hint the DateInput displays when its value is `null`.
         * For more information, refer to the article on
         * [placeholders]({% slug placeholders_dateinput %}).
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-dateinput placeholder="Enter birth date..."></kendo-dateinput>
         * `
         * })
         * export class AppComponent { }
         * ```
         */
        this.placeholder = null;
        /**
         * Configures the incremental steps of the DateInput.
         * For more information, refer to the article on
         * [incremental steps]({% slug incrementalsteps_dateinput %}).
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-dateinput [steps]="steps"></kendo-dateinput>
         * `
         * })
         * export class AppComponent {
         *   public steps = { year: 10, month: 1, day: 5 };
         * }
         * ```
         */
        this.steps = {};
        /**
         * Determines whether the built-in min or max validators are to be enforced when a form is being validated.
         */
        this.rangeValidation = true;
        /**
         * @hidden
         * Based on the min and max values, specifies whether the value will be auto-corrected while typing.
         */
        this.autoCorrect = false;
        /**
         * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
         */
        this.incompleteDateValidation = false;
        /**
         * The maximum year to assume to be from the current century when typing two-digit year value
         * ([see example]({% slug formats_dateinput %}#toc-two-digit-year-format)).
         *
         * The default value is 68, indicating that typing any value less than 69
         * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
         */
        this.twoDigitYearMax = TWO_DIGIT_YEAR_MAX;
        /**
         * Specifies whether the **Up** and **Down** spin buttons will be rendered.
         * For more information, refer to the article on
         * [spinner buttons]({% slug spinbuttons_dateinput %}).
         */
        this.spinners = false;
        /**
         * @hidden
         */
        this.isPopupOpen = false;
        /**
         * @hidden
         */
        this.hasPopup = false;
        /**
         * Fires each time the user selects a new value.
         * For more information, refer to the section on
         * [events]({% slug overview_dateinput %}#toc-events).
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         * Fires each time the user selects a new value.
         * For more information, refer to the section on
         * [events]({% slug overview_dateinput %}#toc-events).
         */
        this.valueUpdate = new EventEmitter();
        /**
         * Fires each time the user focuses the input element.
         * For more information, refer to the section on
         * [events]({% slug overview_dateinput %}#toc-events).
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-dateinput (focus)="handleFocus()"></kendo-dateinput>
         * `
         * })
         * export class AppComponent {
         *   public handleFocus(): void {
         *      console.log("Component is focused");
         *   }
         * }
         * ```
         *
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the input element gets blurred.
         * For more information, refer to the section on
         * [events]({% slug overview_dateinput %}#toc-events).
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-dateinput (blur)="handleBlur()"></kendo-dateinput>
         * `
         * })
         * export class AppComponent {
         *   public handleBlur(): void {
         *      console.log("Component is blurred");
         *   }
         * }
         * ```
         *
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        this.arrow = Arrow;
        this.arrowDirection = Arrow.None;
        this.formatSections = { date: false, time: false };
        this.hasMousedown = false;
        this.focusedPriorToMousedown = false;
        /**
         * @hidden
         */
        this.isDateIncomplete = false;
        this.currentValue = "";
        this.currentFormat = "";
        this.backspace = false;
        this.resetSegmentValue = true;
        this.minValidator = noop;
        this.maxValidator = noop;
        this.incompleteValidator = noop;
        this._value = null;
        this._active = false;
        this.kendoDate = null;
        this.paste = false;
        this.domEvents = [];
        this.onControlChange = noop;
        this.onControlTouched = noop;
        this.onValidatorChange = noop;
        this._size = 'medium';
        this._rounded = 'medium';
        this._fillMode = 'solid';
        this.symbolsMap = this.dateSymbolMap();
        this.updateFormatSections();
        if (this.pickerService) {
            this.pickerService.input = this;
        }
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Specifies the value of the DateInput component.
     *
     * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.
     */
    set value(value) {
        this.verifyValue(value);
        if (this.autoCorrect && !isInRange(value, this.min, this.max)) {
            return;
        }
        this._value = cloneDate(value);
        this.valueUpdate.emit(cloneDate(value));
    }
    get value() {
        return this._value;
    }
    /**
     * Sets the size of the component.
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (Default)
     * * `'large'`
     * * `null`
     *
     */
    set size(size) {
        this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));
        if (size) {
            this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', size));
        }
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * Sets the border radius of the component.
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (Default)
     * * `'large'`
     * * `'full'`
     * * `null`
     *
     */
    set rounded(rounded) {
        this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
        if (rounded) {
            this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(rounded));
        }
        this._rounded = rounded;
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * Sets the fillMode of the component.
     *
     * The possible values are:
     * * `'solid'` (Default)
     * * `'flat'`
     * * `'outline'`
     * * `null`
     *
     */
    set fillMode(fillMode) {
        this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));
        if (fillMode) {
            this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', fillMode));
            if (this.spinners && this.spinup && this.spindown) {
                this.setSpinnerFill(this.spinup.nativeElement, fillMode, this.fillMode);
                this.setSpinnerFill(this.spindown.nativeElement, fillMode, this.fillMode);
            }
        }
        this._fillMode = fillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    get wrapperClass() {
        return true;
    }
    get disabledClass() {
        return this.disabled;
    }
    get inputElement() {
        return this.dateInput ? this.dateInput.nativeElement : null;
    }
    get inputValue() {
        return (this.inputElement || {}).value || '';
    }
    get isActive() {
        return this._active;
    }
    set isActive(value) {
        this._active = value;
        if (!this.wrapper) {
            return;
        }
        if (!isPresent(this.pickerService)) {
            const element = this.wrapper.nativeElement;
            if (value) {
                this.renderer.addClass(element, 'k-focus');
            }
            else {
                this.renderer.removeClass(element, 'k-focus');
            }
        }
    }
    get inputFormat() {
        if (!this.format) {
            return DEFAULT_FORMAT;
        }
        if (typeof this.format === 'string') {
            return this.format;
        }
        else {
            return this.format.inputFormat;
        }
    }
    get displayFormat() {
        if (!this.format) {
            return DEFAULT_FORMAT;
        }
        if (typeof this.format === 'string') {
            return this.format;
        }
        else {
            return this.format.displayFormat;
        }
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty
     */
    isEmpty() {
        return !this.currentValue || !String(this.currentValue).trim();
    }
    /**
     * @hidden
     */
    containsElement(element) {
        return Boolean(closest(element, node => node === this.wrapper.nativeElement));
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        this.verifyRange();
        if (changes.min || changes.max || changes.rangeValidation || changes.incompleteDateValidation) {
            this.minValidator = this.rangeValidation ? minValidator(this.min) : noop;
            this.maxValidator = this.rangeValidation ? maxValidator(this.max) : noop;
            this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop;
            this.onValidatorChange();
        }
        if (changes.format) {
            this.symbolsMap = this.dateSymbolMap();
            this.updateFormatSections();
        }
        const isEqualToKendoDate = this.kendoDate && isEqual(this.value, this.kendoDate.getDateObject());
        if (changes.format || !isEqualToKendoDate || changes.placeholder) {
            this.kendoDate = this.getKendoDate(this.value);
            this.updateElementValue(this.isActive);
        }
    }
    ngOnDestroy() {
        if (this.intlSubscription) {
            this.intlSubscription.unsubscribe();
        }
        if (this.pickerService) {
            this.pickerService.input = null;
        }
        this.domEvents.forEach(unbindCallback => unbindCallback());
    }
    /**
     * @hidden
     */
    validate(control) {
        return this.minValidator(control) || this.maxValidator(control) || this.incompleteValidator(control, this.isDateIncomplete);
    }
    /**
     * @hidden
     */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.kendoDate = this.getKendoDate(this.value);
        this.updateElementValue();
        this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
        this.ngControl = this.injector.get(NgControl, null);
        if (this.wrapper) {
            this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');
            this.ngZone.runOutsideAngular(() => {
                this.bindEvents();
            });
        }
    }
    ngAfterViewInit() {
        this.setComponentClasses();
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.cdr.markForCheck();
    }
    //ngModel binding
    /**
     * @hidden
     */
    writeValue(value) {
        this.verifyValue(value);
        this.kendoDate = this.getKendoDate(value);
        this.value = cloneDate(value);
        this.updateElementValue(this.isActive);
    }
    /**
     * @hidden
     */
    triggerChange() {
        const value = this.kendoDate.getDateObject();
        if (+value !== +this.value) {
            this.value = cloneDate(value);
            this.notify();
        }
    }
    /**
     * @hidden
     */
    notify() {
        this.ngZone.run(() => {
            this.onControlChange(cloneDate(this.value));
            this.valueChange.emit(cloneDate(this.value));
        });
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onControlChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onControlTouched = fn;
    }
    /**
     * Focuses the DateInput component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="dateinput.focus()">Focus date input</button>
     *  <kendo-dateinput #dateinput></kendo-dateinput>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    focus() {
        const input = this.inputElement;
        if (input) {
            input.focus();
            this.selectDateSegment(this.currentFormat[0]);
        }
    }
    /**
     * Blurs the DateInput component.
     */
    blur() {
        const input = this.inputElement;
        if (input) {
            input.blur();
        }
    }
    /**
     * @hidden
     */
    handleButtonClick(offset) {
        this.arrowDirection = Arrow.None;
        this.modifyDateSegmentValue(offset);
    }
    /**
     * @hidden
     */
    modifyDateSegmentValue(offset) {
        const caret = this.caret();
        const symbol = this.currentFormat[caret[0]];
        let step = (this.steps || {})[this.symbolsMap[symbol]] || 1;
        if (symbol === "S" && !this.steps.millisecond) {
            const msDigits = millisecondDigitsInFormat(this.inputFormat);
            step = millisecondStepFor(msDigits);
        }
        this.kendoDate.modifyPart(symbol, offset * step);
        this.putDateInRange();
        this.updateElementValue(this.isActive);
        this.triggerChange();
        this.selectDateSegment(symbol);
        this.updateIncompleteValidationStatus();
    }
    /**
     * @hidden
     */
    switchDateSegment(offset) {
        const caret = this.caret();
        if (this.kendoDate.resetLeadingZero()) {
            this.updateElementValue(this.isActive);
        }
        if (caret[0] < caret[1] && this.currentFormat[caret[0]] !== this.currentFormat[caret[1] - 1]) {
            this.selectNearestSegment(offset > 0 ? caret[0] : caret[1] - 1);
            this.resetSegmentValue = true;
            return true;
        }
        const previousFormatSymbol = this.currentFormat[caret[0]];
        let a = caret[0] + offset;
        while (a > 0 && a < this.currentFormat.length) {
            if (this.currentFormat[a] !== previousFormatSymbol &&
                this.currentFormat[a] !== "_") {
                break;
            }
            a += offset;
        }
        if (this.currentFormat[a] === "_") {
            //there is not known symbol found
            return false;
        }
        let b = a;
        while (b >= 0 && b < this.currentFormat.length) {
            if (this.currentFormat[b] !== this.currentFormat[a]) {
                break;
            }
            b += offset;
        }
        if (a > b && (b + 1 !== caret[0] || a + 1 !== caret[1])) {
            this.caret(b + 1, a + 1);
            this.resetSegmentValue = true;
            return true;
        }
        else if (a < b && (a !== caret[0] || b !== caret[1])) {
            this.caret(a, b);
            this.resetSegmentValue = true;
            return true;
        }
        return false;
    }
    /**
     * @hidden
     */
    selectDateSegment(symbol) {
        let begin = -1;
        let end = 0;
        for (let i = 0; i < this.currentFormat.length; i++) {
            if (this.currentFormat[i] === symbol) {
                end = i + 1;
                if (begin === -1) {
                    begin = i;
                }
            }
        }
        if (begin < 0) {
            begin = 0;
        }
        this.caret(0, 0);
        this.caret(begin, end);
    }
    /**
     * @hidden
     */
    handleClick() {
        this.hasMousedown = false;
        if (this.isActive) {
            const selectionPresent = this.inputElement.selectionStart !== this.inputElement.selectionEnd;
            const placeholderToggled = isPresent(this.placeholder) && !this.kendoDate.hasValue() && !this.focusedPriorToMousedown;
            // focus first segment if the user hasn't selected something during mousedown and if the placeholder was just toggled
            const selectFirstSegment = !selectionPresent && placeholderToggled;
            const index = selectFirstSegment ? 0 : this.caret()[0];
            this.selectNearestSegment(index);
        }
    }
    /**
     * @hidden
     */
    handleDragAndDrop(args) {
        args.preventDefault();
    }
    /**
     * @hidden
     */
    handleMousedown() {
        this.hasMousedown = true;
        this.focusedPriorToMousedown = this.isActive;
    }
    /**
     * @hidden
     */
    handleFocus(args) {
        this.isActive = true;
        this.updateElementValue();
        if (!this.hasMousedown) {
            this.caret(0, this.inputValue.length);
        }
        this.hasMousedown = false;
        if (hasObservers(this.onFocus)) {
            this.ngZone.run(() => {
                this.emitFocus(args);
            });
        }
        else {
            this.emitFocus(args);
        }
    }
    /**
     * @hidden
     */
    handleBlur(args) {
        this.isActive = false;
        this.resetSegmentValue = true;
        this.kendoDate.resetLeadingZero();
        this.updateElementValue();
        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.ngControl)) {
            this.ngZone.run(() => {
                this.onControlTouched();
                this.emitBlur(args);
                this.cdr.markForCheck();
            });
        }
        else {
            this.emitBlur(args);
        }
    }
    getKendoDate(value) {
        const { leadingZero } = (this.kendoDate || {}) || null;
        const kendoDate = new KendoDate(this.intl, this.formatPlaceholder, this.inputFormat, value, this.twoDigitYearMax);
        kendoDate.setLeadingZero(this.isActive ? leadingZero : null);
        return kendoDate;
    }
    dateSymbolMap() {
        const reducer = (map$$1, part) => {
            map$$1[part.pattern[0]] = part.type;
            return map$$1;
        };
        return this.intl.splitDateFormat(this.inputFormat).reduce(reducer, {});
    }
    updateElementValue(isActive) {
        const start = this.caret()[0]; //XXX: get caret position before input is updated
        const format = this.isActive ? this.inputFormat : this.displayFormat;
        const texts = this.kendoDate.getTextAndFormat(format);
        const showPlaceholder = !this.isActive && isPresent(this.placeholder) && !this.kendoDate.hasValue();
        const input = this.inputElement;
        this.currentFormat = texts[1];
        this.currentValue = !showPlaceholder ? texts[0] : '';
        this.renderer.setProperty(input, "value", this.currentValue);
        if (input.placeholder !== this.placeholder) {
            this.renderer.setProperty(input, "placeholder", this.placeholder);
        }
        if (isActive) {
            this.selectNearestSegment(start);
        }
    }
    caret(start, end = start) {
        const isPosition = start !== undefined;
        let returnValue = [start, start];
        const element = this.inputElement;
        if (isPosition && (this.disabled || this.readonly)) {
            return undefined;
        }
        try {
            if (element.selectionStart !== undefined) {
                if (isPosition) {
                    if (isDocumentAvailable() && document.activeElement !== element) {
                        element.focus();
                    }
                    element.setSelectionRange(start, end);
                }
                returnValue = [element.selectionStart, element.selectionEnd];
            }
        }
        catch (e) {
            returnValue = [];
        }
        return returnValue;
    }
    selectNearestSegment(index) {
        // Finds the nearest (in both directions) known part.
        for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {
            if (i < this.currentFormat.length && this.currentFormat[i] !== "_") {
                this.selectDateSegment(this.currentFormat[i]);
                return;
            }
            if (j >= 0 && this.currentFormat[j] !== "_") {
                this.selectDateSegment(this.currentFormat[j]);
                return;
            }
        }
    }
    verifyRange() {
        if (!isDevMode()) {
            return;
        }
        if (!isValidRange(this.min, this.max)) {
            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$2} and ${MAX_DOC_LINK$2}.`);
        }
    }
    verifyValue(value) {
        if (!isDevMode()) {
            return;
        }
        if (value && !(value instanceof Date)) {
            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$2} for possible resolution.`);
        }
    }
    putDateInRange() {
        const currentDate = this.kendoDate.getDateObject();
        const candidate = dateInRange(currentDate, this.min, this.max);
        if (this.autoCorrect && !isEqual(currentDate, candidate)) {
            this.kendoDate = this.getKendoDate(candidate);
        }
    }
    updateFormatSections() {
        this.formatSections = this.intl.splitDateFormat(this.inputFormat)
            .reduce(({ date, time }, p) => {
            return {
                date: date || DATE_PART_REGEXP.test(p.type),
                time: time || TIME_PART_REGEXP.test(p.type)
            };
        }, { date: false, time: false });
    }
    intlChange() {
        this.updateFormatSections();
        this.kendoDate = this.getKendoDate(this.value);
        this.updateElementValue(this.isActive);
    }
    updateOnPaste() {
        let value = this.intl.parseDate(this.inputValue, this.inputFormat) || this.value;
        if (isPresent(value) && this.kendoDate.shouldNormalizeCentury()) {
            value = this.kendoDate.normalizeCentury(value);
        }
        const notify = +value !== +this.value;
        this.writeValue(value);
        if (notify) {
            this.notify();
        }
    }
    bindEvents() {
        const element = this.wrapper.nativeElement;
        const mousewheelHandler = this.handleMouseWheel.bind(this);
        this.domEvents.push(this.renderer.listen(element, 'DOMMouseScroll', mousewheelHandler), this.renderer.listen(element, 'mousewheel', mousewheelHandler), this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)), this.renderer.listen(element, 'paste', this.handlePaste.bind(this)), this.renderer.listen(element, 'input', this.handleInput.bind(this)));
    }
    handleMouseWheel(event) {
        if (this.disabled || this.readonly || !this.isActive) {
            return;
        }
        /* tslint:disable-next-line:deprecation */
        event = window.event || event;
        if (event.shiftKey) {
            this.switchDateSegment((event.wheelDelta || -event.detail) > 0 ? -1 : 1);
        }
        else {
            this.modifyDateSegmentValue((event.wheelDelta || -event.detail) > 0 ? 1 : -1);
        }
        event.returnValue = false;
        if (event.preventDefault) {
            event.preventDefault();
        }
        if (event.stopPropagation) {
            event.stopPropagation();
        }
    }
    handlePaste() {
        this.paste = true;
    }
    handleKeydown(event) {
        if (this.disabled || this.readonly || event.altKey || event.ctrlKey || event.metaKey) {
            return;
        }
        if (event.keyCode === Keys.Tab) {
            const moved = this.switchDateSegment(event.shiftKey ? -1 : 1);
            if (moved) {
                event.preventDefault();
            }
            return;
        }
        if (event.keyCode === Keys.Backspace) {
            this.backspace = true;
            return;
        }
        switch (event.keyCode) {
            case Keys.ArrowDown:
                this.modifyDateSegmentValue(-1);
                break;
            case Keys.ArrowUp:
                this.modifyDateSegmentValue(1);
                break;
            case Keys.ArrowRight:
                this.switchDateSegment(1);
                break;
            case Keys.ArrowLeft:
                this.switchDateSegment(-1);
                break;
            case Keys.Home:
                this.selectNearestSegment(0);
                break;
            case Keys.End:
                this.selectNearestSegment(this.inputValue.length);
                break;
            default:
                return; //skip the preventDefault if we didn't handled the keyCode
        }
        event.preventDefault();
    }
    handleInput() {
        if (this.disabled || this.readonly) {
            return;
        }
        if (this.paste) {
            this.updateOnPaste();
            this.paste = false;
            return;
        }
        const diff = approximateStringMatching(this.currentValue, this.currentFormat, this.inputValue, this.caret()[0]);
        const navigationOnly = (diff.length === 1 && diff[0][1] === "_");
        let switchPart = false;
        if (!navigationOnly) {
            let parsedPart;
            for (let i = 0; i < diff.length; i++) {
                parsedPart = this.kendoDate.parsePart(diff[i][0], diff[i][1], this.resetSegmentValue);
                switchPart = parsedPart.switchToNext;
            }
            const candidate = this.kendoDate.getDateObject();
            if (this.value && candidate && !this.formatSections.date) {
                this.kendoDate = this.getKendoDate(setTime(this.value, candidate));
            }
        }
        this.resetSegmentValue = false;
        this.putDateInRange();
        this.updateElementValue(this.isActive);
        this.triggerChange();
        this.updateIncompleteValidationStatus();
        if (diff.length && diff[0][0] !== "_") {
            this.selectDateSegment(diff[0][0]);
        }
        if (switchPart || navigationOnly) {
            this.switchDateSegment(1);
        }
        if (this.backspace) {
            this.switchDateSegment(-1);
        }
        this.backspace = false;
    }
    emitFocus(args) {
        this.onFocus.emit();
        if (this.pickerService) {
            this.pickerService.onFocus.emit(args);
        }
    }
    emitBlur(args) {
        this.onBlur.emit();
        if (this.pickerService) {
            this.pickerService.onBlur.emit(args);
        }
    }
    updateIncompleteValidationStatus() {
        const previousValue = this.isDateIncomplete;
        this.isDateIncomplete = this.kendoDate.hasValue() && this.value === null;
        if (previousValue === this.isDateIncomplete || !this.incompleteDateValidation) {
            return;
        }
        if (isPresent(this.ngControl) && !isPresent(this.pickerService)) {
            this.cdr.markForCheck();
            this.ngZone.run(() => this.onValidatorChange());
        }
        else if (isPresent(this.pickerService)) {
            this.pickerService.dateCompletenessChange.emit();
        }
    }
    setSpinnerFill(spinner, fill, oldFill) {
        if (oldFill) {
            this.renderer.removeClass(spinner, `k-button-${oldFill}`);
            this.renderer.removeClass(spinner, `k-button-${oldFill}-base`);
        }
        this.renderer.addClass(spinner, `k-button-${fill}`);
        this.renderer.addClass(spinner, `k-button-${fill}-base`);
    }
    setComponentClasses() {
        if (this.size) {
            this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));
        }
        if (this.rounded) {
            this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
        }
        if (this.fillMode) {
            this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));
        }
        if (this.spinners) {
            this.setSpinnerFill(this.spinup.nativeElement, this.fillMode);
            this.setSpinnerFill(this.spindown.nativeElement, this.fillMode);
        }
    }
};
DateInputComponent.ɵfac = function DateInputComponent_Factory(t) { return new (t || DateInputComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService), ɵngcc0.ɵɵdirectiveInject(PickerService, 8)); };
DateInputComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DateInputComponent, selectors: [["kendo-dateinput"]], viewQuery: function DateInputComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c19, 7);
        ɵngcc0.ɵɵviewQuery(_c20, 5);
        ɵngcc0.ɵɵviewQuery(_c21, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dateInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.spinup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.spindown = _t.first);
    } }, hostVars: 6, hostBindings: function DateInputComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-input", ctx.wrapperClass)("k-dateinput", ctx.wrapperClass)("k-disabled", ctx.disabledClass);
    } }, inputs: { focusableId: "focusableId", disabled: "disabled", readonly: "readonly", title: "title", tabindex: "tabindex", role: "role", ariaReadOnly: "ariaReadOnly", format: "format", placeholder: "placeholder", steps: "steps", rangeValidation: "rangeValidation", autoCorrect: "autoCorrect", incompleteDateValidation: "incompleteDateValidation", twoDigitYearMax: "twoDigitYearMax", spinners: "spinners", isPopupOpen: "isPopupOpen", hasPopup: "hasPopup", tabIndex: "tabIndex", value: "value", size: "size", rounded: "rounded", fillMode: "fillMode", formatPlaceholder: "formatPlaceholder", max: "max", min: "min" }, outputs: { valueChange: "valueChange", valueUpdate: "valueUpdate", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendo-dateinput"], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DateInputComponent_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => DateInputComponent_1), multi: true },
            { provide: L10N_PREFIX, useValue: 'kendo.dateinput' },
            { provide: KendoInput, useExisting: forwardRef(() => DateInputComponent_1) },
            LocalizationService
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 21, consts: function () { let i18n_22; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the **Increment** button in the DateInput
         * @meaning kendo.dateinput.increment
         */
        const MSG_EXTERNAL_589112377451589685$$DIST_FESM2015_INDEX_JS_23 = goog.getMsg("Increase value");
        i18n_22 = MSG_EXTERNAL_589112377451589685$$DIST_FESM2015_INDEX_JS_23;
    }
    else {
        i18n_22 = $localize `:kendo.dateinput.increment|The label for the **Increment** button in the DateInput␟a55944f9de69e7cc86b91200fe96f980a947d704␟589112377451589685:Increase value`;
    } let i18n_24; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the **Decrement** button in the DateInput
         * @meaning kendo.dateinput.decrement
         */
        const MSG_EXTERNAL_6980524091606682769$$DIST_FESM2015_INDEX_JS_25 = goog.getMsg("Decrease value");
        i18n_24 = MSG_EXTERNAL_6980524091606682769$$DIST_FESM2015_INDEX_JS_25;
    }
    else {
        i18n_24 = $localize `:kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput␟0eded761107e6dad120997006a7f915bade9b15c␟6980524091606682769:Decrease value`;
    } return [["kendoDateInputLocalizedMessages", "", "increment", i18n_22, "decrement", i18n_24], ["autocomplete", "off", "autocorrect", "off", "autocapitalize", "off", "spellcheck", "false", 1, "k-input-inner", 3, "id", "title", "tabindex", "disabled", "readonly", "placeholder", "kendoEventsOutsideAngular", "scope"], ["dateInput", ""], ["class", "k-input-spinner k-spin-button", 3, "mousedown", 4, "ngIf"], [1, "k-input-spinner", "k-spin-button", 3, "mousedown"], ["tabindex", "-1", 1, "k-spinner-increase", "k-button", "k-icon-button", 3, "title", "mousedown", "mouseleave", "click"], ["spinup", ""], [1, "k-button-icon", "k-icon", "k-i-arrow-n"], ["tabindex", "-1", 1, "k-spinner-decrease", "k-button", "k-icon-button", 3, "title", "click", "mousedown", "mouseleave"], ["spindown", ""], [1, "k-button-icon", "k-icon", "k-i-arrow-s"]]; }, template: function DateInputComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelement(1, "input", 1, 2);
        ɵngcc0.ɵɵtemplate(3, DateInputComponent_span_3_Template, 7, 8, "span", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("title", ctx.title)("tabindex", ctx.tabindex)("disabled", ctx.disabled)("readonly", ctx.readonly)("placeholder", ctx.placeholder)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction7(13, _c26, ctx.handleClick, ctx.handleFocus, ctx.handleMousedown, ctx.handleMousedown, ctx.handleDragAndDrop, ctx.handleDragAndDrop, ctx.handleBlur))("scope", ctx);
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-readonly", ctx.ariaReadOnly)("aria-expanded", ctx.isPopupOpen)("aria-haspopup", ctx.hasPopup);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.spinners);
    } }, directives: function () { return [DateInputLocalizedMessagesDirective, ɵngcc4.EventsOutsideAngularDirective, ɵngcc2.NgIf]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], DateInputComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateInputComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateInputComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateInputComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DateInputComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateInputComponent.prototype, "role", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateInputComponent.prototype, "ariaReadOnly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], DateInputComponent.prototype, "tabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateInputComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateInputComponent.prototype, "formatPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateInputComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateInputComponent.prototype, "steps", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], DateInputComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], DateInputComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateInputComponent.prototype, "rangeValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateInputComponent.prototype, "autoCorrect", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateInputComponent.prototype, "incompleteDateValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DateInputComponent.prototype, "twoDigitYearMax", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], DateInputComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateInputComponent.prototype, "spinners", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateInputComponent.prototype, "isPopupOpen", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateInputComponent.prototype, "hasPopup", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DateInputComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DateInputComponent.prototype, "rounded", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DateInputComponent.prototype, "fillMode", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DateInputComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DateInputComponent.prototype, "valueUpdate", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], DateInputComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], DateInputComponent.prototype, "onBlur", void 0);
__decorate([
    ViewChild('dateInput', { static: true }),
    __metadata("design:type", ElementRef)
], DateInputComponent.prototype, "dateInput", void 0);
__decorate([
    HostBinding('class.k-input'),
    HostBinding('class.k-dateinput'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DateInputComponent.prototype, "wrapperClass", null);
__decorate([
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DateInputComponent.prototype, "disabledClass", null);
__decorate([
    ViewChild('spinup', { static: false }),
    __metadata("design:type", ElementRef)
], DateInputComponent.prototype, "spinup", void 0);
__decorate([
    ViewChild('spindown', { static: false }),
    __metadata("design:type", ElementRef)
], DateInputComponent.prototype, "spindown", void 0);
DateInputComponent = DateInputComponent_1 = __decorate([ __param(7, Optional()),
    __metadata("design:paramtypes", [ChangeDetectorRef,
        IntlService,
        Renderer2,
        ElementRef,
        NgZone,
        Injector,
        LocalizationService,
        PickerService])
], DateInputComponent);

/**
 * A preventable event instance which is triggered by the `open` and `close` events.
 */
class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * @hidden
 */
const TOUCH_ENABLED = new InjectionToken('dateinputs-touch-enabled');

/**
 * @hidden
 */
const disabledDatesValidator = (isDateDisabled) => {
    return (control) => {
        if (!isDateDisabled || !control.value) {
            return null;
        }
        const error = {
            disabledDate: true
        };
        return isDateDisabled(control.value) ? error : null;
    };
};

/* tslint:disable:max-line-length */
var DatePickerComponent_1;
const MIN_DOC_LINK$3 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-min';
const MAX_DOC_LINK$3 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-max';
const VALUE_DOC_LINK$3 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/datepicker/#toc-using-with-json';
const DEFAULT_FORMAT$1 = 'd';
const TWO_DIGIT_YEAR_MAX$1 = 68;
/**
 * Represents the [Kendo UI DatePicker component for Angular]({% slug overview_datepicker %}#toc-basic-usage).
 */
let DatePickerComponent = DatePickerComponent_1 = class DatePickerComponent {
    constructor(zone, localization, cdr, popupService, wrapper, renderer, injector, pickerService, disabledDatesService, touchEnabled$$1) {
        this.zone = zone;
        this.localization = localization;
        this.cdr = cdr;
        this.popupService = popupService;
        this.wrapper = wrapper;
        this.renderer = renderer;
        this.injector = injector;
        this.pickerService = pickerService;
        this.disabledDatesService = disabledDatesService;
        this.touchEnabled = touchEnabled$$1;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Defines the active view that the Calendar initially renders
         * ([see example]({% slug calendar_type_datepicker %}#toc-active-view)).
         * By default, the active view is `month`.
         *
         * > You have to set `activeView` within the `topView`-`bottomView` range.
         */
        this.activeView = CalendarViewEnum[CalendarViewEnum.month];
        /**
         * Defines the bottommost Calendar view to which the user can navigate
         * ([see example]({% slug calendar_type_datepicker %}#toc-focused-dates)).
         */
        this.bottomView = CalendarViewEnum[CalendarViewEnum.month];
        /**
         * Defines the topmost Calendar view to which the user can navigate
         * ([see example]({% slug calendar_type_datepicker %}#toc-focused-dates)).
         */
        this.topView = CalendarViewEnum[CalendarViewEnum.century];
        /**
         * Specifies the Calendar type.
         *
         * The possible values are:
         * - `infinite` (default)
         * - `classic`
         *
         */
        this.calendarType = 'infinite';
        /**
         * Determines whether to enable animation when navigating to previous/next Calendar view.
         * Applies to the [`classic`]({% slug api_dateinputs_datepickercomponent %}#toc-calendartype) Calendar only.
         *
         * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
         *
         * @default false
         */
        this.animateCalendarNavigation = false;
        /**
         * Sets or gets the `disabled` property of the DatePicker and determines whether the component is active
         * ([see example]({% slug disabled_datepicker %})).
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the DatePicker
         * ([see example]({% slug readonly_datepicker %}#toc-read-only-datepicker)).
         */
        this.readonly = false;
        /**
         * Sets the read-only state of the DatePicker input field
         * ([see example]({% slug readonly_datepicker %}#toc-read-only-input)).
         *
         * > Note that if you set the [`readonly`]({% slug api_dateinputs_datepickercomponent %}#toc-readonly) property value to `true`,
         * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
         */
        this.readOnlyInput = false;
        /**
         * Sets or gets the `navigation` property of the Calendar
         * and determines whether the navigation side-bar is displayed.
         * ([see example]({% slug sidebar_datepicker %})).
         */
        this.navigation = true;
        /**
         * Specifies the smallest valid date
         * ([see example]({% slug dateranges_datepicker %})).
         * By default, the `min` value is `1900-1-1`.
         */
        this.min = cloneDate(MIN_DATE);
        /**
         * Specifies the biggest valid date
         * ([see example]({% slug dateranges_datepicker %})).
         * By default, the `max` value is `2099-12-31`.
         */
        this.max = cloneDate(MAX_DATE);
        /**
         * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
         */
        this.incompleteDateValidation = false;
        /**
         * Specifies the focused date of the Calendar component
         * ([see example]({% slug calendar_type_datepicker %}#toc-focused-dates)).
         */
        this.focusedDate = null;
        /**
         * Specifies the date format that is used to display the input value
         * ([see example]({% slug formats_datepicker %})).
         *
         * Format value options:
         * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.
         * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.
         */
        this.format = DEFAULT_FORMAT$1;
        /**
         * The maximum year to assume to be from the current century when typing two-digit year value
         * ([see example]({% slug formats_datepicker %}#toc-two-digit-year-format)).
         *
         * The default value is 68, indicating that typing any value less than 69
         * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
         */
        this.twoDigitYearMax = TWO_DIGIT_YEAR_MAX$1;
        /**
         * Specifies the hint the DatePicker displays when its value is `null`.
         * ([more information and exaples]({% slug placeholders_datepicker %})).
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-datepicker placeholder="Enter birth date..."></kendo-datepicker>
         * `
         * })
         * export class AppComponent { }
         * ```
         */
        this.placeholder = null;
        /**
         * Sets or gets the `tabindex` property of the DatePicker.
         */
        this.tabindex = 0;
        /**
         * Sets the title of the input element of the DatePicker.
         */
        this.title = "";
        /**
         * Determines whether the built-in min or max validators are enforced when validating a form.
         */
        this.rangeValidation = true;
        /**
         * Determines whether the built-in validator for disabled
         * date ranges is enforced when validating a form
         * ([see example]({% slug disabled_dates_datepicker %}#toc-validation)).
         */
        this.disabledDatesValidation = true;
        /**
         * Determines whether to display a week number column in the `month` view of the Calendar
         * ([see example]({% slug calendar_type_datepicker %}#toc-week-number-column)).
         */
        this.weekNumber = false;
        /**
         * Fires each time the user selects a new value
         * ([more information and example]({% slug overview_datepicker %}#toc-events)).
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user focuses the input element
         * ([more information and example]({% slug overview_datepicker %}#toc-events)).
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-datepicker (focus)="handleFocus()"></kendo-datepicker>
         * `
         * })
         * export class AppComponent {
         *   public handleFocus(): void {
         *      console.log("Component is focused");
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the input element gets blurred
         * ([more information and example]({% slug overview_datepicker %}#toc-events)).
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-datepicker (blur)="handleBlur()"></kendo-datepicker>
         * `
         * })
         * export class AppComponent {
         *   public handleBlur(): void {
         *      console.log("Component is blurred");
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel the event, the popup will remain closed
         * ([more information and example]({% slug overview_datepicker %}#toc-events)).
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel the event, the popup will remain open
         * ([more information and example]({% slug overview_datepicker %}#toc-events)).
         */
        this.close = new EventEmitter();
        /**
         * @hidden
         */
        this.wrapperClasses = true;
        this.popupUID = guid();
        this._popupSettings = { animate: true };
        this._show = false;
        this._value = null;
        this._active = false;
        this.onControlChange = noop;
        this.onControlTouched = noop;
        this.onValidatorChange = noop;
        this.minValidateFn = noop;
        this.maxValidateFn = noop;
        this.disabledDatesValidateFn = noop;
        this.incompleteValidator = noop;
        this.resolvedPromise = Promise.resolve(null);
        this.domEvents = [];
        this._size = 'medium';
        this._rounded = 'medium';
        this._fillMode = 'solid';
        validatePackage(packageMetadata);
        this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));
        this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
        this.pickerSubscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleSameSelection.bind(this)));
        this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
    }
    /**
     * @hidden
     */
    set cellTemplateRef(template) {
        this.cellTemplate = template;
    }
    /**
     * @hidden
     */
    set monthCellTemplateRef(template) {
        this.monthCellTemplate = template;
    }
    /**
     * @hidden
     */
    set yearCellTemplateRef(template) {
        this.yearCellTemplate = template;
    }
    /**
     * @hidden
     */
    set decadeCellTemplateRef(template) {
        this.decadeCellTemplate = template;
    }
    /**
     * @hidden
     */
    set centuryCellTemplateRef(template) {
        this.centuryCellTemplate = template;
    }
    /**
     * @hidden
     */
    set weekNumberTemplateRef(template) {
        this.weekNumberTemplate = template;
    }
    /**
     * @hidden
     */
    set headerTitleTemplateRef(template) {
        this.headerTitleTemplate = template;
    }
    /**
     * @hidden
     */
    set navigationItemTemplateRef(template) {
        this.navigationItemTemplate = template;
    }
    /**
     * Configures the popup options of the DatePicker.
     *
     * The available options are:
     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
     * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.
     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({}, { animate: true }, settings);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * Specifies the value of the DatePicker component.
     *
     * > The `value` has to be a valid
     * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.
     */
    set value(value) {
        this.verifyValue(value);
        this._value = cloneDate(value);
    }
    get value() {
        return this._value;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Sets the dates of the DatePicker that will be disabled
     * ([see example]({% slug disabled_dates_datepicker %})).
     */
    set disabledDates(value) {
        this._disabledDates = value;
        this.disabledDatesService.initialize(value);
    }
    get disabledDates() {
        return this._disabledDates;
    }
    /**
     * Sets the size of the component.
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (Default)
     * * `'large'`
     * * `null`
     *
     */
    set size(size) {
        this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));
        this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass('input', this.size));
        if (size) {
            this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', size));
            this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('input', size));
        }
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * Sets the border radius of the component.
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (Default)
     * * `'large'`
     * * `'full'`
     * * `null`
     *
     */
    set rounded(rounded) {
        this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
        if (rounded) {
            this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(rounded));
        }
        this._rounded = rounded;
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * Sets the fillMode of the component.
     *
     * The possible values are:
     * * `'solid'` (Default)
     * * `'flat'`
     * * `'outline'`
     * * `null`
     *
     */
    set fillMode(fillMode) {
        this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));
        this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));
        this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
        if (fillMode) {
            this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', fillMode));
            this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${fillMode}-base`);
            this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', fillMode));
        }
        this._fillMode = fillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * @hidden
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get inputRole() {
        return this.readOnlyInput ? 'listbox' : 'spinbutton';
    }
    get isActive() {
        return this._active;
    }
    set isActive(value) {
        this._active = value;
        if (!this.wrapper) {
            return;
        }
        const element = this.wrapper.nativeElement;
        if (value) {
            this.renderer.addClass(element, 'k-focus');
        }
        else {
            this.renderer.removeClass(element, 'k-focus');
        }
    }
    get show() {
        return this._show;
    }
    set show(show) {
        if (show && (this.disabled || this.readonly)) {
            return;
        }
        const skipZone = !show && (!this._show || !hasObservers(this.close));
        if (!skipZone) {
            this.zone.run(() => {
                this.togglePopup(show);
            });
        }
        else {
            this.togglePopup(show);
        }
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return !this.value && this.input.isEmpty();
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.localizationChangeSubscription = this.localization
            .changes
            .subscribe(() => this.cdr.markForCheck());
        this.control = this.injector.get(NgControl, null);
        if (this.wrapper) {
            this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');
            this.zone.runOutsideAngular(() => {
                this.bindEvents();
            });
        }
    }
    ngAfterViewInit() {
        this.setComponentClasses();
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        this.verifySettings();
        if (changes.min || changes.max || changes.rangeValidation || changes.disabledDatesValidation || changes.disabledDates || changes.incompleteDateValidation) {
            this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;
            this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;
            this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop;
            this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop;
            this.onValidatorChange();
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.isActive = false;
        this.show = false;
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
        if (this.windowBlurSubscription) {
            this.windowBlurSubscription.unsubscribe();
        }
        this.domEvents.forEach(unbindCallback => unbindCallback());
        this.pickerSubscriptions.unsubscribe();
    }
    /**
     * Returns the current open state of the popup.
     */
    get isOpen() {
        return this.show;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.verifyValue(value);
        this.value = cloneDate(value);
        this.cdr.markForCheck();
        if (!value && this.input) {
            this.input.placeholder = this.placeholder;
            this.input.writeValue(value);
        }
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onControlChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onControlTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    validate(control) {
        return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.input && this.input.isDateIncomplete);
    }
    /**
     * @hidden
     */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /**
     * Focuses the DatePicker component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="datepicker.focus()">Focus date picker</button>
     *  <kendo-datepicker #datepicker></kendo-datepicker>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    focus() {
        this.input.focus();
    }
    /**
     * Blurs the DatePicker component.
     */
    blur() {
        (this.calendar || this.input)['blur'](); //tslint:disable-line:no-string-literal
    }
    /**
     * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,
     * the `open` and `close` events do not fire.
     *
     * @param show - The state of the popup.
     */
    toggle(show) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.resolvedPromise.then(() => {
            this._toggle((show === undefined) ? !this.show : show);
        });
    }
    /**
     * @hidden
     */
    handleIconClick(event) {
        if (this.disabled || this.readonly) {
            return;
        }
        event.preventDefault();
        this.focusInput();
        //XXX: explicitly call the handleFocus handler here
        //due to async IE focus event
        this.handleFocus();
        this.show = !this.show;
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    handleMousedown(args) {
        args.preventDefault();
    }
    /**
     * @hidden
     */
    handleChange(value) {
        this.cdr.markForCheck();
        this.focusInput();
        this.value = value;
        this.show = false;
        this.onControlChange(cloneDate(value));
        this.valueChange.emit(cloneDate(value));
    }
    /**
     * @hidden
     */
    handleInputChange(value) {
        this.handleChange(this.input.formatSections.time ? value : this.mergeTime(value));
    }
    /**
     * @hidden
     */
    get popupClasses() {
        return [
            'k-calendar-container',
            'k-group',
            'k-reset'
        ].concat(this.popupSettings.popupClass || []);
    }
    /**
     * @hidden
     */
    get appendTo() {
        const { appendTo } = this.popupSettings;
        if (!appendTo || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    get input() {
        return this.pickerService.input;
    }
    get calendar() {
        return this.pickerService.calendar;
    }
    /**
     * @hidden
     */
    mergeTime(value) {
        return this.value && value ? setTime(value, this.value) : value;
    }
    /**
     * @hidden
     */
    handleKeydown(e) {
        const { altKey, shiftKey, keyCode, target } = e;
        if (keyCode === Keys.Escape) {
            this.show = false;
        }
        if (altKey) {
            if (keyCode === Keys.ArrowDown && !this.show) {
                this.show = true;
            }
            if (keyCode === Keys.ArrowUp) {
                this.show = false;
            }
        }
        if (keyCode === Keys.Enter && target.classList.contains('k-calendar')) {
            e.preventDefault(); // Don't submit form on date selection in popup
        }
        if (keyCode === Keys.Tab && this.show && this.calendar.isActive && isTabExitingCalendar(this.calendarType, target, shiftKey)) {
            this.input.focus();
            this.show = false;
        }
    }
    togglePopup(show) {
        const event = new PreventableEvent();
        if (!this._show && show) {
            this.open.emit(event);
        }
        else if (this._show && !show) {
            this.close.emit(event);
        }
        if (event.isDefaultPrevented()) {
            return;
        }
        this._toggle(show);
        this.toggleFocus();
    }
    _toggle(show) {
        if (show === this._show) {
            return;
        }
        this._show = show;
        if (show) {
            const direction = this.localization.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchor: this.wrapper,
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                animate: this.popupSettings.animate,
                appendTo: this.appendTo,
                content: this.popupTemplate,
                popupAlign: { vertical: 'top', horizontal: direction },
                popupClass: this.popupClasses,
                positionMode: 'absolute'
            });
            this.popupRef.popupElement.setAttribute('id', this.popupUID);
            this.subscription = this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);
        }
        else {
            this.popupRef.close();
            this.popupRef = null;
            this.subscription.unsubscribe();
        }
    }
    focusInput() {
        if (this.touchEnabled) {
            return;
        }
        this.input.focus();
    }
    toggleFocus() {
        if (!this.isActive) {
            return;
        }
        if (this.show) {
            if (!this.calendar) {
                this.cdr.detectChanges();
            }
            if (this.calendar) {
                this.calendar.focus();
            }
        }
        else if (!this.touchEnabled) {
            this.input.focus();
        }
        else if (!this.input.isActive) {
            this.handleBlur();
        }
    }
    verifySettings() {
        if (!isDevMode()) {
            return;
        }
        if (!isValidRange(this.min, this.max)) {
            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$3} and ${MAX_DOC_LINK$3}.`);
        }
    }
    verifyValue(value) {
        if (!isDevMode()) {
            return;
        }
        if (value && !(value instanceof Date)) {
            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$3} for possible resolution.`);
        }
    }
    bindEvents() {
        const element = this.wrapper.nativeElement;
        this.domEvents.push(this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));
        if (isWindowAvailable()) {
            this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this));
        }
    }
    handleFocus() {
        if (this.isActive) {
            return;
        }
        this.isActive = true;
        if (hasObservers(this.onFocus)) {
            this.zone.run(() => {
                this.onFocus.emit();
            });
        }
    }
    handleWindowBlur() {
        if (!this.isOpen) {
            return;
        }
        this.show = false;
    }
    handleBlur(args) {
        const currentTarget = args && currentFocusTarget(args);
        if (currentTarget && (this.input.containsElement(currentTarget) ||
            (this.calendar && this.calendar.containsElement(currentTarget)))) {
            return;
        }
        if (hasObservers(this.onBlur) || (this.show && hasObservers(this.close)) || requiresZoneOnBlur(this.control)) {
            this.zone.run(() => {
                this.blurComponent();
                this.cdr.markForCheck();
            });
        }
        else {
            this.blurComponent();
        }
    }
    blurComponent() {
        this.isActive = false; // order is important ¯\_(ツ)_/¯
        this.show = false;
        this.cdr.detectChanges();
        this.onControlTouched();
        this.onBlur.emit();
    }
    handleSameSelection() {
        if (this.show) {
            this.focusInput();
            this.show = false;
        }
    }
    handleDateCompletenessChange() {
        this.cdr.markForCheck();
        this.zone.run(() => this.onValidatorChange());
    }
    setComponentClasses() {
        if (this.size) {
            this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));
            this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('button', this.size));
        }
        if (this.rounded) {
            this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
        }
        if (this.fillMode) {
            this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));
            this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));
            this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
        }
    }
};
DatePickerComponent.ɵfac = function DatePickerComponent_Factory(t) { return new (t || DatePickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(PickerService), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService), ɵngcc0.ɵɵdirectiveInject(TOUCH_ENABLED, 8)); };
DatePickerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DatePickerComponent, selectors: [["kendo-datepicker"]], contentQueries: function DatePickerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NavigationItemTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);
    } }, viewQuery: function DatePickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c27, 7, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c28, 7);
        ɵngcc0.ɵɵviewQuery(_c29, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
    } }, hostVars: 6, hostBindings: function DatePickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-datepicker", ctx.wrapperClasses)("k-input", ctx.wrapperClasses)("k-disabled", ctx.disabledClass);
    } }, inputs: { focusableId: "focusableId", activeView: "activeView", bottomView: "bottomView", topView: "topView", calendarType: "calendarType", animateCalendarNavigation: "animateCalendarNavigation", disabled: "disabled", readonly: "readonly", readOnlyInput: "readOnlyInput", navigation: "navigation", min: "min", max: "max", incompleteDateValidation: "incompleteDateValidation", focusedDate: "focusedDate", format: "format", twoDigitYearMax: "twoDigitYearMax", placeholder: "placeholder", tabindex: "tabindex", title: "title", rangeValidation: "rangeValidation", disabledDatesValidation: "disabledDatesValidation", weekNumber: "weekNumber", cellTemplateRef: ["cellTemplate", "cellTemplateRef"], monthCellTemplateRef: ["monthCellTemplate", "monthCellTemplateRef"], yearCellTemplateRef: ["yearCellTemplate", "yearCellTemplateRef"], decadeCellTemplateRef: ["decadeCellTemplate", "decadeCellTemplateRef"], centuryCellTemplateRef: ["centuryCellTemplate", "centuryCellTemplateRef"], weekNumberTemplateRef: ["weekNumberTemplate", "weekNumberTemplateRef"], headerTitleTemplateRef: ["headerTitleTemplate", "headerTitleTemplateRef"], navigationItemTemplateRef: ["navigationItemTemplate", "navigationItemTemplateRef"], popupSettings: "popupSettings", value: "value", tabIndex: "tabIndex", disabledDates: "disabledDates", size: "size", rounded: "rounded", fillMode: "fillMode", formatPlaceholder: "formatPlaceholder" }, outputs: { valueChange: "valueChange", onFocus: "focus", onBlur: "blur", open: "open", close: "close" }, exportAs: ["kendo-datepicker"], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DatePickerComponent_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => DatePickerComponent_1), multi: true },
            { provide: KendoInput, useExisting: forwardRef(() => DatePickerComponent_1) },
            LocalizationService,
            PickerService,
            DisabledDatesService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.datepicker'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 10, vars: 28, consts: function () { let i18n_30; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the today button in the calendar header
         * @meaning kendo.datepicker.today
         */
        const MSG_EXTERNAL_5799873230514803381$$DIST_FESM2015_INDEX_JS_31 = goog.getMsg("Today");
        i18n_30 = MSG_EXTERNAL_5799873230514803381$$DIST_FESM2015_INDEX_JS_31;
    }
    else {
        i18n_30 = $localize `:kendo.datepicker.today|The label for the today button in the calendar header␟c8af34428eb25c8f689f0c19a9300394b07b5be3␟5799873230514803381:Today`;
    } let i18n_32; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the toggle button in the datepicker component
         * @meaning kendo.datepicker.toggle
         */
        const MSG_EXTERNAL_4817467473728423164$$DIST_FESM2015_INDEX_JS_33 = goog.getMsg("Toggle calendar");
        i18n_32 = MSG_EXTERNAL_4817467473728423164$$DIST_FESM2015_INDEX_JS_33;
    }
    else {
        i18n_32 = $localize `:kendo.datepicker.toggle|The title of the toggle button in the datepicker component␟f6c28c2d80dbe993c4b33f4dc4010364f41cc2ae␟4817467473728423164:Toggle calendar`;
    } let i18n_34; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the previous button in the Classic calendar
         * @meaning kendo.datepicker.prevButtonTitle
         */
        const MSG_EXTERNAL_1741914107549506055$$DIST_FESM2015_INDEX_JS_35 = goog.getMsg("Navigate to previous view");
        i18n_34 = MSG_EXTERNAL_1741914107549506055$$DIST_FESM2015_INDEX_JS_35;
    }
    else {
        i18n_34 = $localize `:kendo.datepicker.prevButtonTitle|The title of the previous button in the Classic calendar␟b24bedd31916ff8439cd7e3c46cbdabea3409dd1␟1741914107549506055:Navigate to previous view`;
    } let i18n_36; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the next button in the Classic calendar
         * @meaning kendo.datepicker.nextButtonTitle
         */
        const MSG_EXTERNAL_3363484587807059211$$DIST_FESM2015_INDEX_JS_37 = goog.getMsg("Navigate to next view");
        i18n_36 = MSG_EXTERNAL_3363484587807059211$$DIST_FESM2015_INDEX_JS_37;
    }
    else {
        i18n_36 = $localize `:kendo.datepicker.nextButtonTitle|The title of the next button in the Classic calendar␟2f0e2a91beb7149035e42bd0d6663e8903dc3852␟3363484587807059211:Navigate to next view`;
    } return [["kendoDatePickerLocalizedMessages", "", "today", i18n_30, "toggle", i18n_32, "prevButtonTitle", i18n_34, "nextButtonTitle", i18n_36], [3, "role", "focusableId", "hasPopup", "isPopupOpen", "disabled", "readonly", "ariaReadOnly", "tabindex", "title", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "min", "max", "incompleteDateValidation", "fillMode", "rounded", "size", "value", "valueChange"], ["input", ""], ["type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "tabindex", "kendoEventsOutsideAngular", "scope"], ["toggleButton", ""], [1, "k-button-icon", "k-icon", "k-i-calendar"], ["container", ""], ["popupTemplate", ""], [3, "type", "min", "max", "navigation", "animateNavigation", "activeView", "bottomView", "topView", "weekNumber", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "navigationItemTemplate", "focusedDate", "value", "kendoEventsOutsideAngular", "scope", "disabledDates", "valueChange"], ["calendar", ""], [3, "today", "prevButtonTitle", "nextButtonTitle"]]; }, template: function DatePickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementStart(1, "kendo-dateinput", 1, 2);
        ɵngcc0.ɵɵlistener("valueChange", function DatePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) { return ctx.handleInputChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "button", 3, 4);
        ɵngcc0.ɵɵelement(5, "span", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainer(6, null, 6);
        ɵngcc0.ɵɵtemplate(8, DatePickerComponent_ng_template_8_Template, 4, 27, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("role", ctx.inputRole)("focusableId", ctx.focusableId)("hasPopup", true)("isPopupOpen", ctx.show)("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.readOnlyInput)("ariaReadOnly", ctx.readonly)("tabindex", ctx.tabindex)("title", ctx.title)("format", ctx.format)("twoDigitYearMax", ctx.twoDigitYearMax)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("min", ctx.min)("max", ctx.max)("incompleteDateValidation", ctx.incompleteDateValidation)("fillMode", null)("rounded", null)("size", null)("value", ctx.value);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("tabindex", -1)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(25, _c39, ctx.handleIconClick, ctx.handleMousedown))("scope", ctx);
        ɵngcc0.ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"));
    } }, directives: function () { return [DatePickerLocalizedMessagesDirective, DateInputComponent, ɵngcc4.EventsOutsideAngularDirective, CalendarComponent, CalendarCustomMessagesComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    ViewChild('container', { read: ViewContainerRef, static: true }),
    __metadata("design:type", ViewContainerRef)
], DatePickerComponent.prototype, "container", void 0);
__decorate([
    ViewChild('popupTemplate', { static: true }),
    __metadata("design:type", TemplateRef)
], DatePickerComponent.prototype, "popupTemplate", void 0);
__decorate([
    ViewChild('toggleButton', { static: true }),
    __metadata("design:type", ElementRef)
], DatePickerComponent.prototype, "toggleButton", void 0);
__decorate([
    ContentChild(CellTemplateDirective, { static: false }),
    __metadata("design:type", CellTemplateDirective)
], DatePickerComponent.prototype, "cellTemplate", void 0);
__decorate([
    Input('cellTemplate'),
    __metadata("design:type", CellTemplateDirective),
    __metadata("design:paramtypes", [CellTemplateDirective])
], DatePickerComponent.prototype, "cellTemplateRef", null);
__decorate([
    ContentChild(MonthCellTemplateDirective, { static: false }),
    __metadata("design:type", MonthCellTemplateDirective)
], DatePickerComponent.prototype, "monthCellTemplate", void 0);
__decorate([
    Input('monthCellTemplate'),
    __metadata("design:type", MonthCellTemplateDirective),
    __metadata("design:paramtypes", [MonthCellTemplateDirective])
], DatePickerComponent.prototype, "monthCellTemplateRef", null);
__decorate([
    ContentChild(YearCellTemplateDirective, { static: false }),
    __metadata("design:type", YearCellTemplateDirective)
], DatePickerComponent.prototype, "yearCellTemplate", void 0);
__decorate([
    Input('yearCellTemplate'),
    __metadata("design:type", YearCellTemplateDirective),
    __metadata("design:paramtypes", [YearCellTemplateDirective])
], DatePickerComponent.prototype, "yearCellTemplateRef", null);
__decorate([
    ContentChild(DecadeCellTemplateDirective, { static: false }),
    __metadata("design:type", DecadeCellTemplateDirective)
], DatePickerComponent.prototype, "decadeCellTemplate", void 0);
__decorate([
    Input('decadeCellTemplate'),
    __metadata("design:type", DecadeCellTemplateDirective),
    __metadata("design:paramtypes", [DecadeCellTemplateDirective])
], DatePickerComponent.prototype, "decadeCellTemplateRef", null);
__decorate([
    ContentChild(CenturyCellTemplateDirective, { static: false }),
    __metadata("design:type", CenturyCellTemplateDirective)
], DatePickerComponent.prototype, "centuryCellTemplate", void 0);
__decorate([
    Input('centuryCellTemplate'),
    __metadata("design:type", CenturyCellTemplateDirective),
    __metadata("design:paramtypes", [CenturyCellTemplateDirective])
], DatePickerComponent.prototype, "centuryCellTemplateRef", null);
__decorate([
    ContentChild(WeekNumberCellTemplateDirective, { static: false }),
    __metadata("design:type", WeekNumberCellTemplateDirective)
], DatePickerComponent.prototype, "weekNumberTemplate", void 0);
__decorate([
    Input('weekNumberTemplate'),
    __metadata("design:type", WeekNumberCellTemplateDirective),
    __metadata("design:paramtypes", [WeekNumberCellTemplateDirective])
], DatePickerComponent.prototype, "weekNumberTemplateRef", null);
__decorate([
    ContentChild(HeaderTitleTemplateDirective, { static: false }),
    __metadata("design:type", HeaderTitleTemplateDirective)
], DatePickerComponent.prototype, "headerTitleTemplate", void 0);
__decorate([
    Input('headerTitleTemplate'),
    __metadata("design:type", HeaderTitleTemplateDirective),
    __metadata("design:paramtypes", [HeaderTitleTemplateDirective])
], DatePickerComponent.prototype, "headerTitleTemplateRef", null);
__decorate([
    ContentChild(NavigationItemTemplateDirective, { static: false }),
    __metadata("design:type", NavigationItemTemplateDirective)
], DatePickerComponent.prototype, "navigationItemTemplate", void 0);
__decorate([
    Input('navigationItemTemplate'),
    __metadata("design:type", NavigationItemTemplateDirective),
    __metadata("design:paramtypes", [NavigationItemTemplateDirective])
], DatePickerComponent.prototype, "navigationItemTemplateRef", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerComponent.prototype, "bottomView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerComponent.prototype, "topView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerComponent.prototype, "calendarType", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerComponent.prototype, "animateCalendarNavigation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerComponent.prototype, "readOnlyInput", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DatePickerComponent.prototype, "popupSettings", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerComponent.prototype, "navigation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], DatePickerComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], DatePickerComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerComponent.prototype, "incompleteDateValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], DatePickerComponent.prototype, "focusedDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], DatePickerComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DatePickerComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DatePickerComponent.prototype, "twoDigitYearMax", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DatePickerComponent.prototype, "formatPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DatePickerComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], DatePickerComponent.prototype, "tabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DatePickerComponent.prototype, "disabledDates", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerComponent.prototype, "rangeValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerComponent.prototype, "disabledDatesValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerComponent.prototype, "weekNumber", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DatePickerComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DatePickerComponent.prototype, "rounded", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DatePickerComponent.prototype, "fillMode", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DatePickerComponent.prototype, "valueChange", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], DatePickerComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], DatePickerComponent.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DatePickerComponent.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DatePickerComponent.prototype, "close", void 0);
__decorate([
    HostBinding('class.k-datepicker'),
    HostBinding('class.k-input'),
    __metadata("design:type", Boolean)
], DatePickerComponent.prototype, "wrapperClasses", void 0);
__decorate([
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DatePickerComponent.prototype, "disabledClass", null);
DatePickerComponent = DatePickerComponent_1 = __decorate([ __param(9, Optional()), __param(9, Inject(TOUCH_ENABLED)),
    __metadata("design:paramtypes", [NgZone,
        LocalizationService,
        ChangeDetectorRef,
        PopupService,
        ElementRef,
        Renderer2,
        Injector,
        PickerService,
        DisabledDatesService, Boolean])
], DatePickerComponent);

/**
 * @hidden
 */
const TIME_PART = {
    dayperiod: 'dayperiod',
    hour: 'hour',
    millisecond: 'millisecond',
    minute: 'minute',
    second: 'second'
};

/**
 * @hidden
 */
const timeRangeValidator = (min, max) => {
    return (control) => {
        if (!min || !max || !control.value) {
            return null;
        }
        const err = {
            timeRangeError: {
                maxValue: max,
                minValue: min,
                value: control.value
            }
        };
        return isInTimeRange(control.value, min, max) ? null : err;
    };
};

var TimePickerComponent_1;
const VALUE_DOC_LINK$4 = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/timepicker/#toc-integration-with-json';
const INTL_DATE_FORMAT = 'https://github.com/telerik/kendo-intl/blob/master/docs/date-formatting/index.md';
const formatRegExp = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.millisecond}|${TIME_PART.dayperiod}|literal`);
/**
 * Represents the [Kendo UI TimePicker component for Angular]({% slug overview_timepicker %}#toc-basic-usage).
 */
let TimePickerComponent = TimePickerComponent_1 = class TimePickerComponent {
    constructor(zone, localization, cdr, popupService, wrapper, renderer, injector, pickerService, intl, touchEnabled$$1) {
        this.zone = zone;
        this.localization = localization;
        this.cdr = cdr;
        this.popupService = popupService;
        this.wrapper = wrapper;
        this.renderer = renderer;
        this.injector = injector;
        this.pickerService = pickerService;
        this.intl = intl;
        this.touchEnabled = touchEnabled$$1;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Sets or gets the `disabled` property of the TimePicker and
         * determines whether the component is active
         * ([see example]({% slug disabled_timepicker %})).
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the TimePicker
         * ([see example]({% slug readonly_timepicker %}#toc-read-only-timepicker)).
         */
        this.readonly = false;
        /**
         * Sets the read-only state of the TimePicker input field
         * ([see example]({% slug readonly_timepicker %}#toc-read-only-input)).
         *
         * > Note that if you set the [`readonly`]({% slug api_dateinputs_timepickercomponent %}#toc-readonly) property value to `true`,
         * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
         */
        this.readOnlyInput = false;
        /**
         * Specifies the time format that is used to display the input value
         * ([see example]({% slug formats_timepicker %})).
         */
        this.format = 't';
        /**
         * Specifies the hint the TimePicker displays when its value is `null`.
         * For more information, refer to the article on
         * [placeholders]({% slug placeholders_timepicker %}).
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-timepicker placeholder="Enter start..."></kendo-timepicker>
         * `
         * })
         * export class AppComponent { }
         * ```
         */
        this.placeholder = null;
        /**
         * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
         */
        this.incompleteDateValidation = false;
        /**
         * Determines whether to display the **Cancel** button in the popup.
         */
        this.cancelButton = true;
        /**
         * Determines whether to display the **Now** button in the popup.
         *
         * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.
         */
        this.nowButton = true;
        /**
         * Sets or gets the `tabindex` property of the TimePicker.
         */
        this.tabindex = 0;
        /**
         * Sets the title of the input element of the TimePicker.
         */
        this.title = "";
        /**
         * Determines whether the built-in min or max validators are enforced when a form is being validated.
         */
        this.rangeValidation = true;
        /**
         * Fires each time the user selects a new value.
         * For more information, refer to the section on
         * [events]({% slug overview_timepicker %}#toc-events).
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user focuses the input element.
         * For more information, refer to the section on
         * [events]({% slug overview_timepicker %}#toc-events).
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-timepicker (focus)="handleFocus()"></kendo-timepicker>
         * `
         * })
         * export class AppComponent {
         *   public handleFocus(): void {
         *      console.log("Component is focused");
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the input element gets blurred.
         * For more information, refer to the section on
         * [events]({% slug overview_timepicker %}#toc-events).
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-timepicker (blur)="handleBlur()"></kendo-timepicker>
         * `
         * })
         * export class AppComponent {
         *   public handleBlur(): void {
         *      console.log("Component is blurred");
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel the event, the popup will remain closed.
         * For more information, refer to the section on
         * [events]({% slug overview_timepicker %}#toc-events).
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel the event, the popup will remain open.
         * For more information, refer to the section on
         * [events]({% slug overview_timepicker %}#toc-events).
         */
        this.close = new EventEmitter();
        /**
         * @hidden
         */
        this.wrapperClasses = true;
        this.popupUID = guid();
        this.onControlChange = noop;
        this.onControlTouched = noop;
        this.onValidatorChange = noop;
        this.resolvedPromise = Promise.resolve(null);
        this.timeRangeValidateFn = noop;
        this.incompleteValidator = noop;
        this._min = cloneDate(MIN_TIME);
        this._max = cloneDate(MAX_TIME);
        this._popupSettings = { animate: true };
        this._show = false;
        this._steps = {};
        this._value = null;
        this._active = false;
        this.domEvents = [];
        this._size = 'medium';
        this._rounded = 'medium';
        this._fillMode = 'solid';
        validatePackage(packageMetadata);
        this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));
        this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
        this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
    }
    /**
     * Specifies the smallest valid time value
     * ([see example]({% slug timeranges_timepicker %})).
     */
    set min(min) {
        this._min = cloneDate(min || MIN_TIME);
    }
    get min() {
        return this._min;
    }
    /**
     * Specifies the biggest valid time value
     * ([see example]({% slug timeranges_timepicker %})).
     */
    set max(max) {
        this._max = cloneDate(max || MAX_TIME);
    }
    get max() {
        return this._max;
    }
    /**
     * Configures the incremental steps of the TimePicker.
     * For more information, refer to the article on
     * [incremental steps]({% slug incrementalsteps_timepicker %}).
     *
     * > If the incremental step is greater than `1`, the **Now** button will be hidden.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-timepicker format="HH:mm:ss" [steps]="steps"></kendo-timepicker>
     * `
     * })
     * class AppComponent {
     *   public steps = { hour: 2, minute: 15, second: 15, millisecond: 10 };
     * }
     * ```
     *
     */
    set steps(steps) {
        this._steps = steps || {};
    }
    get steps() {
        return this._steps;
    }
    /**
     * Configures the popup of the TimePicker.
     *
     * The available options are:
     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
     * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.
     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({}, { animate: true }, settings);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Specifies the value of the TimePicker component.
     */
    set value(value) {
        this.verifyValue(value);
        this._value = cloneDate(value);
    }
    get value() {
        return this._value;
    }
    /**
     * Sets the size of the component.
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (Default)
     * * `'large'`
     * * `null`
     *
     */
    set size(size) {
        this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));
        this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass('input', this.size));
        if (size) {
            this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', size));
            this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('input', size));
        }
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * Sets the border radius of the component.
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (Default)
     * * `'large'`
     * * `'full'`
     * * `null`
     *
     */
    set rounded(rounded) {
        this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
        if (rounded) {
            this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(rounded));
        }
        this._rounded = rounded;
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * Sets the fillMode of the component.
     *
     * The possible values are:
     * * `'solid'` (Default)
     * * `'flat'`
     * * `'outline'`
     * * `null`
     *
     */
    set fillMode(fillMode) {
        this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));
        this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));
        this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
        if (fillMode) {
            this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', fillMode));
            this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', fillMode));
            this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${fillMode}-base`);
        }
        this._fillMode = fillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * @hidden
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get inputRole() {
        return this.readOnlyInput ? 'listbox' : 'spinbutton';
    }
    get isActive() {
        return this._active;
    }
    set isActive(value) {
        this._active = value;
        if (!this.wrapper) {
            return;
        }
        const element = this.wrapper.nativeElement;
        if (value) {
            this.renderer.addClass(element, 'k-focus');
        }
        else {
            this.renderer.removeClass(element, 'k-focus');
        }
    }
    get show() {
        return this._show;
    }
    set show(show) {
        if (show && (this.disabled || this.readonly)) {
            return;
        }
        const skipZone = !show && (!this._show || !hasObservers(this.close));
        if (!skipZone) {
            this.zone.run(() => {
                this.togglePopup(show);
            });
        }
        else {
            this.togglePopup(show);
        }
    }
    get input() {
        return this.pickerService.input;
    }
    get timeSelector() {
        return this.pickerService.timeSelector;
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty
     */
    isEmpty() {
        return !this.value && this.input.isEmpty();
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(() => this.cdr.markForCheck());
        this.control = this.injector.get(NgControl, null);
        if (this.wrapper) {
            this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');
            this.zone.runOutsideAngular(() => {
                this.bindEvents();
            });
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.setComponentClasses();
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (changes.min || changes.max || changes.rangeValidation || changes.incompleteDateValidation) {
            this.timeRangeValidateFn = this.rangeValidation ? timeRangeValidator(this.min, this.max) : noop;
            this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop;
            this.onValidatorChange();
        }
        if (changes.format) {
            this.verifyFormat();
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.isActive = false;
        this.show = false;
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
        if (this.windowBlurSubscription) {
            this.windowBlurSubscription.unsubscribe();
        }
        this.domEvents.forEach(unbindCallback => unbindCallback());
        this.pickerSubscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    handleKeydown(event) {
        const { altKey, keyCode } = event;
        if (keyCode === Keys.Escape) {
            this.show = false;
            return;
        }
        if (altKey) {
            if (keyCode === Keys.ArrowUp) {
                this.show = false;
            }
            if (keyCode === Keys.ArrowDown && !this.show) {
                this.show = true;
            }
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.verifyValue(value);
        this.value = cloneDate(value);
        this.cdr.markForCheck();
        if (!value && this.input) {
            this.input.placeholder = this.placeholder;
            this.input.writeValue(value);
        }
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onControlChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onControlTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    validate(control) {
        return this.timeRangeValidateFn(control) || this.incompleteValidator(control, this.input && this.input.isDateIncomplete);
    }
    /**
     * @hidden
     */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /**
     * Focuses the TimePicker component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="timepicker.focus()">Focus time picker</button>
     *  <kendo-timepicker #timepicker></kendo-timepicker>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    focus() {
        this.input.focus();
    }
    /**
     * Blurs the TimePicker component.
     */
    blur() {
        (this.timeSelector || this.input)['blur'](); //tslint:disable-line:no-string-literal
    }
    /**
     * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,
     * the `open` and `close` events do not fire.
     *
     * @param show - The state of the popup.
     */
    toggle(show) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.resolvedPromise.then(() => {
            this._toggle((show === undefined) ? !this.show : show);
        });
    }
    /**
     * Returns the current open state of the popup.
     */
    get isOpen() {
        return this.show;
    }
    /**
     * @hidden
     */
    get appendTo() {
        const { appendTo } = this.popupSettings;
        if (!appendTo || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    /**
     * @hidden
     */
    handleChange(value) {
        if (isEqual(this.value, value)) {
            this.focusInput();
            this.show = false;
            return;
        }
        this.value = cloneDate(value);
        this.zone.run(() => {
            this.focusInput();
            this.show = false;
            this.onControlChange(cloneDate(value));
            this.valueChange.emit(cloneDate(value));
        });
    }
    /**
     * @hidden
     */
    handleReject() {
        this.show = false;
    }
    /**
     * @hidden
     */
    handleInputChange(value) {
        const val = this.input.formatSections.date ? value : this.mergeTime(value);
        this.handleChange(val);
    }
    /**
     * @hidden
     */
    handleMousedown(args) {
        args.preventDefault();
    }
    /**
     * @hidden
     */
    handleIconClick(event) {
        if (this.disabled || this.readonly) {
            return;
        }
        event.preventDefault();
        this.focusInput();
        //XXX: explicit call handleFocus handler here
        //due to async IE focus event
        this.handleFocus();
        this.show = !this.show;
    }
    /**
     * @hidden
     */
    get popupClasses() {
        return [
            'k-group',
            'k-reset'
        ].concat(this.popupSettings.popupClass || []);
    }
    /**
     * @hidden
     */
    normalizeTime(date) {
        return setTime(MIDNIGHT_DATE, date);
    }
    /**
     * @hidden
     */
    mergeTime(value) {
        return this.value && value ? setTime(this.value, value) : value;
    }
    togglePopup(show) {
        const event = new PreventableEvent();
        if (!this._show && show) {
            this.open.emit(event);
        }
        else if (this._show && !show) {
            this.close.emit(event);
        }
        if (event.isDefaultPrevented()) {
            return;
        }
        this._toggle(show);
        this.toggleFocus();
    }
    _toggle(show) {
        if (show === this.isOpen) {
            return;
        }
        this._show = show;
        this.cdr.markForCheck();
        if (show) {
            const direction = this.localization.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchor: this.wrapper,
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                animate: this.popupSettings.animate,
                appendTo: this.appendTo,
                content: this.popupTemplate,
                popupAlign: { vertical: 'top', horizontal: direction },
                popupClass: this.popupClasses,
                positionMode: 'absolute'
            });
            this.popupRef.popupElement.setAttribute('id', this.popupUID);
            this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);
        }
        else {
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    focusInput() {
        if (this.touchEnabled) {
            return;
        }
        this.input.focus();
    }
    toggleFocus() {
        if (!this.isActive) {
            return;
        }
        if (this.show) {
            if (!this.timeSelector) {
                this.cdr.detectChanges();
            }
            if (this.isActive) {
                this.timeSelector.focus();
            }
        }
        else if (!this.touchEnabled) {
            this.input.focus();
        }
        else if (!this.input.isActive) {
            this.handleBlur();
        }
    }
    verifyValue(value) {
        if (!isDevMode()) {
            return;
        }
        if (value && !(value instanceof Date)) {
            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
        }
    }
    verifyFormat() {
        if (!isDevMode()) {
            return;
        }
        const formatContainsDateParts = this.intl.splitDateFormat(this.format).some(part => !formatRegExp.test(part.type));
        if (formatContainsDateParts) {
            throw new Error(`Provided format is not supported. Supported specifiers are T|t|H|h|m|s|S|a. See ${INTL_DATE_FORMAT}`);
        }
    }
    bindEvents() {
        const element = this.wrapper.nativeElement;
        this.domEvents.push(this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));
        if (isWindowAvailable()) {
            this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this));
        }
    }
    handleWindowBlur() {
        if (!this.isOpen) {
            return;
        }
        this.show = false;
    }
    handleFocus() {
        if (this.isActive) {
            return;
        }
        this.isActive = true;
        if (hasObservers(this.onFocus)) {
            this.zone.run(() => {
                this.onFocus.emit();
            });
        }
    }
    handleBlur(args) {
        const currentTarget = args && currentFocusTarget(args);
        if (currentTarget && (this.input.containsElement(currentTarget) ||
            (this.timeSelector && this.timeSelector.containsElement(currentTarget)))) {
            return;
        }
        if (hasObservers(this.onBlur) || (this.show && hasObservers(this.close)) || requiresZoneOnBlur(this.control)) {
            this.zone.run(() => {
                this.blurComponent();
                this.cdr.markForCheck();
            });
        }
        else {
            this.blurComponent();
        }
    }
    blurComponent() {
        this.isActive = false; // order is important ¯\_(ツ)_/¯
        this.show = false;
        this.onControlTouched();
        this.onBlur.emit();
    }
    handleDateCompletenessChange() {
        this.cdr.markForCheck();
        this.zone.run(() => this.onValidatorChange());
    }
    setComponentClasses() {
        if (this.size) {
            this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));
            this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('button', this.size));
        }
        if (this.rounded) {
            this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
        }
        if (this.fillMode) {
            this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));
            this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));
            this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
        }
    }
};
TimePickerComponent.ɵfac = function TimePickerComponent_Factory(t) { return new (t || TimePickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(PickerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(TOUCH_ENABLED, 8)); };
TimePickerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TimePickerComponent, selectors: [["kendo-timepicker"]], viewQuery: function TimePickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c27, 5, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c28, 5);
        ɵngcc0.ɵɵviewQuery(_c29, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
    } }, hostVars: 6, hostBindings: function TimePickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-timepicker", ctx.wrapperClasses)("k-input", ctx.wrapperClasses)("k-disabled", ctx.disabledClass);
    } }, inputs: { focusableId: "focusableId", disabled: "disabled", readonly: "readonly", readOnlyInput: "readOnlyInput", format: "format", placeholder: "placeholder", incompleteDateValidation: "incompleteDateValidation", cancelButton: "cancelButton", nowButton: "nowButton", tabindex: "tabindex", title: "title", rangeValidation: "rangeValidation", min: "min", max: "max", steps: "steps", popupSettings: "popupSettings", tabIndex: "tabIndex", value: "value", size: "size", rounded: "rounded", fillMode: "fillMode", formatPlaceholder: "formatPlaceholder" }, outputs: { valueChange: "valueChange", onFocus: "focus", onBlur: "blur", open: "open", close: "close" }, exportAs: ["kendo-timepicker"], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => TimePickerComponent_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => TimePickerComponent_1), multi: true },
            { provide: KendoInput, useExisting: forwardRef(() => TimePickerComponent_1) },
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.timepicker'
            },
            PickerService
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 10, vars: 27, consts: function () { let i18n_40; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Accept button text in the timepicker component
         * @meaning kendo.timepicker.accept
         */
        const MSG_EXTERNAL_7519663530416240229$$DIST_FESM2015_INDEX_JS_41 = goog.getMsg("Set");
        i18n_40 = MSG_EXTERNAL_7519663530416240229$$DIST_FESM2015_INDEX_JS_41;
    }
    else {
        i18n_40 = $localize `:kendo.timepicker.accept|The Accept button text in the timepicker component␟4c3bf42192220c7611c09ece1c5de14855139dd0␟7519663530416240229:Set`;
    } let i18n_42; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Accept button in the timepicker component
         * @meaning kendo.timepicker.acceptLabel
         */
        const MSG_EXTERNAL_4355879331538595758$$DIST_FESM2015_INDEX_JS_43 = goog.getMsg("Set time");
        i18n_42 = MSG_EXTERNAL_4355879331538595758$$DIST_FESM2015_INDEX_JS_43;
    }
    else {
        i18n_42 = $localize `:kendo.timepicker.acceptLabel|The label for the Accept button in the timepicker component␟93c2a9c3aa49f56e452c0aecbaabe3bb33fa4222␟4355879331538595758:Set time`;
    } let i18n_44; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Cancel button text in the timepicker component
         * @meaning kendo.timepicker.cancel
         */
        const MSG_EXTERNAL_1086687567255473060$$DIST_FESM2015_INDEX_JS_45 = goog.getMsg("Cancel");
        i18n_44 = MSG_EXTERNAL_1086687567255473060$$DIST_FESM2015_INDEX_JS_45;
    }
    else {
        i18n_44 = $localize `:kendo.timepicker.cancel|The Cancel button text in the timepicker component␟132eefca16bd41d489b4647724b91e93793603aa␟1086687567255473060:Cancel`;
    } let i18n_46; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Cancel button in the timepicker component
         * @meaning kendo.timepicker.cancelLabel
         */
        const MSG_EXTERNAL_83621966901491941$$DIST_FESM2015_INDEX_JS_47 = goog.getMsg("Cancel changes");
        i18n_46 = MSG_EXTERNAL_83621966901491941$$DIST_FESM2015_INDEX_JS_47;
    }
    else {
        i18n_46 = $localize `:kendo.timepicker.cancelLabel|The label for the Cancel button in the timepicker component␟2cf6f4ca4470810944b4016c9b6f87943d3390ab␟83621966901491941:Cancel changes`;
    } let i18n_48; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Now button text in the timepicker component
         * @meaning kendo.timepicker.now
         */
        const MSG_EXTERNAL_5912507758515138116$$DIST_FESM2015_INDEX_JS_49 = goog.getMsg("Now");
        i18n_48 = MSG_EXTERNAL_5912507758515138116$$DIST_FESM2015_INDEX_JS_49;
    }
    else {
        i18n_48 = $localize `:kendo.timepicker.now|The Now button text in the timepicker component␟bbc99bb74ae75a503bd813aad0c7253d3553e923␟5912507758515138116:Now`;
    } let i18n_50; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Now button in the timepicker component
         * @meaning kendo.timepicker.nowLabel
         */
        const MSG_EXTERNAL_371982627910576599$$DIST_FESM2015_INDEX_JS_51 = goog.getMsg("Select now");
        i18n_50 = MSG_EXTERNAL_371982627910576599$$DIST_FESM2015_INDEX_JS_51;
    }
    else {
        i18n_50 = $localize `:kendo.timepicker.nowLabel|The label for the Now button in the timepicker component␟df1a696f318275aa934e27850920889d494c2740␟371982627910576599:Select now`;
    } let i18n_52; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the toggle button in the timepicker component
         * @meaning kendo.timepicker.toggle
         */
        const MSG_EXTERNAL_6938407659294495526$$DIST_FESM2015_INDEX_JS_53 = goog.getMsg("Toggle time list");
        i18n_52 = MSG_EXTERNAL_6938407659294495526$$DIST_FESM2015_INDEX_JS_53;
    }
    else {
        i18n_52 = $localize `:kendo.timepicker.toggle|The label for the toggle button in the timepicker component␟f2c196786ed2d3ecb2369750c36aac9a4053fb30␟6938407659294495526:Toggle time list`;
    } return [["kendoTimePickerLocalizedMessages", "", "accept", i18n_40, "acceptLabel", i18n_42, "cancel", i18n_44, "cancelLabel", i18n_46, "now", i18n_48, "nowLabel", i18n_50, "toggle", i18n_52], [3, "focusableId", "hasPopup", "isPopupOpen", "disabled", "readonly", "role", "ariaReadOnly", "format", "formatPlaceholder", "placeholder", "min", "max", "incompleteDateValidation", "fillMode", "rounded", "size", "steps", "tabindex", "title", "value", "valueChange"], ["input", ""], ["type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "kendoEventsOutsideAngular", "scope"], ["toggleButton", ""], [1, "k-button-icon", "k-icon", "k-i-clock"], ["popupTemplate", ""], ["container", ""], [3, "cancelButton", "nowButton", "format", "min", "max", "steps", "value", "kendoEventsOutsideAngular", "scope", "valueChange", "valueReject"], ["timeSelector", ""], [3, "acceptLabel", "accept", "cancelLabel", "cancel", "nowLabel", "now"]]; }, template: function TimePickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementStart(1, "kendo-dateinput", 1, 2);
        ɵngcc0.ɵɵlistener("valueChange", function TimePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) { return ctx.handleInputChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "button", 3, 4);
        ɵngcc0.ɵɵelement(5, "span", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, TimePickerComponent_ng_template_6_Template, 3, 18, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementContainer(8, null, 7);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("focusableId", ctx.focusableId)("hasPopup", true)("isPopupOpen", ctx.show)("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.readOnlyInput)("role", ctx.inputRole)("ariaReadOnly", ctx.readonly)("format", ctx.format)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("min", ctx.normalizeTime(ctx.min))("max", ctx.normalizeTime(ctx.max))("incompleteDateValidation", ctx.incompleteDateValidation)("fillMode", ctx.fillMode)("rounded", ctx.rounded)("size", ctx.size)("steps", ctx.steps)("tabindex", !ctx.show ? ctx.tabindex : -1)("title", ctx.title)("value", ctx.value);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(24, _c39, ctx.handleIconClick, ctx.handleMousedown))("scope", ctx);
        ɵngcc0.ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"));
    } }, directives: function () { return [TimePickerLocalizedMessagesDirective, DateInputComponent, ɵngcc4.EventsOutsideAngularDirective, TimeSelectorComponent, TimeSelectorCustomMessagesComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    ViewChild('container', { read: ViewContainerRef, static: false }),
    __metadata("design:type", ViewContainerRef)
], TimePickerComponent.prototype, "container", void 0);
__decorate([
    ViewChild('popupTemplate', { static: false }),
    __metadata("design:type", TemplateRef)
], TimePickerComponent.prototype, "popupTemplate", void 0);
__decorate([
    ViewChild('toggleButton', { static: true }),
    __metadata("design:type", ElementRef)
], TimePickerComponent.prototype, "toggleButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TimePickerComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimePickerComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimePickerComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimePickerComponent.prototype, "readOnlyInput", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TimePickerComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TimePickerComponent.prototype, "formatPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TimePickerComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], TimePickerComponent.prototype, "min", null);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], TimePickerComponent.prototype, "max", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimePickerComponent.prototype, "incompleteDateValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimePickerComponent.prototype, "cancelButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimePickerComponent.prototype, "nowButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], TimePickerComponent.prototype, "steps", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], TimePickerComponent.prototype, "popupSettings", null);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TimePickerComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], TimePickerComponent.prototype, "tabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], TimePickerComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimePickerComponent.prototype, "rangeValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], TimePickerComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TimePickerComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TimePickerComponent.prototype, "rounded", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TimePickerComponent.prototype, "fillMode", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TimePickerComponent.prototype, "valueChange", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], TimePickerComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], TimePickerComponent.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TimePickerComponent.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TimePickerComponent.prototype, "close", void 0);
__decorate([
    HostBinding('class.k-timepicker'),
    HostBinding('class.k-input'),
    __metadata("design:type", Boolean)
], TimePickerComponent.prototype, "wrapperClasses", void 0);
__decorate([
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TimePickerComponent.prototype, "disabledClass", null);
TimePickerComponent = TimePickerComponent_1 = __decorate([ __param(9, Optional()), __param(9, Inject(TOUCH_ENABLED)),
    __metadata("design:paramtypes", [NgZone,
        LocalizationService,
        ChangeDetectorRef,
        PopupService,
        ElementRef,
        Renderer2,
        Injector,
        PickerService,
        IntlService, Boolean])
], TimePickerComponent);

var DateTimePickerComponent_1;
const timeFormatRegExp = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.dayperiod}|literal`);
const VALUE_DOC_LINK$5 = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/integration-with-json/';
const MIN_MAX_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/date-time-limits/';
const DEFAULT_ACTIVE_TAB = 'date';
const DEFAULT_DATEINPUT_FORMAT = 'g';
const DEFAULT_TIMESELECTOR_FORMAT = 't';
const TWO_DIGIT_YEAR_MAX$2 = 68;
/**
 * Represents the [Kendo UI DateTimePicker component for Angular]({% slug overview_datetimepicker %}).
 */
let DateTimePickerComponent = DateTimePickerComponent_1 = class DateTimePickerComponent {
    constructor(popupService, intl, cdr, pickerService, ngZone, wrapper, touchEnabled$$1, localization, disabledDatesService, renderer) {
        this.popupService = popupService;
        this.intl = intl;
        this.cdr = cdr;
        this.pickerService = pickerService;
        this.ngZone = ngZone;
        this.wrapper = wrapper;
        this.touchEnabled = touchEnabled$$1;
        this.localization = localization;
        this.disabledDatesService = disabledDatesService;
        this.renderer = renderer;
        /**
         * @hidden
         */
        this.hostClasses = true;
        /**
         * The maximum year to assume to be from the current century when typing two-digit year value
         * ([see example]({% slug formats_datetimepicker %}#toc-two-digit-year-format)).
         *
         * The default value is 68, indicating that typing any value less than 69
         * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
         */
        this.twoDigitYearMax = TWO_DIGIT_YEAR_MAX$2;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Sets the title of the input element of the DateTimePicker.
         */
        this.title = '';
        /**
         * Sets or gets the `disabled` property of the DateTimePicker and determines whether the component is active
         * ([see example]({% slug disabled_datetimepicker %})).
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the DateTimePicker
         * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-datetimepicker)).
         */
        this.readonly = false;
        /**
         * Sets the read-only state of the DateTimePicker input field
         * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-input)).
         *
         * > Note that if you set the [`readonly`]({% slug api_dateinputs_datetimepickercomponent %}#toc-readonly) property value to `true`,
         * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
         */
        this.readOnlyInput = false;
        /**
         * Determines whether to display the **Cancel** button in the popup
         * ([see example]({% slug datetimepicker_popup_options %}#toc-toggling-the-cancel-button)).
         */
        this.cancelButton = true;
        /**
         * Configures the incremental steps of the DateInput and the popup component of the TimePicker
         * ([see example]({% slug incrementalsteps_datetimepicker %})).
         */
        this.steps = {};
        /**
         * Specifies the Calendar type.
         *
         * The possible values are:
         * - `infinite` (default)
         * - `classic`
         *
         */
        this.calendarType = 'infinite';
        /**
         * Determines whether to enable animation when navigating to previous/next Calendar view.
         * Applies to the [`classic`]({% slug api_dateinputs_datetimepickercomponent %}#toc-calendartype) Calendar only.
         *
         * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
         *
         * @default false
         */
        this.animateCalendarNavigation = false;
        /**
         * Determines whether to display a week number column in the `month` view of the popup Calendar
         * ([see example]({% slug datetimepicker_calendar_options %}#toc-week-number-column)).
         */
        this.weekNumber = false;
        /**
         * Determines whether the built-in min or max validators are enforced when validating a form
         * ([see example]({% slug dateranges_datetimepicker %}#toc-prevent-invalid-input)).
         */
        this.rangeValidation = true;
        /**
         * Determines whether the built-in validator for disabled
         * date ranges is enforced when validating a form
         * ([see example]({% slug disabled_dates_datetimepicker %}#toc-validation)).
         */
        this.disabledDatesValidation = true;
        /**
         * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
         */
        this.incompleteDateValidation = false;
        /**
         * Fires each time the user selects a new value.
         * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain closed.
         * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain open.
         * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).
         */
        this.close = new EventEmitter();
        /**
         * Fires each time the user focuses the component.
         * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the user blurs the component.
         * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         *
         * Controls whether the Calendar or the TimeSelector will be displayed.
         */
        this.activeTab = DEFAULT_ACTIVE_TAB;
        /**
         * @hidden
         *
         * Specifies the stripped time-related format that is used in the TimeSelector.
         * Updates each time the `format` property value changes.
         */
        this.timeSelectorFormat = DEFAULT_TIMESELECTOR_FORMAT;
        /**
         * @hidden
         */
        this.timeSelectorMin = cloneDate(MIN_TIME);
        /**
         * @hidden
         */
        this.timeSelectorMax = cloneDate(MAX_TIME);
        /**
         * @hidden
         */
        this.calendarValue = null;
        /**
         * @hidden
         */
        this.calendarMin = cloneDate(MIN_DATE);
        /**
         * @hidden
         */
        this.calendarMax = lastMillisecondOfDate(MAX_DATE);
        this._popupSettings = { animate: true };
        this._value = null;
        this._format = DEFAULT_DATEINPUT_FORMAT;
        this._tabindex = 0;
        this._defaultTab = DEFAULT_ACTIVE_TAB;
        this._min = mergeDateAndTime(MIN_DATE, MIN_TIME);
        this._max = mergeDateAndTime(MAX_DATE, MAX_TIME);
        this._isActive = false;
        this.onControlTouched = noop;
        this.onControlChange = noop;
        this.onValidatorChange = noop;
        this.minValidateFn = noop;
        this.maxValidateFn = noop;
        this.disabledDatesValidateFn = noop;
        this.incompleteValidator = noop;
        this.subscriptions = new Subscription();
        this._size = 'medium';
        this._rounded = 'medium';
        this._fillMode = 'solid';
        validatePackage(packageMetadata);
    }
    /**
     * @hidden
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get input() {
        return this.pickerService.input;
    }
    /**
     * @hidden
     */
    get calendar() {
        return this.pickerService.calendar;
    }
    /**
     * @hidden
     */
    get timeSelector() {
        return this.pickerService.timeSelector;
    }
    /**
     * Specifies the value of the DateTimePicker component.
     *
     * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.
     */
    set value(value) {
        this.verifyValue(value);
        this._value = cloneDate(value);
        this.setCalendarValue(value);
        this.cdr.markForCheck();
    }
    get value() {
        return this._value;
    }
    /**
     * Specifies the date format for displaying the input value
     * ([see example]({% slug formats_datetimepicker %}))
     *
     * Format value options:
     * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.
     * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.
     *
     * > If a [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) object is provided, the `displayFormat` value will be used for the popup TimePicker.
     */
    set format(format) {
        this._format = format;
        const displayFormat = this.getDisplayFormat(format);
        this.timeSelectorFormat = this.getTimeSelectorFormat(displayFormat);
    }
    get format() {
        return this._format;
    }
    /**
     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the DateTimePicker.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return this.disabled ? -1 : this._tabindex;
    }
    /**
     * Sets the dates of the DateTimePicker that will be disabled
     * ([see example]({% slug disabled_dates_datetimepicker %})).
     */
    set disabledDates(value) {
        this._disabledDates = value;
        this.disabledDatesService.initialize(value);
    }
    get disabledDates() {
        return this._disabledDates;
    }
    /**
     * Configures the popup settings of the DateTimePicker
     * ([see example]({% slug datetimepicker_popup_options %}#toc-customizing-the-popup)).
     *
     * The available options are:
     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
     * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.
     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({}, { animate: true }, settings);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * Specifies the smallest valid date.
     * The Calendar will not display dates before this value.
     * If the `min` value of the Calendar is selected, the TimePicker will not display
     * time entries before the specified time portion of this value
     * ([see example]({% slug dateranges_datetimepicker %})).
     */
    set min(value) {
        if (!isPresent(value)) {
            return;
        }
        this._min = cloneDate(value);
        this.calendarMin = getDate(value);
    }
    get min() {
        return this._min;
    }
    /**
     * Specifies the biggest valid date.
     * The Calendar will not display dates after this value.
     * If the `max` value of the Calendar is selected, the TimePicker will not display
     * time entries after the specified time portion of this value
     * ([see example]({% slug dateranges_datetimepicker %})).
     */
    set max(value) {
        if (!isPresent(value)) {
            return;
        }
        this._max = cloneDate(value);
        this.calendarMax = lastMillisecondOfDate(value);
    }
    get max() {
        return this._max;
    }
    /**
     * Indicates whether the component is currently open.
     */
    get isOpen() {
        return isPresent(this.popupRef);
    }
    /**
     * Indicates whether the component or its popup content is focused.
     */
    get isActive() {
        return this._isActive;
    }
    set isActive(value) {
        if (value) {
            this.renderer.addClass(this.wrapper.nativeElement, 'k-focus');
        }
        else {
            this.renderer.removeClass(this.wrapper.nativeElement, 'k-focus');
        }
        this._isActive = value;
    }
    /**
     * Sets the active tab on opening the popup
     * ([see example]({% slug datetimepicker_popup_options %}#toc-setting-the-default-tab)).
     */
    set defaultTab(tab) {
        this._defaultTab = tab || DEFAULT_ACTIVE_TAB;
        this.activeTab = this.defaultTab;
    }
    get defaultTab() {
        return this._defaultTab;
    }
    /**
     * Sets the size of the component.
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (Default)
     * * `'large'`
     * * `null`
     *
     */
    set size(size) {
        this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));
        this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass('input', this.size));
        if (size) {
            this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', size));
            this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('input', size));
        }
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * Sets the border radius of the component.
     *
     * The possible values are:
     * * `'small'`
     * * `'medium'` (Default)
     * * `'large'`
     * * `'full'`
     * * `null`
     *
     */
    set rounded(rounded) {
        this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
        if (rounded) {
            this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(rounded));
        }
        this._rounded = rounded;
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * Sets the fillMode of the component.
     *
     * The possible values are:
     * * `'solid'` (Default)
     * * `'flat'`
     * * `'outline'`
     * * `null`
     *
     */
    set fillMode(fillMode) {
        this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));
        this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));
        this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
        if (fillMode) {
            this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', fillMode));
            this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', fillMode));
            this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${fillMode}-base`);
        }
        this._fillMode = fillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * @hidden
     */
    get tabSwitchTransition() {
        /*
         When the popup is opening, disables the set transition in the themes. When `defaultTab` is set to `time`,
         the popup opens with an active **Time** tab and the animation of the initial transition is undesired.
         Setting the inline transition style to `none` overrides the set animation in the themes.
         Setting the inline transition style to `null` does not apply any inline styles or override the themes CSS.
        */
        return this.isOpen ? null : 'none';
    }
    /**
     * @hidden
     *
     * Indicates whether the Calendar will be disabled.
     * The inactive tab component gets disabled and becomes inaccessible on tab click.
     */
    get disableCalendar() {
        return this.activeTab !== 'date' && !this.calendar.isActive;
    }
    /**
     * @hidden
     */
    get inputRole() {
        return this.readOnlyInput ? 'listbox' : 'spinbutton';
    }
    /**
     * @hidden
     *
     * Indicates whether the TimeSelector will be disabled.
     * The inactive tab component gets disabled and becomes inaccessible on tab click.
     */
    get disableTimeSelector() {
        return this.activeTab !== 'time' && !this.timeSelector.isActive;
    }
    get activeTabComponent() {
        if (!this.isOpen) {
            return;
        }
        if (!(isPresent(this.calendar) || isPresent(this.timeSelector))) {
            this.cdr.detectChanges();
        }
        return this.activeTab === 'date' ? this.calendar : this.timeSelector;
    }
    get appendTo() {
        const { appendTo } = this.popupSettings;
        if (!isPresent(appendTo) || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    ngOnInit() {
        this.subscriptions.add(this.pickerService.onFocus
            // detect popup changes to disable the inactive view mark-up when the popup is open
            .pipe(tap(this.detectPopupChanges.bind(this)))
            .subscribe(this.handleFocus.bind(this)));
        this.subscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
        this.subscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleCalendarValueChange.bind(this)));
        this.subscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));
        this.subscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
        if (isWindowAvailable()) {
            this.subscriptions.add(this.ngZone.runOutsideAngular(() => fromEvent(window, 'blur').subscribe(this.handleCancel.bind(this))));
        }
    }
    ngAfterViewInit() {
        this.setComponentClasses();
    }
    ngOnChanges(changes) {
        if (isPresent(changes.min) || isPresent(changes.max)) {
            this.verifyMinMaxRange();
        }
        if (changes.min || changes.max || changes.rangeValidation || changes.disabledDatesValidation || changes.disabledDates || changes.incompleteDateValidation) {
            this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;
            this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;
            this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop;
            this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop;
            this.onValidatorChange();
        }
    }
    ngOnDestroy() {
        if (this.isOpen) {
            this.closePopup();
        }
        this.subscriptions.unsubscribe();
    }
    /**
     * * If the popup is closed, focuses the DateTimePicker input.
     * * If the popup is open, the focus is moved to its content.
     */
    focus() {
        if (this.disabled) {
            return;
        }
        if (this.isOpen) {
            this.activeTabComponent.focus();
        }
        else {
            this.input.focus();
        }
    }
    /**
     * Blurs the DateTimePicker.
     */
    blur() {
        if (this.isOpen && this.activeTabComponent.isActive) {
            this.activeTabComponent.blur();
        }
        else {
            this.input.blur();
        }
    }
    /**
     * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,
     * the `open` and `close` events do not fire.
     * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).
     *
     * @param show - The state of the popup.
     */
    toggle(show) {
        if (this.disabled || this.readonly || show === this.isOpen) {
            return;
        }
        const shouldOpen = isPresent(show) ? show : !this.isOpen;
        if (shouldOpen) {
            this.openPopup();
        }
        else {
            this.closePopup();
            // Changes the tab and the calendar or clock icon to the designated default.
            if (this.activeTab !== this.defaultTab) {
                this.activeTab = this.defaultTab;
                this.cdr.detectChanges();
            }
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onControlChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onControlTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(disabled) {
        this.disabled = disabled;
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    validate(control) {
        return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.input && this.input.isDateIncomplete);
    }
    /**
     * @hidden
     */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /**
     * @hidden
     *
     * Used by the TextBoxContainer to determine if the floating label will render in the input.
     */
    isEmpty() {
        return !isPresent(this.value) && this.input.isEmpty();
    }
    /**
     * @hidden
     */
    handleIconClick(event) {
        if (this.disabled || this.readonly) {
            return;
        }
        // prevents the event default to evade focusing the DateInput input when placed inside a label (FF/IE/Edge)
        event.preventDefault();
        const runInZone = !this.isOpen || hasObservers(this.close);
        this.run(runInZone, () => {
            const shouldOpen = !this.isOpen;
            // handle focus first to maintain correct event order `focus` => `open`
            this.handleFocus();
            this.togglePopup(shouldOpen);
            this.switchFocus();
        });
    }
    /**
     * @hidden
     */
    handleFocus() {
        if (this.isActive) {
            return;
        }
        this.isActive = true;
        if (hasObservers(this.onFocus)) {
            this.ngZone.run(() => this.onFocus.emit());
        }
    }
    /**
     * @hidden
     */
    handleBlur(event) {
        if (!this.isActive || this.focusTargetInComponent(event)) {
            return;
        }
        this.isActive = false;
        const isNgControlUntouched = this.wrapper.nativeElement.classList.contains('ng-untouched');
        const runInZone = isNgControlUntouched || hasObservers(this.onBlur) || (this.isOpen && hasObservers(this.close));
        this.run(runInZone, () => {
            this.onBlur.emit();
            this.onControlTouched();
            this.togglePopup(false);
            this.cdr.markForCheck();
        });
    }
    /**
     * @hidden
     */
    changeActiveTab(tab) {
        if (!this.isOpen || this.activeTab === tab) {
            return;
        }
        // persists the Tcurrent value of the TimeSelector when switching between tabs
        if (!isEqual(this.timeSelector.value, this.timeSelector.current)) {
            this.timeSelector.handleAccept();
        }
        this.activeTab = tab;
        this.cdr.detectChanges();
        this.detectPopupChanges();
    }
    /**
     * @hidden
     */
    handleTabChangeTransitionEnd(dateTimeSelector, event) {
        // handle only the .k-datetime-selector element transition, ignore any child element transitions
        if (event.target !== dateTimeSelector) {
            return;
        }
        this.activeTabComponent.focus();
    }
    /**
     * @hidden
     */
    handleAccept() {
        if (!this.isOpen) {
            return;
        }
        const candidate = mergeDateAndTime(this.calendar.value, this.timeSelector.current);
        const valueChangePresent = !isEqual(this.value, candidate);
        const runInZone = valueChangePresent || hasObservers(this.close);
        this.run(runInZone, () => {
            this.handleValueChange(candidate);
            this.togglePopup(false);
        });
    }
    /**
     * @hidden
     */
    handleCancel() {
        if (!this.isOpen) {
            return;
        }
        const runInZone = hasObservers(this.close);
        this.run(runInZone, () => this.togglePopup(false));
    }
    /**
     * @hidden
     */
    handleInputValueChange(value) {
        this.handleValueChange(value);
        if (this.isOpen) {
            this.togglePopup(false);
        }
    }
    /**
     * @hidden
     */
    handleCalendarValueChange() {
        this.setTimeSelectorMinMax(this.calendar.value);
        this.changeActiveTab('time');
    }
    /**
     * @hidden
     */
    handleKeyDown(event) {
        if (this.disabled || this.readonly) {
            return;
        }
        const { keyCode, altKey } = event;
        switch (keyCode) {
            case altKey && Keys.ArrowUp:
            case Keys.Escape:
                this.handleCancel();
                break;
            case !this.isOpen && altKey && Keys.ArrowDown:
                this.ngZone.run(() => this.togglePopup(true));
                break;
            case altKey && Keys.ArrowRight:
                this.changeActiveTab('time');
                break;
            case altKey && Keys.ArrowLeft:
                this.changeActiveTab('date');
                break;
            case this.isOpen && this.timeSelector.isActive && isPresent(this.calendarValue) && Keys.Enter:
                this.handleAccept();
                break;
            default: return;
        }
        event.preventDefault();
    }
    /**
     * @hidden
     */
    handleTabOut(event) {
        const { keyCode, shiftKey, target } = event;
        // if no focusable next sibling elements exist in the controls sections, the user is tabbing out of the popup
        const focusableSiblingAvailable = isPresent(target.nextElementSibling) && !target.nextElementSibling.disabled;
        if (keyCode === Keys.Tab && !shiftKey && !focusableSiblingAvailable) {
            this.input.focus();
            this.handleCancel();
        }
    }
    /**
     * @hidden
     */
    handleBackTabOut(event) {
        const { keyCode, shiftKey } = event;
        if (keyCode === Keys.Tab && shiftKey) {
            this.input.focus();
        }
    }
    /**
     * @hidden
     */
    popupButtonsClasses(type) {
        const buttonType = type ? type : 'base';
        return `${this.size ? getSizeClass('button', this.size) : ''} ${this.rounded ? getRoundedClass(this.rounded) : ''} ${this.fillMode ? 'k-button-' + this.fillMode + ' ' + 'k-button-' + this.fillMode + '-' + buttonType : ''}`;
    }
    /**
     * @hidden
     *
     * Prevents the diversion of the focus from the currently active element in the component.
     */
    preventMouseDown(event) {
        event.preventDefault();
    }
    verifyValue(value) {
        if (!isDevMode()) {
            return;
        }
        if (isPresent(value) && !(value instanceof Date)) {
            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
        }
    }
    verifyMinMaxRange() {
        if (!isDevMode()) {
            return;
        }
        if (!isValidRange(this.min, this.max)) {
            throw new Error(`The max value should be bigger than the min. See ${MIN_MAX_DOC_LINK}.`);
        }
    }
    /**
     * Extracts the time slots and the literals that are not preceded by date parts
     * and concatenates the resulting parts into a string.
     * If the provided format value does not contain any time parts,
     * returns the designated format of the default popup component of the TimePicker.
     */
    getTimeSelectorFormat(format) {
        const timeSelectorFormat = this.intl
            .splitDateFormat(format)
            .filter(this.timeFormatPartFilter)
            .reduce((format, part) => format += part.pattern, '');
        return timeSelectorFormat || DEFAULT_TIMESELECTOR_FORMAT;
    }
    /**
     * Extracts the `displayFormat` from the provided `string | FormatSettings` value.
     * Fallbacks to the default input value, if a falsy value param is passed.
     */
    getDisplayFormat(format) {
        if (!format) {
            return DEFAULT_DATEINPUT_FORMAT;
        }
        if (typeof format === 'string') {
            return format;
        }
        else {
            return format.displayFormat;
        }
    }
    /**
     * The filter expression that filters out all format parts
     * except for `hour`, `minute`, `second`, `dayperiod`, and specific literals.
     * Literals will be left only if they are not preceded by date parts.
     */
    timeFormatPartFilter(part, index, parts) {
        const previousPart = index >= 1 && parts[index - 1];
        if (previousPart && part.type === 'literal') {
            return timeFormatRegExp.test(previousPart.type);
        }
        return timeFormatRegExp.test(part.type);
    }
    togglePopup(open) {
        if (open === this.isOpen) {
            return;
        }
        const event = new PreventableEvent();
        open ? this.open.emit(event) : this.close.emit(event);
        if (event.isDefaultPrevented()) {
            return;
        }
        this.toggle(open);
        this.switchFocus();
    }
    switchFocus() {
        if (!this.isActive) {
            return;
        }
        if (this.isOpen) {
            this.activeTabComponent.focus();
        }
        else if (!this.touchEnabled) {
            this.input.focus();
        }
        else if (!this.input.isActive) {
            this.handleBlur();
        }
    }
    openPopup() {
        this.setCalendarValue(this.value);
        this.setTimeSelectorMinMax(this.value);
        const direction = this.localization.rtl ? 'right' : 'left';
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            content: this.popupTemplate,
            positionMode: 'absolute',
            animate: this.popupSettings.animate,
            appendTo: this.appendTo,
            popupClass: `k-datetime-container ${this.popupSettings.popupClass || ''}`,
            anchorAlign: { vertical: 'bottom', horizontal: direction },
            popupAlign: { vertical: 'top', horizontal: direction }
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(() => this.handleCancel());
    }
    closePopup() {
        if (!this.isOpen) {
            return;
        }
        this.popupRef.close();
        this.popupRef = null;
    }
    handleValueChange(value) {
        if (isEqual(this.value, value)) {
            return;
        }
        this.value = cloneDate(value);
        this.onControlChange(cloneDate(value));
        this.valueChange.emit(cloneDate(value));
    }
    /**
     * Indicates whether the focus target is part of this component,
     * that is, whether the focus target is inside the component or in the popup.
     */
    focusTargetInComponent(event) {
        if (!isPresent(event)) {
            return false;
        }
        const relatedTarget = event.relatedTarget || document.activeElement;
        const focusInPopup = isPresent(this.popupRef) && this.popupRef.popupElement.contains(relatedTarget);
        const focusInWrapper = this.wrapper.nativeElement.contains(relatedTarget);
        return focusInPopup || focusInWrapper;
    }
    setTimeSelectorMinMax(selectedDate) {
        const minDateSelected = isPresent(selectedDate) && isEqual(getDate(selectedDate), getDate(this.min));
        this.timeSelectorMin = cloneDate(minDateSelected ? this.min : MIN_TIME);
        const maxDateSelected = isPresent(selectedDate) && isEqual(getDate(selectedDate), getDate(this.max));
        this.timeSelectorMax = cloneDate(maxDateSelected ? this.max : MAX_TIME);
    }
    setCalendarValue(value) {
        const isInCalendarRange = isPresent(value) && isInRange(value, this.calendarMin, this.calendarMax);
        this.calendarValue = isInCalendarRange ? getDate(value) : null;
    }
    /**
     * If the popup is available, runs a popup change detection.
     */
    detectPopupChanges() {
        if (!this.isOpen) {
            return;
        }
        this.popupRef.popup.changeDetectorRef.detectChanges();
    }
    /**
     * Depending on the predicate `runInZone` value that is passed,
     * runs the provided function either in the Angular or in the current zone.
     */
    run(runInZone, fn) {
        if (runInZone) {
            this.ngZone.run(() => fn());
        }
        else {
            fn();
        }
    }
    handleDateCompletenessChange() {
        this.cdr.markForCheck();
        this.ngZone.run(() => this.onValidatorChange());
    }
    setComponentClasses() {
        if (this.size) {
            this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));
            this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('button', this.size));
        }
        if (this.rounded) {
            this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
        }
        if (this.fillMode) {
            this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));
            this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));
            this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
        }
    }
};
DateTimePickerComponent.ɵfac = function DateTimePickerComponent_Factory(t) { return new (t || DateTimePickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc5.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(PickerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(TOUCH_ENABLED), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
DateTimePickerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DateTimePickerComponent, selectors: [["kendo-datetimepicker"]], contentQueries: function DateTimePickerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
    } }, viewQuery: function DateTimePickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c29, 7);
        ɵngcc0.ɵɵviewQuery(_c27, 7, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c28, 7, TemplateRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
    } }, hostVars: 6, hostBindings: function DateTimePickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-datetimepicker", ctx.hostClasses)("k-input", ctx.hostClasses)("k-disabled", ctx.disabledClass);
    } }, inputs: { twoDigitYearMax: "twoDigitYearMax", focusableId: "focusableId", title: "title", disabled: "disabled", readonly: "readonly", readOnlyInput: "readOnlyInput", cancelButton: "cancelButton", steps: "steps", calendarType: "calendarType", animateCalendarNavigation: "animateCalendarNavigation", weekNumber: "weekNumber", rangeValidation: "rangeValidation", disabledDatesValidation: "disabledDatesValidation", incompleteDateValidation: "incompleteDateValidation", value: "value", format: "format", tabindex: "tabindex", disabledDates: "disabledDates", popupSettings: "popupSettings", min: "min", max: "max", defaultTab: "defaultTab", size: "size", rounded: "rounded", fillMode: "fillMode", formatPlaceholder: "formatPlaceholder", placeholder: "placeholder", focusedDate: "focusedDate" }, outputs: { valueChange: "valueChange", open: "open", close: "close", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendo-datetimepicker"], features: [ɵngcc0.ɵɵProvidersFeature([
            PickerService,
            LocalizationService,
            DisabledDatesService,
            { provide: L10N_PREFIX, useValue: 'kendo.datetimepicker' },
            { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DateTimePickerComponent_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => DateTimePickerComponent_1), multi: true },
            { provide: KendoInput, useExisting: forwardRef(() => DateTimePickerComponent_1) }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 9, vars: 37, consts: function () { let i18n_55; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Date tab text in the datetimepicker popup header
         * @meaning kendo.datetimepicker.dateTab
         */
        const MSG_EXTERNAL_3360129034450596425$$DIST_FESM2015_INDEX_JS_56 = goog.getMsg("Date");
        i18n_55 = MSG_EXTERNAL_3360129034450596425$$DIST_FESM2015_INDEX_JS_56;
    }
    else {
        i18n_55 = $localize `:kendo.datetimepicker.dateTab|The Date tab text in the datetimepicker popup header␟5bb17f81ae8dbc109499ce3792afffa6b7cef855␟3360129034450596425:Date`;
    } let i18n_57; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Date tab in the datetimepicker popup header
         * @meaning kendo.datetimepicker.dateTabLabel
         */
        const MSG_EXTERNAL_1810540079817643910$$DIST_FESM2015_INDEX_JS_58 = goog.getMsg("Date tab");
        i18n_57 = MSG_EXTERNAL_1810540079817643910$$DIST_FESM2015_INDEX_JS_58;
    }
    else {
        i18n_57 = $localize `:kendo.datetimepicker.dateTabLabel|The label for the Date tab in the datetimepicker popup header␟2a400c9e364a4c6d83ac39b5513c962805db54b2␟1810540079817643910:Date tab`;
    } let i18n_59; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Time tab text in the datetimepicker popup header
         * @meaning kendo.datetimepicker.timeTab
         */
        const MSG_EXTERNAL_3807284594201983607$$DIST_FESM2015_INDEX_JS_60 = goog.getMsg("Time");
        i18n_59 = MSG_EXTERNAL_3807284594201983607$$DIST_FESM2015_INDEX_JS_60;
    }
    else {
        i18n_59 = $localize `:kendo.datetimepicker.timeTab|The Time tab text in the datetimepicker popup header␟e9b2b760a6916040e7520a9a2926d65de175944d␟3807284594201983607:Time`;
    } let i18n_61; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Time tab in the datetimepicker popup header
         * @meaning kendo.datetimepicker.timeTabLabel
         */
        const MSG_EXTERNAL_2577682127494513393$$DIST_FESM2015_INDEX_JS_62 = goog.getMsg("Time tab");
        i18n_61 = MSG_EXTERNAL_2577682127494513393$$DIST_FESM2015_INDEX_JS_62;
    }
    else {
        i18n_61 = $localize `:kendo.datetimepicker.timeTabLabel|The label for the Time tab in the datetimepicker popup header␟13bf7e3a1036140119732c6d5952f7a20c22999e␟2577682127494513393:Time tab`;
    } let i18n_63; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the toggle button in the datetimepicker component
         * @meaning kendo.datetimepicker.toggle
         */
        const MSG_EXTERNAL_3159207801887264026$$DIST_FESM2015_INDEX_JS_64 = goog.getMsg("Toggle popup");
        i18n_63 = MSG_EXTERNAL_3159207801887264026$$DIST_FESM2015_INDEX_JS_64;
    }
    else {
        i18n_63 = $localize `:kendo.datetimepicker.toggle|The title of the toggle button in the datetimepicker component␟60296a83f0d3e3d07aaba87c4f8e91b0aca3c22a␟3159207801887264026:Toggle popup`;
    } let i18n_65; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Accept button text in the datetimepicker component
         * @meaning kendo.datetimepicker.accept
         */
        const MSG_EXTERNAL_3915774704336012538$$DIST_FESM2015_INDEX_JS_66 = goog.getMsg("Set");
        i18n_65 = MSG_EXTERNAL_3915774704336012538$$DIST_FESM2015_INDEX_JS_66;
    }
    else {
        i18n_65 = $localize `:kendo.datetimepicker.accept|The Accept button text in the datetimepicker component␟4359b59db7ded88e106ada877e744c71b188f8f9␟3915774704336012538:Set`;
    } let i18n_67; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Accept button in the datetimepicker component
         * @meaning kendo.datetimepicker.acceptLabel
         */
        const MSG_EXTERNAL_4770689705864890748$$DIST_FESM2015_INDEX_JS_68 = goog.getMsg("Set");
        i18n_67 = MSG_EXTERNAL_4770689705864890748$$DIST_FESM2015_INDEX_JS_68;
    }
    else {
        i18n_67 = $localize `:kendo.datetimepicker.acceptLabel|The label for the Accept button in the datetimepicker component␟cbea4571cca81ad9767a6b29f0287d1f3f6372dc␟4770689705864890748:Set`;
    } let i18n_69; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Cancel button text in the datetimepicker component
         * @meaning kendo.datetimepicker.cancel
         */
        const MSG_EXTERNAL_5100781969600382158$$DIST_FESM2015_INDEX_JS_70 = goog.getMsg("Cancel");
        i18n_69 = MSG_EXTERNAL_5100781969600382158$$DIST_FESM2015_INDEX_JS_70;
    }
    else {
        i18n_69 = $localize `:kendo.datetimepicker.cancel|The Cancel button text in the datetimepicker component␟17ab795d6f7527dd962a309759ca58cb4edd7e52␟5100781969600382158:Cancel`;
    } let i18n_71; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Cancel button in the datetimepicker component
         * @meaning kendo.datetimepicker.cancelLabel
         */
        const MSG_EXTERNAL_3535986227615756275$$DIST_FESM2015_INDEX_JS_72 = goog.getMsg("Cancel");
        i18n_71 = MSG_EXTERNAL_3535986227615756275$$DIST_FESM2015_INDEX_JS_72;
    }
    else {
        i18n_71 = $localize `:kendo.datetimepicker.cancelLabel|The label for the Cancel button in the datetimepicker component␟ba26795ab9f4c21d66b17549ba854a96fcdac1f9␟3535986227615756275:Cancel`;
    } let i18n_73; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Now button text in the timepicker component
         * @meaning kendo.datetimepicker.now
         */
        const MSG_EXTERNAL_5497093725885127701$$DIST_FESM2015_INDEX_JS_74 = goog.getMsg("NOW");
        i18n_73 = MSG_EXTERNAL_5497093725885127701$$DIST_FESM2015_INDEX_JS_74;
    }
    else {
        i18n_73 = $localize `:kendo.datetimepicker.now|The Now button text in the timepicker component␟7172e7e9a1741f6b63439ec89e498c995cb23b0d␟5497093725885127701:NOW`;
    } let i18n_75; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Now button in the timepicker component
         * @meaning kendo.datetimepicker.nowLabel
         */
        const MSG_EXTERNAL_5046379108717037514$$DIST_FESM2015_INDEX_JS_76 = goog.getMsg("Select now");
        i18n_75 = MSG_EXTERNAL_5046379108717037514$$DIST_FESM2015_INDEX_JS_76;
    }
    else {
        i18n_75 = $localize `:kendo.datetimepicker.nowLabel|The label for the Now button in the timepicker component␟52d90641b26b1ce4c011cadf0437ce36c1dac1d5␟5046379108717037514:Select now`;
    } let i18n_77; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the today button in the calendar header
         * @meaning kendo.datetimepicker.today
         */
        const MSG_EXTERNAL_2570147067439993260$$DIST_FESM2015_INDEX_JS_78 = goog.getMsg("Today");
        i18n_77 = MSG_EXTERNAL_2570147067439993260$$DIST_FESM2015_INDEX_JS_78;
    }
    else {
        i18n_77 = $localize `:kendo.datetimepicker.today|The label for the today button in the calendar header␟9ef9db9ac4951523d519b989d223f507878c612d␟2570147067439993260:Today`;
    } let i18n_79; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the previous button in the Classic calendar
         * @meaning kendo.datetimepicker.prevButtonTitle
         */
        const MSG_EXTERNAL_6176055232586065404$$DIST_FESM2015_INDEX_JS_80 = goog.getMsg("Navigate to previous view");
        i18n_79 = MSG_EXTERNAL_6176055232586065404$$DIST_FESM2015_INDEX_JS_80;
    }
    else {
        i18n_79 = $localize `:kendo.datetimepicker.prevButtonTitle|The title of the previous button in the Classic calendar␟447d09c4ecfc2ab2b84d708f4c07fa0fcda85167␟6176055232586065404:Navigate to previous view`;
    } let i18n_81; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The title of the next button in the Classic calendar
         * @meaning kendo.datetimepicker.nextButtonTitle
         */
        const MSG_EXTERNAL_6424339255333594510$$DIST_FESM2015_INDEX_JS_82 = goog.getMsg("Navigate to next view");
        i18n_81 = MSG_EXTERNAL_6424339255333594510$$DIST_FESM2015_INDEX_JS_82;
    }
    else {
        i18n_81 = $localize `:kendo.datetimepicker.nextButtonTitle|The title of the next button in the Classic calendar␟80fd3325bfe94a180fd27391f2245c024472ec58␟6424339255333594510:Navigate to next view`;
    } return [["kendoDateTimePickerLocalizedMessages", "", "dateTab", i18n_55, "dateTabLabel", i18n_57, "timeTab", i18n_59, "timeTabLabel", i18n_61, "toggle", i18n_63, "accept", i18n_65, "acceptLabel", i18n_67, "cancel", i18n_69, "cancelLabel", i18n_71, "now", i18n_73, "nowLabel", i18n_75, "today", i18n_77, "prevButtonTitle", i18n_79, "nextButtonTitle", i18n_81], [3, "value", "format", "twoDigitYearMax", "min", "max", "incompleteDateValidation", "formatPlaceholder", "placeholder", "disabled", "readonly", "role", "ariaReadOnly", "steps", "tabindex", "title", "focusableId", "hasPopup", "isPopupOpen", "kendoEventsOutsideAngular", "scope", "fillMode", "rounded", "size", "valueChange"], ["type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "tabindex", "kendoEventsOutsideAngular", "scope"], ["toggleButton", ""], [1, "k-button-icon", "k-icon", 3, "ngClass"], ["container", ""], ["popupTemplate", ""], [3, "kendoEventsOutsideAngular", "scope"], [1, "k-datetime-buttongroup", 3, "kendoEventsOutsideAngular", "scope"], [1, "k-button-group", "k-button-group-stretched"], ["type", "button", 1, "k-button", "k-group-start", "k-date-tab", 3, "ngClass", "kendoEventsOutsideAngular", "scope"], ["type", "button", 1, "k-button", "k-group-end", "k-time-tab", 3, "ngClass", "kendoEventsOutsideAngular"], [1, "k-datetime-selector", 3, "kendoEventsOutsideAngular"], ["dateTimeSelector", ""], [1, "k-datetime-calendar-wrap"], [3, "value", "type", "min", "max", "focusedDate", "weekNumber", "navigation", "animateNavigation", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "disabled", "disabledDates", "valueChange"], [3, "today", "prevButtonTitle", "nextButtonTitle"], [1, "k-datetime-time-wrap"], [3, "value", "format", "min", "max", "setButton", "cancelButton", "steps", "disabled"], [3, "now", "nowLabel"], [1, "k-datetime-footer", "k-action-buttons", "k-actions", "k-hstack", "k-justify-content-stretch", 3, "kendoEventsOutsideAngular", "scope"], ["type", "button", "class", "k-button k-time-cancel", 3, "ngClass", "kendoEventsOutsideAngular", "scope", 4, "ngIf"], ["type", "button", 1, "k-button", "k-time-accept", 3, "ngClass", "disabled", "kendoEventsOutsideAngular", "scope"], ["type", "button", 1, "k-button", "k-time-cancel", 3, "ngClass", "kendoEventsOutsideAngular", "scope"]]; }, template: function DateTimePickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementStart(1, "kendo-dateinput", 1);
        ɵngcc0.ɵɵlistener("valueChange", function DateTimePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) { return ctx.handleInputValueChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "button", 2, 3);
        ɵngcc0.ɵɵelement(4, "span", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainer(5, null, 5);
        ɵngcc0.ɵɵtemplate(7, DateTimePickerComponent_ng_template_7_Template, 19, 84, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("value", ctx.value)("format", ctx.format)("twoDigitYearMax", ctx.twoDigitYearMax)("min", ctx.min)("max", ctx.max)("incompleteDateValidation", ctx.incompleteDateValidation)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.readOnlyInput)("role", ctx.inputRole)("ariaReadOnly", ctx.readonly)("steps", ctx.steps)("tabindex", ctx.tabindex)("title", ctx.title)("focusableId", ctx.focusableId)("hasPopup", true)("isPopupOpen", ctx.isOpen)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(29, _c38, ctx.handleKeyDown))("scope", ctx)("fillMode", ctx.fillMode)("rounded", ctx.rounded)("size", ctx.size);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("tabindex", -1)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(31, _c88, ctx.preventMouseDown, ctx.handleIconClick))("scope", ctx);
        ɵngcc0.ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(34, _c89, ctx.activeTab === "date", ctx.activeTab === "time"));
    } }, directives: function () { return [LocalizedMessagesDirective, DateInputComponent, ɵngcc4.EventsOutsideAngularDirective, ɵngcc2.NgClass, CalendarComponent, CalendarCustomMessagesComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent, ɵngcc2.NgIf]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    HostBinding('class.k-datetimepicker'),
    HostBinding('class.k-input'),
    __metadata("design:type", Boolean)
], DateTimePickerComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], DateTimePickerComponent.prototype, "disabledClass", null);
__decorate([
    ViewChild('toggleButton', { static: true }),
    __metadata("design:type", ElementRef)
], DateTimePickerComponent.prototype, "toggleButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], DateTimePickerComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DateTimePickerComponent.prototype, "format", null);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DateTimePickerComponent.prototype, "twoDigitYearMax", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], DateTimePickerComponent.prototype, "tabindex", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DateTimePickerComponent.prototype, "disabledDates", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DateTimePickerComponent.prototype, "popupSettings", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateTimePickerComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateTimePickerComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateTimePickerComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateTimePickerComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateTimePickerComponent.prototype, "readOnlyInput", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateTimePickerComponent.prototype, "cancelButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateTimePickerComponent.prototype, "formatPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateTimePickerComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateTimePickerComponent.prototype, "steps", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], DateTimePickerComponent.prototype, "focusedDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateTimePickerComponent.prototype, "calendarType", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateTimePickerComponent.prototype, "animateCalendarNavigation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateTimePickerComponent.prototype, "weekNumber", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], DateTimePickerComponent.prototype, "min", null);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], DateTimePickerComponent.prototype, "max", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateTimePickerComponent.prototype, "rangeValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateTimePickerComponent.prototype, "disabledDatesValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateTimePickerComponent.prototype, "incompleteDateValidation", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DateTimePickerComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DateTimePickerComponent.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DateTimePickerComponent.prototype, "close", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], DateTimePickerComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], DateTimePickerComponent.prototype, "onBlur", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DateTimePickerComponent.prototype, "defaultTab", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DateTimePickerComponent.prototype, "size", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DateTimePickerComponent.prototype, "rounded", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DateTimePickerComponent.prototype, "fillMode", null);
__decorate([
    ContentChild(CellTemplateDirective, { static: false }),
    __metadata("design:type", CellTemplateDirective)
], DateTimePickerComponent.prototype, "cellTemplate", void 0);
__decorate([
    ContentChild(MonthCellTemplateDirective, { static: false }),
    __metadata("design:type", MonthCellTemplateDirective)
], DateTimePickerComponent.prototype, "monthCellTemplate", void 0);
__decorate([
    ContentChild(YearCellTemplateDirective, { static: false }),
    __metadata("design:type", YearCellTemplateDirective)
], DateTimePickerComponent.prototype, "yearCellTemplate", void 0);
__decorate([
    ContentChild(DecadeCellTemplateDirective, { static: false }),
    __metadata("design:type", DecadeCellTemplateDirective)
], DateTimePickerComponent.prototype, "decadeCellTemplate", void 0);
__decorate([
    ContentChild(CenturyCellTemplateDirective, { static: false }),
    __metadata("design:type", CenturyCellTemplateDirective)
], DateTimePickerComponent.prototype, "centuryCellTemplate", void 0);
__decorate([
    ContentChild(WeekNumberCellTemplateDirective, { static: false }),
    __metadata("design:type", WeekNumberCellTemplateDirective)
], DateTimePickerComponent.prototype, "weekNumberTemplate", void 0);
__decorate([
    ContentChild(HeaderTitleTemplateDirective, { static: false }),
    __metadata("design:type", HeaderTitleTemplateDirective)
], DateTimePickerComponent.prototype, "headerTitleTemplate", void 0);
__decorate([
    ViewChild('container', { read: ViewContainerRef, static: true }),
    __metadata("design:type", ViewContainerRef)
], DateTimePickerComponent.prototype, "container", void 0);
__decorate([
    ViewChild('popupTemplate', { read: TemplateRef, static: true }),
    __metadata("design:type", TemplateRef)
], DateTimePickerComponent.prototype, "popupTemplate", void 0);
DateTimePickerComponent = DateTimePickerComponent_1 = __decorate([ __param(6, Inject(TOUCH_ENABLED)),
    __metadata("design:paramtypes", [PopupService,
        IntlService,
        ChangeDetectorRef,
        PickerService,
        NgZone,
        ElementRef, Boolean, LocalizationService,
        DisabledDatesService,
        Renderer2])
], DateTimePickerComponent);

/**
 * A directive which renders the content of the DateRange Popup. To define the cell template, nest an
 * `<ng-template>` tag with the `kendoRangePopupTemplate` directive inside the component tag.
 */
let DateRangePopupTemplateDirective = class DateRangePopupTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
DateRangePopupTemplateDirective.ɵfac = function DateRangePopupTemplateDirective_Factory(t) { return new (t || DateRangePopupTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
DateRangePopupTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DateRangePopupTemplateDirective, selectors: [["", "kendoDateRangePopupTemplate", ""]] });
DateRangePopupTemplateDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], DateRangePopupTemplateDirective);

const isActive = (cmp) => (cmp && cmp.isActive) || false;
const hasActiveContent = (popup) => popup && popup.hasActiveContent();
/**
 * A service that handles the communication between the components that are placed inside the DateRangeComponent.
 * For example, the start and end `DateInput` and `DateRangePopup` components.
 */
let DateRangeService = class DateRangeService {
    /**
     * A service that handles the communication between the components that are placed inside the DateRangeComponent.
     * For example, the start and end `DateInput` and `DateRangePopup` components.
     */
    constructor() {
        /**
         * An Observable instance that notifies when the `activeRangeEnd` state is changed.
         */
        this.activeRangeEnd$ = new BehaviorSubject(null);
        /**
         * An Observable instance that notifies when the `focusedDate` is changed.
         */
        this.focusedDate$ = new BehaviorSubject(null);
        /**
         * An Observable instance that notifies when the end `DateInput` component is changed.
         * For example, when a new end `DateInput` is attached or when the old one is detached.
         */
        this.endInput$ = new BehaviorSubject(null);
        /**
         * An Observable instance that notifies when the start `DateInput` component is changed.
         * For example, when a new start `DateInput` is attached or the old one is detached.
         */
        this.startInput$ = new BehaviorSubject(null);
        /**
         * An Observable instance that notifies when the `DateRangePopup` component is changed.
         */
        this.dateRangePopup$ = new BehaviorSubject(null);
        /**
         * An Observable instance that notifies when the state of the selection range is changed.
         */
        this.range$ = new BehaviorSubject(EMPTY_SELECTIONRANGE);
    }
    /**
     * Gets the current `activeRangeEnd` value.
     */
    get activeRangeEnd() {
        return this.activeRangeEnd$.value;
    }
    /**
     * Gets the current `focusedDate` value.
     */
    get focusedDate() {
        return this.focusedDate$.value;
    }
    /**
     * Gets the `min` range value.
     * The `min` value is extracted from the `start` DateInput value or the `min` value of the Calendar.
     */
    get min() {
        return (this.startInput$.value || {}).min || null;
    }
    /**
     * Gets the `max` range value.
     * The `max` value is extracted from the `end` DateInput value or the `max` value of the Calendar.
     */
    get max() {
        return (this.endInput$.value || {}).max || null;
    }
    /**
     * Gets the current `selectionRange` value.
     */
    get selectionRange() {
        return this.range$.value;
    }
    /**
     * Activates the registered `DateRangePopup` component.
     * The method opens the popup and focuses the calendar.
     */
    activatePopup() {
        const dateRangePopup = this.dateRangePopup$.value;
        if (!dateRangePopup) {
            return;
        }
        dateRangePopup.activate();
    }
    /**
     * Deactivates the registered `DateRangePopup` component.
     * The method closes the popup.
     */
    deactivatePopup() {
        const dateRangePopup = this.dateRangePopup$.value;
        if (!(dateRangePopup && dateRangePopup.show)) {
            return;
        }
        dateRangePopup.show = false;
    }
    /**
     * @hidden
     *
     * Deactivates the registered `DateRangePopup` component and fires the `cancel` event.
     * The method closes the popup.
     */
    cancelPopup() {
        const dateRangePopup = this.dateRangePopup$.value;
        if (!(dateRangePopup && dateRangePopup.show)) {
            return;
        }
        dateRangePopup.cancelPopup();
    }
    /**
     * Completes all observables to mitigate possible memory leaks.
     * Calls the method when a component that uses it is destroyed.
     */
    destroy() {
        this.activeRangeEnd$.complete();
        this.dateRangePopup$.complete();
        this.focusedDate$.complete();
        this.endInput$.complete();
        this.startInput$.complete();
        this.range$.complete();
    }
    /**
     * Returns `true` when an active component that is placed inside the `DateRangeComponent` is detected.
     * For example, the opened popup or the focused DateInput.
     *
     * @returns `true` if an active component is present.
     */
    hasActiveComponent() {
        const popup = this.dateRangePopup$.value;
        const isPopup = isActive(popup);
        const isStart = isActive(this.startInput$.value);
        const isEnd = isActive(this.endInput$.value);
        return isPopup || isStart || isEnd || hasActiveContent(popup) || false;
    }
    /**
     * Registers a new start `DateInput` component. Notifies all `startInput$` listeners.
     */
    registerStartInput(startInput) {
        this.startInput$.next(startInput);
    }
    /**
     * Registers a new end `DateInput` component. Notifies all `endInput$` listeners.
     */
    registerEndInput(endInput) {
        this.endInput$.next(endInput);
    }
    /**
     * Registers a new `DateRangePopup` component. Notifies all `dateRangePopup$` listeners.
     */
    registerPopup(dateRangePopup) {
        this.dateRangePopup$.next(dateRangePopup);
    }
    /**
     * Updates the `activeRangeEnd` value. Notifies all `activeRangeEnd$` listeners.
     */
    setActiveRangeEnd(activeRange) {
        if (!activeRange || this.activeRangeEnd === activeRange) {
            return;
        }
        this.activeRangeEnd$.next(activeRange);
    }
    /**
     * Updates the focused date. Notifies all `focusedDate$` listeners.
     */
    setFocusedDate(value) {
        if (isEqual(this.focusedDate$.value, value)) {
            return;
        }
        this.focusedDate$.next(value);
    }
    /**
     * Updates the selection range. Notifies all `range$` listeners.
     */
    setRange(range = EMPTY_SELECTIONRANGE) {
        this.range$.next(range);
    }
};
DateRangeService.ɵfac = function DateRangeService_Factory(t) { return new (t || DateRangeService)(); };
DateRangeService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DateRangeService, factory: function (t) { return DateRangeService.ɵfac(t); } });

/**
 * Represents the Kendo UI DateRangePopup component for Angular.
 *
 * @example
 * ```ts
 * import { DateInputsModule, DateRangeService } from '@progress/kendo-angular-dateinputs';
 *
 * _@Component({
 * providers: [DateRangeService],
 * selector: 'my-app',
 * template: `
 *  <button #anchor (click)="popup.toggle()">Toggle</button>
 *  <kendo-daterange-popup [anchor]="anchor" #popup></kendo-daterange-popup>
 * `
 * })
 * export class AppComponent {
 * }
 * ```
 */
let DateRangePopupComponent = class DateRangePopupComponent {
    constructor(popupService, dateRangeService, ref, zone, rtl) {
        this.popupService = popupService;
        this.dateRangeService = dateRangeService;
        this.ref = ref;
        this.zone = zone;
        this.rtl = rtl;
        /**
         * Controls the popup animation.
         * By default, the opening and closing animations are enabled.
         * For more information about controlling the popup animations,
         * refer to the article on [animations]({% slug animations_popup %}).
         */
        this.animate = true;
        /**
         * Configures the collision behavior of the popup.
         * For more information, refer to the article on
         * [viewport boundary detection]({% slug viewportboundarydetection_popup %}).
         */
        this.collision = { horizontal: 'fit', vertical: 'flip' };
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel the event, the popup will remain closed.
         * For more information, refer to the section on
         * [events]({% slug overview_datepicker %}#toc-events).
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel the event, the popup will remain open.
         * For more information, refer to the section on
         * [events]({% slug overview_datepicker %}#toc-events).
         */
        this.close = new EventEmitter();
        /**
         * Fires each time the calendar element is blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the calendar element is focused.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the popup is closed either on `ESC` keypress or on leaving the viewport.
         */
        this.cancel = new EventEmitter();
        /**
         * @hidden
         */
        this.popupUID = guid();
        this.calendarSubscriptions = new Subscription();
        this.popupSubscriptions = new Subscription();
        this.resolvedPromise = Promise.resolve();
    }
    /**
     * The active calendar that is visible in the popup.
     *
     * > When the popup is closed, the property returns `null`.
     */
    get calendar() {
        return this._calendar;
    }
    set calendar(calendar) {
        this._calendar = calendar;
        this.subscribeFocusBlur(calendar);
    }
    /**
     * Gets the active state of the component.
     * When the opened calendar is active, returns `true`.
     */
    get isActive() {
        return this.calendar && this.calendar.isActive;
    }
    /**
     * Gets or sets the visibility state of the component.
     */
    set show(show) {
        if (this._show === show) {
            return;
        }
        const event = new PreventableEvent();
        if (show) {
            this.open.emit(event);
        }
        else {
            this.close.emit(event);
        }
        if (event.isDefaultPrevented()) {
            return;
        }
        this._toggle(show);
    }
    get show() {
        return this._show;
    }
    ngOnInit() {
        this.dateRangeService.registerPopup(this);
    }
    ngAfterViewInit() {
        this.calendarSubscriptions.add(this.contentCalendar.changes.subscribe((changes) => this.calendar = changes.first));
        this.calendarSubscriptions.add(this.viewCalendar.changes.subscribe((changes) => this.calendar = changes.first));
        if (isWindowAvailable()) {
            this.zone.runOutsideAngular(() => this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this)));
        }
    }
    ngOnDestroy() {
        this.destroyPopup();
        this.calendarSubscriptions.unsubscribe();
        if (this.activateSubscription) {
            this.activateSubscription.unsubscribe();
        }
        if (this.blurSubscription) {
            this.blurSubscription.unsubscribe();
            this.focusSubscription.unsubscribe();
        }
        if (this.windowBlurSubscription) {
            this.windowBlurSubscription.unsubscribe();
        }
    }
    /**
     *  Opens the popup component and focuses the calendar.
     */
    activate() {
        if (this.show === true) {
            return;
        }
        if (this.activateSubscription) {
            this.activateSubscription.unsubscribe();
        }
        this.show = true;
        this.ref.markForCheck();
        this.zone.runOutsideAngular(() => {
            this.activateSubscription = merge(this.contentCalendar.changes, this.viewCalendar.changes)
                .pipe(filter(changes => changes && changes.first), map(changes => changes.first))
                .subscribe((calendar) => setTimeout(() => calendar.focus()));
        });
    }
    /**
     *  Focuses the calendar (if available).
     */
    focus() {
        if (this.calendar) {
            this.calendar.focus();
        }
    }
    /**
     * Checks if a focused element ids placed inside the popup.
     *
     * @return boolean;
     */
    hasActiveContent() {
        if (!isDocumentAvailable() || !this.popupRef) {
            return false;
        }
        return this.popupRef.popupElement.contains(document.activeElement);
    }
    /**
     * Toggles the visibility of the popup.
     * If you use the `toggle` method to show or hide the popup,
     * the `open` and `close` events do not fire.
     *
     * @param show The state of the popup.
     */
    toggle(show) {
        this.resolvedPromise.then(() => {
            this._toggle((show === undefined) ? !this.show : show);
        });
    }
    /**
     * @hidden
     *
     * Closes the popup and triggers the `cancel` event.
     */
    cancelPopup() {
        this.show = false;
        this.cancel.emit();
    }
    handleWindowBlur() {
        if (!this.show) {
            return;
        }
        if (hasObservers(this.close)) {
            this.zone.run(() => this.show = false);
        }
        else {
            this.show = false;
        }
    }
    handleMouseLeave() {
        this.dateRangeService.setRange(this.dateRangeService.selectionRange);
    }
    handleKeydown(event) {
        const { altKey, keyCode } = event;
        if (keyCode === Keys.Escape || (altKey && keyCode === Keys.ArrowUp)) {
            this.zone.run(() => this.cancelPopup());
        }
    }
    subscribeFocusBlur(calendar) {
        if (this.blurSubscription) {
            this.blurSubscription.unsubscribe();
            this.focusSubscription.unsubscribe();
        }
        if (!calendar) {
            return;
        }
        const nativeElement = calendar.element.nativeElement;
        this.blurSubscription = fromEvent(nativeElement, 'blur').subscribe(() => this.onBlur.emit());
        this.focusSubscription = fromEvent(nativeElement, 'focus').subscribe(() => this.onFocus.emit());
    }
    addPopupSubscriptions(...subscriptions) {
        if (!isPresent(this.popupSubscriptions)) {
            this.popupSubscriptions = new Subscription();
        }
        subscriptions.map(s => this.popupSubscriptions.add(s));
    }
    get _appendTo() {
        const appendTo = this.appendTo;
        if (!appendTo || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    _toggle(show) {
        this._show = show;
        if (this.popupRef) {
            this.destroyPopup();
        }
        if (this._show) {
            const direction = this.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchor: this.anchor,
                anchorAlign: this.anchorAlign || { vertical: 'bottom', horizontal: direction },
                animate: this.animate,
                appendTo: this._appendTo,
                collision: this.collision,
                content: (this.contentTemplate || {}).templateRef || this.defaultTemplate,
                margin: this.margin,
                popupAlign: this.popupAlign || { vertical: 'top', horizontal: direction },
                positionMode: 'absolute'
            });
            const { popupElement, popupAnchorViewportLeave } = this.popupRef;
            popupElement.setAttribute('id', this.popupUID);
            this.addPopupSubscriptions(this.zone.runOutsideAngular(() => fromEvent(popupElement, 'keydown').subscribe(this.handleKeydown.bind(this))), fromEvent(popupElement, 'mouseleave').subscribe(this.handleMouseLeave.bind(this)), popupAnchorViewportLeave.subscribe(() => this.cancelPopup()));
        }
    }
    destroyPopup() {
        if (isPresent(this.popupRef)) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (isPresent(this.popupSubscriptions)) {
            this.popupSubscriptions.unsubscribe();
        }
    }
};
DateRangePopupComponent.ɵfac = function DateRangePopupComponent_Factory(t) { return new (t || DateRangePopupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc5.PopupService), ɵngcc0.ɵɵdirectiveInject(DateRangeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(RTL, 8)); };
DateRangePopupComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DateRangePopupComponent, selectors: [["kendo-daterange-popup"]], contentQueries: function DateRangePopupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DateRangePopupTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MultiViewCalendarComponent, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentCalendar = _t);
    } }, viewQuery: function DateRangePopupComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c27, 5, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c90, 5);
        ɵngcc0.ɵɵviewQuery(MultiViewCalendarComponent, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewCalendar = _t);
    } }, inputs: { animate: "animate", collision: "collision", anchor: "anchor", anchorAlign: "anchorAlign", appendTo: "appendTo", popupAlign: "popupAlign", margin: "margin" }, outputs: { open: "open", close: "close", onBlur: "blur", onFocus: "focus", cancel: "cancel" }, exportAs: ["kendo-daterange-popup"], decls: 4, vars: 0, consts: [["container", ""], ["defaultTemplate", ""], ["kendoDateRangeSelection", ""]], template: function DateRangePopupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, null, 0);
        ɵngcc0.ɵɵtemplate(2, DateRangePopupComponent_ng_template_2_Template, 1, 0, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, directives: function () { return [MultiViewCalendarComponent, DateRangeSelectionDirective]; }, encapsulation: 2 });
__decorate([
    ViewChild('container', { read: ViewContainerRef, static: false }),
    __metadata("design:type", ViewContainerRef)
], DateRangePopupComponent.prototype, "container", void 0);
__decorate([
    ViewChild('defaultTemplate', { static: false }),
    __metadata("design:type", TemplateRef)
], DateRangePopupComponent.prototype, "defaultTemplate", void 0);
__decorate([
    ContentChild(DateRangePopupTemplateDirective, { static: false }),
    __metadata("design:type", DateRangePopupTemplateDirective)
], DateRangePopupComponent.prototype, "contentTemplate", void 0);
__decorate([
    ViewChildren(MultiViewCalendarComponent),
    __metadata("design:type", QueryList)
], DateRangePopupComponent.prototype, "viewCalendar", void 0);
__decorate([
    ContentChildren(MultiViewCalendarComponent),
    __metadata("design:type", QueryList)
], DateRangePopupComponent.prototype, "contentCalendar", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePopupComponent.prototype, "animate", void 0);
__decorate([
    Input(),
    __metadata("design:type", ElementRef)
], DateRangePopupComponent.prototype, "anchor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePopupComponent.prototype, "anchorAlign", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePopupComponent.prototype, "appendTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePopupComponent.prototype, "collision", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePopupComponent.prototype, "popupAlign", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePopupComponent.prototype, "margin", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DateRangePopupComponent.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DateRangePopupComponent.prototype, "close", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], DateRangePopupComponent.prototype, "onBlur", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], DateRangePopupComponent.prototype, "onFocus", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DateRangePopupComponent.prototype, "cancel", void 0);
DateRangePopupComponent = __decorate([ __param(4, Optional()), __param(4, Inject(RTL)),
    __metadata("design:paramtypes", [PopupService,
        DateRangeService,
        ChangeDetectorRef,
        NgZone, Boolean])
], DateRangePopupComponent);

/**
 * Represents the Kendo UI DateRange component for Angular.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-daterange>
 *      <kendo-dateinput kendoDateRangeStartInput [(value)]="dateRange.start"></kendo-dateinput>
 *      <kendo-dateinput kendoDateRangeEndInput [(value)]="dateRange.end"></kendo-dateinput>
 *  </kendo-daterange>
 * `
 * })
 * export class AppComponent {
 *   public dateRange: any = { start: null, end: null };
 * }
 * ```
 */
let DateRangeComponent = class DateRangeComponent {
    constructor() {
        /**
         * @hidden
         */
        this.showDefault = false;
        validatePackage(packageMetadata);
    }
    get hasContentPopup() {
        return this.contentPopup.length > 0;
    }
    ngAfterContentInit() {
        this.showDefault = !this.hasContentPopup;
        this.subscription = this.contentPopup.changes.subscribe(() => {
            this.showDefault = !this.hasContentPopup;
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
};
DateRangeComponent.ɵfac = function DateRangeComponent_Factory(t) { return new (t || DateRangeComponent)(); };
DateRangeComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DateRangeComponent, selectors: [["kendo-daterange"]], contentQueries: function DateRangeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DateRangePopupComponent, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentPopup = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([DateRangeService])], ngContentSelectors: _c11, decls: 2, vars: 1, consts: [[4, "ngIf"]], template: function DateRangeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, DateRangeComponent_kendo_daterange_popup_1_Template, 1, 0, "kendo-daterange-popup", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showDefault);
    } }, directives: [ɵngcc2.NgIf, DateRangePopupComponent], encapsulation: 2 });
__decorate([
    ContentChildren(DateRangePopupComponent),
    __metadata("design:type", QueryList)
], DateRangeComponent.prototype, "contentPopup", void 0);
DateRangeComponent = __decorate([ __metadata("design:paramtypes", [])
], DateRangeComponent);

/**
 * @hidden
 */
class DateRangeInput {
    constructor(activeRangeEnd, dateRangeService, input, element, renderer, zone) {
        this.activeRangeEnd = activeRangeEnd;
        this.dateRangeService = dateRangeService;
        this.input = input;
        this.element = element;
        this.renderer = renderer;
        this.zone = zone;
        this.navigateCalendarOnFocus = false;
        this.popupSubscriptions = new Subscription();
        this.subscriptions = new Subscription();
    }
    get isActiveEnd() {
        return this.dateRangeService.activeRangeEnd === this.activeRangeEnd;
    }
    get popupCalendarActivated() {
        const popup = this.dateRangeService.dateRangePopup$.value;
        return isPresent(popup) && isPresent(popup.calendar);
    }
    init() {
        if (this.input.value) {
            this.dateRangeService.setRange(this.getRange(this.input.value));
        }
        [
            this.input.onBlur.subscribe(() => this.deactivate()),
            this.input.onFocus.pipe(filter(() => !this.popupCalendarActivated)).subscribe(() => this.activate()),
            this.input.valueUpdate.subscribe(value => this.updateRange(value, 'change')),
            this.dateRangeService.activeRangeEnd$.subscribe(() => {
                if (this.navigateCalendarOnFocus) {
                    this.focusActiveDate();
                }
                this.toggleActiveClass(this.isActiveEnd);
            }),
            this.dateRangeService.dateRangePopup$.subscribe(popup => this.initPopup(popup)),
            this.dateRangeService.range$.subscribe(range => this.updateInputValue(range)),
            fromEvent(this.element.nativeElement, 'click').subscribe(() => this.activate()),
            fromEvent(this.element.nativeElement, 'keydown').subscribe((event) => this.togglePopup(event || {}))
        ].map(s => this.subscriptions.add(s));
    }
    destroy() {
        this.subscriptions.unsubscribe();
        this.unsubscribePopup();
    }
    initPopup(popup) {
        if (!popup) {
            this.unsubscribePopup();
            return;
        }
        if (!popup.anchor) {
            popup.anchor = this.element.nativeElement;
        }
        [
            popup.cancel.subscribe(() => this.isActiveEnd && this.input.focus()),
            popup.onFocus.subscribe(() => this.toggleActiveClass(this.isActiveEnd)),
            popup.onBlur.subscribe(() => this.deactivate())
        ].map(s => this.popupSubscriptions.add(s));
    }
    unsubscribePopup() {
        this.popupSubscriptions.unsubscribe();
        this.popupSubscriptions = new Subscription();
    }
    activate() {
        this.dateRangeService.setActiveRangeEnd(this.activeRangeEnd);
        this.dateRangeService.activatePopup();
    }
    deactivate() {
        this.zone.runOutsideAngular(() => {
            setTimeout(() => {
                this.updateRange(this.input.value, 'blur');
                if (this.dateRangeService.hasActiveComponent()) {
                    return;
                }
                this.toggleActiveClass(false);
                this.zone.run(() => this.dateRangeService.deactivatePopup());
            });
        });
    }
    updateRange(value, correctOn) {
        const range = this.getRange(value, correctOn);
        if (range) {
            this.focusActiveDate();
            this.dateRangeService.setRange(range);
        }
    }
    togglePopup({ altKey, keyCode }) {
        if (keyCode === Keys.Escape) {
            this.dateRangeService.cancelPopup();
        }
        else if (altKey && keyCode === Keys.ArrowDown) {
            this.dateRangeService.activatePopup();
        }
    }
    focusActiveDate() {
        if (this.input.value && this.isActiveEnd) {
            this.dateRangeService.setFocusedDate(cloneDate(this.input.value));
        }
    }
    toggleActiveClass(show) {
        const action = show ? 'addClass' : 'removeClass';
        const nativeElement = this.element.nativeElement;
        if (nativeElement && nativeElement.querySelector) {
            this.renderer[action](nativeElement, 'k-focus');
        }
    }
}

/**
 * A directive which manages the end range selection.
 *
 * > You can use the DateRangeEndInputDirective only with a DateInput component.
 */
let DateRangeEndInputDirective = class DateRangeEndInputDirective extends DateRangeInput {
    constructor(rangeService, dateInput, element, renderer, zone) {
        super('end', rangeService, dateInput, element, renderer, zone);
        this.rangeService = rangeService;
        this.dateInput = dateInput;
        /**
         * Specifies the navigation behavior of the calendar when the active end is changed on input focus. When enabled,
         * the calendar navigates to the value of the focused input. Otherwise, the calendar displays the last picked date.
         *
         * By default, the automatic navigation behavior on input focus is disabled.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>
         *  <kendo-daterange>
         *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]="true" [(value)]="start"></kendo-dateinput>
         *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]="true" [(value)]="end"></kendo-dateinput>
         *  </kendo-daterange>
         * `
         * })
         * export class AppComponent {
         *   public start: Date = new Date(2018, 3, 10);
         *   public end: Date = new Date(2018, 10, 20);
         * }
         * ```
         */
        this.navigateCalendarOnFocus = false;
    }
    ngOnInit() {
        this.rangeService.registerEndInput(this.dateInput);
        super.init();
    }
    ngOnDestroy() {
        super.destroy();
    }
    getRange(value, correctOn) {
        const { min, max } = this.dateInput;
        if (!isInRange(value, min, max)) {
            return null;
        }
        const { start } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;
        const shouldClamp = this.autoCorrectOn === correctOn && isPresent(value) && value < start;
        return shouldClamp ? clampRange(value) : { start, end: cloneDate(value) };
    }
    updateInputValue(range$$1) {
        const { end } = range$$1 || EMPTY_SELECTIONRANGE;
        const { min, max } = this.dateInput;
        if (isEqual(this.dateInput.value, end) || !isInRange(end, min, max)) {
            return;
        }
        this.dateInput.writeValue(cloneDate(end));
        this.dateInput.notify();
    }
};
DateRangeEndInputDirective.ɵfac = function DateRangeEndInputDirective_Factory(t) { return new (t || DateRangeEndInputDirective)(ɵngcc0.ɵɵdirectiveInject(DateRangeService), ɵngcc0.ɵɵdirectiveInject(DateInputComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
DateRangeEndInputDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DateRangeEndInputDirective, selectors: [["", "kendoDateRangeEndInput", ""]], inputs: { navigateCalendarOnFocus: "navigateCalendarOnFocus", autoCorrectOn: "autoCorrectOn" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], DateRangeEndInputDirective.prototype, "autoCorrectOn", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateRangeEndInputDirective.prototype, "navigateCalendarOnFocus", void 0);
DateRangeEndInputDirective = __decorate([ __metadata("design:paramtypes", [DateRangeService,
        DateInputComponent,
        ElementRef,
        Renderer2,
        NgZone])
], DateRangeEndInputDirective);

/**
 * A directive which manages the start selection range.
 *
 * > You can use the DateRangeStartInputDirective only with a DateInput component.
 */
let DateRangeStartInputDirective = class DateRangeStartInputDirective extends DateRangeInput {
    constructor(rangeService, dateInput, element, renderer, zone) {
        super('start', rangeService, dateInput, element, renderer, zone);
        this.rangeService = rangeService;
        this.dateInput = dateInput;
        /**
         * Specifies the navigation behavior of the calendar when the active end is changed on input focus.
         * When enabled, the calendar navigates to the value of the focused input. Otherwise, the calendar
         * displays the last picked date.
         *
         * By default, the automatic navigation behavior on input focus is disabled.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>
         *  <kendo-daterange>
         *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]="true" [(value)]="start"></kendo-dateinput>
         *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]="true" [(value)]="end"></kendo-dateinput>
         *  </kendo-daterange>
         * `
         * })
         * export class AppComponent {
         *   public start: Date = new Date(2018, 3, 10);
         *   public end: Date = new Date(2018, 10, 20);
         * }
         * ```
         */
        this.navigateCalendarOnFocus = false;
    }
    ngOnInit() {
        this.rangeService.registerStartInput(this.dateInput);
        super.init();
    }
    ngOnDestroy() {
        super.destroy();
    }
    getRange(value, correctOn) {
        const { min, max } = this.dateInput;
        if (!isInRange(value, min, max)) {
            return null;
        }
        const { end } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;
        const shouldClamp = this.autoCorrectOn === correctOn && end && value > end;
        return shouldClamp ? clampRange(value) : { start: cloneDate(value), end };
    }
    updateInputValue(range$$1) {
        const { start } = range$$1 || EMPTY_SELECTIONRANGE;
        const { min, max } = this.dateInput;
        if (isEqual(this.dateInput.value, start) || !isInRange(start, min, max)) {
            return;
        }
        this.dateInput.writeValue(cloneDate(start));
        this.dateInput.notify();
    }
};
DateRangeStartInputDirective.ɵfac = function DateRangeStartInputDirective_Factory(t) { return new (t || DateRangeStartInputDirective)(ɵngcc0.ɵɵdirectiveInject(DateRangeService), ɵngcc0.ɵɵdirectiveInject(DateInputComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
DateRangeStartInputDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DateRangeStartInputDirective, selectors: [["", "kendoDateRangeStartInput", ""]], inputs: { navigateCalendarOnFocus: "navigateCalendarOnFocus", autoCorrectOn: "autoCorrectOn" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], DateRangeStartInputDirective.prototype, "autoCorrectOn", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DateRangeStartInputDirective.prototype, "navigateCalendarOnFocus", void 0);
DateRangeStartInputDirective = __decorate([ __metadata("design:paramtypes", [DateRangeService,
        DateInputComponent,
        ElementRef,
        Renderer2,
        NgZone])
], DateRangeStartInputDirective);

/**
 * A directive which manages the MultiViewCalendar range selection.
 */
let DateRangeSelectionDirective = class DateRangeSelectionDirective {
    constructor(calendar, cdr, element, renderer, dateRangeService) {
        this.calendar = calendar;
        this.cdr = cdr;
        this.element = element;
        this.dateRangeService = dateRangeService;
        /**
         * Specifies the auto-correction behavior. If the start date is greater than the end date,
         * the directive fixes the date range to a single date either on input change or on blur
         * ([see example]({% slug autocorrect_daterange %}#toc-configuring-the-calendar-selection-directive)).
         *
         * By default, the auto-correction is triggered on change.
         * To disable this behavior, set the `autoCorrectOn` property to `none`.
         */
        this.autoCorrectOn = 'change';
        /**
         * Fires when the active range end is changed. For more information, refer to
         * the section on [events]({% slug overview_multiviewcalendar %}#toc-events).
         */
        this.activeRangeEndChange = new EventEmitter();
        /**
         * Fires when the selection range is changed. For more information, refer to
         * the section on [events]({% slug overview_multiviewcalendar %}#toc-events).
         */
        this.selectionRangeChange = new EventEmitter();
        this.calendarSubscriptions = new Subscription();
        this.dateRangeService = this.dateRangeService || new DateRangeService();
        renderer.setAttribute(element.nativeElement, 'aria-multiselectable', 'true');
    }
    /**
     * Gets or sets the selection range of the calendar. When a new range is set,
     * the connected DateRangeService notifies all related parties.
     */
    get selectionRange() {
        return this.calendar ? this.calendar.selectionRange : null;
    }
    set selectionRange(range$$1) {
        if (!this.isEqualCalendarRange(range$$1)) {
            this.setSelectionRange(range$$1);
        }
        if (!isEqualRange(this.dateRangeService.selectionRange, range$$1)) {
            this.dateRangeService.setRange(range$$1);
        }
        this.updateFocusedDate(range$$1);
    }
    /**
     * Gets or sets the active end of the selection range. This option determines which range end will be updated on
     * user interaction. When a new active end is set, the connected DateRangeService notifies all related parties.
     */
    /**
     * Specifies which end of the selection range will be marked as active. The active end gets modified upon user
     * interaction. When a new active end is set, the wired DateRangeService notifies all related components. For
     * example, the start and end DateInput components.
     *
     * > If the selection range is undefined, the value is ignored.
     */
    get activeRangeEnd() {
        return this.calendar.activeRangeEnd;
    }
    set activeRangeEnd(activeRange) {
        if (this.dateRangeService.activeRangeEnd === activeRange) {
            return;
        }
        this.calendar.activeRangeEnd = activeRange;
        this.dateRangeService.setActiveRangeEnd(activeRange);
    }
    get calendarRange() {
        return this.selectionRange || EMPTY_SELECTIONRANGE;
    }
    ngOnInit() {
        const calendar = this.calendar;
        const dateRangeService = this.dateRangeService;
        calendar.min = either(dateRangeService.min, calendar.min);
        calendar.max = either(dateRangeService.max, calendar.max);
        this.addSubscriptions(calendar.cellEnter.subscribe((value) => this.handleHover(value)), calendar.valueChange.subscribe((value) => this.handleChange(value)), dateRangeService.focusedDate$.subscribe(focusedDate => {
            if (!isEqual(calendar.focusedDate, focusedDate)) {
                calendar.focusedDate = focusedDate;
            }
        }), dateRangeService.activeRangeEnd$.subscribe(rangeEnd => {
            if (calendar.activeRangeEnd === rangeEnd) {
                return;
            }
            calendar.activeRangeEnd = rangeEnd;
            this.activeRangeEndChange.emit(rangeEnd);
            this.cdr.markForCheck();
        }), dateRangeService.range$.subscribe(range$$1 => {
            if (!this.isEqualCalendarRange(range$$1)) {
                this.acceptAndEmit(range$$1);
            }
            this.updateFocusedDate(range$$1);
        }), fromEvent(this.element.nativeElement, 'blur').subscribe(() => this.handleBlur()));
    }
    ngOnDestroy() {
        this.calendarSubscriptions.unsubscribe();
    }
    addSubscriptions(...subscriptions) {
        subscriptions.map(s => this.calendarSubscriptions.add(s));
    }
    isEqualCalendarRange(range$$1) {
        return isEqualRange(this.calendar.selectionRange, range$$1);
    }
    handleBlur() {
        const { start, end } = this.calendarRange;
        const autoCorrect = this.autoCorrectOn === 'blur' && start !== null && end !== null && end < start;
        if (autoCorrect) {
            this.dateRangeService.setRange(clampRange(start));
        }
    }
    handleChange(value) {
        const service = this.dateRangeService;
        const autoCorrect = this.autoCorrectOn === 'change' && this.shouldAutoCorrect(value);
        const activeEnd = this.calendar.activeRangeEnd !== 'end' ? 'end' : (autoCorrect ? 'end' : 'start');
        const range$$1 = autoCorrect ? clampRange(value) : this.updateRange(value);
        if (!isEqualRange(service.selectionRange, range$$1)) {
            this.acceptAndEmit(range$$1);
            service.setActiveRangeEnd(activeEnd);
            service.setRange(range$$1);
        }
    }
    handleHover(value) {
        if (this.hasCompleteRange()) {
            return;
        }
        const { start, end } = this.calendarRange;
        const activeRangeEnd = this.calendar.activeRangeEnd;
        const updateRange = (start && activeRangeEnd === 'end') || (end && activeRangeEnd === 'start');
        if (updateRange) {
            this.setSelectionRange(this.updateRange(value));
        }
    }
    hasCompleteRange() {
        const { start, end } = this.dateRangeService.selectionRange || EMPTY_SELECTIONRANGE;
        return Boolean(start) && Boolean(end);
    }
    shouldAutoCorrect(value) {
        const { end, start } = this.calendarRange;
        if (this.calendar.activeRangeEnd !== 'end') {
            return end !== null && value > end;
        }
        else {
            return start !== null && value < start;
        }
    }
    updateFocusedDate(range$$1) {
        if (!range$$1 || this.dateRangeService.focusedDate) {
            return;
        }
        this.dateRangeService.setFocusedDate(range$$1.start || range$$1.end);
    }
    updateRange(value) {
        const { end, start } = this.calendarRange;
        return this.calendar.activeRangeEnd !== 'end' ? ({ start: value, end }) : ({ start, end: value });
    }
    setSelectionRange(range$$1) {
        this.calendar.selectionRange = range$$1;
        this.calendar.writeValue(null);
    }
    acceptAndEmit(range$$1) {
        this.setSelectionRange(range$$1);
        this.selectionRangeChange.emit(range$$1);
    }
};
DateRangeSelectionDirective.ɵfac = function DateRangeSelectionDirective_Factory(t) { return new (t || DateRangeSelectionDirective)(ɵngcc0.ɵɵdirectiveInject(MultiViewCalendarComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DateRangeService, 8)); };
DateRangeSelectionDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DateRangeSelectionDirective, selectors: [["", "kendoDateRangeSelection", ""]], inputs: { autoCorrectOn: "autoCorrectOn", selectionRange: "selectionRange", activeRangeEnd: "activeRangeEnd" }, outputs: { activeRangeEndChange: "activeRangeEndChange", selectionRangeChange: "selectionRangeChange" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], DateRangeSelectionDirective.prototype, "autoCorrectOn", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DateRangeSelectionDirective.prototype, "selectionRange", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DateRangeSelectionDirective.prototype, "activeRangeEnd", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DateRangeSelectionDirective.prototype, "activeRangeEndChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DateRangeSelectionDirective.prototype, "selectionRangeChange", void 0);
DateRangeSelectionDirective = __decorate([ __param(4, Optional()),
    __metadata("design:paramtypes", [MultiViewCalendarComponent,
        ChangeDetectorRef,
        ElementRef,
        Renderer2,
        DateRangeService])
], DateRangeSelectionDirective);

/* tslint:disable:directive-class-suffix directive-selector */
/**
 * @hidden
 */
class KForOfContext {
    constructor($implicit, kForOf, index, count) {
        this.$implicit = $implicit;
        this.kForOf = kForOf;
        this.index = index;
        this.count = count;
    }
    get first() { return this.index === 0; }
    get last() { return this.index === this.count - 1; }
    get even() { return this.index % 2 === 0; }
    get odd() { return !this.even; }
}
/**
 * @hidden
 */
let KForOf = class KForOf {
    constructor(_viewContainer, _template, _differs) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this._differ = null;
    }
    set kForTemplate(value) {
        if (value) {
            this._template = value;
        }
    }
    ngOnChanges(changes) {
        if ('kForOf' in changes) {
            const value = changes.kForOf.currentValue;
            if (this._differ || !value) {
                return;
            }
            try {
                this._differ = this._differs.find(value).create(this.kForTrackBy);
            }
            catch (e) {
                throw new Error(`Cannot find a differ supporting object '${value}' of type '${getTypeNameForDebugging(value)}'.`);
            }
        }
    }
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.kForOf);
            if (changes) {
                this._applyChanges(changes);
            }
        }
    }
    _applyChanges(changes) {
        if (!isDocumentAvailable()) {
            return;
        }
        const viewContainerLength = this._viewContainer.length;
        const dataLength = this.kForOf.length;
        const tuples = {};
        changes.forEachOperation((record, _, currentIndex) => {
            if (currentIndex !== null) {
                tuples[currentIndex] = record.item;
            }
        });
        for (let i = viewContainerLength; i < dataLength; i++) {
            this._viewContainer.createEmbeddedView(this._template, new KForOfContext(null, this.kForOf, -1, -1), i);
        }
        for (let i = this._viewContainer.length; i > dataLength; i--) {
            this._viewContainer.remove(i - 1);
        }
        for (let i = 0; i < this._viewContainer.length; i++) {
            const view = this._viewContainer.get(i);
            view.context.index = i;
            view.context.count = length;
            view.context.$implicit = tuples[i] || null;
        }
    }
};
KForOf.ɵfac = function KForOf_Factory(t) { return new (t || KForOf)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers)); };
KForOf.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: KForOf, selectors: [["", "kFor", "", "kForOf", ""]], inputs: { kForTemplate: "kForTemplate", kForOf: "kForOf", kForTrackBy: "kForTrackBy" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], KForOf.prototype, "kForOf", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], KForOf.prototype, "kForTrackBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef),
    __metadata("design:paramtypes", [TemplateRef])
], KForOf.prototype, "kForTemplate", null);
KForOf = __decorate([ __metadata("design:paramtypes", [ViewContainerRef,
        TemplateRef,
        IterableDiffers])
], KForOf);
/**
 * @hidden
 */
function getTypeNameForDebugging(type) {
    return type.name || typeof type;
}

/**
 * @hidden
 */
let ViewComponent = class ViewComponent {
    constructor(bus, intl, cdr, element, zone, renderer, disabledDatesService) {
        this.bus = bus;
        this.intl = intl;
        this.cdr = cdr;
        this.element = element;
        this.zone = zone;
        this.renderer = renderer;
        this.disabledDatesService = disabledDatesService;
        this.direction = 'vertical';
        this.isActive = true;
        this.selectedDates = [];
        this.cellClick = new EventEmitter();
        this.weekNumberCellClick = new EventEmitter();
        this.cellEnter = new EventEmitter();
        this.cellLeave = new EventEmitter();
        this.colSpan = 0;
        this.subscriptions = new Subscription();
        this.domEvents = [];
        this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
        this.subscriptions.add(this.disabledDatesService.changes.subscribe(this.disabledDatesChange.bind(this)));
    }
    get weekNumber() {
        return this.showWeekNumbers && this.activeView === CalendarViewEnum.month;
    }
    set weekNumber(showWeekNumbers) {
        this.showWeekNumbers = showWeekNumbers;
    }
    ngOnInit() {
        if (this.element) {
            this.zone.runOutsideAngular(() => {
                this.bindEvents();
            });
        }
    }
    ngOnChanges(changes) {
        this.service = this.bus.service(this.activeView);
        if (!this.service) {
            return;
        }
        this.colSpan = this.service.rowLength({ prependCell: this.weekNumber });
        this.title = this.service.title(this.viewDate);
        this.updateData();
        if (changes.activeView) {
            this.currentCellIndex = null;
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.domEvents.forEach(unsubscribeCallback => unsubscribeCallback());
    }
    isHorizontal() {
        return this.direction === 'horizontal';
    }
    isMonthView() {
        return this.activeView === CalendarViewEnum.month;
    }
    shouldRenderCellContent(cellCtx) {
        return isPresent(cellCtx) && !(!this.isHorizontal() && cellCtx.isOtherMonth);
    }
    firstDate(rowCtx) {
        const ctx = this.firstWeekDateContext(rowCtx);
        return ctx ? ctx.value : null;
    }
    getWeekNumber(date) {
        if (!this.weekNumber) {
            return null;
        }
        return weekInYear(date, this.intl.firstDay());
    }
    getWeekNumberContext(rowCtx) {
        const ctx = this.firstWeekDateContext(rowCtx);
        if (!this.weekNumber || !ctx) {
            return null;
        }
        const weekNumber = weekInYear(ctx.value, this.intl.firstDay()).toString();
        return {
            formattedValue: weekNumber,
            id: null,
            isFocused: false,
            isSelected: false,
            isWeekend: false,
            title: weekNumber,
            value: cloneDate(ctx.value)
        };
    }
    getStyles(context) {
        const { isRangeEnd, isRangeStart } = context;
        const isEndActive = this.activeRangeEnd === 'end' && isRangeEnd;
        const isStartActive = this.activeRangeEnd === 'start' && isRangeStart;
        return stringifyClassObject({
            'k-range-end': !context.isOtherMonth && isRangeEnd,
            'k-range-mid': !context.isOtherMonth && context.isRangeMid,
            'k-range-split-end': !context.isOtherMonth && context.isRangeSplitEnd,
            'k-range-split-start': !context.isOtherMonth && context.isRangeSplitStart,
            'k-range-start': !context.isOtherMonth && isRangeStart,
            'k-state-active': isStartActive || isEndActive,
            'k-state-focused': !context.isOtherMonth && this.isActive && context.isFocused,
            'k-state-selected': !context.isOtherMonth && (context.isSelected || isRangeStart || isRangeEnd),
            'k-today': !context.isOtherMonth && context.isToday,
            'k-weekend': context.isWeekend,
            'k-disabled': context.isDisabled,
            'k-other-month': context.isOtherMonth
        });
    }
    tableCellIndex(rowIndex, cellIndex) {
        return `${rowIndex}:${cellIndex}`;
    }
    handleWeekNumberClick(week) {
        const availableDates = week.map(item => item.value).filter(date => !this.disabledDatesService.isDateDisabled(date));
        this.weekNumberCellClick.emit(availableDates);
    }
    firstWeekDateContext(rowCtx) {
        if (!this.weekNumber) {
            return null;
        }
        let idx = 0;
        let ctx = this.shouldRenderCellContent(rowCtx[idx]) ? rowCtx[idx] : null;
        while (!ctx && idx < rowCtx.length) {
            const cellCtx = rowCtx[++idx];
            ctx = this.shouldRenderCellContent(cellCtx) ? cellCtx : null;
        }
        return ctx;
    }
    updateData() {
        const time = last(this.selectedDates) || getToday();
        const viewDate = setTime(this.viewDate, time);
        this.data = this.service.data({
            cellUID: this.cellUID,
            focusedDate: this.focusedDate,
            isActiveView: !this.bus.canMoveDown(this.activeView),
            max: this.max,
            min: this.min,
            selectedDates: this.selectedDates,
            selectionRange: this.selectionRange,
            viewDate: viewDate,
            isDateDisabled: this.disabledDatesService.isDateDisabled,
            direction: this.direction
        });
    }
    intlChange() {
        this.updateData();
        this.cdr.markForCheck();
    }
    disabledDatesChange() {
        this.updateData();
        this.cdr.markForCheck();
    }
    bindEvents() {
        const element = this.element.nativeElement;
        this.domEvents.push(this.renderer.listen(element, 'mouseover', this.cellMouseoverHandler.bind(this)), this.renderer.listen(element, 'mouseleave', this.mouseLeaveHandler.bind(this)), this.renderer.listen(element, 'click', this.clickHandler.bind(this)));
    }
    clickHandler(args) {
        const cell = this.closestCell(args);
        if (!cell) {
            return;
        }
        const index = cell.getAttribute('data-cell-index');
        const cellContext = this.cellByIndex(index);
        if (!cellContext.isDisabled) {
            const { ctrlKey, metaKey, shiftKey } = args;
            this.cellClick.emit({
                date: cellContext.value,
                modifiers: { ctrlKey, metaKey, shiftKey }
            });
        }
    }
    mouseLeaveHandler() {
        if (this.currentCellIndex) {
            this.emitCellLeave();
        }
    }
    cellMouseoverHandler(args) {
        const cell = this.closestCell(args);
        if (cell) {
            const index = cell.getAttribute('data-cell-index');
            if (this.currentCellIndex && this.currentCellIndex !== index) {
                this.emitCellLeave();
            }
            const value = this.cellByIndex(index).value;
            this.cellEnter.emit(value);
            this.currentCellIndex = index;
        }
        else if (this.currentCellIndex) {
            this.emitCellLeave();
        }
    }
    closestCell(eventArgs) {
        return closestInScope(eventArgs.target, node => node.hasAttribute('data-cell-index'), this.element.nativeElement);
    }
    emitCellLeave() {
        const item = this.cellByIndex(this.currentCellIndex);
        if (item) {
            this.cellLeave.emit(item.value);
        }
        this.currentCellIndex = null;
    }
    cellByIndex(index) {
        const [rowIndex, cellIndex] = index.split(':');
        return this.data[rowIndex][cellIndex];
    }
};
ViewComponent.ɵfac = function ViewComponent_Factory(t) { return new (t || ViewComponent)(ɵngcc0.ɵɵdirectiveInject(BusViewService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DisabledDatesService)); };
ViewComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ViewComponent, selectors: [["", "kendoCalendarView", ""]], inputs: { direction: "direction", isActive: "isActive", selectedDates: "selectedDates", weekNumber: "weekNumber", activeView: "activeView", cellUID: "cellUID", focusedDate: "focusedDate", viewDate: "viewDate", activeRangeEnd: "activeRangeEnd", selectionRange: "selectionRange", min: "min", max: "max", viewIndex: "viewIndex", templateRef: "templateRef", weekNumberTemplateRef: "weekNumberTemplateRef" }, outputs: { cellClick: "cellClick", weekNumberCellClick: "weekNumberCellClick", cellEnter: "cellEnter", cellLeave: "cellLeave" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c91, decls: 4, vars: 2, consts: [["emptyCell", ""], ["class", "k-calendar-tr", "role", "row", 4, "ngIf"], ["class", "k-calendar-tr", "role", "row", 4, "kFor", "kForOf"], [1, "k-empty", "k-calendar-td"], ["role", "row", 1, "k-calendar-tr"], ["scope", "col", 1, "k-calendar-caption", 3, "colSpan"], [3, "ngIf"], [4, "kFor", "kForOf"], ["class", "k-alt k-calendar-td", 3, "kendoEventsOutsideAngular", 4, "ngIf", "ngIfElse"], [1, "k-alt", "k-calendar-td", 3, "kendoEventsOutsideAngular"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "k-calendar-td", "role", "gridcell", 3, "ngClass", "title", 4, "ngIf", "ngIfElse"], ["role", "gridcell", 1, "k-calendar-td", 3, "ngClass", "title"], [1, "k-link"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function ViewComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ViewComponent_ng_template_0_Template, 2, 0, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, ViewComponent_tr_2_Template, 3, 2, "tr", 1);
        ɵngcc0.ɵɵtemplate(3, ViewComponent_tr_3_Template, 3, 2, "tr", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isHorizontal());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("kForOf", ctx.data);
    } }, directives: [ɵngcc2.NgIf, KForOf, ɵngcc4.EventsOutsideAngularDirective, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgClass], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], ViewComponent.prototype, "direction", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ViewComponent.prototype, "isActive", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ViewComponent.prototype, "activeView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ViewComponent.prototype, "cellUID", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], ViewComponent.prototype, "focusedDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], ViewComponent.prototype, "viewDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ViewComponent.prototype, "activeRangeEnd", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ViewComponent.prototype, "selectionRange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], ViewComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], ViewComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ViewComponent.prototype, "selectedDates", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], ViewComponent.prototype, "weekNumber", null);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ViewComponent.prototype, "viewIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ViewComponent.prototype, "templateRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], ViewComponent.prototype, "weekNumberTemplateRef", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ViewComponent.prototype, "cellClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ViewComponent.prototype, "weekNumberCellClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ViewComponent.prototype, "cellEnter", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ViewComponent.prototype, "cellLeave", void 0);
ViewComponent = __decorate([ __metadata("design:paramtypes", [BusViewService,
        IntlService,
        ChangeDetectorRef,
        ElementRef,
        NgZone,
        Renderer2,
        DisabledDatesService])
], ViewComponent);

/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `HeaderComponent`&mdash;The component that renders the UI for vertical navigation.
 * - `ViewComponent`&mdash;The component that renders the active Calendar view.
 */
let CalendarCommonModule = class CalendarCommonModule {
};
CalendarCommonModule.ɵfac = function CalendarCommonModule_Factory(t) { return new (t || CalendarCommonModule)(); };
CalendarCommonModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CalendarCommonModule });
CalendarCommonModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, EventsModule]] });

/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `CellTemplateDirective`&mdash;The month cell template directive.
 * - `MonthCellTemplateDirective`&mdash;The month cell template directive.
 * - `YearCellTemplateDirective`&mdash;The year cell template directive.
 * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.
 * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.
 * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.
 * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.
 * - `NavigationItemTemplateDirective`&mdash;The navigation item template directive.
 */
let TemplatesModule = class TemplatesModule {
};
TemplatesModule.ɵfac = function TemplatesModule_Factory(t) { return new (t || TemplatesModule)(); };
TemplatesModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: TemplatesModule });
TemplatesModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});

/**
 * @hidden
 */
class Messages extends ComponentMessages {
}
Messages.ɵfac = /*@__PURE__*/ function () { let ɵMessages_BaseFactory; return function Messages_Factory(t) { return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages)))(t || Messages); }; }();
Messages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: Messages, inputs: { today: "today", prevButtonTitle: "prevButtonTitle", nextButtonTitle: "nextButtonTitle" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "today", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "prevButtonTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "nextButtonTitle", void 0);

var MultiViewCalendarLocalizedMessagesDirective_1;
/**
 * @hidden
 */
let MultiViewCalendarLocalizedMessagesDirective = MultiViewCalendarLocalizedMessagesDirective_1 = class MultiViewCalendarLocalizedMessagesDirective extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
};
MultiViewCalendarLocalizedMessagesDirective.ɵfac = function MultiViewCalendarLocalizedMessagesDirective_Factory(t) { return new (t || MultiViewCalendarLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
MultiViewCalendarLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MultiViewCalendarLocalizedMessagesDirective, selectors: [["", "kendoMultiViewCalendarLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => MultiViewCalendarLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
MultiViewCalendarLocalizedMessagesDirective = MultiViewCalendarLocalizedMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], MultiViewCalendarLocalizedMessagesDirective);

var MultiViewCalendarCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).
 */
let MultiViewCalendarCustomMessagesComponent = MultiViewCalendarCustomMessagesComponent_1 = class MultiViewCalendarCustomMessagesComponent extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
MultiViewCalendarCustomMessagesComponent.ɵfac = function MultiViewCalendarCustomMessagesComponent_Factory(t) { return new (t || MultiViewCalendarCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
MultiViewCalendarCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MultiViewCalendarCustomMessagesComponent, selectors: [["kendo-multiviewcalendar-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => MultiViewCalendarCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function MultiViewCalendarCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
MultiViewCalendarCustomMessagesComponent = MultiViewCalendarCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], MultiViewCalendarCustomMessagesComponent);

/**
 * The package exports:
 * - `CellTemplateDirective`&mdash;The month cell template directive.
 * - `MonthCellTemplateDirective`&mdash;The month cell template directive.
 * - `YearCellTemplateDirective`&mdash;The year cell template directive.
 * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.
 * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.
 * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.
 * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the MultiViewCalendar module
 * import { MultiViewCalendarModule } from '@progress/kendo-angular-dateinputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, MultiViewCalendarModule], // import MultiViewCalendar module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 */
let MultiViewCalendarModule = class MultiViewCalendarModule {
};
MultiViewCalendarModule.ɵfac = function MultiViewCalendarModule_Factory(t) { return new (t || MultiViewCalendarModule)(); };
MultiViewCalendarModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MultiViewCalendarModule });
MultiViewCalendarModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        NavigationService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        WeekNamesService
    ], imports: [[
            CommonModule,
            CalendarCommonModule,
            IntlModule,
            TemplatesModule,
            PopupModule,
            EventsModule
        ], CalendarCommonModule, TemplatesModule] });

/**
 * @hidden
 */
class CalendarMessages extends ComponentMessages {
}
CalendarMessages.ɵfac = /*@__PURE__*/ function () { let ɵCalendarMessages_BaseFactory; return function CalendarMessages_Factory(t) { return (ɵCalendarMessages_BaseFactory || (ɵCalendarMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(CalendarMessages)))(t || CalendarMessages); }; }();
CalendarMessages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CalendarMessages, inputs: { today: "today", prevButtonTitle: "prevButtonTitle", nextButtonTitle: "nextButtonTitle" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], CalendarMessages.prototype, "today", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CalendarMessages.prototype, "prevButtonTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CalendarMessages.prototype, "nextButtonTitle", void 0);

var CalendarLocalizedMessagesDirective_1;
/**
 * @hidden
 */
let CalendarLocalizedMessagesDirective = CalendarLocalizedMessagesDirective_1 = class CalendarLocalizedMessagesDirective extends CalendarMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
CalendarLocalizedMessagesDirective.ɵfac = function CalendarLocalizedMessagesDirective_Factory(t) { return new (t || CalendarLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
CalendarLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CalendarLocalizedMessagesDirective, selectors: [["", "kendoCalendarLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: CalendarMessages,
                useExisting: forwardRef(() => CalendarLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
CalendarLocalizedMessagesDirective = CalendarLocalizedMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], CalendarLocalizedMessagesDirective);

var CalendarCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).
 */
let CalendarCustomMessagesComponent = CalendarCustomMessagesComponent_1 = class CalendarCustomMessagesComponent extends CalendarMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
CalendarCustomMessagesComponent.ɵfac = function CalendarCustomMessagesComponent_Factory(t) { return new (t || CalendarCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
CalendarCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CalendarCustomMessagesComponent, selectors: [["kendo-calendar-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: CalendarMessages,
                useExisting: forwardRef(() => CalendarCustomMessagesComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CalendarCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
CalendarCustomMessagesComponent = CalendarCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], CalendarCustomMessagesComponent);

const COMPONENT_DIRECTIVES = [
    VirtualizationComponent
];
/**
 * @hidden
 *
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Virtualization component.
 */
let VirtualizationModule = class VirtualizationModule {
};
VirtualizationModule.ɵfac = function VirtualizationModule_Factory(t) { return new (t || VirtualizationModule)(); };
VirtualizationModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: VirtualizationModule });
VirtualizationModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

/**
 * The exported package module.
 *
 * The package exports:
 * - `CellTemplateDirective`&mdash;The month cell template directive.
 * - `MonthCellTemplateDirective`&mdash;The month cell template directive.
 * - `YearCellTemplateDirective`&mdash;The year cell template directive.
 * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.
 * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.
 * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.
 * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.
 * - `NavigationItemTemplateDirective`&mdash;The navigation item template directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Calendar module
 * import { CalendarModule } from '@progress/kendo-angular-dateinputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, CalendarModule], // import Calendar module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let CalendarModule = class CalendarModule {
};
CalendarModule.ɵfac = function CalendarModule_Factory(t) { return new (t || CalendarModule)(); };
CalendarModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CalendarModule });
CalendarModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        WeekNamesService
    ], imports: [[
            CommonModule,
            CalendarCommonModule,
            MultiViewCalendarModule,
            IntlModule,
            TemplatesModule,
            VirtualizationModule,
            EventsModule,
            ResizeSensorModule
        ], CalendarCommonModule, TemplatesModule] });

/**
 * The exported package module.
 *
 * The package exports:
 * - `CalendarModule`&mdash;The calendar module.
 * - `MultiViewCalendarModule`&mdash;The multi-view calendar module.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Calendars module
 * import { CalendarsModule } from '@progress/kendo-angular-dateinputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, CalendarsModule], // import the Calendars module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let CalendarsModule = class CalendarsModule {
};
CalendarsModule.ɵfac = function CalendarsModule_Factory(t) { return new (t || CalendarsModule)(); };
CalendarsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CalendarsModule });
CalendarsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            CalendarModule,
            MultiViewCalendarModule
        ], CalendarModule, MultiViewCalendarModule] });

/**
 * @hidden
 */
class DateInputMessages extends ComponentMessages {
}
DateInputMessages.ɵfac = /*@__PURE__*/ function () { let ɵDateInputMessages_BaseFactory; return function DateInputMessages_Factory(t) { return (ɵDateInputMessages_BaseFactory || (ɵDateInputMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(DateInputMessages)))(t || DateInputMessages); }; }();
DateInputMessages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DateInputMessages, inputs: { decrement: "decrement", increment: "increment" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], DateInputMessages.prototype, "decrement", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DateInputMessages.prototype, "increment", void 0);

var DateInputLocalizedMessagesDirective_1;
/**
 * @hidden
 */
let DateInputLocalizedMessagesDirective = DateInputLocalizedMessagesDirective_1 = class DateInputLocalizedMessagesDirective extends DateInputMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
DateInputLocalizedMessagesDirective.ɵfac = function DateInputLocalizedMessagesDirective_Factory(t) { return new (t || DateInputLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
DateInputLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DateInputLocalizedMessagesDirective, selectors: [["", "kendoDateInputLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: DateInputMessages,
                useExisting: forwardRef(() => DateInputLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
DateInputLocalizedMessagesDirective = DateInputLocalizedMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], DateInputLocalizedMessagesDirective);

var DateInputCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).
 */
let DateInputCustomMessagesComponent = DateInputCustomMessagesComponent_1 = class DateInputCustomMessagesComponent extends DateInputMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
DateInputCustomMessagesComponent.ɵfac = function DateInputCustomMessagesComponent_Factory(t) { return new (t || DateInputCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
DateInputCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DateInputCustomMessagesComponent, selectors: [["kendo-dateinput-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: DateInputMessages,
                useExisting: forwardRef(() => DateInputCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function DateInputCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
DateInputCustomMessagesComponent = DateInputCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], DateInputCustomMessagesComponent);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the DateInput component.
 */
let DateInputModule = class DateInputModule {
};
DateInputModule.ɵfac = function DateInputModule_Factory(t) { return new (t || DateInputModule)(); };
DateInputModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DateInputModule });
DateInputModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, IntlModule, EventsModule]] });

/**
 * @hidden
 */
class DatePickerMessages extends ComponentMessages {
}
DatePickerMessages.ɵfac = /*@__PURE__*/ function () { let ɵDatePickerMessages_BaseFactory; return function DatePickerMessages_Factory(t) { return (ɵDatePickerMessages_BaseFactory || (ɵDatePickerMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(DatePickerMessages)))(t || DatePickerMessages); }; }();
DatePickerMessages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DatePickerMessages, inputs: { today: "today", toggle: "toggle", prevButtonTitle: "prevButtonTitle", nextButtonTitle: "nextButtonTitle" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerMessages.prototype, "today", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerMessages.prototype, "toggle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerMessages.prototype, "prevButtonTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerMessages.prototype, "nextButtonTitle", void 0);

var DatePickerLocalizedMessagesDirective_1;
/**
 * @hidden
 */
let DatePickerLocalizedMessagesDirective = DatePickerLocalizedMessagesDirective_1 = class DatePickerLocalizedMessagesDirective extends DatePickerMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
DatePickerLocalizedMessagesDirective.ɵfac = function DatePickerLocalizedMessagesDirective_Factory(t) { return new (t || DatePickerLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
DatePickerLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DatePickerLocalizedMessagesDirective, selectors: [["", "kendoDatePickerLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: DatePickerMessages,
                useExisting: forwardRef(() => DatePickerLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
DatePickerLocalizedMessagesDirective = DatePickerLocalizedMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], DatePickerLocalizedMessagesDirective);

var DatePickerCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).
 */
let DatePickerCustomMessagesComponent = DatePickerCustomMessagesComponent_1 = class DatePickerCustomMessagesComponent extends DatePickerMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
DatePickerCustomMessagesComponent.ɵfac = function DatePickerCustomMessagesComponent_Factory(t) { return new (t || DatePickerCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
DatePickerCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DatePickerCustomMessagesComponent, selectors: [["kendo-datepicker-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: DatePickerMessages,
                useExisting: forwardRef(() => DatePickerCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function DatePickerCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
DatePickerCustomMessagesComponent = DatePickerCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], DatePickerCustomMessagesComponent);

const ɵ0$e = touchEnabled;
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the DatePicker component.
 */
let DatePickerModule = class DatePickerModule {
};
DatePickerModule.ɵfac = function DatePickerModule_Factory(t) { return new (t || DatePickerModule)(); };
DatePickerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DatePickerModule });
DatePickerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [{ provide: TOUCH_ENABLED, useValue: ɵ0$e }], imports: [[
            CommonModule,
            DateInputModule,
            CalendarModule,
            IntlModule,
            PopupModule,
            TemplatesModule,
            EventsModule
        ], TemplatesModule] });

const COMPONENT_DIRECTIVES$1 = [
    DateRangeComponent,
    DateRangePopupComponent,
    DateRangePopupTemplateDirective,
    DateRangeSelectionDirective,
    DateRangeStartInputDirective,
    DateRangeEndInputDirective
];
const COMPONENT_MODULES = [
    MultiViewCalendarModule,
    DateInputModule,
    PopupModule,
    EventsModule
];
/**
 * The exported package module.
 *
 * The package exports:
 * - `DateRangeComponent`&mdash;The DateRange component class.
 * - `DateRangePopupComponent`&mdash;The DateRangePopup component class.
 * - `DateRangeSelectionDirective`&mdash;The MultiviewCalendar date range selection directive.
 * - `DateRangeEndInputDirective`&mdash;The end DateInput date range selection directive.
 * - `DateRangeStartInputDirective`&mdash;The start DateInput date range selection directive.
 * - `DateRangePopupTemplateDirective`&mdash;The DateRangePopup content template directive.
 * - `MultiViewCalendarModule`&mdash;The MultiViewCalendar module.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the DateRange module
 * import { DateRangeModule } from '@progress/kendo-angular-dateinputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, DateRangeModule], // import DateRange module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let DateRangeModule = class DateRangeModule {
};
DateRangeModule.ɵfac = function DateRangeModule_Factory(t) { return new (t || DateRangeModule)(); };
DateRangeModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DateRangeModule });
DateRangeModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, COMPONENT_MODULES]] });

const div$1 = domContainerFactory('div');
const ul$1 = domContainerFactory('ul');
const li$1 = domContainerFactory('li');
const span = domContainerFactory('span');
const listTitle = () => span('hour', 'k-title k-timeselector-title');
const listItem = () => li$1('<span>02</span>', 'k-item');
const list = () => ul$1([listItem()], 'k-reset');
const scrollable$1 = () => (div$1([list()], 'k-time-container k-flex k-content k-calendar-content k-scrollable'));
const timeListWrapper = () => {
    if (!isDocumentAvailable()) {
        return null;
    }
    return div$1([listTitle(), div$1([scrollable$1()], 'k-time-list')], 'k-time-list-wrapper', { left: '-10000px', position: 'absolute' });
};
const TIMELIST_WRAPPER = timeListWrapper();
/**
 * @hidden
 */
let TimePickerDOMService = class TimePickerDOMService {
    ensureHeights() {
        if (this.timeListHeight !== undefined) {
            return;
        }
        this.calculateHeights();
    }
    calculateHeights(container) {
        if (!isDocumentAvailable()) {
            return;
        }
        const listContainer = container && container.querySelector('.k-time-list-container');
        const hostContainer = listContainer || document.body;
        const wrapper = hostContainer.appendChild(TIMELIST_WRAPPER);
        this.timeListHeight = wrapper.querySelector('.k-scrollable').getBoundingClientRect().height;
        this.itemHeight = wrapper.querySelector('li').getBoundingClientRect().height;
        hostContainer.removeChild(wrapper);
    }
    isActive(element) {
        if (!isDocumentAvailable() || !element) {
            return false;
        }
        return (element.nativeElement || element) === document.activeElement;
    }
};
TimePickerDOMService.ɵfac = function TimePickerDOMService_Factory(t) { return new (t || TimePickerDOMService)(); };
TimePickerDOMService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: TimePickerDOMService, factory: function (t) { return TimePickerDOMService.ɵfac(t); } });

const HOURS_IN_DAY = 24;
const clampToRange = (rangeValue) => (value) => value % rangeValue;
const clamp = clampToRange(HOURS_IN_DAY);
const stepper = (start, step) => (idx) => clamp(start + (idx * step));
const distanceFromMin = (value, min) => clamp(HOURS_IN_DAY + value - min);
const limit = (borderValue) => (barrier, value) => {
    const useBarrier = !value || getDate(barrier).getTime() === getDate(value).getTime();
    return useBarrier ? barrier : setHours(barrier, borderValue);
};
const limitDown = limit(0);
const limitUp = limit(HOURS_IN_DAY - 1);
/**
 * @hidden
 */
let HoursService = class HoursService {
    constructor(intl) {
        this.intl = intl;
        this.boundRange = false;
        this.insertUndividedMax = false;
    }
    apply(value, candidate) {
        return setHours(value, candidate.getHours());
    }
    configure(settings) {
        const { boundRange = this.boundRange, insertUndividedMax = this.insertUndividedMax, min = this.min, max = this.max, part, step = this.step } = settings;
        this.boundRange = boundRange;
        this.insertUndividedMax = insertUndividedMax;
        this.toListItem = (hour) => {
            const date = setHours(MIDNIGHT_DATE, hour);
            return {
                text: this.intl.formatDate(date, part.pattern),
                value: date
            };
        };
        this.min = min;
        this.max = max;
        this.step = step;
    }
    data(selectedValue) {
        const [min] = this.range(selectedValue);
        const getHour = stepper(min, this.step);
        const convertToItem = (idx) => (this.toListItem(getHour(idx)));
        const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
        this.addLast(data);
        this.addMissing(data, selectedValue);
        return data;
    }
    isRangeChanged(min, max) {
        return !isEqual(this.min, min) || !isEqual(this.max, max);
    }
    limitRange(min, max, value) {
        return this.boundRange ? [limitDown(min, value), limitUp(max, value)] : [min, max];
    }
    total(value) {
        const last$$1 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;
        const missing = this.isMissing(value) ? 1 : 0;
        return this.countFromMin(value) + missing + last$$1;
    }
    selectedIndex(value) {
        return Math.ceil(this.divideByStep(value));
    }
    valueInList(value) {
        if (!value) {
            return true;
        }
        const matchMax = this.insertUndividedMax && this.lastHour(value) === value.getHours();
        return matchMax || !this.isMissing(value);
    }
    addLast(data, value) {
        if (this.insertUndividedMax && this.isLastMissing(value)) {
            data.push(this.toListItem(this.lastHour(value)));
        }
        return data;
    }
    addMissing(data, value) {
        if (this.valueInList(value)) {
            return data;
        }
        const missingItem = this.toListItem(value.getHours());
        data.splice(this.selectedIndex(value), 0, missingItem);
        return data;
    }
    countFromMin(value) {
        const [min, max] = this.range(value);
        return Math.floor(distanceFromMin(max, min) / this.step) + 1; /* include min */
    }
    isMissing(value) {
        if (!value) {
            return false;
        }
        return this.selectedIndex(value) !== this.divideByStep(value);
    }
    isLastMissing(value) {
        return this.isMissing(setHours(this.max, this.lastHour(value)));
    }
    divideByStep(value) {
        return distanceFromMin(value.getHours(), this.min.getHours()) / this.step;
    }
    lastHour(value) {
        return this.range(value)[1];
    }
    range(value) {
        const [min, max] = this.limitRange(this.min, this.max, value);
        return [min.getHours(), max.getHours()];
    }
};
HoursService.ɵfac = function HoursService_Factory(t) { return new (t || HoursService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService)); };
HoursService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: HoursService, factory: function (t) { return HoursService.ɵfac(t); } });
HoursService = __decorate([ __metadata("design:paramtypes", [IntlService])
], HoursService);

const MINUTES_IN_HOUR = 60;
const clampToRange$1 = (rangeValue) => (value) => value % rangeValue;
const clamp$1 = clampToRange$1(MINUTES_IN_HOUR);
const stepper$1 = (start, step) => (idx) => clamp$1(start + (idx * step));
const distanceFromMin$1 = (value, min) => clamp$1(MINUTES_IN_HOUR + value - min);
const limit$1 = (borderValue) => (barrier, value) => {
    const useBarrier = !value || barrier.getHours() === value.getHours();
    return useBarrier ? barrier : setMinutes(barrier, borderValue);
};
const limitDown$1 = limit$1(0);
const limitUp$1 = limit$1(MINUTES_IN_HOUR - 1);
/**
 * @hidden
 */
let MinutesService = class MinutesService {
    constructor(intl) {
        this.intl = intl;
        this.insertUndividedMax = false;
    }
    apply(value, candidate) {
        return setMinutes(value, candidate.getMinutes());
    }
    configure(settings) {
        const { insertUndividedMax = this.insertUndividedMax, min = this.min, max = this.max, part, step = this.step } = settings;
        this.insertUndividedMax = insertUndividedMax;
        this.toListItem = (minute) => {
            const date = setMinutes(MIDNIGHT_DATE, minute);
            return {
                text: this.intl.formatDate(date, part.pattern),
                value: date
            };
        };
        this.min = min;
        this.max = max;
        this.step = step;
    }
    data(selectedValue) {
        const [min] = this.range(selectedValue);
        const getMinute = stepper$1(min, this.step);
        const convertToItem = (idx) => (this.toListItem(getMinute(idx)));
        const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
        this.addLast(data);
        this.addMissing(data, selectedValue);
        return data;
    }
    isRangeChanged(min, max) {
        return !isEqual(this.min, min) || !isEqual(this.max, max);
    }
    limitRange(min, max, value) {
        return [limitDown$1(min, value), limitUp$1(max, value)];
    }
    total(value) {
        const last$$1 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;
        const missing = this.isMissing(value) ? 1 : 0;
        return this.countFromMin(value) + missing + last$$1;
    }
    selectedIndex(value) {
        return Math.ceil(this.divideByStep(value));
    }
    valueInList(value) {
        if (!value) {
            return true;
        }
        const matchMax = this.insertUndividedMax && this.lastMinute(value) === value.getMinutes();
        return matchMax || !this.isMissing(value);
    }
    addLast(data, value) {
        if (this.insertUndividedMax && this.isLastMissing(value)) {
            data.push(this.toListItem(this.lastMinute(value)));
        }
        return data;
    }
    addMissing(data, value) {
        if (this.valueInList(value)) {
            return data;
        }
        const missingItem = this.toListItem(value.getMinutes());
        data.splice(this.selectedIndex(value), 0, missingItem);
        return data;
    }
    countFromMin(value) {
        const [min, max] = this.range(value);
        return Math.floor(distanceFromMin$1(max, min) / this.step) + 1; /* include min */
    }
    isMissing(value) {
        if (!value) {
            return false;
        }
        return this.selectedIndex(value) !== this.divideByStep(value);
    }
    isLastMissing(value) {
        return this.isMissing(setMinutes(this.max, this.lastMinute(value)));
    }
    divideByStep(value) {
        return distanceFromMin$1(value.getMinutes(), this.min.getMinutes()) / this.step;
    }
    lastMinute(value) {
        return this.range(value)[1];
    }
    range(value) {
        const [min, max] = this.limitRange(this.min, this.max, value);
        return [min.getMinutes(), max.getMinutes()];
    }
};
MinutesService.ɵfac = function MinutesService_Factory(t) { return new (t || MinutesService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService)); };
MinutesService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MinutesService, factory: function (t) { return MinutesService.ɵfac(t); } });
MinutesService = __decorate([ __metadata("design:paramtypes", [IntlService])
], MinutesService);

const SECONDS_IN_HOUR = 60;
const clampToRange$2 = (rangeValue) => (value) => value % rangeValue;
const clamp$2 = clampToRange$2(SECONDS_IN_HOUR);
const stepper$2 = (start, step) => (idx) => clamp$2(start + (idx * step));
const distanceFromMin$2 = (value, min) => clamp$2(SECONDS_IN_HOUR + value - min);
const limit$2 = (borderValue) => (barrier, value) => {
    const useBarrier = !value || barrier.getHours() === value.getHours() && barrier.getMinutes() === value.getMinutes();
    return useBarrier ? barrier : setSeconds(barrier, borderValue);
};
const limitDown$2 = limit$2(0);
const limitUp$2 = limit$2(SECONDS_IN_HOUR - 1);
/**
 * @hidden
 */
let SecondsService = class SecondsService {
    constructor(intl) {
        this.intl = intl;
        this.insertUndividedMax = false;
    }
    apply(value, candidate) {
        return setSeconds(value, candidate.getSeconds());
    }
    configure(settings) {
        const { insertUndividedMax = this.insertUndividedMax, min = this.min, max = this.max, part, step = this.step } = settings;
        this.insertUndividedMax = insertUndividedMax;
        this.toListItem = (second) => {
            const date = setSeconds(MIDNIGHT_DATE, second);
            return {
                text: this.intl.formatDate(date, part.pattern),
                value: date
            };
        };
        this.min = min;
        this.max = max;
        this.step = step;
    }
    data(selectedValue) {
        const [min] = this.range(selectedValue);
        const getSecond = stepper$2(min, this.step);
        const convertToItem = (idx) => (this.toListItem(getSecond(idx)));
        const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
        this.addLast(data);
        this.addMissing(data, selectedValue);
        return data;
    }
    isRangeChanged(min, max) {
        return !isEqual(this.min, min) || !isEqual(this.max, max);
    }
    limitRange(min, max, value) {
        return [limitDown$2(min, value), limitUp$2(max, value)];
    }
    total(value) {
        const last$$1 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;
        const missing = this.isMissing(value) ? 1 : 0;
        return this.countFromMin(value) + missing + last$$1;
    }
    selectedIndex(value) {
        return Math.ceil(this.divideByStep(value));
    }
    valueInList(value) {
        if (!value) {
            return true;
        }
        const matchMax = this.insertUndividedMax && this.lastSecond(value) === value.getSeconds();
        return matchMax || !this.isMissing(value);
    }
    divideByStep(value) {
        return distanceFromMin$2(value.getSeconds(), this.min.getSeconds()) / this.step;
    }
    addLast(data, value) {
        if (this.insertUndividedMax && this.isLastMissing(value)) {
            data.push(this.toListItem(this.lastSecond(value)));
        }
        return data;
    }
    addMissing(data, value) {
        if (this.valueInList(value)) {
            return data;
        }
        const missingItem = this.toListItem(value.getSeconds());
        data.splice(this.selectedIndex(value), 0, missingItem);
        return data;
    }
    countFromMin(value) {
        const [min, max] = this.range(value);
        return Math.floor(distanceFromMin$2(max, min) / this.step) + 1; /* include min */
    }
    isMissing(value) {
        if (!value) {
            return false;
        }
        return this.selectedIndex(value) !== this.divideByStep(value);
    }
    isLastMissing(value) {
        return this.isMissing(setSeconds(this.max, this.lastSecond(value)));
    }
    lastSecond(value) {
        return this.range(value)[1];
    }
    range(value) {
        const [min, max] = this.limitRange(this.min, this.max, value);
        return [min.getSeconds(), max.getSeconds()];
    }
};
SecondsService.ɵfac = function SecondsService_Factory(t) { return new (t || SecondsService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService)); };
SecondsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SecondsService, factory: function (t) { return SecondsService.ɵfac(t); } });
SecondsService = __decorate([ __metadata("design:paramtypes", [IntlService])
], SecondsService);

const MILLISECONDS_IN_SECOND = 1000;
const clampToRange$3 = (rangeValue) => (value) => value % rangeValue;
const clamp$3 = clampToRange$3(MILLISECONDS_IN_SECOND);
const stepper$3 = (start, step) => (idx) => clamp$3(start + (idx * step));
const distanceFromMin$3 = (value, min) => clamp$3(MILLISECONDS_IN_SECOND + value - min);
const limit$3 = (borderValue) => (barrier, value) => {
    const useBarrier = !value ||
        (barrier.getHours() === value.getHours() &&
            barrier.getMinutes() === value.getMinutes() &&
            barrier.getSeconds() === value.getSeconds());
    return useBarrier ? barrier : setMilliseconds(barrier, borderValue);
};
const limitDown$3 = limit$3(0);
const limitUp$3 = limit$3(MILLISECONDS_IN_SECOND - 1);
/**
 * @hidden
 */
let MillisecondsService = class MillisecondsService {
    constructor(intl) {
        this.intl = intl;
        this.insertUndividedMax = false;
    }
    apply(value, candidate) {
        return setMilliseconds(value, candidate.getMilliseconds());
    }
    configure(settings) {
        const { insertUndividedMax = this.insertUndividedMax, min = this.min, max = this.max, step = this.step } = settings;
        this.insertUndividedMax = insertUndividedMax;
        this.toListItem = (millisecond) => {
            const date = setMilliseconds(MIDNIGHT_DATE, millisecond);
            return {
                text: this.intl.formatDate(date, "SSS"),
                value: date
            };
        };
        this.min = min;
        this.max = max;
        this.step = step;
    }
    data(selectedValue) {
        const [min] = this.range(selectedValue);
        const getMillisecond = stepper$3(min, this.step);
        const convertToItem = (idx) => (this.toListItem(getMillisecond(idx)));
        const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
        this.addLast(data);
        this.addMissing(data, selectedValue);
        return data;
    }
    isRangeChanged(min, max) {
        return !isEqual(this.min, min) || !isEqual(this.max, max);
    }
    limitRange(min, max, value) {
        return [limitDown$3(min, value), limitUp$3(max, value)];
    }
    total(value) {
        const last$$1 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;
        const missing = this.isMissing(value) ? 1 : 0;
        return this.countFromMin(value) + missing + last$$1;
    }
    selectedIndex(value) {
        return Math.ceil(this.divideByStep(value));
    }
    valueInList(value) {
        if (!value) {
            return true;
        }
        const matchMax = this.insertUndividedMax && this.lastMillisecond(value) === value.getMilliseconds();
        return matchMax || !this.isMissing(value);
    }
    divideByStep(value) {
        return distanceFromMin$3(value.getMilliseconds(), this.min.getMilliseconds()) / this.step;
    }
    addLast(data, value) {
        if (this.insertUndividedMax && this.isLastMissing(value)) {
            data.push(this.toListItem(this.lastMillisecond(value)));
        }
        return data;
    }
    addMissing(data, value) {
        if (this.valueInList(value)) {
            return data;
        }
        const missingItem = this.toListItem(value.getMilliseconds());
        data.splice(this.selectedIndex(value), 0, missingItem);
        return data;
    }
    countFromMin(value) {
        const [min, max] = this.range(value);
        return Math.floor(distanceFromMin$3(max, min) / this.step) + 1; /* include min */
    }
    isMissing(value) {
        if (!value) {
            return false;
        }
        return this.selectedIndex(value) !== this.divideByStep(value);
    }
    isLastMissing(value) {
        return this.isMissing(setMilliseconds(this.max, this.lastMillisecond(value)));
    }
    lastMillisecond(value) {
        return this.range(value)[1];
    }
    range(value) {
        const [min, max] = this.limitRange(this.min, this.max, value);
        return [min.getMilliseconds(), max.getMilliseconds()];
    }
};
MillisecondsService.ɵfac = function MillisecondsService_Factory(t) { return new (t || MillisecondsService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService)); };
MillisecondsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MillisecondsService, factory: function (t) { return MillisecondsService.ɵfac(t); } });
MillisecondsService = __decorate([ __metadata("design:paramtypes", [IntlService])
], MillisecondsService);

const setHours$1 = (date, hours) => {
    const clone = cloneDate(date);
    clone.setHours(hours);
    return clone;
};
const isAM = (value) => value !== null && value < 12;
const isPM = (value) => value !== null && (!value || value > 11);
const inRange = (value, min, max) => ((!min && !max) || (value >= min && value <= max));
const inReverseRange = (value, min, max) => ((!min && !max) || value >= min || value <= max);
/**
 * @hidden
 */
let DayPeriodService = class DayPeriodService {
    constructor(intl) {
        this.intl = intl;
    }
    /**
     * @hidden
     */
    apply(value, candidate) {
        const hour = value.getHours();
        const hourAM = isAM(hour);
        const candidateAM = isAM(candidate.getHours());
        if ((hourAM && candidateAM) || (!hourAM && !candidateAM)) {
            return value;
        }
        const [min, max = 24] = this.normalizedRange();
        const result = hour + (candidateAM ? -12 : 12);
        return setHours$1(value, Math.min(Math.max(min, result), (max || 24)));
    }
    /**
     * @hidden
     */
    configure(settings) {
        const { min = this.min, max = this.max, part = this.part } = settings;
        this.min = min;
        this.max = max;
        this.part = part;
    }
    /**
     * @hidden
     */
    data(_) {
        const names = this.part.names;
        if (!names) {
            return [];
        }
        const data = [];
        const [min, max] = this.normalizedRange();
        const dayPeriod = this.intl.dateFormatNames(names);
        if (isAM(min)) {
            data.push({ text: dayPeriod.am, value: setHours$1(this.min, min) });
        }
        if (isPM(max)) {
            data.push({ text: dayPeriod.pm, value: setHours$1(this.min, Math.max(12, max)) });
        }
        return this.min.getHours() !== min ? data.reverse() : data;
    }
    /**
     * @hidden
     */
    isRangeChanged(_, __) {
        return false;
    }
    /**
     * @hidden
     */
    limitRange(min, max, _) {
        return [min, max];
    }
    /**
     * @hidden
     */
    total() {
        const [min, max] = this.normalizedRange();
        if (!min && !max) {
            return 2;
        }
        if (min > 11 || max < 12) {
            return 1;
        }
        return 2;
    }
    /**
     * @hidden
     */
    selectedIndex(value) {
        if (!this.valueInList(value)) {
            return -1;
        }
        const index = Math.floor(value.getHours() / 12);
        return this.min.getHours() === this.normalizedRange()[0] ? index : (index === 0 ? 1 : 0);
    }
    /**
     * @hidden
     */
    valueInList(value) {
        const reverse = this.min.getHours() !== this.normalizedRange()[0];
        const isInRange = reverse ? inReverseRange : inRange;
        return isInRange(value.getHours(), this.min.getHours(), this.max.getHours());
    }
    normalizedRange() {
        const minHour = this.min.getHours();
        const maxHour = this.max.getHours();
        return [
            Math.min(minHour, maxHour),
            Math.max(minHour, maxHour)
        ];
    }
};
DayPeriodService.ɵfac = function DayPeriodService_Factory(t) { return new (t || DayPeriodService)(ɵngcc0.ɵɵinject(ɵngcc1.IntlService)); };
DayPeriodService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DayPeriodService, factory: function (t) { return DayPeriodService.ɵfac(t); } });
DayPeriodService = __decorate([ __metadata("design:paramtypes", [IntlService])
], DayPeriodService);

const SNAP_THRESHOLD = 0.05; //% of the item height
const SCROLL_THRESHOLD = 2; //< 2px threshold
const nil = () => (null);
const getters = {
    35: (data, _) => data[data.length - 1],
    36: (data, _) => data[0],
    38: (data, index) => data[index - 1],
    40: (data, index) => data[index + 1]
};
const services$1 = {
    [TIME_PART.dayperiod]: DayPeriodService,
    [TIME_PART.hour]: HoursService,
    [TIME_PART.minute]: MinutesService,
    [TIME_PART.second]: SecondsService,
    [TIME_PART.millisecond]: MillisecondsService
};
/**
 * @hidden
 */
let TimeListComponent = class TimeListComponent {
    constructor(element, injector, dom, renderer, zone) {
        this.element = element;
        this.injector = injector;
        this.dom = dom;
        this.renderer = renderer;
        this.zone = zone;
        this.min = cloneDate(MIDNIGHT_DATE);
        this.max = cloneDate(MAX_TIME);
        this.step = 1;
        this.disabled = false;
        this.valueChange = new EventEmitter();
        this.componentClass = true;
        this.animateToIndex = true;
        this.isActive = false;
        this.skip = 0;
        this.total = 60;
        this.data = [];
        this.indexToScroll = -1;
        this.domEvents = [];
    }
    get tabIndex() {
        return this.disabled ? undefined : 0;
    }
    ngOnChanges(changes) {
        if (changes.part) {
            this.service = this.injector.get(services$1[this.part.type]);
            this.service.configure(this.serviceSettings());
        }
        const value = this.value;
        const valueChanges = changes.value || {};
        const [min, max] = this.service.limitRange(this.min, this.max, value);
        if (this.service.isRangeChanged(min, max) || changes.min || changes.max || changes.step) {
            this.data = [];
            this.service.configure(this.serviceSettings({ min, max }));
        }
        // Skip the rendering of the list whenever possible
        if (!this.data.length || this.hasMissingValue(valueChanges)) {
            this.animateToIndex = false;
            this.data = this.service.data(value);
        }
        this.animateToIndex = this.animateToIndex && this.textHasChanged(valueChanges);
        this.total = this.service.total(value);
        this.indexToScroll = this.selectedIndex(value);
    }
    ngOnInit() {
        this.animateToIndex = true;
        this.dom.ensureHeights();
        this.itemHeight = this.dom.itemHeight;
        this.listHeight = this.dom.timeListHeight;
        this.topOffset = (this.listHeight - this.itemHeight) / 2;
        this.bottomOffset = this.listHeight - this.itemHeight;
        this.topThreshold = this.itemHeight * SNAP_THRESHOLD;
        this.bottomThreshold = this.itemHeight * (1 - SNAP_THRESHOLD);
        const translate = `translateY(${this.topOffset}px)`;
        this.style = { transform: translate, '-ms-transform': translate };
        if (this.element) {
            this.zone.runOutsideAngular(() => {
                this.bindEvents();
            });
        }
    }
    ngOnDestroy() {
        this.scrollSubscription.unsubscribe();
        this.domEvents.forEach(unbindCallback => unbindCallback());
    }
    ngAfterViewInit() {
        this.scrollOnce((index) => this.virtualization.scrollToIndex(index));
    }
    ngAfterViewChecked() {
        this.scrollOnce((index) => {
            const action = this.animateToIndex ? 'animateToIndex' : 'scrollToIndex';
            this.virtualization[action](index);
            this.animateToIndex = true;
        });
    }
    handleChange(dataItem) {
        const candidate = this.service.apply(this.value, dataItem.value);
        if (this.value.getTime() === candidate.getTime()) {
            return;
        }
        this.indexToScroll = this.data.indexOf(dataItem);
        this.value = candidate;
        this.valueChange.emit(candidate);
    }
    handleItemClick(args) {
        const item = closestInScope(args.target, node => node.hasAttribute('data-timelist-item-index'), this.element.nativeElement);
        if (item) {
            const index = item.getAttribute('data-timelist-item-index');
            this.handleChange(this.data[index]);
        }
    }
    /**
     * Focuses the host element of the TimeList.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="timelist.focus()">Focus TimeList</button>
     *  <kendo-timelist #timelist></kendo-timelist>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    focus() {
        if (!this.element) {
            return;
        }
        this.element.nativeElement.focus();
    }
    /**
     * Blurs the TimeList component.
     */
    blur() {
        if (!this.element) {
            return;
        }
        this.element.nativeElement.blur();
    }
    itemOffset(scrollTop) {
        const valueIndex = this.selectedIndex(this.value);
        const activeIndex = this.virtualization.activeIndex();
        const offset = this.virtualization.itemOffset(activeIndex);
        const distance = Math.abs(Math.ceil(scrollTop) - offset);
        if (valueIndex === activeIndex && distance < SCROLL_THRESHOLD) {
            return offset;
        }
        const scrollUp = valueIndex > activeIndex;
        const moveToNext = scrollUp && distance >= this.bottomThreshold || !scrollUp && distance > this.topThreshold;
        return moveToNext ? this.virtualization.itemOffset(activeIndex + 1) : offset;
    }
    hasMissingValue({ previousValue, currentValue }) {
        const isPreviousMissing = previousValue && !this.service.valueInList(previousValue);
        const isCurrentMissing = currentValue && !this.service.valueInList(currentValue);
        return isPreviousMissing || isCurrentMissing;
    }
    scrollOnce(action) {
        if (this.indexToScroll !== -1) {
            action(this.indexToScroll);
            this.indexToScroll = -1;
        }
    }
    serviceSettings(settings) {
        const defaults = {
            boundRange: false,
            insertUndividedMax: false,
            max: this.max,
            min: this.min,
            part: this.part,
            step: this.step
        };
        const result = Object.assign({}, defaults, settings);
        result.boundRange = result.part.type !== 'hour';
        return result;
    }
    selectedIndex(value) {
        if (!value) {
            return -1;
        }
        return this.service.selectedIndex(value);
    }
    textHasChanged({ previousValue, currentValue }) {
        if (!previousValue || !currentValue) {
            return false;
        }
        const oldData = this.data[this.selectedIndex(previousValue)];
        const newData = this.data[this.selectedIndex(currentValue)];
        return oldData && newData && oldData.text !== newData.text;
    }
    handleKeyDown(e) {
        const getter = getters[e.keyCode] || nil;
        const dataItem = getter(this.data, this.service.selectedIndex(this.value));
        if (dataItem) {
            this.handleChange(dataItem);
            e.preventDefault();
        }
    }
    bindEvents() {
        this.scrollSubscription = this.virtualization
            .scroll$()
            .pipe(debounceTime(100), map((e) => e.target.scrollTop), map((top) => this.itemOffset(top)), map((itemOffset) => this.virtualization.itemIndex(itemOffset)))
            .subscribe(index => {
            this.virtualization.scrollToIndex(index);
            this.handleChange(this.data[index]);
        });
        const element = this.element.nativeElement;
        this.domEvents.push(this.renderer.listen(element, 'mouseover', () => !this.isActive && this.focus()), this.renderer.listen(element, 'click', () => this.focus()), this.renderer.listen(element, 'blur', () => this.isActive = false), this.renderer.listen(element, 'focus', () => this.isActive = true), this.renderer.listen(element, 'keydown', this.handleKeyDown.bind(this)));
    }
};
TimeListComponent.ɵfac = function TimeListComponent_Factory(t) { return new (t || TimeListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(TimePickerDOMService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
TimeListComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TimeListComponent, selectors: [["kendo-timelist"]], viewQuery: function TimeListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(VirtualizationComponent, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtualization = _t.first);
    } }, hostVars: 3, hostBindings: function TimeListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵclassProp("k-time-list", ctx.componentClass);
    } }, inputs: { min: "min", max: "max", step: "step", disabled: "disabled", value: "value", part: "part" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 13, consts: [["role", "presentation", "tabindex", "-1", 1, "k-time-container", 3, "skip", "take", "total", "itemHeight", "maxScrollDifference", "topOffset", "bottomOffset"], [1, "k-reset", 3, "ngStyle", "kendoEventsOutsideAngular", "scope"], ["class", "k-item", 4, "ngFor", "ngForOf"], [1, "k-item"]], template: function TimeListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-virtualization", 0)(1, "ul", 1);
        ɵngcc0.ɵɵtemplate(2, TimeListComponent_li_2_Template, 3, 2, "li", 2);
        ɵngcc0.ɵɵelementEnd()();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("skip", ctx.skip)("take", ctx.total)("total", ctx.total)("itemHeight", ctx.itemHeight)("maxScrollDifference", ctx.listHeight)("topOffset", ctx.topOffset)("bottomOffset", ctx.bottomOffset);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.style)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(11, _c2, ctx.handleItemClick))("scope", ctx);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data);
    } }, directives: [VirtualizationComponent, ɵngcc2.NgStyle, ɵngcc4.EventsOutsideAngularDirective, ɵngcc2.NgForOf], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Date)
], TimeListComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], TimeListComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TimeListComponent.prototype, "part", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TimeListComponent.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimeListComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], TimeListComponent.prototype, "value", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TimeListComponent.prototype, "valueChange", void 0);
__decorate([
    ViewChild(VirtualizationComponent, { static: true }),
    __metadata("design:type", VirtualizationComponent)
], TimeListComponent.prototype, "virtualization", void 0);
__decorate([
    HostBinding("attr.tabindex"),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], TimeListComponent.prototype, "tabIndex", null);
__decorate([
    HostBinding("class.k-time-list"),
    __metadata("design:type", Boolean)
], TimeListComponent.prototype, "componentClass", void 0);
TimeListComponent = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Injector,
        TimePickerDOMService,
        Renderer2,
        NgZone])
], TimeListComponent);

const isEqualTillMinute = (value, min) => value.getHours() === min.getHours() && value.getMinutes() === min.getMinutes();
const isEqualTillSecond = (value, min) => isEqualTillMinute(value, min) && value.getSeconds() === min.getSeconds();
const isEqualTillMillisecond = (value, min) => isEqualTillSecond(value, min) && value.getMilliseconds() === min.getMilliseconds();
const ɵ3$7 = (value) => value.getHours(), ɵ4$3 = (_, min) => min.getHours(), ɵ5$1 = (value) => value.getMinutes(), ɵ6$1 = (value, min) => isEqualTillMinute(value, min) ? min.getMinutes() : 0, ɵ7$1 = (value) => value.getSeconds(), ɵ8$1 = (value, min) => isEqualTillSecond(value, min) ? min.getSeconds() : 0, ɵ9$1 = (value) => value.getMilliseconds(), ɵ10$1 = (value, min) => isEqualTillMillisecond(value, min) ? min.getMilliseconds() : 0;
const defaultGetters = [
    {
        type: TIME_PART.hour,
        getter: ɵ3$7,
        minGetter: ɵ4$3
    }, {
        type: TIME_PART.minute,
        getter: ɵ5$1,
        minGetter: ɵ6$1
    }, {
        type: TIME_PART.second,
        getter: ɵ7$1,
        minGetter: ɵ8$1
    }, {
        type: TIME_PART.millisecond,
        getter: ɵ9$1,
        minGetter: ɵ10$1
    }
];
const left = getter => (origin, _) => getter(origin);
const right = getter => (_, candidate) => getter(candidate);
const convertToObject = (parts) => parts.reduce((obj, p) => { obj[p.type] = p.type; return obj; }, {});
const getterByPart = parts => g => parts[g.type] ? right(g.getter) : left(g.getter);
const gettersFactory = getters => parts => (getters.map(getterByPart(convertToObject(parts))));
const snapValue = (getter, minGetter, step) => (date, min) => {
    const value = getter(date);
    const minValue = minGetter(date, min);
    const rest = value - minValue;
    if (rest < 0) {
        return minValue;
    }
    const mod = rest % step;
    return value - mod + (mod > step / 2 ? step : 0);
};
const snappersFactory = (getters) => steps => (getters.map(g => {
    const step = steps[g.type];
    return step ? snapValue(g.getter, g.minGetter, step) : g.getter;
}));
/**
 * @hidden
 */
const generateGetters = gettersFactory(defaultGetters);
/**
 * @hidden
 */
const generateSnappers = snappersFactory(defaultGetters);
/**
 * @hidden
 */
const valueMerger = getters => (origin, candidate) => {
    origin.setHours(...getters.map(g => g(origin, candidate)));
    return origin;
};
/**
 * @hidden
 */
const snapTime = snappers => (candidate, min) => {
    const date = cloneDate(candidate);
    date.setHours(...snappers.map(s => s(date, min)));
    return date;
};

const listReducer = (state, list, idx, all) => {
    if (state.length || !list.isActive) {
        return state;
    }
    return [{
            next: all[idx + 1] || list,
            prev: all[idx - 1] || list
        }];
};
var Direction;
(function (Direction) {
    Direction[Direction["Left"] = 0] = "Left";
    Direction[Direction["Right"] = 1] = "Right";
})(Direction || (Direction = {}));
/**
 * @hidden
 *
 * Represents the Kendo UI TimeSelector component for Angular.
 */
let TimeSelectorComponent = class TimeSelectorComponent {
    constructor(localization, cdr, element, intl, dom, zone, renderer, pickerService) {
        this.localization = localization;
        this.cdr = cdr;
        this.element = element;
        this.intl = intl;
        this.dom = dom;
        this.zone = zone;
        this.renderer = renderer;
        this.pickerService = pickerService;
        /**
         * Specifies the time format used to display the time list columns.
         */
        this.format = 't';
        /**
         * Specifies the smallest valid time value.
         */
        this.min = cloneDate(MIN_TIME);
        /**
         * Specifies the biggest valid time value.
         */
        this.max = cloneDate(MAX_TIME);
        /**
         * Determines whether to display the **Cancel** button in the popup.
         */
        this.cancelButton = true;
        /**
         * Determines whether to display the **Set** button in the popup.
         */
        this.setButton = true;
        /**
         * Determines whether to display the **Now** button in the popup.
         *
         * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.
         */
        this.nowButton = true;
        /**
         * Sets or gets the `disabled` property of the TimeSelector and determines whether the component is active.
         */
        this.disabled = false;
        /**
         * Specifies the value of the TimeSelector component.
         */
        this.value = null;
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user cancels the selected value.
         */
        this.valueReject = new EventEmitter();
        this.isActive = false;
        this.showNowButton = true;
        this._activeListIndex = -1;
        this._steps = {};
        this.domEvents = [];
        if (this.pickerService) {
            this.pickerService.timeSelector = this;
        }
    }
    /**
     * @hidden
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * Configures the incremental steps of the TimeSelector.
     *
     * The available options are:
     * - `hour: Number`&mdash;Controls the incremental step of the hour value.
     * - `minute: Number`&mdash;Controls the incremental step of the minute value.
     * - `second: Number`&mdash;Controls the incremental step of the second value.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-timeselector format="HH:mm:ss" [steps]="steps"></kendo-timeselector>
     * `
     * })
     * export class AppComponent {
     *   public steps = { hour: 2, minute: 15, second: 15 };
     * }
     * ```
     *
     * > If the incremental step is greater than `1`, the **Now** button will be hidden.
     */
    set steps(steps) {
        this._steps = steps || {};
    }
    get steps() {
        return this._steps;
    }
    set current(value) {
        this._current = timeInRange(this.snapTime(cloneDate(value || MIDNIGHT_DATE), this.min), this.min, this.max);
        if (!NgZone.isInAngularZone()) {
            this.cdr.detectChanges();
        }
    }
    get current() {
        return this._current;
    }
    get activeListIndex() {
        return this._activeListIndex;
    }
    set activeListIndex(value) {
        this._activeListIndex = value;
        if (!this.timeListWrappers || !this.timeListWrappers.length) {
            return;
        }
        this.timeListWrappers.forEach(listWrapper => {
            this.renderer.removeClass(listWrapper.nativeElement, 'k-state-focused');
        });
        if (value >= 0) {
            const listIndex = this.listIndex(value);
            const focusedWrapper = this.timeListWrappers.toArray()[listIndex];
            if (focusedWrapper) {
                this.renderer.addClass(focusedWrapper.nativeElement, 'k-state-focused');
            }
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));
        if (this.localization) {
            this.subscriptions.add(this.localization
                .changes
                .subscribe(() => this.cdr.markForCheck()));
        }
        this.renderer.addClass(this.element.nativeElement, 'k-timeselector');
        this.dom.calculateHeights(this.element.nativeElement);
        this.init();
        this.bindEvents();
    }
    /**
     * @hidden
     */
    ngOnChanges(_) {
        this.init();
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        if (this.pickerService) {
            this.pickerService.timeSelector = null;
        }
        this.domEvents.forEach(unbindCallback => unbindCallback());
    }
    /**
     * Focuses the TimeSelector component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="timeselector.focus()">Focus time picker</button>
     *  <kendo-timeselector #timeselector></kendo-timeselector>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    focus() {
        const list = this.timeLists.first;
        if (!list) {
            return;
        }
        list.focus();
    }
    /**
     * Blurs the TimeSelector component.
     */
    blur() {
        const list = this.timeLists.first;
        if (!list) {
            return;
        }
        list.blur();
    }
    /**
     * @hidden
     */
    handleAccept() {
        this.handleChange(this.mergeValue(cloneDate(this.value || getDate(getNow())), this.current));
    }
    /**
     * @hidden
     */
    handleNow() {
        this.current = getNow();
        this.handleChange(this.current);
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    handleReject() {
        this.current = this.value;
        this.valueReject.emit();
    }
    /**
     * @hidden
     */
    handleFocus(args) {
        if (this.isActive) {
            return;
        }
        this.isActive = true;
        this.emitFocus(args);
    }
    /**
     * @hidden
     */
    handleListFocus(args) {
        const index = parseInt(args.target.getAttribute('data-timelist-index'), 10);
        this.activeListIndex = index;
        this.handleFocus(args);
    }
    /**
     * @hidden
     */
    handleBlur(args) {
        const currentTarget = currentFocusTarget(args);
        if (currentTarget && this.containsElement(currentTarget)) {
            return;
        }
        this.activeListIndex = -1;
        this.isActive = false;
        this.emitBlur(args);
    }
    /**
     * @hidden
     */
    containsElement(element) {
        return Boolean(closest(element, node => node === this.element.nativeElement));
    }
    partStep(part) {
        return this.steps[part.type] || 1;
    }
    init(changes) {
        if (!changes || hasChange(changes, 'format')) {
            this.dateFormatParts = this.intl.splitDateFormat(this.format);
            this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));
        }
        if (!changes || hasChange(changes, 'steps')) {
            this.snapTime = snapTime(generateSnappers(this.steps));
        }
        if (!changes || hasChange(changes, 'value')) {
            this.current = this.value;
        }
        this.showNowButton = !this.hasSteps() && this.nowButton && isInTimeRange(getNow(), this.min, this.max);
    }
    focusList(dir) {
        if (!this.timeLists.length) {
            return;
        }
        this.timeLists.reduce(listReducer, [])
            .map(state => dir === Direction.Right ? state.next : state.prev)
            .map(list => list && list.focus());
    }
    handleChange(value) {
        this.value = value;
        this.valueChange.emit(cloneDate(value));
    }
    hasActiveButton() {
        if (!this.accept) {
            return false;
        }
        return [this.accept, this.cancel, this.now].reduce((isActive, el) => isActive || this.dom.isActive(el), false);
    }
    hasSteps() {
        const keys = Object.keys(this.steps);
        return keys.length !== keys.reduce((acc, k) => acc + this.steps[k], 0);
    }
    intlChange() {
        this.dateFormatParts = this.intl.splitDateFormat(this.format);
        this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));
        this.cdr.markForCheck();
    }
    bindEvents() {
        if (this.element) {
            this.zone.runOutsideAngular(() => {
                this.domEvents.push(this.renderer.listen(this.element.nativeElement, 'keydown', this.handleKeydown.bind(this)));
            });
        }
    }
    handleKeydown(args) {
        const { keyCode, altKey } = args;
        // reserve the alt + arrow key commands for the picker
        const arrowKeyPressed = [Keys.ArrowLeft, Keys.ArrowRight].indexOf(keyCode) !== -1;
        if (isPresent(this.pickerService) && arrowKeyPressed && altKey) {
            return;
        }
        if (keyCode === Keys.Enter && !this.hasActiveButton()) {
            this.handleAccept();
        }
        else if (keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight) {
            this.focusList(keyCode === Keys.ArrowLeft ? Direction.Left : Direction.Right);
        }
    }
    emitBlur(args) {
        if (this.pickerService) {
            this.pickerService.onBlur.emit(args);
        }
    }
    emitFocus(args) {
        if (this.pickerService) {
            this.pickerService.onFocus.emit(args);
        }
    }
    listIndex(partIndex) {
        let listIdx = 0;
        let partIdx = 0;
        while (partIdx < partIndex) {
            if (this.dateFormatParts[partIdx].type !== 'literal') {
                listIdx++;
            }
            partIdx++;
        }
        return listIdx;
    }
};
TimeSelectorComponent.ɵfac = function TimeSelectorComponent_Factory(t) { return new (t || TimeSelectorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(TimePickerDOMService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(PickerService, 8)); };
TimeSelectorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TimeSelectorComponent, selectors: [["kendo-timeselector"]], viewQuery: function TimeSelectorComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c93, 5);
        ɵngcc0.ɵɵviewQuery(_c94, 5);
        ɵngcc0.ɵɵviewQuery(_c95, 5);
        ɵngcc0.ɵɵviewQuery(TimeListComponent, 5);
        ɵngcc0.ɵɵviewQuery(_c96, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.accept = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cancel = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.now = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.timeLists = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.timeListWrappers = _t);
    } }, hostVars: 2, hostBindings: function TimeSelectorComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-disabled", ctx.disabledClass);
    } }, inputs: { format: "format", min: "min", max: "max", cancelButton: "cancelButton", setButton: "setButton", nowButton: "nowButton", disabled: "disabled", value: "value", steps: "steps" }, outputs: { valueChange: "valueChange", valueReject: "valueReject" }, exportAs: ["kendo-timeselector"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.timeselector'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 9, vars: 4, consts: function () { let i18n_97; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Accept button text in the timeselector component
         * @meaning kendo.timeselector.accept
         */
        const MSG_EXTERNAL_5362895271044573681$$DIST_FESM2015_INDEX_JS_98 = goog.getMsg("Set");
        i18n_97 = MSG_EXTERNAL_5362895271044573681$$DIST_FESM2015_INDEX_JS_98;
    }
    else {
        i18n_97 = $localize `:kendo.timeselector.accept|The Accept button text in the timeselector component␟801811aa1609e3f173c86baa82cee037f75a215f␟5362895271044573681:Set`;
    } let i18n_99; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Accept button in the timeselector component
         * @meaning kendo.timeselector.acceptLabel
         */
        const MSG_EXTERNAL_3417396278000787211$$DIST_FESM2015_INDEX_JS_100 = goog.getMsg("Set time");
        i18n_99 = MSG_EXTERNAL_3417396278000787211$$DIST_FESM2015_INDEX_JS_100;
    }
    else {
        i18n_99 = $localize `:kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component␟b4b1e5ac55f0330f6c4e32b866ae4339ad969978␟3417396278000787211:Set time`;
    } let i18n_101; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Cancel button text in the timeselector component
         * @meaning kendo.timeselector.cancel
         */
        const MSG_EXTERNAL_1890188482755567622$$DIST_FESM2015_INDEX_JS_102 = goog.getMsg("Cancel");
        i18n_101 = MSG_EXTERNAL_1890188482755567622$$DIST_FESM2015_INDEX_JS_102;
    }
    else {
        i18n_101 = $localize `:kendo.timeselector.cancel|The Cancel button text in the timeselector component␟3004d7704ffa6202a3b3925fcea490e486203a3e␟1890188482755567622:Cancel`;
    } let i18n_103; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Cancel button in the timeselector component
         * @meaning kendo.timeselector.cancelLabel
         */
        const MSG_EXTERNAL_5738120209397145846$$DIST_FESM2015_INDEX_JS_104 = goog.getMsg("Cancel changes");
        i18n_103 = MSG_EXTERNAL_5738120209397145846$$DIST_FESM2015_INDEX_JS_104;
    }
    else {
        i18n_103 = $localize `:kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component␟08dfbdfffd662371a6ff4c0b6ed82b9faa48143b␟5738120209397145846:Cancel changes`;
    } let i18n_105; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The Now button text in the timeselector component
         * @meaning kendo.timeselector.now
         */
        const MSG_EXTERNAL_1926162752852226109$$DIST_FESM2015_INDEX_JS_106 = goog.getMsg("Now");
        i18n_105 = MSG_EXTERNAL_1926162752852226109$$DIST_FESM2015_INDEX_JS_106;
    }
    else {
        i18n_105 = $localize `:kendo.timeselector.now|The Now button text in the timeselector component␟98cba1ae36a7bbe15e1bac1837e07922ec109e7d␟1926162752852226109:Now`;
    } let i18n_107; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        /**
         * @desc The label for the Now button in the timeselector component
         * @meaning kendo.timeselector.nowLabel
         */
        const MSG_EXTERNAL_7789175884909488647$$DIST_FESM2015_INDEX_JS_108 = goog.getMsg("Select now");
        i18n_107 = MSG_EXTERNAL_7789175884909488647$$DIST_FESM2015_INDEX_JS_108;
    }
    else {
        i18n_107 = $localize `:kendo.timeselector.nowLabel|The label for the Now button in the timeselector component␟08e6a8a51d970609e138950fdd89c5cf201869f3␟7789175884909488647:Select now`;
    } return [["kendoTimeSelectorLocalizedMessages", "", "accept", i18n_97, "acceptLabel", i18n_99, "cancel", i18n_101, "cancelLabel", i18n_103, "now", i18n_105, "nowLabel", i18n_107], [1, "k-time-header"], [1, "k-title", "k-timeselector-title"], ["type", "button", "class", "k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-time-now", 3, "kendoEventsOutsideAngular", "scope", "disabled", 4, "ngIf"], [1, "k-time-list-container"], [1, "k-time-highlight"], ["ngFor", "", 3, "ngForOf"], ["class", "k-time-footer k-action-buttons k-actions k-hstack k-justify-content-stretch", 4, "ngIf"], ["type", "button", 1, "k-button", "k-button-md", "k-rounded-md", "k-button-flat", "k-button-flat-base", "k-time-now", 3, "kendoEventsOutsideAngular", "scope", "disabled"], ["now", ""], ["class", "k-time-list-wrapper", "role", "presentation", "tabindex", "-1", 4, "ngIf"], ["class", "k-time-separator", 4, "ngIf"], ["role", "presentation", "tabindex", "-1", 1, "k-time-list-wrapper"], ["listWrapper", ""], [3, "min", "max", "part", "step", "disabled", "value", "kendoEventsOutsideAngular", "scope", "valueChange"], [1, "k-time-separator"], [1, "k-time-footer", "k-action-buttons", "k-actions", "k-hstack", "k-justify-content-stretch"], ["class", "k-button k-time-cancel k-button-md k-rounded-md k-button-solid k-button-solid-base", "type", "button", 3, "kendoEventsOutsideAngular", "scope", "disabled", 4, "ngIf"], ["type", "button", "class", "k-button k-time-accept k-button-md k-rounded-md k-button-solid k-button-solid-primary", 3, "kendoEventsOutsideAngular", "scope", "disabled", 4, "ngIf"], ["type", "button", 1, "k-button", "k-time-cancel", "k-button-md", "k-rounded-md", "k-button-solid", "k-button-solid-base", 3, "kendoEventsOutsideAngular", "scope", "disabled"], ["cancel", ""], ["type", "button", 1, "k-button", "k-time-accept", "k-button-md", "k-rounded-md", "k-button-solid", "k-button-solid-primary", 3, "kendoEventsOutsideAngular", "scope", "disabled"], ["accept", ""]]; }, template: function TimeSelectorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1)(2, "span", 2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, TimeSelectorComponent_button_4_Template, 3, 10, "button", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelement(6, "span", 5);
        ɵngcc0.ɵɵtemplate(7, TimeSelectorComponent_ng_template_7_Template, 2, 2, "ng-template", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, TimeSelectorComponent_div_8_Template, 3, 2, "div", 7);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.intl.formatDate(ctx.current, ctx.format), " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showNowButton);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.dateFormatParts);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.setButton || ctx.cancelButton);
    } }, directives: function () { return [TimeSelectorLocalizedMessagesDirective, ɵngcc2.NgIf, ɵngcc4.EventsOutsideAngularDirective, ɵngcc2.NgForOf, TimeListComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    ViewChild('accept', { static: false }),
    __metadata("design:type", ElementRef)
], TimeSelectorComponent.prototype, "accept", void 0);
__decorate([
    ViewChild('cancel', { static: false }),
    __metadata("design:type", ElementRef)
], TimeSelectorComponent.prototype, "cancel", void 0);
__decorate([
    ViewChild('now', { static: false }),
    __metadata("design:type", ElementRef)
], TimeSelectorComponent.prototype, "now", void 0);
__decorate([
    ViewChildren(TimeListComponent),
    __metadata("design:type", QueryList)
], TimeSelectorComponent.prototype, "timeLists", void 0);
__decorate([
    ViewChildren('listWrapper'),
    __metadata("design:type", QueryList)
], TimeSelectorComponent.prototype, "timeListWrappers", void 0);
__decorate([
    HostBinding('class.k-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TimeSelectorComponent.prototype, "disabledClass", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], TimeSelectorComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], TimeSelectorComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], TimeSelectorComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimeSelectorComponent.prototype, "cancelButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimeSelectorComponent.prototype, "setButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimeSelectorComponent.prototype, "nowButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TimeSelectorComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], TimeSelectorComponent.prototype, "steps", null);
__decorate([
    Input(),
    __metadata("design:type", Date)
], TimeSelectorComponent.prototype, "value", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TimeSelectorComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TimeSelectorComponent.prototype, "valueReject", void 0);
TimeSelectorComponent = __decorate([ __param(7, Optional()),
    __metadata("design:paramtypes", [LocalizationService,
        ChangeDetectorRef,
        ElementRef,
        IntlService,
        TimePickerDOMService,
        NgZone,
        Renderer2,
        PickerService])
], TimeSelectorComponent);

/**
 * @hidden
 */
class TimePickerMessages extends ComponentMessages {
}
TimePickerMessages.ɵfac = /*@__PURE__*/ function () { let ɵTimePickerMessages_BaseFactory; return function TimePickerMessages_Factory(t) { return (ɵTimePickerMessages_BaseFactory || (ɵTimePickerMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TimePickerMessages)))(t || TimePickerMessages); }; }();
TimePickerMessages.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TimePickerMessages, inputs: { accept: "accept", acceptLabel: "acceptLabel", cancel: "cancel", cancelLabel: "cancelLabel", now: "now", nowLabel: "nowLabel", toggle: "toggle" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], TimePickerMessages.prototype, "accept", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TimePickerMessages.prototype, "acceptLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TimePickerMessages.prototype, "cancel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TimePickerMessages.prototype, "cancelLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TimePickerMessages.prototype, "now", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TimePickerMessages.prototype, "nowLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TimePickerMessages.prototype, "toggle", void 0);

var TimePickerLocalizedMessagesDirective_1;
/**
 * @hidden
 */
let TimePickerLocalizedMessagesDirective = TimePickerLocalizedMessagesDirective_1 = class TimePickerLocalizedMessagesDirective extends TimePickerMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
TimePickerLocalizedMessagesDirective.ɵfac = function TimePickerLocalizedMessagesDirective_Factory(t) { return new (t || TimePickerLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
TimePickerLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TimePickerLocalizedMessagesDirective, selectors: [["", "kendoTimePickerLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TimePickerMessages,
                useExisting: forwardRef(() => TimePickerLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
TimePickerLocalizedMessagesDirective = TimePickerLocalizedMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], TimePickerLocalizedMessagesDirective);

var TimePickerCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).
 */
let TimePickerCustomMessagesComponent = TimePickerCustomMessagesComponent_1 = class TimePickerCustomMessagesComponent extends TimePickerMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
TimePickerCustomMessagesComponent.ɵfac = function TimePickerCustomMessagesComponent_Factory(t) { return new (t || TimePickerCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
TimePickerCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TimePickerCustomMessagesComponent, selectors: [["kendo-timepicker-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TimePickerMessages,
                useExisting: forwardRef(() => TimePickerCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function TimePickerCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
TimePickerCustomMessagesComponent = TimePickerCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], TimePickerCustomMessagesComponent);

var TimeSelectorLocalizedMessagesDirective_1;
/**
 * @hidden
 */
let TimeSelectorLocalizedMessagesDirective = TimeSelectorLocalizedMessagesDirective_1 = class TimeSelectorLocalizedMessagesDirective extends TimePickerMessages {
    constructor(service) {
        super();
        this.service = service;
    }
};
TimeSelectorLocalizedMessagesDirective.ɵfac = function TimeSelectorLocalizedMessagesDirective_Factory(t) { return new (t || TimeSelectorLocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
TimeSelectorLocalizedMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TimeSelectorLocalizedMessagesDirective, selectors: [["", "kendoTimeSelectorLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TimePickerMessages,
                useExisting: forwardRef(() => TimeSelectorLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
TimeSelectorLocalizedMessagesDirective = TimeSelectorLocalizedMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], TimeSelectorLocalizedMessagesDirective);

var TimeSelectorCustomMessagesComponent_1;
/**
 * @hidden
 *
 * Custom component messages override default component messages.
 */
let TimeSelectorCustomMessagesComponent = TimeSelectorCustomMessagesComponent_1 = class TimeSelectorCustomMessagesComponent extends TimePickerMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
TimeSelectorCustomMessagesComponent.ɵfac = function TimeSelectorCustomMessagesComponent_Factory(t) { return new (t || TimeSelectorCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
TimeSelectorCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TimeSelectorCustomMessagesComponent, selectors: [["kendo-timeselector-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TimePickerMessages,
                useExisting: forwardRef(() => TimeSelectorCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function TimeSelectorCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
TimeSelectorCustomMessagesComponent = TimeSelectorCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], TimeSelectorCustomMessagesComponent);

const COMPONENT_DIRECTIVES$2 = [
    TimePickerLocalizedMessagesDirective,
    TimeListComponent,
    TimePickerCustomMessagesComponent,
    TimePickerComponent,
    TimeSelectorLocalizedMessagesDirective,
    TimeSelectorCustomMessagesComponent,
    TimeSelectorComponent
];
const COMPONENT_MODULES$1 = [
    DateInputModule,
    IntlModule,
    PopupModule,
    VirtualizationModule,
    EventsModule
];
const ɵ0$o = touchEnabled;
const providers = [
    TimePickerDOMService,
    HoursService,
    MinutesService,
    SecondsService,
    MillisecondsService,
    DayPeriodService,
    {
        provide: TOUCH_ENABLED,
        useValue: ɵ0$o
    }
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TimePicker component.
 */
let TimePickerModule = class TimePickerModule {
};
TimePickerModule.ɵfac = function TimePickerModule_Factory(t) { return new (t || TimePickerModule)(); };
TimePickerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: TimePickerModule });
TimePickerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: providers, imports: [[CommonModule, ...COMPONENT_MODULES$1]] });

/**
 * @hidden
 */
class Messages$1 extends ComponentMessages {
}
Messages$1.ɵfac = /*@__PURE__*/ function () { let ɵMessages$1_BaseFactory; return function Messages$1_Factory(t) { return (ɵMessages$1_BaseFactory || (ɵMessages$1_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages$1)))(t || Messages$1); }; }();
Messages$1.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: Messages$1, inputs: { toggle: "toggle", dateTab: "dateTab", dateTabLabel: "dateTabLabel", timeTab: "timeTab", timeTabLabel: "timeTabLabel", accept: "accept", acceptLabel: "acceptLabel", cancel: "cancel", cancelLabel: "cancelLabel", today: "today", now: "now", nowLabel: "nowLabel", prevButtonTitle: "prevButtonTitle", nextButtonTitle: "nextButtonTitle" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "toggle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "dateTab", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "dateTabLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "timeTab", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "timeTabLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "accept", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "acceptLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "cancel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "cancelLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "today", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "now", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "nowLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "prevButtonTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages$1.prototype, "nextButtonTitle", void 0);

var DateTimePickerCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).
 */
let DateTimePickerCustomMessagesComponent = DateTimePickerCustomMessagesComponent_1 = class DateTimePickerCustomMessagesComponent extends Messages$1 {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
};
DateTimePickerCustomMessagesComponent.ɵfac = function DateTimePickerCustomMessagesComponent_Factory(t) { return new (t || DateTimePickerCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
DateTimePickerCustomMessagesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DateTimePickerCustomMessagesComponent, selectors: [["kendo-datetimepicker-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages$1,
                useExisting: forwardRef(() => DateTimePickerCustomMessagesComponent_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function DateTimePickerCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
DateTimePickerCustomMessagesComponent = DateTimePickerCustomMessagesComponent_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], DateTimePickerCustomMessagesComponent);

var LocalizedMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedMessagesDirective = LocalizedMessagesDirective_1 = class LocalizedMessagesDirective extends Messages$1 {
    constructor(service) {
        super();
        this.service = service;
    }
};
LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) { return new (t || LocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.LocalizationService)); };
LocalizedMessagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LocalizedMessagesDirective, selectors: [["", "kendoDateTimePickerLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages$1,
                useExisting: forwardRef(() => LocalizedMessagesDirective_1)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
LocalizedMessagesDirective = LocalizedMessagesDirective_1 = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], LocalizedMessagesDirective);

const COMPONENT_DIRECTIVES$3 = [
    DateTimePickerComponent,
    DateTimePickerCustomMessagesComponent,
    LocalizedMessagesDirective
];
const ɵ0$p = touchEnabled;
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the DateTimePicker component.
 */
let DateTimePickerModule = class DateTimePickerModule {
};
DateTimePickerModule.ɵfac = function DateTimePickerModule_Factory(t) { return new (t || DateTimePickerModule)(); };
DateTimePickerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DateTimePickerModule });
DateTimePickerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        { provide: TOUCH_ENABLED, useValue: ɵ0$p }
    ], imports: [[
            CommonModule,
            IntlModule,
            DateInputModule,
            CalendarModule,
            TimePickerModule,
            PopupModule,
            EventsModule,
            TemplatesModule
        ], TemplatesModule] });

const COMPONENT_MODULES$2 = [
    CalendarsModule,
    DateInputModule,
    DatePickerModule,
    TimePickerModule,
    DateRangeModule,
    DateTimePickerModule
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Date Inputs components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Date Inputs module
 * import { DateInputsModule } from '@progress/kendo-angular-dateinputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare the app component
 *     imports:      [BrowserModule, DateInputsModule], // import the Date Inputs module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let DateInputsModule = class DateInputsModule {
};
DateInputsModule.ɵfac = function DateInputsModule_Factory(t) { return new (t || DateInputsModule)(); };
DateInputsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DateInputsModule });
DateInputsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [COMPONENT_MODULES$2, CalendarsModule, DateInputModule, DatePickerModule, TimePickerModule, DateRangeModule, DateTimePickerModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CenturyViewService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DecadeViewService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MonthViewService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.IntlService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YearViewService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.IntlService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BusViewService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.Injector }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WeekNamesService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.IntlService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HorizontalViewListComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-calendar-horizontal',
                template: `
        <ng-template #tableTemplate let-date="date" let-class="className">
            <table
                role="grid"
                class="k-content k-calendar-content k-calendar-table"
                [ngClass]="class"
            >
                <caption *ngIf="showViewHeader" [ngClass]="getCaptionClass()">{{ getCaptionTitle(date) }}</caption>
                <thead *ngIf="isMonthView()" class="k-calendar-thead">
                    <tr class="k-calendar-tr" role="row">
                        <th *ngFor="let name of weekNames" class="k-calendar-th">{{name}}</th>
                    </tr>
                </thead>
                <tbody
                    class="k-calendar-tbody"
                    kendoCalendarView
                    role="rowgroup"
                    direction="horizontal"
                    [activeView]="activeView"
                    [isActive]="isActive"
                    [min]="min"
                    [max]="max"
                    [cellUID]="cellUID"
                    [focusedDate]="focusedDate"
                    [selectedDates]="selectedDates"
                    [selectionRange]="selectionRange"
                    [activeRangeEnd]="activeRangeEnd"
                    [weekNumber]="weekNumber"
                    [templateRef]="cellTemplateRef"
                    [weekNumberTemplateRef]="weekNumberTemplateRef"
                    [viewDate]="date"
                    (cellClick)="cellClick.emit($event)"
                    (weekNumberCellClick)="weekNumberCellClick.emit($event)"
                    (cellEnter)="cellEnter.emit($event)"
                    (cellLeave)="cellLeave.emit($event)"
                >
                </tbody>
            </table>
        </ng-template>

        <!-- When Next is clicked a placeholder table is rendered before the Main Table -->
        <ng-template
            *ngIf="nextAnimationDate"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: nextAnimationDate,
                className: 'k-pointer-events-none'
            }"
        >
        </ng-template>

        <ng-template
            *kFor="let date of dates"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: date
            }"
        >
        </ng-template>

        <!-- When Prev is clicked a placeholder table is rendered after the Main Table -->
        <ng-template
            *ngIf="prevAnimationDate"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: prevAnimationDate,
                className: 'k-pointer-events-none'
            }"
        >
        </ng-template>
    `
            }]
    }], function () { return [{ type: BusViewService }, { type: ɵngcc1.IntlService }, { type: WeekNamesService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { activeView: [{
            type: Input
        }], isActive: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], selectedDates: [{
            type: Input
        }], views: [{
            type: Input
        }], showViewHeader: [{
            type: Input
        }], animateNavigation: [{
            type: Input
        }], cellClick: [{
            type: Output
        }], weekNumberCellClick: [{
            type: Output
        }], cellEnter: [{
            type: Output
        }], cellLeave: [{
            type: Output
        }], activeDateChange: [{
            type: Output
        }], getComponentClass: [{
            type: HostBinding,
            args: ["class.k-calendar-view"]
        }, {
            type: HostBinding,
            args: ["class.k-hstack"]
        }, {
            type: HostBinding,
            args: ["class.k-align-items-start"]
        }, {
            type: HostBinding,
            args: ["class.k-justify-content-center"]
        }], weekNumber: [{
            type: Input
        }], getComponentMonthClass: [{
            type: HostBinding,
            args: ["class.k-calendar-monthview"]
        }], getComponentYearClass: [{
            type: HostBinding,
            args: ["class.k-calendar-yearview"]
        }], getComponentDecadeClass: [{
            type: HostBinding,
            args: ["class.k-calendar-decadeview"]
        }], getComponentCenturyClass: [{
            type: HostBinding,
            args: ["class.k-calendar-centuryview"]
        }], focusedDate: [{
            type: Input
        }], cellTemplateRef: [{
            type: Input
        }], weekNumberTemplateRef: [{
            type: Input
        }], activeRangeEnd: [{
            type: Input
        }], cellUID: [{
            type: Input
        }], selectionRange: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DisabledDatesService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeaderComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-calendar-header',
                template: `
    <span class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-calendar-title" [class.k-disabled]="!navigate"
        [kendoEventsOutsideAngular]="{
            click: handleNavigation
        }"
        [scope]="this">
        <ng-template [ngIf]="!templateRef">{{title}}</ng-template>
        <ng-template
            [ngIf]="templateRef"
            [ngTemplateOutlet]="templateRef"
            [ngTemplateOutletContext]="{ $implicit: title, activeView: activeViewValue, date: currentDate }"
        ></ng-template>
    </span>
    <span class="k-spacer"></span>
    <span class="k-calendar-nav k-hstack">
        <button
            *ngIf="showNavigationButtons"
            class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-icon-button k-prev-view"
            type="button"
            [attr.aria-disabled]="isPrevDisabled"
            [disabled]="isPrevDisabled"
            [title]="prevButtonTitle"
            (click)="prevButtonClick.emit()"
        >
            <span class="k-icon k-i-arrow-60-left"></span>
        </button>
        <span
            class="k-today k-nav-today"
            [class.k-disabled]="!todayAvailable"
            [kendoEventsOutsideAngular]="{
                click: handleTodayClick
            }"
            [scope]="this"
        >
            {{ todayMessage }}
        </span>
        <button
            *ngIf="showNavigationButtons"
            class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-icon-button k-next-view"
            type="button"
            [attr.aria-disabled]="isNextDisabled"
            [disabled]="isNextDisabled"
            [title]="nextButtonTitle"
            (click)="nextButtonClick.emit()"
        >
            <span class="k-icon k-i-arrow-60-right"></span>
        </button>
    </span>
  `
            }]
    }], function () { return [{ type: BusViewService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc3.LocalizationService }, { type: ɵngcc1.IntlService }, { type: DisabledDatesService }]; }, { min: [{
            type: Input
        }], max: [{
            type: Input
        }], rangeLength: [{
            type: Input
        }], isPrevDisabled: [{
            type: Input
        }], isNextDisabled: [{
            type: Input
        }], showNavigationButtons: [{
            type: Input
        }], todayButtonClick: [{
            type: Output
        }], prevButtonClick: [{
            type: Output
        }], nextButtonClick: [{
            type: Output
        }], getComponentClass: [{
            type: HostBinding,
            args: ["class.k-calendar-header"]
        }, {
            type: HostBinding,
            args: ["class.k-hstack"]
        }], activeView: [{
            type: Input
        }], currentDate: [{
            type: Input
        }], templateRef: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigationService, [{
        type: Injectable
    }], function () { return [{ type: BusViewService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SelectionService, [{
        type: Injectable
    }], function () { return [{ type: BusViewService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCalendarCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MonthCellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCalendarMonthCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YearCellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCalendarYearCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DecadeCellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCalendarDecadeCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CenturyCellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCalendarCenturyCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WeekNumberCellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCalendarWeekNumberCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeaderTitleTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCalendarHeaderTitleTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MultiViewCalendarComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendo-multiviewcalendar',
                providers: [
                    BusViewService,
                    RANGE_CALENDAR_VALUE_ACCESSOR,
                    RANGE_CALENDAR_RANGE_VALIDATORS,
                    LocalizationService,
                    DisabledDatesService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.multiviewcalendar'
                    },
                    NavigationService,
                    SelectionService
                ],
                selector: 'kendo-multiviewcalendar',
                template: `
    <ng-container kendoMultiViewCalendarLocalizedMessages
        i18n-today="kendo.multiviewcalendar.today|The label for the today button in the calendar header"
        today="Today"

        i18n-prevButtonTitle="kendo.multiviewcalendar.prevButtonTitle|The label for the previous button in the Multiview calendar"
        prevButtonTitle="Navigate to previous view"

        i18n-nextButtonTitle="kendo.multiviewcalendar.nextButtonTitle|The label for the next button in the Multiview calendar"
        nextButtonTitle="Navigate to next view"
    >
    </ng-container>
    <kendo-calendar-header
        [activeView]="activeViewEnum"
        [currentDate]="activeDate"
        [min]="min"
        [max]="max"
        [rangeLength]="views"
        [templateRef]="headerTitleTemplateRef?.templateRef"
        [isPrevDisabled]="isPrevDisabled"
        [isNextDisabled]="isNextDisabled"
        [showNavigationButtons]="true"
        (todayButtonClick)="handleTodayButtonClick({ selectedDates: [$event], focusedDate: $event })"
        (prevButtonClick)="navigateView(prevView)"
        (nextButtonClick)="navigateView(nextView)"
        [kendoEventsOutsideAngular]="{
            focusin: handleHeaderFocus
        }"
        [scope]="this"
    >
    </kendo-calendar-header>
    <kendo-calendar-horizontal
        [activeView]="activeViewEnum"
        [isActive]="isActive || (isHovered && !isHeaderActive)"
        [cellTemplateRef]="activeCellTemplate()?.templateRef"
        [weekNumberTemplateRef]="weekNumberTemplateRef?.templateRef"
        [cellUID]="cellUID"
        [views]="views"
        [min]="min"
        [max]="max"
        [focusedDate]="focusedDate"
        [animateNavigation]="animateNavigation"
        [showViewHeader]="showViewHeader"
        [weekNumber]="weekNumber"
        [activeRangeEnd]="activeRangeEnd"
        [selectionRange]="selectionRange"
        [selectedDates]="selectedDates"
        (valueChange)="handleDateChange($event)"
        (cellClick)="handleCellClick($event)"
        (weekNumberCellClick)="handleWeekNumberClick($event)"
        (cellEnter)="emitCellEvent(cellEnter, $event)"
        (cellLeave)="emitCellEvent(cellLeave, $event)"
        (activeDateChange)="setActiveDate($event)"
    >
    </kendo-calendar-horizontal>
  `
            }]
    }], function () { return [{ type: BusViewService }, { type: ɵngcc0.ElementRef }, { type: NavigationService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: DisabledDatesService }, { type: SelectionService }, { type: PickerService, decorators: [{
                type: Optional
            }] }]; }, { id: [{
            type: Input
        }], rangeValidation: [{
            type: Input
        }], disabledDatesRangeValidation: [{
            type: Input
        }], selection: [{
            type: Input
        }], disabled: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], isActive: [{
            type: Input
        }], activeView: [{
            type: Input
        }], bottomView: [{
            type: Input
        }], topView: [{
            type: Input
        }], showViewHeader: [{
            type: Input
        }], animateNavigation: [{
            type: Input
        }], weekNumber: [{
            type: Input
        }], views: [{
            type: Input
        }], activeViewChange: [{
            type: Output
        }], navigate: [{
            type: Output
        }], cellEnter: [{
            type: Output
        }], cellLeave: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], blurEvent: [{
            type: Output,
            args: ['blur']
        }], focusedDate: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], value: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], disabledDates: [{
            type: Input
        }], selectionRange: [{
            type: Input
        }], cellTemplateRef: [{
            type: Input,
            args: ['cellTemplate']
        }], monthCellTemplateRef: [{
            type: Input,
            args: ['monthCellTemplate']
        }], yearCellTemplateRef: [{
            type: Input,
            args: ['yearCellTemplate']
        }], decadeCellTemplateRef: [{
            type: Input,
            args: ['decadeCellTemplate']
        }], centuryCellTemplateRef: [{
            type: Input,
            args: ['centuryCellTemplate']
        }], weekNumberTemplateRef: [{
            type: Input,
            args: ['weekNumberTemplate']
        }], headerTitleTemplateRef: [{
            type: Input,
            args: ['headerTitleTemplate']
        }], widgetId: [{
            type: HostBinding,
            args: ['attr.id']
        }], calendarTabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.k-disabled']
        }], ariaActivedescendant: [{
            type: HostBinding,
            args: ['attr.aria-activedescendant']
        }], 
    /**
     * @hidden
     */
    handleFocusout: [{
            type: HostListener,
            args: ['focusout', ['$event']]
        }], 
    /**
     * @hidden
     */
    handleFocus: [{
            type: HostListener,
            args: ["focus"]
        }], 
    /**
     * @hidden
     */
    handleMouseEnter: [{
            type: HostListener,
            args: ["mouseenter"]
        }], 
    /**
     * @hidden
     */
    handleMouseLeave: [{
            type: HostListener,
            args: ["mouseleave"]
        }], 
    /**
     * @hidden
     */
    handleMousedown: [{
            type: HostListener,
            args: ["mousedown", ['$event']]
        }], 
    /**
     * @hidden
     */
    handleClick: [{
            type: HostListener,
            args: ["click"]
        }], 
    /**
     * @hidden
     */
    keydown: [{
            type: HostListener,
            args: ["keydown", ["$event"]]
        }], activeRangeEnd: [{
            type: Input
        }], cellTemplate: [{
            type: ContentChild,
            args: [CellTemplateDirective, { static: false }]
        }], monthCellTemplate: [{
            type: ContentChild,
            args: [MonthCellTemplateDirective, { static: false }]
        }], yearCellTemplate: [{
            type: ContentChild,
            args: [YearCellTemplateDirective, { static: false }]
        }], decadeCellTemplate: [{
            type: ContentChild,
            args: [DecadeCellTemplateDirective, { static: false }]
        }], centuryCellTemplate: [{
            type: ContentChild,
            args: [CenturyCellTemplateDirective, { static: false }]
        }], weekNumberTemplate: [{
            type: ContentChild,
            args: [WeekNumberCellTemplateDirective, { static: false }]
        }], headerTitleTemplate: [{
            type: ContentChild,
            args: [HeaderTitleTemplateDirective, { static: false }]
        }], headerElement: [{
            type: ViewChild,
            args: [HeaderComponent, { static: false, read: ElementRef }]
        }], viewList: [{
            type: ViewChild,
            args: [HorizontalViewListComponent, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalendarDOMService, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(VirtualizationComponent, [{
        type: Component,
        args: [{
                providers: [{
                        provide: SCROLLER_FACTORY_TOKEN,
                        useValue: DEFAULT_SCROLLER_FACTORY
                    }],
                selector: 'kendo-virtualization',
                template: `
    <ng-content></ng-content>
    <div
        class="k-scrollable-placeholder"
        [class.k-scrollable-horizontal-placeholder]="direction === 'horizontal'"
        [ngStyle]="totalVertexLength"
    ></div>
  `
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [SCROLLER_FACTORY_TOKEN]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { direction: [{
            type: Input
        }], itemHeight: [{
            type: Input
        }], itemWidth: [{
            type: Input
        }], topOffset: [{
            type: Input
        }], bottomOffset: [{
            type: Input
        }], maxScrollDifference: [{
            type: Input
        }], scrollOffsetSize: [{
            type: Input
        }], scrollDuration: [{
            type: Input
        }], activeIndexChange: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], scrollChange: [{
            type: Output
        }], wrapperClasses: [{
            type: HostBinding,
            args: ['class.k-flex']
        }, {
            type: HostBinding,
            args: ['class.k-content']
        }, {
            type: HostBinding,
            args: ['class.k-calendar-content']
        }, {
            type: HostBinding,
            args: ['class.k-scrollable']
        }], horizontalClass: [{
            type: HostBinding,
            args: ['class.k-scrollable-horizontal']
        }], skip: [{
            type: Input
        }], take: [{
            type: Input
        }], total: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigationComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-calendar-navigation',
                template: `
    <span class="k-calendar-navigation-highlight"></span>
    <kendo-virtualization
        [skip]="skip"
        [take]="take"
        [total]="total"
        [itemHeight]="itemHeight"
        [topOffset]="topOffset"
        [bottomOffset]="bottomOffset"
        [maxScrollDifference]="maxViewHeight"
        (pageChange)="onPageChange($event)"
        (scrollChange)="scrollChange($event)"
    >
        <ul #list class="k-reset" [kendoEventsOutsideAngular]="{ click: handleDateChange }" [scope]="this">
            <li *kFor="let date of dates; let index=index" [attr.data-date-index]="index">
                <span [class.k-calendar-navigation-marker]="service.isRangeStart(date)">
                    <ng-template [ngIf]="!templateRef">{{service.navigationTitle(date)}}</ng-template>
                    <ng-template
                        [ngIf]="templateRef"
                        [ngTemplateOutlet]="templateRef"
                        [ngTemplateOutletContext]="{ $implicit: service.navigationTitle(date), activeView: activeViewValue, date: date }"
                    ></ng-template>
                </span>
            </li>
        </ul>
    </kendo-virtualization>
  `
            }]
    }], function () { return [{ type: BusViewService }, { type: CalendarDOMService }, { type: ɵngcc1.IntlService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }]; }, { min: [{
            type: Input
        }], max: [{
            type: Input
        }], focusedDate: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], getComponentClass: [{
            type: HostBinding,
            args: ["class.k-calendar-navigation"]
        }], activeView: [{
            type: Input
        }], templateRef: [{
            type: Input
        }], virtualization: [{
            type: ViewChild,
            args: [VirtualizationComponent, { static: false }]
        }], list: [{
            type: ViewChild,
            args: ['list', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ViewListComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-calendar-viewlist',
                template: `
    <kendo-calendar-header
        [currentDate]="activeDate"
        [min]="min"
        [max]="max"
        [activeView]="activeView"
        [templateRef]="headerTitleTemplateRef"
        (todayButtonClick)="todayButtonClick.emit($event)"
    >
    </kendo-calendar-header>
    <table class="k-calendar-weekdays k-calendar-table" style="table-layout: auto;" *ngIf="isMonthView()">
        <thead class="k-calendar-thead">
            <tr class="k-calendar-tr">
                <th class="k-calendar-th" *ngFor="let name of weekNames" [style.width.%]="colWidth">{{name}}</th>
            </tr>
        </thead>
    </table>
    <kendo-virtualization
        [tabindex]="-1"
        [skip]="skip"
        [take]="take"
        [total]="total"
        [itemHeight]="viewHeight"
        [topOffset]="viewOffset"
        [bottomOffset]="bottomOffset"
        [scrollOffsetSize]="viewOffset"
        [maxScrollDifference]="viewHeight"
        (pageChange)="onPageChange($event)"
        (scrollChange)="scrollChange($event)"
        (activeIndexChange)="setActiveDate($event)"
        >
        <table
            #list
            role="grid"
            class="k-calendar-table"
        >
            <colgroup><col *ngFor="let _ of cols" /></colgroup>

            <tbody class="k-calendar-tbody"
                   *kFor="let date of dates"
                   kendoCalendarView
                   role="rowgroup"
                   [activeView]="activeView"
                   [isActive]="isActive"
                   [min]="min" [max]="max"
                   [cellUID]="cellUID"
                   [focusedDate]="focusedDate"
                   [selectedDates]="selectedDates"
                   [weekNumber]="weekNumber"
                   [templateRef]="cellTemplateRef"
                   [weekNumberTemplateRef]="weekNumberTemplateRef"
                   [viewDate]="date"
                   (cellClick)="cellClick.emit($event)"
                   (weekNumberCellClick)="weekNumberCellClick.emit($event)"
            ></tbody>
        </table>
    </kendo-virtualization>
  `
            }]
    }], function () { return [{ type: BusViewService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.IntlService }, { type: CalendarDOMService }, { type: ɵngcc0.Renderer2 }]; }, { isActive: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], selectedDates: [{
            type: Input
        }], cellClick: [{
            type: Output
        }], weekNumberCellClick: [{
            type: Output
        }], activeDateChange: [{
            type: Output
        }], todayButtonClick: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], getComponentClass: [{
            type: HostBinding,
            args: ["class.k-vstack"]
        }, {
            type: HostBinding,
            args: ["class.k-calendar-view"]
        }], weekNumber: [{
            type: Input
        }], getComponentMonthClass: [{
            type: HostBinding,
            args: ["class.k-calendar-monthview"]
        }], getComponentYearClass: [{
            type: HostBinding,
            args: ["class.k-calendar-yearview"]
        }], getComponentDecadeClass: [{
            type: HostBinding,
            args: ["class.k-calendar-decadeview"]
        }], getComponentCenturyClass: [{
            type: HostBinding,
            args: ["class.k-calendar-centuryview"]
        }], cellTemplateRef: [{
            type: Input
        }], weekNumberTemplateRef: [{
            type: Input
        }], headerTitleTemplateRef: [{
            type: Input
        }], activeView: [{
            type: Input
        }], cellUID: [{
            type: Input
        }], focusedDate: [{
            type: Input
        }], virtualization: [{
            type: ViewChild,
            args: [VirtualizationComponent, { static: false }]
        }], list: [{
            type: ViewChild,
            args: ['list', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollSyncService, [{
        type: Injectable
    }], function () { return [{ type: CalendarDOMService }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigationItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCalendarNavigationItemTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalendarComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendo-calendar',
                providers: [
                    BusViewService,
                    CALENDAR_VALUE_ACCESSOR,
                    CALENDAR_RANGE_VALIDATORS,
                    KENDO_INPUT_PROVIDER,
                    LocalizationService,
                    DisabledDatesService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.calendar'
                    },
                    NavigationService,
                    ScrollSyncService,
                    SelectionService
                ],
                selector: 'kendo-calendar',
                template: `
    <ng-container kendoCalendarLocalizedMessages
        i18n-today="kendo.calendar.today|The label for the today button in the calendar header"
        today="Today"

        i18n-prevButtonTitle="kendo.calendar.prevButtonTitle|The title of the previous button in the Classic calendar"
        prevButtonTitle="Navigate to previous view"

        i18n-nextButtonTitle="kendo.calendar.nextButtonTitle|The title of the next button in the Classic calendar"
        nextButtonTitle="Navigate to next view"
    >
    </ng-container>
    <ng-container *ngIf="type === 'infinite'">
        <kendo-calendar-navigation
            *ngIf="navigation"
            [activeView]="activeViewEnum"
            [focusedDate]="focusedDate"
            [min]="min"
            [max]="max"
            [templateRef]="navigationItemTemplateRef?.templateRef"
            (valueChange)="handleNavigation($event)"
            (pageChange)="onPageChange()"
        >
        </kendo-calendar-navigation>
        <kendo-calendar-viewlist
            [activeView]="activeViewEnum"
            [isActive]="isActive"
            [cellTemplateRef]="activeCellTemplate()?.templateRef"
            [headerTitleTemplateRef]="headerTitleTemplateRef?.templateRef"
            [weekNumberTemplateRef]="weekNumberTemplateRef?.templateRef"
            [cellUID]="cellUID"
            [min]="min"
            [max]="max"
            [focusedDate]="focusedDate"
            [weekNumber]="weekNumber"
            [selectedDates]="selectedDates"
            (todayButtonClick)="handleDateChange({
                selectedDates: [$event],
                focusedDate: $event
            })"
            (cellClick)="handleCellClick($event)"
            (weekNumberCellClick)="handleWeekNumberClick($event)"
            (activeDateChange)="handleActiveDateChange($event)"
            (pageChange)="onPageChange()"
        >
        </kendo-calendar-viewlist>
        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
    </ng-container>
    <ng-container *ngIf="type === 'classic'">
        <kendo-multiviewcalendar
            #multiviewcalendar
            [views]="1"
            [min]="min"
            [max]="max"
            [isActive]="isActive"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [weekNumber]="weekNumber"
            [animateNavigation]="animateNavigation"
            [cellTemplate]="activeCellTemplate()"
            [monthCellTemplate]="monthCellTemplateRef"
            [yearCellTemplate]="yearCellTemplateRef"
            [decadeCellTemplate]="decadeCellTemplateRef"
            [centuryCellTemplate]="centuryCellTemplateRef"
            [headerTitleTemplate]="headerTitleTemplateRef"
            [weekNumberTemplate]="weekNumberTemplateRef"
            [focusedDate]="focusedDate"
            [selection]="selection"
            [value]="value"
            [disabledDates]="disabledDates"
            (activeViewChange)="handleActiveViewChange($event)"
            (navigate)="handleNavigate($event)"
            (valueChange)="handleMultiViewCalendarValueChange($event, multiviewcalendar.focusedDate)"
            (focus)="handleFocus()"
            (blur)="handleBlur($event)"
        >
            <kendo-multiviewcalendar-messages
                [today]="localization.get('today')"
                [prevButtonTitle]="localization.get('prevButtonTitle')"
                [nextButtonTitle]="localization.get('nextButtonTitle')"
            >
            </kendo-multiviewcalendar-messages>
        </kendo-multiviewcalendar>
    </ng-container>
  `
            }]
    }], function () { return [{ type: BusViewService }, { type: CalendarDOMService }, { type: ɵngcc0.ElementRef }, { type: NavigationService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Injector }, { type: ScrollSyncService }, { type: DisabledDatesService }, { type: ɵngcc3.LocalizationService }, { type: SelectionService }, { type: PickerService, decorators: [{
                type: Optional
            }] }]; }, { id: [{
            type: Input
        }], rangeValidation: [{
            type: Input
        }], selection: [{
            type: Input
        }], disabled: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], navigation: [{
            type: Input
        }], activeView: [{
            type: Input
        }], bottomView: [{
            type: Input
        }], topView: [{
            type: Input
        }], animateNavigation: [{
            type: Input
        }], weekNumber: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.k-week-number']
        }], activeViewChange: [{
            type: Output
        }], navigate: [{
            type: Output
        }], activeViewDateChange: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], focusedDate: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], value: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], disabledDates: [{
            type: Input
        }], type: [{
            type: Input
        }], cellTemplateRef: [{
            type: Input,
            args: ['cellTemplate']
        }], monthCellTemplateRef: [{
            type: Input,
            args: ['monthCellTemplate']
        }], yearCellTemplateRef: [{
            type: Input,
            args: ['yearCellTemplate']
        }], decadeCellTemplateRef: [{
            type: Input,
            args: ['decadeCellTemplate']
        }], centuryCellTemplateRef: [{
            type: Input,
            args: ['centuryCellTemplate']
        }], weekNumberTemplateRef: [{
            type: Input,
            args: ['weekNumberTemplate']
        }], headerTitleTemplateRef: [{
            type: Input,
            args: ['headerTitleTemplate']
        }], navigationItemTemplateRef: [{
            type: Input,
            args: ['navigationItemTemplate']
        }], widgetId: [{
            type: HostBinding,
            args: ['attr.id']
        }], calendarTabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.k-disabled']
        }], cellTemplate: [{
            type: ContentChild,
            args: [CellTemplateDirective, { static: false }]
        }], monthCellTemplate: [{
            type: ContentChild,
            args: [MonthCellTemplateDirective, { static: false }]
        }], yearCellTemplate: [{
            type: ContentChild,
            args: [YearCellTemplateDirective, { static: false }]
        }], decadeCellTemplate: [{
            type: ContentChild,
            args: [DecadeCellTemplateDirective, { static: false }]
        }], centuryCellTemplate: [{
            type: ContentChild,
            args: [CenturyCellTemplateDirective, { static: false }]
        }], weekNumberTemplate: [{
            type: ContentChild,
            args: [WeekNumberCellTemplateDirective, { static: false }]
        }], headerTitleTemplate: [{
            type: ContentChild,
            args: [HeaderTitleTemplateDirective, { static: false }]
        }], navigationItemTemplate: [{
            type: ContentChild,
            args: [NavigationItemTemplateDirective, { static: false }]
        }], navigationView: [{
            type: ViewChild,
            args: [NavigationComponent, { static: false }]
        }], monthView: [{
            type: ViewChild,
            args: [ViewListComponent, { static: false }]
        }], multiViewCalendar: [{
            type: ViewChild,
            args: [MultiViewCalendarComponent, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateInputComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendo-dateinput',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DateInputComponent_1), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => DateInputComponent_1), multi: true },
                    { provide: L10N_PREFIX, useValue: 'kendo.dateinput' },
                    { provide: KendoInput, useExisting: forwardRef(() => DateInputComponent_1) },
                    LocalizationService
                ],
                selector: 'kendo-dateinput',
                template: `
    <ng-container kendoDateInputLocalizedMessages
        i18n-increment="kendo.dateinput.increment|The label for the **Increment** button in the DateInput"
        increment="Increase value"

        i18n-decrement="kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput"
        decrement="Decrease value"
    >
    </ng-container>
    <input
        #dateInput
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
        class="k-input-inner"
        [attr.role]="role"
        [attr.aria-readonly]="ariaReadOnly"
        [id]="focusableId"
        [title]="title"
        [tabindex]="tabindex"
        [disabled]="disabled"
        [readonly]="readonly"
        [placeholder]="placeholder"
        [attr.aria-expanded]="isPopupOpen"
        [attr.aria-haspopup]="hasPopup"
        [kendoEventsOutsideAngular]="{
            click: handleClick,
            focus: handleFocus,
            mousedown: handleMousedown,
            touchstart: handleMousedown,
            dragstart: handleDragAndDrop,
            drop: handleDragAndDrop,
            blur: handleBlur
        }"
        [scope]="this"
        />
    <span *ngIf="spinners" class="k-input-spinner k-spin-button" (mousedown)="$event.preventDefault()">
        <button
            #spinup
            tabindex="-1"
            class="k-spinner-increase k-button k-icon-button"
            [class.k-active]="arrowDirection === arrow.Up"
            (mousedown)="arrowDirection = arrow.Up"
            (mouseleave)="arrowDirection = arrow.None"
            (click)="handleButtonClick(1)"
            [title]="localization.get('increment')"
            [attr.aria-label]="localization.get('increment')">
            <span class="k-button-icon k-icon k-i-arrow-n"></span>
        </button>
        <button
            #spindown
            tabindex="-1"
            class="k-spinner-decrease k-button k-icon-button"
            (click)="handleButtonClick(-1)"
            [class.k-active]="arrowDirection === arrow.Down"
            (mousedown)="arrowDirection = arrow.Down"
            (mouseleave)="arrowDirection = arrow.None"
            [title]="localization.get('decrement')"
            [attr.aria-label]="localization.get('decrement')">
            <span class="k-button-icon k-icon k-i-arrow-s"></span>
        </button>
    </span>
  `
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.IntlService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Injector }, { type: ɵngcc3.LocalizationService }, { type: PickerService, decorators: [{
                type: Optional
            }] }]; }, { focusableId: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], title: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], role: [{
            type: Input
        }], ariaReadOnly: [{
            type: Input
        }], format: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], steps: [{
            type: Input
        }], rangeValidation: [{
            type: Input
        }], autoCorrect: [{
            type: Input
        }], incompleteDateValidation: [{
            type: Input
        }], twoDigitYearMax: [{
            type: Input
        }], spinners: [{
            type: Input
        }], isPopupOpen: [{
            type: Input
        }], hasPopup: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], valueUpdate: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], tabIndex: [{
            type: Input
        }], value: [{
            type: Input
        }], size: [{
            type: Input
        }], rounded: [{
            type: Input
        }], fillMode: [{
            type: Input
        }], wrapperClass: [{
            type: HostBinding,
            args: ['class.k-input']
        }, {
            type: HostBinding,
            args: ['class.k-dateinput']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-disabled']
        }], formatPlaceholder: [{
            type: Input
        }], max: [{
            type: Input
        }], min: [{
            type: Input
        }], dateInput: [{
            type: ViewChild,
            args: ['dateInput', { static: true }]
        }], spinup: [{
            type: ViewChild,
            args: ['spinup', { static: false }]
        }], spindown: [{
            type: ViewChild,
            args: ['spindown', { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DatePickerComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendo-datepicker',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DatePickerComponent_1), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => DatePickerComponent_1), multi: true },
                    { provide: KendoInput, useExisting: forwardRef(() => DatePickerComponent_1) },
                    LocalizationService,
                    PickerService,
                    DisabledDatesService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.datepicker'
                    }
                ],
                selector: 'kendo-datepicker',
                template: `
        <ng-container kendoDatePickerLocalizedMessages
            i18n-today="kendo.datepicker.today|The label for the today button in the calendar header"
            today="Today"

            i18n-toggle="kendo.datepicker.toggle|The title of the toggle button in the datepicker component"
            toggle="Toggle calendar"

            i18n-prevButtonTitle="kendo.datepicker.prevButtonTitle|The title of the previous button in the Classic calendar"
            prevButtonTitle="Navigate to previous view"

            i18n-nextButtonTitle="kendo.datepicker.nextButtonTitle|The title of the next button in the Classic calendar"
            nextButtonTitle="Navigate to next view"
        >
        </ng-container>
        <kendo-dateinput
            #input
            [role]="inputRole"
            [focusableId]="focusableId"
            [hasPopup]="true"
            [isPopupOpen]="show"
            [disabled]="disabled"
            [readonly]="readonly || readOnlyInput"
            [ariaReadOnly]="readonly"
            [tabindex]="tabindex"
            [title]="title"
            [format]="format"
            [twoDigitYearMax]="twoDigitYearMax"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [incompleteDateValidation]="incompleteDateValidation"
            [fillMode]="null"
            [rounded]="null"
            [size]="null"
            [value]="value"
            (valueChange)="handleInputChange($event)"
        ></kendo-dateinput>
        <button
            #toggleButton
            type="button"
            class="k-input-button k-button k-icon-button"
            [tabindex]="-1"
            [attr.title]="localization.get('toggle')"
            [attr.aria-label]="localization.get('toggle')"
            [kendoEventsOutsideAngular]="{
                click: handleIconClick,
                mousedown: handleMousedown
            }"
            [scope]="this"
        >
            <span class="k-button-icon k-icon k-i-calendar"></span>
        </button>
        <ng-container #container></ng-container>
        <ng-template #popupTemplate>
            <kendo-calendar
                #calendar
                [type]="calendarType"
                [min]="min"
                [max]="max"
                [navigation]="navigation"
                [animateNavigation]="animateCalendarNavigation"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [weekNumber]="weekNumber"
                [cellTemplate]="cellTemplate"
                [monthCellTemplate]="monthCellTemplate"
                [yearCellTemplate]="yearCellTemplate"
                [decadeCellTemplate]="decadeCellTemplate"
                [centuryCellTemplate]="centuryCellTemplate"
                [weekNumberTemplate]="weekNumberTemplate"
                [headerTitleTemplate]="headerTitleTemplate"
                [navigationItemTemplate]="navigationItemTemplate"
                [focusedDate]="focusedDate"
                [value]="value"
                (valueChange)="handleChange(mergeTime($event))"
                [kendoEventsOutsideAngular]="{
                    keydown: handleKeydown
                }"
                [scope]="this"
                [disabledDates]="disabledDates"
            >
                <kendo-calendar-messages
                    [today]="localization.get('today')"
                    [prevButtonTitle]="localization.get('prevButtonTitle')"
                    [nextButtonTitle]="localization.get('nextButtonTitle')"
                >
                </kendo-calendar-messages>
            </kendo-calendar>
        <ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc3.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc5.PopupService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.Injector }, { type: PickerService }, { type: DisabledDatesService }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TOUCH_ENABLED]
            }] }]; }, { focusableId: [{
            type: Input
        }], activeView: [{
            type: Input
        }], bottomView: [{
            type: Input
        }], topView: [{
            type: Input
        }], calendarType: [{
            type: Input
        }], animateCalendarNavigation: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], readOnlyInput: [{
            type: Input
        }], navigation: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], incompleteDateValidation: [{
            type: Input
        }], focusedDate: [{
            type: Input
        }], format: [{
            type: Input
        }], twoDigitYearMax: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], title: [{
            type: Input
        }], rangeValidation: [{
            type: Input
        }], disabledDatesValidation: [{
            type: Input
        }], weekNumber: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], wrapperClasses: [{
            type: HostBinding,
            args: ['class.k-datepicker']
        }, {
            type: HostBinding,
            args: ['class.k-input']
        }], cellTemplateRef: [{
            type: Input,
            args: ['cellTemplate']
        }], cellTemplate: [{
            type: ContentChild,
            args: [CellTemplateDirective, { static: false }]
        }], monthCellTemplateRef: [{
            type: Input,
            args: ['monthCellTemplate']
        }], monthCellTemplate: [{
            type: ContentChild,
            args: [MonthCellTemplateDirective, { static: false }]
        }], yearCellTemplateRef: [{
            type: Input,
            args: ['yearCellTemplate']
        }], yearCellTemplate: [{
            type: ContentChild,
            args: [YearCellTemplateDirective, { static: false }]
        }], decadeCellTemplateRef: [{
            type: Input,
            args: ['decadeCellTemplate']
        }], decadeCellTemplate: [{
            type: ContentChild,
            args: [DecadeCellTemplateDirective, { static: false }]
        }], centuryCellTemplateRef: [{
            type: Input,
            args: ['centuryCellTemplate']
        }], centuryCellTemplate: [{
            type: ContentChild,
            args: [CenturyCellTemplateDirective, { static: false }]
        }], weekNumberTemplateRef: [{
            type: Input,
            args: ['weekNumberTemplate']
        }], weekNumberTemplate: [{
            type: ContentChild,
            args: [WeekNumberCellTemplateDirective, { static: false }]
        }], headerTitleTemplateRef: [{
            type: Input,
            args: ['headerTitleTemplate']
        }], headerTitleTemplate: [{
            type: ContentChild,
            args: [HeaderTitleTemplateDirective, { static: false }]
        }], navigationItemTemplateRef: [{
            type: Input,
            args: ['navigationItemTemplate']
        }], navigationItemTemplate: [{
            type: ContentChild,
            args: [NavigationItemTemplateDirective, { static: false }]
        }], popupSettings: [{
            type: Input
        }], value: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], disabledDates: [{
            type: Input
        }], size: [{
            type: Input
        }], rounded: [{
            type: Input
        }], fillMode: [{
            type: Input
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-disabled']
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef, static: true }]
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate', { static: true }]
        }], toggleButton: [{
            type: ViewChild,
            args: ['toggleButton', { static: true }]
        }], formatPlaceholder: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimePickerComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendo-timepicker',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => TimePickerComponent_1), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => TimePickerComponent_1), multi: true },
                    { provide: KendoInput, useExisting: forwardRef(() => TimePickerComponent_1) },
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.timepicker'
                    },
                    PickerService
                ],
                selector: 'kendo-timepicker',
                template: `
        <ng-container kendoTimePickerLocalizedMessages
            i18n-accept="kendo.timepicker.accept|The Accept button text in the timepicker component"
            accept="Set"

            i18n-acceptLabel="kendo.timepicker.acceptLabel|The label for the Accept button in the timepicker component"
            acceptLabel="Set time"

            i18n-cancel="kendo.timepicker.cancel|The Cancel button text in the timepicker component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.timepicker.cancelLabel|The label for the Cancel button in the timepicker component"
            cancelLabel="Cancel changes"

            i18n-now="kendo.timepicker.now|The Now button text in the timepicker component"
            now="Now"

            i18n-nowLabel="kendo.timepicker.nowLabel|The label for the Now button in the timepicker component"
            nowLabel="Select now"

            i18n-toggle="kendo.timepicker.toggle|The label for the toggle button in the timepicker component"
            toggle="Toggle time list"
        >
        </ng-container>
        <kendo-dateinput
            #input
            [focusableId]="focusableId"
            [hasPopup]="true"
            [isPopupOpen]="show"
            [disabled]="disabled"
            [readonly]="readonly || readOnlyInput"
            [role]="inputRole"
            [ariaReadOnly]="readonly"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="normalizeTime(min)"
            [max]="normalizeTime(max)"
            [incompleteDateValidation]="incompleteDateValidation"
            [fillMode]="fillMode"
            [rounded]="rounded"
            [size]="size"
            [steps]="steps"
            [tabindex]="!show ? tabindex : -1"
            [title]="title"
            [value]="value"
            (valueChange)="handleInputChange($event)"
        ></kendo-dateinput>
        <button
            #toggleButton
            type="button"
            class="k-input-button k-button k-icon-button"
            [attr.title]="localization.get('toggle')"
            [attr.aria-label]="localization.get('toggle')"
            [kendoEventsOutsideAngular]="{
                click: handleIconClick,
                mousedown: handleMousedown
            }"
            [scope]="this"
        >
            <span class="k-button-icon k-icon k-i-clock"></span>
        </button>
        <ng-template #popupTemplate>
            <kendo-timeselector
                #timeSelector
                [cancelButton]="cancelButton"
                [nowButton]="nowButton"
                [format]="format"
                [min]="min"
                [max]="max"
                [steps]="steps"
                [value]="value"
                [kendoEventsOutsideAngular]="{
                    keydown: handleKeydown,
                    mousedown: handleMousedown
                }"
                [scope]="this"
                (valueChange)="handleChange($event)"
                (valueReject)="handleReject()"
            >
                <kendo-timeselector-messages
                    [acceptLabel]="localization.get('acceptLabel')"
                    [accept]="localization.get('accept')"
                    [cancelLabel]="localization.get('cancelLabel')"
                    [cancel]="localization.get('cancel')"
                    [nowLabel]="localization.get('nowLabel')"
                    [now]="localization.get('now')"
                >
                </kendo-timeselector-messages>
            </kendo-timeselector>
        </ng-template>
        <ng-container #container></ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc3.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc5.PopupService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.Injector }, { type: PickerService }, { type: ɵngcc1.IntlService }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TOUCH_ENABLED]
            }] }]; }, { focusableId: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], readOnlyInput: [{
            type: Input
        }], format: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], incompleteDateValidation: [{
            type: Input
        }], cancelButton: [{
            type: Input
        }], nowButton: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], title: [{
            type: Input
        }], rangeValidation: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], wrapperClasses: [{
            type: HostBinding,
            args: ['class.k-timepicker']
        }, {
            type: HostBinding,
            args: ['class.k-input']
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], steps: [{
            type: Input
        }], popupSettings: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], value: [{
            type: Input
        }], size: [{
            type: Input
        }], rounded: [{
            type: Input
        }], fillMode: [{
            type: Input
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-disabled']
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef, static: false }]
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate', { static: false }]
        }], toggleButton: [{
            type: ViewChild,
            args: ['toggleButton', { static: true }]
        }], formatPlaceholder: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateTimePickerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-datetimepicker',
                exportAs: 'kendo-datetimepicker',
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    PickerService,
                    LocalizationService,
                    DisabledDatesService,
                    { provide: L10N_PREFIX, useValue: 'kendo.datetimepicker' },
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DateTimePickerComponent_1), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => DateTimePickerComponent_1), multi: true },
                    { provide: KendoInput, useExisting: forwardRef(() => DateTimePickerComponent_1) }
                ],
                template: `
        <ng-container
            kendoDateTimePickerLocalizedMessages

            i18n-dateTab="kendo.datetimepicker.dateTab|The Date tab text in the datetimepicker popup header"
            dateTab="Date"

            i18n-dateTabLabel="kendo.datetimepicker.dateTabLabel|The label for the Date tab in the datetimepicker popup header"
            dateTabLabel="Date tab"

            i18n-timeTab="kendo.datetimepicker.timeTab|The Time tab text in the datetimepicker popup header"
            timeTab="Time"

            i18n-timeTabLabel="kendo.datetimepicker.timeTabLabel|The label for the Time tab in the datetimepicker popup header"
            timeTabLabel="Time tab"

            i18n-toggle="kendo.datetimepicker.toggle|The title of the toggle button in the datetimepicker component"
            toggle="Toggle popup"

            i18n-accept="kendo.datetimepicker.accept|The Accept button text in the datetimepicker component"
            accept="Set"

            i18n-acceptLabel="kendo.datetimepicker.acceptLabel|The label for the Accept button in the datetimepicker component"
            acceptLabel="Set"

            i18n-cancel="kendo.datetimepicker.cancel|The Cancel button text in the datetimepicker component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.datetimepicker.cancelLabel|The label for the Cancel button in the datetimepicker component"
            cancelLabel="Cancel"

            i18n-now="kendo.datetimepicker.now|The Now button text in the timepicker component"
            now="NOW"

            i18n-nowLabel="kendo.datetimepicker.nowLabel|The label for the Now button in the timepicker component"
            nowLabel="Select now"

            i18n-today="kendo.datetimepicker.today|The label for the today button in the calendar header"
            today="Today"

            i18n-prevButtonTitle="kendo.datetimepicker.prevButtonTitle|The title of the previous button in the Classic calendar"
            prevButtonTitle="Navigate to previous view"

            i18n-nextButtonTitle="kendo.datetimepicker.nextButtonTitle|The title of the next button in the Classic calendar"
            nextButtonTitle="Navigate to next view"
        >
        </ng-container>

        <kendo-dateinput
            [value]="value"
            [format]="format"
            [twoDigitYearMax]="twoDigitYearMax"
            [min]="min"
            [max]="max"
            [incompleteDateValidation]="incompleteDateValidation"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [disabled]="disabled"
            [readonly]="readonly || readOnlyInput"
            [role]="inputRole"
            [ariaReadOnly]="readonly"
            [steps]="steps"
            [tabindex]="tabindex"
            [title]="title"
            [focusableId]="focusableId"
            [hasPopup]="true"
            [isPopupOpen]="isOpen"
            (valueChange)="handleInputValueChange($event)"
            [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown
            }"
            [scope]="this"
            [fillMode]="fillMode"
            [rounded]="rounded"
            [size]="size"
        >
        </kendo-dateinput>
        <button
            #toggleButton
            type="button"
            class="k-input-button k-button k-icon-button"
            [tabindex]="-1"
            [attr.title]="localization.get('toggle')"
            [attr.aria-label]="localization.get('toggle')"
            [kendoEventsOutsideAngular]="{
                mousedown: preventMouseDown,
                click: handleIconClick
            }"
            [scope]="this"
        >
            <span class="k-button-icon k-icon"
                [ngClass]="{
                    'k-i-calendar': activeTab === 'date',
                    'k-i-clock': activeTab === 'time'
                }"
            ></span>
        </button>

        <ng-container #container></ng-container>

        <ng-template #popupTemplate>
            <div
                class="k-datetime-wrap k-{{activeTab}}-tab"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventMouseDown,
                    keydown: handleKeyDown
                }"
                [scope]="this"
            >
                <div class="k-datetime-buttongroup"
                    [kendoEventsOutsideAngular]="{
                        focusin: handleFocus,
                        focusout: handleBlur
                    }"
                    [scope]="this"
                >
                    <div class="k-button-group k-button-group-stretched">
                        <button
                            type="button"
                            class="k-button k-group-start k-date-tab"
                            [ngClass]="popupButtonsClasses()"
                            [class.k-active]="activeTab === 'date'"
                            [attr.title]="localization.get('dateTabLabel')"
                            [attr.aria-label]="localization.get('dateTabLabel')"
                            [kendoEventsOutsideAngular]="{
                                click: changeActiveTab.bind(this, 'date'),
                                keydown: handleBackTabOut
                            }"
                            [scope]="this"
                        >
                            {{localization.get('dateTab')}}
                        </button>
                        <button
                            type="button"
                            class="k-button k-group-end k-time-tab"
                            [ngClass]="popupButtonsClasses()"
                            [class.k-active]="activeTab === 'time'"
                            [attr.title]="localization.get('timeTabLabel')"
                            [attr.aria-label]="localization.get('timeTabLabel')"
                            [kendoEventsOutsideAngular]="{
                                click: changeActiveTab.bind(this, 'time')
                            }"
                        >
                            {{localization.get('timeTab')}}
                        </button>
                    </div>
                </div>
                <div
                    #dateTimeSelector
                    class="k-datetime-selector"
                    [style.transition]="tabSwitchTransition"
                    [kendoEventsOutsideAngular]="{
                        transitionend: handleTabChangeTransitionEnd.bind(this, dateTimeSelector)
                    }"
                >
                    <div class="k-datetime-calendar-wrap">
                        <kendo-calendar
                            [(value)]="calendarValue"
                            [type]="calendarType"
                            [min]="calendarMin"
                            [max]="calendarMax"
                            [focusedDate]="focusedDate"
                            [weekNumber]="weekNumber"
                            [navigation]="false"
                            [animateNavigation]="animateCalendarNavigation"
                            [cellTemplate]="cellTemplate"
                            [monthCellTemplate]="monthCellTemplate"
                            [yearCellTemplate]="yearCellTemplate"
                            [decadeCellTemplate]="decadeCellTemplate"
                            [centuryCellTemplate]="centuryCellTemplate"
                            [weekNumberTemplate]="weekNumberTemplate"
                            [headerTitleTemplate]="headerTitleTemplate"
                            [disabled]="disableCalendar"
                            [disabledDates]="disabledDates"
                            (valueChange)="handleCalendarValueChange()"
                        >
                            <kendo-calendar-messages
                                [today]="localization.get('today')"
                                [prevButtonTitle]="localization.get('prevButtonTitle')"
                                [nextButtonTitle]="localization.get('nextButtonTitle')"
                            >
                            </kendo-calendar-messages>
                        </kendo-calendar>
                    </div>
                    <div class="k-datetime-time-wrap">
                        <kendo-timeselector
                            [value]="value"
                            [format]="timeSelectorFormat"
                            [min]="timeSelectorMin"
                            [max]="timeSelectorMax"
                            [setButton]="false"
                            [cancelButton]="false"
                            [steps]="steps"
                            [disabled]="disableTimeSelector"
                        >
                            <kendo-timeselector-messages
                                [now]="localization.get('now')"
                                [nowLabel]="localization.get('nowLabel')"
                            >
                            </kendo-timeselector-messages>
                        </kendo-timeselector>
                    </div>
                </div>
                <div
                    class="k-datetime-footer k-action-buttons k-actions k-hstack k-justify-content-stretch"
                    [kendoEventsOutsideAngular]="{
                        keydown: handleTabOut,
                        focusin: handleFocus,
                        focusout: handleBlur
                    }"
                    [scope]="this"
                >
                    <button
                        *ngIf="cancelButton"
                        type="button"
                        class="k-button k-time-cancel"
                        [ngClass]="popupButtonsClasses()"
                        [attr.title]="localization.get('cancelLabel')"
                        [attr.aria-label]="localization.get('cancelLabel')"
                        [kendoEventsOutsideAngular]="{
                            click: handleCancel
                        }"
                        [scope]="this"
                    >
                        {{localization.get('cancel')}}
                    </button>
                    <button
                        type="button"
                        class="k-button k-time-accept"
                        [ngClass]="popupButtonsClasses('primary')"
                        [attr.title]="localization.get('acceptLabel')"
                        [attr.aria-label]="localization.get('acceptLabel')"
                        [disabled]="!calendarValue"
                        [kendoEventsOutsideAngular]="{
                            click: handleAccept
                        }"
                        [scope]="this"
                    >
                        {{localization.get('accept')}}
                    </button>
                </div>
            </div>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc5.PopupService }, { type: ɵngcc1.IntlService }, { type: ɵngcc0.ChangeDetectorRef }, { type: PickerService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: Boolean, decorators: [{
                type: Inject,
                args: [TOUCH_ENABLED]
            }] }, { type: ɵngcc3.LocalizationService }, { type: DisabledDatesService }, { type: ɵngcc0.Renderer2 }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-datetimepicker']
        }, {
            type: HostBinding,
            args: ['class.k-input']
        }], twoDigitYearMax: [{
            type: Input
        }], focusableId: [{
            type: Input
        }], title: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], readOnlyInput: [{
            type: Input
        }], cancelButton: [{
            type: Input
        }], steps: [{
            type: Input
        }], calendarType: [{
            type: Input
        }], animateCalendarNavigation: [{
            type: Input
        }], weekNumber: [{
            type: Input
        }], rangeValidation: [{
            type: Input
        }], disabledDatesValidation: [{
            type: Input
        }], incompleteDateValidation: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-disabled']
        }], value: [{
            type: Input
        }], format: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], disabledDates: [{
            type: Input
        }], popupSettings: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], defaultTab: [{
            type: Input
        }], size: [{
            type: Input
        }], rounded: [{
            type: Input
        }], fillMode: [{
            type: Input
        }], toggleButton: [{
            type: ViewChild,
            args: ['toggleButton', { static: true }]
        }], formatPlaceholder: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], focusedDate: [{
            type: Input
        }], cellTemplate: [{
            type: ContentChild,
            args: [CellTemplateDirective, { static: false }]
        }], monthCellTemplate: [{
            type: ContentChild,
            args: [MonthCellTemplateDirective, { static: false }]
        }], yearCellTemplate: [{
            type: ContentChild,
            args: [YearCellTemplateDirective, { static: false }]
        }], decadeCellTemplate: [{
            type: ContentChild,
            args: [DecadeCellTemplateDirective, { static: false }]
        }], centuryCellTemplate: [{
            type: ContentChild,
            args: [CenturyCellTemplateDirective, { static: false }]
        }], weekNumberTemplate: [{
            type: ContentChild,
            args: [WeekNumberCellTemplateDirective, { static: false }]
        }], headerTitleTemplate: [{
            type: ContentChild,
            args: [HeaderTitleTemplateDirective, { static: false }]
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef, static: true }]
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate', { read: TemplateRef, static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateRangePopupTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDateRangePopupTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateRangeService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateRangePopupComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendo-daterange-popup',
                selector: 'kendo-daterange-popup',
                template: `
        <ng-container #container></ng-container>
        <ng-template #defaultTemplate>
            <kendo-multiviewcalendar kendoDateRangeSelection></kendo-multiviewcalendar>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc5.PopupService }, { type: DateRangeService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { animate: [{
            type: Input
        }], collision: [{
            type: Input
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], cancel: [{
            type: Output
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef, static: false }]
        }], defaultTemplate: [{
            type: ViewChild,
            args: ['defaultTemplate', { static: false }]
        }], contentTemplate: [{
            type: ContentChild,
            args: [DateRangePopupTemplateDirective, { static: false }]
        }], viewCalendar: [{
            type: ViewChildren,
            args: [MultiViewCalendarComponent]
        }], contentCalendar: [{
            type: ContentChildren,
            args: [MultiViewCalendarComponent]
        }], anchor: [{
            type: Input
        }], anchorAlign: [{
            type: Input
        }], appendTo: [{
            type: Input
        }], popupAlign: [{
            type: Input
        }], margin: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateRangeComponent, [{
        type: Component,
        args: [{
                providers: [DateRangeService],
                selector: 'kendo-daterange',
                template: `
        <ng-content></ng-content>
        <kendo-daterange-popup *ngIf="showDefault"></kendo-daterange-popup>
    `
            }]
    }], function () { return []; }, { contentPopup: [{
            type: ContentChildren,
            args: [DateRangePopupComponent]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateRangeEndInputDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDateRangeEndInput]'
            }]
    }], function () { return [{ type: DateRangeService }, { type: DateInputComponent }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { navigateCalendarOnFocus: [{
            type: Input
        }], autoCorrectOn: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateRangeStartInputDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDateRangeStartInput]'
            }]
    }], function () { return [{ type: DateRangeService }, { type: DateInputComponent }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { navigateCalendarOnFocus: [{
            type: Input
        }], autoCorrectOn: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateRangeSelectionDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDateRangeSelection]'
            }]
    }], function () { return [{ type: MultiViewCalendarComponent }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: DateRangeService, decorators: [{
                type: Optional
            }] }]; }, { autoCorrectOn: [{
            type: Input
        }], activeRangeEndChange: [{
            type: Output
        }], selectionRangeChange: [{
            type: Output
        }], selectionRange: [{
            type: Input
        }], activeRangeEnd: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(KForOf, [{
        type: Directive,
        args: [{ selector: '[kFor][kForOf]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }]; }, { kForTemplate: [{
            type: Input
        }], kForOf: [{
            type: Input
        }], kForTrackBy: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ViewComponent, [{
        type: Component,
        args: [{
                selector: '[kendoCalendarView]',
                template: `
    <ng-template #emptyCell><td class="k-empty k-calendar-td">&nbsp;</td></ng-template>
    <tr *ngIf="!isHorizontal()" class="k-calendar-tr" role="row"><th class="k-calendar-caption" scope="col" [colSpan]="colSpan">{{title}}</th></tr>
    <tr *kFor="let row of data; let rowIndex = index" class="k-calendar-tr" role="row">
        <ng-template [ngIf]="weekNumber">
            <td
                class="k-alt k-calendar-td"
                *ngIf="firstDate(row); else emptyCell"
                [kendoEventsOutsideAngular]="{
                    click: handleWeekNumberClick.bind(this, row)
                }"
            >
                <ng-template [ngIf]="!weekNumberTemplateRef">
                    {{getWeekNumber(firstDate(row))}}
                </ng-template>
                <ng-template
                    [ngIf]="weekNumberTemplateRef"
                    [ngTemplateOutlet]="weekNumberTemplateRef"
                    [ngTemplateOutletContext]="{
                        $implicit: firstDate(row),
                        cellContext: getWeekNumberContext(row)
                    }"
                ></ng-template>
            </td>
        </ng-template>
        <ng-container *kFor="let cell of row; let cellIndex = index">
            <td class="k-calendar-td"
                *ngIf="shouldRenderCellContent(cell); else emptyCell"
                role="gridcell"
                [attr.id]="cell.id"
                [attr.data-cell-index]="tableCellIndex(rowIndex, cellIndex)"
                [attr.aria-selected]="cell.isSelected || cell.isRangeStart || cell.isRangeMid || cell.isRangeEnd"
                [attr.aria-disabled]="cell.isDisabled"
                [ngClass]="getStyles(cell)"
                [title]="cell.title"
            >
                <span class="k-link">
                    <ng-template [ngIf]="!templateRef">{{cell.formattedValue}}</ng-template>
                    <ng-template
                        *ngIf="templateRef"
                        [ngTemplateOutlet]="templateRef"
                        [ngTemplateOutletContext]="{ $implicit: cell.value, cellContext: cell }"
                    ></ng-template>
                </span>
            </td>
        </ng-container>
    </tr>
  `
            }]
    }], function () { return [{ type: BusViewService }, { type: ɵngcc1.IntlService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: DisabledDatesService }]; }, { direction: [{
            type: Input
        }], isActive: [{
            type: Input
        }], selectedDates: [{
            type: Input
        }], cellClick: [{
            type: Output
        }], weekNumberCellClick: [{
            type: Output
        }], cellEnter: [{
            type: Output
        }], cellLeave: [{
            type: Output
        }], weekNumber: [{
            type: Input
        }], activeView: [{
            type: Input
        }], cellUID: [{
            type: Input
        }], focusedDate: [{
            type: Input
        }], viewDate: [{
            type: Input
        }], activeRangeEnd: [{
            type: Input
        }], selectionRange: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], viewIndex: [{
            type: Input
        }], templateRef: [{
            type: Input
        }], weekNumberTemplateRef: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalendarCommonModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    KForOf,
                    HeaderComponent,
                    ViewComponent
                ],
                exports: [
                    KForOf,
                    HeaderComponent,
                    ViewComponent
                ],
                imports: [CommonModule, EventsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CalendarCommonModule, { declarations: function () { return [KForOf, HeaderComponent, ViewComponent]; }, imports: function () { return [CommonModule, EventsModule]; }, exports: function () { return [KForOf, HeaderComponent, ViewComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TemplatesModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    CellTemplateDirective,
                    MonthCellTemplateDirective,
                    YearCellTemplateDirective,
                    DecadeCellTemplateDirective,
                    CenturyCellTemplateDirective,
                    WeekNumberCellTemplateDirective,
                    HeaderTitleTemplateDirective,
                    NavigationItemTemplateDirective
                ],
                exports: [
                    CellTemplateDirective,
                    MonthCellTemplateDirective,
                    YearCellTemplateDirective,
                    DecadeCellTemplateDirective,
                    CenturyCellTemplateDirective,
                    WeekNumberCellTemplateDirective,
                    HeaderTitleTemplateDirective,
                    NavigationItemTemplateDirective
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TemplatesModule, { declarations: [CellTemplateDirective, MonthCellTemplateDirective, YearCellTemplateDirective, DecadeCellTemplateDirective, CenturyCellTemplateDirective, WeekNumberCellTemplateDirective, HeaderTitleTemplateDirective, NavigationItemTemplateDirective], exports: [CellTemplateDirective, MonthCellTemplateDirective, YearCellTemplateDirective, DecadeCellTemplateDirective, CenturyCellTemplateDirective, WeekNumberCellTemplateDirective, HeaderTitleTemplateDirective, NavigationItemTemplateDirective] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MultiViewCalendarLocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => MultiViewCalendarLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoMultiViewCalendarLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MultiViewCalendarCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => MultiViewCalendarCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-multiviewcalendar-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MultiViewCalendarModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    HorizontalViewListComponent,
                    MultiViewCalendarLocalizedMessagesDirective,
                    MultiViewCalendarCustomMessagesComponent,
                    MultiViewCalendarComponent
                ],
                exports: [
                    HorizontalViewListComponent,
                    MultiViewCalendarLocalizedMessagesDirective,
                    MultiViewCalendarCustomMessagesComponent,
                    MultiViewCalendarComponent,
                    CalendarCommonModule,
                    TemplatesModule
                ],
                imports: [
                    CommonModule,
                    CalendarCommonModule,
                    IntlModule,
                    TemplatesModule,
                    PopupModule,
                    EventsModule
                ],
                providers: [
                    NavigationService,
                    CenturyViewService,
                    DecadeViewService,
                    MonthViewService,
                    YearViewService,
                    WeekNamesService
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MultiViewCalendarModule, { declarations: function () { return [HorizontalViewListComponent, MultiViewCalendarLocalizedMessagesDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent]; }, imports: function () { return [CommonModule, CalendarCommonModule, IntlModule, TemplatesModule, PopupModule,
        EventsModule]; }, exports: function () { return [HorizontalViewListComponent, MultiViewCalendarLocalizedMessagesDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CalendarCommonModule, TemplatesModule]; } }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalendarLocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: CalendarMessages,
                        useExisting: forwardRef(() => CalendarLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoCalendarLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalendarCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: CalendarMessages,
                        useExisting: forwardRef(() => CalendarCustomMessagesComponent_1)
                    }
                ],
                selector: 'kendo-calendar-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(VirtualizationModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES],
                exports: [COMPONENT_DIRECTIVES],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(VirtualizationModule, { declarations: function () { return [VirtualizationComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [VirtualizationComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalendarModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    CalendarComponent,
                    NavigationComponent,
                    CalendarCustomMessagesComponent,
                    CalendarLocalizedMessagesDirective,
                    ViewListComponent
                ],
                exports: [
                    CalendarComponent,
                    NavigationComponent,
                    CalendarCustomMessagesComponent,
                    CalendarLocalizedMessagesDirective,
                    ViewListComponent,
                    CalendarCommonModule,
                    TemplatesModule
                ],
                imports: [
                    CommonModule,
                    CalendarCommonModule,
                    MultiViewCalendarModule,
                    IntlModule,
                    TemplatesModule,
                    VirtualizationModule,
                    EventsModule,
                    ResizeSensorModule
                ],
                providers: [
                    CalendarDOMService,
                    CenturyViewService,
                    DecadeViewService,
                    MonthViewService,
                    YearViewService,
                    WeekNamesService
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CalendarModule, { declarations: function () { return [CalendarComponent, NavigationComponent, CalendarCustomMessagesComponent, CalendarLocalizedMessagesDirective, ViewListComponent]; }, imports: function () { return [CommonModule, CalendarCommonModule, MultiViewCalendarModule, IntlModule, TemplatesModule, VirtualizationModule, EventsModule,
        ResizeSensorModule]; }, exports: function () { return [CalendarComponent, NavigationComponent, CalendarCustomMessagesComponent, CalendarLocalizedMessagesDirective, ViewListComponent, CalendarCommonModule, TemplatesModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalendarsModule, [{
        type: NgModule,
        args: [{
                exports: [
                    CalendarModule,
                    MultiViewCalendarModule
                ],
                imports: [
                    CalendarModule,
                    MultiViewCalendarModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CalendarsModule, { imports: [CalendarModule, MultiViewCalendarModule], exports: [CalendarModule, MultiViewCalendarModule] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateInputLocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: DateInputMessages,
                        useExisting: forwardRef(() => DateInputLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoDateInputLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateInputCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: DateInputMessages,
                        useExisting: forwardRef(() => DateInputCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-dateinput-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateInputModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    DateInputComponent,
                    DateInputCustomMessagesComponent,
                    DateInputLocalizedMessagesDirective
                ],
                exports: [
                    DateInputComponent,
                    DateInputCustomMessagesComponent,
                    DateInputLocalizedMessagesDirective
                ],
                imports: [CommonModule, IntlModule, EventsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DateInputModule, { declarations: function () { return [DateInputComponent, DateInputCustomMessagesComponent, DateInputLocalizedMessagesDirective]; }, imports: function () { return [CommonModule, IntlModule, EventsModule]; }, exports: function () { return [DateInputComponent, DateInputCustomMessagesComponent, DateInputLocalizedMessagesDirective]; } }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DatePickerLocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: DatePickerMessages,
                        useExisting: forwardRef(() => DatePickerLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoDatePickerLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DatePickerCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: DatePickerMessages,
                        useExisting: forwardRef(() => DatePickerCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-datepicker-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DatePickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    DatePickerComponent,
                    DatePickerCustomMessagesComponent,
                    DatePickerLocalizedMessagesDirective
                ],
                exports: [
                    DatePickerComponent,
                    DatePickerCustomMessagesComponent,
                    DatePickerLocalizedMessagesDirective,
                    TemplatesModule
                ],
                imports: [
                    CommonModule,
                    DateInputModule,
                    CalendarModule,
                    IntlModule,
                    PopupModule,
                    TemplatesModule,
                    EventsModule
                ],
                providers: [{ provide: TOUCH_ENABLED, useValue: ɵ0$e }]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DatePickerModule, { declarations: function () { return [DatePickerComponent, DatePickerCustomMessagesComponent, DatePickerLocalizedMessagesDirective]; }, imports: function () { return [CommonModule, DateInputModule, CalendarModule, IntlModule,
        PopupModule, TemplatesModule, EventsModule]; }, exports: function () { return [DatePickerComponent, DatePickerCustomMessagesComponent, DatePickerLocalizedMessagesDirective, TemplatesModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateRangeModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES$1],
                exports: [COMPONENT_DIRECTIVES$1],
                imports: [CommonModule, COMPONENT_MODULES]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DateRangeModule, { declarations: function () { return [DateRangeComponent, DateRangePopupComponent, DateRangePopupTemplateDirective, DateRangeSelectionDirective, DateRangeStartInputDirective, DateRangeEndInputDirective]; }, imports: function () { return [CommonModule, MultiViewCalendarModule, DateInputModule, PopupModule,
        EventsModule]; }, exports: function () { return [DateRangeComponent, DateRangePopupComponent, DateRangePopupTemplateDirective, DateRangeSelectionDirective, DateRangeStartInputDirective, DateRangeEndInputDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimePickerDOMService, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HoursService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.IntlService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MinutesService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.IntlService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SecondsService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.IntlService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MillisecondsService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.IntlService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DayPeriodService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.IntlService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimeListComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-timelist',
                template: `
    <kendo-virtualization
        [skip]="skip"
        [take]="total"
        [total]="total"
        [itemHeight]="itemHeight"
        [maxScrollDifference]="listHeight"
        [topOffset]="topOffset"
        [bottomOffset]="bottomOffset"
        class="k-time-container"
        role="presentation"
        tabindex="-1"
    >
        <ul [ngStyle]="style" class="k-reset"
            [kendoEventsOutsideAngular]="{
                click: handleItemClick
            }"
            [scope]="this"
        >
            <li *ngFor="let item of data; let index = index;" class="k-item"
                [attr.data-timelist-item-index]="index">
                <span>{{item.text}}</span>
            </li>
        </ul>
    </kendo-virtualization>
  `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Injector }, { type: TimePickerDOMService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { min: [{
            type: Input
        }], max: [{
            type: Input
        }], step: [{
            type: Input
        }], disabled: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], componentClass: [{
            type: HostBinding,
            args: ["class.k-time-list"]
        }], tabIndex: [{
            type: HostBinding,
            args: ["attr.tabindex"]
        }], value: [{
            type: Input
        }], part: [{
            type: Input
        }], virtualization: [{
            type: ViewChild,
            args: [VirtualizationComponent, { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimeSelectorComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendo-timeselector',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.timeselector'
                    }
                ],
                selector: 'kendo-timeselector',
                template: `
        <ng-container kendoTimeSelectorLocalizedMessages
            i18n-accept="kendo.timeselector.accept|The Accept button text in the timeselector component"
            accept="Set"

            i18n-acceptLabel="kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component"
            acceptLabel="Set time"

            i18n-cancel="kendo.timeselector.cancel|The Cancel button text in the timeselector component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component"
            cancelLabel="Cancel changes"

            i18n-now="kendo.timeselector.now|The Now button text in the timeselector component"
            now="Now"

            i18n-nowLabel="kendo.timeselector.nowLabel|The label for the Now button in the timeselector component"
            nowLabel="Select now"
        >
        </ng-container>
        <div class="k-time-header">
            <span class="k-title k-timeselector-title">
                {{ intl.formatDate(current, format) }}
            </span>
            <button
                #now
                *ngIf="showNowButton"
                type="button"
                class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-time-now"
                [attr.title]="localization.get('nowLabel')"
                [attr.aria-label]="localization.get('nowLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleNow,
                    focus: handleFocus,
                    blur: handleBlur
                }"
                [scope]="this"
                [disabled]="disabled"
            >{{localization.get('now')}}</button>
        </div>
        <div class="k-time-list-container">
            <span class="k-time-highlight"></span>
            <ng-template ngFor [ngForOf]="dateFormatParts" let-part let-idx="index">
                <div
                    #listWrapper
                    class="k-time-list-wrapper"
                    role="presentation" tabindex="-1"
                    *ngIf="part.type !== 'literal'"
                >
                    <span class="k-title k-timeselector-title">{{intl.dateFieldName(part)}}</span>
                    <kendo-timelist
                        [min]="min"
                        [max]="max"
                        [part]="part"
                        [step]="partStep(part)"
                        [disabled]="disabled"
                        [(value)]="current"
                        [kendoEventsOutsideAngular]="{
                            focus: handleListFocus,
                            blur: handleBlur
                        }"
                        [scope]="this"
                        [attr.data-timelist-index]="idx"
                    ></kendo-timelist>
                </div>
                <div class="k-time-separator" *ngIf="part.type === 'literal'">
                    {{part.pattern}}
                </div>
            </ng-template>
        </div>
        <div class="k-time-footer k-action-buttons k-actions k-hstack k-justify-content-stretch" *ngIf="setButton || cancelButton">
            <button
                #cancel
                *ngIf="cancelButton"
                class="k-button k-time-cancel k-button-md k-rounded-md k-button-solid k-button-solid-base"
                type="button"
                [attr.title]="localization.get('cancelLabel')"
                [attr.aria-label]="localization.get('cancelLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleReject,
                    focus: handleFocus,
                    blur: handleBlur
                }"
                [scope]="this"
                [disabled]="disabled"
            >{{localization.get('cancel')}}</button>
            <button
                #accept
                *ngIf="setButton"
                type="button"
                class="k-button k-time-accept k-button-md k-rounded-md k-button-solid k-button-solid-primary"
                [attr.title]="localization.get('acceptLabel')"
                [attr.aria-label]="localization.get('acceptLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleAccept,
                    focus: handleFocus,
                    blur: handleBlur
                }"
                [scope]="this"
                [disabled]="disabled"
            >{{localization.get('accept')}}</button>
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.IntlService }, { type: TimePickerDOMService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: PickerService, decorators: [{
                type: Optional
            }] }]; }, { format: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], cancelButton: [{
            type: Input
        }], setButton: [{
            type: Input
        }], nowButton: [{
            type: Input
        }], disabled: [{
            type: Input
        }], value: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], valueReject: [{
            type: Output
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-disabled']
        }], steps: [{
            type: Input
        }], accept: [{
            type: ViewChild,
            args: ['accept', { static: false }]
        }], cancel: [{
            type: ViewChild,
            args: ['cancel', { static: false }]
        }], now: [{
            type: ViewChild,
            args: ['now', { static: false }]
        }], timeLists: [{
            type: ViewChildren,
            args: [TimeListComponent]
        }], timeListWrappers: [{
            type: ViewChildren,
            args: ['listWrapper']
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimePickerLocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: TimePickerMessages,
                        useExisting: forwardRef(() => TimePickerLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoTimePickerLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimePickerCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: TimePickerMessages,
                        useExisting: forwardRef(() => TimePickerCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-timepicker-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimeSelectorLocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: TimePickerMessages,
                        useExisting: forwardRef(() => TimeSelectorLocalizedMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoTimeSelectorLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimeSelectorCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: TimePickerMessages,
                        useExisting: forwardRef(() => TimeSelectorCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-timeselector-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimePickerModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES$2],
                exports: [COMPONENT_DIRECTIVES$2],
                imports: [CommonModule, ...COMPONENT_MODULES$1],
                providers: providers
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TimePickerModule, { declarations: function () { return [TimePickerLocalizedMessagesDirective, TimeListComponent, TimePickerCustomMessagesComponent, TimePickerComponent, TimeSelectorLocalizedMessagesDirective, TimeSelectorCustomMessagesComponent, TimeSelectorComponent]; }, imports: function () { return [CommonModule, DateInputModule, IntlModule,
        PopupModule, VirtualizationModule, EventsModule]; }, exports: function () { return [TimePickerLocalizedMessagesDirective, TimeListComponent, TimePickerCustomMessagesComponent, TimePickerComponent, TimeSelectorLocalizedMessagesDirective, TimeSelectorCustomMessagesComponent, TimeSelectorComponent]; } }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateTimePickerCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: Messages$1,
                        useExisting: forwardRef(() => DateTimePickerCustomMessagesComponent_1)
                    }
                ],
                selector: 'kendo-datetimepicker-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: Messages$1,
                        useExisting: forwardRef(() => LocalizedMessagesDirective_1)
                    }
                ],
                selector: '[kendoDateTimePickerLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc3.LocalizationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateTimePickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    ...COMPONENT_DIRECTIVES$3
                ],
                exports: [
                    ...COMPONENT_DIRECTIVES$3,
                    TemplatesModule
                ],
                imports: [
                    CommonModule,
                    IntlModule,
                    DateInputModule,
                    CalendarModule,
                    TimePickerModule,
                    PopupModule,
                    EventsModule,
                    TemplatesModule
                ],
                providers: [
                    { provide: TOUCH_ENABLED, useValue: ɵ0$p }
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DateTimePickerModule, { declarations: function () { return [DateTimePickerComponent, DateTimePickerCustomMessagesComponent, LocalizedMessagesDirective]; }, imports: function () { return [CommonModule,
        IntlModule, DateInputModule, CalendarModule, TimePickerModule, PopupModule,
        EventsModule, TemplatesModule]; }, exports: function () { return [DateTimePickerComponent, DateTimePickerCustomMessagesComponent, LocalizedMessagesDirective, TemplatesModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateInputsModule, [{
        type: NgModule,
        args: [{
                exports: COMPONENT_MODULES$2,
                imports: COMPONENT_MODULES$2
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DateInputsModule, { imports: [CalendarsModule, DateInputModule, DatePickerModule, TimePickerModule, DateRangeModule, DateTimePickerModule], exports: [CalendarsModule, DateInputModule, DatePickerModule, TimePickerModule, DateRangeModule, DateTimePickerModule] }); })();


/**
 * Generated bundle index. Do not edit.
 */

export { CalendarCommonModule, CALENDAR_RANGE_VALIDATORS, CALENDAR_VALUE_ACCESSOR, KENDO_INPUT_PROVIDER, KForOf, KForOfContext, HeaderComponent, HorizontalViewListComponent, CalendarMessages, MultiViewCalendarCustomMessagesComponent, Messages, RANGE_CALENDAR_RANGE_VALIDATORS, RANGE_CALENDAR_VALUE_ACCESSOR, NavigationComponent, BusViewService, CenturyViewService, DecadeViewService, DisabledDatesService, CalendarDOMService, MonthViewService, NavigationService, ScrollSyncService, SelectionService, WeekNamesService, YearViewService, TemplatesModule, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ViewListComponent, ViewComponent, PickerService, DateInputMessages, DatePickerMessages, DateRangeInput, DateRangePopupTemplateDirective, DateTimePickerCustomMessagesComponent, LocalizedMessagesDirective, Messages$1, TimePickerMessages, TimePickerCustomMessagesComponent, TimeSelectorCustomMessagesComponent, DayPeriodService, TimePickerDOMService, HoursService, MillisecondsService, MinutesService, SecondsService, TimeListComponent, TimeSelectorComponent, TOUCH_ENABLED, ScrollerService, DEFAULT_SCROLLER_FACTORY, SCROLLER_FACTORY_TOKEN, VirtualizationComponent, VirtualizationModule, CalendarComponent, DateInputComponent, DatePickerComponent, TimePickerComponent, DateTimePickerComponent, MultiViewCalendarComponent, DateRangeComponent, DateRangePopupComponent, DateRangeEndInputDirective, DateRangeStartInputDirective, DateRangeSelectionDirective, CalendarModule, CalendarsModule, DateInputModule, DatePickerModule, DateInputsModule, TimePickerModule, DateTimePickerModule, MultiViewCalendarModule, DateRangeModule, DateRangeService, CalendarCustomMessagesComponent, DateInputCustomMessagesComponent, DatePickerCustomMessagesComponent, PreventableEvent, CalendarLocalizedMessagesDirective, MultiViewCalendarLocalizedMessagesDirective, DateInputLocalizedMessagesDirective, DatePickerLocalizedMessagesDirective, TimePickerLocalizedMessagesDirective, TimeSelectorLocalizedMessagesDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0tBR3VCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2SkFHc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBKQUFFO0FBQ0YsK0JBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dUpBQUU7QUFDRiw4QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b0pBQUU7QUFDRiw2QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBKQUFFO0FBQ0YsK0JBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7b0xBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0E0RUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c0tBR3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VIQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQXFERztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NkpBQUU7QUFDRixnQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MEpBQUU7QUFDRiwrQkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5SkFBRTtBQUNGLG9DQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dLQUFFO0FBQ0YseUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUtBQUU7QUFDRix3Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MktBQUU7QUFDRiwwQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OEtBQUU7QUFDRiwyQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1TEFBRTtBQUNGLDhDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OEtBQUU7QUFDRiwyQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxSEFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dOQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0EyRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dLQUd1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OzJEQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQWdCRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b01BQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBZ0NHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxTEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0ErREc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2SkFBRTtBQUNGLGdDQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dUxBQUU7QUFDRiw4Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29SQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0EyR0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytLQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBNkVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJPQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREErR0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bVBBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQThHRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MFRBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQW1RRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsrS0FBRTtBQUNGLDhDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MEpBR3FCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0SEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7aUZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQVNHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7K1NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FUQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0WEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxUEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzsrSUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFvREc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OytHQWV5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztpRUF3Qm9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OE5BQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tEQUFFO0FBQ0YsMEdBVUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7MEtBQUU7QUFDRixvR0FXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7cURBa0M0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhPQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFBRTtBQUNGLHdGQVVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2lLQUFFO0FBQ0Ysa0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O2lHQU95QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxREFzQ21CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7dURBWW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d01BQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFBRTtBQUNGLDBGQVVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tLQUFFO0FBQ0Ysb0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7c0hBZW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b1FBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBQUU7QUFDRiw0RkFVRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzttS0FBRTtBQUNGLHNGQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzsrQkF5QnFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzsrR0FPb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c0tBR3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhJQUFFO0FBQ0YsMkJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b0pBQUU7QUFDRiw2QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvSkFBRTtBQUNGLDZCQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21LQUFFO0FBQ0Ysa0NBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MEpBQUU7QUFDRiwrQkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MElBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBOEJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxTkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBcUhHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswU0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFBRTtBQUNGLDRGQVVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O21LQUFFO0FBQ0Ysc0ZBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBQUU7QUFDRixnR0FVRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7cUtBQUU7QUFDRiwwRkFXRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7MklBUXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c2RBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt1S0FBRTtBQUNGLDhGQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tEQUFFO0FBQ0Ysd0VBVUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzsrQkF3QnlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIxIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBFdmVudEVtaXR0ZXIsIEluamVjdG9yLCBJbnB1dCwgVGVtcGxhdGVSZWYsIE91dHB1dCwgSG9zdEJpbmRpbmcsIENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBSZW5kZXJlcjIsIGlzRGV2TW9kZSwgRGlyZWN0aXZlLCBmb3J3YXJkUmVmLCBDb250ZW50Q2hpbGQsIFZpZXdDaGlsZCwgSG9zdExpc3RlbmVyLCBPcHRpb25hbCwgTmdab25lLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0LCBWaWV3Q29udGFpbmVyUmVmLCBWaWV3Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgQ29udGVudENoaWxkcmVuLCBJdGVyYWJsZURpZmZlcnMsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiwgTkdfVkFMSURBVE9SUywgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTG9jYWxpemF0aW9uU2VydmljZSwgTDEwTl9QUkVGSVgsIFJUTCwgQ29tcG9uZW50TWVzc2FnZXMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IGdldERhdGUsIGlzRXF1YWwsIGNsb25lRGF0ZSwgYWRkRGF5cywgYWRkRGVjYWRlcywgYWRkQ2VudHVyaWVzLCBmaXJzdERlY2FkZU9mQ2VudHVyeSwgbGFzdERlY2FkZU9mQ2VudHVyeSwgZmlyc3RZZWFyT2ZEZWNhZGUsIGNyZWF0ZURhdGUsIGxhc3RZZWFyT2ZEZWNhZGUsIGxhc3RNb250aE9mWWVhciwgbGFzdERheU9mTW9udGgsIGR1cmF0aW9uSW5DZW50dXJpZXMsIGFkZFllYXJzLCBkdXJhdGlvbkluRGVjYWRlcywgYWRkV2Vla3MsIGFkZE1vbnRocywgZmlyc3REYXlPZk1vbnRoLCBkYXlPZldlZWssIGR1cmF0aW9uSW5Nb250aHMsIGZpcnN0TW9udGhPZlllYXIsIGR1cmF0aW9uSW5ZZWFycywgd2Vla0luWWVhciB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1kYXRlLW1hdGgnO1xuaW1wb3J0IHsgaXNEb2N1bWVudEF2YWlsYWJsZSwgZ3VpZCwgS2V5cywgaGFzT2JzZXJ2ZXJzLCBLZW5kb0lucHV0LCBFdmVudHNNb2R1bGUsIFJlc2l6ZVNlbnNvck1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG5pbXBvcnQgeyB2YWxpZGF0ZVBhY2thZ2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tbGljZW5zaW5nJztcbmltcG9ydCB7IEludGxTZXJ2aWNlLCBJbnRsTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItaW50bCc7XG5pbXBvcnQgeyBTdWJqZWN0LCBTdWJzY3JpcHRpb24sIFJlcGxheVN1YmplY3QsIE9ic2VydmFibGUsIGNvbWJpbmVMYXRlc3QsIG9mLCBpbnRlcnZhbCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIsIGZyb21FdmVudCwgRU1QVFksIGZyb20sIEJlaGF2aW9yU3ViamVjdCwgbWVyZ2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgc2NhbiwgdGFrZVdoaWxlLCB0YXAsIGZpbHRlciwgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUG9wdXBTZXJ2aWNlLCBQb3B1cE1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXBvcHVwJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyB0b3VjaEVuYWJsZWQgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tY29tbW9uJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhY2thZ2VNZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZGF0ZWlucHV0cycsXG4gICAgcHJvZHVjdE5hbWU6ICdLZW5kbyBVSSBmb3IgQW5ndWxhcicsXG4gICAgcHJvZHVjdENvZGVzOiBbJ0tFTkRPVUlBTkdVTEFSJywgJ0tFTkRPVUlDT01QTEVURSddLFxuICAgIHB1Ymxpc2hEYXRlOiAxNjQ3MzU4NjQ5LFxuICAgIHZlcnNpb246ICcnLFxuICAgIGxpY2Vuc2luZ0RvY3NVcmw6ICdodHRwczovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL215LWxpY2Vuc2UvP3V0bV9tZWRpdW09cHJvZHVjdCZ1dG1fc291cmNlPWtlbmRvYW5ndWxhciZ1dG1fY2FtcGFpZ249a2VuZG8tdWktYW5ndWxhci1wdXJjaGFzZS1saWNlbnNlLWtleXMtd2FybmluZydcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgQWN0aW9uO1xuKGZ1bmN0aW9uIChBY3Rpb24pIHtcbiAgICBBY3Rpb25bQWN0aW9uW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XG4gICAgQWN0aW9uW0FjdGlvbltcIlJpZ2h0XCJdID0gMV0gPSBcIlJpZ2h0XCI7XG4gICAgQWN0aW9uW0FjdGlvbltcIlVwXCJdID0gMl0gPSBcIlVwXCI7XG4gICAgQWN0aW9uW0FjdGlvbltcIkRvd25cIl0gPSAzXSA9IFwiRG93blwiO1xuICAgIEFjdGlvbltBY3Rpb25bXCJQcmV2Vmlld1wiXSA9IDRdID0gXCJQcmV2Vmlld1wiO1xuICAgIEFjdGlvbltBY3Rpb25bXCJOZXh0Vmlld1wiXSA9IDVdID0gXCJOZXh0Vmlld1wiO1xuICAgIEFjdGlvbltBY3Rpb25bXCJGaXJzdEluVmlld1wiXSA9IDZdID0gXCJGaXJzdEluVmlld1wiO1xuICAgIEFjdGlvbltBY3Rpb25bXCJMYXN0SW5WaWV3XCJdID0gN10gPSBcIkxhc3RJblZpZXdcIjtcbiAgICBBY3Rpb25bQWN0aW9uW1wiTG93ZXJWaWV3XCJdID0gOF0gPSBcIkxvd2VyVmlld1wiO1xuICAgIEFjdGlvbltBY3Rpb25bXCJVcHBlclZpZXdcIl0gPSA5XSA9IFwiVXBwZXJWaWV3XCI7XG59KShBY3Rpb24gfHwgKEFjdGlvbiA9IHt9KSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBFTVBUWV9TRUxFQ1RJT05SQU5HRSA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgTUlETklHSFRfREFURSA9IG5ldyBEYXRlKDE5ODAsIDAsIDEpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE1JTl9EQVRFID0gbmV3IERhdGUoMTkwMCwgMCwgMSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgTUFYX0RBVEUgPSBuZXcgRGF0ZSgyMDk5LCAxMSwgMzEpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE1JTl9USU1FID0gbmV3IERhdGUoMTk4MCwgMCwgMSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgTUFYX1RJTUUgPSBuZXcgRGF0ZSgxOTgwLCAwLCAxLCAyMywgNTksIDU5KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHJlcXVpcmVzWm9uZU9uQmx1ciA9IChuZ0NvbnRyb2wpID0+IG5nQ29udHJvbCAmJlxuICAgICghbmdDb250cm9sLnRvdWNoZWQgfHwgKG5nQ29udHJvbC5jb250cm9sICYmIG5nQ29udHJvbC5jb250cm9sLnVwZGF0ZU9uID09PSAnYmx1cicpKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwcmV2ZW50RGVmYXVsdCA9IChhcmdzKSA9PiBhcmdzLnByZXZlbnREZWZhdWx0KCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY3VycmVudEZvY3VzVGFyZ2V0ID0gKGJsdXJBcmdzKSA9PiBibHVyQXJncy5yZWxhdGVkVGFyZ2V0IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNQcmVzZW50ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogSWYgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBpdGVtXG4gKiBhbmQgYWxsIGl0ZW1zIGluIHRoZSBhcnJheSBhcmUgbnVtYmVycywgcmV0dXJucyBgdHJ1ZS5cbiAqL1xuY29uc3QgaXNOdW1iZXJBcnJheSA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZS5ldmVyeShpdGVtID0+IHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBJZiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGFuIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGl0ZW1cbiAqIGFuZCBhbGwgaXRlbXMgaW4gdGhlIGFycmF5IGFyZSBkYXRlcywgcmV0dXJucyBgdHJ1ZWAuXG4gKi9cbmNvbnN0IGlzRGF0ZUFycmF5ID0gKHZhbHVlKSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlLmV2ZXJ5KGl0ZW0gPT4gaXRlbSBpbnN0YW5jZW9mIERhdGUpO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1iaXR3aXNlIG1heC1saW5lLWxlbmd0aCAqL1xuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG5jb25zdCBzZXR0ZXIgPSAobWV0aG9kKSA9PiAoZGF0ZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBjbG9uZSA9IGNsb25lRGF0ZShkYXRlKTtcbiAgICBjbG9uZVttZXRob2RdKHZhbHVlKTtcbiAgICByZXR1cm4gY2xvbmU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNldFRpbWUgPSAob3JpZ2luLCBjYW5kaWRhdGUpID0+IHtcbiAgICBjb25zdCBkYXRlID0gY2xvbmVEYXRlKG9yaWdpbik7XG4gICAgZGF0ZS5zZXRIb3VycyhjYW5kaWRhdGUuZ2V0SG91cnMoKSwgY2FuZGlkYXRlLmdldE1pbnV0ZXMoKSwgY2FuZGlkYXRlLmdldFNlY29uZHMoKSwgY2FuZGlkYXRlLmdldE1pbGxpc2Vjb25kcygpKTtcbiAgICByZXR1cm4gZGF0ZTtcbn07XG5jb25zdCBub3JtYWxpemVUaW1lcyA9IChjYW5kaWRhdGUsIG1pbiwgbWF4KSA9PiAoe1xuICAgIGNhbmRpZGF0ZVZhbHVlOiBzZXRUaW1lKE1JRE5JR0hUX0RBVEUsIGNhbmRpZGF0ZSksXG4gICAgbWF4VmFsdWU6IGFkZERheXMoc2V0VGltZShNSUROSUdIVF9EQVRFLCBtYXgpLCBtaW4uZ2V0SG91cnMoKSA8IG1heC5nZXRIb3VycygpIHx8XG4gICAgICAgIChtaW4uZ2V0SG91cnMoKSA9PT0gbWF4LmdldEhvdXJzKCkgJiYgbWluLmdldE1pbnV0ZXMoKSA8IG1heC5nZXRNaW51dGVzKCkpID8gMCA6IDEpLFxuICAgIG1pblZhbHVlOiBzZXRUaW1lKE1JRE5JR0hUX0RBVEUsIG1pbilcbn0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNldFllYXJzID0gc2V0dGVyKCdzZXRGdWxsWWVhcicpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNldEhvdXJzID0gc2V0dGVyKCdzZXRIb3VycycpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNldE1pbnV0ZXMgPSBzZXR0ZXIoJ3NldE1pbnV0ZXMnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzZXRTZWNvbmRzID0gc2V0dGVyKCdzZXRTZWNvbmRzJyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc2V0TWlsbGlzZWNvbmRzID0gc2V0dGVyKCdzZXRNaWxsaXNlY29uZHMnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCByYW5nZSA9IChzdGFydCwgZW5kLCBzdGVwID0gMSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSA9IGkgKyBzdGVwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0luUmFuZ2UgPSAoY2FuZGlkYXRlLCBtaW4sIG1heCkgPT4gKCFjYW5kaWRhdGUgfHwgISgobWluICYmIG1pbiA+IGNhbmRpZGF0ZSkgfHwgKG1heCAmJiBtYXggPCBjYW5kaWRhdGUpKSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNJblRpbWVSYW5nZSA9IChjYW5kaWRhdGUsIG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKCFjYW5kaWRhdGUgfHwgIW1pbiB8fCAhbWF4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7IGNhbmRpZGF0ZVZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUgfSA9IG5vcm1hbGl6ZVRpbWVzKGNhbmRpZGF0ZSwgbWluLCBtYXgpO1xuICAgIHJldHVybiBtaW5WYWx1ZSA8PSBjYW5kaWRhdGVWYWx1ZSAmJiBjYW5kaWRhdGVWYWx1ZSA8PSBtYXhWYWx1ZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNWYWxpZFJhbmdlID0gKG1pbiwgbWF4KSA9PiAoIWlzU2V0KG1pbikgfHwgIWlzU2V0KG1heCkgfHwgbWluIDw9IG1heCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGF0ZUluUmFuZ2UgPSAoY2FuZGlkYXRlLCBtaW4sIG1heCkgPT4ge1xuICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfVxuICAgIGlmIChtaW4gJiYgY2FuZGlkYXRlIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBjbG9uZURhdGUobWluKTtcbiAgICB9XG4gICAgaWYgKG1heCAmJiBjYW5kaWRhdGUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lRGF0ZShtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuZGlkYXRlO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0aW1lSW5SYW5nZSA9IChjYW5kaWRhdGUsIG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKCFjYW5kaWRhdGUgfHwgIW1pbiB8fCAhbWF4KSB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfVxuICAgIGNvbnN0IHsgY2FuZGlkYXRlVmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSB9ID0gbm9ybWFsaXplVGltZXMoY2FuZGlkYXRlLCBtaW4sIG1heCk7XG4gICAgaWYgKGNhbmRpZGF0ZVZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHNldFRpbWUoY2FuZGlkYXRlLCBtaW4pO1xuICAgIH1cbiAgICBpZiAoY2FuZGlkYXRlVmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICByZXR1cm4gc2V0VGltZShjYW5kaWRhdGUsIG1heCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5kaWRhdGU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldE5vdyA9ICgpID0+IG5ldyBEYXRlKCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2V0VG9kYXkgPSAoKSA9PiBnZXREYXRlKG5ldyBEYXRlKCkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG5vb3AgPSAoXykgPT4geyB9OyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWVtcHR5XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNXaW5kb3dBdmFpbGFibGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzdHJpbmdpZnlDbGFzc09iamVjdCA9IChjbGFzc2VzKSA9PiB7XG4gICAgY29uc3QgcHVzaFRvQWNjID0gKGFjYywgY2xzKSA9PiBjbGFzc2VzW2Nsc10gPyBhY2MuY29uY2F0KGNscykgOiBhY2M7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNsYXNzZXMpLnJlZHVjZShwdXNoVG9BY2MsIFtdKS5qb2luKCcgJyk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNoaWZ0V2Vla05hbWVzID0gKG5hbWVzLCBvZmZzZXQpID0+IChuYW1lcy5zbGljZShvZmZzZXQpLmNvbmNhdChuYW1lcy5zbGljZSgwLCBvZmZzZXQpKSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgYXBwcm94aW1hdGVTdHJpbmdNYXRjaGluZyA9IChvbGRUZXh0T3JpZ2luLCBvbGRGb3JtYXQsIG5ld1RleHRPcmlnaW4sIGNhcmV0KSA9PiB7XG4gICAgLy8gUmVtb3ZlIHRoZSByaWdodCBwYXJ0IG9mIHRoZSBjdXJzb3IuXG4gICAgLy9vbGRGb3JtYXQgPSBvbGRGb3JtYXQuc3Vic3RyaW5nKDAsIGNhcmV0ICsgb2xkVGV4dC5sZW5ndGggLSBuZXdUZXh0Lmxlbmd0aCk7XG4gICAgY29uc3Qgb2xkSW5kZXggPSBjYXJldCArIG9sZFRleHRPcmlnaW4ubGVuZ3RoIC0gbmV3VGV4dE9yaWdpbi5sZW5ndGg7XG4gICAgY29uc3Qgb2xkVGV4dFNlcGFyYXRvciA9IG9sZFRleHRPcmlnaW5bb2xkSW5kZXhdO1xuICAgIGNvbnN0IG9sZFRleHQgPSBvbGRUZXh0T3JpZ2luLnN1YnN0cmluZygwLCBjYXJldCArIG9sZFRleHRPcmlnaW4ubGVuZ3RoIC0gbmV3VGV4dE9yaWdpbi5sZW5ndGgpO1xuICAgIGNvbnN0IG5ld1RleHQgPSBuZXdUZXh0T3JpZ2luLnN1YnN0cmluZygwLCBjYXJldCk7XG4gICAgY29uc3QgZGlmZiA9IFtdO1xuICAgIC8vIEhhbmRsZSB0eXBpbmcgYSBzaW5nbGUgY2hhcmFjdGVyIG92ZXIgdGhlIHNhbWUgc2VsZWN0aW9uLlxuICAgIGlmIChvbGRUZXh0ID09PSBuZXdUZXh0ICYmIGNhcmV0ID4gMCkge1xuICAgICAgICBkaWZmLnB1c2goW29sZEZvcm1hdFtjYXJldCAtIDFdLCBuZXdUZXh0W2NhcmV0IC0gMV1dKTtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgfVxuICAgIGlmIChvbGRUZXh0LmluZGV4T2YobmV3VGV4dCkgPT09IDAgJiYgKG5ld1RleHQubGVuZ3RoID09PSAwIHx8IG9sZEZvcm1hdFtuZXdUZXh0Lmxlbmd0aCAtIDFdICE9PSBvbGRGb3JtYXRbbmV3VGV4dC5sZW5ndGhdKSkge1xuICAgICAgICAvLyBIYW5kbGUgRGVsZXRlL0JhY2tzcGFjZS5cbiAgICAgICAgbGV0IGRlbGV0ZWRTeW1ib2wgPSBcIlwiO1xuICAgICAgICAvL1hYWDpcbiAgICAgICAgLy8gV2hvbGUgdGV4dCBpcyByZXBsYWNlZCB3aXRoIGEgc2FtZSBjaGFyXG4gICAgICAgIC8vIE5hc3R5IHBhdGNoIHJlcXVpcmVkIHRvIGtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgZmlyc3Qgc2VnbWVudFxuICAgICAgICBpZiAobmV3VGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRpZmYucHVzaChbb2xkRm9ybWF0WzBdLCBuZXdUZXh0WzBdXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IG5ld1RleHQubGVuZ3RoOyBpIDwgb2xkVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9sZEZvcm1hdFtpXSAhPT0gZGVsZXRlZFN5bWJvbCAmJiBvbGRGb3JtYXRbaV0gIT09IFwiX1wiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlZFN5bWJvbCA9IG9sZEZvcm1hdFtpXTtcbiAgICAgICAgICAgICAgICBkaWZmLnB1c2goW2RlbGV0ZWRTeW1ib2wsIFwiXCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGluc2VydGluZyB0ZXh0ICh0aGUgbmV3IHRleHQgaXMgbG9uZ2VyIHRoYW4gdGhlIHByZXZpb3VzIG9uZSkuXG4gICAgLy8gSGFuZGxlIHR5cGluZyBvdmVyIGEgbGl0ZXJhbCBhcyB3ZWxsLlxuICAgIGlmIChuZXdUZXh0LmluZGV4T2Yob2xkVGV4dCkgPT09IDAgfHwgb2xkRm9ybWF0W2NhcmV0IC0gMV0gPT09IFwiX1wiKSB7XG4gICAgICAgIGxldCBzeW1ib2wgPSBvbGRGb3JtYXRbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBvbGRUZXh0Lmxlbmd0aCAtIDEpOyBpIDwgb2xkRm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob2xkRm9ybWF0W2ldICE9PSBcIl9cIikge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG9sZEZvcm1hdFtpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1tzeW1ib2wsIG5ld1RleHRbY2FyZXQgLSAxXV1dO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgZW50ZXJpbmcgYSBzcGFjZSBvciBhIHNlcGFyYXRvciwgZm9yIG5hdmlnYXRpb24gdG8gdGhlIG5leHQgaXRlbS5cbiAgICBpZiAobmV3VGV4dFtuZXdUZXh0Lmxlbmd0aCAtIDFdID09PSBcIiBcIiB8fCAobmV3VGV4dFtuZXdUZXh0Lmxlbmd0aCAtIDFdID09PSBvbGRUZXh0U2VwYXJhdG9yICYmIG9sZEZvcm1hdFtvbGRJbmRleF0gPT09ICdfJykpIHtcbiAgICAgICAgcmV0dXJuIFtbb2xkRm9ybWF0W2NhcmV0IC0gMV0sIFwiX1wiXV07XG4gICAgfVxuICAgIC8vIEhhbmRsZSB0eXBpbmcgb3ZlciBhIGNvcnJlY3RseSBzZWxlY3RlZCBwYXJ0LlxuICAgIHJldHVybiBbW29sZEZvcm1hdFtjYXJldCAtIDFdLCBuZXdUZXh0W2NhcmV0IC0gMV1dXTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZG9tQ29udGFpbmVyRmFjdG9yeSA9ICh0eXBlKSA9PiAoY2hpbGRyZW4sIGNsYXNzZXMgPSBcIlwiLCBzdHlsZXMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IGNsYXNzZXM7XG4gICAgT2JqZWN0LmtleXMoc3R5bGVzKS5tYXAoa2V5ID0+IGNvbnRhaW5lci5zdHlsZVtrZXldID0gc3R5bGVzW2tleV0pO1xuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBjaGlsZHJlbiB8fCAnJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIChjaGlsZHJlbiB8fCBbXSkuZm9yRWFjaChjaGlsZCA9PiBjaGlsZCAmJiBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzQ2hhbmdlID0gKGNoYW5nZXMsIGZpZWxkKSA9PiBjaGFuZ2VzW2ZpZWxkXSAhPT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc0V4aXN0aW5nVmFsdWUgPSAoY2hhbmdlcywgZmllbGQpID0+IGNoYW5nZXNbZmllbGRdICYmIGNoYW5nZXNbZmllbGRdLmN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGNoYW5nZXNbZmllbGRdLmN1cnJlbnRWYWx1ZSAhPT0gbnVsbDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBsYXN0ID0gKGxpc3QgPSBbXSkgPT4gbGlzdCAmJiBsaXN0W2xpc3QubGVuZ3RoIC0gMV07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNJblNlbGVjdGlvblJhbmdlID0gKHZhbHVlLCBzZWxlY3Rpb25SYW5nZSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gc2VsZWN0aW9uUmFuZ2UgfHwgRU1QVFlfU0VMRUNUSU9OUkFOR0U7XG4gICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0IDwgdmFsdWUgJiYgdmFsdWUgPCBlbmQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGVpdGhlciA9ICh2YWx1ZTEsIHZhbHVlMikgPT4gdmFsdWUxIHx8IHZhbHVlMjtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbGFtcFJhbmdlID0gKHZhbHVlKSA9PiAoeyBzdGFydDogdmFsdWUsIGVuZDogdmFsdWUgfSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNFcXVhbFJhbmdlID0gKGluaXRpYWwsIHVwZGF0ZWQpID0+IHtcbiAgICBjb25zdCB7IHN0YXJ0OiBpbml0aWFsU3RhcnQsIGVuZDogaW5pdGlhbEVuZCB9ID0gaW5pdGlhbCB8fCBFTVBUWV9TRUxFQ1RJT05SQU5HRTtcbiAgICBjb25zdCB7IHN0YXJ0OiB1cGRhdGVkU3RhcnQsIGVuZDogdXBkYXRlZEVuZCB9ID0gdXBkYXRlZCB8fCBFTVBUWV9TRUxFQ1RJT05SQU5HRTtcbiAgICByZXR1cm4gaXNFcXVhbChpbml0aWFsU3RhcnQsIHVwZGF0ZWRTdGFydCkgJiYgaXNFcXVhbChpbml0aWFsRW5kLCB1cGRhdGVkRW5kKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgYXJlRGF0ZXNFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgZmlyc3QgPSBmaXJzdCB8fCBbXTtcbiAgICBzZWNvbmQgPSBzZWNvbmQgfHwgW107XG4gICAgcmV0dXJuIGZpcnN0Lmxlbmd0aCA9PT0gc2Vjb25kLmxlbmd0aCAmJiBmaXJzdC5ldmVyeSgoZGF0ZSwgaW5kZXgpID0+IGlzRXF1YWwoZGF0ZSwgc2Vjb25kW2luZGV4XSkpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzb3J0RGF0ZXMgPSAoZGF0ZXMpID0+IHtcbiAgICByZXR1cm4gZGF0ZXMuZmlsdGVyKGRhdGUgPT4gaXNQcmVzZW50KGRhdGUpKS5zb3J0KChhLCBiKSA9PiBhLmdldFRpbWUoKSAtIGIuZ2V0VGltZSgpKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBDcmVhdGVzIGEgbmV3IGRhdGUgYmFzZWQgb24gdGhlIGRhdGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgc3BlY2lmaWVkIGRhdGUgcG9ydGlvblxuICogYW5kIHRoZSB0aW1lIGluZm9ybWF0aW9uIGZyb20gdGhlIHRpbWUgcG9ydGlvbi5cbiAqIElmIGEgcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZCwgcmV0dXJucyBgbnVsbGAuXG4gKi9cbmNvbnN0IG1lcmdlRGF0ZUFuZFRpbWUgPSAoZGF0ZSwgdGltZSkgPT4ge1xuICAgIGlmICghKGRhdGUgJiYgdGltZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIHRpbWUuZ2V0SG91cnMoKSwgdGltZS5nZXRNaW51dGVzKCksIHRpbWUuZ2V0U2Vjb25kcygpLCB0aW1lLmdldE1pbGxpc2Vjb25kcygpKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbGFzdE1pbGxpc2Vjb25kT2ZEYXRlID0gKGRhdGUpID0+IHtcbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIDIzLCA1OSwgNTksIDk5OSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmV0dXJucyBhbiBhcnJheSB3aXRoIGRhdGVzIHJhbmdpbmcgYmV0d2VlbiBhbmQgaW5jbHVkaW5nIHRoZSBzcGVjaWZpZWQgc3RhcnQgYW5kXG4gKiBlbmQgZGF0ZXMgdGhhdCBhcmUgZXZhbHVhdGVkIGFzIGRpc2FibGVkLlxuICovXG5jb25zdCBkaXNhYmxlZERhdGVzSW5SYW5nZSA9IChzdGFydCwgZW5kLCBpc0RhdGVEaXNhYmxlZCkgPT4ge1xuICAgIGlmICghKHN0YXJ0ICYmIGVuZCAmJiBpc0RhdGVEaXNhYmxlZCkgfHwgKHN0YXJ0ID4gZW5kKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGRhdGVzID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSBzdGFydDtcbiAgICB3aGlsZSAoY3VycmVudCA8PSBlbmQpIHtcbiAgICAgICAgaWYgKGlzRGF0ZURpc2FibGVkKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBkYXRlcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBhZGREYXlzKGN1cnJlbnQsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZXM7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogQ3JvcHMgdGhlIGxhc3QgdHdvIGRpZ2l0cyBmcm9tIHRoZSB5ZWFyIG9mIHRoZSBwcm92aWRlZCBkYXRlIHZhbHVlLlxuICovXG5jb25zdCBjcm9wVHdvRGlnaXRZZWFyID0gKGRhdGUpID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudChkYXRlKSB8fCBpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIoZGF0ZVxuICAgICAgICAuZ2V0RnVsbFllYXIoKVxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAuc2xpY2UoLTIpKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBVc2VkIHdoZW4gcmVzZXR0aW5nIG1pbGxpc2Vjb25kIHNlZ21lbnQgdmFsdWUgaW4gdGhlIERhdGVJbnB1dFxuICovXG5jb25zdCBtc1BhZGRpbmdGcm9tRm9ybWF0ID0gKGZvcm1hdCkgPT4ge1xuICAgIHJldHVybiBBcnJheShmb3JtYXQubWF0Y2goL1MrKFxcMSkvKVswXS5sZW5ndGgpLmpvaW4oXCIwXCIpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBtaWxsaXNlY29uZERpZ2l0c0luRm9ybWF0ID0gKGZvcm1hdCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdCAmJiBmb3JtYXQubWF0Y2goL1MrKFxcMSkvKTtcbiAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0WzBdLmxlbmd0aCA6IDA7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG1pbGxpc2Vjb25kU3RlcEZvciA9IChkaWdpdHMpID0+IHtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIDMgLSBkaWdpdHMpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIENoZWNrcyBpZiBhIHRhYiBrZXlkb3duIHdvdWxkIHdvdWxkIG1vdmUgdGhlIGZvY3VzIG91dHNpZGUgb2YgdGhlIGNhbGVuZGFyLlxuICovXG5jb25zdCBpc1RhYkV4aXRpbmdDYWxlbmRhciA9IChjYWxlbmRhclR5cGUsIGZvY3VzZWRFbGVtZW50LCBzaGlmdEtleSkgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KGZvY3VzZWRFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjYWxlbmRhclR5cGUgPT09ICdpbmZpbml0ZScgfHwgKCAvLyBpbmZpbnRlIGNhbGVuZGFyIGlzIGFsd2F5cyBleGl0ZWQgb24gZmlyc3QgdGFiIGtleWRvd25cbiAgICBjYWxlbmRhclR5cGUgPT09ICdjbGFzc2ljJyAmJlxuICAgICAgICAoc2hpZnRLZXkgJiYgZm9jdXNlZEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdrLWNhbGVuZGFyJykpIHx8IC8vIGV4aXRlZCBvbiBtYWluIGNhbGVuZGFyIGVsZW1lbnQgZm9jdXNlZCBhbmQgYmFjay10YWJcbiAgICAgICAgKCFzaGlmdEtleSAmJiBmb2N1c2VkRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2stbmV4dC12aWV3JykpIC8vIGV4aXRlZCBvbiBuZXh0IGJ1dHRvbiBmb2N1c2VkIGFuZCByZWd1bGFyIHRhYlxuICAgICk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKiBSZXR1cm5zIHRoZSBzaXplIGNsYXNzIGJhc2VkIG9uIHRoZSBjb21wb25lbnQgYW5kIHNpemUgaW5wdXQuXG4gKi9cbmNvbnN0IGdldFNpemVDbGFzcyA9IChjb21wb25lbnQsIHNpemUpID0+IHtcbiAgICBjb25zdCBTSVpFX0NMQVNTRVMgPSB7XG4gICAgICAgICdzbWFsbCc6IGBrLSR7Y29tcG9uZW50fS1zbWAsXG4gICAgICAgICdtZWRpdW0nOiBgay0ke2NvbXBvbmVudH0tbWRgLFxuICAgICAgICAnbGFyZ2UnOiBgay0ke2NvbXBvbmVudH0tbGdgXG4gICAgfTtcbiAgICByZXR1cm4gU0laRV9DTEFTU0VTW3NpemVdO1xufTtcbi8qKlxuICogQGhpZGRlblxuICogUmV0dXJucyB0aGUgcm91bmRlZCBjbGFzcyBiYXNlZCBvbiB0aGUgcm91bmRlZCBpbnB1dC5cbiAqL1xuY29uc3QgZ2V0Um91bmRlZENsYXNzID0gKHJvdW5kZWQpID0+IHtcbiAgICBjb25zdCBST1VOREVEX0NMQVNTRVMgPSB7XG4gICAgICAgICdzbWFsbCc6ICdrLXJvdW5kZWQtc20nLFxuICAgICAgICAnbWVkaXVtJzogJ2stcm91bmRlZC1tZCcsXG4gICAgICAgICdsYXJnZSc6ICdrLXJvdW5kZWQtbGcnLFxuICAgICAgICAnZnVsbCc6ICdrLXJvdW5kZWQtZnVsbCdcbiAgICB9O1xuICAgIHJldHVybiBST1VOREVEX0NMQVNTRVNbcm91bmRlZF07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKiBSZXR1cm4gdGhlIGZpbGxNb2RlIGNsYXNzIGJhc2VkIG9uIHRoZSBjb21wb25lbnQgYW5kIGZpbGxNb2RlIGlucHV0LlxuICovXG5jb25zdCBnZXRGaWxsTW9kZUNsYXNzID0gKGNvbXBvbmVudCwgZmlsbE1vZGUpID0+IHtcbiAgICBjb25zdCBGSUxMTU9ERV9DTEFTU0VTID0ge1xuICAgICAgICAnc29saWQnOiBgay0ke2NvbXBvbmVudH0tc29saWRgLFxuICAgICAgICAnZmxhdCc6IGBrLSR7Y29tcG9uZW50fS1mbGF0YCxcbiAgICAgICAgJ291dGxpbmUnOiBgay0ke2NvbXBvbmVudH0tb3V0bGluZWBcbiAgICB9O1xuICAgIHJldHVybiBGSUxMTU9ERV9DTEFTU0VTW2ZpbGxNb2RlXTtcbn07XG5cbmNvbnN0IEVNUFRZX0RBVEEgPSBbW11dO1xuY29uc3QgQ0VMTFNfTEVOR1RIID0gNDtcbmNvbnN0IFJPV1NfTEVOR1RIID0gMztcbmNvbnN0IEFDVElPTlMgPSB7XG4gICAgW0FjdGlvbi5MZWZ0XTogKGRhdGUpID0+IGFkZERlY2FkZXMoZGF0ZSwgLTEpLFxuICAgIFtBY3Rpb24uVXBdOiAoZGF0ZSkgPT4gYWRkRGVjYWRlcyhkYXRlLCAtNSksXG4gICAgW0FjdGlvbi5SaWdodF06IChkYXRlKSA9PiBhZGREZWNhZGVzKGRhdGUsIDEpLFxuICAgIFtBY3Rpb24uRG93bl06IChkYXRlKSA9PiBhZGREZWNhZGVzKGRhdGUsIDUpLFxuICAgIFtBY3Rpb24uUHJldlZpZXddOiAoZGF0ZSkgPT4gYWRkQ2VudHVyaWVzKGRhdGUsIC0xKSxcbiAgICBbQWN0aW9uLk5leHRWaWV3XTogKGRhdGUpID0+IGFkZENlbnR1cmllcyhkYXRlLCAxKSxcbiAgICBbQWN0aW9uLkZpcnN0SW5WaWV3XTogKGRhdGUpID0+IGZpcnN0RGVjYWRlT2ZDZW50dXJ5KGRhdGUpLFxuICAgIFtBY3Rpb24uTGFzdEluVmlld106IChkYXRlKSA9PiBsYXN0RGVjYWRlT2ZDZW50dXJ5KGRhdGUpXG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDZW50dXJ5Vmlld1NlcnZpY2UgPSBjbGFzcyBDZW50dXJ5Vmlld1NlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2UgPSAoc3RhcnQsIGVuZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoc3RhcnQpIHx8ICFpc1ByZXNlbnQoZW5kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBzdGFydDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50IDw9IGVuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBhZGREZWNhZGVzKGN1cnJlbnQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkVG9EYXRlKG1pbiwgc2tpcCkge1xuICAgICAgICByZXR1cm4gYWRkQ2VudHVyaWVzKG1pbiwgc2tpcCk7XG4gICAgfVxuICAgIGRhdGVzTGlzdChzdGFydCwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlKDAsIGNvdW50KS5tYXAoaSA9PiBhZGRDZW50dXJpZXMoc3RhcnQsIGkpKTtcbiAgICB9XG4gICAgZGF0YShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgY2VsbFVJRCwgZm9jdXNlZERhdGUsIGlzQWN0aXZlVmlldywgbWF4LCBtaW4sIHNlbGVjdGVkRGF0ZXMsIHNlbGVjdGlvblJhbmdlID0gRU1QVFlfU0VMRUNUSU9OUkFOR0UsIHZpZXdEYXRlIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoIXZpZXdEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfREFUQTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZWxscyA9IHJhbmdlKDAsIENFTExTX0xFTkdUSCk7XG4gICAgICAgIGNvbnN0IGZpcnN0RGF0ZSA9IGZpcnN0RGVjYWRlT2ZDZW50dXJ5KHZpZXdEYXRlKTtcbiAgICAgICAgY29uc3QgbGFzdERhdGUgPSBsYXN0RGVjYWRlT2ZDZW50dXJ5KHZpZXdEYXRlKTtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBnZXRUb2RheSgpO1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgUk9XU19MRU5HVEgpLm1hcChyb3dPZmZzZXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmFzZURhdGUgPSBhZGREZWNhZGVzKGZpcnN0RGF0ZSwgcm93T2Zmc2V0ICogQ0VMTFNfTEVOR1RIKTtcbiAgICAgICAgICAgIHJldHVybiBjZWxscy5tYXAoY2VsbE9mZnNldCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbERhdGUgPSB0aGlzLm5vcm1hbGl6ZShhZGREZWNhZGVzKGJhc2VEYXRlLCBjZWxsT2Zmc2V0KSwgbWluLCBtYXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDZW50dXJ5ID0gY2VsbERhdGUuZ2V0RnVsbFllYXIoKSA+IGxhc3REYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5SYW5nZShjZWxsRGF0ZSwgbWluLCBtYXgpIHx8IG5leHRDZW50dXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc1JhbmdlU3RhcnQgPSB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIHNlbGVjdGlvblJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JhbmdlRW5kID0gdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBzZWxlY3Rpb25SYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzSW5NaWRkbGUgPSAhaXNSYW5nZVN0YXJ0ICYmICFpc1JhbmdlRW5kO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmFuZ2VNaWQgPSBpc0luTWlkZGxlICYmIGlzSW5TZWxlY3Rpb25SYW5nZShjZWxsRGF0ZSwgc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiB0aGlzLnZhbHVlKGNlbGxEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGAke2NlbGxVSUR9JHtjZWxsRGF0ZS5nZXRUaW1lKCl9YCxcbiAgICAgICAgICAgICAgICAgICAgaXNGb2N1c2VkOiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIGZvY3VzZWREYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZDogaXNBY3RpdmVWaWV3ICYmIHNlbGVjdGVkRGF0ZXMuc29tZShkYXRlID0+IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgZGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICBpc1dlZWtlbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlU3RhcnQ6IGlzUmFuZ2VTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZU1pZDogaXNSYW5nZU1pZCxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZUVuZDogaXNSYW5nZUVuZCxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZVNwbGl0RW5kOiBpc1JhbmdlTWlkICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgbGFzdERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlU3BsaXRTdGFydDogaXNSYW5nZU1pZCAmJiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIGZpcnN0RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlzVG9kYXk6IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgdG9kYXkpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5jZWxsVGl0bGUoY2VsbERhdGUpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2VsbERhdGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0VxdWFsKGNhbmRpZGF0ZSwgZXhwZWN0ZWQpIHtcbiAgICAgICAgaWYgKCFjYW5kaWRhdGUgfHwgIWV4cGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpcnN0WWVhck9mRGVjYWRlKGNhbmRpZGF0ZSkuZ2V0RnVsbFllYXIoKSA9PT0gZmlyc3RZZWFyT2ZEZWNhZGUoZXhwZWN0ZWQpLmdldEZ1bGxZZWFyKCk7XG4gICAgfVxuICAgIGlzSW5BcnJheShkYXRlLCBkYXRlcykge1xuICAgICAgICBpZiAoIWRhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHJldHVybiBkYXRlc1swXS5nZXRGdWxsWWVhcigpIDw9IHllYXIgJiYgeWVhciA8PSAoZGF0ZXNbZGF0ZXMubGVuZ3RoIC0gMV0uZ2V0RnVsbFllYXIoKSArIDk5KTtcbiAgICB9XG4gICAgaXNJblJhbmdlKGNhbmRpZGF0ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgeWVhciA9IGZpcnN0WWVhck9mRGVjYWRlKGNhbmRpZGF0ZSkuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgY29uc3QgYWJvdmVNaW4gPSAhbWluIHx8IGZpcnN0WWVhck9mRGVjYWRlKG1pbikuZ2V0RnVsbFllYXIoKSA8PSB5ZWFyO1xuICAgICAgICBjb25zdCBiZWxvd01heCA9ICFtYXggfHwgeWVhciA8PSBmaXJzdFllYXJPZkRlY2FkZShtYXgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHJldHVybiBhYm92ZU1pbiAmJiBiZWxvd01heDtcbiAgICB9XG4gICAgYmVnaW5uaW5nT2ZQZXJpb2QoZGF0ZSkge1xuICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0WWVhciA9IGZpcnN0WWVhck9mRGVjYWRlKGZpcnN0RGVjYWRlT2ZDZW50dXJ5KGRhdGUpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURhdGUoZmlyc3RZZWFyLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICAgIH1cbiAgICBsYXN0RGF5T2ZQZXJpb2QoZGF0ZSkge1xuICAgICAgICBjb25zdCBkZWNhZGUgPSBsYXN0RGVjYWRlT2ZDZW50dXJ5KGRhdGUpO1xuICAgICAgICBjb25zdCB5ZWFyID0gbGFzdFllYXJPZkRlY2FkZShkZWNhZGUpO1xuICAgICAgICBjb25zdCBtb250aCA9IGxhc3RNb250aE9mWWVhcih5ZWFyKTtcbiAgICAgICAgcmV0dXJuIGxhc3REYXlPZk1vbnRoKG1vbnRoKTtcbiAgICB9XG4gICAgaXNSYW5nZVN0YXJ0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5nZXRGdWxsWWVhcigpICUgMTAwMCA9PT0gMDtcbiAgICB9XG4gICAgbW92ZSh2YWx1ZSwgYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gQUNUSU9OU1thY3Rpb25dO1xuICAgICAgICBpZiAoIW1vZGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGlmaWVyKHZhbHVlKTtcbiAgICB9XG4gICAgY2VsbFRpdGxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmaXJzdFllYXJPZkRlY2FkZSh2YWx1ZSkuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBuYXZpZ2F0aW9uVGl0bGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gZmlyc3REZWNhZGVPZkNlbnR1cnkodmFsdWUpLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSA6ICcnO1xuICAgIH1cbiAgICB0aXRsZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2ZpcnN0RGVjYWRlT2ZDZW50dXJ5KHZhbHVlKS5nZXRGdWxsWWVhcigpfSAtICR7bGFzdERlY2FkZU9mQ2VudHVyeSh2YWx1ZSkuZ2V0RnVsbFllYXIoKX1gO1xuICAgIH1cbiAgICByb3dMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiBDRUxMU19MRU5HVEg7XG4gICAgfVxuICAgIHNraXAodmFsdWUsIG1pbikge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25JbkNlbnR1cmllcyhtaW4sIHZhbHVlKTtcbiAgICB9XG4gICAgdG90YWwobWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uSW5DZW50dXJpZXMobWluLCBtYXgpICsgMTtcbiAgICB9XG4gICAgdmFsdWUoY3VycmVudCkge1xuICAgICAgICByZXR1cm4gY3VycmVudCA/IGZpcnN0WWVhck9mRGVjYWRlKGN1cnJlbnQpLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSA6ICcnO1xuICAgIH1cbiAgICB2aWV3RGF0ZShkYXRlLCBtYXgsIHZpZXdzQ291bnQgPSAxKSB7XG4gICAgICAgIGNvbnN0IHZpZXdzSW5SYW5nZSA9IHRoaXMudG90YWwoZGF0ZSwgbWF4KTtcbiAgICAgICAgaWYgKHZpZXdzSW5SYW5nZSA8IHZpZXdzQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbnR1cmllc1RvU3VidHJhY3QgPSB2aWV3c0NvdW50IC0gdmlld3NJblJhbmdlO1xuICAgICAgICAgICAgcmV0dXJuIGFkZENlbnR1cmllcyhkYXRlLCAtMSAqIGNlbnR1cmllc1RvU3VidHJhY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBub3JtYWxpemUoY2VsbERhdGUsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmIChjZWxsRGF0ZSA8IG1pbiAmJiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIG1pbikpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZURhdGUobWluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbERhdGUgPiBtYXggJiYgdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBtYXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVEYXRlKG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGxEYXRlO1xuICAgIH1cbn07XG5DZW50dXJ5Vmlld1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIENlbnR1cnlWaWV3U2VydmljZSk7XG5cbmNvbnN0IEVNUFRZX0RBVEEkMSA9IFtbXV07XG5jb25zdCBDRUxMU19MRU5HVEgkMSA9IDQ7XG5jb25zdCBST1dTX0xFTkdUSCQxID0gMztcbmNvbnN0IEFDVElPTlMkMSA9IHtcbiAgICBbQWN0aW9uLkxlZnRdOiAoZGF0ZSkgPT4gYWRkWWVhcnMoZGF0ZSwgLTEpLFxuICAgIFtBY3Rpb24uVXBdOiAoZGF0ZSkgPT4gYWRkWWVhcnMoZGF0ZSwgLTUpLFxuICAgIFtBY3Rpb24uUmlnaHRdOiAoZGF0ZSkgPT4gYWRkWWVhcnMoZGF0ZSwgMSksXG4gICAgW0FjdGlvbi5Eb3duXTogKGRhdGUpID0+IGFkZFllYXJzKGRhdGUsIDUpLFxuICAgIFtBY3Rpb24uUHJldlZpZXddOiAoZGF0ZSkgPT4gYWRkRGVjYWRlcyhkYXRlLCAtMSksXG4gICAgW0FjdGlvbi5OZXh0Vmlld106IChkYXRlKSA9PiBhZGREZWNhZGVzKGRhdGUsIDEpLFxuICAgIFtBY3Rpb24uRmlyc3RJblZpZXddOiAoZGF0ZSkgPT4gZmlyc3RZZWFyT2ZEZWNhZGUoZGF0ZSksXG4gICAgW0FjdGlvbi5MYXN0SW5WaWV3XTogKGRhdGUpID0+IGxhc3RZZWFyT2ZEZWNhZGUoZGF0ZSlcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERlY2FkZVZpZXdTZXJ2aWNlID0gY2xhc3MgRGVjYWRlVmlld1NlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2UgPSAoc3RhcnQsIGVuZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoc3RhcnQpIHx8ICFpc1ByZXNlbnQoZW5kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBzdGFydDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50IDw9IGVuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBhZGRZZWFycyhjdXJyZW50LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZFRvRGF0ZShtaW4sIHNraXApIHtcbiAgICAgICAgcmV0dXJuIGFkZERlY2FkZXMobWluLCBza2lwKTtcbiAgICB9XG4gICAgZGF0ZXNMaXN0KHN0YXJ0LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgY291bnQpLm1hcChpID0+IGFkZERlY2FkZXMoc3RhcnQsIGkpKTtcbiAgICB9XG4gICAgZGF0YShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgY2VsbFVJRCwgZm9jdXNlZERhdGUsIGlzQWN0aXZlVmlldywgbWF4LCBtaW4sIHNlbGVjdGVkRGF0ZXMsIHNlbGVjdGlvblJhbmdlID0gRU1QVFlfU0VMRUNUSU9OUkFOR0UsIHZpZXdEYXRlIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoIXZpZXdEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfREFUQSQxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGxzID0gcmFuZ2UoMCwgQ0VMTFNfTEVOR1RIJDEpO1xuICAgICAgICBjb25zdCBmaXJzdERhdGUgPSBmaXJzdFllYXJPZkRlY2FkZSh2aWV3RGF0ZSk7XG4gICAgICAgIGNvbnN0IGxhc3REYXRlID0gbGFzdFllYXJPZkRlY2FkZSh2aWV3RGF0ZSk7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gZ2V0VG9kYXkoKTtcbiAgICAgICAgcmV0dXJuIHJhbmdlKDAsIFJPV1NfTEVOR1RIJDEpLm1hcChyb3dPZmZzZXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmFzZURhdGUgPSBhZGRZZWFycyhmaXJzdERhdGUsIHJvd09mZnNldCAqIENFTExTX0xFTkdUSCQxKTtcbiAgICAgICAgICAgIHJldHVybiBjZWxscy5tYXAoY2VsbE9mZnNldCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbERhdGUgPSB0aGlzLm5vcm1hbGl6ZShhZGRZZWFycyhiYXNlRGF0ZSwgY2VsbE9mZnNldCksIG1pbiwgbWF4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGVjYWRlID0gY2VsbERhdGUuZ2V0RnVsbFllYXIoKSA+IGxhc3REYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5SYW5nZShjZWxsRGF0ZSwgbWluLCBtYXgpIHx8IG5leHREZWNhZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmFuZ2VTdGFydCA9IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgc2VsZWN0aW9uUmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmFuZ2VFbmQgPSB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIHNlbGVjdGlvblJhbmdlLmVuZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNJbk1pZGRsZSA9ICFpc1JhbmdlU3RhcnQgJiYgIWlzUmFuZ2VFbmQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSYW5nZU1pZCA9IGlzSW5NaWRkbGUgJiYgaXNJblNlbGVjdGlvblJhbmdlKGNlbGxEYXRlLCBzZWxlY3Rpb25SYW5nZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWU6IHRoaXMudmFsdWUoY2VsbERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpZDogYCR7Y2VsbFVJRH0ke2NlbGxEYXRlLmdldFRpbWUoKX1gLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvY3VzZWQ6IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgZm9jdXNlZERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBpc0FjdGl2ZVZpZXcgJiYgc2VsZWN0ZWREYXRlcy5zb21lKGRhdGUgPT4gdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBkYXRlKSksXG4gICAgICAgICAgICAgICAgICAgIGlzV2Vla2VuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzUmFuZ2VTdGFydDogaXNSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlTWlkOiBpc1JhbmdlTWlkLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlRW5kOiBpc1JhbmdlRW5kLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlU3BsaXRFbmQ6IGlzUmFuZ2VNaWQgJiYgdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBsYXN0RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlzUmFuZ2VTcGxpdFN0YXJ0OiBpc1JhbmdlTWlkICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgZmlyc3REYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgaXNUb2RheTogdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCB0b2RheSksXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLmNlbGxUaXRsZShjZWxsRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjZWxsRGF0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzRXF1YWwoY2FuZGlkYXRlLCBleHBlY3RlZCkge1xuICAgICAgICBpZiAoIWNhbmRpZGF0ZSB8fCAhZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlLmdldEZ1bGxZZWFyKCkgPT09IGV4cGVjdGVkLmdldEZ1bGxZZWFyKCk7XG4gICAgfVxuICAgIGlzSW5BcnJheShkYXRlLCBkYXRlcykge1xuICAgICAgICBpZiAoIWRhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHJldHVybiBkYXRlc1swXS5nZXRGdWxsWWVhcigpIDw9IHllYXIgJiYgeWVhciA8PSAoZGF0ZXNbZGF0ZXMubGVuZ3RoIC0gMV0uZ2V0RnVsbFllYXIoKSArIDkpO1xuICAgIH1cbiAgICBpc0luUmFuZ2UoY2FuZGlkYXRlLCBtaW4sIG1heCkge1xuICAgICAgICBjb25zdCB5ZWFyID0gY2FuZGlkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIGNvbnN0IGFib3ZlTWluID0gIW1pbiB8fCBtaW4uZ2V0RnVsbFllYXIoKSA8PSB5ZWFyO1xuICAgICAgICBjb25zdCBiZWxvd01heCA9ICFtYXggfHwgeWVhciA8PSBtYXguZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgcmV0dXJuIGFib3ZlTWluICYmIGJlbG93TWF4O1xuICAgIH1cbiAgICBiZWdpbm5pbmdPZlBlcmlvZChkYXRlKSB7XG4gICAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RZZWFyID0gZmlyc3RZZWFyT2ZEZWNhZGUoZGF0ZSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVEYXRlKGZpcnN0WWVhci5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgICB9XG4gICAgbGFzdERheU9mUGVyaW9kKGRhdGUpIHtcbiAgICAgICAgY29uc3QgeWVhciA9IGxhc3RZZWFyT2ZEZWNhZGUoZGF0ZSk7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gbGFzdE1vbnRoT2ZZZWFyKHllYXIpO1xuICAgICAgICByZXR1cm4gbGFzdERheU9mTW9udGgobW9udGgpO1xuICAgIH1cbiAgICBpc1JhbmdlU3RhcnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmdldEZ1bGxZZWFyKCkgJSAxMDAgPT09IDA7XG4gICAgfVxuICAgIG1vdmUodmFsdWUsIGFjdGlvbikge1xuICAgICAgICBjb25zdCBtb2RpZmllciA9IEFDVElPTlMkMVthY3Rpb25dO1xuICAgICAgICBpZiAoIW1vZGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGlmaWVyKHZhbHVlKTtcbiAgICB9XG4gICAgY2VsbFRpdGxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIG5hdmlnYXRpb25UaXRsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBmaXJzdFllYXJPZkRlY2FkZSh2YWx1ZSkuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpIDogJyc7XG4gICAgfVxuICAgIHRpdGxlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7Zmlyc3RZZWFyT2ZEZWNhZGUodmFsdWUpLmdldEZ1bGxZZWFyKCl9IC0gJHtsYXN0WWVhck9mRGVjYWRlKHZhbHVlKS5nZXRGdWxsWWVhcigpfWA7XG4gICAgfVxuICAgIHJvd0xlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIENFTExTX0xFTkdUSCQxO1xuICAgIH1cbiAgICBza2lwKHZhbHVlLCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uSW5EZWNhZGVzKG1pbiwgdmFsdWUpO1xuICAgIH1cbiAgICB0b3RhbChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25JbkRlY2FkZXMobWluLCBtYXgpICsgMTtcbiAgICB9XG4gICAgdmFsdWUoY3VycmVudCkge1xuICAgICAgICByZXR1cm4gY3VycmVudCA/IGN1cnJlbnQuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpIDogJyc7XG4gICAgfVxuICAgIHZpZXdEYXRlKGRhdGUsIG1heCwgdmlld3NDb3VudCA9IDEpIHtcbiAgICAgICAgY29uc3Qgdmlld3NJblJhbmdlID0gdGhpcy50b3RhbChkYXRlLCBtYXgpO1xuICAgICAgICBpZiAodmlld3NJblJhbmdlIDwgdmlld3NDb3VudCkge1xuICAgICAgICAgICAgY29uc3QgZGVjYWRlc1RvU3VidHJhY3QgPSB2aWV3c0NvdW50IC0gdmlld3NJblJhbmdlO1xuICAgICAgICAgICAgcmV0dXJuIGFkZERlY2FkZXMoZGF0ZSwgLTEgKiBkZWNhZGVzVG9TdWJ0cmFjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIG5vcm1hbGl6ZShjZWxsRGF0ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKGNlbGxEYXRlIDwgbWluICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgbWluKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lRGF0ZShtaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsRGF0ZSA+IG1heCAmJiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIG1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZURhdGUobWF4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2VsbERhdGU7XG4gICAgfVxufTtcbkRlY2FkZVZpZXdTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBEZWNhZGVWaWV3U2VydmljZSk7XG5cbmNvbnN0IEVNUFRZX0RBVEEkMiA9IFtbXV07XG5jb25zdCBDRUxMU19MRU5HVEgkMiA9IDc7XG5jb25zdCBST1dTX0xFTkdUSCQyID0gNjtcbmNvbnN0IEFDVElPTlMkMiA9IHtcbiAgICBbQWN0aW9uLkxlZnRdOiAoZGF0ZSkgPT4gYWRkRGF5cyhkYXRlLCAtMSksXG4gICAgW0FjdGlvbi5VcF06IChkYXRlKSA9PiBhZGRXZWVrcyhkYXRlLCAtMSksXG4gICAgW0FjdGlvbi5SaWdodF06IChkYXRlKSA9PiBhZGREYXlzKGRhdGUsIDEpLFxuICAgIFtBY3Rpb24uRG93bl06IChkYXRlKSA9PiBhZGRXZWVrcyhkYXRlLCAxKSxcbiAgICBbQWN0aW9uLlByZXZWaWV3XTogKGRhdGUpID0+IGFkZE1vbnRocyhkYXRlLCAtMSksXG4gICAgW0FjdGlvbi5OZXh0Vmlld106IChkYXRlKSA9PiBhZGRNb250aHMoZGF0ZSwgMSksXG4gICAgW0FjdGlvbi5GaXJzdEluVmlld106IChkYXRlKSA9PiBmaXJzdERheU9mTW9udGgoZGF0ZSksXG4gICAgW0FjdGlvbi5MYXN0SW5WaWV3XTogKGRhdGUpID0+IGxhc3REYXlPZk1vbnRoKGRhdGUpXG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBNb250aFZpZXdTZXJ2aWNlID0gY2xhc3MgTW9udGhWaWV3U2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoX2ludGxTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX2ludGxTZXJ2aWNlID0gX2ludGxTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGVSYW5nZSA9IChzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChzdGFydCkgfHwgIWlzUHJlc2VudChlbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHN0YXJ0O1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGFkZERheXMoY3VycmVudCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRUb0RhdGUobWluLCBza2lwKSB7XG4gICAgICAgIHJldHVybiBhZGRNb250aHMobWluLCBza2lwKTtcbiAgICB9XG4gICAgZGF0ZXNMaXN0KHN0YXJ0LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgY291bnQpLm1hcChpID0+IGFkZE1vbnRocyhzdGFydCwgaSkpO1xuICAgIH1cbiAgICBkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBjZWxsVUlELCBmb2N1c2VkRGF0ZSwgaXNBY3RpdmVWaWV3LCBtYXgsIG1pbiwgc2VsZWN0ZWREYXRlcywgc2VsZWN0aW9uUmFuZ2UgPSBFTVBUWV9TRUxFQ1RJT05SQU5HRSwgdmlld0RhdGUsIGlzRGF0ZURpc2FibGVkID0gKCkgPT4gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmICghdmlld0RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9EQVRBJDI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RNb250aERhdGUgPSBmaXJzdERheU9mTW9udGgodmlld0RhdGUpO1xuICAgICAgICBjb25zdCBmaXJzdE1vbnRoRGF5ID0gZ2V0RGF0ZShmaXJzdE1vbnRoRGF0ZSk7XG4gICAgICAgIGNvbnN0IGxhc3RNb250aERhdGUgPSBsYXN0RGF5T2ZNb250aCh2aWV3RGF0ZSk7XG4gICAgICAgIGNvbnN0IGxhc3RNb250aERheSA9IGdldERhdGUobGFzdE1vbnRoRGF0ZSk7XG4gICAgICAgIGNvbnN0IGJhY2t3YXJkID0gLTE7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBkYXlPZldlZWsoZmlyc3RNb250aERhdGUsIHRoaXMuX2ludGxTZXJ2aWNlLmZpcnN0RGF5KCksIGJhY2t3YXJkKTtcbiAgICAgICAgY29uc3QgY2VsbHMgPSByYW5nZSgwLCBDRUxMU19MRU5HVEgkMik7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gZ2V0VG9kYXkoKTtcbiAgICAgICAgcmV0dXJuIHJhbmdlKDAsIFJPV1NfTEVOR1RIJDIpLm1hcChyb3dPZmZzZXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmFzZURhdGUgPSBhZGREYXlzKGRhdGUsIHJvd09mZnNldCAqIENFTExTX0xFTkdUSCQyKTtcbiAgICAgICAgICAgIHJldHVybiBjZWxscy5tYXAoY2VsbE9mZnNldCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbERhdGUgPSB0aGlzLm5vcm1hbGl6ZShhZGREYXlzKGJhc2VEYXRlLCBjZWxsT2Zmc2V0KSwgbWluLCBtYXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxEYXkgPSBnZXREYXRlKGNlbGxEYXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlck1vbnRoID0gY2VsbERheSA8IGZpcnN0TW9udGhEYXkgfHwgY2VsbERheSA+IGxhc3RNb250aERheTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRPZlJhbmdlID0gY2VsbERhdGUgPCBtaW4gfHwgY2VsbERhdGUgPiBtYXg7XG4gICAgICAgICAgICAgICAgaWYgKG91dE9mUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmFuZ2VTdGFydCA9IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgc2VsZWN0aW9uUmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmFuZ2VFbmQgPSB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIHNlbGVjdGlvblJhbmdlLmVuZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNJbk1pZGRsZSA9ICFpc1JhbmdlU3RhcnQgJiYgIWlzUmFuZ2VFbmQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSYW5nZU1pZCA9IGlzSW5NaWRkbGUgJiYgaXNJblNlbGVjdGlvblJhbmdlKGNlbGxEYXRlLCBzZWxlY3Rpb25SYW5nZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWU6IHRoaXMudmFsdWUoY2VsbERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpZDogYCR7Y2VsbFVJRH0ke2NlbGxEYXRlLmdldFRpbWUoKX1gLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvY3VzZWQ6IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgZm9jdXNlZERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBpc0FjdGl2ZVZpZXcgJiYgc2VsZWN0ZWREYXRlcy5zb21lKGRhdGUgPT4gdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBkYXRlKSksXG4gICAgICAgICAgICAgICAgICAgIGlzV2Vla2VuZDogdGhpcy5pc1dlZWtlbmQoY2VsbERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlU3RhcnQ6IGlzUmFuZ2VTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZU1pZDogaXNSYW5nZU1pZCxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZUVuZDogaXNSYW5nZUVuZCxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZVNwbGl0U3RhcnQ6IGlzUmFuZ2VNaWQgJiYgdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBmaXJzdE1vbnRoRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlzUmFuZ2VTcGxpdEVuZDogaXNSYW5nZU1pZCAmJiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIGxhc3RNb250aERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpc1RvZGF5OiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIHRvZGF5KSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRoaXMuY2VsbFRpdGxlKGNlbGxEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNlbGxEYXRlLFxuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FibGVkOiBpc0RhdGVEaXNhYmxlZChjZWxsRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlzT3RoZXJNb250aDogb3RoZXJNb250aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzRXF1YWwoY2FuZGlkYXRlLCBleHBlY3RlZCkge1xuICAgICAgICBpZiAoIWNhbmRpZGF0ZSB8fCAhZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0RGF0ZShjYW5kaWRhdGUpLmdldFRpbWUoKSA9PT0gZ2V0RGF0ZShleHBlY3RlZCkuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBpc0luQXJyYXkoZGF0ZSwgZGF0ZXMpIHtcbiAgICAgICAgaWYgKGRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSB0aGlzLmJlZ2lubmluZ09mUGVyaW9kKGRhdGVzWzBdKTtcbiAgICAgICAgY29uc3QgdXBwZXJCb3VuZCA9IHRoaXMuYmVnaW5uaW5nT2ZQZXJpb2QoYWRkTW9udGhzKGRhdGVzW2RhdGVzLmxlbmd0aCAtIDFdLCAxKSk7XG4gICAgICAgIHJldHVybiBsb3dlckJvdW5kIDw9IGRhdGUgJiYgZGF0ZSA8IHVwcGVyQm91bmQ7XG4gICAgfVxuICAgIGlzSW5SYW5nZShjYW5kaWRhdGUsIG1pbiwgbWF4KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0RGF0ZShjYW5kaWRhdGUpO1xuICAgICAgICBjb25zdCBhYm92ZU1pbiA9ICFtaW4gfHwgZ2V0RGF0ZShtaW4pIDw9IHZhbHVlO1xuICAgICAgICBjb25zdCBiZWxvd01heCA9ICFtYXggfHwgdmFsdWUgPD0gZ2V0RGF0ZShtYXgpO1xuICAgICAgICByZXR1cm4gYWJvdmVNaW4gJiYgYmVsb3dNYXg7XG4gICAgfVxuICAgIGJlZ2lubmluZ09mUGVyaW9kKGRhdGUpIHtcbiAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgMSk7XG4gICAgfVxuICAgIGxhc3REYXlPZlBlcmlvZChkYXRlKSB7XG4gICAgICAgIHJldHVybiBsYXN0RGF5T2ZNb250aChkYXRlKTtcbiAgICB9XG4gICAgaXNSYW5nZVN0YXJ0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuZ2V0TW9udGgoKTtcbiAgICB9XG4gICAgbW92ZSh2YWx1ZSwgYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gQUNUSU9OUyQyW2FjdGlvbl07XG4gICAgICAgIGlmICghbW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kaWZpZXIodmFsdWUpO1xuICAgIH1cbiAgICBjZWxsVGl0bGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGxTZXJ2aWNlLmZvcm1hdERhdGUodmFsdWUsICdEJyk7XG4gICAgfVxuICAgIG5hdmlnYXRpb25UaXRsZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSYW5nZVN0YXJ0KHZhbHVlKSA/IHZhbHVlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSA6IHRoaXMuYWJick1vbnRoTmFtZXMoKVt2YWx1ZS5nZXRNb250aCgpXTtcbiAgICB9XG4gICAgdGl0bGUoY3VycmVudCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy53aWRlTW9udGhOYW1lcygpW2N1cnJlbnQuZ2V0TW9udGgoKV19ICR7Y3VycmVudC5nZXRGdWxsWWVhcigpfWA7XG4gICAgfVxuICAgIHJvd0xlbmd0aChvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIENFTExTX0xFTkdUSCQyICsgKG9wdGlvbnMucHJlcGVuZENlbGwgPyAxIDogMCk7XG4gICAgfVxuICAgIHNraXAodmFsdWUsIG1pbikge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25Jbk1vbnRocyhtaW4sIHZhbHVlKTtcbiAgICB9XG4gICAgdG90YWwobWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uSW5Nb250aHMobWluLCBtYXgpICsgMTtcbiAgICB9XG4gICAgdmFsdWUoY3VycmVudCkge1xuICAgICAgICByZXR1cm4gY3VycmVudCA/IGN1cnJlbnQuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgIH1cbiAgICB2aWV3RGF0ZShkYXRlLCBtYXgsIHZpZXdzQ291bnQgPSAxKSB7XG4gICAgICAgIGNvbnN0IHZpZXdzSW5SYW5nZSA9IHRoaXMudG90YWwoZGF0ZSwgbWF4KTtcbiAgICAgICAgaWYgKHZpZXdzSW5SYW5nZSA8IHZpZXdzQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoc1RvU3VidHJhY3QgPSB2aWV3c0NvdW50IC0gdmlld3NJblJhbmdlO1xuICAgICAgICAgICAgcmV0dXJuIGFkZE1vbnRocyhkYXRlLCAtMSAqIG1vbnRoc1RvU3VidHJhY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBpc1dlZWtlbmQoZGF0ZSkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMuX2ludGxTZXJ2aWNlLndlZWtlbmRSYW5nZSgpO1xuICAgICAgICBjb25zdCBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXkgPD0gZW5kIHx8IHN0YXJ0IDw9IGRheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnQgPD0gZGF5ICYmIGRheSA8PSBlbmQ7XG4gICAgfVxuICAgIGFiYnJNb250aE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50bFNlcnZpY2UuZGF0ZUZvcm1hdE5hbWVzKHsgbmFtZVR5cGU6ICdhYmJyZXZpYXRlZCcsIHR5cGU6ICdtb250aHMnIH0pO1xuICAgIH1cbiAgICBub3JtYWxpemUoY2VsbERhdGUsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmIChjZWxsRGF0ZSA8IG1pbiAmJiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIG1pbikpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZURhdGUobWluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbERhdGUgPiBtYXggJiYgdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBtYXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVEYXRlKG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGxEYXRlO1xuICAgIH1cbiAgICB3aWRlTW9udGhOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGxTZXJ2aWNlLmRhdGVGb3JtYXROYW1lcyh7IG5hbWVUeXBlOiAnd2lkZScsIHR5cGU6ICdtb250aHMnIH0pO1xuICAgIH1cbn07XG5Nb250aFZpZXdTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgTW9udGhWaWV3U2VydmljZSk7XG5cbmNvbnN0IEVNUFRZX0RBVEEkMyA9IFtbXV07XG5jb25zdCBDRUxMU19MRU5HVEgkMyA9IDQ7XG5jb25zdCBST1dTX0xFTkdUSCQzID0gMztcbmNvbnN0IHVwU3RlcCA9IChtb250aCkgPT4ge1xuICAgIGlmIChtb250aCA+IDQpIHtcbiAgICAgICAgcmV0dXJuIC01O1xuICAgIH1cbiAgICBpZiAobW9udGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMjtcbiAgICB9XG4gICAgcmV0dXJuIC03O1xufTtcbmNvbnN0IGRvd25TdGVwID0gKG1vbnRoKSA9PiB7XG4gICAgaWYgKG1vbnRoIDwgNykge1xuICAgICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgaWYgKG1vbnRoIDwgMTApIHtcbiAgICAgICAgcmV0dXJuIDc7XG4gICAgfVxuICAgIHJldHVybiAyO1xufTtcbmNvbnN0IEFDVElPTlMkMyA9IHtcbiAgICBbQWN0aW9uLkxlZnRdOiAoZGF0ZSkgPT4gYWRkTW9udGhzKGRhdGUsIC0xKSxcbiAgICBbQWN0aW9uLlVwXTogKGRhdGUpID0+IGFkZE1vbnRocyhkYXRlLCB1cFN0ZXAoZGF0ZS5nZXRNb250aCgpKSksXG4gICAgW0FjdGlvbi5SaWdodF06IChkYXRlKSA9PiBhZGRNb250aHMoZGF0ZSwgMSksXG4gICAgW0FjdGlvbi5Eb3duXTogKGRhdGUpID0+IGFkZE1vbnRocyhkYXRlLCBkb3duU3RlcChkYXRlLmdldE1vbnRoKCkpKSxcbiAgICBbQWN0aW9uLlByZXZWaWV3XTogKGRhdGUpID0+IGFkZFllYXJzKGRhdGUsIC0xKSxcbiAgICBbQWN0aW9uLk5leHRWaWV3XTogKGRhdGUpID0+IGFkZFllYXJzKGRhdGUsIDEpLFxuICAgIFtBY3Rpb24uRmlyc3RJblZpZXddOiAoZGF0ZSkgPT4gZmlyc3RNb250aE9mWWVhcihkYXRlKSxcbiAgICBbQWN0aW9uLkxhc3RJblZpZXddOiAoZGF0ZSkgPT4gbGFzdE1vbnRoT2ZZZWFyKGRhdGUpXG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBZZWFyVmlld1NlcnZpY2UgPSBjbGFzcyBZZWFyVmlld1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKF9pbnRsU2VydmljZSkge1xuICAgICAgICB0aGlzLl9pbnRsU2VydmljZSA9IF9pbnRsU2VydmljZTtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2UgPSAoc3RhcnQsIGVuZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoc3RhcnQpIHx8ICFpc1ByZXNlbnQoZW5kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBzdGFydDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50IDw9IGVuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBhZGRNb250aHMoY3VycmVudCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRUb0RhdGUobWluLCBza2lwKSB7XG4gICAgICAgIHJldHVybiBhZGRZZWFycyhtaW4sIHNraXApO1xuICAgIH1cbiAgICBkYXRlc0xpc3Qoc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiByYW5nZSgwLCBjb3VudCkubWFwKGkgPT4gYWRkWWVhcnMoc3RhcnQsIGkpKTtcbiAgICB9XG4gICAgZGF0YShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgY2VsbFVJRCwgZm9jdXNlZERhdGUsIGlzQWN0aXZlVmlldywgbWF4LCBtaW4sIHNlbGVjdGVkRGF0ZXMsIHNlbGVjdGlvblJhbmdlID0gRU1QVFlfU0VMRUNUSU9OUkFOR0UsIHZpZXdEYXRlIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoIXZpZXdEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfREFUQSQzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vbnRocyA9IHRoaXMuYWJick1vbnRoTmFtZXMoKTtcbiAgICAgICAgY29uc3QgZmlyc3REYXRlID0gZmlyc3RNb250aE9mWWVhcih2aWV3RGF0ZSk7XG4gICAgICAgIGNvbnN0IGxhc3REYXRlID0gbGFzdE1vbnRoT2ZZZWFyKHZpZXdEYXRlKTtcbiAgICAgICAgY29uc3QgY3VycmVudFllYXIgPSBmaXJzdERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgY29uc3QgY2VsbHMgPSByYW5nZSgwLCBDRUxMU19MRU5HVEgkMyk7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gZ2V0VG9kYXkoKTtcbiAgICAgICAgcmV0dXJuIHJhbmdlKDAsIFJPV1NfTEVOR1RIJDMpLm1hcChyb3dPZmZzZXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmFzZURhdGUgPSBhZGRNb250aHMoZmlyc3REYXRlLCByb3dPZmZzZXQgKiBDRUxMU19MRU5HVEgkMyk7XG4gICAgICAgICAgICByZXR1cm4gY2VsbHMubWFwKGNlbGxPZmZzZXQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxEYXRlID0gdGhpcy5ub3JtYWxpemUoYWRkTW9udGhzKGJhc2VEYXRlLCBjZWxsT2Zmc2V0KSwgbWluLCBtYXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRZZWFyID0gY3VycmVudFllYXIgPCBjZWxsRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0luUmFuZ2UoY2VsbERhdGUsIG1pbiwgbWF4KSB8fCBjaGFuZ2VkWWVhcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSYW5nZVN0YXJ0ID0gdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBzZWxlY3Rpb25SYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSYW5nZUVuZCA9IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgc2VsZWN0aW9uUmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0luTWlkZGxlID0gIWlzUmFuZ2VTdGFydCAmJiAhaXNSYW5nZUVuZDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JhbmdlTWlkID0gaXNJbk1pZGRsZSAmJiBpc0luU2VsZWN0aW9uUmFuZ2UoY2VsbERhdGUsIHNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogbW9udGhzW2NlbGxEYXRlLmdldE1vbnRoKCldLFxuICAgICAgICAgICAgICAgICAgICBpZDogYCR7Y2VsbFVJRH0ke2NlbGxEYXRlLmdldFRpbWUoKX1gLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvY3VzZWQ6IHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgZm9jdXNlZERhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBpc0FjdGl2ZVZpZXcgJiYgc2VsZWN0ZWREYXRlcy5zb21lKGRhdGUgPT4gdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBkYXRlKSksXG4gICAgICAgICAgICAgICAgICAgIGlzV2Vla2VuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzUmFuZ2VTdGFydDogaXNSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlTWlkOiBpc1JhbmdlTWlkLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlRW5kOiBpc1JhbmdlRW5kLFxuICAgICAgICAgICAgICAgICAgICBpc1JhbmdlU3BsaXRFbmQ6IGlzUmFuZ2VNaWQgJiYgdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCBsYXN0RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlzUmFuZ2VTcGxpdFN0YXJ0OiBpc1JhbmdlTWlkICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgZmlyc3REYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgaXNUb2RheTogdGhpcy5pc0VxdWFsKGNlbGxEYXRlLCB0b2RheSksXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLmNlbGxUaXRsZShjZWxsRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjZWxsRGF0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzRXF1YWwoY2FuZGlkYXRlLCBleHBlY3RlZCkge1xuICAgICAgICBpZiAoIWNhbmRpZGF0ZSB8fCAhZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlLmdldEZ1bGxZZWFyKCkgPT09IGV4cGVjdGVkLmdldEZ1bGxZZWFyKCkgJiZcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5nZXRNb250aCgpID09PSBleHBlY3RlZC5nZXRNb250aCgpO1xuICAgIH1cbiAgICBpc0luQXJyYXkoZGF0ZSwgZGF0ZXMpIHtcbiAgICAgICAgaWYgKCFkYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICByZXR1cm4gZGF0ZXNbMF0uZ2V0RnVsbFllYXIoKSA8PSB5ZWFyICYmIHllYXIgPD0gZGF0ZXNbZGF0ZXMubGVuZ3RoIC0gMV0uZ2V0RnVsbFllYXIoKTtcbiAgICB9XG4gICAgaXNJblJhbmdlKGNhbmRpZGF0ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlVmFsdWUgPSBjcmVhdGVEYXRlKGNhbmRpZGF0ZS5nZXRGdWxsWWVhcigpLCBjYW5kaWRhdGUuZ2V0TW9udGgoKSwgMSk7XG4gICAgICAgIGNvbnN0IGFib3ZlTWluID0gIW1pbiB8fCBjcmVhdGVEYXRlKG1pbi5nZXRGdWxsWWVhcigpLCBtaW4uZ2V0TW9udGgoKSwgMSkgPD0gY2FuZGlkYXRlVmFsdWU7XG4gICAgICAgIGNvbnN0IGJlbG93TWF4ID0gIW1heCB8fCBjYW5kaWRhdGVWYWx1ZSA8PSBjcmVhdGVEYXRlKG1heC5nZXRGdWxsWWVhcigpLCBtYXguZ2V0TW9udGgoKSwgMSk7XG4gICAgICAgIHJldHVybiBhYm92ZU1pbiAmJiBiZWxvd01heDtcbiAgICB9XG4gICAgYmVnaW5uaW5nT2ZQZXJpb2QoZGF0ZSkge1xuICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgfVxuICAgIGxhc3REYXlPZlBlcmlvZChkYXRlKSB7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gbGFzdE1vbnRoT2ZZZWFyKGRhdGUpO1xuICAgICAgICByZXR1cm4gbGFzdERheU9mTW9udGgobW9udGgpO1xuICAgIH1cbiAgICBpc1JhbmdlU3RhcnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmdldEZ1bGxZZWFyKCkgJSAxMCA9PT0gMDtcbiAgICB9XG4gICAgbW92ZSh2YWx1ZSwgYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gQUNUSU9OUyQzW2FjdGlvbl07XG4gICAgICAgIGlmICghbW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kaWZpZXIodmFsdWUpO1xuICAgIH1cbiAgICBjZWxsVGl0bGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlLmdldEZ1bGxZZWFyKCl9ICR7dGhpcy52YWx1ZSh2YWx1ZSl9YDtcbiAgICB9XG4gICAgbmF2aWdhdGlvblRpdGxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlKHZhbHVlKTtcbiAgICB9XG4gICAgdGl0bGUoY3VycmVudCkge1xuICAgICAgICByZXR1cm4gY3VycmVudCA/IGN1cnJlbnQuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpIDogJyc7XG4gICAgfVxuICAgIHJvd0xlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIENFTExTX0xFTkdUSCQzO1xuICAgIH1cbiAgICBza2lwKHZhbHVlLCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uSW5ZZWFycyhtaW4sIHZhbHVlKTtcbiAgICB9XG4gICAgdG90YWwobWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uSW5ZZWFycyhtaW4sIG1heCkgKyAxO1xuICAgIH1cbiAgICB2YWx1ZShjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50ID8gdGhpcy5hYmJyTW9udGhOYW1lcygpW2N1cnJlbnQuZ2V0TW9udGgoKV0gOiAnJztcbiAgICB9XG4gICAgdmlld0RhdGUoZGF0ZSwgbWF4LCB2aWV3c0NvdW50ID0gMSkge1xuICAgICAgICBjb25zdCB2aWV3c0luUmFuZ2UgPSB0aGlzLnRvdGFsKGRhdGUsIG1heCk7XG4gICAgICAgIGlmICh2aWV3c0luUmFuZ2UgPCB2aWV3c0NvdW50KSB7XG4gICAgICAgICAgICBjb25zdCB5ZWFyc1RvU3VidHJhY3QgPSB2aWV3c0NvdW50IC0gdmlld3NJblJhbmdlO1xuICAgICAgICAgICAgcmV0dXJuIGFkZFllYXJzKGRhdGUsIC0xICogeWVhcnNUb1N1YnRyYWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgYWJick1vbnRoTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRsU2VydmljZS5kYXRlRm9ybWF0TmFtZXMoeyBuYW1lVHlwZTogJ2FiYnJldmlhdGVkJywgdHlwZTogJ21vbnRocycgfSk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZShjZWxsRGF0ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKGNlbGxEYXRlIDwgbWluICYmIHRoaXMuaXNFcXVhbChjZWxsRGF0ZSwgbWluKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lRGF0ZShtaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsRGF0ZSA+IG1heCAmJiB0aGlzLmlzRXF1YWwoY2VsbERhdGUsIG1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZURhdGUobWF4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2VsbERhdGU7XG4gICAgfVxufTtcblllYXJWaWV3U2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0ludGxTZXJ2aWNlXSlcbl0sIFllYXJWaWV3U2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFRoZSBFbnVtIHdoaWNoIGRlZmluZXMgYWxsIHBvc3NpYmxlIENhbGVuZGFyIHZpZXcgdHlwZXMuXG4gKi9cbnZhciBDYWxlbmRhclZpZXdFbnVtO1xuKGZ1bmN0aW9uIChDYWxlbmRhclZpZXdFbnVtKSB7XG4gICAgQ2FsZW5kYXJWaWV3RW51bVtDYWxlbmRhclZpZXdFbnVtW1wibW9udGhcIl0gPSAwXSA9IFwibW9udGhcIjtcbiAgICBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW1bXCJ5ZWFyXCJdID0gMV0gPSBcInllYXJcIjtcbiAgICBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW1bXCJkZWNhZGVcIl0gPSAyXSA9IFwiZGVjYWRlXCI7XG4gICAgQ2FsZW5kYXJWaWV3RW51bVtDYWxlbmRhclZpZXdFbnVtW1wiY2VudHVyeVwiXSA9IDNdID0gXCJjZW50dXJ5XCI7XG59KShDYWxlbmRhclZpZXdFbnVtIHx8IChDYWxlbmRhclZpZXdFbnVtID0ge30pKTtcblxuY29uc3Qgc2VydmljZXMgPSB7XG4gICAgW0NhbGVuZGFyVmlld0VudW0ubW9udGhdOiBNb250aFZpZXdTZXJ2aWNlLFxuICAgIFtDYWxlbmRhclZpZXdFbnVtLnllYXJdOiBZZWFyVmlld1NlcnZpY2UsXG4gICAgW0NhbGVuZGFyVmlld0VudW0uZGVjYWRlXTogRGVjYWRlVmlld1NlcnZpY2UsXG4gICAgW0NhbGVuZGFyVmlld0VudW0uY2VudHVyeV06IENlbnR1cnlWaWV3U2VydmljZVxufTtcbmNvbnN0IHZpZXdPZmZzZXQgPSAodmlldywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgY2FuZGlkYXRlID0gQ2FsZW5kYXJWaWV3RW51bVtDYWxlbmRhclZpZXdFbnVtW3ZpZXcgKyBvZmZzZXRdXTtcbiAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgPyBjYW5kaWRhdGUgOiB2aWV3O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQnVzVmlld1NlcnZpY2UgPSBjbGFzcyBCdXNWaWV3U2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoaW5qZWN0b3IpIHtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLnZpZXdDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IENhbGVuZGFyVmlld0VudW0ubW9udGg7XG4gICAgICAgIHRoaXMudG9wID0gQ2FsZW5kYXJWaWV3RW51bS5jZW50dXJ5O1xuICAgIH1cbiAgICBjb25maWd1cmUoYm90dG9tLCB0b3ApIHtcbiAgICAgICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgIH1cbiAgICBzZXJ2aWNlKHZpZXcpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZVR5cGUgPSBzZXJ2aWNlc1t2aWV3XTtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VUeXBlID8gdGhpcy5pbmplY3Rvci5nZXQoc2VydmljZVR5cGUpIDogbnVsbDtcbiAgICB9XG4gICAgbW92ZURvd24odmlldykge1xuICAgICAgICB0aGlzLm1vdmUodmlldywgLTEpO1xuICAgIH1cbiAgICBtb3ZlVXAodmlldykge1xuICAgICAgICB0aGlzLm1vdmUodmlldywgMSk7XG4gICAgfVxuICAgIG1vdmVUb0JvdHRvbShhY3RpdmVWaWV3KSB7XG4gICAgICAgIGlmIChhY3RpdmVWaWV3ID09PSB0aGlzLmJvdHRvbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld0NoYW5nZWQuZW1pdCh7IHZpZXc6IHRoaXMuYm90dG9tIH0pO1xuICAgIH1cbiAgICBjYW5Nb3ZlRG93bih2aWV3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSA8IHZpZXc7XG4gICAgfVxuICAgIGNhbk1vdmVVcCh2aWV3KSB7XG4gICAgICAgIHJldHVybiB2aWV3IDwgdGhpcy50b3A7XG4gICAgfVxuICAgIGNsYW1wKHZpZXcpIHtcbiAgICAgICAgaWYgKHZpZXcgPCB0aGlzLmJvdHRvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3ID4gdGhpcy50b3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9XG4gICAgbW92ZSh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdGhpcy5jbGFtcCh2aWV3T2Zmc2V0KHZpZXcsIG9mZnNldCkpO1xuICAgICAgICBpZiAoY2FuZGlkYXRlID09PSB2aWV3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3Q2hhbmdlZC5lbWl0KHsgdmlldzogY2FuZGlkYXRlIH0pO1xuICAgIH1cbn07XG5CdXNWaWV3U2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0luamVjdG9yXSlcbl0sIEJ1c1ZpZXdTZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBXZWVrTmFtZXNTZXJ2aWNlID0gY2xhc3MgV2Vla05hbWVzU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoaW50bCkge1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgIH1cbiAgICBnZXRXZWVrTmFtZXMoaW5jbHVkZVdlZWtOdW1iZXIgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB3ZWVrTmFtZXMgPSBzaGlmdFdlZWtOYW1lcyh0aGlzLmludGwuZGF0ZUZvcm1hdE5hbWVzKHsgbmFtZVR5cGU6ICdzaG9ydCcsIHR5cGU6ICdkYXlzJyB9KSwgdGhpcy5pbnRsLmZpcnN0RGF5KCkpO1xuICAgICAgICByZXR1cm4gaW5jbHVkZVdlZWtOdW1iZXIgPyBbJyddLmNvbmNhdCh3ZWVrTmFtZXMpIDogd2Vla05hbWVzO1xuICAgIH1cbn07XG5XZWVrTmFtZXNTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgV2Vla05hbWVzU2VydmljZSk7XG5cbmNvbnN0IERFRkFVTFRfVklFV1NfTEVOR1RIID0gMjtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50ID0gY2xhc3MgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihidXMsIGludGwsIHdlZWtTZXJ2aWNlLCBjZHIsIGVsZW1lbnQsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuYnVzID0gYnVzO1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLndlZWtTZXJ2aWNlID0gd2Vla1NlcnZpY2U7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IENhbGVuZGFyVmlld0VudW0ubW9udGg7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLm1pbiA9IG5ldyBEYXRlKE1JTl9EQVRFKTtcbiAgICAgICAgdGhpcy5tYXggPSBuZXcgRGF0ZShNQVhfREFURSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlcyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdzID0gREVGQVVMVF9WSUVXU19MRU5HVEg7XG4gICAgICAgIHRoaXMuc2hvd1ZpZXdIZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRlTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNlbGxDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyQ2VsbENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNlbGxFbnRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jZWxsTGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnRDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMud2Vla05hbWVzID0gW107XG4gICAgICAgIHRoaXMuZGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnRsU3Vic2NyaXB0aW9uID0gdGhpcy5pbnRsLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMuaW50bENoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0IHdlZWtOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3dXZWVrTnVtYmVycyAmJiB0aGlzLmlzTW9udGhWaWV3KCk7XG4gICAgfVxuICAgIHNldCB3ZWVrTnVtYmVyKHNob3dXZWVrTnVtYmVycykge1xuICAgICAgICB0aGlzLnNob3dXZWVrTnVtYmVycyA9IHNob3dXZWVrTnVtYmVycztcbiAgICB9XG4gICAgZ2V0IGdldENvbXBvbmVudE1vbnRoQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZpZXcgPT09IENhbGVuZGFyVmlld0VudW0ubW9udGg7XG4gICAgfVxuICAgIGdldCBnZXRDb21wb25lbnRZZWFyQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZpZXcgPT09IENhbGVuZGFyVmlld0VudW0ueWVhcjtcbiAgICB9XG4gICAgZ2V0IGdldENvbXBvbmVudERlY2FkZUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVWaWV3ID09PSBDYWxlbmRhclZpZXdFbnVtLmRlY2FkZTtcbiAgICB9XG4gICAgZ2V0IGdldENvbXBvbmVudENlbnR1cnlDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldyA9PT0gQ2FsZW5kYXJWaWV3RW51bS5jZW50dXJ5O1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuaW5pdFNlcnZpY2UoKTtcbiAgICAgICAgaWYgKHRoaXMud2Vla05hbWVzLmxlbmd0aCA9PT0gMCB8fCBjaGFuZ2VzLndlZWtOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla05hbWVzID0gdGhpcy53ZWVrU2VydmljZS5nZXRXZWVrTmFtZXModGhpcy53ZWVrTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3MgPSB0aGlzLnZpZXdzIHx8IERFRkFVTFRfVklFV1NfTEVOR1RIO1xuICAgICAgICBjb25zdCBmb2N1c2VkRGF0ZSA9IHRoaXMuZm9jdXNlZERhdGU7XG4gICAgICAgIGNvbnN0IHZpZXdEYXRlID0gdGhpcy5jbGFtcERhdGUodGhpcy5zZXJ2aWNlLnZpZXdEYXRlKGZvY3VzZWREYXRlLCB0aGlzLm1heCwgdGhpcy52aWV3cykpO1xuICAgICAgICB0aGlzLnNraXAgPSB0aGlzLnNlcnZpY2Uuc2tpcCh2aWV3RGF0ZSwgdGhpcy5taW4pO1xuICAgICAgICB0aGlzLnRvdGFsID0gdGhpcy5zZXJ2aWNlLnRvdGFsKHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXdDaGFuZ2VkID0gaGFzQ2hhbmdlKGNoYW5nZXMsICdhY3RpdmVWaWV3Jyk7XG4gICAgICAgIGNvbnN0IHZpZXdzSGFzQ2hhbmdlZCA9IHRoaXMudmlld3MgPiAwICYmIGhhc0NoYW5nZShjaGFuZ2VzLCAndmlld3MnKTtcbiAgICAgICAgaWYgKGFjdGl2ZVZpZXdDaGFuZ2VkIHx8ICF0aGlzLmlzSW5EYXRlcyhmb2N1c2VkRGF0ZSkgfHwgdmlld3NIYXNDaGFuZ2VkIHx8ICF0aGlzLmFjdGl2ZURhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZXMgPSB0aGlzLnNlcnZpY2UuZGF0ZXNMaXN0KHZpZXdEYXRlLCB0aGlzLmdldFRha2UodGhpcy5za2lwKSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSBjbG9uZURhdGUodGhpcy5kYXRlc1swXSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZURhdGVDaGFuZ2UuZW1pdCh0aGlzLmFjdGl2ZURhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgY2FsZW5kYXIgbG9vayB0aGUgc2FtZSBpbiB0aGUgZGlmZmVyZW50IGJyb3dzZXJzXG4gICAgICAgIC8vIHdoaWNoIGFsc28gc21vb3RoZW5zIHRoZSBuYXZpZ2F0aW9uIGFuaW1hdGlvblxuICAgICAgICBpZiAodGhpcy52aWV3cyA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5zZXRUYWJsZU1pbldpZHRoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaW50bFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpbml0U2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gdGhpcy5idXMuc2VydmljZSh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgIH1cbiAgICBpc01vbnRoVmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldyA9PT0gQ2FsZW5kYXJWaWV3RW51bS5tb250aDtcbiAgICB9XG4gICAgZ2V0Q2FwdGlvblRpdGxlKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS50aXRsZShkYXRlKTtcbiAgICB9XG4gICAgZ2V0Q2FwdGlvbkNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc01vbnRoVmlldygpID8gJ2stbW9udGgtaGVhZGVyJyA6ICdrLW1ldGEtaGVhZGVyJztcbiAgICB9XG4gICAgYW5pbWF0ZVZpZXcoYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCB0YWJsZSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCd0YWJsZScpO1xuICAgICAgICAvLyB0aGUgd2hvbGUgd2lkdGggZXhjbHVkaW5nIHBhZGRpbmcvbWFyZ2luXG4gICAgICAgIGNvbnN0IGluaXRpYWxDb250YWluZXJXaWR0aCA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLndpZHRoKTtcbiAgICAgICAgLy8gdGFibGUgd2lkdGhcbiAgICAgICAgY29uc3QgdGFibGVXaWR0aCA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZSh0YWJsZSkud2lkdGgpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGNvbnRhaW5lciwgJ3dpZHRoJywgYCR7aW5pdGlhbENvbnRhaW5lcldpZHRofXB4YCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoY29udGFpbmVyLCAnb3ZlcmZsb3cnLCAndmlzaWJsZScpO1xuICAgICAgICAvLyBpbml0aWFsaXplIGFuIGFkZGl0aW9uYWwgdmlldyBmb3IgdGhlIGFuaW1hdGlvblxuICAgICAgICBpZiAoYWN0aW9uID09PSBBY3Rpb24uTmV4dFZpZXcpIHtcbiAgICAgICAgICAgIC8vIGFuaW1hdGluZyBBY3Rpb24uTmV4dFZpZXcgcmVxdWlyZXMgYWRkaW5nIGFuIGFkZGl0aW9uYWwgdmlldyBiZWZvcmUgdGhlIHJlbmRlcmVkIHZpZXdzXG4gICAgICAgICAgICB0aGlzLm5leHRBbmltYXRpb25EYXRlID0gY2xvbmVEYXRlKHRoaXMuZGF0ZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYW5pbWF0aW5nIEFjdGlvbi5QcmV2VmlldyByZXF1aXJlcyBhZGRpbmcgYW4gYWRkaXRpb25hbCB2aWV3IGFmdGVyIHRoZSByZW5kZXJlZCB2aWV3c1xuICAgICAgICAgICAgdGhpcy5wcmV2QW5pbWF0aW9uRGF0ZSA9IGNsb25lRGF0ZSh0aGlzLmRhdGVzW3RoaXMuZGF0ZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJ1biBjZHIgdG8gcmVuZGVyIHRoZSBhZGRpdGlvbmFsIHZpZXdcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgndGFibGUnKS5mb3JFYWNoKHRhYmxlID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGFibGUsICd3aWR0aCcsIGAke3RhYmxlV2lkdGh9cHhgKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXdzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0YWJsZSwgJ21pbi13aWR0aCcsIGAke2luaXRpYWxDb250YWluZXJXaWR0aH1weGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gd2UgYWx3YXlzIHNsaWRlIGJ5IHRoZSB3aWR0aCBvZiAxIHRhYmxlXG4gICAgICAgIC8vIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eSBpcyBlbnN1cmVkIGJ5IG1lYXN1cmluZyB0aGUgY2xpZW50IHJlY3RhbmdsZSBhbmQgc3Vic3RyYWN0aW5nIHRoZSBnYXBcbiAgICAgICAgY29uc3QgdGFiUmVjdCA9IHRhYmxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBjb250YWluZXJHYXAgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5jb2x1bW5HYXApO1xuICAgICAgICBjb25zdCBzdGFydCA9IGFjdGlvbiA9PT0gQWN0aW9uLk5leHRWaWV3ID8gJ3RyYW5zbGF0ZVgoMCknIDogYHRyYW5zbGF0ZVgoLSR7dGFiUmVjdC53aWR0aCArIGNvbnRhaW5lckdhcH1weClgO1xuICAgICAgICBjb25zdCBlbmQgPSBhY3Rpb24gPT09IEFjdGlvbi5OZXh0VmlldyA/IGB0cmFuc2xhdGVYKC0ke3RhYlJlY3Qud2lkdGggKyBjb250YWluZXJHYXB9cHgpYCA6ICd0cmFuc2xhdGVYKDApJztcbiAgICAgICAgaWYgKCF0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBjb250YWluZXIuYW5pbWF0ZShbXG4gICAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHN0YXJ0IH0sXG4gICAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IGVuZCB9XG4gICAgICAgICAgICBdLCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgICAgICAgICBlYXNpbmc6ICdlYXNlLW91dCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24ub25jYW5jZWwgPSB0aGlzLmFuaW1hdGlvbi5vbmZpbmlzaCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBhbGwgaW5saW5lIHN0eWxlc1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlU3R5bGUoY29udGFpbmVyLCAnd2lkdGgnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZVN0eWxlKGNvbnRhaW5lciwgJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RhYmxlJykuZm9yRWFjaCh0YWJsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlU3R5bGUodGFibGUsICd3aWR0aCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBhbmltYXRpb24gYW5kIHRoZSBhbmltYXRpb24gdmlld1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRBbmltYXRpb25EYXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZBbmltYXRpb25EYXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBydW4gY2RyIHRvIHJlbW92ZSBhZGRpdGlvbmFsIGFuaW1hdGlvbiB2aWV3IGZyb20gdGhlIG1hcmt1cFxuICAgICAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBhbmltYXRpb24gaXMgYWxyZWFkeSBydW5uaW5nLCBjYW5jZWwgaXQgYW5kIHNob3cgdGhlIGVuZCBuYXZpZ2F0aW9uIHJlc3VsdCBvbiBtdWx0aXBsZSBwcmV2L25leHQgYnV0dG9uIGNsaWNrc1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmF2aWdhdGUoYWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGVOYXZpZ2F0aW9uICYmIGlzRG9jdW1lbnRBdmFpbGFibGUoKSAmJiBpc1ByZXNlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYW5pbWF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVZpZXcoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB0aGlzLm1vdmUoYWN0aW9uKTtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuc2VydmljZS5kYXRlc0xpc3QoY2FuZGlkYXRlLCB0aGlzLmdldFRha2UodGhpcy5za2lwKSk7XG4gICAgICAgIGlmICh0aGlzLmlzTGlzdEluUmFuZ2UobGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZXMgPSBsaXN0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IGNsb25lRGF0ZSh0aGlzLmRhdGVzWzBdKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IGNsb25lRGF0ZShjYW5kaWRhdGUpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlQ2hhbmdlLmVtaXQodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgICAgcmV0dXJuIGNsb25lRGF0ZShjYW5kaWRhdGUpO1xuICAgIH1cbiAgICBjYW5OYXZpZ2F0ZShhY3Rpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc0xpc3RJblJhbmdlKHRoaXMuc2VydmljZS5kYXRlc0xpc3QodGhpcy5tb3ZlKGFjdGlvbiksIHRoaXMuZ2V0VGFrZSh0aGlzLnNraXApKSk7XG4gICAgfVxuICAgIHNldFRhYmxlTWluV2lkdGgoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCB0YWJsZSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCd0YWJsZScpO1xuICAgICAgICBpZiAodGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcikud2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0YWJsZSwgJ21pbi13aWR0aCcsIGAke2NvbnRhaW5lcldpZHRofXB4YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW50bENoYW5nZSgpIHtcbiAgICAgICAgdGhpcy53ZWVrTmFtZXMgPSB0aGlzLndlZWtTZXJ2aWNlLmdldFdlZWtOYW1lcyh0aGlzLndlZWtOdW1iZXIpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgY2xhbXBEYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkYXRlSW5SYW5nZSh2YWx1ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICB9XG4gICAgbW92ZShhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5tb3ZlKHRoaXMuZGF0ZXNbMF0gfHwgdGhpcy5mb2N1c2VkRGF0ZSwgYWN0aW9uKTtcbiAgICB9XG4gICAgaXNMaXN0SW5SYW5nZShsaXN0KSB7XG4gICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSB0aGlzLnNlcnZpY2UuYmVnaW5uaW5nT2ZQZXJpb2QodGhpcy5taW4pO1xuICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gdGhpcy5zZXJ2aWNlLmJlZ2lubmluZ09mUGVyaW9kKHRoaXMuc2VydmljZS5hZGRUb0RhdGUodGhpcy5tYXgsIDEpKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyQm91bmQgPD0gbGlzdFswXSAmJiBsaXN0W2xpc3QubGVuZ3RoIC0gMV0gPCB1cHBlckJvdW5kO1xuICAgIH1cbiAgICBpc0luRGF0ZXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5pc0luQXJyYXkodmFsdWUsIHRoaXMuZGF0ZXMpO1xuICAgIH1cbiAgICBnZXRUYWtlKHNraXApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMudG90YWwgLSBza2lwLCB0aGlzLnZpZXdzKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxUZW1wbGF0ZVJlZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJUZW1wbGF0ZVJlZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVSYW5nZUVuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxVSURcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImZvY3VzZWREYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0FjdGl2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0aW9uUmFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZERhdGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInZpZXdzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93Vmlld0hlYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0ZU5hdmlnYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJDZWxsQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxFbnRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbExlYXZlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVEYXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstY2FsZW5kYXItdmlld1wiKSxcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstaHN0YWNrXCIpLFxuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1hbGlnbi1pdGVtcy1zdGFydFwiKSxcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstanVzdGlmeS1jb250ZW50LWNlbnRlclwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2V0Q29tcG9uZW50Q2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci1tb250aHZpZXdcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2V0Q29tcG9uZW50TW9udGhDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci15ZWFydmlld1wiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJnZXRDb21wb25lbnRZZWFyQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstY2FsZW5kYXItZGVjYWRldmlld1wiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJnZXRDb21wb25lbnREZWNhZGVDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci1jZW50dXJ5dmlld1wiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJnZXRDb21wb25lbnRDZW50dXJ5Q2xhc3NcIiwgbnVsbCk7XG5Ib3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYWxlbmRhci1ob3Jpem9udGFsJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLXRlbXBsYXRlICN0YWJsZVRlbXBsYXRlIGxldC1kYXRlPVwiZGF0ZVwiIGxldC1jbGFzcz1cImNsYXNzTmFtZVwiPlxuICAgICAgICAgICAgPHRhYmxlXG4gICAgICAgICAgICAgICAgcm9sZT1cImdyaWRcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay1jb250ZW50IGstY2FsZW5kYXItY29udGVudCBrLWNhbGVuZGFyLXRhYmxlXCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJjbGFzc1wiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGNhcHRpb24gKm5nSWY9XCJzaG93Vmlld0hlYWRlclwiIFtuZ0NsYXNzXT1cImdldENhcHRpb25DbGFzcygpXCI+e3sgZ2V0Q2FwdGlvblRpdGxlKGRhdGUpIH19PC9jYXB0aW9uPlxuICAgICAgICAgICAgICAgIDx0aGVhZCAqbmdJZj1cImlzTW9udGhWaWV3KClcIiBjbGFzcz1cImstY2FsZW5kYXItdGhlYWRcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVwiay1jYWxlbmRhci10clwiIHJvbGU9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aCAqbmdGb3I9XCJsZXQgbmFtZSBvZiB3ZWVrTmFtZXNcIiBjbGFzcz1cImstY2FsZW5kYXItdGhcIj57e25hbWV9fTwvdGg+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICA8dGJvZHlcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWNhbGVuZGFyLXRib2R5XCJcbiAgICAgICAgICAgICAgICAgICAga2VuZG9DYWxlbmRhclZpZXdcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cInJvd2dyb3VwXCJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uPVwiaG9yaXpvbnRhbFwiXG4gICAgICAgICAgICAgICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdcIlxuICAgICAgICAgICAgICAgICAgICBbaXNBY3RpdmVdPVwiaXNBY3RpdmVcIlxuICAgICAgICAgICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICAgICAgW2NlbGxVSURdPVwiY2VsbFVJRFwiXG4gICAgICAgICAgICAgICAgICAgIFtmb2N1c2VkRGF0ZV09XCJmb2N1c2VkRGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtzZWxlY3RlZERhdGVzXT1cInNlbGVjdGVkRGF0ZXNcIlxuICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uUmFuZ2VdPVwic2VsZWN0aW9uUmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICBbYWN0aXZlUmFuZ2VFbmRdPVwiYWN0aXZlUmFuZ2VFbmRcIlxuICAgICAgICAgICAgICAgICAgICBbd2Vla051bWJlcl09XCJ3ZWVrTnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlUmVmXT1cImNlbGxUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgIFt3ZWVrTnVtYmVyVGVtcGxhdGVSZWZdPVwid2Vla051bWJlclRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgW3ZpZXdEYXRlXT1cImRhdGVcIlxuICAgICAgICAgICAgICAgICAgICAoY2VsbENsaWNrKT1cImNlbGxDbGljay5lbWl0KCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAod2Vla051bWJlckNlbGxDbGljayk9XCJ3ZWVrTnVtYmVyQ2VsbENsaWNrLmVtaXQoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChjZWxsRW50ZXIpPVwiY2VsbEVudGVyLmVtaXQoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChjZWxsTGVhdmUpPVwiY2VsbExlYXZlLmVtaXQoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgIDwhLS0gV2hlbiBOZXh0IGlzIGNsaWNrZWQgYSBwbGFjZWhvbGRlciB0YWJsZSBpcyByZW5kZXJlZCBiZWZvcmUgdGhlIE1haW4gVGFibGUgLS0+XG4gICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgKm5nSWY9XCJuZXh0QW5pbWF0aW9uRGF0ZVwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJ0YWJsZVRlbXBsYXRlXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgZGF0ZTogbmV4dEFuaW1hdGlvbkRhdGUsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnay1wb2ludGVyLWV2ZW50cy1ub25lJ1xuICAgICAgICAgICAgfVwiXG4gICAgICAgID5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICprRm9yPVwibGV0IGRhdGUgb2YgZGF0ZXNcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwidGFibGVUZW1wbGF0ZVwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgIGRhdGU6IGRhdGVcbiAgICAgICAgICAgIH1cIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgPCEtLSBXaGVuIFByZXYgaXMgY2xpY2tlZCBhIHBsYWNlaG9sZGVyIHRhYmxlIGlzIHJlbmRlcmVkIGFmdGVyIHRoZSBNYWluIFRhYmxlIC0tPlxuICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICpuZ0lmPVwicHJldkFuaW1hdGlvbkRhdGVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwidGFibGVUZW1wbGF0ZVwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgIGRhdGU6IHByZXZBbmltYXRpb25EYXRlLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2stcG9pbnRlci1ldmVudHMtbm9uZSdcbiAgICAgICAgICAgIH1cIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQnVzVmlld1NlcnZpY2UsXG4gICAgICAgIEludGxTZXJ2aWNlLFxuICAgICAgICBXZWVrTmFtZXNTZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyXSlcbl0sIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudCk7XG5cbmNvbnN0IG5vb3AkMSA9ICgpID0+IGZhbHNlO1xuY29uc3QgRElTQUJMRURfREFURVNfRE9DX0xJTksgPSAnaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvY2FsZW5kYXIvZGlzYWJsZWQtZGF0ZXMvJztcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRGlzYWJsZWREYXRlc1NlcnZpY2UgPSBjbGFzcyBEaXNhYmxlZERhdGVzU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgZXZlcnkgdGltZSB0aGUgYGlzRGF0ZURpc2FibGVkYCBtZXRob2QgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYXNlZCBvbiB0aGUgdXNlci1kZWZpbmVkIGBkaXNhYmxlZERhdGVzYCBpbnB1dCBldmFsdWF0ZXMgaWYgdGhlIGRhdGUgaXMgZGlzYWJsZWQuXG4gICAgICAgICAqIElmIG5vdCBzZXQsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNEYXRlRGlzYWJsZWQgPSBub29wJDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGBpc0RhdGVEaXNhYmxlZGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqIElmIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZXMgaXQgYXMtaXMgYW5kIHBhc3NlcyBlYWNoIGRhdGUgdG8gaXQgZm9yIGV2YWx1YXRpb24uXG4gICAgICogVGhlIHRpbWUgcGFydCBpcyBzZXQgdG8gYG1pZG5pZ2h0YC5cbiAgICAgKiAqIElmIGEgYERhdGVbXWAgaXMgcHJvdmlkZWQsIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyB0aGUgdGFyZ2V0ZWQgZGF0ZSBhZ2FpbnN0XG4gICAgICogdGhlIGxpc3RlZCBkYXRlcyBhbmQsIGlmIHRoZSB0YXJnZXRlZCBkYXRlIGlzIGxpc3RlZCwgbWFya3MgaXQgYXMgZGlzYWJsZWQuXG4gICAgICogKiBJZiBhIGBEYXlbXWAgaXMgcHJvdmlkZWQsIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0aGUgcHJvdmlkZWQgZGF5cyBvZiB0aGVcbiAgICAgKiB3ZWVrIGFzIGRpc2FibGVkLlxuICAgICAqL1xuICAgIGluaXRpYWxpemUoZGlzYWJsZWREYXRlcykge1xuICAgICAgICBpZiAodHlwZW9mIGRpc2FibGVkRGF0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEYXRlRGlzYWJsZWQgPSAoZGF0ZSkgPT4gZGlzYWJsZWREYXRlcyhnZXREYXRlKGRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bWJlckFycmF5KGRpc2FibGVkRGF0ZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNhYmxlZFdlZWtEYXlzID0gbmV3IFNldChkaXNhYmxlZERhdGVzKTtcbiAgICAgICAgICAgIHRoaXMuaXNEYXRlRGlzYWJsZWQgPSAoZGF0ZSkgPT4gZGlzYWJsZWRXZWVrRGF5cy5oYXMoZGF0ZS5nZXREYXkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlQXJyYXkoZGlzYWJsZWREYXRlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREaXNhYmxlZERhdGVzID0gbmV3IFNldChkaXNhYmxlZERhdGVzLm1hcChkYXRlID0+IGdldERhdGUoZGF0ZSkuZ2V0VGltZSgpKSk7XG4gICAgICAgICAgICB0aGlzLmlzRGF0ZURpc2FibGVkID0gKGRhdGUpID0+IG5vcm1hbGl6ZWREaXNhYmxlZERhdGVzLmhhcyhnZXREYXRlKGRhdGUpLmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRGF0ZURpc2FibGVkID0gbm9vcCQxO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlJbnZhbGlkSW5wdXQoZGlzYWJsZWREYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnlTZXJ2aWNlQ2hhbmdlKCk7XG4gICAgfVxuICAgIG5vdGlmeUludmFsaWRJbnB1dChkaXNhYmxlZERhdGVzKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZGlzYWJsZWREYXRlcykgJiYgaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICdkaXNhYmxlZERhdGVzJyB2YWx1ZSBzaG91bGQgYmUgYSBmdW5jdGlvbiwgYSBEYXkgYXJyYXkgb3IgYSBEYXRlIGFycmF5LiBDaGVjayAke0RJU0FCTEVEX0RBVEVTX0RPQ19MSU5LfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub3RpZnlTZXJ2aWNlQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCgpO1xuICAgIH1cbn07XG5EaXNhYmxlZERhdGVzU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgRGlzYWJsZWREYXRlc1NlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEhlYWRlckNvbXBvbmVudCA9IGNsYXNzIEhlYWRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYnVzLCBjZHIsIGxvY2FsaXphdGlvbiwgaW50bCwgZGlzYWJsZWREYXRlc1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5idXMgPSBidXM7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzU2VydmljZSA9IGRpc2FibGVkRGF0ZXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50b2RheUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMubWluID0gbmV3IERhdGUoTUlOX0RBVEUpO1xuICAgICAgICB0aGlzLm1heCA9IG5ldyBEYXRlKE1BWF9EQVRFKTtcbiAgICAgICAgdGhpcy5yYW5nZUxlbmd0aCA9IDE7XG4gICAgICAgIHRoaXMuaXNQcmV2RGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzTmV4dERpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaG93TmF2aWdhdGlvbkJ1dHRvbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b2RheUJ1dHRvbkNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnByZXZCdXR0b25DbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5uZXh0QnV0dG9uQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50Q2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuaW50bC5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmludGxDaGFuZ2UuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMubDEwbkNoYW5nZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5kaXNhYmxlZERhdGVzU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLnNldFRvZGF5QXZhaWxhYmlsaXR5LmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoXykge1xuICAgICAgICBjb25zdCBzZXJ2aWNlID0gdGhpcy5idXMuc2VydmljZSh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgICAgICBpZiAoIXNlcnZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVZpZXdWYWx1ZSA9IENhbGVuZGFyVmlld0VudW1bdGhpcy5hY3RpdmVWaWV3XTtcbiAgICAgICAgdGhpcy50b2RheU1lc3NhZ2UgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ3RvZGF5Jyk7XG4gICAgICAgIHRoaXMuc2V0VG9kYXlBdmFpbGFiaWxpdHkoKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZSA9IHRoaXMuYnVzLmNhbk1vdmVVcCh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgICAgICB0aGlzLnRpdGxlID0gdGhpcy5nZXRUaXRsZSgpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGhhbmRsZVRvZGF5Q2xpY2soKSB7XG4gICAgICAgIGlmICghdGhpcy50b2RheUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVzLm1vdmVUb0JvdHRvbSh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgICAgICB0aGlzLnRvZGF5QnV0dG9uQ2xpY2suZW1pdChkYXRlSW5SYW5nZShnZXRUb2RheSgpLCB0aGlzLm1pbiwgdGhpcy5tYXgpKTtcbiAgICB9XG4gICAgaGFuZGxlTmF2aWdhdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hdmlnYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idXMubW92ZVVwKHRoaXMuYWN0aXZlVmlldyk7XG4gICAgfVxuICAgIGludGxDaGFuZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREYXRlICYmIHRoaXMuYnVzLnNlcnZpY2UodGhpcy5hY3RpdmVWaWV3KSkge1xuICAgICAgICAgICAgdGhpcy50aXRsZSA9IHRoaXMuZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGwxMG5DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMucHJldkJ1dHRvblRpdGxlID0gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdwcmV2QnV0dG9uVGl0bGUnKTtcbiAgICAgICAgdGhpcy5uZXh0QnV0dG9uVGl0bGUgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ25leHRCdXR0b25UaXRsZScpO1xuICAgICAgICB0aGlzLnRvZGF5TWVzc2FnZSA9IHRoaXMubG9jYWxpemF0aW9uLmdldCgndG9kYXknKTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIGdldFRpdGxlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2aWNlID0gdGhpcy5idXMuc2VydmljZSh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgICAgICBjb25zdCB0YWtlID0gdGhpcy5yYW5nZUxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gc2VydmljZS50aXRsZSh0aGlzLmN1cnJlbnREYXRlKTtcbiAgICAgICAgY29uc3QgbmV4dERhdGUgPSBzZXJ2aWNlLmFkZFRvRGF0ZSh0aGlzLmN1cnJlbnREYXRlLCB0YWtlKTtcbiAgICAgICAgaWYgKHRha2UgPCAxIHx8ICFzZXJ2aWNlLmlzSW5SYW5nZShuZXh0RGF0ZSwgdGhpcy5taW4sIHRoaXMubWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aXRsZX0gLSAke3NlcnZpY2UudGl0bGUobmV4dERhdGUpfWA7XG4gICAgfVxuICAgIHNldFRvZGF5QXZhaWxhYmlsaXR5KCkge1xuICAgICAgICBjb25zdCB0b2RheSA9IGdldFRvZGF5KCk7XG4gICAgICAgIGNvbnN0IGlzVG9kYXlJblJhbmdlID0gaXNJblJhbmdlKHRvZGF5LCBnZXREYXRlKHRoaXMubWluKSwgZ2V0RGF0ZSh0aGlzLm1heCkpO1xuICAgICAgICBjb25zdCBpc0Rpc2FibGVkID0gdGhpcy5kaXNhYmxlZERhdGVzU2VydmljZS5pc0RhdGVEaXNhYmxlZCh0b2RheSk7XG4gICAgICAgIHRoaXMudG9kYXlBdmFpbGFibGUgPSBpc1RvZGF5SW5SYW5nZSAmJiAhaXNEaXNhYmxlZDtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VycmVudERhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlTGVuZ3RoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGVtcGxhdGVSZWZcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImlzUHJldkRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc05leHREaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd05hdmlnYXRpb25CdXR0b25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b2RheUJ1dHRvbkNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmV2QnV0dG9uQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm5leHRCdXR0b25DbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoXCJjbGFzcy5rLWNhbGVuZGFyLWhlYWRlclwiKSxcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstaHN0YWNrXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJnZXRDb21wb25lbnRDbGFzc1wiLCB2b2lkIDApO1xuSGVhZGVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYWxlbmRhci1oZWFkZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxzcGFuIGNsYXNzPVwiay1idXR0b24gay1idXR0b24tbWQgay1yb3VuZGVkLW1kIGstYnV0dG9uLWZsYXQgay1idXR0b24tZmxhdC1iYXNlIGstY2FsZW5kYXItdGl0bGVcIiBbY2xhc3Muay1kaXNhYmxlZF09XCIhbmF2aWdhdGVcIlxuICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICBjbGljazogaGFuZGxlTmF2aWdhdGlvblxuICAgICAgICB9XCJcbiAgICAgICAgW3Njb3BlXT1cInRoaXNcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiF0ZW1wbGF0ZVJlZlwiPnt7dGl0bGV9fTwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgW25nSWZdPVwidGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwidGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgJGltcGxpY2l0OiB0aXRsZSwgYWN0aXZlVmlldzogYWN0aXZlVmlld1ZhbHVlLCBkYXRlOiBjdXJyZW50RGF0ZSB9XCJcbiAgICAgICAgPjwvbmctdGVtcGxhdGU+XG4gICAgPC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiay1zcGFjZXJcIj48L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJrLWNhbGVuZGFyLW5hdiBrLWhzdGFja1wiPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAqbmdJZj1cInNob3dOYXZpZ2F0aW9uQnV0dG9uc1wiXG4gICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uIGstYnV0dG9uLW1kIGstcm91bmRlZC1tZCBrLWJ1dHRvbi1mbGF0IGstYnV0dG9uLWZsYXQtYmFzZSBrLWljb24tYnV0dG9uIGstcHJldi12aWV3XCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJpc1ByZXZEaXNhYmxlZFwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiaXNQcmV2RGlzYWJsZWRcIlxuICAgICAgICAgICAgW3RpdGxlXT1cInByZXZCdXR0b25UaXRsZVwiXG4gICAgICAgICAgICAoY2xpY2spPVwicHJldkJ1dHRvbkNsaWNrLmVtaXQoKVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1hcnJvdy02MC1sZWZ0XCI+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPHNwYW5cbiAgICAgICAgICAgIGNsYXNzPVwiay10b2RheSBrLW5hdi10b2RheVwiXG4gICAgICAgICAgICBbY2xhc3Muay1kaXNhYmxlZF09XCIhdG9kYXlBdmFpbGFibGVcIlxuICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgIGNsaWNrOiBoYW5kbGVUb2RheUNsaWNrXG4gICAgICAgICAgICB9XCJcbiAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgPlxuICAgICAgICAgICAge3sgdG9kYXlNZXNzYWdlIH19XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgKm5nSWY9XCJzaG93TmF2aWdhdGlvbkJ1dHRvbnNcIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvbiBrLWJ1dHRvbi1tZCBrLXJvdW5kZWQtbWQgay1idXR0b24tZmxhdCBrLWJ1dHRvbi1mbGF0LWJhc2Ugay1pY29uLWJ1dHRvbiBrLW5leHQtdmlld1wiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwiaXNOZXh0RGlzYWJsZWRcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImlzTmV4dERpc2FibGVkXCJcbiAgICAgICAgICAgIFt0aXRsZV09XCJuZXh0QnV0dG9uVGl0bGVcIlxuICAgICAgICAgICAgKGNsaWNrKT1cIm5leHRCdXR0b25DbGljay5lbWl0KClcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstaWNvbiBrLWktYXJyb3ctNjAtcmlnaHRcIj48L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIDwvc3Bhbj5cbiAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQnVzVmlld1NlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBJbnRsU2VydmljZSxcbiAgICAgICAgRGlzYWJsZWREYXRlc1NlcnZpY2VdKVxuXSwgSGVhZGVyQ29tcG9uZW50KTtcblxuY29uc3QgS0VZX1RPX0FDVElPTiA9IHtcbiAgICAnMzMnOiBBY3Rpb24uUHJldlZpZXcsXG4gICAgJzM0JzogQWN0aW9uLk5leHRWaWV3LFxuICAgICczNSc6IEFjdGlvbi5MYXN0SW5WaWV3LFxuICAgICczNic6IEFjdGlvbi5GaXJzdEluVmlldyxcbiAgICAnMzcnOiBBY3Rpb24uTGVmdCxcbiAgICAnMzgnOiBBY3Rpb24uVXAsXG4gICAgJzM5JzogQWN0aW9uLlJpZ2h0LFxuICAgICc0MCc6IEFjdGlvbi5Eb3duLFxuICAgICdtZXRhKzM4JzogQWN0aW9uLlVwcGVyVmlldyxcbiAgICAnbWV0YSs0MCc6IEFjdGlvbi5Mb3dlclZpZXdcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IE5hdmlnYXRpb25TZXJ2aWNlID0gY2xhc3MgTmF2aWdhdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGJ1cykge1xuICAgICAgICB0aGlzLmJ1cyA9IGJ1cztcbiAgICB9XG4gICAgYWN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IGAke2V2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSA/ICdtZXRhKycgOiAnJ30ke2V2ZW50LmtleUNvZGV9YDtcbiAgICAgICAgcmV0dXJuIEtFWV9UT19BQ1RJT05bYWN0aW9uXTtcbiAgICB9XG4gICAgbW92ZSh2YWx1ZSwgYWN0aW9uLCBhY3RpdmVWaWV3KSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzLmJ1cy5zZXJ2aWNlKGFjdGl2ZVZpZXcpO1xuICAgICAgICBpZiAoIXNlcnZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uID09PSBBY3Rpb24uVXBwZXJWaWV3ICYmIHRoaXMuYnVzLmNhbk1vdmVVcChhY3RpdmVWaWV3KSkge1xuICAgICAgICAgICAgdGhpcy5idXMubW92ZVVwKGFjdGl2ZVZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb24gPT09IEFjdGlvbi5Mb3dlclZpZXcgJiYgdGhpcy5idXMuY2FuTW92ZURvd24oYWN0aXZlVmlldykpIHtcbiAgICAgICAgICAgIHRoaXMuYnVzLm1vdmVEb3duKGFjdGl2ZVZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJ2aWNlLm1vdmUodmFsdWUsIGFjdGlvbik7XG4gICAgfVxufTtcbk5hdmlnYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQnVzVmlld1NlcnZpY2VdKVxuXSwgTmF2aWdhdGlvblNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFNlbGVjdGlvblNlcnZpY2UgPSBjbGFzcyBTZWxlY3Rpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihidXMpIHtcbiAgICAgICAgdGhpcy5idXMgPSBidXM7XG4gICAgfVxuICAgIHBlcmZvcm1TZWxlY3Rpb24oYXJncykge1xuICAgICAgICBsZXQgeyBkYXRlLCBtb2RpZmllcnMsIHNlbGVjdGlvbk1vZGUsIGFjdGl2ZVZpZXdFbnVtLCByYW5nZVBpdm90IH0gPSBhcmdzO1xuICAgICAgICBsZXQgc2VsZWN0ZWREYXRlcyA9IGFyZ3Muc2VsZWN0ZWREYXRlcy5zbGljZSgpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpcGxlJykge1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5jdHJsS2V5IHx8IG1vZGlmaWVycy5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEYXRlU2VsZWN0ZWQoc2VsZWN0ZWREYXRlcywgZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlcyA9IHNlbGVjdGVkRGF0ZXMuZmlsdGVyKGl0ZW0gPT4gIWlzRXF1YWwoaXRlbSwgZGF0ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlcy5wdXNoKGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYW5nZVBpdm90ID0gZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGlmaWVycy5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHNvcnREYXRlcyhbcmFuZ2VQaXZvdCB8fCBkYXRlLCBkYXRlXSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlcyA9IHRoaXMuYnVzLnNlcnZpY2UoYWN0aXZlVmlld0VudW0pLmRhdGVSYW5nZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICByYW5nZVBpdm90ID0gZGF0ZSA+IHNlbGVjdGVkRGF0ZXNbMF0gPyBzZWxlY3RlZERhdGVzWzBdIDogbGFzdChzZWxlY3RlZERhdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0ZXMgPSBbZGF0ZV07XG4gICAgICAgICAgICAgICAgcmFuZ2VQaXZvdCA9IGRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RlZERhdGVzID0gW2RhdGVdO1xuICAgICAgICAgICAgcmFuZ2VQaXZvdCA9IGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VsZWN0ZWREYXRlcywgcmFuZ2VQaXZvdCB9O1xuICAgIH1cbiAgICBpc0RhdGVTZWxlY3RlZChzZWxlY3RlZERhdGVzLCBkYXRlKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZERhdGVzLnNvbWUoaXRlbSA9PiBpc0VxdWFsKGl0ZW0sIGRhdGUpKTtcbiAgICB9XG59O1xuU2VsZWN0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0J1c1ZpZXdTZXJ2aWNlXSlcbl0sIFNlbGVjdGlvblNlcnZpY2UpO1xuXG4vKipcbiAqIFVzZWQgZm9yIHJlbmRlcmluZyB0aGUgY2VsbCBjb250ZW50IG9mIHRoZSBDYWxlbmRhci4gVG8gZGVmaW5lIHRoZSBjZWxsIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWdcbiAqIHdpdGggdGhlIGBrZW5kb0NhbGVuZGFyQ2VsbFRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBjb21wb25lbnQgdGFnLiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlXG4gKiBjdXJyZW50IGNvbXBvbmVudC4gVG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGRhdGUsIHVzZSB0aGUgYGxldC1kYXRlYCBkaXJlY3RpdmUuIFRvIHByb3ZpZGUgbW9yZSBkZXRhaWxzXG4gKiBhYm91dCB0aGUgY3VycmVudCBjZWxsLCBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgYGNlbGxDb250ZXh0YCBieSB1c2luZyB0aGUgYGxldC1jZWxsQ29udGV4dGAgZGlyZWN0aXZlLlxuICpcbiAqIEZvciBtb3JlIGV4YW1wbGVzLCByZWZlciB0byB0aGUgYXJ0aWNsZSBvbiBbdGVtcGxhdGVzXSh7JSBzbHVnIHRlbXBsYXRlc19jYWxlbmRhciAlfSkuXG4gKlxuICogPiBga2VuZG9DYWxlbmRhckNlbGxUZW1wbGF0ZWAgaXMgZXF1aXZhbGVudCB0b1xuICogPiBbYGtlbmRvQ2FsZW5kYXJNb250aENlbGxUZW1wbGF0ZWBdKHslIHNsdWcgYXBpX2RhdGVpbnB1dHNfbW9udGhjZWxsdGVtcGxhdGVkaXJlY3RpdmUgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogc3R5bGVzOiBbJy5jdXN0b20geyBjb2xvcjogcmVkOyB9J10sXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1jYWxlbmRhcj5cbiAqICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0NhbGVuZGFyQ2VsbFRlbXBsYXRlIGxldC1kYXRlPlxuICogICAgICA8c3BhbiBjbGFzcz1cImN1c3RvbVwiPnt7ZGF0ZS5nZXREYXRlKCl9fTwvc3Bhbj5cbiAqICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9rZW5kby1jYWxlbmRhcj5cbiAqIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICogYGBgXG4gKi9cbmxldCBDZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBDZWxsVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuQ2VsbFRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DYWxlbmRhckNlbGxUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBDZWxsVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFVzZWQgZm9yIHJlbmRlcmluZyB0aGUgbW9udGggY2VsbCBjb250ZW50IG9mIHRoZSBDYWxlbmRhci4gVG8gZGVmaW5lIHRoZSBtb250aCBjZWxsIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWdcbiAqIHdpdGggdGhlIGBrZW5kb0NhbGVuZGFyTW9udGhDZWxsVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IGlzIHNldCB0byB0aGUgY3VycmVudFxuICogY29tcG9uZW50LiBUbyBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZGF0ZSwgdXNlIHRoZSBgbGV0LWRhdGVgIGRpcmVjdGl2ZS4gVG8gcHJvdmlkZSBtb3JlIGRldGFpbHMgYWJvdXQgdGhlIGN1cnJlbnRcbiAqIG1vbnRoIGNlbGwsIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBgY2VsbENvbnRleHRgIGJ5IHVzaW5nIHRoZSBgbGV0LWNlbGxDb250ZXh0YCBkaXJlY3RpdmUuXG4gKlxuICogRm9yIG1vcmUgZXhhbXBsZXMsIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uIFt0ZW1wbGF0ZXNdKHslIHNsdWcgdGVtcGxhdGVzX2NhbGVuZGFyICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHN0eWxlczogWycuY3VzdG9tIHsgY29sb3I6IHJlZDsgfSddLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tY2FsZW5kYXI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9DYWxlbmRhck1vbnRoQ2VsbFRlbXBsYXRlIGxldC1jb250ZXh0PVwiY2VsbENvbnRleHRcIj5cbiAqICAgICAgPHNwYW4gY2xhc3M9XCJjdXN0b21cIj57e2NvbnRleHQuZm9ybWF0dGVkVmFsdWV9fTwvc3Bhbj5cbiAqICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9rZW5kby1jYWxlbmRhcj5cbiAqIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICogYGBgXG4gKi9cbmxldCBNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbk1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DYWxlbmRhck1vbnRoQ2VsbFRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBVc2VkIGZvciByZW5kZXJpbmcgdGhlIHllYXIgY2VsbCBjb250ZW50IG9mIHRoZSBDYWxlbmRhci4gVG8gZGVmaW5lIHRoZSB5ZWFyIGNlbGwgdGVtcGxhdGUsIG5lc3QgYW5cbiAqIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvQ2FsZW5kYXJZZWFyQ2VsbFRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBjb21wb25lbnQgdGFnLlxuICogVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZSBjdXJyZW50IGNvbXBvbmVudC4gVG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGRhdGUsIHVzZVxuICogdGhlIGBsZXQtZGF0ZWAgZGlyZWN0aXZlLiBUbyBwcm92aWRlIG1vcmUgZGV0YWlscyBhYm91dCB0aGUgY3VycmVudCB5ZWFyIGNlbGwsIGdldCBhIHJlZmVyZW5jZSB0byB0aGVcbiAqIGN1cnJlbnQgYGNlbGxDb250ZXh0YCBieSB1c2luZyB0aGUgYGxldC1jZWxsQ29udGV4dGAgZGlyZWN0aXZlLlxuICpcbiAqIEZvciBtb3JlIGV4YW1wbGVzLCByZWZlciB0byB0aGUgYXJ0aWNsZSBvbiBbdGVtcGxhdGVzXSh7JSBzbHVnIHRlbXBsYXRlc19jYWxlbmRhciAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiBzdHlsZXM6IFsnLmN1c3RvbSB7IGNvbG9yOiByZWQ7IH0nXSxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWNhbGVuZGFyIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdcIj5cbiAqICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0NhbGVuZGFyWWVhckNlbGxUZW1wbGF0ZSBsZXQtY29udGV4dD1cImNlbGxDb250ZXh0XCI+XG4gKiAgICAgIDxzcGFuIGNsYXNzPVwiY3VzdG9tXCI+e3tjb250ZXh0LmZvcm1hdHRlZFZhbHVlfX08L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tY2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgcHVibGljIGFjdGl2ZVZpZXc6IENhbGVuZGFyVmlldyA9ICd5ZWFyJztcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2FsZW5kYXJZZWFyQ2VsbFRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFVzZWQgZm9yIHJlbmRlcmluZyB0aGUgZGVjYWRlIGNlbGwgY29udGVudCBvZiB0aGUgQ2FsZW5kYXIuIFRvIGRlZmluZSB0aGUgZGVjYWRlIGNlbGwgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gXG4gKiB0YWcgd2l0aCB0aGUgYGtlbmRvQ2FsZW5kYXJEZWNhZGVDZWxsVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IGlzIHNldCB0byB0aGVcbiAqIGN1cnJlbnQgY29tcG9uZW50LiBUbyBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZGF0ZSwgdXNlIHRoZSBgbGV0LWRhdGVgIGRpcmVjdGl2ZS4gVG8gcHJvdmlkZSBtb3JlIGRldGFpbHMgYWJvdXRcbiAqIHRoZSBjdXJyZW50IGRlY2FkZSBjZWxsLCBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgYGNlbGxDb250ZXh0YCBieSB1c2luZyB0aGUgYGxldC1jZWxsQ29udGV4dGAgZGlyZWN0aXZlLlxuICpcbiAqIEZvciBtb3JlIGV4YW1wbGVzLCByZWZlciB0byB0aGUgYXJ0aWNsZSBvbiBbdGVtcGxhdGVzXSh7JSBzbHVnIHRlbXBsYXRlc19jYWxlbmRhciAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiBzdHlsZXM6IFsnLmN1c3RvbSB7IGNvbG9yOiByZWQ7IH0nXSxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWNhbGVuZGFyIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdcIj5cbiAqICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0NhbGVuZGFyRGVjYWRlQ2VsbFRlbXBsYXRlIGxldC1jb250ZXh0PVwiY2VsbENvbnRleHRcIj5cbiAqICAgICAgPHNwYW4gY2xhc3M9XCJjdXN0b21cIj57e2NvbnRleHQuZm9ybWF0dGVkVmFsdWV9fTwvc3Bhbj5cbiAqICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9rZW5kby1jYWxlbmRhcj5cbiAqIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICBwdWJsaWMgYWN0aXZlVmlldzogQ2FsZW5kYXJWaWV3ID0gJ2RlY2FkZSc7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5EZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NhbGVuZGFyRGVjYWRlQ2VsbFRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogVXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBjZW50dXJ5IGNlbGwgY29udGVudCBvZiB0aGUgQ2FsZW5kYXIuIFRvIGRlZmluZSB0aGUgY2VudHVyeSBjZWxsIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YFxuICogdGFnIHdpdGggdGhlIGBrZW5kb0NhbGVuZGFyQ2VudHVyeUNlbGxUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgY29tcG9uZW50IHRhZy4gVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZVxuICogY3VycmVudCBjb21wb25lbnQuIFRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBkYXRlLCB1c2UgdGhlIGBsZXQtZGF0ZWAgZGlyZWN0aXZlLiBUbyBwcm92aWRlIG1vcmUgZGV0YWlscyBhYm91dFxuICogdGhlIGN1cnJlbnQgY2VudHVyeSBjZWxsLCBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgYGNlbGxDb250ZXh0YCBieSB1c2luZyB0aGUgYGxldC1jZWxsQ29udGV4dGAgZGlyZWN0aXZlLlxuICpcbiAqIEZvciBtb3JlIGV4YW1wbGVzLCByZWZlciB0byB0aGUgYXJ0aWNsZSBvbiBbdGVtcGxhdGVzXSh7JSBzbHVnIHRlbXBsYXRlc19jYWxlbmRhciAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiBzdHlsZXM6IFsnLmN1c3RvbSB7IGNvbG9yOiByZWQ7IH0nXSxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWNhbGVuZGFyIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdcIj5cbiAqICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0NhbGVuZGFyQ2VudHVyeUNlbGxUZW1wbGF0ZSBsZXQtY29udGV4dD1cImNlbGxDb250ZXh0XCI+XG4gKiAgICAgIDxzcGFuIGNsYXNzPVwiY3VzdG9tXCI+e3tjb250ZXh0LmZvcm1hdHRlZFZhbHVlfX08L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tY2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgcHVibGljIGFjdGl2ZVZpZXc6IENhbGVuZGFyVmlldyA9ICdjZW50dXJ5JztcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2FsZW5kYXJDZW50dXJ5Q2VsbFRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFVzZWQgZm9yIHJlbmRlcmluZyB0aGUgd2VlayBudW1iZXIgY2VsbCBjb250ZW50IGluIHRoZSBtb250aCB2aWV3IG9mIHRoZSBDYWxlbmRhci4gVG8gZGVmaW5lIHRoZSBtb250aCB3ZWVrIG51bWJlciBjZWxsIHRlbXBsYXRlLFxuICogbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnIHdpdGggdGhlIGBrZW5kb0NhbGVuZGFyV2Vla051bWJlckNlbGxUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgY29tcG9uZW50IHRhZy4gVGhlIHRlbXBsYXRlXG4gKiBjb250ZXh0IGlzIHNldCB0byB0aGUgY3VycmVudCBjb21wb25lbnQuIFRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBkYXRlLCB1c2UgdGhlIGBsZXQtZGF0ZWAgZGlyZWN0aXZlLiBUbyBwcm92aWRlIG1vcmVcbiAqIGRldGFpbHMgYWJvdXQgdGhlIGN1cnJlbnQgd2VlayBudW1iZXIgY2VsbCwgZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGBjZWxsQ29udGV4dGAgYnkgdXNpbmcgdGhlIGBsZXQtY2VsbENvbnRleHRgIGRpcmVjdGl2ZS5cbiAqXG4gKiBGb3IgbW9yZSBleGFtcGxlcywgcmVmZXIgdG8gdGhlIGFydGljbGUgb24gW3RlbXBsYXRlc10oeyUgc2x1ZyB0ZW1wbGF0ZXNfY2FsZW5kYXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogc3R5bGVzOiBbJy5jdXN0b20geyBjb2xvcjogcmVkOyB9J10sXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1jYWxlbmRhciBbd2Vla051bWJlcl09XCJ0cnVlXCI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9DYWxlbmRhcldlZWtOdW1iZXJDZWxsVGVtcGxhdGUgbGV0LWNvbnRleHQ9XCJjZWxsQ29udGV4dFwiPlxuICogICAgICA8c3BhbiBjbGFzcz1cImN1c3RvbVwiPnt7Y29udGV4dC5mb3JtYXR0ZWRWYWx1ZX19PC9zcGFuPlxuICogICAgPC9uZy10ZW1wbGF0ZT5cbiAqICA8L2tlbmRvLWNhbGVuZGFyPlxuICogYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gKiBgYGBcbiAqL1xubGV0IFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbldlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NhbGVuZGFyV2Vla051bWJlckNlbGxUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBVc2VkIGZvciByZW5kZXJpbmcgdGhlIGhlYWRlciB0aXRsZSBvZiB0aGUgQ2FsZW5kYXIuIFRvIGRlZmluZSB0aGUgaGVhZGVyIHRpdGxlIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWdcbiAqIHdpdGggdGhlIGBrZW5kb0NhbGVuZGFySGVhZGVyVGl0bGVUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgY29tcG9uZW50IHRhZy4gVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZVxuICogY3VycmVudCBjb21wb25lbnQuIFRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCB0aXRsZSwgdXNlIHRoZSBgbGV0LXRpdGxlYCBkaXJlY3RpdmUuIFRvIHByb3ZpZGUgbW9yZSBkZXRhaWxzIGFib3V0XG4gKiB0aGUgY3VycmVudCB0aXRsZSwgZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGBkYXRlYCBieSB1c2luZyB0aGUgYGxldC1kYXRlYCBkaXJlY3RpdmUgb3IgZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZVxuICogY3VycmVudCBhY3RpdmUgdmlldyAgYnkgdXNpbmcgdGhlIGBsZXQtYWN0aXZlVmlld2AgZGlyZWN0aXZlLlxuICpcbiAqIEZvciBtb3JlIGV4YW1wbGVzLCByZWZlciB0byB0aGUgYXJ0aWNsZSBvbiBbdGVtcGxhdGVzXSh7JSBzbHVnIHRlbXBsYXRlc19jYWxlbmRhciAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiBzdHlsZXM6IFsnLmN1c3RvbSB7IGNvbG9yOiByZWQ7IH0nXSxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWNhbGVuZGFyPlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvQ2FsZW5kYXJIZWFkZXJUaXRsZVRlbXBsYXRlIGxldC10aXRsZT5cbiAqICAgICAgPHNwYW4gY2xhc3M9XCJjdXN0b21cIj57e3RpdGxlfX08L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tY2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAqIGBgYFxuICovXG5sZXQgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2FsZW5kYXJIZWFkZXJUaXRsZVRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbWluVmFsaWRhdG9yID0gKG1pblZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIChjb250cm9sKSA9PiB7XG4gICAgICAgIGNvbnN0IGVyciA9IHtcbiAgICAgICAgICAgIG1pbkVycm9yOiB7XG4gICAgICAgICAgICAgICAgbWluVmFsdWU6IG1pblZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjb250cm9sLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghbWluVmFsdWUgfHwgIWNvbnRyb2wudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sLnZhbHVlIDwgbWluVmFsdWUgPyBlcnIgOiBudWxsO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbWF4VmFsaWRhdG9yID0gKG1heFZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIChjb250cm9sKSA9PiB7XG4gICAgICAgIGNvbnN0IGVyciA9IHtcbiAgICAgICAgICAgIG1heEVycm9yOiB7XG4gICAgICAgICAgICAgICAgbWF4VmFsdWU6IG1heFZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjb250cm9sLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghbWF4VmFsdWUgfHwgIWNvbnRyb2wudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sLnZhbHVlID4gbWF4VmFsdWUgPyBlcnIgOiBudWxsO1xuICAgIH07XG59O1xuXG5jb25zdCBub29wJDIgPSAoKSA9PiBudWxsO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRpc2FibGVkRGF0ZXNSYW5nZVZhbGlkYXRvciA9IChpc0RhdGVEaXNhYmxlZCkgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KGlzRGF0ZURpc2FibGVkKSkge1xuICAgICAgICByZXR1cm4gbm9vcCQyO1xuICAgIH1cbiAgICByZXR1cm4gKHNlbGVjdGVkUmFuZ2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNSYW5nZUNvbXBsZXRlID0gaXNQcmVzZW50KHNlbGVjdGVkUmFuZ2UpICYmIGlzUHJlc2VudChzZWxlY3RlZFJhbmdlLnN0YXJ0KSAmJiBpc1ByZXNlbnQoc2VsZWN0ZWRSYW5nZS5lbmQpO1xuICAgICAgICBpZiAoIWlzUmFuZ2VDb21wbGV0ZSB8fCBzZWxlY3RlZFJhbmdlLnN0YXJ0ID4gc2VsZWN0ZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc2FibGVkRGF0ZXMgPSBkaXNhYmxlZERhdGVzSW5SYW5nZShzZWxlY3RlZFJhbmdlLnN0YXJ0LCBzZWxlY3RlZFJhbmdlLmVuZCwgaXNEYXRlRGlzYWJsZWQpO1xuICAgICAgICBjb25zdCBlcnJvciA9IHtcbiAgICAgICAgICAgIGRpc2FibGVkRGF0ZXNJblJhbmdlOiBkaXNhYmxlZERhdGVzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkaXNhYmxlZERhdGVzLmxlbmd0aCA/IGVycm9yIDogbnVsbDtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFBpY2tlclNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25CbHVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNhbWVEYXRlU2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGF0ZUNvbXBsZXRlbmVzc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG59XG5cbmNvbnN0IEJPVFRPTV9WSUVXX0RPQ19MSU5LID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvYXBpL0NhbGVuZGFyQ29tcG9uZW50LyN0b2MtYm90dG9tdmlldyc7XG5jb25zdCBUT1BfVklFV19ET0NfTElOSyA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2FwaS9DYWxlbmRhckNvbXBvbmVudC8jdG9jLXRvcHZpZXcnO1xuY29uc3QgTUlOX0RPQ19MSU5LID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvYXBpL0NhbGVuZGFyQ29tcG9uZW50LyN0b2MtbWluJztcbmNvbnN0IE1BWF9ET0NfTElOSyA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2FwaS9DYWxlbmRhckNvbXBvbmVudC8jdG9jLW1heCc7XG5jb25zdCBWQUxVRV9ET0NfTElOSyA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2NhbGVuZGFyLyN0b2MtdXNpbmctd2l0aC1qc29uJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBSQU5HRV9DQUxFTkRBUl9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBtdWx0aTogdHJ1ZSxcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudCkgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLXVzZS1iZWZvcmUtZGVjbGFyZVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBSQU5HRV9DQUxFTkRBUl9SQU5HRV9WQUxJREFUT1JTID0ge1xuICAgIG11bHRpOiB0cnVlLFxuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQpIC8vdHNsaW50OmRpc2FibGUtbGluZTpuby11c2UtYmVmb3JlLWRlY2xhcmVcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIEtlbmRvIFVJIE11bHRpVmlld0NhbGVuZGFyIGNvbXBvbmVudCBmb3IgQW5ndWxhci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLW11bHRpdmlld2NhbGVuZGFyPjwva2VuZG8tbXVsdGl2aWV3Y2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAqIGBgYFxuICovXG5sZXQgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQgPSBjbGFzcyBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYnVzLCBlbGVtZW50LCBuYXZpZ2F0b3IsIHJlbmRlcmVyLCBjZHIsIHpvbmUsIGRpc2FibGVkRGF0ZXNTZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlLCBwaWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuYnVzID0gYnVzO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5hdmlnYXRvciA9IG5hdmlnYXRvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzU2VydmljZSA9IGRpc2FibGVkRGF0ZXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2UgPSBwaWNrZXJTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gbWluIG9yIG1heCB2YWxpZGF0b3JzIGFyZSBlbmZvcmNlZCB3aGVuIHZhbGlkYXRpbmcgYSBmb3JtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZVZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gdmFsaWRhdG9yIGZvciBkaXNhYmxlZFxuICAgICAgICAgKiBkYXRlIHJhbmdlcyBpcyBlbmZvcmNlZCB3aGVuIHZhbGlkYXRpbmcgYSBmb3JtXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGlzYWJsZWRfZGF0ZXNfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLXZhbGlkYXRpb24pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1JhbmdlVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgQ2FsZW5kYXIgc2VsZWN0aW9uIG1vZGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBtdWx0aXBsZV9zZWxlY3Rpb25fbXVsdGl2aWV3Y2FsZW5kYXIgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGF2YWlsYWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIGBzaW5nbGVgIChkZWZhdWx0KVxuICAgICAgICAgKiAqIGBtdWx0aXBsZWBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gJ3NpbmdsZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBkaXNhYmxlZGAgcHJvcGVydHkgb2YgdGhlIENhbGVuZGFyIGFuZFxuICAgICAgICAgKiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBhY3RpdmVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZF9tdWx0aXZpZXdjYWxlbmRhciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBgdGFiaW5kZXhgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhci4gQmFzZWQgb24gdGhlXG4gICAgICAgICAqIFtIVE1MIGB0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIGJlaGF2aW9yLFxuICAgICAgICAgKiBpdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBmb2N1c2FibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNIZWFkZXJBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGFjdGl2ZSB2aWV3IHRoYXQgdGhlIENhbGVuZGFyIGluaXRpYWxseSByZW5kZXJzXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYWN0aXZldmlld19tdWx0aXZpZXdjYWxlbmRhciAlfSkpLlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYWN0aXZlIHZpZXcgaXMgYG1vbnRoYC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBZb3UgaGF2ZSB0byBzZXQgYGFjdGl2ZVZpZXdgIHdpdGhpbiB0aGUgYHRvcFZpZXdgLWBib3R0b21WaWV3YCByYW5nZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IENhbGVuZGFyVmlld0VudW1bQ2FsZW5kYXJWaWV3RW51bS5tb250aF07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBib3R0b21tb3N0IHZpZXcsIHRvIHdoaWNoIHRoZSB1c2VyIGNhbiBuYXZpZ2F0ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVzX211bHRpdmlld2NhbGVuZGFyICV9I3RvYy1wYXJ0aWFsLWRhdGVzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdHRvbVZpZXcgPSBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW0ubW9udGhdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgdG9wbW9zdCB2aWV3LCB0byB3aGljaCB0aGUgdXNlciBjYW4gbmF2aWdhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvcFZpZXcgPSBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW0uY2VudHVyeV07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZGlzcGxheSBhIGhlYWRlciBmb3IgZXZlcnkgdmlldyAoZm9yIGV4YW1wbGUgdGhlIG1vbnRoIG5hbWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93Vmlld0hlYWRlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGVuYWJsZSBhbmltYXRpb24gd2hlbiBuYXZpZ2F0aW5nIHRvIHByZXZpb3VzL25leHQgdmlldy5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUaGlzIGZlYXR1cmUgdXNlcyB0aGUgW1dlYiBBbmltYXRpb25zIEFQSV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9BbmltYXRpb25zX0FQSSkuIEluIG9yZGVyIHRvIHJ1biB0aGUgYW5pbWF0aW9uIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsIHlvdSBuZWVkIHRoZSBgd2ViLWFuaW1hdGlvbnMtanNgIHBvbHlmaWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRlTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGRpc3BsYXkgYSB3ZWVrIG51bWJlciBjb2x1bW4gaW4gdGhlIGBtb250aGAgdmlld1xuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHdlZWtudW1jb2x1bW5fbXVsdGl2aWV3Y2FsZW5kYXIgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2Vla051bWJlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBgdmlld3NgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgICAgICogZGVmaW5lcyB0aGUgbnVtYmVyIG9mIHJlbmRlcmVkIG1vbnRocy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld3MgPSAyO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYWN0aXZlIHZpZXcgaXMgY2hhbmdlZFxuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBuYXZpZ2F0aW5nIGluIHRoZSBjdXJyZW50bHkgYWN0aXZlIHZpZXdcbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIGV2ZW50c19tdWx0aXZpZXdjYWxlbmRhciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYXZpZ2F0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYSB2aWV3IGNlbGwgaXMgZW50ZXJlZFxuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZWxsRW50ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIGEgdmlldyBjZWxsIGlzIGxlYXZlZFxuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZWxsTGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19tdWx0aXZpZXdjYWxlbmRhciAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibHVyRXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2VsbFVJRCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1ByZXZEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNOZXh0RGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnByZXZWaWV3ID0gQWN0aW9uLlByZXZWaWV3O1xuICAgICAgICB0aGlzLm5leHRWaWV3ID0gQWN0aW9uLk5leHRWaWV3O1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluID0gbmV3IERhdGUoTUlOX0RBVEUpO1xuICAgICAgICB0aGlzLl9tYXggPSBuZXcgRGF0ZShNQVhfREFURSk7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWREYXRlID0gZ2V0VG9kYXkoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLm9uQ29udHJvbFRvdWNoZWQgPSBub29wO1xuICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlID0gbm9vcDtcbiAgICAgICAgdGhpcy5taW5WYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5tYXhWYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzUmFuZ2VWYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLnNldENsYXNzZXMoZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBgZm9jdXNlZERhdGVgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgKiBkZWZpbmVzIHRoZSBmb2N1c2VkIGRhdGUgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXNfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLWZvY3VzZWQtZGF0ZXMpKS5cbiAgICAgKlxuICAgICAqID4gSWYgdGhlIENhbGVuZGFyIGlzIG91dCBvZiB0aGUgbWluIG9yIG1heCByYW5nZSwgaXQgbm9ybWFsaXplcyB0aGUgZGVmaW5lZCBgZm9jdXNlZERhdGVgLlxuICAgICAqL1xuICAgIHNldCBmb2N1c2VkRGF0ZShmb2N1c2VkRGF0ZSkge1xuICAgICAgICB0aGlzLl9mb2N1c2VkRGF0ZSA9IGZvY3VzZWREYXRlIHx8IGdldFRvZGF5KCk7XG4gICAgfVxuICAgIGdldCBmb2N1c2VkRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWREYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBtaW5gIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgKiBkZWZpbmVzIHRoZSBtaW5pbXVtIGFsbG93ZWQgZGF0ZSB2YWx1ZS5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYG1pbmAgdmFsdWUgaXMgYDE5MDAtMS0xYC5cbiAgICAgKi9cbiAgICBzZXQgbWluKG1pbikge1xuICAgICAgICB0aGlzLl9taW4gPSBtaW4gfHwgbmV3IERhdGUoTUlOX0RBVEUpO1xuICAgIH1cbiAgICBnZXQgbWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBtYXhgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgKiBkZWZpbmVzIHRoZSBtYXhpbXVtIGFsbG93ZWQgZGF0ZSB2YWx1ZS5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYG1heGAgdmFsdWUgaXMgYDIwOTktMTItMzFgLlxuICAgICAqL1xuICAgIHNldCBtYXgobWF4KSB7XG4gICAgICAgIHRoaXMuX21heCA9IG1heCB8fCBuZXcgRGF0ZShNQVhfREFURSk7XG4gICAgfVxuICAgIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBvZiB0aGUgQ2FsZW5kYXIgYW5kIGRlZmluZXMgdGhlIHNlbGVjdGVkIHZhbHVlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiA+IFRoZSBgdmFsdWVgIGhhcyB0byBiZSBhIHZhbGlkXG4gICAgICogW0phdmFTY3JpcHQgYERhdGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlKVxuICAgICAqIGluc3RhbmNlIHdoZW4gaW4gYHNpbmdsZWAgc2VsZWN0aW9uIG1vZGUgb3IgYW4gYXJyYXkgb2YgdmFsaWQgSmF2YVNjcmlwdCBEYXRlIGluc3RhbmNlcyB3aGVuIGluIGBtdWx0aXBsZWAgc2VsZWN0aW9uIG1vZGUuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZShjYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZShjYW5kaWRhdGUpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlKSA/XG4gICAgICAgICAgICBjYW5kaWRhdGUuZmlsdGVyKGRhdGUgPT4gaXNQcmVzZW50KGRhdGUpKS5tYXAoZWxlbWVudCA9PiBjbG9uZURhdGUoZWxlbWVudCkpIDpcbiAgICAgICAgICAgIGNsb25lRGF0ZShjYW5kaWRhdGUpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBbXS5jb25jYXQoY2FuZGlkYXRlKS5maWx0ZXIoZGF0ZSA9PiBpc1ByZXNlbnQoZGF0ZSkpLm1hcChkYXRlID0+IGNsb25lRGF0ZShkYXRlKSk7XG4gICAgICAgIGlmICghYXJlRGF0ZXNFcXVhbChzZWxlY3Rpb24sIHRoaXMuc2VsZWN0ZWREYXRlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTZWxlY3RlZCA9IGxhc3Qoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VQaXZvdCA9IGNsb25lRGF0ZShsYXN0U2VsZWN0ZWQpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IGNsb25lRGF0ZShsYXN0U2VsZWN0ZWQpIHx8IHRoaXMuZm9jdXNlZERhdGU7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXMgPSBzZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB0YWJJbmRleCh0YWJJbmRleCkge1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gdGFiSW5kZXg7XG4gICAgfVxuICAgIGdldCB0YWJJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiaW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRhdGVzIG9mIHRoZSBNdWx0aVZpZXdDYWxlbmRhciB0aGF0IHdpbGwgYmUgZGlzYWJsZWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX2RhdGVzX211bHRpdmlld2NhbGVuZGFyICV9KSkuXG4gICAgICovXG4gICAgc2V0IGRpc2FibGVkRGF0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzU2VydmljZS5pbml0aWFsaXplKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBgc2VsZWN0aW9uUmFuZ2VgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgKiBkZWZpbmVzIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXNfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLXNlbGVjdGlvbi1yYW5nZSkpLlxuICAgICAqL1xuICAgIHNldCBzZWxlY3Rpb25SYW5nZShyYW5nZSQkMSkge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb25SYW5nZSA9IHJhbmdlJCQxO1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZERhdGVzUmFuZ2VWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uUmFuZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIERlZmluZXMgdGhlIHRlbXBsYXRlIGZvciBlYWNoIGNlbGwuXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5lc3RlZCB0ZW1wbGF0ZXMgaW4gdGhlIEtlbmRvTXVsdGlWaWV3Q2FsZW5kYXIgdGFnLlxuICAgICAqL1xuICAgIHNldCBjZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5fY2VsbFRlbXBsYXRlUmVmID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBjZWxsVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jZWxsVGVtcGxhdGVSZWYgfHwgdGhpcy5jZWxsVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIERlZmluZXMgdGhlIHRlbXBsYXRlIGZvciBlYWNoIG1vbnRoIGNlbGwuXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5lc3RlZCB0ZW1wbGF0ZXMgaW4gdGhlIEtlbmRvTXVsdGlWaWV3Q2FsZW5kYXIgdGFnLlxuICAgICAqL1xuICAgIHNldCBtb250aENlbGxUZW1wbGF0ZVJlZih0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLl9tb250aENlbGxUZW1wbGF0ZVJlZiA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICBnZXQgbW9udGhDZWxsVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aENlbGxUZW1wbGF0ZVJlZiB8fCB0aGlzLm1vbnRoQ2VsbFRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBEZWZpbmVzIHRoZSB0ZW1wbGF0ZSBmb3IgZWFjaCB5ZWFyIGNlbGwuXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5lc3RlZCB0ZW1wbGF0ZXMgaW4gdGhlIEtlbmRvTXVsdGlWaWV3Q2FsZW5kYXIgdGFnLlxuICAgICAqL1xuICAgIHNldCB5ZWFyQ2VsbFRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuX3llYXJDZWxsVGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0IHllYXJDZWxsVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95ZWFyQ2VsbFRlbXBsYXRlUmVmIHx8IHRoaXMueWVhckNlbGxUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogRGVmaW5lcyB0aGUgdGVtcGxhdGUgZm9yIGVhY2ggZGVjYWRlIGNlbGwuXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5lc3RlZCB0ZW1wbGF0ZXMgaW4gdGhlIEtlbmRvTXVsdGlWaWV3Q2FsZW5kYXIgdGFnLlxuICAgICAqL1xuICAgIHNldCBkZWNhZGVDZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5fZGVjYWRlQ2VsbFRlbXBsYXRlUmVmID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBkZWNhZGVDZWxsVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNhZGVDZWxsVGVtcGxhdGVSZWYgfHwgdGhpcy5kZWNhZGVDZWxsVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIERlZmluZXMgdGhlIHRlbXBsYXRlIGZvciBlYWNoIGNlbnR1cnkgY2VsbC5cbiAgICAgKiBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgbmVzdGVkIHRlbXBsYXRlcyBpbiB0aGUgS2VuZG9NdWx0aVZpZXdDYWxlbmRhciB0YWcuXG4gICAgICovXG4gICAgc2V0IGNlbnR1cnlDZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5fY2VudHVyeUNlbGxUZW1wbGF0ZVJlZiA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICBnZXQgY2VudHVyeUNlbGxUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnR1cnlDZWxsVGVtcGxhdGVSZWYgfHwgdGhpcy5jZW50dXJ5Q2VsbFRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBEZWZpbmVzIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIHdlZWsgY2VsbC5cbiAgICAgKiBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgbmVzdGVkIHRlbXBsYXRlcyBpbiB0aGUgS2VuZG9NdWx0aVZpZXdDYWxlbmRhciB0YWcuXG4gICAgICovXG4gICAgc2V0IHdlZWtOdW1iZXJUZW1wbGF0ZVJlZih0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLl93ZWVrTnVtYmVyVGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0IHdlZWtOdW1iZXJUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtOdW1iZXJUZW1wbGF0ZVJlZiB8fCB0aGlzLndlZWtOdW1iZXJUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogRGVmaW5lcyB0aGUgdGVtcGxhdGUgZm9yIHRoZSBoZWFkZXIgdGl0bGUuXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5lc3RlZCB0ZW1wbGF0ZXMgaW4gdGhlIEtlbmRvTXVsdGlWaWV3Q2FsZW5kYXIgdGFnLlxuICAgICAqL1xuICAgIHNldCBoZWFkZXJUaXRsZVRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlclRpdGxlVGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0IGhlYWRlclRpdGxlVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJUaXRsZVRlbXBsYXRlUmVmIHx8IHRoaXMuaGVhZGVyVGl0bGVUZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZVZpZXdFbnVtKCkge1xuICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gQ2FsZW5kYXJWaWV3RW51bVt0aGlzLmFjdGl2ZVZpZXddO1xuICAgICAgICByZXR1cm4gYWN0aXZlVmlldyA8IHRoaXMuYm90dG9tVmlld0VudW0gPyB0aGlzLmJvdHRvbVZpZXdFbnVtIDogYWN0aXZlVmlldztcbiAgICB9XG4gICAgZ2V0IGJvdHRvbVZpZXdFbnVtKCkge1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJWaWV3RW51bVt0aGlzLmJvdHRvbVZpZXddO1xuICAgIH1cbiAgICBnZXQgdG9wVmlld0VudW0oKSB7XG4gICAgICAgIHJldHVybiBDYWxlbmRhclZpZXdFbnVtW3RoaXMudG9wVmlld107XG4gICAgfVxuICAgIGdldCB3aWRnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhclRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/IHVuZGVmaW5lZCA6IHRoaXMudGFiSW5kZXg7XG4gICAgfVxuICAgIGdldCBhcmlhRGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICBnZXQgYXJpYUFjdGl2ZWRlc2NlbmRhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxVSUQgKyB0aGlzLmZvY3VzZWREYXRlLmdldFRpbWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUZvY3Vzb3V0KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLmJsdXJFdmVudC5lbWl0KGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0hvdmVyZWQgPSBmYWxzZTsgLy9lbnN1cmUgdGhhdCBob3ZlcmVkIGlzIGFsc28gbm90IGFjdGl2ZVxuICAgICAgICB0aGlzLmlzSGVhZGVyQWN0aXZlID0gdGhpcy5oZWFkZXJFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY29udGFpbnMocmVsYXRlZFRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVGb2N1cygpIHtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNIZWFkZXJBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRW50ZXIoKSB7XG4gICAgICAgIHRoaXMuaXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTGVhdmUoKSB7XG4gICAgICAgIHRoaXMuaXNIb3ZlcmVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZWRvd24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNIZWFkZXJBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5FbnRlcikge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBpY2tlclNlcnZpY2UpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gRG9uJ3Qgc3VibWl0IGZvcm0gZnJvbSBEYXRlcGlja2VyIHBvcHVwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1TZWxlY3Rpb24odGhpcy5mb2N1c2VkRGF0ZSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGRhdGVJblJhbmdlKHRoaXMubmF2aWdhdG9yLm1vdmUodGhpcy5mb2N1c2VkRGF0ZSwgdGhpcy5uYXZpZ2F0b3IuYWN0aW9uKGV2ZW50KSwgdGhpcy5hY3RpdmVWaWV3RW51bSksIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIGlmIChpc0VxdWFsKHRoaXMuZm9jdXNlZERhdGUsIGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gY2FuZGlkYXRlO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBpc1NhbWVWaWV3ID0gdGhpcy5idXMuc2VydmljZSh0aGlzLmFjdGl2ZVZpZXdFbnVtKS5pc0luQXJyYXkodGhpcy5mb2N1c2VkRGF0ZSwgdGhpcy52aWV3TGlzdC5kYXRlcyk7XG4gICAgICAgIGlmICghaXNTYW1lVmlldykge1xuICAgICAgICAgICAgdGhpcy5lbWl0TmF2aWdhdGUodGhpcy5mb2N1c2VkRGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5idXMudmlld0NoYW5nZWQuc3Vic2NyaWJlKCh7IHZpZXcgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVWaWV3ID0gQ2FsZW5kYXJWaWV3RW51bVt2aWV3XTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVmlld0NoYW5nZS5lbWl0KHRoaXMuYWN0aXZlVmlldyk7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJ1dHRvblN0YXRlKCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnZlcmlmeUNoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5idXMuY29uZmlndXJlKHRoaXMuYm90dG9tVmlld0VudW0sIHRoaXMudG9wVmlld0VudW0pO1xuICAgICAgICBpZiAoaGFzRXhpc3RpbmdWYWx1ZShjaGFuZ2VzLCAnZm9jdXNlZERhdGUnKSkge1xuICAgICAgICAgICAgY29uc3QgZm9jdXNlZERhdGUgPSBjaGFuZ2VzLmZvY3VzZWREYXRlLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZERhdGUgPSBkYXRlSW5SYW5nZShmb2N1c2VkRGF0ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5taW4gfHwgY2hhbmdlcy5tYXggfHwgY2hhbmdlcy5yYW5nZVZhbGlkYXRpb24gfHwgY2hhbmdlcy5kaXNhYmxlZERhdGVzIHx8IGNoYW5nZXMuZGlzYWJsZWREYXRlc1JhbmdlVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5taW5WYWxpZGF0ZUZuID0gdGhpcy5yYW5nZVZhbGlkYXRpb24gPyBtaW5WYWxpZGF0b3IodGhpcy5taW4pIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMubWF4VmFsaWRhdGVGbiA9IHRoaXMucmFuZ2VWYWxpZGF0aW9uID8gbWF4VmFsaWRhdG9yKHRoaXMubWF4KSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNSYW5nZVZhbGlkYXRlRm4gPSB0aGlzLmRpc2FibGVkRGF0ZXNSYW5nZVZhbGlkYXRpb24gPyBkaXNhYmxlZERhdGVzUmFuZ2VWYWxpZGF0b3IodGhpcy5kaXNhYmxlZERhdGVzU2VydmljZS5pc0RhdGVEaXNhYmxlZCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLm1pbiB8fCBjaGFuZ2VzLm1heCB8fCBjaGFuZ2VzLmZvY3VzZWREYXRlIHx8IGNoYW5nZXMuYWN0aXZlVmlldykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCdXR0b25TdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUJ1dHRvblN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGhvc3QgZWxlbWVudCBvZiB0aGUgQ2FsZW5kYXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8YnV0dG9uIChjbGljayk9XCJtdWx0aXZpZXdjYWxlbmRhci5mb2N1cygpXCI+Rm9jdXMgY2FsZW5kYXI8L2J1dHRvbj5cbiAgICAgKiAgPGtlbmRvLW11bHRpdmlld2NhbGVuZGFyICNtdWx0aXZpZXdjYWxlbmRhcj48L2tlbmRvLW11bHRpdmlld2NhbGVuZGFyPlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIENhbGVuZGFyIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUhlYWRlckZvY3VzKCkge1xuICAgICAgICB0aGlzLmlzSGVhZGVyQWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZURhdGVDaGFuZ2UoYXJncykge1xuICAgICAgICBjb25zdCBjYW5OYXZpZ2F0ZURvd24gPSB0aGlzLmJ1cy5jYW5Nb3ZlRG93bih0aGlzLmFjdGl2ZVZpZXdFbnVtKTtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlRGF0ZXMgPSBhcmdzLnNlbGVjdGVkRGF0ZXMuZmlsdGVyKGRhdGUgPT4gIXRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UuaXNEYXRlRGlzYWJsZWQoZGF0ZSkpO1xuICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gYXJncy5mb2N1c2VkRGF0ZSB8fCB0aGlzLmZvY3VzZWREYXRlO1xuICAgICAgICBjb25zdCBzYW1lRGF0ZXMgPSAhY2FuTmF2aWdhdGVEb3duICYmIGFyZURhdGVzRXF1YWwoYXZhaWxhYmxlRGF0ZXMsIHRoaXMuc2VsZWN0ZWREYXRlcyk7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHNhbWVEYXRlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5OYXZpZ2F0ZURvd24pIHtcbiAgICAgICAgICAgIHRoaXMuYnVzLm1vdmVEb3duKHRoaXMuYWN0aXZlVmlld0VudW0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmlzRGF0ZURpc2FibGVkKHRoaXMuZm9jdXNlZERhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVzID0gYXZhaWxhYmxlRGF0ZXMubWFwKGRhdGUgPT4gY2xvbmVEYXRlKGRhdGUpKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMucGFyc2VTZWxlY3Rpb25Ub1ZhbHVlKGF2YWlsYWJsZURhdGVzKTtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UodGhpcy5wYXJzZVNlbGVjdGlvblRvVmFsdWUoYXZhaWxhYmxlRGF0ZXMpKTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMucGFyc2VTZWxlY3Rpb25Ub1ZhbHVlKGF2YWlsYWJsZURhdGVzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVUb2RheUJ1dHRvbkNsaWNrKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdG9kYXlEYXRlID0gYXJncy5mb2N1c2VkRGF0ZTtcbiAgICAgICAgY29uc3QgaXNTYW1lVmlldyA9IHRoaXMuYnVzLnNlcnZpY2UodGhpcy5hY3RpdmVWaWV3RW51bSkuaXNJbkFycmF5KHRvZGF5RGF0ZSwgdGhpcy52aWV3TGlzdC5kYXRlcyk7XG4gICAgICAgIGNvbnN0IGlzQm90dG9tVmlldyA9ICF0aGlzLmJ1cy5jYW5Nb3ZlRG93bih0aGlzLmFjdGl2ZVZpZXdFbnVtKTtcbiAgICAgICAgaWYgKCFpc1NhbWVWaWV3ICYmIGlzQm90dG9tVmlldykge1xuICAgICAgICAgICAgdGhpcy5lbWl0TmF2aWdhdGUodG9kYXlEYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZURhdGVDaGFuZ2UoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXRBY3RpdmVEYXRlKGRhdGUpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gY2xvbmVEYXRlKGRhdGUpO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKGNhbmRpZGF0ZSkge1xuICAgICAgICB0aGlzLnZlcmlmeVZhbHVlKGNhbmRpZGF0ZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBjYW5kaWRhdGU7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ29udHJvbENoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdmFsaWRhdGUoY29udHJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5WYWxpZGF0ZUZuKGNvbnRyb2wpIHx8IHRoaXMubWF4VmFsaWRhdGVGbihjb250cm9sKSB8fCB0aGlzLmRpc2FibGVkRGF0ZXNSYW5nZVZhbGlkYXRlRm4odGhpcy5zZWxlY3Rpb25SYW5nZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGFjdGl2ZUNlbGxUZW1wbGF0ZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFjdGl2ZVZpZXdFbnVtKSB7XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0ubW9udGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9udGhDZWxsVGVtcGxhdGVSZWYgfHwgdGhpcy5jZWxsVGVtcGxhdGVSZWY7XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0ueWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55ZWFyQ2VsbFRlbXBsYXRlUmVmO1xuICAgICAgICAgICAgY2FzZSBDYWxlbmRhclZpZXdFbnVtLmRlY2FkZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNhZGVDZWxsVGVtcGxhdGVSZWY7XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0uY2VudHVyeTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jZW50dXJ5Q2VsbFRlbXBsYXRlUmVmO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmF2aWdhdGVWaWV3KGFjdGlvbikge1xuICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gdGhpcy52aWV3TGlzdC5uYXZpZ2F0ZShhY3Rpb24pO1xuICAgICAgICB0aGlzLnVwZGF0ZUJ1dHRvblN0YXRlKCk7XG4gICAgICAgIHRoaXMuZW1pdE5hdmlnYXRlKHRoaXMuZm9jdXNlZERhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZW1pdE5hdmlnYXRlKGZvY3VzZWREYXRlKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSBDYWxlbmRhclZpZXdFbnVtW3RoaXMuYWN0aXZlVmlld0VudW1dO1xuICAgICAgICB0aGlzLm5hdmlnYXRlLmVtaXQoeyBhY3RpdmVWaWV3LCBmb2N1c2VkRGF0ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGVtaXRDZWxsRXZlbnQoZW1pdHRlciwgYXJncykge1xuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKGVtaXR0ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQ2VsbENsaWNrKHsgZGF0ZSwgbW9kaWZpZXJzIH0pIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtU2VsZWN0aW9uKGRhdGUsIG1vZGlmaWVycyk7XG4gICAgICAgIGNvbnN0IGlzU2FtZVZpZXcgPSB0aGlzLmJ1cy5zZXJ2aWNlKHRoaXMuYWN0aXZlVmlld0VudW0pLmlzSW5BcnJheSh0aGlzLmZvY3VzZWREYXRlLCB0aGlzLnZpZXdMaXN0LmRhdGVzKTtcbiAgICAgICAgaWYgKCFpc1NhbWVWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXROYXZpZ2F0ZSh0aGlzLmZvY3VzZWREYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlV2Vla051bWJlckNsaWNrKGRhdGVzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0ZUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlczogZGF0ZXMsXG4gICAgICAgICAgICAgICAgZm9jdXNlZERhdGU6IGxhc3QoZGF0ZXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENsYXNzZXMoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLXdpZGdldCcpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLWNhbGVuZGFyJyk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgJ2stY2FsZW5kYXItcmFuZ2UnKTtcbiAgICB9XG4gICAgdmVyaWZ5Q2hhbmdlcygpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1pbiA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtYXggdmFsdWUgc2hvdWxkIGJlIGJpZ2dlciB0aGFuIHRoZSBtaW4uIFNlZSAke01JTl9ET0NfTElOS30gYW5kICR7TUFYX0RPQ19MSU5LfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3R0b21WaWV3RW51bSA+IHRoaXMudG9wVmlld0VudW0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHRvcFZpZXcgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBib3R0b21WaWV3LiBTZWUgJHtCT1RUT01fVklFV19ET0NfTElOS30gYW5kICR7VE9QX1ZJRVdfRE9DX0xJTkt9LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeVZhbHVlKGNhbmRpZGF0ZSkge1xuICAgICAgICBpZiAoIWlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uID09PSAnc2luZ2xlJyAmJiBjYW5kaWRhdGUgJiYgIShjYW5kaWRhdGUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ3ZhbHVlJyBzaG91bGQgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IERhdGUgaW5zdGFuY2UuIENoZWNrICR7VkFMVUVfRE9DX0xJTkt9IGZvciBwb3NzaWJsZSByZXNvbHV0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uID09PSAnbXVsdGlwbGUnICYmIGNhbmRpZGF0ZSAmJiBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9ubHlEYXRlcyA9IGNhbmRpZGF0ZS5ldmVyeSh2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpO1xuICAgICAgICAgICAgaWYgKCFvbmx5RGF0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAndmFsdWUnIHNob3VsZCBiZSBhbiBhcnJheSBvZiB2YWxpZCBKYXZhU2NyaXB0IERhdGUgaW5zdGFuY2VzLiBDaGVjayAke1ZBTFVFX0RPQ19MSU5LfSBmb3IgcG9zc2libGUgcmVzb2x1dGlvbi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVCdXR0b25TdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzUHJldkRpc2FibGVkID0gIXRoaXMudmlld0xpc3QuY2FuTmF2aWdhdGUodGhpcy5wcmV2Vmlldyk7XG4gICAgICAgICAgICB0aGlzLmlzTmV4dERpc2FibGVkID0gIXRoaXMudmlld0xpc3QuY2FuTmF2aWdhdGUodGhpcy5uZXh0Vmlldyk7XG4gICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhcnNlU2VsZWN0aW9uVG9WYWx1ZShzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uIHx8IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24gPT09ICdzaW5nbGUnID8gY2xvbmVEYXRlKGxhc3Qoc2VsZWN0aW9uKSkgOiBzZWxlY3Rpb24ubWFwKGRhdGUgPT4gY2xvbmVEYXRlKGRhdGUpKTtcbiAgICB9XG4gICAgcGVyZm9ybVNlbGVjdGlvbihkYXRlLCBzZWxlY3Rpb25Nb2RpZmllcnMpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnBlcmZvcm1TZWxlY3Rpb24oe1xuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgIG1vZGlmaWVyczogc2VsZWN0aW9uTW9kaWZpZXJzLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogdGhpcy5zZWxlY3Rpb24sXG4gICAgICAgICAgICBhY3RpdmVWaWV3RW51bTogdGhpcy5hY3RpdmVWaWV3RW51bSxcbiAgICAgICAgICAgIHJhbmdlUGl2b3Q6IHRoaXMucmFuZ2VQaXZvdCxcbiAgICAgICAgICAgIHNlbGVjdGVkRGF0ZXM6IHRoaXMuc2VsZWN0ZWREYXRlc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yYW5nZVBpdm90ID0gc2VsZWN0aW9uLnJhbmdlUGl2b3Q7XG4gICAgICAgIHRoaXMuaGFuZGxlRGF0ZUNoYW5nZSh7XG4gICAgICAgICAgICBzZWxlY3RlZERhdGVzOiBzZWxlY3Rpb24uc2VsZWN0ZWREYXRlcyxcbiAgICAgICAgICAgIGZvY3VzZWREYXRlOiBkYXRlXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGF0ZV0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNlZERhdGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGF0ZV0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZVZhbGlkYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWREYXRlc1JhbmdlVmFsaWRhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0FjdGl2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWREYXRlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm90dG9tVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInRvcFZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1ZpZXdIZWFkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0ZU5hdmlnYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVJhbmdlRW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3Rpb25SYW5nZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aWV3c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3Q2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm5hdmlnYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxFbnRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsTGVhdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnYmx1cicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYmx1ckV2ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdjZWxsVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NlbGxUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1vbnRoQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnbW9udGhDZWxsVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTW9udGhDZWxsVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTW9udGhDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1vbnRoQ2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5ZWFyQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgneWVhckNlbGxUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1llYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInllYXJDZWxsVGVtcGxhdGVSZWZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoRGVjYWRlQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWNhZGVDZWxsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdkZWNhZGVDZWxsVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGVjYWRlQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVjYWRlQ2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZW50dXJ5Q2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnY2VudHVyeUNlbGxUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNlbnR1cnlDZWxsVGVtcGxhdGVSZWZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ3dlZWtOdW1iZXJUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1dlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChIZWFkZXJUaXRsZVRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVhZGVyVGl0bGVUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2hlYWRlclRpdGxlVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtIZWFkZXJUaXRsZVRlbXBsYXRlRGlyZWN0aXZlXSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWFkZXJUaXRsZVRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKEhlYWRlckNvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlLCByZWFkOiBFbGVtZW50UmVmIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhlYWRlckVsZW1lbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZChIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50KVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInZpZXdMaXN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5pZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWRnZXRJZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNhbGVuZGFyVGFiSW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLWRpc2FibGVkJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFyaWFEaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtYWN0aXZlZGVzY2VuZGFudCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhQWN0aXZlZGVzY2VuZGFudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcignZm9jdXNvdXQnLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYW5kbGVGb2N1c291dFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcihcImZvY3VzXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhhbmRsZUZvY3VzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKFwibW91c2VlbnRlclwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYW5kbGVNb3VzZUVudGVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKFwibW91c2VsZWF2ZVwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYW5kbGVNb3VzZUxlYXZlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKFwibW91c2Vkb3duXCIsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhhbmRsZU1vdXNlZG93blwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RMaXN0ZW5lcihcImNsaWNrXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhhbmRsZUNsaWNrXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKFwia2V5ZG93blwiLCBbXCIkZXZlbnRcIl0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImtleWRvd25cIiwgbnVsbCk7XG5NdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvLW11bHRpdmlld2NhbGVuZGFyJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBCdXNWaWV3U2VydmljZSxcbiAgICAgICAgICAgIFJBTkdFX0NBTEVOREFSX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgUkFOR0VfQ0FMRU5EQVJfUkFOR0VfVkFMSURBVE9SUyxcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBEaXNhYmxlZERhdGVzU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLm11bHRpdmlld2NhbGVuZGFyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgU2VsZWN0aW9uU2VydmljZVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLW11bHRpdmlld2NhbGVuZGFyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyIGtlbmRvTXVsdGlWaWV3Q2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICBpMThuLXRvZGF5PVwia2VuZG8ubXVsdGl2aWV3Y2FsZW5kYXIudG9kYXl8VGhlIGxhYmVsIGZvciB0aGUgdG9kYXkgYnV0dG9uIGluIHRoZSBjYWxlbmRhciBoZWFkZXJcIlxuICAgICAgICB0b2RheT1cIlRvZGF5XCJcblxuICAgICAgICBpMThuLXByZXZCdXR0b25UaXRsZT1cImtlbmRvLm11bHRpdmlld2NhbGVuZGFyLnByZXZCdXR0b25UaXRsZXxUaGUgbGFiZWwgZm9yIHRoZSBwcmV2aW91cyBidXR0b24gaW4gdGhlIE11bHRpdmlldyBjYWxlbmRhclwiXG4gICAgICAgIHByZXZCdXR0b25UaXRsZT1cIk5hdmlnYXRlIHRvIHByZXZpb3VzIHZpZXdcIlxuXG4gICAgICAgIGkxOG4tbmV4dEJ1dHRvblRpdGxlPVwia2VuZG8ubXVsdGl2aWV3Y2FsZW5kYXIubmV4dEJ1dHRvblRpdGxlfFRoZSBsYWJlbCBmb3IgdGhlIG5leHQgYnV0dG9uIGluIHRoZSBNdWx0aXZpZXcgY2FsZW5kYXJcIlxuICAgICAgICBuZXh0QnV0dG9uVGl0bGU9XCJOYXZpZ2F0ZSB0byBuZXh0IHZpZXdcIlxuICAgID5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8a2VuZG8tY2FsZW5kYXItaGVhZGVyXG4gICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdFbnVtXCJcbiAgICAgICAgW2N1cnJlbnREYXRlXT1cImFjdGl2ZURhdGVcIlxuICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgW3JhbmdlTGVuZ3RoXT1cInZpZXdzXCJcbiAgICAgICAgW3RlbXBsYXRlUmVmXT1cImhlYWRlclRpdGxlVGVtcGxhdGVSZWY/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgW2lzUHJldkRpc2FibGVkXT1cImlzUHJldkRpc2FibGVkXCJcbiAgICAgICAgW2lzTmV4dERpc2FibGVkXT1cImlzTmV4dERpc2FibGVkXCJcbiAgICAgICAgW3Nob3dOYXZpZ2F0aW9uQnV0dG9uc109XCJ0cnVlXCJcbiAgICAgICAgKHRvZGF5QnV0dG9uQ2xpY2spPVwiaGFuZGxlVG9kYXlCdXR0b25DbGljayh7IHNlbGVjdGVkRGF0ZXM6IFskZXZlbnRdLCBmb2N1c2VkRGF0ZTogJGV2ZW50IH0pXCJcbiAgICAgICAgKHByZXZCdXR0b25DbGljayk9XCJuYXZpZ2F0ZVZpZXcocHJldlZpZXcpXCJcbiAgICAgICAgKG5leHRCdXR0b25DbGljayk9XCJuYXZpZ2F0ZVZpZXcobmV4dFZpZXcpXCJcbiAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgZm9jdXNpbjogaGFuZGxlSGVhZGVyRm9jdXNcbiAgICAgICAgfVwiXG4gICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICA+XG4gICAgPC9rZW5kby1jYWxlbmRhci1oZWFkZXI+XG4gICAgPGtlbmRvLWNhbGVuZGFyLWhvcml6b250YWxcbiAgICAgICAgW2FjdGl2ZVZpZXddPVwiYWN0aXZlVmlld0VudW1cIlxuICAgICAgICBbaXNBY3RpdmVdPVwiaXNBY3RpdmUgfHwgKGlzSG92ZXJlZCAmJiAhaXNIZWFkZXJBY3RpdmUpXCJcbiAgICAgICAgW2NlbGxUZW1wbGF0ZVJlZl09XCJhY3RpdmVDZWxsVGVtcGxhdGUoKT8udGVtcGxhdGVSZWZcIlxuICAgICAgICBbd2Vla051bWJlclRlbXBsYXRlUmVmXT1cIndlZWtOdW1iZXJUZW1wbGF0ZVJlZj8udGVtcGxhdGVSZWZcIlxuICAgICAgICBbY2VsbFVJRF09XCJjZWxsVUlEXCJcbiAgICAgICAgW3ZpZXdzXT1cInZpZXdzXCJcbiAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgIFtmb2N1c2VkRGF0ZV09XCJmb2N1c2VkRGF0ZVwiXG4gICAgICAgIFthbmltYXRlTmF2aWdhdGlvbl09XCJhbmltYXRlTmF2aWdhdGlvblwiXG4gICAgICAgIFtzaG93Vmlld0hlYWRlcl09XCJzaG93Vmlld0hlYWRlclwiXG4gICAgICAgIFt3ZWVrTnVtYmVyXT1cIndlZWtOdW1iZXJcIlxuICAgICAgICBbYWN0aXZlUmFuZ2VFbmRdPVwiYWN0aXZlUmFuZ2VFbmRcIlxuICAgICAgICBbc2VsZWN0aW9uUmFuZ2VdPVwic2VsZWN0aW9uUmFuZ2VcIlxuICAgICAgICBbc2VsZWN0ZWREYXRlc109XCJzZWxlY3RlZERhdGVzXCJcbiAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZURhdGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgIChjZWxsQ2xpY2spPVwiaGFuZGxlQ2VsbENsaWNrKCRldmVudClcIlxuICAgICAgICAod2Vla051bWJlckNlbGxDbGljayk9XCJoYW5kbGVXZWVrTnVtYmVyQ2xpY2soJGV2ZW50KVwiXG4gICAgICAgIChjZWxsRW50ZXIpPVwiZW1pdENlbGxFdmVudChjZWxsRW50ZXIsICRldmVudClcIlxuICAgICAgICAoY2VsbExlYXZlKT1cImVtaXRDZWxsRXZlbnQoY2VsbExlYXZlLCAkZXZlbnQpXCJcbiAgICAgICAgKGFjdGl2ZURhdGVDaGFuZ2UpPVwic2V0QWN0aXZlRGF0ZSgkZXZlbnQpXCJcbiAgICA+XG4gICAgPC9rZW5kby1jYWxlbmRhci1ob3Jpem9udGFsPlxuICBgXG4gICAgfSksXG4gICAgX19wYXJhbSg4LCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0J1c1ZpZXdTZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgTmdab25lLFxuICAgICAgICBEaXNhYmxlZERhdGVzU2VydmljZSxcbiAgICAgICAgU2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgUGlja2VyU2VydmljZV0pXG5dLCBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudCk7XG5cbmNvbnN0IGRpdiA9IGRvbUNvbnRhaW5lckZhY3RvcnkoJ2RpdicpO1xuY29uc3QgdWwgPSBkb21Db250YWluZXJGYWN0b3J5KCd1bCcpO1xuY29uc3QgbGkgPSBkb21Db250YWluZXJGYWN0b3J5KCdsaScpO1xuY29uc3QgdGQgPSBkb21Db250YWluZXJGYWN0b3J5KCd0ZCcpO1xuY29uc3QgdGggPSBkb21Db250YWluZXJGYWN0b3J5KCd0aCcpO1xuY29uc3QgdHIgPSBkb21Db250YWluZXJGYWN0b3J5KCd0cicpO1xuY29uc3QgdGJvZHkgPSBkb21Db250YWluZXJGYWN0b3J5KCd0Ym9keScpO1xuY29uc3QgdGhlYWQgPSBkb21Db250YWluZXJGYWN0b3J5KCd0aGVhZCcpO1xuY29uc3QgdGFibGUgPSBkb21Db250YWluZXJGYWN0b3J5KCd0YWJsZScpO1xuY29uc3QgbW9udGhIZWFkZXIgPSAoKSA9PiAoZGl2KGBcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1idXR0b24gay1idXR0b24tbWQgay1yb3VuZGVkLW1kIGstYnV0dG9uLWZsYXQgay1idXR0b24tZmxhdC1iYXNlIGstY2FsZW5kYXItdGl0bGVcIj5NYXJjaCAyMDE3PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLXNwYWNlclwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1jYWxlbmRhci1uYXYgay1oc3RhY2tcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstdG9kYXkgay1uYXYtdG9kYXlcIj5UT0RBWTwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgYCwgJ2stY2FsZW5kYXItaGVhZGVyIGstaHN0YWNrJykpO1xuY29uc3QgbW9udGhXZWVrSGVhZGVyID0gKCkgPT4gKHRhYmxlKFtcbiAgICB0aGVhZChbXG4gICAgICAgIHRyKFt0aCgnTU8nLCAnay1jYWxlbmRhci10aCcpXSwgJ2stY2FsZW5kYXItdHInKVxuICAgIF0sICdrLWNhbGVuZGFyLXRoZWFkJylcbl0sICdrLWNhbGVuZGFyLXdlZWtkYXlzIGstY2FsZW5kYXItdGFibGUnKSk7XG5jb25zdCByZXBlYXQgPSAoY291bnQsIG1hcHBlcikgPT4gbmV3IEFycmF5KGNvdW50KS5maWxsKCcxJykubWFwKG1hcHBlcik7XG5jb25zdCBjb250ZW50ID0gKHJvd3MsIGNlbGxzID0gMSkgPT4gKHRhYmxlKFtcbiAgICB0Ym9keShbdHIoW3RoKCcxJywgJ2stY2FsZW5kYXItdGgnKV0sICdrLWNhbGVuZGFyLXRyJyldLmNvbmNhdChyZXBlYXQocm93cywgKCkgPT4gdHIocmVwZWF0KGNlbGxzLCBjID0+IHRkKGA8c3BhbiBjbGFzcz1cImstbGlua1wiPiR7Y308L3NwYW4+YCwgJ2stY2FsZW5kYXItdGQnKSksICdrLWNhbGVuZGFyLXRyJykpKSwgJ2stY2FsZW5kYXItdGJvZHknKVxuXSwgJ2stY2FsZW5kYXItdGFibGUnKSk7XG5jb25zdCBzY3JvbGxhYmxlID0gKGNoaWxkcmVuKSA9PiBkaXYoY2hpbGRyZW4sICdrLWZsZXggay1jb250ZW50IGstY2FsZW5kYXItY29udGVudCBrLXNjcm9sbGFibGUnKTtcbmNvbnN0IHZpZXcgPSAoY29udGVudEVsZW1lbnQsIGNsYXNzTmFtZSwgcmVuZGVyV2Vla0hlYWRlcikgPT4gKGRpdihbXG4gICAgbW9udGhIZWFkZXIoKSxcbiAgICByZW5kZXJXZWVrSGVhZGVyID8gbW9udGhXZWVrSGVhZGVyKCkgOiBudWxsLFxuICAgIHNjcm9sbGFibGUoW2NvbnRlbnRFbGVtZW50LCBjb250ZW50RWxlbWVudF0pXG5dLCBjbGFzc05hbWUsIHsgbGVmdDogJy0xMDAwMHB4JywgcG9zaXRpb246ICdhYnNvbHV0ZScgfSkpO1xuY29uc3QgybU2ID0gKCkgPT4ge1xuICAgIGxldCBuYXZFbGVtZW50O1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuYXZFbGVtZW50KSB7XG4gICAgICAgICAgICBuYXZFbGVtZW50ID0gZGl2KFtzY3JvbGxhYmxlKFt1bChbbGkoJzxzcGFuPkZFQjwvc3Bhbj4nKV0pXSldLCAnay1jYWxlbmRhci1uYXZpZ2F0aW9uJywgeyBsZWZ0OiAnMHB4JywgcG9zaXRpb246ICdhYnNvbHV0ZScgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdkVsZW1lbnQ7XG4gICAgfTtcbn07XG5jb25zdCBuYXZpZ2F0aW9uTGlzdCA9ICjJtTYpKCk7XG5jb25zdCB2aWV3RmFjdG9yeSA9ICh7IGNlbGxzLCByb3dzIH0sIGNsYXNzTmFtZSwgcmVuZGVyV2Vla0hlYWRlcikgPT4ge1xuICAgIGxldCB2aWV3RWxlbWVudDtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmlld0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHZpZXdFbGVtZW50ID0gdmlldyhjb250ZW50KHJvd3MsIGNlbGxzKSwgY2xhc3NOYW1lLCByZW5kZXJXZWVrSGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld0VsZW1lbnQ7XG4gICAgfTtcbn07XG5jb25zdCBnZXRTY3JvbGxhYmxlID0gKGVsZW1lbnQpID0+IGVsZW1lbnQucXVlcnlTZWxlY3RvcignLmstc2Nyb2xsYWJsZScpO1xuY29uc3QgaG9yaXpvbnRhbCA9IGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gZ2V0U2Nyb2xsYWJsZShlbGVtZW50KTtcbiAgICBzY3JvbGxhYmxlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdrLXNjcm9sbGFibGUtaG9yaXpvbnRhbCcpO1xuICAgIHJldHVybiBlbGVtZW50O1xufTtcbmNvbnN0IG1vbnRoVmlldyA9IHZpZXdGYWN0b3J5KHsgY2VsbHM6IDcsIHJvd3M6IDYgfSwgJ2stdnN0YWNrIGstY2FsZW5kYXItdmlldyBrLWNhbGVuZGFyLW1vbnRodmlldycsIHRydWUpO1xuY29uc3QgeWVhclZpZXcgPSB2aWV3RmFjdG9yeSh7IGNlbGxzOiA0LCByb3dzOiAzIH0sICdrLXZzdGFjayBrLWNhbGVuZGFyLXZpZXcgay1jYWxlbmRhci15ZWFydmlldycsIGZhbHNlKTtcbmNvbnN0IGRlY2FkZVZpZXcgPSB2aWV3RmFjdG9yeSh7IGNlbGxzOiA0LCByb3dzOiAzIH0sICdrLXZzdGFjayBrLWNhbGVuZGFyLXZpZXcgay1jYWxlbmRhci1kZWNhZGV2aWV3JywgZmFsc2UpO1xuY29uc3QgaG9yek1vbnRoVmlldyA9ICgpID0+IGhvcml6b250YWwobW9udGhWaWV3KCkpO1xuY29uc3QgaG9yelllYXJWaWV3ID0gKCkgPT4gaG9yaXpvbnRhbCh5ZWFyVmlldygpKTtcbmNvbnN0IGhvcnpEZWNhZGVWaWV3ID0gKCkgPT4gaG9yaXpvbnRhbChkZWNhZGVWaWV3KCkpO1xuY29uc3QgaGVpZ2h0ID0gKGVsZW1lbnQpID0+IChwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmhlaWdodCkgfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQpO1xuY29uc3Qgd2lkdGggPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGNvbnN0IGNvbXB1dGVkID0gcGFyc2VGbG9hdChzdHlsZXMud2lkdGgpXG4gICAgICAgICsgcGFyc2VGbG9hdChzdHlsZXMucGFkZGluZ0xlZnQpXG4gICAgICAgICsgcGFyc2VGbG9hdChzdHlsZXMucGFkZGluZ1JpZ2h0KTtcbiAgICByZXR1cm4gY29tcHV0ZWQgfHwgZWxlbWVudC5vZmZzZXRXaWR0aDtcbn07XG5jb25zdCBnZXRCb2R5ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGJvZHknKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ2FsZW5kYXJET01TZXJ2aWNlID0gY2xhc3MgQ2FsZW5kYXJET01TZXJ2aWNlIHtcbiAgICBlbnN1cmVIZWlnaHRzKCkge1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhckhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVIZWlnaHRzKCk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUhlaWdodHMoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3N0Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmJhdGNoKG1vbnRoVmlldygpLCAoY29udGVudEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdFbGVtZW50ID0gZ2V0Qm9keShjb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFySGVpZ2h0ID0gaGVpZ2h0KGNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMubW9udGhWaWV3SGVpZ2h0ID0gaGVpZ2h0KHZpZXdFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVySGVpZ2h0ID0gaGVpZ2h0KHZpZXdFbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsYWJsZUNvbnRlbnRIZWlnaHQgPSBoZWlnaHQoZ2V0U2Nyb2xsYWJsZShjb250ZW50RWxlbWVudCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYXRjaChob3J6TW9udGhWaWV3KCksIChjb250ZW50RWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgdmlld0VsZW1lbnQgPSBnZXRCb2R5KGNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJXaWR0aCA9IHdpZHRoKGNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMubW9udGhWaWV3V2lkdGggPSB3aWR0aCh2aWV3RWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGFibGVDb250ZW50V2lkdGggPSB3aWR0aChnZXRTY3JvbGxhYmxlKGNvbnRlbnRFbGVtZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhdGNoKHllYXJWaWV3KCksIChjb250ZW50RWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy55ZWFyVmlld0hlaWdodCA9IGhlaWdodChnZXRCb2R5KGNvbnRlbnRFbGVtZW50KSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGFibGVZZWFyQ29udGVudEhlaWdodCA9IGhlaWdodChnZXRTY3JvbGxhYmxlKGNvbnRlbnRFbGVtZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhdGNoKGhvcnpZZWFyVmlldygpLCAoY29udGVudEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMueWVhclZpZXdXaWR0aCA9IHdpZHRoKGdldEJvZHkoY29udGVudEVsZW1lbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmF0Y2goZGVjYWRlVmlldygpLCAoY29udGVudEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVjYWRlVmlld0hlaWdodCA9IGhlaWdodChnZXRCb2R5KGNvbnRlbnRFbGVtZW50KSk7XG4gICAgICAgICAgICB0aGlzLmNlbnR1cnlWaWV3SGVpZ2h0ID0gdGhpcy5kZWNhZGVWaWV3SGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYXRjaChob3J6RGVjYWRlVmlldygpLCAoY29udGVudEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVjYWRlVmlld1dpZHRoID0gd2lkdGgoZ2V0Qm9keShjb250ZW50RWxlbWVudCkpO1xuICAgICAgICAgICAgdGhpcy5jZW50dXJ5Vmlld1dpZHRoID0gdGhpcy5kZWNhZGVWaWV3V2lkdGg7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhdGNoKG5hdmlnYXRpb25MaXN0KCksIChjb250ZW50RWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSXRlbUhlaWdodCA9IGhlaWdodChjb250ZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsaScpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpZXdIZWlnaHQodmlld1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0RpbWVuc2lvbih2aWV3VHlwZSwgJ2hlaWdodCcpO1xuICAgIH1cbiAgICB2aWV3V2lkdGgodmlld1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0RpbWVuc2lvbih2aWV3VHlwZSwgJ3dpZHRoJyk7XG4gICAgfVxuICAgIHZpZXdEaW1lbnNpb24odmlld1R5cGUsIGRpbWVuc2lvbikge1xuICAgICAgICBjb25zdCB2aWV3UHJvcCA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgPyAnVmlld0hlaWdodCcgOiAnVmlld1dpZHRoJztcbiAgICAgICAgc3dpdGNoICh2aWV3VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBDYWxlbmRhclZpZXdFbnVtLm1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2Btb250aCR7dmlld1Byb3B9YF07XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0ueWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tgeWVhciR7dmlld1Byb3B9YF07XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0uZGVjYWRlOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2BkZWNhZGUke3ZpZXdQcm9wfWBdO1xuICAgICAgICAgICAgY2FzZSBDYWxlbmRhclZpZXdFbnVtLmNlbnR1cnk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbYGNlbnR1cnkke3ZpZXdQcm9wfWBdO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiYXRjaChjb250ZW50RWxlbWVudCwgYWN0aW9uKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuaG9zdENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0Q2xvbmUgPSB0aGlzLmhvc3RDb250YWluZXIuY2xvbmVOb2RlKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaG9zdENsb25lKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFwcGVuZGVkQ29udGVudCA9IGhvc3RDbG9uZS5hcHBlbmRDaGlsZChjb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICBhY3Rpb24oYXBwZW5kZWRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChob3N0Q2xvbmUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkNhbGVuZGFyRE9NU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgQ2FsZW5kYXJET01TZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHVwZGF0ZSA9IChhcnIsIGlkeCwgdmFsdWUpID0+IChbXG4gICAgLi4uYXJyLnNsaWNlKDAsIGlkeCArIDEpLFxuICAgIC4uLihhcnIuc2xpY2UoaWR4ICsgMSkubWFwKHggPT4geCArIHZhbHVlKSlcbl0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFJvd0hlaWdodFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHRvdGFsID0gMCwgcm93SGVpZ2h0LCBkZXRhaWxSb3dIZWlnaHQpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLnJvd0hlaWdodCA9IHJvd0hlaWdodDtcbiAgICAgICAgdGhpcy5kZXRhaWxSb3dIZWlnaHQgPSBkZXRhaWxSb3dIZWlnaHQ7XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmhlaWdodHMgPSBbXTtcbiAgICAgICAgbGV0IGFnZyA9IDA7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRvdGFsOyBpZHgrKykge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnB1c2goYWdnKTtcbiAgICAgICAgICAgIGFnZyArPSByb3dIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmhlaWdodHMucHVzaChyb3dIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhlaWdodChyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHRzW3Jvd0luZGV4XTtcbiAgICB9XG4gICAgZXhwYW5kRGV0YWlsKHJvd0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodChyb3dJbmRleCkgPT09IHRoaXMucm93SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJvd0hlaWdodChyb3dJbmRleCwgdGhpcy5kZXRhaWxSb3dIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxhcHNlRGV0YWlsKHJvd0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodChyb3dJbmRleCkgPiB0aGlzLnJvd0hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSb3dIZWlnaHQocm93SW5kZXgsIHRoaXMuZGV0YWlsUm93SGVpZ2h0ICogLTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluZGV4KHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5vZmZzZXRzLnJlZHVjZSgocHJldiwgY3VycmVudCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJldiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50ID09PSBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50ID4gcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sIHVuZGVmaW5lZCk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcy50b3RhbCAtIDEgOiByZXN1bHQ7XG4gICAgfVxuICAgIG9mZnNldChyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXRzW3Jvd0luZGV4XTtcbiAgICB9XG4gICAgdG90YWxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodHMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBwcmV2ICsgY3VyciwgMCk7XG4gICAgfVxuICAgIHVwZGF0ZVJvd0hlaWdodChyb3dJbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWlnaHRzW3Jvd0luZGV4XSArPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gdXBkYXRlKHRoaXMub2Zmc2V0cywgcm93SW5kZXgsIHZhbHVlKTtcbiAgICB9XG59XG5cbmNvbnN0IG5vcm1hbGl6ZSA9IHggPT4gTWF0aC5tYXgoeCwgMCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2Nyb2xsQWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFBhZ2VBY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNraXApIHtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICB9XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2Nyb2xsZXJTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxPYnNlcnZhYmxlKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsT2JzZXJ2YWJsZSA9IHNjcm9sbE9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuZmlyc3RMb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmJvdHRvbU9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMudG9wT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY3JlYXRlKHJvd0hlaWdodFNlcnZpY2UsIHNraXAsIHRha2UsIHRvdGFsLCB0b3BPZmZzZXQgPSAwLCBib3R0b21PZmZzZXQgPSAwLCBkaXJlY3Rpb24gPSAndmVydGljYWwnKSB7XG4gICAgICAgIHRoaXMucm93SGVpZ2h0U2VydmljZSA9IHJvd0hlaWdodFNlcnZpY2U7XG4gICAgICAgIHRoaXMuZmlyc3RMb2FkZWQgPSBza2lwO1xuICAgICAgICB0aGlzLmxhc3RMb2FkZWQgPSBza2lwICsgdGFrZTtcbiAgICAgICAgdGhpcy50YWtlID0gdGFrZTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGwgPSAwO1xuICAgICAgICB0aGlzLnRvcE9mZnNldCA9IHRvcE9mZnNldDtcbiAgICAgICAgdGhpcy5ib3R0b21PZmZzZXQgPSBib3R0b21PZmZzZXQ7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICBjb25zdCBzdWJqZWN0ID0gbmV3IFJlcGxheVN1YmplY3QoMik7XG4gICAgICAgIGNvbnN0IG9mZnNldEJ1ZmZlclJvd3MgPSB0aGlzLnJvd3NGb3JIZWlnaHQodG9wT2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc2tpcFdpdGhPZmZzZXQgPSBub3JtYWxpemUoc2tpcCAtIG9mZnNldEJ1ZmZlclJvd3MpO1xuICAgICAgICBzdWJqZWN0Lm5leHQobmV3IFNjcm9sbEFjdGlvbih0aGlzLnJvd09mZnNldChza2lwV2l0aE9mZnNldCkpKTtcbiAgICAgICAgaWYgKG9mZnNldEJ1ZmZlclJvd3MpIHtcbiAgICAgICAgICAgIHN1YmplY3QubmV4dChuZXcgUGFnZUFjdGlvbihza2lwV2l0aE9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24gPSB0aGlzLnNjcm9sbE9ic2VydmFibGUuc3Vic2NyaWJlKHggPT4gdGhpcy5vblNjcm9sbCh4LCBvYnNlcnZlcikpO1xuICAgICAgICB9KS5zdWJzY3JpYmUoKHgpID0+IHN1YmplY3QubmV4dCh4KSk7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblNjcm9sbCh7IHNjcm9sbExlZnQsIHNjcm9sbFRvcCwgb2Zmc2V0SGVpZ2h0LCBvZmZzZXRXaWR0aCB9LCBvYnNlcnZlcikge1xuICAgICAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gc2Nyb2xsVG9wIDogc2Nyb2xsTGVmdDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0U2l6ZSA9IHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gb2Zmc2V0SGVpZ2h0IDogb2Zmc2V0V2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmxhc3RTY3JvbGwgPT09IHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXAgPSB0aGlzLmxhc3RTY3JvbGwgPj0gc2Nyb2xsUG9zaXRpb247XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbCA9IHNjcm9sbFBvc2l0aW9uO1xuICAgICAgICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5pbmRleChub3JtYWxpemUoc2Nyb2xsUG9zaXRpb24gLSB0aGlzLnRvcE9mZnNldCkpO1xuICAgICAgICBjb25zdCBsYXN0SXRlbUluZGV4ID0gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLmluZGV4KG5vcm1hbGl6ZShzY3JvbGxQb3NpdGlvbiArIG9mZnNldFNpemUgLSB0aGlzLmJvdHRvbU9mZnNldCkpO1xuICAgICAgICBpZiAoIXVwICYmIGxhc3RJdGVtSW5kZXggPj0gdGhpcy5sYXN0TG9hZGVkICYmIHRoaXMubGFzdExvYWRlZCA8IHRoaXMudG90YWwpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RMb2FkZWQgPSBmaXJzdEl0ZW1JbmRleDtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQobmV3IFNjcm9sbEFjdGlvbih0aGlzLnJvd09mZnNldChmaXJzdEl0ZW1JbmRleCkpKTtcbiAgICAgICAgICAgIHRoaXMubGFzdExvYWRlZCA9IE1hdGgubWluKHRoaXMuZmlyc3RMb2FkZWQgKyB0aGlzLnRha2UsIHRoaXMudG90YWwpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgUGFnZUFjdGlvbih0aGlzLmZpcnN0TG9hZGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwICYmIGZpcnN0SXRlbUluZGV4IDw9IHRoaXMuZmlyc3RMb2FkZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vblZpc2libGVCdWZmZXIgPSBNYXRoLmZsb29yKHRoaXMudGFrZSAqIDAuMyk7XG4gICAgICAgICAgICB0aGlzLmZpcnN0TG9hZGVkID0gbm9ybWFsaXplKGZpcnN0SXRlbUluZGV4IC0gbm9uVmlzaWJsZUJ1ZmZlcik7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KG5ldyBTY3JvbGxBY3Rpb24odGhpcy5yb3dPZmZzZXQodGhpcy5maXJzdExvYWRlZCkpKTtcbiAgICAgICAgICAgIHRoaXMubGFzdExvYWRlZCA9IE1hdGgubWluKHRoaXMuZmlyc3RMb2FkZWQgKyB0aGlzLnRha2UsIHRoaXMudG90YWwpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgUGFnZUFjdGlvbih0aGlzLmZpcnN0TG9hZGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcm93T2Zmc2V0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KGluZGV4KSArIHRoaXMudG9wT2Zmc2V0O1xuICAgIH1cbiAgICByb3dzRm9ySGVpZ2h0KGhlaWdodCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGhlaWdodCAvIHRoaXMucm93SGVpZ2h0U2VydmljZS5oZWlnaHQoMCkpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgU0NST0xMRVJfRkFDVE9SWV9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbignZGF0ZWlucHV0cy1zY3JvbGwtc2VydmljZS1mYWN0b3J5Jyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gREVGQVVMVF9TQ1JPTExFUl9GQUNUT1JZKG9ic2VydmFibGUpIHtcbiAgICByZXR1cm4gbmV3IFNjcm9sbGVyU2VydmljZShvYnNlcnZhYmxlKTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgU2Nyb2xsRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChTY3JvbGxEaXJlY3Rpb24pIHtcbiAgICBTY3JvbGxEaXJlY3Rpb25bU2Nyb2xsRGlyZWN0aW9uW1wiQmFja3dhcmRcIl0gPSAwXSA9IFwiQmFja3dhcmRcIjtcbiAgICBTY3JvbGxEaXJlY3Rpb25bU2Nyb2xsRGlyZWN0aW9uW1wiRm9yd2FyZFwiXSA9IDFdID0gXCJGb3J3YXJkXCI7XG59KShTY3JvbGxEaXJlY3Rpb24gfHwgKFNjcm9sbERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBGUkFNRV9EVVJBVElPTiA9IDE3O1xuY29uc3Qgc2Nyb2xsTW9kaWZpZXJzID0ge1xuICAgIFtTY3JvbGxEaXJlY3Rpb24uRm9yd2FyZF06IChzdGVwKSA9PiB2YWx1ZSA9PiB2YWx1ZSArIHN0ZXAsXG4gICAgW1Njcm9sbERpcmVjdGlvbi5CYWNrd2FyZF06IChzdGVwKSA9PiB2YWx1ZSA9PiB2YWx1ZSAtIHN0ZXBcbn07XG5jb25zdCBzY3JvbGxOb3JtYWxpemVycyA9IHtcbiAgICBbU2Nyb2xsRGlyZWN0aW9uLkZvcndhcmRdOiAoZW5kKSA9PiB2YWx1ZSA9PiBNYXRoLm1pbih2YWx1ZSwgZW5kKSxcbiAgICBbU2Nyb2xsRGlyZWN0aW9uLkJhY2t3YXJkXTogKGVuZCkgPT4gdmFsdWUgPT4gTWF0aC5tYXgodmFsdWUsIGVuZClcbn07XG5jb25zdCBzY3JvbGxWYWxpZGF0b3JzID0ge1xuICAgIFtTY3JvbGxEaXJlY3Rpb24uRm9yd2FyZF06IGVuZCA9PiBzdGFydCA9PiBzdGFydCA8IGVuZCxcbiAgICBbU2Nyb2xsRGlyZWN0aW9uLkJhY2t3YXJkXTogZW5kID0+IHN0YXJ0ID0+IHN0YXJ0ID4gZW5kXG59O1xuY29uc3QgZGlmZmVyZW5jZVRvU2Nyb2xsID0gKHNjcm9sbFRvcCwgc3RhdGljT2Zmc2V0LCBtYXhTY3JvbGxEaWZmZXJlbmNlKSA9PiB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGguYWJzKHN0YXRpY09mZnNldCAtIHNjcm9sbFRvcCksIG1heFNjcm9sbERpZmZlcmVuY2UpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVmlydHVhbGl6YXRpb25Db21wb25lbnQgPSBjbGFzcyBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc2Nyb2xsZXJGYWN0b3J5LCBjb250YWluZXIsIHJlbmRlcmVyLCB6b25lKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgdGhpcy5pdGVtSGVpZ2h0ID0gMTtcbiAgICAgICAgdGhpcy5pdGVtV2lkdGggPSAxO1xuICAgICAgICB0aGlzLnRvcE9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuYm90dG9tT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5tYXhTY3JvbGxEaWZmZXJlbmNlID0gMTAwO1xuICAgICAgICB0aGlzLnNjcm9sbE9mZnNldFNpemUgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbER1cmF0aW9uID0gMTUwO1xuICAgICAgICB0aGlzLmFjdGl2ZUluZGV4Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnBhZ2VDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLndyYXBwZXJDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXIgPSBzY3JvbGxlckZhY3RvcnkodGhpcy5kaXNwYXRjaGVyKTtcbiAgICB9XG4gICAgZ2V0IGhvcml6b250YWxDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIGdldCB0b3RhbFZlcnRleExlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBgJHt0aGlzLnRvdGFsU2l6ZX1weGA7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHsgaGVpZ2h0OiB2YWx1ZSB9IDogeyB3aWR0aDogdmFsdWUgfTtcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lck9mZnNldFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbnRhaW5lclByb3BlcnR5KHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gJ29mZnNldEhlaWdodCcgOiAnb2Zmc2V0V2lkdGgnKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lclNjcm9sbFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbnRhaW5lclByb3BlcnR5KHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gJ3Njcm9sbEhlaWdodCcgOiAnc2Nyb2xsV2lkdGgnKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lclNjcm9sbFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250YWluZXJQcm9wZXJ0eSh0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5kaXJlY3Rpb24gfHwgY2hhbmdlcy50YWtlIHx8IGNoYW5nZXMudG90YWwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFNlcnZpY2VzKCk7XG4gICAgICAgICAgICB0aGlzLnRvdGFsU2l6ZSA9IHRoaXMucm93SGVpZ2h0U2VydmljZS50b3RhbEhlaWdodCgpICsgdGhpcy5ib3R0b21PZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3dIZWlnaHRTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0hlaWdodFNlcnZpY2UgPSB0aGlzLmNyZWF0ZVJvd0hlaWdodFNlcnZpY2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclNjcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuc2Nyb2xsJCgpXG4gICAgICAgICAgICAgICAgLnBpcGUobWFwKChldmVudCkgPT4gZXZlbnQudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKHQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5uZXh0KHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdEFjdGl2ZUluZGV4KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXJTY3JvbGxTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyU2Nyb2xsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb250YWluZXJQcm9wZXJ0eShwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnRbcHJvcGVydHlOYW1lXTtcbiAgICB9XG4gICAgYWN0aXZlSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1JbmRleChNYXRoLmNlaWwodGhpcy5jb250YWluZXJTY3JvbGxQb3NpdGlvbikpOyAvL2hhbmRsZSBzdWJwaXhlbGluZ1xuICAgIH1cbiAgICBpdGVtSW5kZXgob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0hlaWdodFNlcnZpY2UuaW5kZXgob2Zmc2V0KTtcbiAgICB9XG4gICAgaXRlbU9mZnNldChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLm9mZnNldChpbmRleCk7XG4gICAgfVxuICAgIGlzSW5kZXhWaXNpYmxlKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5yb3dIZWlnaHRTZXJ2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyVG9wID0gdGhpcy5jb250YWluZXJTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgY29uc3QgY29udGFpbmVyQm90dG9tID0gY29udGFpbmVyVG9wICsgdGhpcy5jb250YWluZXJPZmZzZXRTaXplO1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KGluZGV4KTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gdG9wICsgdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLmhlaWdodChpbmRleCk7XG4gICAgICAgIHJldHVybiB0b3AgPj0gY29udGFpbmVyVG9wICYmIGJvdHRvbSA8PSBjb250YWluZXJCb3R0b207XG4gICAgfVxuICAgIGlzTGlzdFNjcm9sbGVkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lclNjcm9sbFBvc2l0aW9uICE9PSB0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KGluZGV4KTtcbiAgICB9XG4gICAgc2Nyb2xsVG8odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsUHJvcGVydHkgPSB0aGlzLmRpcmVjdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCwgc2Nyb2xsUHJvcGVydHksIHZhbHVlKTtcbiAgICB9XG4gICAgc2Nyb2xsVG9JbmRleChpbmRleCkge1xuICAgICAgICAvL1hYWDogc2Nyb2xsaW5nIHdpdGggdGljayBpcyByZXF1aXJlZCB0byBwcmV2ZW50IGxpc3QganVtcCBpbiBDaHJvbWUuXG4gICAgICAgIC8vT3JpZ2luYWwgaXNzdWU6IGZvY3VzIGZpcnN0IGRheSBpbiB0aGUgbW9udGggYW5kIHByZXNzIExFRlQgYXJyb3cuXG4gICAgICAgIC8vTm90aWNlIGhvdyB0aGUgdmlldyBqdW1wcyBvbiBldmVyeSBkYXkgY2hhbmdlLlxuICAgICAgICAvL1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KGluZGV4KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjcm9sbFRvQm90dG9tKCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvKHRoaXMudG90YWxTaXplKTtcbiAgICB9XG4gICAgYW5pbWF0ZVRvSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4T2Zmc2V0ID0gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLm9mZnNldChpbmRleCk7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0Q29udGFpbmVyU2Nyb2xsRGlyZWN0aW9uKGluZGV4T2Zmc2V0KTtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLnNjcm9sbFJhbmdlKGluZGV4T2Zmc2V0LCBkaXJlY3Rpb24pO1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnNjcm9sbFN0ZXAoc3RhcnQsIGVuZCk7XG4gICAgICAgIGNvbnN0IG1vZGlmeVNjcm9sbCA9IHNjcm9sbE1vZGlmaWVyc1tkaXJlY3Rpb25dKHN0ZXApO1xuICAgICAgICBjb25zdCBub3JtYWxpemVTY3JvbGwgPSBzY3JvbGxOb3JtYWxpemVyc1tkaXJlY3Rpb25dKGVuZCk7XG4gICAgICAgIGNvbnN0IGlzU2Nyb2xsVmFsaWQgPSBzY3JvbGxWYWxpZGF0b3JzW2RpcmVjdGlvbl0obW9kaWZ5U2Nyb2xsKGVuZCkpO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdWJzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgIGNvbWJpbmVMYXRlc3Qob2Yoc3RhcnQpLCBpbnRlcnZhbCgwLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlcikpLnBpcGUobWFwKHN0cmVhbSA9PiBzdHJlYW1bMF0pLCBzY2FuKG1vZGlmeVNjcm9sbCksIHRha2VXaGlsZShpc1Njcm9sbFZhbGlkKSwgbWFwKG5vcm1hbGl6ZVNjcm9sbCkpLnN1YnNjcmliZSgoeCkgPT4gdGhpcy5zY3JvbGxUbyh4KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY3JvbGxSYW5nZShpbmRleE9mZnNldCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNjcm9sbCA9IHRoaXMuY29udGFpbmVyU2Nyb2xsUG9zaXRpb247XG4gICAgICAgIGlmIChwYXJzZUludChpbmRleE9mZnNldCwgMTApID09PSBwYXJzZUludChjb250YWluZXJTY3JvbGwsIDEwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGluZGV4T2Zmc2V0LCBlbmQ6IGluZGV4T2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4U2Nyb2xsID0gdGhpcy5jb250YWluZXJNYXhTY3JvbGwoKTtcbiAgICAgICAgY29uc3Qgc2lnbiA9IGRpcmVjdGlvbiA9PT0gU2Nyb2xsRGlyZWN0aW9uLkJhY2t3YXJkID8gMSA6IC0xO1xuICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gZGlmZmVyZW5jZVRvU2Nyb2xsKGNvbnRhaW5lclNjcm9sbCwgaW5kZXhPZmZzZXQsIHRoaXMubWF4U2Nyb2xsRGlmZmVyZW5jZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKGluZGV4T2Zmc2V0LCBtYXhTY3JvbGwpO1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKE1hdGgubWF4KGVuZCArIChzaWduICogZGlmZmVyZW5jZSksIDApLCBtYXhTY3JvbGwpO1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgfVxuICAgIHNjcm9sbFN0ZXAoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoZW5kIC0gc3RhcnQpIC8gKHRoaXMuc2Nyb2xsRHVyYXRpb24gLyBGUkFNRV9EVVJBVElPTik7XG4gICAgfVxuICAgIHNjcm9sbCQoKSB7XG4gICAgICAgIHJldHVybiBpc0RvY3VtZW50QXZhaWxhYmxlKCkgPyBmcm9tRXZlbnQodGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCwgJ3Njcm9sbCcpIDogRU1QVFk7XG4gICAgfVxuICAgIGluaXRTZXJ2aWNlcygpIHtcbiAgICAgICAgdGhpcy5yb3dIZWlnaHRTZXJ2aWNlID0gdGhpcy5jcmVhdGVSb3dIZWlnaHRTZXJ2aWNlKCk7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuc2Nyb2xsZXJcbiAgICAgICAgICAgIC5jcmVhdGUodGhpcy5yb3dIZWlnaHRTZXJ2aWNlLCB0aGlzLnNraXAsIHRoaXMudGFrZSwgdGhpcy50b3RhbCwgdGhpcy50b3BPZmZzZXQsIHRoaXMuc2Nyb2xsT2Zmc2V0U2l6ZSwgdGhpcy5kaXJlY3Rpb24pXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh4KSA9PiB7XG4gICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFBhZ2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VDaGFuZ2UuZW1pdCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2hhbmdlLmVtaXQoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVSb3dIZWlnaHRTZXJ2aWNlKCkge1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHRoaXMuaXRlbUhlaWdodCA6IHRoaXMuaXRlbVdpZHRoO1xuICAgICAgICByZXR1cm4gbmV3IFJvd0hlaWdodFNlcnZpY2UodGhpcy50b3RhbCwgZGltZW5zaW9uLCAwKTtcbiAgICB9XG4gICAgZW1pdEFjdGl2ZUluZGV4KCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5pbmRleCh0aGlzLmNvbnRhaW5lclNjcm9sbFBvc2l0aW9uIC0gdGhpcy50b3BPZmZzZXQpO1xuICAgICAgICBpZiAodGhpcy5sYXN0QWN0aXZlSW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RBY3RpdmVJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleENoYW5nZS5lbWl0KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb250YWluZXJNYXhTY3JvbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lclNjcm9sbFNpemUgLSB0aGlzLmNvbnRhaW5lck9mZnNldFNpemU7XG4gICAgfVxuICAgIGdldENvbnRhaW5lclNjcm9sbERpcmVjdGlvbihpbmRleE9mZnNldCkge1xuICAgICAgICByZXR1cm4gaW5kZXhPZmZzZXQgPCB0aGlzLmNvbnRhaW5lclNjcm9sbFBvc2l0aW9uID8gU2Nyb2xsRGlyZWN0aW9uLkJhY2t3YXJkIDogU2Nyb2xsRGlyZWN0aW9uLkZvcndhcmQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtSGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbVdpZHRoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwidG9wT2Zmc2V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm90dG9tT2Zmc2V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4U2Nyb2xsRGlmZmVyZW5jZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmlydHVhbGl6YXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcInNjcm9sbE9mZnNldFNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY3JvbGxEdXJhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmlydHVhbGl6YXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcInNraXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWtlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwidG90YWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlSW5kZXhDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwicGFnZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY3JvbGxDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWZsZXgnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1jb250ZW50JyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstY2FsZW5kYXItY29udGVudCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXNjcm9sbGFibGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3cmFwcGVyQ2xhc3Nlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstc2Nyb2xsYWJsZS1ob3Jpem9udGFsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3Jpem9udGFsQ2xhc3NcIiwgbnVsbCk7XG5WaXJ0dWFsaXphdGlvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBTQ1JPTExFUl9GQUNUT1JZX1RPS0VOLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiBERUZBVUxUX1NDUk9MTEVSX0ZBQ1RPUllcbiAgICAgICAgICAgIH1dLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXZpcnR1YWxpemF0aW9uJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPGRpdlxuICAgICAgICBjbGFzcz1cImstc2Nyb2xsYWJsZS1wbGFjZWhvbGRlclwiXG4gICAgICAgIFtjbGFzcy5rLXNjcm9sbGFibGUtaG9yaXpvbnRhbC1wbGFjZWhvbGRlcl09XCJkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJ1wiXG4gICAgICAgIFtuZ1N0eWxlXT1cInRvdGFsVmVydGV4TGVuZ3RoXCJcbiAgICA+PC9kaXY+XG4gIGBcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIEluamVjdChTQ1JPTExFUl9GQUNUT1JZX1RPS0VOKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTmdab25lXSlcbl0sIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3RJblNjb3BlID0gKG5vZGUsIHByZWRpY2F0ZSwgc2NvcGUpID0+IHtcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBzY29wZSAmJiAhcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlICE9PSBzY29wZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3QgPSAobm9kZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIXByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IElURU1TX0NPVU5UID0gMzA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IE5hdmlnYXRpb25Db21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihidXMsIGRvbSwgaW50bCwgY2RyLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmJ1cyA9IGJ1cztcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubWluID0gbmV3IERhdGUoTUlOX0RBVEUpO1xuICAgICAgICB0aGlzLm1heCA9IG5ldyBEYXRlKE1BWF9EQVRFKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kYXRlcyA9IFtdO1xuICAgICAgICB0aGlzLnRha2UgPSBJVEVNU19DT1VOVDtcbiAgICAgICAgdGhpcy5pbmRleFRvU2Nyb2xsID0gLTE7XG4gICAgfVxuICAgIGdldCBnZXRDb21wb25lbnRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmRvbS5lbnN1cmVIZWlnaHRzKCk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFySGVpZ2h0ID0gdGhpcy5kb20uY2FsZW5kYXJIZWlnaHQ7XG4gICAgICAgIHRoaXMuaXRlbUhlaWdodCA9IHRoaXMuZG9tLm5hdmlnYXRpb25JdGVtSGVpZ2h0O1xuICAgICAgICB0aGlzLm1heFZpZXdIZWlnaHQgPSB0aGlzLmRvbS5tb250aFZpZXdIZWlnaHQ7XG4gICAgICAgIHRoaXMudG9wT2Zmc2V0ID0gKGNhbGVuZGFySGVpZ2h0IC0gdGhpcy5pdGVtSGVpZ2h0KSAvIDI7XG4gICAgICAgIHRoaXMuYm90dG9tT2Zmc2V0ID0gY2FsZW5kYXJIZWlnaHQgLSB0aGlzLml0ZW1IZWlnaHQ7XG4gICAgICAgIHRoaXMuaW50bFN1YnNjcmlwdGlvbiA9IHRoaXMuaW50bC5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmludGxDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gdGhpcy5idXMuc2VydmljZSh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgICAgICBpZiAoIXRoaXMuc2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlVmlld1ZhbHVlID0gQ2FsZW5kYXJWaWV3RW51bVt0aGlzLmFjdGl2ZVZpZXddO1xuICAgICAgICBjb25zdCB2aWV3RGF0ZSA9IGRhdGVJblJhbmdlKHRoaXMuZm9jdXNlZERhdGUsIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gdGhpcy5zZXJ2aWNlLnRvdGFsKHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIGNvbnN0IHRvdGFsQ2hhbmdlZCA9IHRoaXMudG90YWwgJiYgdGhpcy50b3RhbCAhPT0gdG90YWw7XG4gICAgICAgIHRoaXMuc2tpcCA9IHRoaXMuc2VydmljZS5za2lwKHZpZXdEYXRlLCB0aGlzLm1pbik7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgaWYgKHRvdGFsQ2hhbmdlZCB8fCAhdGhpcy5zZXJ2aWNlLmlzSW5BcnJheSh2aWV3RGF0ZSwgdGhpcy5kYXRlcykpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZXMgPSB0aGlzLnNlcnZpY2UuZGF0ZXNMaXN0KHZpZXdEYXRlLCB0aGlzLmdldFRha2UodGhpcy5za2lwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhY2hhbmdlcy5mb2N1c2VkRGF0ZSB8fCB0b3RhbENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhUb1Njcm9sbCA9IHRoaXMuc2VydmljZS5za2lwKHRoaXMuZm9jdXNlZERhdGUsIHRoaXMubWluKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50bFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5pbnRsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleFRvU2Nyb2xsID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlydHVhbGl6YXRpb24uc2Nyb2xsVG9JbmRleCh0aGlzLmluZGV4VG9TY3JvbGwpO1xuICAgICAgICB0aGlzLmluZGV4VG9TY3JvbGwgPSAtMTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleFRvU2Nyb2xsID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlydHVhbGl6YXRpb24uc2Nyb2xsVG9JbmRleCh0aGlzLmluZGV4VG9TY3JvbGwpO1xuICAgICAgICB0aGlzLmluZGV4VG9TY3JvbGwgPSAtMTtcbiAgICB9XG4gICAgb25QYWdlQ2hhbmdlKHsgc2tpcCB9KSB7XG4gICAgICAgIHRoaXMuZGF0ZXMgPSB0aGlzLnNlcnZpY2UuZGF0ZXNMaXN0KHRoaXMuc2VydmljZS5hZGRUb0RhdGUodGhpcy5taW4sIHNraXApLCB0aGlzLmdldFRha2Uoc2tpcCkpO1xuICAgICAgICB0aGlzLnBhZ2VDaGFuZ2UuZW1pdCgpO1xuICAgIH1cbiAgICBzY3JvbGxDaGFuZ2UoeyBvZmZzZXQgfSkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMubGlzdC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCB0cmFuc2xhdGUgPSBgdHJhbnNsYXRlWSgke29mZnNldH1weClgO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsLCAndHJhbnNmb3JtJywgdHJhbnNsYXRlKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgJy1tcy10cmFuc2Zvcm0nLCB0cmFuc2xhdGUpO1xuICAgIH1cbiAgICBoYW5kbGVEYXRlQ2hhbmdlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGNsb3Nlc3RJblNjb3BlKGFyZ3MudGFyZ2V0LCBub2RlID0+IG5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLWRhdGUtaW5kZXgnKSwgdGhpcy5saXN0Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1kYXRlLWluZGV4JyksIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHRoaXMuZGF0ZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KGNsb25lRGF0ZShjYW5kaWRhdGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUYWtlKHNraXApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMudG90YWwgLSBza2lwLCB0aGlzLnRha2UpO1xuICAgIH1cbiAgICBpbnRsQ2hhbmdlKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVWaWV3ID09PSBDYWxlbmRhclZpZXdFbnVtLm1vbnRoKSB7XG4gICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBOYXZpZ2F0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgTmF2aWdhdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgTmF2aWdhdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgTmF2aWdhdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNlZERhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgTmF2aWdhdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwidGVtcGxhdGVSZWZcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOYXZpZ2F0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE5hdmlnYXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcInBhZ2VDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZChWaXJ0dWFsaXphdGlvbkNvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudClcbl0sIE5hdmlnYXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcInZpcnR1YWxpemF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2xpc3QnLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIE5hdmlnYXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcImxpc3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci1uYXZpZ2F0aW9uXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYXZpZ2F0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJnZXRDb21wb25lbnRDbGFzc1wiLCBudWxsKTtcbk5hdmlnYXRpb25Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYWxlbmRhci1uYXZpZ2F0aW9uJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8c3BhbiBjbGFzcz1cImstY2FsZW5kYXItbmF2aWdhdGlvbi1oaWdobGlnaHRcIj48L3NwYW4+XG4gICAgPGtlbmRvLXZpcnR1YWxpemF0aW9uXG4gICAgICAgIFtza2lwXT1cInNraXBcIlxuICAgICAgICBbdGFrZV09XCJ0YWtlXCJcbiAgICAgICAgW3RvdGFsXT1cInRvdGFsXCJcbiAgICAgICAgW2l0ZW1IZWlnaHRdPVwiaXRlbUhlaWdodFwiXG4gICAgICAgIFt0b3BPZmZzZXRdPVwidG9wT2Zmc2V0XCJcbiAgICAgICAgW2JvdHRvbU9mZnNldF09XCJib3R0b21PZmZzZXRcIlxuICAgICAgICBbbWF4U2Nyb2xsRGlmZmVyZW5jZV09XCJtYXhWaWV3SGVpZ2h0XCJcbiAgICAgICAgKHBhZ2VDaGFuZ2UpPVwib25QYWdlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAoc2Nyb2xsQ2hhbmdlKT1cInNjcm9sbENoYW5nZSgkZXZlbnQpXCJcbiAgICA+XG4gICAgICAgIDx1bCAjbGlzdCBjbGFzcz1cImstcmVzZXRcIiBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7IGNsaWNrOiBoYW5kbGVEYXRlQ2hhbmdlIH1cIiBbc2NvcGVdPVwidGhpc1wiPlxuICAgICAgICAgICAgPGxpICprRm9yPVwibGV0IGRhdGUgb2YgZGF0ZXM7IGxldCBpbmRleD1pbmRleFwiIFthdHRyLmRhdGEtZGF0ZS1pbmRleF09XCJpbmRleFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIFtjbGFzcy5rLWNhbGVuZGFyLW5hdmlnYXRpb24tbWFya2VyXT1cInNlcnZpY2UuaXNSYW5nZVN0YXJ0KGRhdGUpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhdGVtcGxhdGVSZWZcIj57e3NlcnZpY2UubmF2aWdhdGlvblRpdGxlKGRhdGUpfX08L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0lmXT1cInRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7ICRpbXBsaWNpdDogc2VydmljZS5uYXZpZ2F0aW9uVGl0bGUoZGF0ZSksIGFjdGl2ZVZpZXc6IGFjdGl2ZVZpZXdWYWx1ZSwgZGF0ZTogZGF0ZSB9XCJcbiAgICAgICAgICAgICAgICAgICAgPjwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC91bD5cbiAgICA8L2tlbmRvLXZpcnR1YWxpemF0aW9uPlxuICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCdXNWaWV3U2VydmljZSxcbiAgICAgICAgQ2FsZW5kYXJET01TZXJ2aWNlLFxuICAgICAgICBJbnRsU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBOYXZpZ2F0aW9uQ29tcG9uZW50KTtcblxuY29uc3QgVklFV1NfQ09VTlQgPSA1O1xuY29uc3QgaXNFcXVhbE1vbnRoWWVhciA9IChkYXRlMSwgZGF0ZTIpID0+IChkYXRlMSAmJiBkYXRlMiAmJlxuICAgIGRhdGUxLmdldEZ1bGxZZWFyKCkgPT09IGRhdGUyLmdldEZ1bGxZZWFyKCkgJiZcbiAgICBkYXRlMS5nZXRNb250aCgpID09PSBkYXRlMi5nZXRNb250aCgpKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVmlld0xpc3RDb21wb25lbnQgPSBjbGFzcyBWaWV3TGlzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYnVzLCBjZHIsIGludGwsIGRvbSwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5idXMgPSBidXM7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5taW4gPSBuZXcgRGF0ZShNSU5fREFURSk7XG4gICAgICAgIHRoaXMubWF4ID0gbmV3IERhdGUoTUFYX0RBVEUpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jZWxsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMud2Vla051bWJlckNlbGxDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnRvZGF5QnV0dG9uQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnRDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2xzID0gW107XG4gICAgICAgIHRoaXMud2Vla05hbWVzID0gW107XG4gICAgICAgIHRoaXMudGFrZSA9IFZJRVdTX0NPVU5UO1xuICAgICAgICB0aGlzLmFuaW1hdGVUb0luZGV4ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbmRleFRvU2Nyb2xsID0gLTE7XG4gICAgICAgIHRoaXMubWluVmlld3NUb1JlbmRlciA9IDE7XG4gICAgfVxuICAgIGdldCB3ZWVrTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93V2Vla051bWJlcnMgJiYgdGhpcy5pc01vbnRoVmlldygpO1xuICAgIH1cbiAgICBzZXQgd2Vla051bWJlcihzaG93V2Vla051bWJlcnMpIHtcbiAgICAgICAgdGhpcy5zaG93V2Vla051bWJlcnMgPSBzaG93V2Vla051bWJlcnM7XG4gICAgfVxuICAgIGdldCBnZXRDb21wb25lbnRNb250aENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVWaWV3ID09PSBDYWxlbmRhclZpZXdFbnVtLm1vbnRoO1xuICAgIH1cbiAgICBnZXQgZ2V0Q29tcG9uZW50WWVhckNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVWaWV3ID09PSBDYWxlbmRhclZpZXdFbnVtLnllYXI7XG4gICAgfVxuICAgIGdldCBnZXRDb21wb25lbnREZWNhZGVDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldyA9PT0gQ2FsZW5kYXJWaWV3RW51bS5kZWNhZGU7XG4gICAgfVxuICAgIGdldCBnZXRDb21wb25lbnRDZW50dXJ5Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZpZXcgPT09IENhbGVuZGFyVmlld0VudW0uY2VudHVyeTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMud2Vla05hbWVzID0gdGhpcy5nZXRXZWVrTmFtZXMoKTtcbiAgICAgICAgdGhpcy5ib3R0b21PZmZzZXQgPSB0aGlzLmdldEJvdHRvbU9mZnNldCgpO1xuICAgICAgICB0aGlzLnZpZXdPZmZzZXQgPSAtMSAqIHRoaXMuZG9tLmhlYWRlckhlaWdodDtcbiAgICAgICAgdGhpcy52aWV3SGVpZ2h0ID0gdGhpcy5kb20udmlld0hlaWdodCh0aGlzLmFjdGl2ZVZpZXcpO1xuICAgICAgICB0aGlzLmludGxTdWJzY3JpcHRpb24gPSB0aGlzLmludGwuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5pbnRsQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHRoaXMuYnVzLnNlcnZpY2UodGhpcy5hY3RpdmVWaWV3KTtcbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHMgPSBuZXcgQXJyYXkodGhpcy5zZXJ2aWNlLnJvd0xlbmd0aCh7IHByZXBlbmRDZWxsOiB0aGlzLndlZWtOdW1iZXIgfSkpLmZpbGwoJycpO1xuICAgICAgICB0aGlzLmNvbFdpZHRoID0gTWF0aC5yb3VuZCgxMDAgLyB0aGlzLmNvbHMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy53ZWVrTmFtZXMgPSBoYXNDaGFuZ2UoY2hhbmdlcywgJ3dlZWtOdW1iZXInKSAmJiB0aGlzLndlZWtOdW1iZXIgPyB0aGlzLmdldFdlZWtOYW1lcygpIDogdGhpcy53ZWVrTmFtZXM7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXdDaGFuZ2VkID0gaGFzQ2hhbmdlKGNoYW5nZXMsICdhY3RpdmVWaWV3Jyk7XG4gICAgICAgIGNvbnN0IGZvY3VzZWREYXRlID0gdGhpcy5mb2N1c2VkRGF0ZTtcbiAgICAgICAgY29uc3Qgdmlld0RhdGUgPSBkYXRlSW5SYW5nZSh0aGlzLnNlcnZpY2Uudmlld0RhdGUoZm9jdXNlZERhdGUsIHRoaXMubWF4LCB0aGlzLm1pblZpZXdzVG9SZW5kZXIpLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHRoaXMuc2VydmljZS50b3RhbCh0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgICAgICBjb25zdCB0b3RhbENoYW5nZWQgPSB0aGlzLnRvdGFsICYmIHRoaXMudG90YWwgIT09IHRvdGFsO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZURhdGVzID0gdG90YWxDaGFuZ2VkIHx8ICF0aGlzLnNlcnZpY2UuaXNJbkFycmF5KGZvY3VzZWREYXRlLCB0aGlzLmRhdGVzKTtcbiAgICAgICAgdGhpcy5za2lwID0gdGhpcy5zZXJ2aWNlLnNraXAodmlld0RhdGUsIHRoaXMubWluKTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmFuaW1hdGVUb0luZGV4ID0gIWFjdGl2ZVZpZXdDaGFuZ2VkO1xuICAgICAgICB0aGlzLmJvdHRvbU9mZnNldCA9IHRoaXMuZ2V0Qm90dG9tT2Zmc2V0KCk7XG4gICAgICAgIHRoaXMudmlld0hlaWdodCA9IHRoaXMuZG9tLnZpZXdIZWlnaHQodGhpcy5hY3RpdmVWaWV3KTtcbiAgICAgICAgaWYgKGdlbmVyYXRlRGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZXMgPSB0aGlzLnNlcnZpY2UuZGF0ZXNMaXN0KHZpZXdEYXRlLCB0aGlzLmdldFRha2UodGhpcy5za2lwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsTW9udGhZZWFyKHRoaXMuYWN0aXZlRGF0ZSwgZm9jdXNlZERhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSBjbG9uZURhdGUoZm9jdXNlZERhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwZGF0ZUluZGV4ID0gaGFzQ2hhbmdlKGNoYW5nZXMsICdmb2N1c2VkRGF0ZScpIHx8IGFjdGl2ZVZpZXdDaGFuZ2VkO1xuICAgICAgICBpZiAoZ2VuZXJhdGVEYXRlcyB8fCB1cGRhdGVJbmRleCB8fCB0aGlzLnZpcnR1YWxpemF0aW9uLmlzSW5kZXhWaXNpYmxlKHRoaXMuc2tpcCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhUb1Njcm9sbCA9IHRoaXMuc2VydmljZS5za2lwKGZvY3VzZWREYXRlLCB0aGlzLm1pbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmludGxTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaW50bFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhUb1Njcm9sbCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpcnR1YWxpemF0aW9uLnNjcm9sbFRvSW5kZXgodGhpcy5pbmRleFRvU2Nyb2xsKTtcbiAgICAgICAgdGhpcy5pbmRleFRvU2Nyb2xsID0gLTE7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhUb1Njcm9sbCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpcnR1YWxpemF0aW9uW3RoaXMuYW5pbWF0ZVRvSW5kZXggPyAnYW5pbWF0ZVRvSW5kZXgnIDogJ3Njcm9sbFRvSW5kZXgnXSh0aGlzLmluZGV4VG9TY3JvbGwpO1xuICAgICAgICB0aGlzLmFuaW1hdGVUb0luZGV4ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbmRleFRvU2Nyb2xsID0gLTE7XG4gICAgfVxuICAgIG9uUGFnZUNoYW5nZSh7IHNraXAgfSkge1xuICAgICAgICB0aGlzLmRhdGVzID0gdGhpcy5zZXJ2aWNlLmRhdGVzTGlzdCh0aGlzLnNlcnZpY2UuYWRkVG9EYXRlKHRoaXMubWluLCBza2lwKSwgdGhpcy5nZXRUYWtlKHNraXApKTtcbiAgICAgICAgdGhpcy5wYWdlQ2hhbmdlLmVtaXQoKTtcbiAgICB9XG4gICAgc2Nyb2xsQ2hhbmdlKHsgb2Zmc2V0IH0pIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmxpc3QubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlID0gYHRyYW5zbGF0ZVkoJHtvZmZzZXR9cHgpYDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWwsICctbXMtdHJhbnNmb3JtJywgdHJhbnNsYXRlKTtcbiAgICB9XG4gICAgc2V0QWN0aXZlRGF0ZShpbmRleCkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB0aGlzLnNlcnZpY2UuYWRkVG9EYXRlKHRoaXMubWluLCBpbmRleCk7XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlQ2hhbmdlLmVtaXQoY2FuZGlkYXRlKTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICBpc01vbnRoVmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldyA9PT0gQ2FsZW5kYXJWaWV3RW51bS5tb250aDtcbiAgICB9XG4gICAgaXNTY3JvbGxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlydHVhbGl6YXRpb24uaXNMaXN0U2Nyb2xsZWQodGhpcy5zZXJ2aWNlLnNraXAodGhpcy5mb2N1c2VkRGF0ZSwgdGhpcy5taW4pKTtcbiAgICB9XG4gICAgZ2V0Qm90dG9tT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxhYmxlSGVpZ2h0KCkgLSB0aGlzLmRvbS52aWV3SGVpZ2h0KHRoaXMuYWN0aXZlVmlldyk7XG4gICAgfVxuICAgIGdldFNjcm9sbGFibGVIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZpZXcgPT09IENhbGVuZGFyVmlld0VudW0ubW9udGggP1xuICAgICAgICAgICAgdGhpcy5kb20uc2Nyb2xsYWJsZUNvbnRlbnRIZWlnaHQgOlxuICAgICAgICAgICAgdGhpcy5kb20uc2Nyb2xsYWJsZVllYXJDb250ZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRUYWtlKHNraXApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMudG90YWwgLSBza2lwLCB0aGlzLnRha2UpO1xuICAgIH1cbiAgICBnZXRXZWVrTmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IHdlZWtOYW1lcyA9IHNoaWZ0V2Vla05hbWVzKHRoaXMuaW50bC5kYXRlRm9ybWF0TmFtZXMoeyBuYW1lVHlwZTogJ3Nob3J0JywgdHlwZTogJ2RheXMnIH0pLCB0aGlzLmludGwuZmlyc3REYXkoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtOdW1iZXIgPyBbJyddLmNvbmNhdCh3ZWVrTmFtZXMpIDogd2Vla05hbWVzO1xuICAgIH1cbiAgICBpbnRsQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLndlZWtOYW1lcyA9IHRoaXMuZ2V0V2Vla05hbWVzKCk7XG4gICAgICAgIGlmICh0aGlzLmlzTW9udGhWaWV3KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxUZW1wbGF0ZVJlZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclRlbXBsYXRlUmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWFkZXJUaXRsZVRlbXBsYXRlUmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxVSURcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNlZERhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNBY3RpdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWREYXRlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3ZWVrTnVtYmVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlckNlbGxDbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVEYXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInRvZGF5QnV0dG9uQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwicGFnZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKFZpcnR1YWxpemF0aW9uQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50KVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInZpcnR1YWxpemF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2xpc3QnLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsaXN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstdnN0YWNrXCIpLFxuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci12aWV3XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImdldENvbXBvbmVudENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstY2FsZW5kYXItbW9udGh2aWV3XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2V0Q29tcG9uZW50TW9udGhDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci15ZWFydmlld1wiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVmlld0xpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImdldENvbXBvbmVudFllYXJDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKFwiY2xhc3Muay1jYWxlbmRhci1kZWNhZGV2aWV3XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBWaWV3TGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2V0Q29tcG9uZW50RGVjYWRlQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImNsYXNzLmstY2FsZW5kYXItY2VudHVyeXZpZXdcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFZpZXdMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJnZXRDb21wb25lbnRDZW50dXJ5Q2xhc3NcIiwgbnVsbCk7XG5WaWV3TGlzdENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNhbGVuZGFyLXZpZXdsaXN0JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8a2VuZG8tY2FsZW5kYXItaGVhZGVyXG4gICAgICAgIFtjdXJyZW50RGF0ZV09XCJhY3RpdmVEYXRlXCJcbiAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdcIlxuICAgICAgICBbdGVtcGxhdGVSZWZdPVwiaGVhZGVyVGl0bGVUZW1wbGF0ZVJlZlwiXG4gICAgICAgICh0b2RheUJ1dHRvbkNsaWNrKT1cInRvZGF5QnV0dG9uQ2xpY2suZW1pdCgkZXZlbnQpXCJcbiAgICA+XG4gICAgPC9rZW5kby1jYWxlbmRhci1oZWFkZXI+XG4gICAgPHRhYmxlIGNsYXNzPVwiay1jYWxlbmRhci13ZWVrZGF5cyBrLWNhbGVuZGFyLXRhYmxlXCIgc3R5bGU9XCJ0YWJsZS1sYXlvdXQ6IGF1dG87XCIgKm5nSWY9XCJpc01vbnRoVmlldygpXCI+XG4gICAgICAgIDx0aGVhZCBjbGFzcz1cImstY2FsZW5kYXItdGhlYWRcIj5cbiAgICAgICAgICAgIDx0ciBjbGFzcz1cImstY2FsZW5kYXItdHJcIj5cbiAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJrLWNhbGVuZGFyLXRoXCIgKm5nRm9yPVwibGV0IG5hbWUgb2Ygd2Vla05hbWVzXCIgW3N0eWxlLndpZHRoLiVdPVwiY29sV2lkdGhcIj57e25hbWV9fTwvdGg+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICA8L3RoZWFkPlxuICAgIDwvdGFibGU+XG4gICAgPGtlbmRvLXZpcnR1YWxpemF0aW9uXG4gICAgICAgIFt0YWJpbmRleF09XCItMVwiXG4gICAgICAgIFtza2lwXT1cInNraXBcIlxuICAgICAgICBbdGFrZV09XCJ0YWtlXCJcbiAgICAgICAgW3RvdGFsXT1cInRvdGFsXCJcbiAgICAgICAgW2l0ZW1IZWlnaHRdPVwidmlld0hlaWdodFwiXG4gICAgICAgIFt0b3BPZmZzZXRdPVwidmlld09mZnNldFwiXG4gICAgICAgIFtib3R0b21PZmZzZXRdPVwiYm90dG9tT2Zmc2V0XCJcbiAgICAgICAgW3Njcm9sbE9mZnNldFNpemVdPVwidmlld09mZnNldFwiXG4gICAgICAgIFttYXhTY3JvbGxEaWZmZXJlbmNlXT1cInZpZXdIZWlnaHRcIlxuICAgICAgICAocGFnZUNoYW5nZSk9XCJvblBhZ2VDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgIChzY3JvbGxDaGFuZ2UpPVwic2Nyb2xsQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAoYWN0aXZlSW5kZXhDaGFuZ2UpPVwic2V0QWN0aXZlRGF0ZSgkZXZlbnQpXCJcbiAgICAgICAgPlxuICAgICAgICA8dGFibGVcbiAgICAgICAgICAgICNsaXN0XG4gICAgICAgICAgICByb2xlPVwiZ3JpZFwiXG4gICAgICAgICAgICBjbGFzcz1cImstY2FsZW5kYXItdGFibGVcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8Y29sZ3JvdXA+PGNvbCAqbmdGb3I9XCJsZXQgXyBvZiBjb2xzXCIgLz48L2NvbGdyb3VwPlxuXG4gICAgICAgICAgICA8dGJvZHkgY2xhc3M9XCJrLWNhbGVuZGFyLXRib2R5XCJcbiAgICAgICAgICAgICAgICAgICAqa0Zvcj1cImxldCBkYXRlIG9mIGRhdGVzXCJcbiAgICAgICAgICAgICAgICAgICBrZW5kb0NhbGVuZGFyVmlld1xuICAgICAgICAgICAgICAgICAgIHJvbGU9XCJyb3dncm91cFwiXG4gICAgICAgICAgICAgICAgICAgW2FjdGl2ZVZpZXddPVwiYWN0aXZlVmlld1wiXG4gICAgICAgICAgICAgICAgICAgW2lzQWN0aXZlXT1cImlzQWN0aXZlXCJcbiAgICAgICAgICAgICAgICAgICBbbWluXT1cIm1pblwiIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICAgICBbY2VsbFVJRF09XCJjZWxsVUlEXCJcbiAgICAgICAgICAgICAgICAgICBbZm9jdXNlZERhdGVdPVwiZm9jdXNlZERhdGVcIlxuICAgICAgICAgICAgICAgICAgIFtzZWxlY3RlZERhdGVzXT1cInNlbGVjdGVkRGF0ZXNcIlxuICAgICAgICAgICAgICAgICAgIFt3ZWVrTnVtYmVyXT1cIndlZWtOdW1iZXJcIlxuICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZVJlZl09XCJjZWxsVGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgICAgIFt3ZWVrTnVtYmVyVGVtcGxhdGVSZWZdPVwid2Vla051bWJlclRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICBbdmlld0RhdGVdPVwiZGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgKGNlbGxDbGljayk9XCJjZWxsQ2xpY2suZW1pdCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAod2Vla051bWJlckNlbGxDbGljayk9XCJ3ZWVrTnVtYmVyQ2VsbENsaWNrLmVtaXQoJGV2ZW50KVwiXG4gICAgICAgICAgICA+PC90Ym9keT5cbiAgICAgICAgPC90YWJsZT5cbiAgICA8L2tlbmRvLXZpcnR1YWxpemF0aW9uPlxuICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCdXNWaWV3U2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEludGxTZXJ2aWNlLFxuICAgICAgICBDYWxlbmRhckRPTVNlcnZpY2UsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBWaWV3TGlzdENvbXBvbmVudCk7XG5cbmNvbnN0IGRpdmlkZUJ5TWFnbml0dWRlID0gKG1hZ25pdHVkZSkgPT4geCA9PiBNYXRoLmZsb29yKHggLyBtYWduaXR1ZGUpO1xuY29uc3QgcG93ZXJCeU1hZ25pdHVkZSA9IChtYWduaXR1ZGUpID0+IHggPT4geCAqIG1hZ25pdHVkZTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU2Nyb2xsU3luY1NlcnZpY2UgPSBjbGFzcyBTY3JvbGxTeW5jU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoZG9tLCB6b25lKSB7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgIH1cbiAgICBjb25maWd1cmUoYWN0aXZlVmlldykge1xuICAgICAgICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLm1heCh0aGlzLmRvbS52aWV3SGVpZ2h0KGFjdGl2ZVZpZXcpIC8gdGhpcy5kb20ubmF2aWdhdGlvbkl0ZW1IZWlnaHQsIDEpO1xuICAgICAgICB0aGlzLmRpdmlkZUJ5TWFnbml0dWRlID0gZGl2aWRlQnlNYWduaXR1ZGUobWFnbml0dWRlKTtcbiAgICAgICAgdGhpcy5wb3dlckJ5TWFnbml0dWRlID0gcG93ZXJCeU1hZ25pdHVkZShtYWduaXR1ZGUpO1xuICAgIH1cbiAgICBzeW5jKG5hdmlnYXRvciwgdmlldykge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICghbmF2aWdhdG9yIHx8ICF2aWV3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYXZpZ2F0b3IgPSBuYXZpZ2F0b3I7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbmF2U2Nyb2xsZWQsIG1vbnRoU2Nyb2xsZWQ7XG4gICAgICAgICAgICB0aGlzLm5hdlN1YnNjcmlwdGlvbiA9IG5hdmlnYXRvci5zY3JvbGwkKClcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoU2Nyb2xsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhTY3JvbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hdlNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFNpYmxpbmdPZihlLnRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudmlld1N1YnNjcmlwdGlvbiA9IHZpZXcuc2Nyb2xsJCgpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuYXZTY3JvbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBuYXZTY3JvbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vbnRoU2Nyb2xsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsU2libGluZ09mKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2Nyb2xsU2libGluZ09mKHNjcm9sbGVkRWxlbWVudCkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLnNpYmxpbmdDb21wb25lbnQoc2Nyb2xsZWRFbGVtZW50KTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5jYWxjdWxhdGVTY3JvbGwoY29tcG9uZW50LCBzY3JvbGxlZEVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICAgICAgY29tcG9uZW50LnNjcm9sbFRvKHNjcm9sbFRvcCk7XG4gICAgfVxuICAgIHNpYmxpbmdDb21wb25lbnQoc2Nyb2xsYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50ID09PSBzY3JvbGxhYmxlRWxlbWVudCA/IHRoaXMudmlldyA6IHRoaXMubmF2aWdhdG9yO1xuICAgIH1cbiAgICBjYWxjdWxhdGVTY3JvbGwoY29tcG9uZW50LCBzY3JvbGxUb3ApIHtcbiAgICAgICAgY29uc3QgbW9kaWZpZXIgPSBjb21wb25lbnQgPT09IHRoaXMubmF2aWdhdG9yID8gdGhpcy5kaXZpZGVCeU1hZ25pdHVkZSA6IHRoaXMucG93ZXJCeU1hZ25pdHVkZTtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVyKHNjcm9sbFRvcCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5hdlN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5uYXZTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aWV3U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5TY3JvbGxTeW5jU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NhbGVuZGFyRE9NU2VydmljZSwgTmdab25lXSlcbl0sIFNjcm9sbFN5bmNTZXJ2aWNlKTtcblxuLyoqXG4gKiBVc2VkIGZvciByZW5kZXJpbmcgdGhlIG5hdmlnYXRpb24gaXRlbSBvZiB0aGUgQ2FsZW5kYXIuIFRvIGRlZmluZSB0aGUgbmF2aWdhdGlvbiBpdGVtIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YFxuICogdGFnIHdpdGggdGhlIGBrZW5kb0NhbGVuZGFyTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgY29tcG9uZW50IHRhZy4gVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZVxuICogY3VycmVudCBjb21wb25lbnQuIFRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBpdGVtIHZhbHVlLCB1c2UgdGhlIGBsZXQtdGl0bGVgIGRpcmVjdGl2ZS4gVG8gcHJvdmlkZSBtb3JlIGRldGFpbHNcbiAqIGFib3V0IHRoZSBjdXJyZW50IHRpdGxlLCBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgYGRhdGVgIGJ5IHVzaW5nIHRoZSBgbGV0LWRhdGU9J2RhdGUnYCBkaXJlY3RpdmUgb3IgZ2V0IGEgcmVmZXJlbmNlXG4gKiB0byB0aGUgY3VycmVudCBhY3RpdmUgdmlldyBieSB1c2luZyB0aGUgYGxldC1hY3RpdmVWaWV3PSdhY3RpdmVWaWV3J2AgZGlyZWN0aXZlLlxuICpcbiAqIEZvciBtb3JlIGV4YW1wbGVzLCByZWZlciB0byB0aGUgYXJ0aWNsZSBvbiBbdGVtcGxhdGVzXSh7JSBzbHVnIHRlbXBsYXRlc19jYWxlbmRhciAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiBzdHlsZXM6IFsnLmN1c3RvbSB7IGNvbG9yOiByZWQ7IH0nXSxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWNhbGVuZGFyPlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvQ2FsZW5kYXJOYXZpZ2F0aW9uSXRlbVRlbXBsYXRlIGxldC10aXRsZT5cbiAqICAgICAgPHNwYW4gY2xhc3M9XCJjdXN0b21cIj57e3RpdGxlfX08L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tY2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAqIGBgYFxuICovXG5sZXQgTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2FsZW5kYXJOYXZpZ2F0aW9uSXRlbVRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG5jb25zdCBCT1RUT01fVklFV19ET0NfTElOSyQxID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvYXBpL0NhbGVuZGFyQ29tcG9uZW50LyN0b2MtYm90dG9tdmlldyc7XG5jb25zdCBUT1BfVklFV19ET0NfTElOSyQxID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvYXBpL0NhbGVuZGFyQ29tcG9uZW50LyN0b2MtdG9wdmlldyc7XG5jb25zdCBNSU5fRE9DX0xJTkskMSA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2FwaS9DYWxlbmRhckNvbXBvbmVudC8jdG9jLW1pbic7XG5jb25zdCBNQVhfRE9DX0xJTkskMSA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2FwaS9DYWxlbmRhckNvbXBvbmVudC8jdG9jLW1heCc7XG5jb25zdCBWQUxVRV9ET0NfTElOSyQxID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvY2FsZW5kYXIvI3RvYy11c2luZy13aXRoLWpzb24nO1xuY29uc3QgdmlydHVhbGl6YXRpb25Qcm9wID0geCA9PiB4ID8geC52aXJ0dWFsaXphdGlvbiA6IG51bGw7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgQ0FMRU5EQVJfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgbXVsdGk6IHRydWUsXG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2FsZW5kYXJDb21wb25lbnQpIC8vdHNsaW50OmRpc2FibGUtbGluZTpuby11c2UtYmVmb3JlLWRlY2xhcmVcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgQ0FMRU5EQVJfUkFOR0VfVkFMSURBVE9SUyA9IHtcbiAgICBtdWx0aTogdHJ1ZSxcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENhbGVuZGFyQ29tcG9uZW50KSAvL3RzbGludDpkaXNhYmxlLWxpbmU6bm8tdXNlLWJlZm9yZS1kZWNsYXJlXG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEtFTkRPX0lOUFVUX1BST1ZJREVSID0ge1xuICAgIHByb3ZpZGU6IEtlbmRvSW5wdXQsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2FsZW5kYXJDb21wb25lbnQpIC8vdHNsaW50OmRpc2FibGUtbGluZTpuby11c2UtYmVmb3JlLWRlY2xhcmVcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBDYWxlbmRhciBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfY2FsZW5kYXIgJX0jdG9jLWJhc2ljLXVzYWdlKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWNhbGVuZGFyPjwva2VuZG8tY2FsZW5kYXI+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAqIGBgYFxuICovXG5sZXQgQ2FsZW5kYXJDb21wb25lbnQgPSBjbGFzcyBDYWxlbmRhckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYnVzLCBkb20sIGVsZW1lbnQsIG5hdmlnYXRvciwgcmVuZGVyZXIsIGNkciwgbmdab25lLCBpbmplY3Rvciwgc2Nyb2xsU3luY1NlcnZpY2UsIGRpc2FibGVkRGF0ZXNTZXJ2aWNlLCBsb2NhbGl6YXRpb24sIHNlbGVjdGlvblNlcnZpY2UsIHBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5idXMgPSBidXM7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5hdmlnYXRvciA9IG5hdmlnYXRvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5zY3JvbGxTeW5jU2VydmljZSA9IHNjcm9sbFN5bmNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlID0gZGlzYWJsZWREYXRlc1NlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2UgPSBwaWNrZXJTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gbWluIG9yIG1heCB2YWxpZGF0b3JzIGFyZSBlbmZvcmNlZCB3aGVuIHZhbGlkYXRpbmcgYSBmb3JtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZVZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIENhbGVuZGFyIHNlbGVjdGlvbiBtb2RlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbXVsdGlwbGVfc2VsZWN0aW9uX2NhbGVuZGFyICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBhdmFpbGFibGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiBgc2luZ2xlYCAoZGVmYXVsdClcbiAgICAgICAgICogKiBgbXVsdGlwbGVgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9ICdzaW5nbGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBgZGlzYWJsZWRgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgICAgICogZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgYWN0aXZlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGlzYWJsZWRfY2FsZW5kYXIgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYHRhYmluZGV4YCBwcm9wZXJ0eSBvZiB0aGUgQ2FsZW5kYXIuIEJhc2VkIG9uIHRoZVxuICAgICAgICAgKiBbSFRNTCBgdGFiaW5kZXhgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4KSBiZWhhdmlvcixcbiAgICAgICAgICogaXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgZm9jdXNhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJpbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBuYXZpZ2F0aW9uYCBwcm9wZXJ0eSBvZiB0aGUgQ2FsZW5kYXJcbiAgICAgICAgICogYW5kIGRldGVybWluZXMgd2hldGhlciB0aGUgbmF2aWdhdGlvbiBzaWRlLWJhciB3aWxsIGJlIGRpc3BsYXllZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNpZGViYXJfY2FsZW5kYXIgJX0pKS5cbiAgICAgICAgICogQXBwbGllcyB0byB0aGUgW2BpbmZpbml0ZWBdKHslIHNsdWcgYXBpX2RhdGVpbnB1dHNfY2FsZW5kYXJjb21wb25lbnQgJX0jdG9jLXR5cGUpIENhbGVuZGFyIG9ubHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgYWN0aXZlIHZpZXcgdGhhdCB0aGUgQ2FsZW5kYXIgaW5pdGlhbGx5IHJlbmRlcnNcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhY3RpdmV2aWV3X2NhbGVuZGFyICV9KSkuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBhY3RpdmUgdmlldyBpcyBgbW9udGhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IFlvdSBoYXZlIHRvIHNldCBgYWN0aXZlVmlld2Agd2l0aGluIHRoZSBgdG9wVmlld2AtYGJvdHRvbVZpZXdgIHJhbmdlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3ID0gQ2FsZW5kYXJWaWV3RW51bVtDYWxlbmRhclZpZXdFbnVtLm1vbnRoXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGJvdHRvbW1vc3QgdmlldyB0byB3aGljaCB0aGUgdXNlciBjYW4gbmF2aWdhdGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkYXRlc19jYWxlbmRhciAlfSN0b2MtcGFydGlhbC1kYXRlcykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3R0b21WaWV3ID0gQ2FsZW5kYXJWaWV3RW51bVtDYWxlbmRhclZpZXdFbnVtLm1vbnRoXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIHRvcG1vc3QgdmlldyB0byB3aGljaCB0aGUgdXNlciBjYW4gbmF2aWdhdGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzaWRlYmFyX2NhbGVuZGFyICV9I3RvYy1wYXJ0aWFsLWRhdGVzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvcFZpZXcgPSBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW0uY2VudHVyeV07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZW5hYmxlIGFuaW1hdGlvbiB3aGVuIG5hdmlnYXRpbmcgdG8gcHJldmlvdXMvbmV4dCB2aWV3LlxuICAgICAgICAgKiBBcHBsaWVzIHRvIHRoZSBbYGNsYXNzaWNgXSh7JSBzbHVnIGFwaV9kYXRlaW5wdXRzX2NhbGVuZGFyY29tcG9uZW50ICV9I3RvYy10eXBlKSBDYWxlbmRhciBvbmx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IFRoaXMgZmVhdHVyZSB1c2VzIHRoZSBbV2ViIEFuaW1hdGlvbnMgQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0FuaW1hdGlvbnNfQVBJKS4gSW4gb3JkZXIgdG8gcnVuIHRoZSBhbmltYXRpb24gaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCwgeW91IG5lZWQgdGhlIGB3ZWItYW5pbWF0aW9ucy1qc2AgcG9seWZpbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGVOYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZGlzcGxheSBhIHdlZWsgbnVtYmVyIGNvbHVtbiBpbiB0aGUgYG1vbnRoYCB2aWV3XG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgd2Vla251bWNvbHVtbl9jYWxlbmRhciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBhY3RpdmUgdmlldyBpcyBjaGFuZ2VkXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19jYWxlbmRhciAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXdDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIG5hdmlnYXRpbmcgaW4gdGhlIGN1cnJlbnRseSBhY3RpdmUgdmlld1xuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgZXZlbnRzX2NhbGVuZGFyICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYWN0aXZlIHZpZXcgZGF0ZSBpcyBjaGFuZ2VkXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19jYWxlbmRhciAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqIEFwcGxpZXMgdG8gdGhlIFtgaW5maW5pdGVgXSh7JSBzbHVnIGFwaV9kYXRlaW5wdXRzX2NhbGVuZGFyY29tcG9uZW50ICV9I3RvYy10eXBlKSBDYWxlbmRhciBvbmx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3RGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWRcbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2NhbGVuZGFyICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jZWxsVUlEID0gZ3VpZCgpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluID0gbmV3IERhdGUoTUlOX0RBVEUpO1xuICAgICAgICB0aGlzLl9tYXggPSBuZXcgRGF0ZShNQVhfREFURSk7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWREYXRlID0gZ2V0VG9kYXkoKTtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLm9uQ29udHJvbFRvdWNoZWQgPSBub29wO1xuICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlID0gbm9vcDtcbiAgICAgICAgdGhpcy5taW5WYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5tYXhWYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5zeW5jTmF2aWdhdGlvbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnaW5maW5pdGUnO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgICAgIHRoaXMuc2V0Q2xhc3NlcyhlbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpZiAodGhpcy5waWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2UuY2FsZW5kYXIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYGZvY3VzZWREYXRlYCBwcm9wZXJ0eSBvZiB0aGUgQ2FsZW5kYXIgYW5kXG4gICAgICogZGVmaW5lcyB0aGUgZm9jdXNlZCBkYXRlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVzX2NhbGVuZGFyICV9I3RvYy1mb2N1c2VkLWRhdGVzKSkuXG4gICAgICpcbiAgICAgKiA+IElmIHRoZSBDYWxlbmRhciBpcyBvdXQgb2YgdGhlIG1pbiBvciBtYXggcmFuZ2UsIGl0IG5vcm1hbGl6ZXMgdGhlIGRlZmluZWQgYGZvY3VzZWREYXRlYC5cbiAgICAgKi9cbiAgICBzZXQgZm9jdXNlZERhdGUoZm9jdXNlZERhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlVmlld0RhdGUgJiYgIWlzRXF1YWwodGhpcy5fZm9jdXNlZERhdGUsIGZvY3VzZWREYXRlKSkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IHRoaXMuYnVzLnNlcnZpY2UodGhpcy5hY3RpdmVWaWV3RW51bSk7XG4gICAgICAgICAgICBjb25zdCBsYXN0RGF5SW5QZXJpb2QgPSBzZXJ2aWNlLmxhc3REYXlPZlBlcmlvZCh0aGlzLmFjdGl2ZVZpZXdEYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGlzRm9jdXNlZERhdGVJblJhbmdlID0gc2VydmljZS5pc0luUmFuZ2UoZm9jdXNlZERhdGUsIHRoaXMuYWN0aXZlVmlld0RhdGUsIGxhc3REYXlJblBlcmlvZCk7XG4gICAgICAgICAgICBpZiAoIWlzRm9jdXNlZERhdGVJblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0TmF2aWdhdGUoZm9jdXNlZERhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvY3VzZWREYXRlID0gZm9jdXNlZERhdGUgfHwgZ2V0VG9kYXkoKTtcbiAgICAgICAgdGhpcy5zZXRBcmlhQWN0aXZlZGVzY2VuZGFudCgpO1xuICAgIH1cbiAgICBnZXQgZm9jdXNlZERhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb2N1c2VkRGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBgbWluYCBwcm9wZXJ0eSBvZiB0aGUgQ2FsZW5kYXIgYW5kXG4gICAgICogZGVmaW5lcyB0aGUgbWluaW11bSBhbGxvd2VkIGRhdGUgdmFsdWVcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVyYW5nZXNfY2FsZW5kYXIgJX0pKS5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYG1pbmAgdmFsdWUgaXMgYDE5MDAtMS0xYC5cbiAgICAgKi9cbiAgICBzZXQgbWluKG1pbikge1xuICAgICAgICB0aGlzLl9taW4gPSBtaW4gfHwgbmV3IERhdGUoTUlOX0RBVEUpO1xuICAgIH1cbiAgICBnZXQgbWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBtYXhgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmRcbiAgICAgKiBkZWZpbmVzIHRoZSBtYXhpbXVtIGFsbG93ZWQgZGF0ZSB2YWx1ZVxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXJhbmdlc19jYWxlbmRhciAlfSkpLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBgbWF4YCB2YWx1ZSBpcyBgMjA5OS0xMi0zMWAuXG4gICAgICovXG4gICAgc2V0IG1heChtYXgpIHtcbiAgICAgICAgdGhpcy5fbWF4ID0gbWF4IHx8IG5ldyBEYXRlKE1BWF9EQVRFKTtcbiAgICB9XG4gICAgZ2V0IG1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBgdmFsdWVgIHByb3BlcnR5IG9mIHRoZSBDYWxlbmRhciBhbmQgZGVmaW5lcyB0aGUgc2VsZWN0ZWQgdmFsdWUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqID4gVGhlIGB2YWx1ZWAgaGFzIHRvIGJlIGEgdmFsaWRcbiAgICAgKiBbSmF2YVNjcmlwdCBgRGF0ZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUpXG4gICAgICogaW5zdGFuY2Ugd2hlbiBpbiBgc2luZ2xlYCBzZWxlY3Rpb24gbW9kZSBvciBhbiBhcnJheSBvZiB2YWxpZCBKYXZhU2NyaXB0IERhdGUgaW5zdGFuY2VzIHdoZW4gaW4gYG11bHRpcGxlYCBzZWxlY3Rpb24gbW9kZS5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKGNhbmRpZGF0ZSkge1xuICAgICAgICB0aGlzLnZlcmlmeVZhbHVlKGNhbmRpZGF0ZSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gQXJyYXkuaXNBcnJheShjYW5kaWRhdGUpID9cbiAgICAgICAgICAgIGNhbmRpZGF0ZS5maWx0ZXIoZGF0ZSA9PiBpc1ByZXNlbnQoZGF0ZSkpLm1hcChlbGVtZW50ID0+IGNsb25lRGF0ZShlbGVtZW50KSkgOlxuICAgICAgICAgICAgY2xvbmVEYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IFtdLmNvbmNhdChjYW5kaWRhdGUpLmZpbHRlcihkYXRlID0+IGlzUHJlc2VudChkYXRlKSkubWFwKGRhdGUgPT4gY2xvbmVEYXRlKGRhdGUpKTtcbiAgICAgICAgaWYgKCFhcmVEYXRlc0VxdWFsKHNlbGVjdGlvbiwgdGhpcy5zZWxlY3RlZERhdGVzKSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFNlbGVjdGVkID0gbGFzdChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5yYW5nZVBpdm90ID0gY2xvbmVEYXRlKGxhc3RTZWxlY3RlZCk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gY2xvbmVEYXRlKGxhc3RTZWxlY3RlZCkgfHwgdGhpcy5mb2N1c2VkRGF0ZTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlcyA9IHNlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IHRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGF0ZXMgb2YgdGhlIENhbGVuZGFyIHRoYXQgd2lsbCBiZSBkaXNhYmxlZFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGlzYWJsZWRfZGF0ZXNfY2FsZW5kYXIgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgZGlzYWJsZWREYXRlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmluaXRpYWxpemUodmFsdWUpO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZERhdGVzID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZERhdGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWREYXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBDYWxlbmRhciB0eXBlLlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogLSBgaW5maW5pdGVgIChkZWZhdWx0KVxuICAgICAqIC0gYGNsYXNzaWNgXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGBrLWNhbGVuZGFyLSR7dGhpcy50eXBlfWApO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBgay1jYWxlbmRhci0ke3R5cGV9YCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIERlZmluZXMgdGhlIHRlbXBsYXRlIGZvciBlYWNoIGNlbGwuXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5lc3RlZCB0ZW1wbGF0ZXMgaW4gdGhlIEtlbmRvQ2FsZW5kYXIgdGFnLlxuICAgICAqL1xuICAgIHNldCBjZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5fY2VsbFRlbXBsYXRlUmVmID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBjZWxsVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jZWxsVGVtcGxhdGVSZWYgfHwgdGhpcy5jZWxsVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIERlZmluZXMgdGhlIHRlbXBsYXRlIGZvciBlYWNoIG1vbnRoIGNlbGwuXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5lc3RlZCB0ZW1wbGF0ZXMgaW4gdGhlIEtlbmRvQ2FsZW5kYXIgdGFnLlxuICAgICAqL1xuICAgIHNldCBtb250aENlbGxUZW1wbGF0ZVJlZih0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLl9tb250aENlbGxUZW1wbGF0ZVJlZiA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICBnZXQgbW9udGhDZWxsVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aENlbGxUZW1wbGF0ZVJlZiB8fCB0aGlzLm1vbnRoQ2VsbFRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBEZWZpbmVzIHRoZSB0ZW1wbGF0ZSBmb3IgZWFjaCB5ZWFyIGNlbGwuXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5lc3RlZCB0ZW1wbGF0ZXMgaW4gdGhlIEtlbmRvQ2FsZW5kYXIgdGFnLlxuICAgICAqL1xuICAgIHNldCB5ZWFyQ2VsbFRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuX3llYXJDZWxsVGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0IHllYXJDZWxsVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95ZWFyQ2VsbFRlbXBsYXRlUmVmIHx8IHRoaXMueWVhckNlbGxUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogRGVmaW5lcyB0aGUgdGVtcGxhdGUgZm9yIGVhY2ggZGVjYWRlIGNlbGwuXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5lc3RlZCB0ZW1wbGF0ZXMgaW4gdGhlIEtlbmRvQ2FsZW5kYXIgdGFnLlxuICAgICAqL1xuICAgIHNldCBkZWNhZGVDZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5fZGVjYWRlQ2VsbFRlbXBsYXRlUmVmID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBkZWNhZGVDZWxsVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNhZGVDZWxsVGVtcGxhdGVSZWYgfHwgdGhpcy5kZWNhZGVDZWxsVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIERlZmluZXMgdGhlIHRlbXBsYXRlIGZvciBlYWNoIGNlbnR1cnkgY2VsbC5cbiAgICAgKiBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgbmVzdGVkIHRlbXBsYXRlcyBpbiB0aGUgS2VuZG9DYWxlbmRhciB0YWcuXG4gICAgICovXG4gICAgc2V0IGNlbnR1cnlDZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5fY2VudHVyeUNlbGxUZW1wbGF0ZVJlZiA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICBnZXQgY2VudHVyeUNlbGxUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnR1cnlDZWxsVGVtcGxhdGVSZWYgfHwgdGhpcy5jZW50dXJ5Q2VsbFRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBEZWZpbmVzIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIHdlZWsgY2VsbC5cbiAgICAgKiBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgbmVzdGVkIHRlbXBsYXRlcyBpbiB0aGUgS2VuZG9DYWxlbmRhciB0YWcuXG4gICAgICovXG4gICAgc2V0IHdlZWtOdW1iZXJUZW1wbGF0ZVJlZih0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLl93ZWVrTnVtYmVyVGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0IHdlZWtOdW1iZXJUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtOdW1iZXJUZW1wbGF0ZVJlZiB8fCB0aGlzLndlZWtOdW1iZXJUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogRGVmaW5lcyB0aGUgdGVtcGxhdGUgZm9yIHRoZSBoZWFkZXIgdGl0bGUuXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5lc3RlZCB0ZW1wbGF0ZXMgaW4gdGhlIEtlbmRvQ2FsZW5kYXIgdGFnLlxuICAgICAqL1xuICAgIHNldCBoZWFkZXJUaXRsZVRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlclRpdGxlVGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0IGhlYWRlclRpdGxlVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJUaXRsZVRlbXBsYXRlUmVmIHx8IHRoaXMuaGVhZGVyVGl0bGVUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogRGVmaW5lcyB0aGUgdGVtcGxhdGUgZm9yIHRoZSBuYXZpZ2F0aW9uIGl0ZW0uXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5lc3RlZCB0ZW1wbGF0ZXMgaW4gdGhlIEtlbmRvQ2FsZW5kYXIgdGFnLlxuICAgICAqL1xuICAgIHNldCBuYXZpZ2F0aW9uSXRlbVRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25JdGVtVGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0IG5hdmlnYXRpb25JdGVtVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYXZpZ2F0aW9uSXRlbVRlbXBsYXRlUmVmIHx8IHRoaXMubmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZVZpZXdFbnVtKCkge1xuICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gQ2FsZW5kYXJWaWV3RW51bVt0aGlzLmFjdGl2ZVZpZXddO1xuICAgICAgICByZXR1cm4gYWN0aXZlVmlldyA8IHRoaXMuYm90dG9tVmlld0VudW0gPyB0aGlzLmJvdHRvbVZpZXdFbnVtIDogYWN0aXZlVmlldztcbiAgICB9XG4gICAgZ2V0IGJvdHRvbVZpZXdFbnVtKCkge1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJWaWV3RW51bVt0aGlzLmJvdHRvbVZpZXddO1xuICAgIH1cbiAgICBnZXQgdG9wVmlld0VudW0oKSB7XG4gICAgICAgIHJldHVybiBDYWxlbmRhclZpZXdFbnVtW3RoaXMudG9wVmlld107XG4gICAgfVxuICAgIGdldCB3aWRnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhclRhYkluZGV4KCkge1xuICAgICAgICAvLyBpbiBDbGFzc2ljIG1vZGUsIHRoZSBpbm5lciBNdWx0aVZpZXdDYWxlbmRhciBpcyB0aGUgZm9jdXNhYmxlIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgdGhpcy50eXBlID09PSAnY2xhc3NpYycgPyB1bmRlZmluZWQgOiB0aGlzLnRhYkluZGV4O1xuICAgIH1cbiAgICBnZXQgYXJpYURpc2FibGVkKCkge1xuICAgICAgICAvLyBpbiBDbGFzc2ljIG1vZGUsIHRoZSBpbm5lciBNdWx0aVZpZXdDYWxlbmRhciBzaG91bGQgaGFuZGxlIHRoZSBkaXNhYmxlZCBjbGFzcyBhbmQgYXJpYSBhdHRyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdjbGFzc2ljJyA/IHVuZGVmaW5lZCA6IHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmRvbS5jYWxjdWxhdGVIZWlnaHRzKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgdGhpcy5zY3JvbGxTeW5jU2VydmljZS5jb25maWd1cmUodGhpcy5hY3RpdmVWaWV3RW51bSk7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jZHIubWFya0ZvckNoZWNrKCkpO1xuICAgICAgICB0aGlzLnZpZXdDaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLmJ1cy52aWV3Q2hhbmdlZC5zdWJzY3JpYmUoKHsgdmlldyB9KSA9PiB0aGlzLmhhbmRsZUFjdGl2ZVZpZXdDaGFuZ2UoQ2FsZW5kYXJWaWV3RW51bVt2aWV3XSkpO1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSB0aGlzLmluamVjdG9yLmdldChOZ0NvbnRyb2wsIG51bGwpO1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Q2hhbmdlcygpO1xuICAgICAgICB0aGlzLmJ1cy5jb25maWd1cmUodGhpcy5ib3R0b21WaWV3RW51bSwgdGhpcy50b3BWaWV3RW51bSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3luY1NlcnZpY2UuY29uZmlndXJlKHRoaXMuYWN0aXZlVmlld0VudW0pO1xuICAgICAgICBpZiAoaGFzRXhpc3RpbmdWYWx1ZShjaGFuZ2VzLCAnZm9jdXNlZERhdGUnKSkge1xuICAgICAgICAgICAgY29uc3QgZm9jdXNlZERhdGUgPSBjaGFuZ2VzLmZvY3VzZWREYXRlLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZERhdGUgPSBkYXRlSW5SYW5nZShmb2N1c2VkRGF0ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5uYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmNOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5taW4gfHwgY2hhbmdlcy5tYXggfHwgY2hhbmdlcy5yYW5nZVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWluVmFsaWRhdGVGbiA9IHRoaXMucmFuZ2VWYWxpZGF0aW9uID8gbWluVmFsaWRhdG9yKHRoaXMubWluKSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLm1heFZhbGlkYXRlRm4gPSB0aGlzLnJhbmdlVmFsaWRhdGlvbiA/IG1heFZhbGlkYXRvcih0aGlzLm1heCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXRBcmlhQWN0aXZlZGVzY2VuZGFudCgpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zeW5jTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3luY05hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY3JvbGxTeW5jU2VydmljZS5zeW5jKHZpcnR1YWxpemF0aW9uUHJvcCh0aGlzLm5hdmlnYXRpb25WaWV3KSwgdmlydHVhbGl6YXRpb25Qcm9wKHRoaXMubW9udGhWaWV3KSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFN5bmNTZXJ2aWNlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb21FdmVudHMuZm9yRWFjaCh1bmJpbmRDYWxsYmFjayA9PiB1bmJpbmRDYWxsYmFjaygpKTtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLmNhbGVuZGFyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aWV3Q2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYWdlQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2VDaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNlZERhdGUgPSBuZXcgRGF0ZSh0aGlzLmZvY3VzZWREYXRlKTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBob3N0IGVsZW1lbnQgb2YgdGhlIENhbGVuZGFyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogdGVtcGxhdGU6IGBcbiAgICAgKiAgPGJ1dHRvbiAoY2xpY2spPVwiY2FsZW5kYXIuZm9jdXMoKVwiPkZvY3VzIGNhbGVuZGFyPC9idXR0b24+XG4gICAgICogIDxrZW5kby1jYWxlbmRhciAjY2FsZW5kYXI+PC9rZW5kby1jYWxlbmRhcj5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICBjb25zdCBmb2N1c1RhcmdldCA9IHRoaXMudHlwZSA9PT0gJ2luZmluaXRlJyA/XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgJiYgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgOlxuICAgICAgICAgICAgdGhpcy5tdWx0aVZpZXdDYWxlbmRhcjtcbiAgICAgICAgaWYgKGlzUHJlc2VudChmb2N1c1RhcmdldCkpIHtcbiAgICAgICAgICAgIGZvY3VzVGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIENhbGVuZGFyIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICBjb25zdCBibHVyVGFyZ2V0ID0gdGhpcy50eXBlID09PSAnaW5maW5pdGUnID9cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCAmJiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCA6XG4gICAgICAgICAgICB0aGlzLm11bHRpVmlld0NhbGVuZGFyO1xuICAgICAgICBpZiAoaXNQcmVzZW50KGJsdXJUYXJnZXQpKSB7XG4gICAgICAgICAgICBibHVyVGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29udGFpbnNFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oY2xvc2VzdChlbGVtZW50LCBub2RlID0+IG5vZGUgPT09IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVOYXZpZ2F0aW9uKGNhbmRpZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvY3VzVGFyZ2V0ID0gY2FuZGlkYXRlID8gbmV3IERhdGUoY2xvbmVEYXRlKGNhbmRpZGF0ZSkuc2V0RGF0ZSgxKSkgOiB0aGlzLmZvY3VzZWREYXRlO1xuICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gZGF0ZUluUmFuZ2UoZm9jdXNUYXJnZXQsIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25QYWdlQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIU5nWm9uZS5pc0luQW5ndWxhclpvbmUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFnZUNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYWdlQ2hhbmdlU3Vic2NyaXB0aW9uID0gZnJvbSh0aGlzLnJlc29sdmVkUHJvbWlzZSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGVjdENoYW5nZXMoKTsgLy8gcmVxdWlyZXMgem9uZSBpZiB0ZW1wbGF0ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVNdWx0aVZpZXdDYWxlbmRhclZhbHVlQ2hhbmdlKGRhdGUsIGZvY3VzZWREYXRlKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRGF0ZXMgPSBBcnJheS5pc0FycmF5KGRhdGUpID8gZGF0ZSA6IFtkYXRlXTtcbiAgICAgICAgdGhpcy5oYW5kbGVEYXRlQ2hhbmdlKHsgc2VsZWN0ZWREYXRlcywgZm9jdXNlZERhdGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVEYXRlQ2hhbmdlKGFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWREYXRlcyA9IEFycmF5LmlzQXJyYXkoYXJncy5zZWxlY3RlZERhdGVzKSA/IGFyZ3Muc2VsZWN0ZWREYXRlcyA6IFthcmdzLnNlbGVjdGVkRGF0ZXNdO1xuICAgICAgICBjb25zdCBjYW5OYXZpZ2F0ZURvd24gPSB0aGlzLmJ1cy5jYW5Nb3ZlRG93bih0aGlzLmFjdGl2ZVZpZXdFbnVtKTtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlRGF0ZXMgPSBzZWxlY3RlZERhdGVzLmZpbHRlcihkYXRlID0+ICF0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmlzRGF0ZURpc2FibGVkKGRhdGUpKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IGFyZ3MuZm9jdXNlZERhdGUgfHwgdGhpcy5mb2N1c2VkRGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbk5hdmlnYXRlRG93biAmJiBhcmVEYXRlc0VxdWFsKGF2YWlsYWJsZURhdGVzLCB0aGlzLnNlbGVjdGVkRGF0ZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRTYW1lRGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5OYXZpZ2F0ZURvd24pIHtcbiAgICAgICAgICAgIHRoaXMuYnVzLm1vdmVEb3duKHRoaXMuYWN0aXZlVmlld0VudW0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmlzRGF0ZURpc2FibGVkKHRoaXMuZm9jdXNlZERhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlcyA9IGF2YWlsYWJsZURhdGVzLm1hcChkYXRlID0+IGNsb25lRGF0ZShkYXRlKSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5wYXJzZVNlbGVjdGlvblRvVmFsdWUoYXZhaWxhYmxlRGF0ZXMpO1xuICAgICAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UodGhpcy5wYXJzZVNlbGVjdGlvblRvVmFsdWUoYXZhaWxhYmxlRGF0ZXMpKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnBhcnNlU2VsZWN0aW9uVG9WYWx1ZShhdmFpbGFibGVEYXRlcykpO1xuICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZShjYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZShjYW5kaWRhdGUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gY2FuZGlkYXRlO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHZhbGlkYXRlKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluVmFsaWRhdGVGbihjb250cm9sKSB8fCB0aGlzLm1heFZhbGlkYXRlRm4oY29udHJvbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGFjdGl2ZUNlbGxUZW1wbGF0ZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFjdGl2ZVZpZXdFbnVtKSB7XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0ubW9udGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9udGhDZWxsVGVtcGxhdGVSZWYgfHwgdGhpcy5jZWxsVGVtcGxhdGVSZWY7XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0ueWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55ZWFyQ2VsbFRlbXBsYXRlUmVmO1xuICAgICAgICAgICAgY2FzZSBDYWxlbmRhclZpZXdFbnVtLmRlY2FkZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNhZGVDZWxsVGVtcGxhdGVSZWY7XG4gICAgICAgICAgICBjYXNlIENhbGVuZGFyVmlld0VudW0uY2VudHVyeTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jZW50dXJ5Q2VsbFRlbXBsYXRlUmVmO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlTmF2aWdhdGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IGV2ZW50LmZvY3VzZWREYXRlO1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXcgPSBldmVudC5hY3RpdmVWaWV3O1xuICAgICAgICB0aGlzLmVtaXROYXZpZ2F0ZSh0aGlzLmZvY3VzZWREYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGVtaXROYXZpZ2F0ZShmb2N1c2VkRGF0ZSkge1xuICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gQ2FsZW5kYXJWaWV3RW51bVt0aGlzLmFjdGl2ZVZpZXdFbnVtXTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZS5lbWl0KHsgYWN0aXZlVmlldywgZm9jdXNlZERhdGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBlbWl0RXZlbnQoZW1pdHRlciwgYXJncykge1xuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKGVtaXR0ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVBY3RpdmVEYXRlQ2hhbmdlKGRhdGUpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3RGF0ZSA9IGRhdGU7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KHRoaXMuYWN0aXZlVmlld0RhdGVDaGFuZ2UsIGRhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQWN0aXZlVmlld0NoYW5nZSh2aWV3KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KHRoaXMuYWN0aXZlVmlld0NoYW5nZSwgdmlldyk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdpbmZpbml0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsU3luY1NlcnZpY2UuY29uZmlndXJlKHRoaXMuYWN0aXZlVmlld0VudW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpOyAvLyByZXF1aXJlcyB6b25lIGlmIHRlbXBsYXRlc1xuICAgIH1cbiAgICBoYW5kbGVDZWxsQ2xpY2soeyBkYXRlLCBtb2RpZmllcnMgfSkge1xuICAgICAgICB0aGlzLnBlcmZvcm1TZWxlY3Rpb24oZGF0ZSwgbW9kaWZpZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVdlZWtOdW1iZXJDbGljayhkYXRlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0ZUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlczogZGF0ZXMsXG4gICAgICAgICAgICAgICAgZm9jdXNlZERhdGU6IGxhc3QoZGF0ZXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVCbHVyKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKGFyZ3MucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8vIHRoZSBpbmplY3RvciBjYW4gZ2V0IHRoZSBOZ0NvbnRyb2wgaW5zdGFuY2Ugb2YgdGhlIHBhcmVudCBjb21wb25lbnQgKGZvciBleGFtcGxlLCB0aGUgRGF0ZVRpbWVQaWNrZXIpXG4gICAgICAgIC8vIGFuZCBlbnRlcnMgdGhlIHpvbmUgZm9yIG5vIHJlYXNvbiBiZWNhdXNlIHRoZSBwYXJlbnQgY29tcG9uZW50IGlzIHN0aWxsIHVudG91Y2hlZFxuICAgICAgICBpZiAoIXRoaXMucGlja2VyU2VydmljZSAmJiByZXF1aXJlc1pvbmVPbkJsdXIodGhpcy5jb250cm9sKSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29udHJvbFRvdWNoZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRCbHVyKGFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRCbHVyKGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUZvY3VzKCkge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFOZ1pvbmUuaXNJbkFuZ3VsYXJab25lKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdEZvY3VzKCk7XG4gICAgfVxuICAgIHNldENsYXNzZXMoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLXdpZGdldCcpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLWNhbGVuZGFyJyk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgYGstY2FsZW5kYXItJHt0aGlzLnR5cGV9YCk7XG4gICAgfVxuICAgIHZlcmlmeUNoYW5nZXMoKSB7XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW4gPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWF4IHZhbHVlIHNob3VsZCBiZSBiaWdnZXIgdGhhbiB0aGUgbWluLiBTZWUgJHtNSU5fRE9DX0xJTkskMX0gYW5kICR7TUFYX0RPQ19MSU5LJDF9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvdHRvbVZpZXdFbnVtID4gdGhpcy50b3BWaWV3RW51bSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdG9wVmlldyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIGJvdHRvbVZpZXcuIFNlZSAke0JPVFRPTV9WSUVXX0RPQ19MSU5LJDF9IGFuZCAke1RPUF9WSUVXX0RPQ19MSU5LJDF9LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeVZhbHVlKGNhbmRpZGF0ZSkge1xuICAgICAgICBpZiAoIWlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uID09PSAnc2luZ2xlJyAmJiBjYW5kaWRhdGUgJiYgIShjYW5kaWRhdGUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ3ZhbHVlJyBzaG91bGQgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IERhdGUgaW5zdGFuY2UuIENoZWNrICR7VkFMVUVfRE9DX0xJTkskMX0gZm9yIHBvc3NpYmxlIHJlc29sdXRpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb24gPT09ICdtdWx0aXBsZScgJiYgY2FuZGlkYXRlICYmIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgY29uc3Qgb25seURhdGVzID0gY2FuZGlkYXRlLmV2ZXJ5KHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSk7XG4gICAgICAgICAgICBpZiAoIW9ubHlEYXRlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICd2YWx1ZScgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHZhbGlkIEphdmFTY3JpcHQgRGF0ZSBpbnN0YW5jZXMuIENoZWNrICR7VkFMVUVfRE9DX0xJTkskMX0gZm9yIHBvc3NpYmxlIHJlc29sdXRpb24uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmluZEV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLmRvbUV2ZW50cy5wdXNoKHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdibHVyJywgdGhpcy5oYW5kbGVCbHVyLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnbW91c2Vkb3duJywgcHJldmVudERlZmF1bHQpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnY2xpY2snLCB0aGlzLmhhbmRsZUNvbXBvbmVudENsaWNrLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIGVtaXRCbHVyKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLm9uQmx1ci5lbWl0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRGb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLm9uRm9jdXMuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNvbXBvbmVudENsaWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdpbmZpbml0ZScgJiYgdGhpcy5tb250aFZpZXcuaXNTY3JvbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSA9IGNsb25lRGF0ZSh0aGlzLmZvY3VzZWREYXRlKTsgLy9YWFg6IGZvcmNlcyBjaGFuZ2UgZGV0ZWN0XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlS2V5ZG93bihhcmdzKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlckFjdGl2ZSA9IHRoaXMudHlwZSA9PT0gJ2NsYXNzaWMnICYmIHRoaXMubXVsdGlWaWV3Q2FsZW5kYXIuaXNIZWFkZXJBY3RpdmU7XG4gICAgICAgIGlmIChoZWFkZXJBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNlcnZlIHRoZSBhbHQgKyBhcnJvdyBrZXkgY29tbWFuZHMgZm9yIHRoZSBwaWNrZXJcbiAgICAgICAgY29uc3QgYXJyb3dLZXlQcmVzc2VkID0gW0tleXMuQXJyb3dVcCwgS2V5cy5BcnJvd1JpZ2h0LCBLZXlzLkFycm93RG93biwgS2V5cy5BcnJvd0xlZnRdLmluZGV4T2YoYXJncy5rZXlDb2RlKSAhPT0gLTE7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5waWNrZXJTZXJ2aWNlKSAmJiBhcnJvd0tleVByZXNzZWQgJiYgYXJncy5hbHRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBkYXRlSW5SYW5nZSh0aGlzLm5hdmlnYXRvci5tb3ZlKHRoaXMuZm9jdXNlZERhdGUsIHRoaXMubmF2aWdhdG9yLmFjdGlvbihhcmdzKSwgdGhpcy5hY3RpdmVWaWV3RW51bSksIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIGlmICghaXNFcXVhbCh0aGlzLmZvY3VzZWREYXRlLCBjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWREYXRlID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICBhcmdzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5FbnRlcikge1xuICAgICAgICAgICAgdGhpcy5wZXJmb3JtU2VsZWN0aW9uKHRoaXMuZm9jdXNlZERhdGUsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRldGVjdENoYW5nZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0U2FtZURhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyU2VydmljZS5zYW1lRGF0ZVNlbGVjdGVkLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBcmlhQWN0aXZlZGVzY2VuZGFudCgpIHtcbiAgICAgICAgLy8gaW4gQ2xhc3NpYyBtb2RlLCB0aGUgaW5uZXIgTXVsdGlWaWV3Q2FsZW5kYXIgaGFuZGxlcyB0aGUgYWN0aXZlZGVzY2VuZGFudFxuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLmVsZW1lbnQpIHx8ICh0aGlzLnR5cGUgPT09ICdjbGFzc2ljJyAmJiAhdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnY2xhc3NpYycpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9jdXNlZENlbGxJZCA9IHRoaXMuY2VsbFVJRCArIHRoaXMuZm9jdXNlZERhdGUuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIGZvY3VzZWRDZWxsSWQpO1xuICAgIH1cbiAgICBwYXJzZVNlbGVjdGlvblRvVmFsdWUoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbiB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uID09PSAnc2luZ2xlJyA/IGNsb25lRGF0ZShsYXN0KHNlbGVjdGlvbikpIDogc2VsZWN0aW9uLm1hcChkYXRlID0+IGNsb25lRGF0ZShkYXRlKSk7XG4gICAgfVxuICAgIHBlcmZvcm1TZWxlY3Rpb24oZGF0ZSwgc2VsZWN0aW9uTW9kaWZpZXJzKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uU2VydmljZS5wZXJmb3JtU2VsZWN0aW9uKHtcbiAgICAgICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgICAgICBtb2RpZmllcnM6IHNlbGVjdGlvbk1vZGlmaWVycyxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHRoaXMuc2VsZWN0aW9uLFxuICAgICAgICAgICAgYWN0aXZlVmlld0VudW06IHRoaXMuYWN0aXZlVmlld0VudW0sXG4gICAgICAgICAgICByYW5nZVBpdm90OiB0aGlzLnJhbmdlUGl2b3QsXG4gICAgICAgICAgICBzZWxlY3RlZERhdGVzOiB0aGlzLnNlbGVjdGVkRGF0ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmFuZ2VQaXZvdCA9IHNlbGVjdGlvbi5yYW5nZVBpdm90O1xuICAgICAgICB0aGlzLmhhbmRsZURhdGVDaGFuZ2Uoe1xuICAgICAgICAgICAgc2VsZWN0ZWREYXRlczogc2VsZWN0aW9uLnNlbGVjdGVkRGF0ZXMsXG4gICAgICAgICAgICBmb2N1c2VkRGF0ZTogZGF0ZVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvY3VzZWREYXRlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VWYWxpZGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZERhdGVzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImJvdHRvbVZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b3BWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0eXBlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRlTmF2aWdhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay13ZWVrLW51bWJlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlVmlld0NoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVWaWV3RGF0ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKENlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnY2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNlbGxUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtb250aENlbGxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ21vbnRoQ2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW01vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtb250aENlbGxUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwieWVhckNlbGxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ3llYXJDZWxsVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5ZWFyQ2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVjYWRlQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnZGVjYWRlQ2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImRlY2FkZUNlbGxUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VudHVyeUNlbGxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ2NlbnR1cnlDZWxsVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZW50dXJ5Q2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3ZWVrTnVtYmVyVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCd3ZWVrTnVtYmVyVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3ZWVrTnVtYmVyVGVtcGxhdGVSZWZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIZWFkZXJUaXRsZVRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhlYWRlclRpdGxlVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdoZWFkZXJUaXRsZVRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVhZGVyVGl0bGVUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChOYXZpZ2F0aW9uSXRlbVRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwibmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ25hdmlnYXRpb25JdGVtVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYXZpZ2F0aW9uSXRlbVRlbXBsYXRlRGlyZWN0aXZlXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0aW9uSXRlbVRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKE5hdmlnYXRpb25Db21wb25lbnQsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTmF2aWdhdGlvbkNvbXBvbmVudClcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0aW9uVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKFZpZXdMaXN0Q29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpZXdMaXN0Q29tcG9uZW50KVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1vbnRoVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50KVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm11bHRpVmlld0NhbGVuZGFyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5pZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWRnZXRJZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNhbGVuZGFyVGFiSW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLWRpc2FibGVkJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFyaWFEaXNhYmxlZFwiLCBudWxsKTtcbkNhbGVuZGFyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG8tY2FsZW5kYXInLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIEJ1c1ZpZXdTZXJ2aWNlLFxuICAgICAgICAgICAgQ0FMRU5EQVJfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICBDQUxFTkRBUl9SQU5HRV9WQUxJREFUT1JTLFxuICAgICAgICAgICAgS0VORE9fSU5QVVRfUFJPVklERVIsXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgRGlzYWJsZWREYXRlc1NlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5jYWxlbmRhcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgICAgIFNjcm9sbFN5bmNTZXJ2aWNlLFxuICAgICAgICAgICAgU2VsZWN0aW9uU2VydmljZVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNhbGVuZGFyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyIGtlbmRvQ2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICBpMThuLXRvZGF5PVwia2VuZG8uY2FsZW5kYXIudG9kYXl8VGhlIGxhYmVsIGZvciB0aGUgdG9kYXkgYnV0dG9uIGluIHRoZSBjYWxlbmRhciBoZWFkZXJcIlxuICAgICAgICB0b2RheT1cIlRvZGF5XCJcblxuICAgICAgICBpMThuLXByZXZCdXR0b25UaXRsZT1cImtlbmRvLmNhbGVuZGFyLnByZXZCdXR0b25UaXRsZXxUaGUgdGl0bGUgb2YgdGhlIHByZXZpb3VzIGJ1dHRvbiBpbiB0aGUgQ2xhc3NpYyBjYWxlbmRhclwiXG4gICAgICAgIHByZXZCdXR0b25UaXRsZT1cIk5hdmlnYXRlIHRvIHByZXZpb3VzIHZpZXdcIlxuXG4gICAgICAgIGkxOG4tbmV4dEJ1dHRvblRpdGxlPVwia2VuZG8uY2FsZW5kYXIubmV4dEJ1dHRvblRpdGxlfFRoZSB0aXRsZSBvZiB0aGUgbmV4dCBidXR0b24gaW4gdGhlIENsYXNzaWMgY2FsZW5kYXJcIlxuICAgICAgICBuZXh0QnV0dG9uVGl0bGU9XCJOYXZpZ2F0ZSB0byBuZXh0IHZpZXdcIlxuICAgID5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwidHlwZSA9PT0gJ2luZmluaXRlJ1wiPlxuICAgICAgICA8a2VuZG8tY2FsZW5kYXItbmF2aWdhdGlvblxuICAgICAgICAgICAgKm5nSWY9XCJuYXZpZ2F0aW9uXCJcbiAgICAgICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdFbnVtXCJcbiAgICAgICAgICAgIFtmb2N1c2VkRGF0ZV09XCJmb2N1c2VkRGF0ZVwiXG4gICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICBbdGVtcGxhdGVSZWZdPVwibmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZVJlZj8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZU5hdmlnYXRpb24oJGV2ZW50KVwiXG4gICAgICAgICAgICAocGFnZUNoYW5nZSk9XCJvblBhZ2VDaGFuZ2UoKVwiXG4gICAgICAgID5cbiAgICAgICAgPC9rZW5kby1jYWxlbmRhci1uYXZpZ2F0aW9uPlxuICAgICAgICA8a2VuZG8tY2FsZW5kYXItdmlld2xpc3RcbiAgICAgICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdFbnVtXCJcbiAgICAgICAgICAgIFtpc0FjdGl2ZV09XCJpc0FjdGl2ZVwiXG4gICAgICAgICAgICBbY2VsbFRlbXBsYXRlUmVmXT1cImFjdGl2ZUNlbGxUZW1wbGF0ZSgpPy50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICBbaGVhZGVyVGl0bGVUZW1wbGF0ZVJlZl09XCJoZWFkZXJUaXRsZVRlbXBsYXRlUmVmPy50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICBbd2Vla051bWJlclRlbXBsYXRlUmVmXT1cIndlZWtOdW1iZXJUZW1wbGF0ZVJlZj8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW2NlbGxVSURdPVwiY2VsbFVJRFwiXG4gICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICBbZm9jdXNlZERhdGVdPVwiZm9jdXNlZERhdGVcIlxuICAgICAgICAgICAgW3dlZWtOdW1iZXJdPVwid2Vla051bWJlclwiXG4gICAgICAgICAgICBbc2VsZWN0ZWREYXRlc109XCJzZWxlY3RlZERhdGVzXCJcbiAgICAgICAgICAgICh0b2RheUJ1dHRvbkNsaWNrKT1cImhhbmRsZURhdGVDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0ZXM6IFskZXZlbnRdLFxuICAgICAgICAgICAgICAgIGZvY3VzZWREYXRlOiAkZXZlbnRcbiAgICAgICAgICAgIH0pXCJcbiAgICAgICAgICAgIChjZWxsQ2xpY2spPVwiaGFuZGxlQ2VsbENsaWNrKCRldmVudClcIlxuICAgICAgICAgICAgKHdlZWtOdW1iZXJDZWxsQ2xpY2spPVwiaGFuZGxlV2Vla051bWJlckNsaWNrKCRldmVudClcIlxuICAgICAgICAgICAgKGFjdGl2ZURhdGVDaGFuZ2UpPVwiaGFuZGxlQWN0aXZlRGF0ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgIChwYWdlQ2hhbmdlKT1cIm9uUGFnZUNoYW5nZSgpXCJcbiAgICAgICAgPlxuICAgICAgICA8L2tlbmRvLWNhbGVuZGFyLXZpZXdsaXN0PlxuICAgICAgICA8a2VuZG8tcmVzaXplLXNlbnNvciAocmVzaXplKT1cIm9uUmVzaXplKClcIj48L2tlbmRvLXJlc2l6ZS1zZW5zb3I+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInR5cGUgPT09ICdjbGFzc2ljJ1wiPlxuICAgICAgICA8a2VuZG8tbXVsdGl2aWV3Y2FsZW5kYXJcbiAgICAgICAgICAgICNtdWx0aXZpZXdjYWxlbmRhclxuICAgICAgICAgICAgW3ZpZXdzXT1cIjFcIlxuICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgW2lzQWN0aXZlXT1cImlzQWN0aXZlXCJcbiAgICAgICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdcIlxuICAgICAgICAgICAgW2JvdHRvbVZpZXddPVwiYm90dG9tVmlld1wiXG4gICAgICAgICAgICBbdG9wVmlld109XCJ0b3BWaWV3XCJcbiAgICAgICAgICAgIFt3ZWVrTnVtYmVyXT1cIndlZWtOdW1iZXJcIlxuICAgICAgICAgICAgW2FuaW1hdGVOYXZpZ2F0aW9uXT1cImFuaW1hdGVOYXZpZ2F0aW9uXCJcbiAgICAgICAgICAgIFtjZWxsVGVtcGxhdGVdPVwiYWN0aXZlQ2VsbFRlbXBsYXRlKClcIlxuICAgICAgICAgICAgW21vbnRoQ2VsbFRlbXBsYXRlXT1cIm1vbnRoQ2VsbFRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgIFt5ZWFyQ2VsbFRlbXBsYXRlXT1cInllYXJDZWxsVGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW2RlY2FkZUNlbGxUZW1wbGF0ZV09XCJkZWNhZGVDZWxsVGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW2NlbnR1cnlDZWxsVGVtcGxhdGVdPVwiY2VudHVyeUNlbGxUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICBbaGVhZGVyVGl0bGVUZW1wbGF0ZV09XCJoZWFkZXJUaXRsZVRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgIFt3ZWVrTnVtYmVyVGVtcGxhdGVdPVwid2Vla051bWJlclRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgIFtmb2N1c2VkRGF0ZV09XCJmb2N1c2VkRGF0ZVwiXG4gICAgICAgICAgICBbc2VsZWN0aW9uXT1cInNlbGVjdGlvblwiXG4gICAgICAgICAgICBbdmFsdWVdPVwidmFsdWVcIlxuICAgICAgICAgICAgW2Rpc2FibGVkRGF0ZXNdPVwiZGlzYWJsZWREYXRlc1wiXG4gICAgICAgICAgICAoYWN0aXZlVmlld0NoYW5nZSk9XCJoYW5kbGVBY3RpdmVWaWV3Q2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgKG5hdmlnYXRlKT1cImhhbmRsZU5hdmlnYXRlKCRldmVudClcIlxuICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZU11bHRpVmlld0NhbGVuZGFyVmFsdWVDaGFuZ2UoJGV2ZW50LCBtdWx0aXZpZXdjYWxlbmRhci5mb2N1c2VkRGF0ZSlcIlxuICAgICAgICAgICAgKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIlxuICAgICAgICAgICAgKGJsdXIpPVwiaGFuZGxlQmx1cigkZXZlbnQpXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGtlbmRvLW11bHRpdmlld2NhbGVuZGFyLW1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgW3RvZGF5XT1cImxvY2FsaXphdGlvbi5nZXQoJ3RvZGF5JylcIlxuICAgICAgICAgICAgICAgIFtwcmV2QnV0dG9uVGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgncHJldkJ1dHRvblRpdGxlJylcIlxuICAgICAgICAgICAgICAgIFtuZXh0QnV0dG9uVGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgnbmV4dEJ1dHRvblRpdGxlJylcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9rZW5kby1tdWx0aXZpZXdjYWxlbmRhci1tZXNzYWdlcz5cbiAgICAgICAgPC9rZW5kby1tdWx0aXZpZXdjYWxlbmRhcj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oMTIsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQnVzVmlld1NlcnZpY2UsXG4gICAgICAgIENhbGVuZGFyRE9NU2VydmljZSxcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgSW5qZWN0b3IsXG4gICAgICAgIFNjcm9sbFN5bmNTZXJ2aWNlLFxuICAgICAgICBEaXNhYmxlZERhdGVzU2VydmljZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgU2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgUGlja2VyU2VydmljZV0pXG5dLCBDYWxlbmRhckNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpbmNvbXBsZXRlRGF0ZVZhbGlkYXRvciA9ICgpID0+IHtcbiAgICByZXR1cm4gKGNvbnRyb2wsIGluY29tcGxldGUpID0+IHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoY29udHJvbC52YWx1ZSkgJiYgaW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5jb21wbGV0ZURhdGU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgQXJyb3c7XG4oZnVuY3Rpb24gKEFycm93KSB7XG4gICAgQXJyb3dbQXJyb3dbXCJVcFwiXSA9IDBdID0gXCJVcFwiO1xuICAgIEFycm93W0Fycm93W1wiRG93blwiXSA9IDFdID0gXCJEb3duXCI7XG4gICAgQXJyb3dbQXJyb3dbXCJOb25lXCJdID0gMl0gPSBcIk5vbmVcIjtcbn0pKEFycm93IHx8IChBcnJvdyA9IHt9KSk7XG5cbnZhciBEYXRlSW5wdXRDb21wb25lbnRfMTtcbmNvbnN0IE1JTl9ET0NfTElOSyQyID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvYXBpL0RhdGVJbnB1dENvbXBvbmVudC8jdG9jLW1pbic7XG5jb25zdCBNQVhfRE9DX0xJTkskMiA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2FwaS9EYXRlSW5wdXRDb21wb25lbnQvI3RvYy1tYXgnO1xuY29uc3QgVkFMVUVfRE9DX0xJTkskMiA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL2RhdGVpbnB1dC8jdG9jLXVzaW5nLXdpdGgtanNvbic7XG5jb25zdCBEQVRFX1BBUlRfUkVHRVhQID0gL3llYXJ8bW9udGh8PGRheT4vO1xuY29uc3QgVElNRV9QQVJUX1JFR0VYUCA9IC9ob3VyfG1pbnV0ZXxzZWNvbmR8bWlsbGlzZWNvbmQvO1xuY29uc3QgU0hPUlRfUEFUVEVSTl9MRU5HVEhfUkVHRVhQID0gL2R8TXxIfGh8bXxzLztcbmNvbnN0IFRXT19ESUdJVF9ZRUFSX01BWCA9IDY4O1xuY29uc3QgUFJFVklPVVNfQ0VOVFVSWV9CQVNFID0gMTkwMDtcbmNvbnN0IENVUlJFTlRfQ0VOVFVSWV9CQVNFID0gMjAwMDtcbmNvbnN0IERFRkFVTFRfRk9STUFUID0gJ2QnO1xuY29uc3QgcGFkWmVybyA9IChsZW5ndGgpID0+IG5ldyBBcnJheShNYXRoLm1heChsZW5ndGgsIDApKS5maWxsKCcwJykuam9pbignJyk7XG5jb25zdCB1bnBhZFplcm8gPSAodmFsdWUpID0+IHZhbHVlLnJlcGxhY2UoL14wKi8sICcnKTtcbmNsYXNzIE1hc2sge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN5bWJvbHMgPSBcIlwiO1xuICAgIH1cbn1cbmNsYXNzIEtlbmRvRGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaW50bCwgZm9ybWF0UGxhY2Vob2xkZXIsIGZvcm1hdCwgdmFsdWUsIHR3b0RpZ2l0WWVhck1heCA9IFRXT19ESUdJVF9ZRUFSX01BWCkge1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLmZvcm1hdFBsYWNlaG9sZGVyID0gZm9ybWF0UGxhY2Vob2xkZXI7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB0aGlzLnR3b0RpZ2l0WWVhck1heCA9IHR3b0RpZ2l0WWVhck1heDtcbiAgICAgICAgdGhpcy55ZWFyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tb250aCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaG91cnMgPSB0cnVlO1xuICAgICAgICB0aGlzLm1pbnV0ZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlY29uZHMgPSB0cnVlO1xuICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcyA9IHRydWU7XG4gICAgICAgIHRoaXMubGVhZGluZ1plcm8gPSBudWxsO1xuICAgICAgICB0aGlzLm1vbnRoTmFtZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnR5cGVkTW9udGhQYXJ0ID0gXCJcIjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGdldERhdGUobmV3IERhdGUoKSk7XG4gICAgICAgIHRoaXMua25vd25QYXJ0cyA9IFwiYWRIaG1Nc1NFeVwiO1xuICAgICAgICB0aGlzLnN5bWJvbHMgPSB7XG4gICAgICAgICAgICBcIkVcIjogXCJFXCIsXG4gICAgICAgICAgICBcIkhcIjogXCJIXCIsXG4gICAgICAgICAgICBcIk1cIjogXCJNXCIsXG4gICAgICAgICAgICBcImFcIjogXCJhXCIsXG4gICAgICAgICAgICBcImRcIjogXCJkXCIsXG4gICAgICAgICAgICBcImhcIjogXCJoXCIsXG4gICAgICAgICAgICBcIm1cIjogXCJtXCIsXG4gICAgICAgICAgICBcInNcIjogXCJzXCIsXG4gICAgICAgICAgICBcIlNcIjogXCJTXCIsXG4gICAgICAgICAgICBcInlcIjogXCJ5XCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgICAgIHRoaXMubW9udGhOYW1lcyA9IHRoaXMuYWxsRm9ybWF0ZWRNb250aHMoKTtcbiAgICAgICAgdGhpcy5kYXlQZXJpb2RzID0gdGhpcy5hbGxEYXlQZXJpb2RzKCk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBnZXREYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlRm9ybWF0ID0gdGhpcy5kYXRlRm9ybWF0U3RyaW5nKHRoaXMudmFsdWUsIHRoaXMuZm9ybWF0KS5zeW1ib2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVGb3JtYXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEV4aXN0aW5nKHNhbXBsZUZvcm1hdFtpXSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHByZWQgPSAoYSwgcCkgPT4gYSB8fCBwLnR5cGUgIT09ICdsaXRlcmFsJyAmJiBwLnR5cGUgIT09ICdkYXlwZXJpb2QnICYmIHRoaXMuZ2V0RXhpc3RpbmcocC5wYXR0ZXJuWzBdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50bC5zcGxpdERhdGVGb3JtYXQodGhpcy5mb3JtYXQpLnJlZHVjZShwcmVkLCBmYWxzZSk7XG4gICAgfVxuICAgIHNob3VsZE5vcm1hbGl6ZUNlbnR1cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGwuc3BsaXREYXRlRm9ybWF0KHRoaXMuZm9ybWF0KS5zb21lKHBhcnQgPT4gcGFydC5wYXR0ZXJuID09PSAneXknKTtcbiAgICB9XG4gICAgZ2V0RGF0ZU9iamVjdCgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmtub3duUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRFeGlzdGluZyh0aGlzLmtub3duUGFydHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lRGF0ZSh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgZ2V0VGV4dEFuZEZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2UodGhpcy5pbnRsLmZvcm1hdERhdGUodGhpcy52YWx1ZSwgZm9ybWF0KSwgdGhpcy5kYXRlRm9ybWF0U3RyaW5nKHRoaXMudmFsdWUsIGZvcm1hdCkpO1xuICAgIH1cbiAgICBnZXRFeGlzdGluZyhzeW1ib2wpIHtcbiAgICAgICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ5XCI6IHJldHVybiB0aGlzLnllYXI7XG4gICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgY2FzZSBcIkxcIjogcmV0dXJuIHRoaXMubW9udGg7XG4gICAgICAgICAgICBjYXNlIFwiZFwiOiByZXR1cm4gdGhpcy5kYXRlO1xuICAgICAgICAgICAgY2FzZSBcIkVcIjogcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLm1vbnRoICYmIHRoaXMueWVhcjtcbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICBjYXNlIFwiSFwiOiByZXR1cm4gdGhpcy5ob3VycztcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6IHJldHVybiB0aGlzLm1pbnV0ZXM7XG4gICAgICAgICAgICBjYXNlIFwic1wiOiByZXR1cm4gdGhpcy5zZWNvbmRzO1xuICAgICAgICAgICAgY2FzZSBcIlNcIjogcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RXhpc3Rpbmcoc3ltYm9sLCB2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnllYXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuc2V0RnVsbFllYXIoMjAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrOyAvL2FsbG93IDIvMjkgZGF0ZXNcbiAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5tb250aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5zZXRNb250aCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vbWFrZSBzdXJlIHlvdSBjYW4gdHlwZSAzMSBhdCBkYXkgcGFydFxuICAgICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuaG91cnMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vZGlmeVBhcnQoc3ltYm9sLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gY2xvbmVEYXRlKHRoaXMudmFsdWUpO1xuICAgICAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZS5zZXRGdWxsWWVhcihuZXdWYWx1ZS5nZXRGdWxsWWVhcigpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBhZGRNb250aHModGhpcy52YWx1ZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlLnNldERhdGUobmV3VmFsdWUuZ2V0RGF0ZSgpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlLnNldEhvdXJzKG5ld1ZhbHVlLmdldEhvdXJzKCkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZS5zZXRNaW51dGVzKG5ld1ZhbHVlLmdldE1pbnV0ZXMoKSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlLnNldFNlY29uZHMobmV3VmFsdWUuZ2V0U2Vjb25kcygpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUuc2V0TWlsbGlzZWNvbmRzKG5ld1ZhbHVlLmdldE1pbGxpc2Vjb25kcygpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUuc2V0SG91cnMobmV3VmFsdWUuZ2V0SG91cnMoKSArICgxMiAqIG9mZnNldCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkTm9ybWFsaXplQ2VudHVyeSgpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMubm9ybWFsaXplQ2VudHVyeShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1ZhbHVlLmdldEZ1bGxZZWFyKCkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEV4aXN0aW5nKHN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VQYXJ0KHN5bWJvbCwgY3VycmVudENoYXIsIHJlc2V0U2VnbWVudFZhbHVlKSB7XG4gICAgICAgIGlmICghY3VycmVudENoYXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRMZWFkaW5nWmVybygpO1xuICAgICAgICAgICAgdGhpcy5zZXRFeGlzdGluZyhzeW1ib2wsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBudWxsLCBzd2l0Y2hUb05leHQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJhc2VEYXRlID0gdGhpcy5pbnRsLmZvcm1hdERhdGUodGhpcy52YWx1ZSwgdGhpcy5mb3JtYXQpO1xuICAgICAgICBsZXQgZGF0ZVBhcnRzID0gdGhpcy5kYXRlRm9ybWF0U3RyaW5nKHRoaXMudmFsdWUsIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgbGV0IGJhc2VGb3JtYXQgPSBkYXRlUGFydHMuc3ltYm9scztcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGxldCBwcmVmaXggPSBcIlwiO1xuICAgICAgICBsZXQgY3VycmVudCA9IFwiXCI7XG4gICAgICAgIGxldCBzdWZmaXggPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2VEYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYmFzZUZvcm1hdFtpXSA9PT0gc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCArPSB0aGlzLmdldEV4aXN0aW5nKHN5bWJvbCkgPyBiYXNlRGF0ZVtpXSA6IFwiMFwiO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFyZXBsYWNlZCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCArPSBiYXNlRGF0ZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1ZmZpeCArPSBiYXNlRGF0ZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudE1heExlbmd0aCA9IGN1cnJlbnQubGVuZ3RoIC0gMztcbiAgICAgICAgbGV0IHBhcnNlZERhdGUgPSBudWxsO1xuICAgICAgICBjb25zdCBtb250aCA9IHRoaXMubWF0Y2hNb250aChjdXJyZW50Q2hhcik7XG4gICAgICAgIGNvbnN0IGRheVBlcmlvZCA9IHRoaXMubWF0Y2hEYXlQZXJpb2QoY3VycmVudENoYXIsIHN5bWJvbCk7XG4gICAgICAgIGNvbnN0IGlzWmVyb0N1cnJlbnRDaGFyID0gY3VycmVudENoYXIgPT09ICcwJztcbiAgICAgICAgY29uc3QgbGVhZGluZ1plcm8gPSAodGhpcy5sZWFkaW5nWmVybyB8fCB7fSlbc3ltYm9sXSB8fCAwO1xuICAgICAgICBpZiAoaXNaZXJvQ3VycmVudENoYXIpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZU51bWJlciA9IHBhcnNlSW50KHJlc2V0U2VnbWVudFZhbHVlID8gY3VycmVudENoYXIgOiBjdXJyZW50ICsgY3VycmVudENoYXIsIDEwKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZU51bWJlciA9PT0gMCAmJiAhdGhpcy5pc0FiYnJNb250aChkYXRlUGFydHMucGFydE1hcCwgc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50TGVhZGluZ1plcm8oc3ltYm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRMZWFkaW5nWmVybygpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBjdXJyZW50TWF4TGVuZ3RoKTsgaSA8PSBjdXJyZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWlkZGxlID0gcmVzZXRTZWdtZW50VmFsdWUgPyBjdXJyZW50Q2hhciA6IChjdXJyZW50LnN1YnN0cmluZyhpKSArIGN1cnJlbnRDaGFyKTtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IFwiU1wiICYmIHJlc2V0U2VnbWVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIFwiU1wiIHBhcnNlciBpbiBpbnRsIHBhcnNlcyBcIjFcIiBhcyAxMDBtcyBpbiBvcmRlciB0byBoYW5kbGUgSVNPU3RyaW5nIGRhdGVzIGNvcnJlY3RseSwgc28gdG8gZ2V0IDFtcywgd2UgbmVlZCB0byBwYXNzIFwiMDAxXCJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gbXNQYWRkaW5nRnJvbUZvcm1hdChiYXNlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICBtaWRkbGUgPSBwYWRkaW5nICsgbWlkZGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1pZGRsZU51bWJlciA9IHBhcnNlSW50KG1pZGRsZSwgMTApO1xuICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IHRoaXMuaW50bC5wYXJzZURhdGUocHJlZml4ICsgbWlkZGxlICsgc3VmZml4LCB0aGlzLmZvcm1hdCk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZERhdGUgJiYgIWlzTmFOKG1pZGRsZU51bWJlcikgJiYgIWlzTmFOKHBhcnNlSW50KGN1cnJlbnRDaGFyLCAxMCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gJ00nICYmICFtb250aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb250aE51bWJlciA9IG1pZGRsZU51bWJlciAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb250aE51bWJlciA+IC0xICYmIG1vbnRoTnVtYmVyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBjbG9uZURhdGUodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlLnNldE1vbnRoKG1vbnRoTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWREYXRlLmdldE1vbnRoKCkgIT09IG1vbnRoTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IGxhc3REYXlPZk1vbnRoKGFkZE1vbnRocyhwYXJzZWREYXRlLCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzeW1ib2wgPT09ICd5Jykge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gY3JlYXRlRGF0ZShwYXJzZUludChtaWRkbGUsIDEwKSwgdGhpcy5tb250aCA/IHRoaXMudmFsdWUuZ2V0TW9udGgoKSA6IDAsIHRoaXMuZGF0ZSA/IHRoaXMudmFsdWUuZ2V0RGF0ZSgpIDogMSwgdGhpcy5ob3VycyA/IHRoaXMudmFsdWUuZ2V0SG91cnMoKSA6IDAsIHRoaXMubWludXRlcyA/IHRoaXMudmFsdWUuZ2V0TWludXRlcygpIDogMCwgdGhpcy5zZWNvbmRzID8gdGhpcy52YWx1ZS5nZXRTZWNvbmRzKCkgOiAwLCB0aGlzLm1pbGxpc2Vjb25kcyA/IHRoaXMudmFsdWUuZ2V0TWlsbGlzZWNvbmRzKCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0ZSAmJiBwYXJzZWREYXRlLmdldERhdGUoKSAhPT0gdGhpcy52YWx1ZS5nZXREYXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBsYXN0RGF5T2ZNb250aChhZGRNb250aHMocGFyc2VkRGF0ZSwgLTEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgLy9tb3ZlIHRvIG5leHQgc2VnbWVudCBpZiB0aGUgcGFydCB3aWxsIG92ZXJmbG93IHdpdGggbmV4dCBjaGFyXG4gICAgICAgICAgICAgICAgLy93aGVuIHN0YXJ0IGZyb20gZW1wdHkgZGF0ZSAoMDEsIHRoZW4gMDEwKSwgcGFkZGVkIHplcm9zIHNob3VsZCBiZSB0cmltbWVkXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVyblZhbHVlID0gdGhpcy5wYXJ0UGF0dGVybihkYXRlUGFydHMucGFydE1hcCwgc3ltYm9sKS5wYXR0ZXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlZWtEYXRlID0gdGhpcy5pbnRsLnBhcnNlRGF0ZShgJHtwcmVmaXh9JHt0aGlzLnBlZWsobWlkZGxlLCBwYXR0ZXJuVmFsdWUpfSR7c3VmZml4fWAsIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuTGVuZ3RoID0gdGhpcy5wYXR0ZXJuTGVuZ3RoKHBhdHRlcm5WYWx1ZSkgfHwgcGF0dGVyblZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuU2F0aXNmaWVkID0gKGxlYWRpbmdaZXJvICsgKHVucGFkWmVybyhtaWRkbGUpIHx8IGN1cnJlbnRDaGFyKS5sZW5ndGgpID49IHBhdHRlcm5MZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3dpdGNoVG9OZXh0ID0gcGVla0RhdGUgPT09IG51bGwgfHwgcGF0dGVyblNhdGlzZmllZDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGROb3JtYWxpemVDZW50dXJ5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IHRoaXMubm9ybWFsaXplQ2VudHVyeShwYXJzZWREYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlZERhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFeGlzdGluZyhzeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLnZhbHVlLCBzd2l0Y2hUb05leHQ6IHN3aXRjaFRvTmV4dCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb250aCkge1xuICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IHRoaXMuaW50bC5wYXJzZURhdGUocHJlZml4ICsgbW9udGggKyBzdWZmaXgsIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlZERhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFeGlzdGluZyhzeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLnZhbHVlLCBzd2l0Y2hUb05leHQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheVBlcmlvZCkge1xuICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IHRoaXMuaW50bC5wYXJzZURhdGUocHJlZml4ICsgZGF5UGVyaW9kICsgc3VmZml4LCB0aGlzLmZvcm1hdCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkRGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZWREYXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLnZhbHVlLCBzd2l0Y2hUb05leHQ6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNaZXJvQ3VycmVudENoYXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXhpc3Rpbmcoc3ltYm9sLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG51bGwsIHN3aXRjaFRvTmV4dDogZmFsc2UgfTtcbiAgICB9XG4gICAgcmVzZXRMZWFkaW5nWmVybygpIHtcbiAgICAgICAgY29uc3QgaGFzTGVhZGluZ1plcm8gPSB0aGlzLmxlYWRpbmdaZXJvICE9PSBudWxsO1xuICAgICAgICB0aGlzLnNldExlYWRpbmdaZXJvKG51bGwpO1xuICAgICAgICByZXR1cm4gaGFzTGVhZGluZ1plcm87XG4gICAgfVxuICAgIHNldExlYWRpbmdaZXJvKGxlYWRpbmdaZXJvKSB7XG4gICAgICAgIHRoaXMubGVhZGluZ1plcm8gPSBsZWFkaW5nWmVybztcbiAgICB9XG4gICAgbm9ybWFsaXplQ2VudHVyeShkYXRlKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KGRhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0d29EaWdpdFllYXIgPSBjcm9wVHdvRGlnaXRZZWFyKGRhdGUpO1xuICAgICAgICBjb25zdCBjZW50dXJ5QmFzZSA9IHRoaXMuZ2V0Tm9ybWFsaXplZENlbnR1cnlCYXNlKHR3b0RpZ2l0WWVhcik7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREYXRlID0gc2V0WWVhcnMoZGF0ZSwgY2VudHVyeUJhc2UgKyB0d29EaWdpdFllYXIpO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplZERhdGU7XG4gICAgfVxuICAgIGluY3JlbWVudExlYWRpbmdaZXJvKHN5bWJvbCkge1xuICAgICAgICBjb25zdCBsZWFkaW5nWmVybyA9IHRoaXMubGVhZGluZ1plcm8gfHwge307XG4gICAgICAgIGxlYWRpbmdaZXJvW3N5bWJvbF0gPSAobGVhZGluZ1plcm9bc3ltYm9sXSB8fCAwKSArIDE7XG4gICAgICAgIHRoaXMubGVhZGluZ1plcm8gPSBsZWFkaW5nWmVybztcbiAgICB9XG4gICAgaXNBYmJyTW9udGgocGFydHMsIHN5bWJvbCkge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5wYXJ0UGF0dGVybihwYXJ0cywgc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udHlwZSA9PT0gJ21vbnRoJyAmJiBwYXR0ZXJuLm5hbWVzO1xuICAgIH1cbiAgICBwYXJ0UGF0dGVybihwYXJ0cywgc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHBhcnQucGF0dGVybi5pbmRleE9mKHN5bWJvbCkgIT09IC0xKVswXTtcbiAgICB9XG4gICAgcGVlayh2YWx1ZSwgcGF0dGVybikge1xuICAgICAgICBjb25zdCBwZWVrVmFsdWUgPSB1bnBhZFplcm8odmFsdWUpICsgJzAnO1xuICAgICAgICByZXR1cm4gcGFkWmVybyhwYXR0ZXJuLmxlbmd0aCAtIHBlZWtWYWx1ZS5sZW5ndGgpICsgcGVla1ZhbHVlO1xuICAgIH1cbiAgICBtYXRjaE1vbnRoKHR5cGVkQ2hhcikge1xuICAgICAgICB0aGlzLnR5cGVkTW9udGhQYXJ0ICs9IHR5cGVkQ2hhci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMubW9udGhOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMudHlwZWRNb250aFBhcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1vbnRoTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb250aE5hbWVzW2ldLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLnR5cGVkTW9udGhQYXJ0KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb250aE5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vbnRoQXNOdW0gPSBwYXJzZUludCh0aGlzLnR5cGVkTW9udGhQYXJ0LCAxMCk7XG4gICAgICAgICAgICBpZiAobW9udGhBc051bSA+PSAxICYmIG1vbnRoQXNOdW0gPD0gMTIgJiYgbW9udGhBc051bS50b1N0cmluZygpID09PSB0aGlzLnR5cGVkTW9udGhQYXJ0IC8qZW5zdXJlIHRoZXkgZXhhY3QgbWF0Y2gqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vbnRoTmFtZXNbbW9udGhBc051bSAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50eXBlZE1vbnRoUGFydCA9IHRoaXMudHlwZWRNb250aFBhcnQuc3Vic3RyaW5nKDEsIHRoaXMudHlwZWRNb250aFBhcnQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgbWF0Y2hEYXlQZXJpb2QodHlwZWRDaGFyLCBzeW1ib2wpIHtcbiAgICAgICAgY29uc3QgbG93ZXJDaGFydCA9IFN0cmluZyh0eXBlZENoYXIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzeW1ib2wgPT09ICdhJyAmJiB0aGlzLmRheVBlcmlvZHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRheVBlcmlvZHMuYW0udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGxvd2VyQ2hhcnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5UGVyaW9kcy5hbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGF5UGVyaW9kcy5wbS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgobG93ZXJDaGFydCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXlQZXJpb2RzLnBtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgYWxsRm9ybWF0ZWRNb250aHMoKSB7XG4gICAgICAgIGNvbnN0IGRhdGVGb3JtYXRQYXJ0cyA9IHRoaXMuaW50bC5zcGxpdERhdGVGb3JtYXQodGhpcy5mb3JtYXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVGb3JtYXRQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXRQYXJ0c1tpXS50eXBlID09PSBcIm1vbnRoXCIgJiYgZGF0ZUZvcm1hdFBhcnRzW2ldLm5hbWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50bC5kYXRlRm9ybWF0TmFtZXMoZGF0ZUZvcm1hdFBhcnRzW2ldLm5hbWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWxsRGF5UGVyaW9kcygpIHtcbiAgICAgICAgY29uc3QgZGF0ZUZvcm1hdFBhcnRzID0gdGhpcy5pbnRsLnNwbGl0RGF0ZUZvcm1hdCh0aGlzLmZvcm1hdCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZUZvcm1hdFBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdFBhcnRzW2ldLnR5cGUgPT09IFwiZGF5cGVyaW9kXCIgJiYgZGF0ZUZvcm1hdFBhcnRzW2ldLm5hbWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50bC5kYXRlRm9ybWF0TmFtZXMoZGF0ZUZvcm1hdFBhcnRzW2ldLm5hbWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGF0dGVybkxlbmd0aChwYXR0ZXJuKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuWzBdID09PSAneScpIHtcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChTSE9SVF9QQVRURVJOX0xFTkdUSF9SRUdFWFAudGVzdChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vVE9ETzogUkVNT1ZFIVxuICAgIGRhdGVGb3JtYXRTdHJpbmcoZGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IGRhdGVGb3JtYXRQYXJ0cyA9IHRoaXMuaW50bC5zcGxpdERhdGVGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgY29uc3QgcGFydE1hcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVGb3JtYXRQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcnRMZW5ndGggPSB0aGlzLmludGwuZm9ybWF0RGF0ZShkYXRlLCB7IHBhdHRlcm46IGRhdGVGb3JtYXRQYXJ0c1tpXS5wYXR0ZXJuIH0pLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChwYXJ0TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5zeW1ib2xzW2RhdGVGb3JtYXRQYXJ0c1tpXS5wYXR0ZXJuWzBdXSB8fCBcIl9cIik7XG4gICAgICAgICAgICAgICAgcGFydE1hcC5wdXNoKGRhdGVGb3JtYXRQYXJ0c1tpXSk7XG4gICAgICAgICAgICAgICAgcGFydExlbmd0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gbmV3IE1hc2soKTtcbiAgICAgICAgcmV0dXJuVmFsdWUuc3ltYm9scyA9IHBhcnRzLmpvaW4oXCJcIik7XG4gICAgICAgIHJldHVyblZhbHVlLnBhcnRNYXAgPSBwYXJ0TWFwO1xuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIG1lcmdlKHRleHQsIG1hc2spIHtcbiAgICAgICAgLy8gSW1wb3J0YW50OiByaWdodCB0byBsZWZ0LlxuICAgICAgICBsZXQgcmVzdWx0VGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCByZXN1bHRGb3JtYXQgPSBcIlwiO1xuICAgICAgICBsZXQgZm9ybWF0ID0gbWFzay5zeW1ib2xzO1xuICAgICAgICBmb3IgKGxldCByID0gZm9ybWF0Lmxlbmd0aCAtIDE7IHIgPj0gMDsgci0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5rbm93blBhcnRzLmluZGV4T2YoZm9ybWF0W3JdKSA9PT0gLTEgfHwgdGhpcy5nZXRFeGlzdGluZyhmb3JtYXRbcl0pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VGV4dCA9IHRleHRbcl0gKyByZXN1bHRUZXh0O1xuICAgICAgICAgICAgICAgIHJlc3VsdEZvcm1hdCA9IGZvcm1hdFtyXSArIHJlc3VsdEZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTeW1ib2wgPSBmb3JtYXRbcl07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIgPj0gMCAmJiBjdXJyZW50U3ltYm9sID09PSBmb3JtYXRbcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgci0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByKys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVhZGluZ1plcm8gJiYgdGhpcy5sZWFkaW5nWmVyb1tjdXJyZW50U3ltYm9sXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRUZXh0ID0gJzAnICsgcmVzdWx0VGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFRleHQgPSB0aGlzLmRhdGVGaWVsZE5hbWUobWFzay5wYXJ0TWFwW3JdKSArIHJlc3VsdFRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChyZXN1bHRGb3JtYXQubGVuZ3RoIDwgcmVzdWx0VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Rm9ybWF0ID0gZm9ybWF0W3JdICsgcmVzdWx0Rm9ybWF0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3Jlc3VsdFRleHQsIHJlc3VsdEZvcm1hdF07XG4gICAgfVxuICAgIGRhdGVGaWVsZE5hbWUocGFydCkge1xuICAgICAgICBjb25zdCBmb3JtYXRQbGFjZWhvbGRlciA9IHRoaXMuZm9ybWF0UGxhY2Vob2xkZXIgfHwgJ3dpZGUnO1xuICAgICAgICBpZiAoZm9ybWF0UGxhY2Vob2xkZXJbcGFydC50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFBsYWNlaG9sZGVyW3BhcnQudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdFBsYWNlaG9sZGVyID09PSAnZm9ybWF0UGF0dGVybicpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW50bC5kYXRlRmllbGROYW1lKE9iamVjdC5hc3NpZ24ocGFydCwgeyBuYW1lVHlwZTogZm9ybWF0UGxhY2Vob2xkZXIgfSkpO1xuICAgIH1cbiAgICBnZXROb3JtYWxpemVkQ2VudHVyeUJhc2UodHdvRGlnaXRZZWFyKSB7XG4gICAgICAgIHJldHVybiB0d29EaWdpdFllYXIgPiB0aGlzLnR3b0RpZ2l0WWVhck1heCA/XG4gICAgICAgICAgICBQUkVWSU9VU19DRU5UVVJZX0JBU0UgOlxuICAgICAgICAgICAgQ1VSUkVOVF9DRU5UVVJZX0JBU0U7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgRGF0ZUlucHV0IGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19kYXRlaW5wdXQgJX0jdG9jLWJhc2ljLXVzYWdlKS5cbiAqL1xubGV0IERhdGVJbnB1dENvbXBvbmVudCA9IERhdGVJbnB1dENvbXBvbmVudF8xID0gY2xhc3MgRGF0ZUlucHV0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjZHIsIGludGwsIHJlbmRlcmVyLCB3cmFwcGVyLCBuZ1pvbmUsIGluamVjdG9yLCBsb2NhbGl6YXRpb24sIHBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMucGlja2VyU2VydmljZSA9IHBpY2tlclNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUlkID0gYGstJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYGRpc2FibGVkYCBwcm9wZXJ0eSBvZiB0aGUgRGF0ZUlucHV0IGFuZFxuICAgICAgICAgKiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBhY3RpdmVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZF9kYXRlaW5wdXQgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgcmVhZC1vbmx5IHN0YXRlIG9mIHRoZSBEYXRlSW5wdXRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZWFkb25seV9kYXRlaW5wdXQgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBpbnB1dCBlbGVtZW50IG9mIHRoZSBEYXRlSW5wdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpdGxlID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYHRhYkluZGV4YCBwcm9wZXJ0eSBvZiB0aGUgRGF0ZUlucHV0LlxuICAgICAgICAgKiAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9sZSA9ICdzcGluYnV0dG9uJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXJpYVJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGRhdGUgZm9ybWF0IHRoYXQgaXMgdXNlZCB0byBkaXNwbGF5IHRoZSBpbnB1dCB2YWx1ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGZvcm1hdHNfZGF0ZWlucHV0ICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvcm1hdCB2YWx1ZSBvcHRpb25zOlxuICAgICAgICAgKiAtIGBzdHJpbmdgIC0gUHJvdmlkZSBhIGBzdHJpbmdgIGlmIGEgc2luZ2xlIGZvcm1hdCBpcyBnb2luZyB0byBiZSB1c2VkIHJlZ2FyZGxlc3Mgd2hldGhlciB0aGUgaW5wdXQgaXMgZm9jdXNlZCBvciBibHVycmVkLlxuICAgICAgICAgKiAtIFtgRm9ybWF0U2V0dGluZ3NgXSh7JSBzbHVnIGFwaV9kYXRlaW5wdXRzX2Zvcm1hdHNldHRpbmdzICV9KSAtIFRvIGRpc3BsYXkgZGlmZmVyZW50IGZvcm1hdHMgd2hlbiB0aGUgY29tcG9uZW50IGlzIGZvY3VzZWQgb3IgYmx1cnJlZCwgcHJvdmlkZSBhIHNldHRpbmdzIG9iamVjdCB3aXRoIHNwZWNpZmllZCBgaW5wdXRGb3JtYXRgIGFuZCBgZGlzcGxheUZvcm1hdGAgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBERUZBVUxUX0ZPUk1BVDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgaGludCB0aGUgRGF0ZUlucHV0IGRpc3BsYXlzIHdoZW4gaXRzIHZhbHVlIGlzIGBudWxsYC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uXG4gICAgICAgICAqIFtwbGFjZWhvbGRlcnNdKHslIHNsdWcgcGxhY2Vob2xkZXJzX2RhdGVpbnB1dCAlfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLWRhdGVpbnB1dCBwbGFjZWhvbGRlcj1cIkVudGVyIGJpcnRoIGRhdGUuLi5cIj48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJlcyB0aGUgaW5jcmVtZW50YWwgc3RlcHMgb2YgdGhlIERhdGVJbnB1dC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uXG4gICAgICAgICAqIFtpbmNyZW1lbnRhbCBzdGVwc10oeyUgc2x1ZyBpbmNyZW1lbnRhbHN0ZXBzX2RhdGVpbnB1dCAlfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLWRhdGVpbnB1dCBbc3RlcHNdPVwic3RlcHNcIj48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgc3RlcHMgPSB7IHllYXI6IDEwLCBtb250aDogMSwgZGF5OiA1IH07XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZXBzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIG1pbiBvciBtYXggdmFsaWRhdG9ycyBhcmUgdG8gYmUgZW5mb3JjZWQgd2hlbiBhIGZvcm0gaXMgYmVpbmcgdmFsaWRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZVZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKiBCYXNlZCBvbiB0aGUgbWluIGFuZCBtYXggdmFsdWVzLCBzcGVjaWZpZXMgd2hldGhlciB0aGUgdmFsdWUgd2lsbCBiZSBhdXRvLWNvcnJlY3RlZCB3aGlsZSB0eXBpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9Db3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIHZhbGlkYXRpb24gZm9yIGluY29tcGxldGUgZGF0ZXMgaXMgdG8gYmUgZW5mb3JjZWQgd2hlbiBhIGZvcm0gaXMgYmVpbmcgdmFsaWRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHllYXIgdG8gYXNzdW1lIHRvIGJlIGZyb20gdGhlIGN1cnJlbnQgY2VudHVyeSB3aGVuIHR5cGluZyB0d28tZGlnaXQgeWVhciB2YWx1ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGZvcm1hdHNfZGF0ZWlucHV0ICV9I3RvYy10d28tZGlnaXQteWVhci1mb3JtYXQpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgNjgsIGluZGljYXRpbmcgdGhhdCB0eXBpbmcgYW55IHZhbHVlIGxlc3MgdGhhbiA2OVxuICAgICAgICAgKiB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgMjB4eCwgd2hpbGUgNjkgYW5kIGxhcmdlciB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgMTl4eC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHdvRGlnaXRZZWFyTWF4ID0gVFdPX0RJR0lUX1lFQVJfTUFYO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdGhlICoqVXAqKiBhbmQgKipEb3duKiogc3BpbiBidXR0b25zIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgYXJ0aWNsZSBvblxuICAgICAgICAgKiBbc3Bpbm5lciBidXR0b25zXSh7JSBzbHVnIHNwaW5idXR0b25zX2RhdGVpbnB1dCAlfSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNwaW5uZXJzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzUG9wdXBPcGVuID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc1BvcHVwID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgc2VsZWN0cyBhIG5ldyB2YWx1ZS5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZWlucHV0ICV9I3RvYy1ldmVudHMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSBuZXcgdmFsdWUuXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgc2VjdGlvbiBvblxuICAgICAgICAgKiBbZXZlbnRzXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGVpbnB1dCAlfSN0b2MtZXZlbnRzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVVcGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgZm9jdXNlcyB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZWlucHV0ICV9I3RvYy1ldmVudHMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IFRvIHdpcmUgdGhlIGV2ZW50IHByb2dyYW1tYXRpY2FsbHksIHVzZSB0aGUgYG9uRm9jdXNgIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogIDxrZW5kby1kYXRlaW5wdXQgKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIj48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgaGFuZGxlRm9jdXMoKTogdm9pZCB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coXCJDb21wb25lbnQgaXMgZm9jdXNlZFwiKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGlucHV0IGVsZW1lbnQgZ2V0cyBibHVycmVkLlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHNlY3Rpb24gb25cbiAgICAgICAgICogW2V2ZW50c10oeyUgc2x1ZyBvdmVydmlld19kYXRlaW5wdXQgJX0jdG9jLWV2ZW50cykuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25CbHVyYCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogX0BDb21wb25lbnQoe1xuICAgICAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICAgICAqICA8a2VuZG8tZGF0ZWlucHV0IChibHVyKT1cImhhbmRsZUJsdXIoKVwiPjwva2VuZG8tZGF0ZWlucHV0PlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAgICAgKiAgIHB1YmxpYyBoYW5kbGVCbHVyKCk6IHZvaWQge1xuICAgICAgICAgKiAgICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50IGlzIGJsdXJyZWRcIik7XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIHRoaXMuYXJyb3cgPSBBcnJvdztcbiAgICAgICAgdGhpcy5hcnJvd0RpcmVjdGlvbiA9IEFycm93Lk5vbmU7XG4gICAgICAgIHRoaXMuZm9ybWF0U2VjdGlvbnMgPSB7IGRhdGU6IGZhbHNlLCB0aW1lOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmhhc01vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvY3VzZWRQcmlvclRvTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzRGF0ZUluY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnJlbnRGb3JtYXQgPSBcIlwiO1xuICAgICAgICB0aGlzLmJhY2tzcGFjZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0U2VnbWVudFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5taW5WYWxpZGF0b3IgPSBub29wO1xuICAgICAgICB0aGlzLm1heFZhbGlkYXRvciA9IG5vb3A7XG4gICAgICAgIHRoaXMuaW5jb21wbGV0ZVZhbGlkYXRvciA9IG5vb3A7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMua2VuZG9EYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXN0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLm9uQ29udHJvbENoYW5nZSA9IG5vb3A7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCA9IG5vb3A7XG4gICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLl9zaXplID0gJ21lZGl1bSc7XG4gICAgICAgIHRoaXMuX3JvdW5kZWQgPSAnbWVkaXVtJztcbiAgICAgICAgdGhpcy5fZmlsbE1vZGUgPSAnc29saWQnO1xuICAgICAgICB0aGlzLnN5bWJvbHNNYXAgPSB0aGlzLmRhdGVTeW1ib2xNYXAoKTtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JtYXRTZWN0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5waWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2UuaW5wdXQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgdGFiSW5kZXgodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy50YWJpbmRleCA9IHRhYkluZGV4O1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYmluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHZhbHVlIG9mIHRoZSBEYXRlSW5wdXQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogPiBUaGUgYHZhbHVlYCBoYXMgdG8gYmUgYSB2YWxpZCBbSmF2YVNjcmlwdCBgRGF0ZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUpIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZlcmlmeVZhbHVlKHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0NvcnJlY3QgJiYgIWlzSW5SYW5nZSh2YWx1ZSwgdGhpcy5taW4sIHRoaXMubWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gY2xvbmVEYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZVVwZGF0ZS5lbWl0KGNsb25lRGF0ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgJ3NtYWxsJ2BcbiAgICAgKiAqIGAnbWVkaXVtJ2AgKERlZmF1bHQpXG4gICAgICogKiBgJ2xhcmdlJ2BcbiAgICAgKiAqIGBudWxsYFxuICAgICAqXG4gICAgICovXG4gICAgc2V0IHNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50LCBnZXRTaXplQ2xhc3MoJ2lucHV0JywgdGhpcy5zaXplKSk7XG4gICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50LCBnZXRTaXplQ2xhc3MoJ2lucHV0Jywgc2l6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvcmRlciByYWRpdXMgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzbWFsbCdgXG4gICAgICogKiBgJ21lZGl1bSdgIChEZWZhdWx0KVxuICAgICAqICogYCdsYXJnZSdgXG4gICAgICogKiBgJ2Z1bGwnYFxuICAgICAqICogYG51bGxgXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgcm91bmRlZChyb3VuZGVkKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldFJvdW5kZWRDbGFzcyh0aGlzLnJvdW5kZWQpKTtcbiAgICAgICAgaWYgKHJvdW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldFJvdW5kZWRDbGFzcyhyb3VuZGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm91bmRlZCA9IHJvdW5kZWQ7XG4gICAgfVxuICAgIGdldCByb3VuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm91bmRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZmlsbE1vZGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzb2xpZCdgIChEZWZhdWx0KVxuICAgICAqICogYCdmbGF0J2BcbiAgICAgKiAqIGAnb3V0bGluZSdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKlxuICAgICAqL1xuICAgIHNldCBmaWxsTW9kZShmaWxsTW9kZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50LCBnZXRGaWxsTW9kZUNsYXNzKCdpbnB1dCcsIHRoaXMuZmlsbE1vZGUpKTtcbiAgICAgICAgaWYgKGZpbGxNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50LCBnZXRGaWxsTW9kZUNsYXNzKCdpbnB1dCcsIGZpbGxNb2RlKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zcGlubmVycyAmJiB0aGlzLnNwaW51cCAmJiB0aGlzLnNwaW5kb3duKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTcGlubmVyRmlsbCh0aGlzLnNwaW51cC5uYXRpdmVFbGVtZW50LCBmaWxsTW9kZSwgdGhpcy5maWxsTW9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTcGlubmVyRmlsbCh0aGlzLnNwaW5kb3duLm5hdGl2ZUVsZW1lbnQsIGZpbGxNb2RlLCB0aGlzLmZpbGxNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maWxsTW9kZSA9IGZpbGxNb2RlO1xuICAgIH1cbiAgICBnZXQgZmlsbE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsTW9kZTtcbiAgICB9XG4gICAgZ2V0IHdyYXBwZXJDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgZ2V0IGlucHV0RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUlucHV0ID8gdGhpcy5kYXRlSW5wdXQubmF0aXZlRWxlbWVudCA6IG51bGw7XG4gICAgfVxuICAgIGdldCBpbnB1dFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5wdXRFbGVtZW50IHx8IHt9KS52YWx1ZSB8fCAnJztcbiAgICB9XG4gICAgZ2V0IGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cbiAgICBzZXQgaXNBY3RpdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdmFsdWU7XG4gICAgICAgIGlmICghdGhpcy53cmFwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5waWNrZXJTZXJ2aWNlKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50LCAnay1mb2N1cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50LCAnay1mb2N1cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpbnB1dEZvcm1hdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfRk9STUFUO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5mb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQuaW5wdXRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRpc3BsYXlGb3JtYXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5mb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0ZPUk1BVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZm9ybWF0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0LmRpc3BsYXlGb3JtYXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgYnkgdGhlIFRleHRCb3hDb250YWluZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgaXMgZW1wdHlcbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY3VycmVudFZhbHVlIHx8ICFTdHJpbmcodGhpcy5jdXJyZW50VmFsdWUpLnRyaW0oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnRhaW5zRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGNsb3Nlc3QoZWxlbWVudCwgbm9kZSA9PiBub2RlID09PSB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnZlcmlmeVJhbmdlKCk7XG4gICAgICAgIGlmIChjaGFuZ2VzLm1pbiB8fCBjaGFuZ2VzLm1heCB8fCBjaGFuZ2VzLnJhbmdlVmFsaWRhdGlvbiB8fCBjaGFuZ2VzLmluY29tcGxldGVEYXRlVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5taW5WYWxpZGF0b3IgPSB0aGlzLnJhbmdlVmFsaWRhdGlvbiA/IG1pblZhbGlkYXRvcih0aGlzLm1pbikgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5tYXhWYWxpZGF0b3IgPSB0aGlzLnJhbmdlVmFsaWRhdGlvbiA/IG1heFZhbGlkYXRvcih0aGlzLm1heCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5pbmNvbXBsZXRlVmFsaWRhdG9yID0gdGhpcy5pbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb24gPyBpbmNvbXBsZXRlRGF0ZVZhbGlkYXRvcigpIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5mb3JtYXQpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sc01hcCA9IHRoaXMuZGF0ZVN5bWJvbE1hcCgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtYXRTZWN0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRXF1YWxUb0tlbmRvRGF0ZSA9IHRoaXMua2VuZG9EYXRlICYmIGlzRXF1YWwodGhpcy52YWx1ZSwgdGhpcy5rZW5kb0RhdGUuZ2V0RGF0ZU9iamVjdCgpKTtcbiAgICAgICAgaWYgKGNoYW5nZXMuZm9ybWF0IHx8ICFpc0VxdWFsVG9LZW5kb0RhdGUgfHwgY2hhbmdlcy5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgdGhpcy5rZW5kb0RhdGUgPSB0aGlzLmdldEtlbmRvRGF0ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudFZhbHVlKHRoaXMuaXNBY3RpdmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5pbnRsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmludGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5waWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2UuaW5wdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLmZvckVhY2godW5iaW5kQ2FsbGJhY2sgPT4gdW5iaW5kQ2FsbGJhY2soKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZShjb250cm9sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblZhbGlkYXRvcihjb250cm9sKSB8fCB0aGlzLm1heFZhbGlkYXRvcihjb250cm9sKSB8fCB0aGlzLmluY29tcGxldGVWYWxpZGF0b3IoY29udHJvbCwgdGhpcy5pc0RhdGVJbmNvbXBsZXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMua2VuZG9EYXRlID0gdGhpcy5nZXRLZW5kb0RhdGUodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudFZhbHVlKCk7XG4gICAgICAgIHRoaXMuaW50bFN1YnNjcmlwdGlvbiA9IHRoaXMuaW50bC5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmludGxDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubmdDb250cm9sID0gdGhpcy5pbmplY3Rvci5nZXQoTmdDb250cm9sLCBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsICd0YWJpbmRleCcpO1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudENsYXNzZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8vbmdNb2RlbCBiaW5kaW5nXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMua2VuZG9EYXRlID0gdGhpcy5nZXRLZW5kb0RhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gY2xvbmVEYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50VmFsdWUodGhpcy5pc0FjdGl2ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0cmlnZ2VyQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMua2VuZG9EYXRlLmdldERhdGVPYmplY3QoKTtcbiAgICAgICAgaWYgKCt2YWx1ZSAhPT0gK3RoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBjbG9uZURhdGUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbm90aWZ5KCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UoY2xvbmVEYXRlKHRoaXMudmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdChjbG9uZURhdGUodGhpcy52YWx1ZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBEYXRlSW5wdXQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogdGVtcGxhdGU6IGBcbiAgICAgKiAgPGJ1dHRvbiAoY2xpY2spPVwiZGF0ZWlucHV0LmZvY3VzKClcIj5Gb2N1cyBkYXRlIGlucHV0PC9idXR0b24+XG4gICAgICogIDxrZW5kby1kYXRlaW5wdXQgI2RhdGVpbnB1dD48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXRFbGVtZW50O1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdERhdGVTZWdtZW50KHRoaXMuY3VycmVudEZvcm1hdFswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIERhdGVJbnB1dCBjb21wb25lbnQuXG4gICAgICovXG4gICAgYmx1cigpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0RWxlbWVudDtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICBpbnB1dC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUJ1dHRvbkNsaWNrKG9mZnNldCkge1xuICAgICAgICB0aGlzLmFycm93RGlyZWN0aW9uID0gQXJyb3cuTm9uZTtcbiAgICAgICAgdGhpcy5tb2RpZnlEYXRlU2VnbWVudFZhbHVlKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBtb2RpZnlEYXRlU2VnbWVudFZhbHVlKG9mZnNldCkge1xuICAgICAgICBjb25zdCBjYXJldCA9IHRoaXMuY2FyZXQoKTtcbiAgICAgICAgY29uc3Qgc3ltYm9sID0gdGhpcy5jdXJyZW50Rm9ybWF0W2NhcmV0WzBdXTtcbiAgICAgICAgbGV0IHN0ZXAgPSAodGhpcy5zdGVwcyB8fCB7fSlbdGhpcy5zeW1ib2xzTWFwW3N5bWJvbF1dIHx8IDE7XG4gICAgICAgIGlmIChzeW1ib2wgPT09IFwiU1wiICYmICF0aGlzLnN0ZXBzLm1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICBjb25zdCBtc0RpZ2l0cyA9IG1pbGxpc2Vjb25kRGlnaXRzSW5Gb3JtYXQodGhpcy5pbnB1dEZvcm1hdCk7XG4gICAgICAgICAgICBzdGVwID0gbWlsbGlzZWNvbmRTdGVwRm9yKG1zRGlnaXRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtlbmRvRGF0ZS5tb2RpZnlQYXJ0KHN5bWJvbCwgb2Zmc2V0ICogc3RlcCk7XG4gICAgICAgIHRoaXMucHV0RGF0ZUluUmFuZ2UoKTtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50VmFsdWUodGhpcy5pc0FjdGl2ZSk7XG4gICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdERhdGVTZWdtZW50KHN5bWJvbCk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5jb21wbGV0ZVZhbGlkYXRpb25TdGF0dXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHN3aXRjaERhdGVTZWdtZW50KG9mZnNldCkge1xuICAgICAgICBjb25zdCBjYXJldCA9IHRoaXMuY2FyZXQoKTtcbiAgICAgICAgaWYgKHRoaXMua2VuZG9EYXRlLnJlc2V0TGVhZGluZ1plcm8oKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50VmFsdWUodGhpcy5pc0FjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcmV0WzBdIDwgY2FyZXRbMV0gJiYgdGhpcy5jdXJyZW50Rm9ybWF0W2NhcmV0WzBdXSAhPT0gdGhpcy5jdXJyZW50Rm9ybWF0W2NhcmV0WzFdIC0gMV0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0TmVhcmVzdFNlZ21lbnQob2Zmc2V0ID4gMCA/IGNhcmV0WzBdIDogY2FyZXRbMV0gLSAxKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTZWdtZW50VmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNGb3JtYXRTeW1ib2wgPSB0aGlzLmN1cnJlbnRGb3JtYXRbY2FyZXRbMF1dO1xuICAgICAgICBsZXQgYSA9IGNhcmV0WzBdICsgb2Zmc2V0O1xuICAgICAgICB3aGlsZSAoYSA+IDAgJiYgYSA8IHRoaXMuY3VycmVudEZvcm1hdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRGb3JtYXRbYV0gIT09IHByZXZpb3VzRm9ybWF0U3ltYm9sICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Rm9ybWF0W2FdICE9PSBcIl9cIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSArPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEZvcm1hdFthXSA9PT0gXCJfXCIpIHtcbiAgICAgICAgICAgIC8vdGhlcmUgaXMgbm90IGtub3duIHN5bWJvbCBmb3VuZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiID0gYTtcbiAgICAgICAgd2hpbGUgKGIgPj0gMCAmJiBiIDwgdGhpcy5jdXJyZW50Rm9ybWF0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEZvcm1hdFtiXSAhPT0gdGhpcy5jdXJyZW50Rm9ybWF0W2FdKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiICs9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSA+IGIgJiYgKGIgKyAxICE9PSBjYXJldFswXSB8fCBhICsgMSAhPT0gY2FyZXRbMV0pKSB7XG4gICAgICAgICAgICB0aGlzLmNhcmV0KGIgKyAxLCBhICsgMSk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VnbWVudFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEgPCBiICYmIChhICE9PSBjYXJldFswXSB8fCBiICE9PSBjYXJldFsxXSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FyZXQoYSwgYik7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VnbWVudFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNlbGVjdERhdGVTZWdtZW50KHN5bWJvbCkge1xuICAgICAgICBsZXQgYmVnaW4gPSAtMTtcbiAgICAgICAgbGV0IGVuZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jdXJyZW50Rm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Rm9ybWF0W2ldID09PSBzeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoYmVnaW4gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZ2luIDwgMCkge1xuICAgICAgICAgICAgYmVnaW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FyZXQoMCwgMCk7XG4gICAgICAgIHRoaXMuY2FyZXQoYmVnaW4sIGVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVDbGljaygpIHtcbiAgICAgICAgdGhpcy5oYXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblByZXNlbnQgPSB0aGlzLmlucHV0RWxlbWVudC5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5pbnB1dEVsZW1lbnQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJUb2dnbGVkID0gaXNQcmVzZW50KHRoaXMucGxhY2Vob2xkZXIpICYmICF0aGlzLmtlbmRvRGF0ZS5oYXNWYWx1ZSgpICYmICF0aGlzLmZvY3VzZWRQcmlvclRvTW91c2Vkb3duO1xuICAgICAgICAgICAgLy8gZm9jdXMgZmlyc3Qgc2VnbWVudCBpZiB0aGUgdXNlciBoYXNuJ3Qgc2VsZWN0ZWQgc29tZXRoaW5nIGR1cmluZyBtb3VzZWRvd24gYW5kIGlmIHRoZSBwbGFjZWhvbGRlciB3YXMganVzdCB0b2dnbGVkXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RGaXJzdFNlZ21lbnQgPSAhc2VsZWN0aW9uUHJlc2VudCAmJiBwbGFjZWhvbGRlclRvZ2dsZWQ7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHNlbGVjdEZpcnN0U2VnbWVudCA/IDAgOiB0aGlzLmNhcmV0KClbMF07XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE5lYXJlc3RTZWdtZW50KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlRHJhZ0FuZERyb3AoYXJncykge1xuICAgICAgICBhcmdzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZWRvd24oKSB7XG4gICAgICAgIHRoaXMuaGFzTW91c2Vkb3duID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mb2N1c2VkUHJpb3JUb01vdXNlZG93biA9IHRoaXMuaXNBY3RpdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVGb2N1cyhhcmdzKSB7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRWYWx1ZSgpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzTW91c2Vkb3duKSB7XG4gICAgICAgICAgICB0aGlzLmNhcmV0KDAsIHRoaXMuaW5wdXRWYWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkZvY3VzKSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRGb2N1cyhhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0Rm9jdXMoYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUJsdXIoYXJncykge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzZXRTZWdtZW50VmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLmtlbmRvRGF0ZS5yZXNldExlYWRpbmdaZXJvKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudFZhbHVlKCk7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkJsdXIpIHx8IHJlcXVpcmVzWm9uZU9uQmx1cih0aGlzLm5nQ29udHJvbCkpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbnRyb2xUb3VjaGVkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Qmx1cihhcmdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0Qmx1cihhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRLZW5kb0RhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyBsZWFkaW5nWmVybyB9ID0gKHRoaXMua2VuZG9EYXRlIHx8IHt9KSB8fCBudWxsO1xuICAgICAgICBjb25zdCBrZW5kb0RhdGUgPSBuZXcgS2VuZG9EYXRlKHRoaXMuaW50bCwgdGhpcy5mb3JtYXRQbGFjZWhvbGRlciwgdGhpcy5pbnB1dEZvcm1hdCwgdmFsdWUsIHRoaXMudHdvRGlnaXRZZWFyTWF4KTtcbiAgICAgICAga2VuZG9EYXRlLnNldExlYWRpbmdaZXJvKHRoaXMuaXNBY3RpdmUgPyBsZWFkaW5nWmVybyA6IG51bGwpO1xuICAgICAgICByZXR1cm4ga2VuZG9EYXRlO1xuICAgIH1cbiAgICBkYXRlU3ltYm9sTWFwKCkge1xuICAgICAgICBjb25zdCByZWR1Y2VyID0gKG1hcCQkMSwgcGFydCkgPT4ge1xuICAgICAgICAgICAgbWFwJCQxW3BhcnQucGF0dGVyblswXV0gPSBwYXJ0LnR5cGU7XG4gICAgICAgICAgICByZXR1cm4gbWFwJCQxO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRsLnNwbGl0RGF0ZUZvcm1hdCh0aGlzLmlucHV0Rm9ybWF0KS5yZWR1Y2UocmVkdWNlciwge30pO1xuICAgIH1cbiAgICB1cGRhdGVFbGVtZW50VmFsdWUoaXNBY3RpdmUpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmNhcmV0KClbMF07IC8vWFhYOiBnZXQgY2FyZXQgcG9zaXRpb24gYmVmb3JlIGlucHV0IGlzIHVwZGF0ZWRcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5pc0FjdGl2ZSA/IHRoaXMuaW5wdXRGb3JtYXQgOiB0aGlzLmRpc3BsYXlGb3JtYXQ7XG4gICAgICAgIGNvbnN0IHRleHRzID0gdGhpcy5rZW5kb0RhdGUuZ2V0VGV4dEFuZEZvcm1hdChmb3JtYXQpO1xuICAgICAgICBjb25zdCBzaG93UGxhY2Vob2xkZXIgPSAhdGhpcy5pc0FjdGl2ZSAmJiBpc1ByZXNlbnQodGhpcy5wbGFjZWhvbGRlcikgJiYgIXRoaXMua2VuZG9EYXRlLmhhc1ZhbHVlKCk7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY3VycmVudEZvcm1hdCA9IHRleHRzWzFdO1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9ICFzaG93UGxhY2Vob2xkZXIgPyB0ZXh0c1swXSA6ICcnO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KGlucHV0LCBcInZhbHVlXCIsIHRoaXMuY3VycmVudFZhbHVlKTtcbiAgICAgICAgaWYgKGlucHV0LnBsYWNlaG9sZGVyICE9PSB0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KGlucHV0LCBcInBsYWNlaG9sZGVyXCIsIHRoaXMucGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3ROZWFyZXN0U2VnbWVudChzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FyZXQoc3RhcnQsIGVuZCA9IHN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IGlzUG9zaXRpb24gPSBzdGFydCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmV0dXJuVmFsdWUgPSBbc3RhcnQsIHN0YXJ0XTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuaW5wdXRFbGVtZW50O1xuICAgICAgICBpZiAoaXNQb3NpdGlvbiAmJiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuc2VsZWN0aW9uU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RvY3VtZW50QXZhaWxhYmxlKCkgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gW2VsZW1lbnQuc2VsZWN0aW9uU3RhcnQsIGVsZW1lbnQuc2VsZWN0aW9uRW5kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIHNlbGVjdE5lYXJlc3RTZWdtZW50KGluZGV4KSB7XG4gICAgICAgIC8vIEZpbmRzIHRoZSBuZWFyZXN0IChpbiBib3RoIGRpcmVjdGlvbnMpIGtub3duIHBhcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleCwgaiA9IGluZGV4IC0gMTsgaSA8IHRoaXMuY3VycmVudEZvcm1hdC5sZW5ndGggfHwgaiA+PSAwOyBpKyssIGotLSkge1xuICAgICAgICAgICAgaWYgKGkgPCB0aGlzLmN1cnJlbnRGb3JtYXQubGVuZ3RoICYmIHRoaXMuY3VycmVudEZvcm1hdFtpXSAhPT0gXCJfXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdERhdGVTZWdtZW50KHRoaXMuY3VycmVudEZvcm1hdFtpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPj0gMCAmJiB0aGlzLmN1cnJlbnRGb3JtYXRbal0gIT09IFwiX1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3REYXRlU2VnbWVudCh0aGlzLmN1cnJlbnRGb3JtYXRbal0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnlSYW5nZSgpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZFJhbmdlKHRoaXMubWluLCB0aGlzLm1heCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG1heCB2YWx1ZSBzaG91bGQgYmUgYmlnZ2VyIHRoYW4gdGhlIG1pbi4gU2VlICR7TUlOX0RPQ19MSU5LJDJ9IGFuZCAke01BWF9ET0NfTElOSyQyfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnlWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ3ZhbHVlJyBzaG91bGQgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IERhdGUgaW5zdGFuY2UuIENoZWNrICR7VkFMVUVfRE9DX0xJTkskMn0gZm9yIHBvc3NpYmxlIHJlc29sdXRpb24uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0RGF0ZUluUmFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREYXRlID0gdGhpcy5rZW5kb0RhdGUuZ2V0RGF0ZU9iamVjdCgpO1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBkYXRlSW5SYW5nZShjdXJyZW50RGF0ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0NvcnJlY3QgJiYgIWlzRXF1YWwoY3VycmVudERhdGUsIGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMua2VuZG9EYXRlID0gdGhpcy5nZXRLZW5kb0RhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVGb3JtYXRTZWN0aW9ucygpIHtcbiAgICAgICAgdGhpcy5mb3JtYXRTZWN0aW9ucyA9IHRoaXMuaW50bC5zcGxpdERhdGVGb3JtYXQodGhpcy5pbnB1dEZvcm1hdClcbiAgICAgICAgICAgIC5yZWR1Y2UoKHsgZGF0ZSwgdGltZSB9LCBwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGU6IGRhdGUgfHwgREFURV9QQVJUX1JFR0VYUC50ZXN0KHAudHlwZSksXG4gICAgICAgICAgICAgICAgdGltZTogdGltZSB8fCBUSU1FX1BBUlRfUkVHRVhQLnRlc3QocC50eXBlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgeyBkYXRlOiBmYWxzZSwgdGltZTogZmFsc2UgfSk7XG4gICAgfVxuICAgIGludGxDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRm9ybWF0U2VjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5rZW5kb0RhdGUgPSB0aGlzLmdldEtlbmRvRGF0ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50VmFsdWUodGhpcy5pc0FjdGl2ZSk7XG4gICAgfVxuICAgIHVwZGF0ZU9uUGFzdGUoKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuaW50bC5wYXJzZURhdGUodGhpcy5pbnB1dFZhbHVlLCB0aGlzLmlucHV0Rm9ybWF0KSB8fCB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSAmJiB0aGlzLmtlbmRvRGF0ZS5zaG91bGROb3JtYWxpemVDZW50dXJ5KCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5rZW5kb0RhdGUubm9ybWFsaXplQ2VudHVyeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm90aWZ5ID0gK3ZhbHVlICE9PSArdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kRXZlbnRzKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IG1vdXNld2hlZWxIYW5kbGVyID0gdGhpcy5oYW5kbGVNb3VzZVdoZWVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLnB1c2godGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ0RPTU1vdXNlU2Nyb2xsJywgbW91c2V3aGVlbEhhbmRsZXIpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnbW91c2V3aGVlbCcsIG1vdXNld2hlZWxIYW5kbGVyKSwgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWRvd24uYmluZCh0aGlzKSksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdwYXN0ZScsIHRoaXMuaGFuZGxlUGFzdGUuYmluZCh0aGlzKSksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdpbnB1dCcsIHRoaXMuaGFuZGxlSW5wdXQuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICBoYW5kbGVNb3VzZVdoZWVsKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkgfHwgIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGVwcmVjYXRpb24gKi9cbiAgICAgICAgZXZlbnQgPSB3aW5kb3cuZXZlbnQgfHwgZXZlbnQ7XG4gICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgdGhpcy5zd2l0Y2hEYXRlU2VnbWVudCgoZXZlbnQud2hlZWxEZWx0YSB8fCAtZXZlbnQuZGV0YWlsKSA+IDAgPyAtMSA6IDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEYXRlU2VnbWVudFZhbHVlKChldmVudC53aGVlbERlbHRhIHx8IC1ldmVudC5kZXRhaWwpID4gMCA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVBhc3RlKCkge1xuICAgICAgICB0aGlzLnBhc3RlID0gdHJ1ZTtcbiAgICB9XG4gICAgaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5UYWIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVkID0gdGhpcy5zd2l0Y2hEYXRlU2VnbWVudChldmVudC5zaGlmdEtleSA/IC0xIDogMSk7XG4gICAgICAgICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLZXlzLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5iYWNrc3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBLZXlzLkFycm93RG93bjpcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeURhdGVTZWdtZW50VmFsdWUoLTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkFycm93VXA6XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlEYXRlU2VnbWVudFZhbHVlKDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkFycm93UmlnaHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hEYXRlU2VnbWVudCgxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS2V5cy5BcnJvd0xlZnQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hEYXRlU2VnbWVudCgtMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuSG9tZTpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5lYXJlc3RTZWdtZW50KDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkVuZDpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5lYXJlc3RTZWdtZW50KHRoaXMuaW5wdXRWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vc2tpcCB0aGUgcHJldmVudERlZmF1bHQgaWYgd2UgZGlkbid0IGhhbmRsZWQgdGhlIGtleUNvZGVcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBoYW5kbGVJbnB1dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhc3RlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU9uUGFzdGUoKTtcbiAgICAgICAgICAgIHRoaXMucGFzdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWZmID0gYXBwcm94aW1hdGVTdHJpbmdNYXRjaGluZyh0aGlzLmN1cnJlbnRWYWx1ZSwgdGhpcy5jdXJyZW50Rm9ybWF0LCB0aGlzLmlucHV0VmFsdWUsIHRoaXMuY2FyZXQoKVswXSk7XG4gICAgICAgIGNvbnN0IG5hdmlnYXRpb25Pbmx5ID0gKGRpZmYubGVuZ3RoID09PSAxICYmIGRpZmZbMF1bMV0gPT09IFwiX1wiKTtcbiAgICAgICAgbGV0IHN3aXRjaFBhcnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFuYXZpZ2F0aW9uT25seSkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZFBhcnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRQYXJ0ID0gdGhpcy5rZW5kb0RhdGUucGFyc2VQYXJ0KGRpZmZbaV1bMF0sIGRpZmZbaV1bMV0sIHRoaXMucmVzZXRTZWdtZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhcnQgPSBwYXJzZWRQYXJ0LnN3aXRjaFRvTmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHRoaXMua2VuZG9EYXRlLmdldERhdGVPYmplY3QoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlICYmIGNhbmRpZGF0ZSAmJiAhdGhpcy5mb3JtYXRTZWN0aW9ucy5kYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZW5kb0RhdGUgPSB0aGlzLmdldEtlbmRvRGF0ZShzZXRUaW1lKHRoaXMudmFsdWUsIGNhbmRpZGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRTZWdtZW50VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXREYXRlSW5SYW5nZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRWYWx1ZSh0aGlzLmlzQWN0aXZlKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5jb21wbGV0ZVZhbGlkYXRpb25TdGF0dXMoKTtcbiAgICAgICAgaWYgKGRpZmYubGVuZ3RoICYmIGRpZmZbMF1bMF0gIT09IFwiX1wiKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdERhdGVTZWdtZW50KGRpZmZbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzd2l0Y2hQYXJ0IHx8IG5hdmlnYXRpb25Pbmx5KSB7XG4gICAgICAgICAgICB0aGlzLnN3aXRjaERhdGVTZWdtZW50KDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJhY2tzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5zd2l0Y2hEYXRlU2VnbWVudCgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYWNrc3BhY2UgPSBmYWxzZTtcbiAgICB9XG4gICAgZW1pdEZvY3VzKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLm9uRm9jdXMuZW1pdChhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0Qmx1cihhcmdzKSB7XG4gICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLm9uQmx1ci5lbWl0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUluY29tcGxldGVWYWxpZGF0aW9uU3RhdHVzKCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5pc0RhdGVJbmNvbXBsZXRlO1xuICAgICAgICB0aGlzLmlzRGF0ZUluY29tcGxldGUgPSB0aGlzLmtlbmRvRGF0ZS5oYXNWYWx1ZSgpICYmIHRoaXMudmFsdWUgPT09IG51bGw7XG4gICAgICAgIGlmIChwcmV2aW91c1ZhbHVlID09PSB0aGlzLmlzRGF0ZUluY29tcGxldGUgfHwgIXRoaXMuaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm5nQ29udHJvbCkgJiYgIWlzUHJlc2VudCh0aGlzLnBpY2tlclNlcnZpY2UpKSB7XG4gICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLnBpY2tlclNlcnZpY2UpKSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2UuZGF0ZUNvbXBsZXRlbmVzc0NoYW5nZS5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0U3Bpbm5lckZpbGwoc3Bpbm5lciwgZmlsbCwgb2xkRmlsbCkge1xuICAgICAgICBpZiAob2xkRmlsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhzcGlubmVyLCBgay1idXR0b24tJHtvbGRGaWxsfWApO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhzcGlubmVyLCBgay1idXR0b24tJHtvbGRGaWxsfS1iYXNlYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhzcGlubmVyLCBgay1idXR0b24tJHtmaWxsfWApO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHNwaW5uZXIsIGBrLWJ1dHRvbi0ke2ZpbGx9LWJhc2VgKTtcbiAgICB9XG4gICAgc2V0Q29tcG9uZW50Q2xhc3NlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0U2l6ZUNsYXNzKCdpbnB1dCcsIHRoaXMuc2l6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvdW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldFJvdW5kZWRDbGFzcyh0aGlzLnJvdW5kZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWxsTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0RmlsbE1vZGVDbGFzcygnaW5wdXQnLCB0aGlzLmZpbGxNb2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3Bpbm5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3Bpbm5lckZpbGwodGhpcy5zcGludXAubmF0aXZlRWxlbWVudCwgdGhpcy5maWxsTW9kZSk7XG4gICAgICAgICAgICB0aGlzLnNldFNwaW5uZXJGaWxsKHRoaXMuc3BpbmRvd24ubmF0aXZlRWxlbWVudCwgdGhpcy5maWxsTW9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c2FibGVJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInJvbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImFyaWFSZWFkT25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0UGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwic3RlcHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZVZhbGlkYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImF1dG9Db3JyZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwidHdvRGlnaXRZZWFyTWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInNwaW5uZXJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpc1BvcHVwT3BlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGFzUG9wdXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaXplXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbE1vZGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVVcGRhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnZm9jdXMnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2JsdXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnZGF0ZUlucHV0JywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGVJbnB1dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstaW5wdXQnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kYXRlaW5wdXQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3cmFwcGVyQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBEYXRlSW5wdXRDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3NwaW51cCcsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIERhdGVJbnB1dENvbXBvbmVudC5wcm90b3R5cGUsIFwic3BpbnVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3NwaW5kb3duJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgRGF0ZUlucHV0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzcGluZG93blwiLCB2b2lkIDApO1xuRGF0ZUlucHV0Q29tcG9uZW50ID0gRGF0ZUlucHV0Q29tcG9uZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kby1kYXRlaW5wdXQnLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVJbnB1dENvbXBvbmVudF8xKSwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTkdfVkFMSURBVE9SUywgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZUlucHV0Q29tcG9uZW50XzEpLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBMMTBOX1BSRUZJWCwgdXNlVmFsdWU6ICdrZW5kby5kYXRlaW5wdXQnIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IEtlbmRvSW5wdXQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVJbnB1dENvbXBvbmVudF8xKSB9LFxuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWRhdGVpbnB1dCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRhaW5lciBrZW5kb0RhdGVJbnB1dExvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgIGkxOG4taW5jcmVtZW50PVwia2VuZG8uZGF0ZWlucHV0LmluY3JlbWVudHxUaGUgbGFiZWwgZm9yIHRoZSAqKkluY3JlbWVudCoqIGJ1dHRvbiBpbiB0aGUgRGF0ZUlucHV0XCJcbiAgICAgICAgaW5jcmVtZW50PVwiSW5jcmVhc2UgdmFsdWVcIlxuXG4gICAgICAgIGkxOG4tZGVjcmVtZW50PVwia2VuZG8uZGF0ZWlucHV0LmRlY3JlbWVudHxUaGUgbGFiZWwgZm9yIHRoZSAqKkRlY3JlbWVudCoqIGJ1dHRvbiBpbiB0aGUgRGF0ZUlucHV0XCJcbiAgICAgICAgZGVjcmVtZW50PVwiRGVjcmVhc2UgdmFsdWVcIlxuICAgID5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8aW5wdXRcbiAgICAgICAgI2RhdGVJbnB1dFxuICAgICAgICBhdXRvY29tcGxldGU9XCJvZmZcIlxuICAgICAgICBhdXRvY29ycmVjdD1cIm9mZlwiXG4gICAgICAgIGF1dG9jYXBpdGFsaXplPVwib2ZmXCJcbiAgICAgICAgc3BlbGxjaGVjaz1cImZhbHNlXCJcbiAgICAgICAgY2xhc3M9XCJrLWlucHV0LWlubmVyXCJcbiAgICAgICAgW2F0dHIucm9sZV09XCJyb2xlXCJcbiAgICAgICAgW2F0dHIuYXJpYS1yZWFkb25seV09XCJhcmlhUmVhZE9ubHlcIlxuICAgICAgICBbaWRdPVwiZm9jdXNhYmxlSWRcIlxuICAgICAgICBbdGl0bGVdPVwidGl0bGVcIlxuICAgICAgICBbdGFiaW5kZXhdPVwidGFiaW5kZXhcIlxuICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICBbcmVhZG9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImlzUG9wdXBPcGVuXCJcbiAgICAgICAgW2F0dHIuYXJpYS1oYXNwb3B1cF09XCJoYXNQb3B1cFwiXG4gICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgIGNsaWNrOiBoYW5kbGVDbGljayxcbiAgICAgICAgICAgIGZvY3VzOiBoYW5kbGVGb2N1cyxcbiAgICAgICAgICAgIG1vdXNlZG93bjogaGFuZGxlTW91c2Vkb3duLFxuICAgICAgICAgICAgdG91Y2hzdGFydDogaGFuZGxlTW91c2Vkb3duLFxuICAgICAgICAgICAgZHJhZ3N0YXJ0OiBoYW5kbGVEcmFnQW5kRHJvcCxcbiAgICAgICAgICAgIGRyb3A6IGhhbmRsZURyYWdBbmREcm9wLFxuICAgICAgICAgICAgYmx1cjogaGFuZGxlQmx1clxuICAgICAgICB9XCJcbiAgICAgICAgW3Njb3BlXT1cInRoaXNcIlxuICAgICAgICAvPlxuICAgIDxzcGFuICpuZ0lmPVwic3Bpbm5lcnNcIiBjbGFzcz1cImstaW5wdXQtc3Bpbm5lciBrLXNwaW4tYnV0dG9uXCIgKG1vdXNlZG93bik9XCIkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAjc3BpbnVwXG4gICAgICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgIGNsYXNzPVwiay1zcGlubmVyLWluY3JlYXNlIGstYnV0dG9uIGstaWNvbi1idXR0b25cIlxuICAgICAgICAgICAgW2NsYXNzLmstYWN0aXZlXT1cImFycm93RGlyZWN0aW9uID09PSBhcnJvdy5VcFwiXG4gICAgICAgICAgICAobW91c2Vkb3duKT1cImFycm93RGlyZWN0aW9uID0gYXJyb3cuVXBcIlxuICAgICAgICAgICAgKG1vdXNlbGVhdmUpPVwiYXJyb3dEaXJlY3Rpb24gPSBhcnJvdy5Ob25lXCJcbiAgICAgICAgICAgIChjbGljayk9XCJoYW5kbGVCdXR0b25DbGljaygxKVwiXG4gICAgICAgICAgICBbdGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgnaW5jcmVtZW50JylcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdpbmNyZW1lbnQnKVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWJ1dHRvbi1pY29uIGstaWNvbiBrLWktYXJyb3ctblwiPjwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICNzcGluZG93blxuICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICBjbGFzcz1cImstc3Bpbm5lci1kZWNyZWFzZSBrLWJ1dHRvbiBrLWljb24tYnV0dG9uXCJcbiAgICAgICAgICAgIChjbGljayk9XCJoYW5kbGVCdXR0b25DbGljaygtMSlcIlxuICAgICAgICAgICAgW2NsYXNzLmstYWN0aXZlXT1cImFycm93RGlyZWN0aW9uID09PSBhcnJvdy5Eb3duXCJcbiAgICAgICAgICAgIChtb3VzZWRvd24pPVwiYXJyb3dEaXJlY3Rpb24gPSBhcnJvdy5Eb3duXCJcbiAgICAgICAgICAgIChtb3VzZWxlYXZlKT1cImFycm93RGlyZWN0aW9uID0gYXJyb3cuTm9uZVwiXG4gICAgICAgICAgICBbdGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgnZGVjcmVtZW50JylcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdkZWNyZW1lbnQnKVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWJ1dHRvbi1pY29uIGstaWNvbiBrLWktYXJyb3ctc1wiPjwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgPC9zcGFuPlxuICBgXG4gICAgfSksXG4gICAgX19wYXJhbSg3LCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBJbnRsU2VydmljZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIEluamVjdG9yLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBQaWNrZXJTZXJ2aWNlXSlcbl0sIERhdGVJbnB1dENvbXBvbmVudCk7XG5cbi8qKlxuICogQSBwcmV2ZW50YWJsZSBldmVudCBpbnN0YW5jZSB3aGljaCBpcyB0cmlnZ2VyZWQgYnkgdGhlIGBvcGVuYCBhbmQgYGNsb3NlYCBldmVudHMuXG4gKi9cbmNsYXNzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIGEgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIEluIHRoaXMgd2F5LCB0aGUgc291cmNlIGNvbXBvbmVudCBzdXBwcmVzc2VzIHRoZSBidWlsdC1pbiBiZWhhdmlvciB0aGF0IGZvbGxvd3MgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBldmVudCBpcyBwcmV2ZW50ZWQgYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycywgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGRlZmF1bHQgYWN0aW9uIHdhcyBwcmV2ZW50ZWQuIE90aGVyd2lzZSwgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqL1xuICAgIGlzRGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudGVkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFRPVUNIX0VOQUJMRUQgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ2RhdGVpbnB1dHMtdG91Y2gtZW5hYmxlZCcpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGlzYWJsZWREYXRlc1ZhbGlkYXRvciA9IChpc0RhdGVEaXNhYmxlZCkgPT4ge1xuICAgIHJldHVybiAoY29udHJvbCkgPT4ge1xuICAgICAgICBpZiAoIWlzRGF0ZURpc2FibGVkIHx8ICFjb250cm9sLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IHtcbiAgICAgICAgICAgIGRpc2FibGVkRGF0ZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNEYXRlRGlzYWJsZWQoY29udHJvbC52YWx1ZSkgPyBlcnJvciA6IG51bGw7XG4gICAgfTtcbn07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xudmFyIERhdGVQaWNrZXJDb21wb25lbnRfMTtcbmNvbnN0IE1JTl9ET0NfTElOSyQzID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvYXBpL0RhdGVQaWNrZXJDb21wb25lbnQvI3RvYy1taW4nO1xuY29uc3QgTUFYX0RPQ19MSU5LJDMgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZGF0ZWlucHV0cy9hcGkvRGF0ZVBpY2tlckNvbXBvbmVudC8jdG9jLW1heCc7XG5jb25zdCBWQUxVRV9ET0NfTElOSyQzID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvZGF0ZXBpY2tlci8jdG9jLXVzaW5nLXdpdGgtanNvbic7XG5jb25zdCBERUZBVUxUX0ZPUk1BVCQxID0gJ2QnO1xuY29uc3QgVFdPX0RJR0lUX1lFQVJfTUFYJDEgPSA2ODtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIERhdGVQaWNrZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGVwaWNrZXIgJX0jdG9jLWJhc2ljLXVzYWdlKS5cbiAqL1xubGV0IERhdGVQaWNrZXJDb21wb25lbnQgPSBEYXRlUGlja2VyQ29tcG9uZW50XzEgPSBjbGFzcyBEYXRlUGlja2VyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih6b25lLCBsb2NhbGl6YXRpb24sIGNkciwgcG9wdXBTZXJ2aWNlLCB3cmFwcGVyLCByZW5kZXJlciwgaW5qZWN0b3IsIHBpY2tlclNlcnZpY2UsIGRpc2FibGVkRGF0ZXNTZXJ2aWNlLCB0b3VjaEVuYWJsZWQkJDEpIHtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMucGlja2VyU2VydmljZSA9IHBpY2tlclNlcnZpY2U7XG4gICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UgPSBkaXNhYmxlZERhdGVzU2VydmljZTtcbiAgICAgICAgdGhpcy50b3VjaEVuYWJsZWQgPSB0b3VjaEVuYWJsZWQkJDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUlkID0gYGstJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGFjdGl2ZSB2aWV3IHRoYXQgdGhlIENhbGVuZGFyIGluaXRpYWxseSByZW5kZXJzXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2FsZW5kYXJfdHlwZV9kYXRlcGlja2VyICV9I3RvYy1hY3RpdmUtdmlldykpLlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYWN0aXZlIHZpZXcgaXMgYG1vbnRoYC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBZb3UgaGF2ZSB0byBzZXQgYGFjdGl2ZVZpZXdgIHdpdGhpbiB0aGUgYHRvcFZpZXdgLWBib3R0b21WaWV3YCByYW5nZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IENhbGVuZGFyVmlld0VudW1bQ2FsZW5kYXJWaWV3RW51bS5tb250aF07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBib3R0b21tb3N0IENhbGVuZGFyIHZpZXcgdG8gd2hpY2ggdGhlIHVzZXIgY2FuIG5hdmlnYXRlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2FsZW5kYXJfdHlwZV9kYXRlcGlja2VyICV9I3RvYy1mb2N1c2VkLWRhdGVzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdHRvbVZpZXcgPSBDYWxlbmRhclZpZXdFbnVtW0NhbGVuZGFyVmlld0VudW0ubW9udGhdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgdG9wbW9zdCBDYWxlbmRhciB2aWV3IHRvIHdoaWNoIHRoZSB1c2VyIGNhbiBuYXZpZ2F0ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNhbGVuZGFyX3R5cGVfZGF0ZXBpY2tlciAlfSN0b2MtZm9jdXNlZC1kYXRlcykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b3BWaWV3ID0gQ2FsZW5kYXJWaWV3RW51bVtDYWxlbmRhclZpZXdFbnVtLmNlbnR1cnldO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBDYWxlbmRhciB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogLSBgaW5maW5pdGVgIChkZWZhdWx0KVxuICAgICAgICAgKiAtIGBjbGFzc2ljYFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxlbmRhclR5cGUgPSAnaW5maW5pdGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGVuYWJsZSBhbmltYXRpb24gd2hlbiBuYXZpZ2F0aW5nIHRvIHByZXZpb3VzL25leHQgQ2FsZW5kYXIgdmlldy5cbiAgICAgICAgICogQXBwbGllcyB0byB0aGUgW2BjbGFzc2ljYF0oeyUgc2x1ZyBhcGlfZGF0ZWlucHV0c19kYXRlcGlja2VyY29tcG9uZW50ICV9I3RvYy1jYWxlbmRhcnR5cGUpIENhbGVuZGFyIG9ubHkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVGhpcyBmZWF0dXJlIHVzZXMgdGhlIFtXZWIgQW5pbWF0aW9ucyBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfQW5pbWF0aW9uc19BUEkpLiBJbiBvcmRlciB0byBydW4gdGhlIGFuaW1hdGlvbiBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LCB5b3UgbmVlZCB0aGUgYHdlYi1hbmltYXRpb25zLWpzYCBwb2x5ZmlsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0ZUNhbGVuZGFyTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBgZGlzYWJsZWRgIHByb3BlcnR5IG9mIHRoZSBEYXRlUGlja2VyIGFuZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBhY3RpdmVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZF9kYXRlcGlja2VyICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIERhdGVQaWNrZXJcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZWFkb25seV9kYXRlcGlja2VyICV9I3RvYy1yZWFkLW9ubHktZGF0ZXBpY2tlcikpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgcmVhZC1vbmx5IHN0YXRlIG9mIHRoZSBEYXRlUGlja2VyIGlucHV0IGZpZWxkXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcmVhZG9ubHlfZGF0ZXBpY2tlciAlfSN0b2MtcmVhZC1vbmx5LWlucHV0KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gTm90ZSB0aGF0IGlmIHlvdSBzZXQgdGhlIFtgcmVhZG9ubHlgXSh7JSBzbHVnIGFwaV9kYXRlaW5wdXRzX2RhdGVwaWNrZXJjb21wb25lbnQgJX0jdG9jLXJlYWRvbmx5KSBwcm9wZXJ0eSB2YWx1ZSB0byBgdHJ1ZWAsXG4gICAgICAgICAqIHRoZSBpbnB1dCB3aWxsIGJlIHJlbmRlcmVkIGluIGEgcmVhZC1vbmx5IHN0YXRlIHJlZ2FyZGxlc3Mgb2YgdGhlIGByZWFkT25seUlucHV0YCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZE9ubHlJbnB1dCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBgbmF2aWdhdGlvbmAgcHJvcGVydHkgb2YgdGhlIENhbGVuZGFyXG4gICAgICAgICAqIGFuZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdmlnYXRpb24gc2lkZS1iYXIgaXMgZGlzcGxheWVkLlxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNpZGViYXJfZGF0ZXBpY2tlciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgc21hbGxlc3QgdmFsaWQgZGF0ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVyYW5nZXNfZGF0ZXBpY2tlciAlfSkpLlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYG1pbmAgdmFsdWUgaXMgYDE5MDAtMS0xYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWluID0gY2xvbmVEYXRlKE1JTl9EQVRFKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgYmlnZ2VzdCB2YWxpZCBkYXRlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXJhbmdlc19kYXRlcGlja2VyICV9KSkuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBgbWF4YCB2YWx1ZSBpcyBgMjA5OS0xMi0zMWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heCA9IGNsb25lRGF0ZShNQVhfREFURSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIHZhbGlkYXRpb24gZm9yIGluY29tcGxldGUgZGF0ZXMgaXMgdG8gYmUgZW5mb3JjZWQgd2hlbiBhIGZvcm0gaXMgYmVpbmcgdmFsaWRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgZm9jdXNlZCBkYXRlIG9mIHRoZSBDYWxlbmRhciBjb21wb25lbnRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjYWxlbmRhcl90eXBlX2RhdGVwaWNrZXIgJX0jdG9jLWZvY3VzZWQtZGF0ZXMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNlZERhdGUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBkYXRlIGZvcm1hdCB0aGF0IGlzIHVzZWQgdG8gZGlzcGxheSB0aGUgaW5wdXQgdmFsdWVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBmb3JtYXRzX2RhdGVwaWNrZXIgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9ybWF0IHZhbHVlIG9wdGlvbnM6XG4gICAgICAgICAqIC0gYHN0cmluZ2AgLSBQcm92aWRlIGEgYHN0cmluZ2AgaWYgYSBzaW5nbGUgZm9ybWF0IGlzIGdvaW5nIHRvIGJlIHVzZWQgcmVnYXJkbGVzcyB3aGV0aGVyIHRoZSBpbnB1dCBpcyBmb2N1c2VkIG9yIGJsdXJyZWQuXG4gICAgICAgICAqIC0gW2BGb3JtYXRTZXR0aW5nc2BdKHslIHNsdWcgYXBpX2RhdGVpbnB1dHNfZm9ybWF0c2V0dGluZ3MgJX0pIC0gVG8gZGlzcGxheSBkaWZmZXJlbnQgZm9ybWF0cyB3aGVuIHRoZSBjb21wb25lbnQgaXMgZm9jdXNlZCBvciBibHVycmVkLCBwcm92aWRlIGEgc2V0dGluZ3Mgb2JqZWN0IHdpdGggc3BlY2lmaWVkIGBpbnB1dEZvcm1hdGAgYW5kIGBkaXNwbGF5Rm9ybWF0YCB2YWx1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvcm1hdCA9IERFRkFVTFRfRk9STUFUJDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSB5ZWFyIHRvIGFzc3VtZSB0byBiZSBmcm9tIHRoZSBjdXJyZW50IGNlbnR1cnkgd2hlbiB0eXBpbmcgdHdvLWRpZ2l0IHllYXIgdmFsdWVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBmb3JtYXRzX2RhdGVwaWNrZXIgJX0jdG9jLXR3by1kaWdpdC15ZWFyLWZvcm1hdCkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2OCwgaW5kaWNhdGluZyB0aGF0IHR5cGluZyBhbnkgdmFsdWUgbGVzcyB0aGFuIDY5XG4gICAgICAgICAqIHdpbGwgYmUgYXNzdW1lZCB0byBiZSAyMHh4LCB3aGlsZSA2OSBhbmQgbGFyZ2VyIHdpbGwgYmUgYXNzdW1lZCB0byBiZSAxOXh4LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50d29EaWdpdFllYXJNYXggPSBUV09fRElHSVRfWUVBUl9NQVgkMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgaGludCB0aGUgRGF0ZVBpY2tlciBkaXNwbGF5cyB3aGVuIGl0cyB2YWx1ZSBpcyBgbnVsbGAuXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhcGxlc10oeyUgc2x1ZyBwbGFjZWhvbGRlcnNfZGF0ZXBpY2tlciAlfSkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogIDxrZW5kby1kYXRlcGlja2VyIHBsYWNlaG9sZGVyPVwiRW50ZXIgYmlydGggZGF0ZS4uLlwiPjwva2VuZG8tZGF0ZXBpY2tlcj5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBgdGFiaW5kZXhgIHByb3BlcnR5IG9mIHRoZSBEYXRlUGlja2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJpbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGUgaW5wdXQgZWxlbWVudCBvZiB0aGUgRGF0ZVBpY2tlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGl0bGUgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBidWlsdC1pbiBtaW4gb3IgbWF4IHZhbGlkYXRvcnMgYXJlIGVuZm9yY2VkIHdoZW4gdmFsaWRhdGluZyBhIGZvcm0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhbmdlVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIHZhbGlkYXRvciBmb3IgZGlzYWJsZWRcbiAgICAgICAgICogZGF0ZSByYW5nZXMgaXMgZW5mb3JjZWQgd2hlbiB2YWxpZGF0aW5nIGEgZm9ybVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX2RhdGVzX2RhdGVwaWNrZXIgJX0jdG9jLXZhbGlkYXRpb24pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1ZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGRpc3BsYXkgYSB3ZWVrIG51bWJlciBjb2x1bW4gaW4gdGhlIGBtb250aGAgdmlldyBvZiB0aGUgQ2FsZW5kYXJcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjYWxlbmRhcl90eXBlX2RhdGVwaWNrZXIgJX0jdG9jLXdlZWstbnVtYmVyLWNvbHVtbikpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgc2VsZWN0cyBhIG5ldyB2YWx1ZVxuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZXBpY2tlciAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGZvY3VzZXMgdGhlIGlucHV0IGVsZW1lbnRcbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGVwaWNrZXIgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IFRvIHdpcmUgdGhlIGV2ZW50IHByb2dyYW1tYXRpY2FsbHksIHVzZSB0aGUgYG9uRm9jdXNgIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogIDxrZW5kby1kYXRlcGlja2VyIChmb2N1cyk9XCJoYW5kbGVGb2N1cygpXCI+PC9rZW5kby1kYXRlcGlja2VyPlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAgICAgKiAgIHB1YmxpYyBoYW5kbGVGb2N1cygpOiB2b2lkIHtcbiAgICAgICAgICogICAgICBjb25zb2xlLmxvZyhcIkNvbXBvbmVudCBpcyBmb2N1c2VkXCIpO1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgaW5wdXQgZWxlbWVudCBnZXRzIGJsdXJyZWRcbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGVwaWNrZXIgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IFRvIHdpcmUgdGhlIGV2ZW50IHByb2dyYW1tYXRpY2FsbHksIHVzZSB0aGUgYG9uQmx1cmAgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLWRhdGVwaWNrZXIgKGJsdXIpPVwiaGFuZGxlQmx1cigpXCI+PC9rZW5kby1kYXRlcGlja2VyPlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAgICAgKiAgIHB1YmxpYyBoYW5kbGVCbHVyKCk6IHZvaWQge1xuICAgICAgICAgKiAgICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50IGlzIGJsdXJyZWRcIik7XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHBvcHVwIGlzIGFib3V0IHRvIG9wZW4uXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgdGhlIGV2ZW50LCB0aGUgcG9wdXAgd2lsbCByZW1haW4gY2xvc2VkXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19kYXRlcGlja2VyICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gY2xvc2UuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgdGhlIGV2ZW50LCB0aGUgcG9wdXAgd2lsbCByZW1haW4gb3BlblxuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZXBpY2tlciAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwcGVyQ2xhc3NlcyA9IHRydWU7XG4gICAgICAgIHRoaXMucG9wdXBVSUQgPSBndWlkKCk7XG4gICAgICAgIHRoaXMuX3BvcHVwU2V0dGluZ3MgPSB7IGFuaW1hdGU6IHRydWUgfTtcbiAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ29udHJvbENoYW5nZSA9IG5vb3A7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCA9IG5vb3A7XG4gICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLm1pblZhbGlkYXRlRm4gPSBub29wO1xuICAgICAgICB0aGlzLm1heFZhbGlkYXRlRm4gPSBub29wO1xuICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNWYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5pbmNvbXBsZXRlVmFsaWRhdG9yID0gbm9vcDtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuX3NpemUgPSAnbWVkaXVtJztcbiAgICAgICAgdGhpcy5fcm91bmRlZCA9ICdtZWRpdW0nO1xuICAgICAgICB0aGlzLl9maWxsTW9kZSA9ICdzb2xpZCc7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICB0aGlzLnBpY2tlclN1YnNjcmlwdGlvbnMgPSB0aGlzLnBpY2tlclNlcnZpY2Uub25Gb2N1cy5zdWJzY3JpYmUodGhpcy5oYW5kbGVGb2N1cy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5waWNrZXJTdWJzY3JpcHRpb25zLmFkZCh0aGlzLnBpY2tlclNlcnZpY2Uub25CbHVyLnN1YnNjcmliZSh0aGlzLmhhbmRsZUJsdXIuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnBpY2tlclN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucGlja2VyU2VydmljZS5zYW1lRGF0ZVNlbGVjdGVkLnN1YnNjcmliZSh0aGlzLmhhbmRsZVNhbWVTZWxlY3Rpb24uYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnBpY2tlclN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucGlja2VyU2VydmljZS5kYXRlQ29tcGxldGVuZXNzQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmhhbmRsZURhdGVDb21wbGV0ZW5lc3NDaGFuZ2UuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGNlbGxUZW1wbGF0ZVJlZih0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLmNlbGxUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IG1vbnRoQ2VsbFRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMubW9udGhDZWxsVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB5ZWFyQ2VsbFRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMueWVhckNlbGxUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGRlY2FkZUNlbGxUZW1wbGF0ZVJlZih0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLmRlY2FkZUNlbGxUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGNlbnR1cnlDZWxsVGVtcGxhdGVSZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5jZW50dXJ5Q2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgd2Vla051bWJlclRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMud2Vla051bWJlclRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgaGVhZGVyVGl0bGVUZW1wbGF0ZVJlZih0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLmhlYWRlclRpdGxlVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBuYXZpZ2F0aW9uSXRlbVRlbXBsYXRlUmVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBwb3B1cCBvcHRpb25zIG9mIHRoZSBEYXRlUGlja2VyLlxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICAgKiAtIGBhbmltYXRlOiBCb29sZWFuYCZtZGFzaDtDb250cm9scyB0aGUgcG9wdXAgYW5pbWF0aW9uLiBCeSBkZWZhdWx0LCB0aGUgb3BlbiBhbmQgY2xvc2UgYW5pbWF0aW9ucyBhcmUgZW5hYmxlZC5cbiAgICAgKiAtIGBhcHBlbmRUbzogJ3Jvb3QnIHwgJ2NvbXBvbmVudCcgfCBWaWV3Q29udGFpbmVyUmVmYCZtZGFzaDtDb250cm9scyB0aGUgcG9wdXAgY29udGFpbmVyLiBCeSBkZWZhdWx0LCB0aGUgcG9wdXAgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgcm9vdCBjb21wb25lbnQuXG4gICAgICogLSBgcG9wdXBDbGFzczogU3RyaW5nYCZtZGFzaDtTcGVjaWZpZXMgYSBsaXN0IG9mIENTUyBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgdG8gc3R5bGUgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIHNldCBwb3B1cFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX3BvcHVwU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB7IGFuaW1hdGU6IHRydWUgfSwgc2V0dGluZ3MpO1xuICAgIH1cbiAgICBnZXQgcG9wdXBTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVwU2V0dGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgdmFsdWUgb2YgdGhlIERhdGVQaWNrZXIgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogPiBUaGUgYHZhbHVlYCBoYXMgdG8gYmUgYSB2YWxpZFxuICAgICAqIFtKYXZhU2NyaXB0IGBEYXRlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZSkgaW5zdGFuY2UuXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5VmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IHRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGF0ZXMgb2YgdGhlIERhdGVQaWNrZXIgdGhhdCB3aWxsIGJlIGRpc2FibGVkXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZF9kYXRlc19kYXRlcGlja2VyICV9KSkuXG4gICAgICovXG4gICAgc2V0IGRpc2FibGVkRGF0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWREYXRlcyA9IHZhbHVlO1xuICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmluaXRpYWxpemUodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWREYXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkRGF0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzbWFsbCdgXG4gICAgICogKiBgJ21lZGl1bSdgIChEZWZhdWx0KVxuICAgICAqICogYCdsYXJnZSdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKlxuICAgICAqL1xuICAgIHNldCBzaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0U2l6ZUNsYXNzKCdpbnB1dCcsIHRoaXMuc2l6ZSkpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLm5hdGl2ZUVsZW1lbnQsIGdldFNpemVDbGFzcygnaW5wdXQnLCB0aGlzLnNpemUpKTtcbiAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldFNpemVDbGFzcygnaW5wdXQnLCBzaXplKSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLm5hdGl2ZUVsZW1lbnQsIGdldFNpemVDbGFzcygnaW5wdXQnLCBzaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9yZGVyIHJhZGl1cyBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgJ3NtYWxsJ2BcbiAgICAgKiAqIGAnbWVkaXVtJ2AgKERlZmF1bHQpXG4gICAgICogKiBgJ2xhcmdlJ2BcbiAgICAgKiAqIGAnZnVsbCdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKlxuICAgICAqL1xuICAgIHNldCByb3VuZGVkKHJvdW5kZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0Um91bmRlZENsYXNzKHRoaXMucm91bmRlZCkpO1xuICAgICAgICBpZiAocm91bmRlZCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0Um91bmRlZENsYXNzKHJvdW5kZWQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3VuZGVkID0gcm91bmRlZDtcbiAgICB9XG4gICAgZ2V0IHJvdW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3VuZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmaWxsTW9kZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgJ3NvbGlkJ2AgKERlZmF1bHQpXG4gICAgICogKiBgJ2ZsYXQnYFxuICAgICAqICogYCdvdXRsaW5lJ2BcbiAgICAgKiAqIGBudWxsYFxuICAgICAqXG4gICAgICovXG4gICAgc2V0IGZpbGxNb2RlKGZpbGxNb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldEZpbGxNb2RlQ2xhc3MoJ2lucHV0JywgdGhpcy5maWxsTW9kZSkpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLm5hdGl2ZUVsZW1lbnQsIGdldEZpbGxNb2RlQ2xhc3MoJ2J1dHRvbicsIHRoaXMuZmlsbE1vZGUpKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBgay1idXR0b24tJHt0aGlzLmZpbGxNb2RlfS1iYXNlYCk7XG4gICAgICAgIGlmIChmaWxsTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBnZXRGaWxsTW9kZUNsYXNzKCdidXR0b24nLCBmaWxsTW9kZSkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBgay1idXR0b24tJHtmaWxsTW9kZX0tYmFzZWApO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0RmlsbE1vZGVDbGFzcygnaW5wdXQnLCBmaWxsTW9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZpbGxNb2RlID0gZmlsbE1vZGU7XG4gICAgfVxuICAgIGdldCBmaWxsTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxNb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlucHV0Um9sZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE9ubHlJbnB1dCA/ICdsaXN0Ym94JyA6ICdzcGluYnV0dG9uJztcbiAgICB9XG4gICAgZ2V0IGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cbiAgICBzZXQgaXNBY3RpdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdmFsdWU7XG4gICAgICAgIGlmICghdGhpcy53cmFwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgJ2stZm9jdXMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ2stZm9jdXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2hvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3c7XG4gICAgfVxuICAgIHNldCBzaG93KHNob3cpIHtcbiAgICAgICAgaWYgKHNob3cgJiYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBza2lwWm9uZSA9ICFzaG93ICYmICghdGhpcy5fc2hvdyB8fCAhaGFzT2JzZXJ2ZXJzKHRoaXMuY2xvc2UpKTtcbiAgICAgICAgaWYgKCFza2lwWm9uZSkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVQb3B1cChzaG93KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVQb3B1cChzaG93KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXNlZCBieSB0aGUgVGV4dEJveENvbnRhaW5lciB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMudmFsdWUgJiYgdGhpcy5pbnB1dC5pc0VtcHR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXphdGlvblxuICAgICAgICAgICAgLmNoYW5nZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jZHIubWFya0ZvckNoZWNrKCkpO1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSB0aGlzLmluamVjdG9yLmdldChOZ0NvbnRyb2wsIG51bGwpO1xuICAgICAgICBpZiAodGhpcy53cmFwcGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudENsYXNzZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlTZXR0aW5ncygpO1xuICAgICAgICBpZiAoY2hhbmdlcy5taW4gfHwgY2hhbmdlcy5tYXggfHwgY2hhbmdlcy5yYW5nZVZhbGlkYXRpb24gfHwgY2hhbmdlcy5kaXNhYmxlZERhdGVzVmFsaWRhdGlvbiB8fCBjaGFuZ2VzLmRpc2FibGVkRGF0ZXMgfHwgY2hhbmdlcy5pbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWluVmFsaWRhdGVGbiA9IHRoaXMucmFuZ2VWYWxpZGF0aW9uID8gbWluVmFsaWRhdG9yKHRoaXMubWluKSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLm1heFZhbGlkYXRlRm4gPSB0aGlzLnJhbmdlVmFsaWRhdGlvbiA/IG1heFZhbGlkYXRvcih0aGlzLm1heCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzVmFsaWRhdGVGbiA9IHRoaXMuZGlzYWJsZWREYXRlc1ZhbGlkYXRpb24gPyBkaXNhYmxlZERhdGVzVmFsaWRhdG9yKHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UuaXNEYXRlRGlzYWJsZWQpIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMuaW5jb21wbGV0ZVZhbGlkYXRvciA9IHRoaXMuaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uID8gaW5jb21wbGV0ZURhdGVWYWxpZGF0b3IoKSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2luZG93Qmx1clN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dCbHVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb21FdmVudHMuZm9yRWFjaCh1bmJpbmRDYWxsYmFjayA9PiB1bmJpbmRDYWxsYmFjaygpKTtcbiAgICAgICAgdGhpcy5waWNrZXJTdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgb3BlbiBzdGF0ZSBvZiB0aGUgcG9wdXAuXG4gICAgICovXG4gICAgZ2V0IGlzT3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBjbG9uZURhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHZhbGlkYXRlKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluVmFsaWRhdGVGbihjb250cm9sKSB8fCB0aGlzLm1heFZhbGlkYXRlRm4oY29udHJvbCkgfHwgdGhpcy5kaXNhYmxlZERhdGVzVmFsaWRhdGVGbihjb250cm9sKSB8fCB0aGlzLmluY29tcGxldGVWYWxpZGF0b3IoY29udHJvbCwgdGhpcy5pbnB1dCAmJiB0aGlzLmlucHV0LmlzRGF0ZUluY29tcGxldGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIERhdGVQaWNrZXIgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogdGVtcGxhdGU6IGBcbiAgICAgKiAgPGJ1dHRvbiAoY2xpY2spPVwiZGF0ZXBpY2tlci5mb2N1cygpXCI+Rm9jdXMgZGF0ZSBwaWNrZXI8L2J1dHRvbj5cbiAgICAgKiAgPGtlbmRvLWRhdGVwaWNrZXIgI2RhdGVwaWNrZXI+PC9rZW5kby1kYXRlcGlja2VyPlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIERhdGVQaWNrZXIgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgICh0aGlzLmNhbGVuZGFyIHx8IHRoaXMuaW5wdXQpWydibHVyJ10oKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLXN0cmluZy1saXRlcmFsXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHBvcHVwLiBJZiB5b3UgdXNlIHRoZSBgdG9nZ2xlYCBtZXRob2QgdG8gc2hvdyBvciBoaWRlIHRoZSBwb3B1cCxcbiAgICAgKiB0aGUgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyBkbyBub3QgZmlyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaG93IC0gVGhlIHN0YXRlIG9mIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICB0b2dnbGUoc2hvdykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUoKHNob3cgPT09IHVuZGVmaW5lZCkgPyAhdGhpcy5zaG93IDogc2hvdyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlSWNvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmZvY3VzSW5wdXQoKTtcbiAgICAgICAgLy9YWFg6IGV4cGxpY2l0bHkgY2FsbCB0aGUgaGFuZGxlRm9jdXMgaGFuZGxlciBoZXJlXG4gICAgICAgIC8vZHVlIHRvIGFzeW5jIElFIGZvY3VzIGV2ZW50XG4gICAgICAgIHRoaXMuaGFuZGxlRm9jdXMoKTtcbiAgICAgICAgdGhpcy5zaG93ID0gIXRoaXMuc2hvdztcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZWRvd24oYXJncykge1xuICAgICAgICBhcmdzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuZm9jdXNJbnB1dCgpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ29udHJvbENoYW5nZShjbG9uZURhdGUodmFsdWUpKTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KGNsb25lRGF0ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UodGhpcy5pbnB1dC5mb3JtYXRTZWN0aW9ucy50aW1lID8gdmFsdWUgOiB0aGlzLm1lcmdlVGltZSh2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHBvcHVwQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdrLWNhbGVuZGFyLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAnay1ncm91cCcsXG4gICAgICAgICAgICAnay1yZXNldCdcbiAgICAgICAgXS5jb25jYXQodGhpcy5wb3B1cFNldHRpbmdzLnBvcHVwQ2xhc3MgfHwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGFwcGVuZFRvKCkge1xuICAgICAgICBjb25zdCB7IGFwcGVuZFRvIH0gPSB0aGlzLnBvcHVwU2V0dGluZ3M7XG4gICAgICAgIGlmICghYXBwZW5kVG8gfHwgYXBwZW5kVG8gPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwZW5kVG8gPT09ICdjb21wb25lbnQnID8gdGhpcy5jb250YWluZXIgOiBhcHBlbmRUbztcbiAgICB9XG4gICAgZ2V0IGlucHV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrZXJTZXJ2aWNlLmlucHV0O1xuICAgIH1cbiAgICBnZXQgY2FsZW5kYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlclNlcnZpY2UuY2FsZW5kYXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBtZXJnZVRpbWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgJiYgdmFsdWUgPyBzZXRUaW1lKHZhbHVlLCB0aGlzLnZhbHVlKSA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlS2V5ZG93bihlKSB7XG4gICAgICAgIGNvbnN0IHsgYWx0S2V5LCBzaGlmdEtleSwga2V5Q29kZSwgdGFyZ2V0IH0gPSBlO1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Fc2NhcGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbHRLZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLkFycm93RG93biAmJiAhdGhpcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLkFycm93VXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5FbnRlciAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdrLWNhbGVuZGFyJykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gRG9uJ3Qgc3VibWl0IGZvcm0gb24gZGF0ZSBzZWxlY3Rpb24gaW4gcG9wdXBcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5UYWIgJiYgdGhpcy5zaG93ICYmIHRoaXMuY2FsZW5kYXIuaXNBY3RpdmUgJiYgaXNUYWJFeGl0aW5nQ2FsZW5kYXIodGhpcy5jYWxlbmRhclR5cGUsIHRhcmdldCwgc2hpZnRLZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b2dnbGVQb3B1cChzaG93KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IFByZXZlbnRhYmxlRXZlbnQoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93ICYmIHNob3cpIHtcbiAgICAgICAgICAgIHRoaXMub3Blbi5lbWl0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zaG93ICYmICFzaG93KSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RvZ2dsZShzaG93KTtcbiAgICAgICAgdGhpcy50b2dnbGVGb2N1cygpO1xuICAgIH1cbiAgICBfdG9nZ2xlKHNob3cpIHtcbiAgICAgICAgaWYgKHNob3cgPT09IHRoaXMuX3Nob3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaG93ID0gc2hvdztcbiAgICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiB0aGlzLndyYXBwZXIsXG4gICAgICAgICAgICAgICAgYW5jaG9yQWxpZ246IHsgdmVydGljYWw6ICdib3R0b20nLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfSxcbiAgICAgICAgICAgICAgICBhbmltYXRlOiB0aGlzLnBvcHVwU2V0dGluZ3MuYW5pbWF0ZSxcbiAgICAgICAgICAgICAgICBhcHBlbmRUbzogdGhpcy5hcHBlbmRUbyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLnBvcHVwVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgcG9wdXBBbGlnbjogeyB2ZXJ0aWNhbDogJ3RvcCcsIGhvcml6b250YWw6IGRpcmVjdGlvbiB9LFxuICAgICAgICAgICAgICAgIHBvcHVwQ2xhc3M6IHRoaXMucG9wdXBDbGFzc2VzLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uTW9kZTogJ2Fic29sdXRlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5wb3B1cFVJRCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMucG9wdXBSZWYucG9wdXBBbmNob3JWaWV3cG9ydExlYXZlLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNob3cgPSBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9jdXNJbnB1dCgpIHtcbiAgICAgICAgaWYgKHRoaXMudG91Y2hFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgIH1cbiAgICB0b2dnbGVGb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvdykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGVuZGFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMudG91Y2hFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuaW5wdXQuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeVNldHRpbmdzKCkge1xuICAgICAgICBpZiAoIWlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ZhbGlkUmFuZ2UodGhpcy5taW4sIHRoaXMubWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWF4IHZhbHVlIHNob3VsZCBiZSBiaWdnZXIgdGhhbiB0aGUgbWluLiBTZWUgJHtNSU5fRE9DX0xJTkskM30gYW5kICR7TUFYX0RPQ19MSU5LJDN9LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAndmFsdWUnIHNob3VsZCBiZSBhIHZhbGlkIEphdmFTY3JpcHQgRGF0ZSBpbnN0YW5jZS4gQ2hlY2sgJHtWQUxVRV9ET0NfTElOSyQzfSBmb3IgcG9zc2libGUgcmVzb2x1dGlvbi5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kRXZlbnRzKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLnB1c2godGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWRvd24uYmluZCh0aGlzKSkpO1xuICAgICAgICBpZiAoaXNXaW5kb3dBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dCbHVyU3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KHdpbmRvdywgJ2JsdXInKS5zdWJzY3JpYmUodGhpcy5oYW5kbGVXaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUZvY3VzKCkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMub25Gb2N1cykpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVXaW5kb3dCbHVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgfVxuICAgIGhhbmRsZUJsdXIoYXJncykge1xuICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gYXJncyAmJiBjdXJyZW50Rm9jdXNUYXJnZXQoYXJncyk7XG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ICYmICh0aGlzLmlucHV0LmNvbnRhaW5zRWxlbWVudChjdXJyZW50VGFyZ2V0KSB8fFxuICAgICAgICAgICAgKHRoaXMuY2FsZW5kYXIgJiYgdGhpcy5jYWxlbmRhci5jb250YWluc0VsZW1lbnQoY3VycmVudFRhcmdldCkpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkJsdXIpIHx8ICh0aGlzLnNob3cgJiYgaGFzT2JzZXJ2ZXJzKHRoaXMuY2xvc2UpKSB8fCByZXF1aXJlc1pvbmVPbkJsdXIodGhpcy5jb250cm9sKSkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibHVyQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmx1ckNvbXBvbmVudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJsdXJDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTsgLy8gb3JkZXIgaXMgaW1wb3J0YW50IMKvXFxfKOODhClfL8KvXG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCgpO1xuICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KCk7XG4gICAgfVxuICAgIGhhbmRsZVNhbWVTZWxlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNJbnB1dCgpO1xuICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRGF0ZUNvbXBsZXRlbmVzc0NoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpKTtcbiAgICB9XG4gICAgc2V0Q29tcG9uZW50Q2xhc3NlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0U2l6ZUNsYXNzKCdpbnB1dCcsIHRoaXMuc2l6ZSkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBnZXRTaXplQ2xhc3MoJ2J1dHRvbicsIHRoaXMuc2l6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvdW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldFJvdW5kZWRDbGFzcyh0aGlzLnJvdW5kZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWxsTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0RmlsbE1vZGVDbGFzcygnaW5wdXQnLCB0aGlzLmZpbGxNb2RlKSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLm5hdGl2ZUVsZW1lbnQsIGdldEZpbGxNb2RlQ2xhc3MoJ2J1dHRvbicsIHRoaXMuZmlsbE1vZGUpKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy50b2dnbGVCdXR0b24ubmF0aXZlRWxlbWVudCwgYGstYnV0dG9uLSR7dGhpcy5maWxsTW9kZX0tYmFzZWApO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnY29udGFpbmVyJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmLCBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpZXdDb250YWluZXJSZWYpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250YWluZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgncG9wdXBUZW1wbGF0ZScsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgndG9nZ2xlQnV0dG9uJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b2dnbGVCdXR0b25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnY2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibW9udGhDZWxsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdtb250aENlbGxUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtb250aENlbGxUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5ZWFyQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgneWVhckNlbGxUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1llYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwieWVhckNlbGxUZW1wbGF0ZVJlZlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGVjYWRlQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVjYWRlQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnZGVjYWRlQ2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVjYWRlQ2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNlbnR1cnlDZWxsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdjZW50dXJ5Q2VsbFRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZW50dXJ5Q2VsbFRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoJ3dlZWtOdW1iZXJUZW1wbGF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1dlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVdKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhlYWRlclRpdGxlVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdoZWFkZXJUaXRsZVRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWFkZXJUaXRsZVRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm5hdmlnYXRpb25JdGVtVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCduYXZpZ2F0aW9uSXRlbVRlbXBsYXRlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZV0pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0aW9uSXRlbVRlbXBsYXRlUmVmXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNhYmxlSWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImJvdHRvbVZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRvcFZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNhbGVuZGFyVHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVDYWxlbmRhck5hdmlnYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmVhZE9ubHlJbnB1dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cFNldHRpbmdzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm5hdmlnYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c2VkRGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0d29EaWdpdFllYXJNYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkRGF0ZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlVmFsaWRhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkRGF0ZXNWYWxpZGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaXplXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsTW9kZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCdmb2N1cycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2JsdXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwib25CbHVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwib3BlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNsb3NlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kYXRlcGlja2VyJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstaW5wdXQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndyYXBwZXJDbGFzc2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBEYXRlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZENsYXNzXCIsIG51bGwpO1xuRGF0ZVBpY2tlckNvbXBvbmVudCA9IERhdGVQaWNrZXJDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvLWRhdGVwaWNrZXInLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVQaWNrZXJDb21wb25lbnRfMSksIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVQaWNrZXJDb21wb25lbnRfMSksIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IEtlbmRvSW5wdXQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVQaWNrZXJDb21wb25lbnRfMSkgfSxcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBQaWNrZXJTZXJ2aWNlLFxuICAgICAgICAgICAgRGlzYWJsZWREYXRlc1NlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5kYXRlcGlja2VyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWRhdGVwaWNrZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvRGF0ZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLXRvZGF5PVwia2VuZG8uZGF0ZXBpY2tlci50b2RheXxUaGUgbGFiZWwgZm9yIHRoZSB0b2RheSBidXR0b24gaW4gdGhlIGNhbGVuZGFyIGhlYWRlclwiXG4gICAgICAgICAgICB0b2RheT1cIlRvZGF5XCJcblxuICAgICAgICAgICAgaTE4bi10b2dnbGU9XCJrZW5kby5kYXRlcGlja2VyLnRvZ2dsZXxUaGUgdGl0bGUgb2YgdGhlIHRvZ2dsZSBidXR0b24gaW4gdGhlIGRhdGVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIHRvZ2dsZT1cIlRvZ2dsZSBjYWxlbmRhclwiXG5cbiAgICAgICAgICAgIGkxOG4tcHJldkJ1dHRvblRpdGxlPVwia2VuZG8uZGF0ZXBpY2tlci5wcmV2QnV0dG9uVGl0bGV8VGhlIHRpdGxlIG9mIHRoZSBwcmV2aW91cyBidXR0b24gaW4gdGhlIENsYXNzaWMgY2FsZW5kYXJcIlxuICAgICAgICAgICAgcHJldkJ1dHRvblRpdGxlPVwiTmF2aWdhdGUgdG8gcHJldmlvdXMgdmlld1wiXG5cbiAgICAgICAgICAgIGkxOG4tbmV4dEJ1dHRvblRpdGxlPVwia2VuZG8uZGF0ZXBpY2tlci5uZXh0QnV0dG9uVGl0bGV8VGhlIHRpdGxlIG9mIHRoZSBuZXh0IGJ1dHRvbiBpbiB0aGUgQ2xhc3NpYyBjYWxlbmRhclwiXG4gICAgICAgICAgICBuZXh0QnV0dG9uVGl0bGU9XCJOYXZpZ2F0ZSB0byBuZXh0IHZpZXdcIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8a2VuZG8tZGF0ZWlucHV0XG4gICAgICAgICAgICAjaW5wdXRcbiAgICAgICAgICAgIFtyb2xlXT1cImlucHV0Um9sZVwiXG4gICAgICAgICAgICBbZm9jdXNhYmxlSWRdPVwiZm9jdXNhYmxlSWRcIlxuICAgICAgICAgICAgW2hhc1BvcHVwXT1cInRydWVcIlxuICAgICAgICAgICAgW2lzUG9wdXBPcGVuXT1cInNob3dcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seSB8fCByZWFkT25seUlucHV0XCJcbiAgICAgICAgICAgIFthcmlhUmVhZE9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgW3RhYmluZGV4XT1cInRhYmluZGV4XCJcbiAgICAgICAgICAgIFt0aXRsZV09XCJ0aXRsZVwiXG4gICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICBbdHdvRGlnaXRZZWFyTWF4XT1cInR3b0RpZ2l0WWVhck1heFwiXG4gICAgICAgICAgICBbZm9ybWF0UGxhY2Vob2xkZXJdPVwiZm9ybWF0UGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgIFtpbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb25dPVwiaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uXCJcbiAgICAgICAgICAgIFtmaWxsTW9kZV09XCJudWxsXCJcbiAgICAgICAgICAgIFtyb3VuZGVkXT1cIm51bGxcIlxuICAgICAgICAgICAgW3NpemVdPVwibnVsbFwiXG4gICAgICAgICAgICBbdmFsdWVdPVwidmFsdWVcIlxuICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZUlucHV0Q2hhbmdlKCRldmVudClcIlxuICAgICAgICA+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICN0b2dnbGVCdXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWlucHV0LWJ1dHRvbiBrLWJ1dHRvbiBrLWljb24tYnV0dG9uXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCItMVwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCd0b2dnbGUnKVwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ3RvZ2dsZScpXCJcbiAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICBjbGljazogaGFuZGxlSWNvbkNsaWNrLFxuICAgICAgICAgICAgICAgIG1vdXNlZG93bjogaGFuZGxlTW91c2Vkb3duXG4gICAgICAgICAgICB9XCJcbiAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWJ1dHRvbi1pY29uIGstaWNvbiBrLWktY2FsZW5kYXJcIj48L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8bmctY29udGFpbmVyICNjb250YWluZXI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjcG9wdXBUZW1wbGF0ZT5cbiAgICAgICAgICAgIDxrZW5kby1jYWxlbmRhclxuICAgICAgICAgICAgICAgICNjYWxlbmRhclxuICAgICAgICAgICAgICAgIFt0eXBlXT1cImNhbGVuZGFyVHlwZVwiXG4gICAgICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICBbbmF2aWdhdGlvbl09XCJuYXZpZ2F0aW9uXCJcbiAgICAgICAgICAgICAgICBbYW5pbWF0ZU5hdmlnYXRpb25dPVwiYW5pbWF0ZUNhbGVuZGFyTmF2aWdhdGlvblwiXG4gICAgICAgICAgICAgICAgW2FjdGl2ZVZpZXddPVwiYWN0aXZlVmlld1wiXG4gICAgICAgICAgICAgICAgW2JvdHRvbVZpZXddPVwiYm90dG9tVmlld1wiXG4gICAgICAgICAgICAgICAgW3RvcFZpZXddPVwidG9wVmlld1wiXG4gICAgICAgICAgICAgICAgW3dlZWtOdW1iZXJdPVwid2Vla051bWJlclwiXG4gICAgICAgICAgICAgICAgW2NlbGxUZW1wbGF0ZV09XCJjZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFttb250aENlbGxUZW1wbGF0ZV09XCJtb250aENlbGxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgW3llYXJDZWxsVGVtcGxhdGVdPVwieWVhckNlbGxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgW2RlY2FkZUNlbGxUZW1wbGF0ZV09XCJkZWNhZGVDZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtjZW50dXJ5Q2VsbFRlbXBsYXRlXT1cImNlbnR1cnlDZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFt3ZWVrTnVtYmVyVGVtcGxhdGVdPVwid2Vla051bWJlclRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbaGVhZGVyVGl0bGVUZW1wbGF0ZV09XCJoZWFkZXJUaXRsZVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbbmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZV09XCJuYXZpZ2F0aW9uSXRlbVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbZm9jdXNlZERhdGVdPVwiZm9jdXNlZERhdGVcIlxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZUNoYW5nZShtZXJnZVRpbWUoJGV2ZW50KSlcIlxuICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAga2V5ZG93bjogaGFuZGxlS2V5ZG93blxuICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgICAgICAgICBbZGlzYWJsZWREYXRlc109XCJkaXNhYmxlZERhdGVzXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8a2VuZG8tY2FsZW5kYXItbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgW3RvZGF5XT1cImxvY2FsaXphdGlvbi5nZXQoJ3RvZGF5JylcIlxuICAgICAgICAgICAgICAgICAgICBbcHJldkJ1dHRvblRpdGxlXT1cImxvY2FsaXphdGlvbi5nZXQoJ3ByZXZCdXR0b25UaXRsZScpXCJcbiAgICAgICAgICAgICAgICAgICAgW25leHRCdXR0b25UaXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCduZXh0QnV0dG9uVGl0bGUnKVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwva2VuZG8tY2FsZW5kYXItbWVzc2FnZXM+XG4gICAgICAgICAgICA8L2tlbmRvLWNhbGVuZGFyPlxuICAgICAgICA8bmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oOSwgT3B0aW9uYWwoKSksIF9fcGFyYW0oOSwgSW5qZWN0KFRPVUNIX0VOQUJMRUQpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05nWm9uZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIFBvcHVwU2VydmljZSxcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBJbmplY3RvcixcbiAgICAgICAgUGlja2VyU2VydmljZSxcbiAgICAgICAgRGlzYWJsZWREYXRlc1NlcnZpY2UsIEJvb2xlYW5dKVxuXSwgRGF0ZVBpY2tlckNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBUSU1FX1BBUlQgPSB7XG4gICAgZGF5cGVyaW9kOiAnZGF5cGVyaW9kJyxcbiAgICBob3VyOiAnaG91cicsXG4gICAgbWlsbGlzZWNvbmQ6ICdtaWxsaXNlY29uZCcsXG4gICAgbWludXRlOiAnbWludXRlJyxcbiAgICBzZWNvbmQ6ICdzZWNvbmQnXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdGltZVJhbmdlVmFsaWRhdG9yID0gKG1pbiwgbWF4KSA9PiB7XG4gICAgcmV0dXJuIChjb250cm9sKSA9PiB7XG4gICAgICAgIGlmICghbWluIHx8ICFtYXggfHwgIWNvbnRyb2wudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVyciA9IHtcbiAgICAgICAgICAgIHRpbWVSYW5nZUVycm9yOiB7XG4gICAgICAgICAgICAgICAgbWF4VmFsdWU6IG1heCxcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZTogbWluLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjb250cm9sLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpc0luVGltZVJhbmdlKGNvbnRyb2wudmFsdWUsIG1pbiwgbWF4KSA/IG51bGwgOiBlcnI7XG4gICAgfTtcbn07XG5cbnZhciBUaW1lUGlja2VyQ29tcG9uZW50XzE7XG5jb25zdCBWQUxVRV9ET0NfTElOSyQ0ID0gJ2h0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRlaW5wdXRzL3RpbWVwaWNrZXIvI3RvYy1pbnRlZ3JhdGlvbi13aXRoLWpzb24nO1xuY29uc3QgSU5UTF9EQVRFX0ZPUk1BVCA9ICdodHRwczovL2dpdGh1Yi5jb20vdGVsZXJpay9rZW5kby1pbnRsL2Jsb2IvbWFzdGVyL2RvY3MvZGF0ZS1mb3JtYXR0aW5nL2luZGV4Lm1kJztcbmNvbnN0IGZvcm1hdFJlZ0V4cCA9IG5ldyBSZWdFeHAoYCR7VElNRV9QQVJULmhvdXJ9fCR7VElNRV9QQVJULm1pbnV0ZX18JHtUSU1FX1BBUlQuc2Vjb25kfXwke1RJTUVfUEFSVC5taWxsaXNlY29uZH18JHtUSU1FX1BBUlQuZGF5cGVyaW9kfXxsaXRlcmFsYCk7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBUaW1lUGlja2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld190aW1lcGlja2VyICV9I3RvYy1iYXNpYy11c2FnZSkuXG4gKi9cbmxldCBUaW1lUGlja2VyQ29tcG9uZW50ID0gVGltZVBpY2tlckNvbXBvbmVudF8xID0gY2xhc3MgVGltZVBpY2tlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioem9uZSwgbG9jYWxpemF0aW9uLCBjZHIsIHBvcHVwU2VydmljZSwgd3JhcHBlciwgcmVuZGVyZXIsIGluamVjdG9yLCBwaWNrZXJTZXJ2aWNlLCBpbnRsLCB0b3VjaEVuYWJsZWQkJDEpIHtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMucGlja2VyU2VydmljZSA9IHBpY2tlclNlcnZpY2U7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMudG91Y2hFbmFibGVkID0gdG91Y2hFbmFibGVkJCQxO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2FibGVJZCA9IGBrLSR7Z3VpZCgpfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBkaXNhYmxlZGAgcHJvcGVydHkgb2YgdGhlIFRpbWVQaWNrZXIgYW5kXG4gICAgICAgICAqIGRldGVybWluZXMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGFjdGl2ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX3RpbWVwaWNrZXIgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHJlYWQtb25seSBzdGF0ZSBvZiB0aGUgVGltZVBpY2tlclxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlYWRvbmx5X3RpbWVwaWNrZXIgJX0jdG9jLXJlYWQtb25seS10aW1lcGlja2VyKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIFRpbWVQaWNrZXIgaW5wdXQgZmllbGRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZWFkb25seV90aW1lcGlja2VyICV9I3RvYy1yZWFkLW9ubHktaW5wdXQpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlIHRoYXQgaWYgeW91IHNldCB0aGUgW2ByZWFkb25seWBdKHslIHNsdWcgYXBpX2RhdGVpbnB1dHNfdGltZXBpY2tlcmNvbXBvbmVudCAlfSN0b2MtcmVhZG9ubHkpIHByb3BlcnR5IHZhbHVlIHRvIGB0cnVlYCxcbiAgICAgICAgICogdGhlIGlucHV0IHdpbGwgYmUgcmVuZGVyZWQgaW4gYSByZWFkLW9ubHkgc3RhdGUgcmVnYXJkbGVzcyBvZiB0aGUgYHJlYWRPbmx5SW5wdXRgIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkT25seUlucHV0ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHRpbWUgZm9ybWF0IHRoYXQgaXMgdXNlZCB0byBkaXNwbGF5IHRoZSBpbnB1dCB2YWx1ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGZvcm1hdHNfdGltZXBpY2tlciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSAndCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGhpbnQgdGhlIFRpbWVQaWNrZXIgZGlzcGxheXMgd2hlbiBpdHMgdmFsdWUgaXMgYG51bGxgLlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIGFydGljbGUgb25cbiAgICAgICAgICogW3BsYWNlaG9sZGVyc10oeyUgc2x1ZyBwbGFjZWhvbGRlcnNfdGltZXBpY2tlciAlfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLXRpbWVwaWNrZXIgcGxhY2Vob2xkZXI9XCJFbnRlciBzdGFydC4uLlwiPjwva2VuZG8tdGltZXBpY2tlcj5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBidWlsdC1pbiB2YWxpZGF0aW9uIGZvciBpbmNvbXBsZXRlIGRhdGVzIGlzIHRvIGJlIGVuZm9yY2VkIHdoZW4gYSBmb3JtIGlzIGJlaW5nIHZhbGlkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZGlzcGxheSB0aGUgKipDYW5jZWwqKiBidXR0b24gaW4gdGhlIHBvcHVwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGRpc3BsYXkgdGhlICoqTm93KiogYnV0dG9uIGluIHRoZSBwb3B1cC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBJZiB0aGUgY3VycmVudCB0aW1lIGlzIG91dCBvZiByYW5nZSBvciB0aGUgaW5jcmVtZW50YWwgc3RlcCBpcyBncmVhdGVyIHRoYW4gYDFgLCB0aGUgKipOb3cqKiBidXR0b24gd2lsbCBiZSBoaWRkZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vd0J1dHRvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGB0YWJpbmRleGAgcHJvcGVydHkgb2YgdGhlIFRpbWVQaWNrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBpbnB1dCBlbGVtZW50IG9mIHRoZSBUaW1lUGlja2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aXRsZSA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIG1pbiBvciBtYXggdmFsaWRhdG9ycyBhcmUgZW5mb3JjZWQgd2hlbiBhIGZvcm0gaXMgYmVpbmcgdmFsaWRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZVZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSBuZXcgdmFsdWUuXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgc2VjdGlvbiBvblxuICAgICAgICAgKiBbZXZlbnRzXSh7JSBzbHVnIG92ZXJ2aWV3X3RpbWVwaWNrZXIgJX0jdG9jLWV2ZW50cykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGZvY3VzZXMgdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgc2VjdGlvbiBvblxuICAgICAgICAgKiBbZXZlbnRzXSh7JSBzbHVnIG92ZXJ2aWV3X3RpbWVwaWNrZXIgJX0jdG9jLWV2ZW50cykuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25Gb2N1c2AgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLXRpbWVwaWNrZXIgKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIj48L2tlbmRvLXRpbWVwaWNrZXI+XG4gICAgICAgICAqIGBcbiAgICAgICAgICogfSlcbiAgICAgICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgcHVibGljIGhhbmRsZUZvY3VzKCk6IHZvaWQge1xuICAgICAgICAgKiAgICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50IGlzIGZvY3VzZWRcIik7XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpOyAvL3RzbGludDpkaXNhYmxlLWxpbmU6bm8tb3V0cHV0LXJlbmFtZVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBpbnB1dCBlbGVtZW50IGdldHMgYmx1cnJlZC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfdGltZXBpY2tlciAlfSN0b2MtZXZlbnRzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUbyB3aXJlIHRoZSBldmVudCBwcm9ncmFtbWF0aWNhbGx5LCB1c2UgdGhlIGBvbkJsdXJgIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogIDxrZW5kby10aW1lcGlja2VyIChibHVyKT1cImhhbmRsZUJsdXIoKVwiPjwva2VuZG8tdGltZXBpY2tlcj5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgaGFuZGxlQmx1cigpOiB2b2lkIHtcbiAgICAgICAgICogICAgICBjb25zb2xlLmxvZyhcIkNvbXBvbmVudCBpcyBibHVycmVkXCIpO1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CbHVyID0gbmV3IEV2ZW50RW1pdHRlcigpOyAvL3RzbGludDpkaXNhYmxlLWxpbmU6bm8tb3V0cHV0LXJlbmFtZVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBvcGVuLlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgY2FuY2VsIHRoZSBldmVudCwgdGhlIHBvcHVwIHdpbGwgcmVtYWluIGNsb3NlZC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfdGltZXBpY2tlciAlfSN0b2MtZXZlbnRzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gY2xvc2UuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgdGhlIGV2ZW50LCB0aGUgcG9wdXAgd2lsbCByZW1haW4gb3Blbi5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfdGltZXBpY2tlciAlfSN0b2MtZXZlbnRzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBwZXJDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3B1cFVJRCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLm9uQ29udHJvbFRvdWNoZWQgPSBub29wO1xuICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlID0gbm9vcDtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMudGltZVJhbmdlVmFsaWRhdGVGbiA9IG5vb3A7XG4gICAgICAgIHRoaXMuaW5jb21wbGV0ZVZhbGlkYXRvciA9IG5vb3A7XG4gICAgICAgIHRoaXMuX21pbiA9IGNsb25lRGF0ZShNSU5fVElNRSk7XG4gICAgICAgIHRoaXMuX21heCA9IGNsb25lRGF0ZShNQVhfVElNRSk7XG4gICAgICAgIHRoaXMuX3BvcHVwU2V0dGluZ3MgPSB7IGFuaW1hdGU6IHRydWUgfTtcbiAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGVwcyA9IHt9O1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9zaXplID0gJ21lZGl1bSc7XG4gICAgICAgIHRoaXMuX3JvdW5kZWQgPSAnbWVkaXVtJztcbiAgICAgICAgdGhpcy5fZmlsbE1vZGUgPSAnc29saWQnO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5waWNrZXJTdWJzY3JpcHRpb25zID0gdGhpcy5waWNrZXJTZXJ2aWNlLm9uRm9jdXMuc3Vic2NyaWJlKHRoaXMuaGFuZGxlRm9jdXMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucGlja2VyU3Vic2NyaXB0aW9ucy5hZGQodGhpcy5waWNrZXJTZXJ2aWNlLm9uQmx1ci5zdWJzY3JpYmUodGhpcy5oYW5kbGVCbHVyLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5waWNrZXJTdWJzY3JpcHRpb25zLmFkZCh0aGlzLnBpY2tlclNlcnZpY2UuZGF0ZUNvbXBsZXRlbmVzc0NoYW5nZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVEYXRlQ29tcGxldGVuZXNzQ2hhbmdlLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBzbWFsbGVzdCB2YWxpZCB0aW1lIHZhbHVlXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0aW1lcmFuZ2VzX3RpbWVwaWNrZXIgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgbWluKG1pbikge1xuICAgICAgICB0aGlzLl9taW4gPSBjbG9uZURhdGUobWluIHx8IE1JTl9USU1FKTtcbiAgICB9XG4gICAgZ2V0IG1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBiaWdnZXN0IHZhbGlkIHRpbWUgdmFsdWVcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRpbWVyYW5nZXNfdGltZXBpY2tlciAlfSkpLlxuICAgICAqL1xuICAgIHNldCBtYXgobWF4KSB7XG4gICAgICAgIHRoaXMuX21heCA9IGNsb25lRGF0ZShtYXggfHwgTUFYX1RJTUUpO1xuICAgIH1cbiAgICBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBpbmNyZW1lbnRhbCBzdGVwcyBvZiB0aGUgVGltZVBpY2tlci5cbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIGFydGljbGUgb25cbiAgICAgKiBbaW5jcmVtZW50YWwgc3RlcHNdKHslIHNsdWcgaW5jcmVtZW50YWxzdGVwc190aW1lcGlja2VyICV9KS5cbiAgICAgKlxuICAgICAqID4gSWYgdGhlIGluY3JlbWVudGFsIHN0ZXAgaXMgZ3JlYXRlciB0aGFuIGAxYCwgdGhlICoqTm93KiogYnV0dG9uIHdpbGwgYmUgaGlkZGVuLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogdGVtcGxhdGU6IGBcbiAgICAgKiAgPGtlbmRvLXRpbWVwaWNrZXIgZm9ybWF0PVwiSEg6bW06c3NcIiBbc3RlcHNdPVwic3RlcHNcIj48L2tlbmRvLXRpbWVwaWNrZXI+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgIHB1YmxpYyBzdGVwcyA9IHsgaG91cjogMiwgbWludXRlOiAxNSwgc2Vjb25kOiAxNSwgbWlsbGlzZWNvbmQ6IDEwIH07XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgc2V0IHN0ZXBzKHN0ZXBzKSB7XG4gICAgICAgIHRoaXMuX3N0ZXBzID0gc3RlcHMgfHwge307XG4gICAgfVxuICAgIGdldCBzdGVwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXBzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBwb3B1cCBvZiB0aGUgVGltZVBpY2tlci5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAgICogLSBgYW5pbWF0ZTogQm9vbGVhbmAmbWRhc2g7Q29udHJvbHMgdGhlIHBvcHVwIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCwgdGhlIG9wZW4gYW5kIGNsb3NlIGFuaW1hdGlvbnMgYXJlIGVuYWJsZWQuXG4gICAgICogLSBgYXBwZW5kVG86ICdyb290JyB8ICdjb21wb25lbnQnIHwgVmlld0NvbnRhaW5lclJlZmAmbWRhc2g7Q29udHJvbHMgdGhlIHBvcHVwIGNvbnRhaW5lci4gQnkgZGVmYXVsdCwgdGhlIHBvcHVwIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIHJvb3QgY29tcG9uZW50LlxuICAgICAqIC0gYHBvcHVwQ2xhc3M6IFN0cmluZ2AmbWRhc2g7U3BlY2lmaWVzIGEgbGlzdCBvZiBDU1MgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIHRvIHN0eWxlIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICBzZXQgcG9wdXBTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9wb3B1cFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBhbmltYXRlOiB0cnVlIH0sIHNldHRpbmdzKTtcbiAgICB9XG4gICAgZ2V0IHBvcHVwU2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3B1cFNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IHRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSB2YWx1ZSBvZiB0aGUgVGltZVBpY2tlciBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5VmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGAnc21hbGwnYFxuICAgICAqICogYCdtZWRpdW0nYCAoRGVmYXVsdClcbiAgICAgKiAqIGAnbGFyZ2UnYFxuICAgICAqICogYG51bGxgXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgc2l6ZShzaXplKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldFNpemVDbGFzcygnaW5wdXQnLCB0aGlzLnNpemUpKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBnZXRTaXplQ2xhc3MoJ2lucHV0JywgdGhpcy5zaXplKSk7XG4gICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50LCBnZXRTaXplQ2xhc3MoJ2lucHV0Jywgc2l6ZSkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBnZXRTaXplQ2xhc3MoJ2lucHV0Jywgc2l6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvcmRlciByYWRpdXMgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzbWFsbCdgXG4gICAgICogKiBgJ21lZGl1bSdgIChEZWZhdWx0KVxuICAgICAqICogYCdsYXJnZSdgXG4gICAgICogKiBgJ2Z1bGwnYFxuICAgICAqICogYG51bGxgXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgcm91bmRlZChyb3VuZGVkKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldFJvdW5kZWRDbGFzcyh0aGlzLnJvdW5kZWQpKTtcbiAgICAgICAgaWYgKHJvdW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldFJvdW5kZWRDbGFzcyhyb3VuZGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm91bmRlZCA9IHJvdW5kZWQ7XG4gICAgfVxuICAgIGdldCByb3VuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm91bmRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZmlsbE1vZGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzb2xpZCdgIChEZWZhdWx0KVxuICAgICAqICogYCdmbGF0J2BcbiAgICAgKiAqIGAnb3V0bGluZSdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKlxuICAgICAqL1xuICAgIHNldCBmaWxsTW9kZShmaWxsTW9kZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50LCBnZXRGaWxsTW9kZUNsYXNzKCdpbnB1dCcsIHRoaXMuZmlsbE1vZGUpKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBnZXRGaWxsTW9kZUNsYXNzKCdidXR0b24nLCB0aGlzLmZpbGxNb2RlKSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy50b2dnbGVCdXR0b24ubmF0aXZlRWxlbWVudCwgYGstYnV0dG9uLSR7dGhpcy5maWxsTW9kZX0tYmFzZWApO1xuICAgICAgICBpZiAoZmlsbE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldEZpbGxNb2RlQ2xhc3MoJ2lucHV0JywgZmlsbE1vZGUpKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy50b2dnbGVCdXR0b24ubmF0aXZlRWxlbWVudCwgZ2V0RmlsbE1vZGVDbGFzcygnYnV0dG9uJywgZmlsbE1vZGUpKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy50b2dnbGVCdXR0b24ubmF0aXZlRWxlbWVudCwgYGstYnV0dG9uLSR7ZmlsbE1vZGV9LWJhc2VgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maWxsTW9kZSA9IGZpbGxNb2RlO1xuICAgIH1cbiAgICBnZXQgZmlsbE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsTW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpbnB1dFJvbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRPbmx5SW5wdXQgPyAnbGlzdGJveCcgOiAnc3BpbmJ1dHRvbic7XG4gICAgfVxuICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG4gICAgc2V0IGlzQWN0aXZlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMud3JhcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLWZvY3VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW1lbnQsICdrLWZvY3VzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNob3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93O1xuICAgIH1cbiAgICBzZXQgc2hvdyhzaG93KSB7XG4gICAgICAgIGlmIChzaG93ICYmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2tpcFpvbmUgPSAhc2hvdyAmJiAoIXRoaXMuX3Nob3cgfHwgIWhhc09ic2VydmVycyh0aGlzLmNsb3NlKSk7XG4gICAgICAgIGlmICghc2tpcFpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoc2hvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoc2hvdyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlucHV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrZXJTZXJ2aWNlLmlucHV0O1xuICAgIH1cbiAgICBnZXQgdGltZVNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrZXJTZXJ2aWNlLnRpbWVTZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgYnkgdGhlIFRleHRCb3hDb250YWluZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgaXMgZW1wdHlcbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMudmFsdWUgJiYgdGhpcy5pbnB1dC5pc0VtcHR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXphdGlvblxuICAgICAgICAgICAgLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpKTtcbiAgICAgICAgdGhpcy5jb250cm9sID0gdGhpcy5pbmplY3Rvci5nZXQoTmdDb250cm9sLCBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsICd0YWJpbmRleCcpO1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50Q2xhc3NlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5taW4gfHwgY2hhbmdlcy5tYXggfHwgY2hhbmdlcy5yYW5nZVZhbGlkYXRpb24gfHwgY2hhbmdlcy5pbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudGltZVJhbmdlVmFsaWRhdGVGbiA9IHRoaXMucmFuZ2VWYWxpZGF0aW9uID8gdGltZVJhbmdlVmFsaWRhdG9yKHRoaXMubWluLCB0aGlzLm1heCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5pbmNvbXBsZXRlVmFsaWRhdG9yID0gdGhpcy5pbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb24gPyBpbmNvbXBsZXRlRGF0ZVZhbGlkYXRvcigpIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5mb3JtYXQpIHtcbiAgICAgICAgICAgIHRoaXMudmVyaWZ5Rm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2luZG93Qmx1clN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dCbHVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb21FdmVudHMuZm9yRWFjaCh1bmJpbmRDYWxsYmFjayA9PiB1bmJpbmRDYWxsYmFjaygpKTtcbiAgICAgICAgdGhpcy5waWNrZXJTdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVLZXlkb3duKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgYWx0S2V5LCBrZXlDb2RlIH0gPSBldmVudDtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRXNjYXBlKSB7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWx0S2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5BcnJvd1VwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5BcnJvd0Rvd24gJiYgIXRoaXMuc2hvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBjbG9uZURhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHZhbGlkYXRlKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZVJhbmdlVmFsaWRhdGVGbihjb250cm9sKSB8fCB0aGlzLmluY29tcGxldGVWYWxpZGF0b3IoY29udHJvbCwgdGhpcy5pbnB1dCAmJiB0aGlzLmlucHV0LmlzRGF0ZUluY29tcGxldGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIFRpbWVQaWNrZXIgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogdGVtcGxhdGU6IGBcbiAgICAgKiAgPGJ1dHRvbiAoY2xpY2spPVwidGltZXBpY2tlci5mb2N1cygpXCI+Rm9jdXMgdGltZSBwaWNrZXI8L2J1dHRvbj5cbiAgICAgKiAgPGtlbmRvLXRpbWVwaWNrZXIgI3RpbWVwaWNrZXI+PC9rZW5kby10aW1lcGlja2VyPlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIFRpbWVQaWNrZXIgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgICh0aGlzLnRpbWVTZWxlY3RvciB8fCB0aGlzLmlucHV0KVsnYmx1ciddKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1zdHJpbmctbGl0ZXJhbFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBwb3B1cC4gSWYgeW91IHVzZSB0aGUgYHRvZ2dsZWAgbWV0aG9kIHRvIHNob3cgb3IgaGlkZSB0aGUgcG9wdXAsXG4gICAgICogdGhlIGBvcGVuYCBhbmQgYGNsb3NlYCBldmVudHMgZG8gbm90IGZpcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hvdyAtIFRoZSBzdGF0ZSBvZiB0aGUgcG9wdXAuXG4gICAgICovXG4gICAgdG9nZ2xlKHNob3cpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb2x2ZWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKChzaG93ID09PSB1bmRlZmluZWQpID8gIXRoaXMuc2hvdyA6IHNob3cpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBvcGVuIHN0YXRlIG9mIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICBnZXQgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGFwcGVuZFRvKCkge1xuICAgICAgICBjb25zdCB7IGFwcGVuZFRvIH0gPSB0aGlzLnBvcHVwU2V0dGluZ3M7XG4gICAgICAgIGlmICghYXBwZW5kVG8gfHwgYXBwZW5kVG8gPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwZW5kVG8gPT09ICdjb21wb25lbnQnID8gdGhpcy5jb250YWluZXIgOiBhcHBlbmRUbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUNoYW5nZSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNFcXVhbCh0aGlzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNJbnB1dCgpO1xuICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0lucHV0KCk7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub25Db250cm9sQ2hhbmdlKGNsb25lRGF0ZSh2YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KGNsb25lRGF0ZSh2YWx1ZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVJlamVjdCgpIHtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVJbnB1dENoYW5nZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLmlucHV0LmZvcm1hdFNlY3Rpb25zLmRhdGUgPyB2YWx1ZSA6IHRoaXMubWVyZ2VUaW1lKHZhbHVlKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UodmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlZG93bihhcmdzKSB7XG4gICAgICAgIGFyZ3MucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUljb25DbGljayhldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5mb2N1c0lucHV0KCk7XG4gICAgICAgIC8vWFhYOiBleHBsaWNpdCBjYWxsIGhhbmRsZUZvY3VzIGhhbmRsZXIgaGVyZVxuICAgICAgICAvL2R1ZSB0byBhc3luYyBJRSBmb2N1cyBldmVudFxuICAgICAgICB0aGlzLmhhbmRsZUZvY3VzKCk7XG4gICAgICAgIHRoaXMuc2hvdyA9ICF0aGlzLnNob3c7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcG9wdXBDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2stZ3JvdXAnLFxuICAgICAgICAgICAgJ2stcmVzZXQnXG4gICAgICAgIF0uY29uY2F0KHRoaXMucG9wdXBTZXR0aW5ncy5wb3B1cENsYXNzIHx8IFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5vcm1hbGl6ZVRpbWUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gc2V0VGltZShNSUROSUdIVF9EQVRFLCBkYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG1lcmdlVGltZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAmJiB2YWx1ZSA/IHNldFRpbWUodGhpcy52YWx1ZSwgdmFsdWUpIDogdmFsdWU7XG4gICAgfVxuICAgIHRvZ2dsZVBvcHVwKHNob3cpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgUHJldmVudGFibGVFdmVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuX3Nob3cgJiYgc2hvdykge1xuICAgICAgICAgICAgdGhpcy5vcGVuLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Nob3cgJiYgIXNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UuZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdG9nZ2xlKHNob3cpO1xuICAgICAgICB0aGlzLnRvZ2dsZUZvY3VzKCk7XG4gICAgfVxuICAgIF90b2dnbGUoc2hvdykge1xuICAgICAgICBpZiAoc2hvdyA9PT0gdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaG93ID0gc2hvdztcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IHRoaXMucG9wdXBTZXJ2aWNlLm9wZW4oe1xuICAgICAgICAgICAgICAgIGFuY2hvcjogdGhpcy53cmFwcGVyLFxuICAgICAgICAgICAgICAgIGFuY2hvckFsaWduOiB7IHZlcnRpY2FsOiAnYm90dG9tJywgaG9yaXpvbnRhbDogZGlyZWN0aW9uIH0sXG4gICAgICAgICAgICAgICAgYW5pbWF0ZTogdGhpcy5wb3B1cFNldHRpbmdzLmFuaW1hdGUsXG4gICAgICAgICAgICAgICAgYXBwZW5kVG86IHRoaXMuYXBwZW5kVG8sXG4gICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5wb3B1cFRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHBvcHVwQWxpZ246IHsgdmVydGljYWw6ICd0b3AnLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfSxcbiAgICAgICAgICAgICAgICBwb3B1cENsYXNzOiB0aGlzLnBvcHVwQ2xhc3NlcyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk1vZGU6ICdhYnNvbHV0ZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMucG9wdXBVSUQpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cEFuY2hvclZpZXdwb3J0TGVhdmUuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2hvdyA9IGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvY3VzSW5wdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRvdWNoRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICB9XG4gICAgdG9nZ2xlRm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3cpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50aW1lU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZVNlbGVjdG9yLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMudG91Y2hFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuaW5wdXQuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAndmFsdWUnIHNob3VsZCBiZSBhIHZhbGlkIEphdmFTY3JpcHQgRGF0ZSBpbnN0YW5jZS4gQ2hlY2sgJHtWQUxVRV9ET0NfTElOSyQ0fSBmb3IgcG9zc2libGUgcmVzb2x1dGlvbi5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnlGb3JtYXQoKSB7XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXRDb250YWluc0RhdGVQYXJ0cyA9IHRoaXMuaW50bC5zcGxpdERhdGVGb3JtYXQodGhpcy5mb3JtYXQpLnNvbWUocGFydCA9PiAhZm9ybWF0UmVnRXhwLnRlc3QocGFydC50eXBlKSk7XG4gICAgICAgIGlmIChmb3JtYXRDb250YWluc0RhdGVQYXJ0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm92aWRlZCBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZC4gU3VwcG9ydGVkIHNwZWNpZmllcnMgYXJlIFR8dHxIfGh8bXxzfFN8YS4gU2VlICR7SU5UTF9EQVRFX0ZPUk1BVH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kRXZlbnRzKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLnB1c2godGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWRvd24uYmluZCh0aGlzKSkpO1xuICAgICAgICBpZiAoaXNXaW5kb3dBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dCbHVyU3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KHdpbmRvdywgJ2JsdXInKS5zdWJzY3JpYmUodGhpcy5oYW5kbGVXaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVdpbmRvd0JsdXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlRm9jdXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkZvY3VzKSkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUJsdXIoYXJncykge1xuICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gYXJncyAmJiBjdXJyZW50Rm9jdXNUYXJnZXQoYXJncyk7XG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ICYmICh0aGlzLmlucHV0LmNvbnRhaW5zRWxlbWVudChjdXJyZW50VGFyZ2V0KSB8fFxuICAgICAgICAgICAgKHRoaXMudGltZVNlbGVjdG9yICYmIHRoaXMudGltZVNlbGVjdG9yLmNvbnRhaW5zRWxlbWVudChjdXJyZW50VGFyZ2V0KSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uQmx1cikgfHwgKHRoaXMuc2hvdyAmJiBoYXNPYnNlcnZlcnModGhpcy5jbG9zZSkpIHx8IHJlcXVpcmVzWm9uZU9uQmx1cih0aGlzLmNvbnRyb2wpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJsdXJDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ibHVyQ29tcG9uZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmx1ckNvbXBvbmVudCgpIHtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlOyAvLyBvcmRlciBpcyBpbXBvcnRhbnQgwq9cXF8o44OEKV8vwq9cbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25Db250cm9sVG91Y2hlZCgpO1xuICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KCk7XG4gICAgfVxuICAgIGhhbmRsZURhdGVDb21wbGV0ZW5lc3NDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHRoaXMub25WYWxpZGF0b3JDaGFuZ2UoKSk7XG4gICAgfVxuICAgIHNldENvbXBvbmVudENsYXNzZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldFNpemVDbGFzcygnaW5wdXQnLCB0aGlzLnNpemUpKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy50b2dnbGVCdXR0b24ubmF0aXZlRWxlbWVudCwgZ2V0U2l6ZUNsYXNzKCdidXR0b24nLCB0aGlzLnNpemUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yb3VuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50LCBnZXRSb3VuZGVkQ2xhc3ModGhpcy5yb3VuZGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsbE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldEZpbGxNb2RlQ2xhc3MoJ2lucHV0JywgdGhpcy5maWxsTW9kZSkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBnZXRGaWxsTW9kZUNsYXNzKCdidXR0b24nLCB0aGlzLmZpbGxNb2RlKSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLm5hdGl2ZUVsZW1lbnQsIGBrLWJ1dHRvbi0ke3RoaXMuZmlsbE1vZGV9LWJhc2VgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2NvbnRhaW5lcicsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVmlld0NvbnRhaW5lclJlZilcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRhaW5lclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdwb3B1cFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgndG9nZ2xlQnV0dG9uJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b2dnbGVCdXR0b25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvY3VzYWJsZUlkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJlYWRPbmx5SW5wdXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0UGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjYW5jZWxCdXR0b25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub3dCdXR0b25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RlcHNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwU2V0dGluZ3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VWYWxpZGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZpbGxNb2RlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2ZvY3VzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnYmx1cicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGVuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xvc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXRpbWVwaWNrZXInKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1pbnB1dCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwid3JhcHBlckNsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkQ2xhc3NcIiwgbnVsbCk7XG5UaW1lUGlja2VyQ29tcG9uZW50ID0gVGltZVBpY2tlckNvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG8tdGltZXBpY2tlcicsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgeyBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGltZVBpY2tlckNvbXBvbmVudF8xKSwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTkdfVkFMSURBVE9SUywgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGltZVBpY2tlckNvbXBvbmVudF8xKSwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogS2VuZG9JbnB1dCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGltZVBpY2tlckNvbXBvbmVudF8xKSB9LFxuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLnRpbWVwaWNrZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUGlja2VyU2VydmljZVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRpbWVwaWNrZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvVGltZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLWFjY2VwdD1cImtlbmRvLnRpbWVwaWNrZXIuYWNjZXB0fFRoZSBBY2NlcHQgYnV0dG9uIHRleHQgaW4gdGhlIHRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIGFjY2VwdD1cIlNldFwiXG5cbiAgICAgICAgICAgIGkxOG4tYWNjZXB0TGFiZWw9XCJrZW5kby50aW1lcGlja2VyLmFjY2VwdExhYmVsfFRoZSBsYWJlbCBmb3IgdGhlIEFjY2VwdCBidXR0b24gaW4gdGhlIHRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIGFjY2VwdExhYmVsPVwiU2V0IHRpbWVcIlxuXG4gICAgICAgICAgICBpMThuLWNhbmNlbD1cImtlbmRvLnRpbWVwaWNrZXIuY2FuY2VsfFRoZSBDYW5jZWwgYnV0dG9uIHRleHQgaW4gdGhlIHRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIGNhbmNlbD1cIkNhbmNlbFwiXG5cbiAgICAgICAgICAgIGkxOG4tY2FuY2VsTGFiZWw9XCJrZW5kby50aW1lcGlja2VyLmNhbmNlbExhYmVsfFRoZSBsYWJlbCBmb3IgdGhlIENhbmNlbCBidXR0b24gaW4gdGhlIHRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIGNhbmNlbExhYmVsPVwiQ2FuY2VsIGNoYW5nZXNcIlxuXG4gICAgICAgICAgICBpMThuLW5vdz1cImtlbmRvLnRpbWVwaWNrZXIubm93fFRoZSBOb3cgYnV0dG9uIHRleHQgaW4gdGhlIHRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIG5vdz1cIk5vd1wiXG5cbiAgICAgICAgICAgIGkxOG4tbm93TGFiZWw9XCJrZW5kby50aW1lcGlja2VyLm5vd0xhYmVsfFRoZSBsYWJlbCBmb3IgdGhlIE5vdyBidXR0b24gaW4gdGhlIHRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIG5vd0xhYmVsPVwiU2VsZWN0IG5vd1wiXG5cbiAgICAgICAgICAgIGkxOG4tdG9nZ2xlPVwia2VuZG8udGltZXBpY2tlci50b2dnbGV8VGhlIGxhYmVsIGZvciB0aGUgdG9nZ2xlIGJ1dHRvbiBpbiB0aGUgdGltZXBpY2tlciBjb21wb25lbnRcIlxuICAgICAgICAgICAgdG9nZ2xlPVwiVG9nZ2xlIHRpbWUgbGlzdFwiXG4gICAgICAgID5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxrZW5kby1kYXRlaW5wdXRcbiAgICAgICAgICAgICNpbnB1dFxuICAgICAgICAgICAgW2ZvY3VzYWJsZUlkXT1cImZvY3VzYWJsZUlkXCJcbiAgICAgICAgICAgIFtoYXNQb3B1cF09XCJ0cnVlXCJcbiAgICAgICAgICAgIFtpc1BvcHVwT3Blbl09XCJzaG93XCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICBbcmVhZG9ubHldPVwicmVhZG9ubHkgfHwgcmVhZE9ubHlJbnB1dFwiXG4gICAgICAgICAgICBbcm9sZV09XCJpbnB1dFJvbGVcIlxuICAgICAgICAgICAgW2FyaWFSZWFkT25seV09XCJyZWFkb25seVwiXG4gICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICBbZm9ybWF0UGxhY2Vob2xkZXJdPVwiZm9ybWF0UGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgIFttaW5dPVwibm9ybWFsaXplVGltZShtaW4pXCJcbiAgICAgICAgICAgIFttYXhdPVwibm9ybWFsaXplVGltZShtYXgpXCJcbiAgICAgICAgICAgIFtpbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb25dPVwiaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uXCJcbiAgICAgICAgICAgIFtmaWxsTW9kZV09XCJmaWxsTW9kZVwiXG4gICAgICAgICAgICBbcm91bmRlZF09XCJyb3VuZGVkXCJcbiAgICAgICAgICAgIFtzaXplXT1cInNpemVcIlxuICAgICAgICAgICAgW3N0ZXBzXT1cInN0ZXBzXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCIhc2hvdyA/IHRhYmluZGV4IDogLTFcIlxuICAgICAgICAgICAgW3RpdGxlXT1cInRpdGxlXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwiaGFuZGxlSW5wdXRDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgID48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgI3RvZ2dsZUJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzcz1cImstaW5wdXQtYnV0dG9uIGstYnV0dG9uIGstaWNvbi1idXR0b25cIlxuICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgndG9nZ2xlJylcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCd0b2dnbGUnKVwiXG4gICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgY2xpY2s6IGhhbmRsZUljb25DbGljayxcbiAgICAgICAgICAgICAgICBtb3VzZWRvd246IGhhbmRsZU1vdXNlZG93blxuICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1idXR0b24taWNvbiBrLWljb24gay1pLWNsb2NrXCI+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNwb3B1cFRlbXBsYXRlPlxuICAgICAgICAgICAgPGtlbmRvLXRpbWVzZWxlY3RvclxuICAgICAgICAgICAgICAgICN0aW1lU2VsZWN0b3JcbiAgICAgICAgICAgICAgICBbY2FuY2VsQnV0dG9uXT1cImNhbmNlbEJ1dHRvblwiXG4gICAgICAgICAgICAgICAgW25vd0J1dHRvbl09XCJub3dCdXR0b25cIlxuICAgICAgICAgICAgICAgIFtmb3JtYXRdPVwiZm9ybWF0XCJcbiAgICAgICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgICAgIFtzdGVwc109XCJzdGVwc1wiXG4gICAgICAgICAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgIGtleWRvd246IGhhbmRsZUtleWRvd24sXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlZG93bjogaGFuZGxlTW91c2Vkb3duXG4gICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgW3Njb3BlXT1cInRoaXNcIlxuICAgICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgKHZhbHVlUmVqZWN0KT1cImhhbmRsZVJlamVjdCgpXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8a2VuZG8tdGltZXNlbGVjdG9yLW1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgIFthY2NlcHRMYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdhY2NlcHRMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICAgICAgW2FjY2VwdF09XCJsb2NhbGl6YXRpb24uZ2V0KCdhY2NlcHQnKVwiXG4gICAgICAgICAgICAgICAgICAgIFtjYW5jZWxMYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdjYW5jZWxMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICAgICAgW2NhbmNlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdjYW5jZWwnKVwiXG4gICAgICAgICAgICAgICAgICAgIFtub3dMYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdub3dMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICAgICAgW25vd109XCJsb2NhbGl6YXRpb24uZ2V0KCdub3cnKVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwva2VuZG8tdGltZXNlbGVjdG9yLW1lc3NhZ2VzPlxuICAgICAgICAgICAgPC9rZW5kby10aW1lc2VsZWN0b3I+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250YWluZXIgI2NvbnRhaW5lcj48L25nLWNvbnRhaW5lcj5cbiAgICBgXG4gICAgfSksXG4gICAgX19wYXJhbSg5LCBPcHRpb25hbCgpKSwgX19wYXJhbSg5LCBJbmplY3QoVE9VQ0hfRU5BQkxFRCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmdab25lLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgUG9wdXBTZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIEluamVjdG9yLFxuICAgICAgICBQaWNrZXJTZXJ2aWNlLFxuICAgICAgICBJbnRsU2VydmljZSwgQm9vbGVhbl0pXG5dLCBUaW1lUGlja2VyQ29tcG9uZW50KTtcblxudmFyIERhdGVUaW1lUGlja2VyQ29tcG9uZW50XzE7XG5jb25zdCB0aW1lRm9ybWF0UmVnRXhwID0gbmV3IFJlZ0V4cChgJHtUSU1FX1BBUlQuaG91cn18JHtUSU1FX1BBUlQubWludXRlfXwke1RJTUVfUEFSVC5zZWNvbmR9fCR7VElNRV9QQVJULmRheXBlcmlvZH18bGl0ZXJhbGApO1xuY29uc3QgVkFMVUVfRE9DX0xJTkskNSA9ICdodHRwczovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZGF0ZWlucHV0cy9kYXRldGltZXBpY2tlci9pbnRlZ3JhdGlvbi13aXRoLWpzb24vJztcbmNvbnN0IE1JTl9NQVhfRE9DX0xJTksgPSAnaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2RhdGVpbnB1dHMvZGF0ZXRpbWVwaWNrZXIvZGF0ZS10aW1lLWxpbWl0cy8nO1xuY29uc3QgREVGQVVMVF9BQ1RJVkVfVEFCID0gJ2RhdGUnO1xuY29uc3QgREVGQVVMVF9EQVRFSU5QVVRfRk9STUFUID0gJ2cnO1xuY29uc3QgREVGQVVMVF9USU1FU0VMRUNUT1JfRk9STUFUID0gJ3QnO1xuY29uc3QgVFdPX0RJR0lUX1lFQVJfTUFYJDIgPSA2ODtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIERhdGVUaW1lUGlja2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19kYXRldGltZXBpY2tlciAlfSkuXG4gKi9cbmxldCBEYXRlVGltZVBpY2tlckNvbXBvbmVudCA9IERhdGVUaW1lUGlja2VyQ29tcG9uZW50XzEgPSBjbGFzcyBEYXRlVGltZVBpY2tlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocG9wdXBTZXJ2aWNlLCBpbnRsLCBjZHIsIHBpY2tlclNlcnZpY2UsIG5nWm9uZSwgd3JhcHBlciwgdG91Y2hFbmFibGVkJCQxLCBsb2NhbGl6YXRpb24sIGRpc2FibGVkRGF0ZXNTZXJ2aWNlLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIHRoaXMucGlja2VyU2VydmljZSA9IHBpY2tlclNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSB3cmFwcGVyO1xuICAgICAgICB0aGlzLnRvdWNoRW5hYmxlZCA9IHRvdWNoRW5hYmxlZCQkMTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UgPSBkaXNhYmxlZERhdGVzU2VydmljZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSB5ZWFyIHRvIGFzc3VtZSB0byBiZSBmcm9tIHRoZSBjdXJyZW50IGNlbnR1cnkgd2hlbiB0eXBpbmcgdHdvLWRpZ2l0IHllYXIgdmFsdWVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBmb3JtYXRzX2RhdGV0aW1lcGlja2VyICV9I3RvYy10d28tZGlnaXQteWVhci1mb3JtYXQpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgNjgsIGluZGljYXRpbmcgdGhhdCB0eXBpbmcgYW55IHZhbHVlIGxlc3MgdGhhbiA2OVxuICAgICAgICAgKiB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgMjB4eCwgd2hpbGUgNjkgYW5kIGxhcmdlciB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgMTl4eC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHdvRGlnaXRZZWFyTWF4ID0gVFdPX0RJR0lUX1lFQVJfTUFYJDI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUlkID0gYGstJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBpbnB1dCBlbGVtZW50IG9mIHRoZSBEYXRlVGltZVBpY2tlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGl0bGUgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYGRpc2FibGVkYCBwcm9wZXJ0eSBvZiB0aGUgRGF0ZVRpbWVQaWNrZXIgYW5kIGRldGVybWluZXMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGFjdGl2ZVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX2RhdGV0aW1lcGlja2VyICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIERhdGVUaW1lUGlja2VyXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcmVhZG9ubHlfZGF0ZXRpbWVwaWNrZXIgJX0jdG9jLXJlYWQtb25seS1kYXRldGltZXBpY2tlcikpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgcmVhZC1vbmx5IHN0YXRlIG9mIHRoZSBEYXRlVGltZVBpY2tlciBpbnB1dCBmaWVsZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlYWRvbmx5X2RhdGV0aW1lcGlja2VyICV9I3RvYy1yZWFkLW9ubHktaW5wdXQpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlIHRoYXQgaWYgeW91IHNldCB0aGUgW2ByZWFkb25seWBdKHslIHNsdWcgYXBpX2RhdGVpbnB1dHNfZGF0ZXRpbWVwaWNrZXJjb21wb25lbnQgJX0jdG9jLXJlYWRvbmx5KSBwcm9wZXJ0eSB2YWx1ZSB0byBgdHJ1ZWAsXG4gICAgICAgICAqIHRoZSBpbnB1dCB3aWxsIGJlIHJlbmRlcmVkIGluIGEgcmVhZC1vbmx5IHN0YXRlIHJlZ2FyZGxlc3Mgb2YgdGhlIGByZWFkT25seUlucHV0YCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZE9ubHlJbnB1dCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGRpc3BsYXkgdGhlICoqQ2FuY2VsKiogYnV0dG9uIGluIHRoZSBwb3B1cFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGV0aW1lcGlja2VyX3BvcHVwX29wdGlvbnMgJX0jdG9jLXRvZ2dsaW5nLXRoZS1jYW5jZWwtYnV0dG9uKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmVzIHRoZSBpbmNyZW1lbnRhbCBzdGVwcyBvZiB0aGUgRGF0ZUlucHV0IGFuZCB0aGUgcG9wdXAgY29tcG9uZW50IG9mIHRoZSBUaW1lUGlja2VyXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaW5jcmVtZW50YWxzdGVwc19kYXRldGltZXBpY2tlciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGVwcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBDYWxlbmRhciB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogLSBgaW5maW5pdGVgIChkZWZhdWx0KVxuICAgICAgICAgKiAtIGBjbGFzc2ljYFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxlbmRhclR5cGUgPSAnaW5maW5pdGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGVuYWJsZSBhbmltYXRpb24gd2hlbiBuYXZpZ2F0aW5nIHRvIHByZXZpb3VzL25leHQgQ2FsZW5kYXIgdmlldy5cbiAgICAgICAgICogQXBwbGllcyB0byB0aGUgW2BjbGFzc2ljYF0oeyUgc2x1ZyBhcGlfZGF0ZWlucHV0c19kYXRldGltZXBpY2tlcmNvbXBvbmVudCAlfSN0b2MtY2FsZW5kYXJ0eXBlKSBDYWxlbmRhciBvbmx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IFRoaXMgZmVhdHVyZSB1c2VzIHRoZSBbV2ViIEFuaW1hdGlvbnMgQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0FuaW1hdGlvbnNfQVBJKS4gSW4gb3JkZXIgdG8gcnVuIHRoZSBhbmltYXRpb24gaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCwgeW91IG5lZWQgdGhlIGB3ZWItYW5pbWF0aW9ucy1qc2AgcG9seWZpbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGVDYWxlbmRhck5hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBkaXNwbGF5IGEgd2VlayBudW1iZXIgY29sdW1uIGluIHRoZSBgbW9udGhgIHZpZXcgb2YgdGhlIHBvcHVwIENhbGVuZGFyXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXRpbWVwaWNrZXJfY2FsZW5kYXJfb3B0aW9ucyAlfSN0b2Mtd2Vlay1udW1iZXItY29sdW1uKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndlZWtOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gbWluIG9yIG1heCB2YWxpZGF0b3JzIGFyZSBlbmZvcmNlZCB3aGVuIHZhbGlkYXRpbmcgYSBmb3JtXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXJhbmdlc19kYXRldGltZXBpY2tlciAlfSN0b2MtcHJldmVudC1pbnZhbGlkLWlucHV0KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhbmdlVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIHZhbGlkYXRvciBmb3IgZGlzYWJsZWRcbiAgICAgICAgICogZGF0ZSByYW5nZXMgaXMgZW5mb3JjZWQgd2hlbiB2YWxpZGF0aW5nIGEgZm9ybVxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX2RhdGVzX2RhdGV0aW1lcGlja2VyICV9I3RvYy12YWxpZGF0aW9uKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNWYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gdmFsaWRhdGlvbiBmb3IgaW5jb21wbGV0ZSBkYXRlcyBpcyB0byBiZSBlbmZvcmNlZCB3aGVuIGEgZm9ybSBpcyBiZWluZyB2YWxpZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluY29tcGxldGVEYXRlVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSBuZXcgdmFsdWUuXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19kYXRldGltZXBpY2tlciAlfSN0b2MtbWV0aG9kcy1hbmQtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBvcGVuLlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgY2FuY2VsIHRoZSBldmVudCBieSBzZXR0aW5nIGBldmVudC5wcmV2ZW50RGVmYXVsdCgpYCwgdGhlIHBvcHVwIHdpbGwgcmVtYWluIGNsb3NlZC5cbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGV0aW1lcGlja2VyICV9I3RvYy1tZXRob2RzLWFuZC1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gY2xvc2UuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgdGhlIGV2ZW50IGJ5IHNldHRpbmcgYGV2ZW50LnByZXZlbnREZWZhdWx0KClgLCB0aGUgcG9wdXAgd2lsbCByZW1haW4gb3Blbi5cbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGV0aW1lcGlja2VyICV9I3RvYy1tZXRob2RzLWFuZC1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgZm9jdXNlcyB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZXRpbWVwaWNrZXIgJX0jdG9jLW1ldGhvZHMtYW5kLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGJsdXJzIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19kYXRldGltZXBpY2tlciAlfSN0b2MtbWV0aG9kcy1hbmQtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29udHJvbHMgd2hldGhlciB0aGUgQ2FsZW5kYXIgb3IgdGhlIFRpbWVTZWxlY3RvciB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlVGFiID0gREVGQVVMVF9BQ1RJVkVfVEFCO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHN0cmlwcGVkIHRpbWUtcmVsYXRlZCBmb3JtYXQgdGhhdCBpcyB1c2VkIGluIHRoZSBUaW1lU2VsZWN0b3IuXG4gICAgICAgICAqIFVwZGF0ZXMgZWFjaCB0aW1lIHRoZSBgZm9ybWF0YCBwcm9wZXJ0eSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aW1lU2VsZWN0b3JGb3JtYXQgPSBERUZBVUxUX1RJTUVTRUxFQ1RPUl9GT1JNQVQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbWVTZWxlY3Rvck1pbiA9IGNsb25lRGF0ZShNSU5fVElNRSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbWVTZWxlY3Rvck1heCA9IGNsb25lRGF0ZShNQVhfVElNRSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGVuZGFyVmFsdWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxlbmRhck1pbiA9IGNsb25lRGF0ZShNSU5fREFURSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGVuZGFyTWF4ID0gbGFzdE1pbGxpc2Vjb25kT2ZEYXRlKE1BWF9EQVRFKTtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IHsgYW5pbWF0ZTogdHJ1ZSB9O1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Zvcm1hdCA9IERFRkFVTFRfREFURUlOUFVUX0ZPUk1BVDtcbiAgICAgICAgdGhpcy5fdGFiaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9kZWZhdWx0VGFiID0gREVGQVVMVF9BQ1RJVkVfVEFCO1xuICAgICAgICB0aGlzLl9taW4gPSBtZXJnZURhdGVBbmRUaW1lKE1JTl9EQVRFLCBNSU5fVElNRSk7XG4gICAgICAgIHRoaXMuX21heCA9IG1lcmdlRGF0ZUFuZFRpbWUoTUFYX0RBVEUsIE1BWF9USU1FKTtcbiAgICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xUb3VjaGVkID0gbm9vcDtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlID0gbm9vcDtcbiAgICAgICAgdGhpcy5taW5WYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5tYXhWYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5kaXNhYmxlZERhdGVzVmFsaWRhdGVGbiA9IG5vb3A7XG4gICAgICAgIHRoaXMuaW5jb21wbGV0ZVZhbGlkYXRvciA9IG5vb3A7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICB0aGlzLl9yb3VuZGVkID0gJ21lZGl1bSc7XG4gICAgICAgIHRoaXMuX2ZpbGxNb2RlID0gJ3NvbGlkJztcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaW5wdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlclNlcnZpY2UuaW5wdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY2FsZW5kYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlclNlcnZpY2UuY2FsZW5kYXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdGltZVNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrZXJTZXJ2aWNlLnRpbWVTZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSB2YWx1ZSBvZiB0aGUgRGF0ZVRpbWVQaWNrZXIgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogPiBUaGUgYHZhbHVlYCBoYXMgdG8gYmUgYSB2YWxpZCBbSmF2YVNjcmlwdCBgRGF0ZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUpIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZlcmlmeVZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBjbG9uZURhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLnNldENhbGVuZGFyVmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgZGF0ZSBmb3JtYXQgZm9yIGRpc3BsYXlpbmcgdGhlIGlucHV0IHZhbHVlXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBmb3JtYXRzX2RhdGV0aW1lcGlja2VyICV9KSlcbiAgICAgKlxuICAgICAqIEZvcm1hdCB2YWx1ZSBvcHRpb25zOlxuICAgICAqIC0gYHN0cmluZ2AgLSBQcm92aWRlIGEgYHN0cmluZ2AgaWYgYSBzaW5nbGUgZm9ybWF0IGlzIGdvaW5nIHRvIGJlIHVzZWQgcmVnYXJkbGVzcyB3aGV0aGVyIHRoZSBpbnB1dCBpcyBmb2N1c2VkIG9yIGJsdXJyZWQuXG4gICAgICogLSBbYEZvcm1hdFNldHRpbmdzYF0oeyUgc2x1ZyBhcGlfZGF0ZWlucHV0c19mb3JtYXRzZXR0aW5ncyAlfSkgLSBUbyBkaXNwbGF5IGRpZmZlcmVudCBmb3JtYXRzIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBmb2N1c2VkIG9yIGJsdXJyZWQsIHByb3ZpZGUgYSBzZXR0aW5ncyBvYmplY3Qgd2l0aCBzcGVjaWZpZWQgYGlucHV0Rm9ybWF0YCBhbmQgYGRpc3BsYXlGb3JtYXRgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqID4gSWYgYSBbYEZvcm1hdFNldHRpbmdzYF0oeyUgc2x1ZyBhcGlfZGF0ZWlucHV0c19mb3JtYXRzZXR0aW5ncyAlfSkgb2JqZWN0IGlzIHByb3ZpZGVkLCB0aGUgYGRpc3BsYXlGb3JtYXRgIHZhbHVlIHdpbGwgYmUgdXNlZCBmb3IgdGhlIHBvcHVwIFRpbWVQaWNrZXIuXG4gICAgICovXG4gICAgc2V0IGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgdGhpcy5fZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICBjb25zdCBkaXNwbGF5Rm9ybWF0ID0gdGhpcy5nZXREaXNwbGF5Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIHRoaXMudGltZVNlbGVjdG9yRm9ybWF0ID0gdGhpcy5nZXRUaW1lU2VsZWN0b3JGb3JtYXQoZGlzcGxheUZvcm1hdCk7XG4gICAgfVxuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBEYXRlVGltZVBpY2tlci5cbiAgICAgKi9cbiAgICBzZXQgdGFiaW5kZXgodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGFiaW5kZXggPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl90YWJpbmRleCA9ICFpc05hTih0YWJpbmRleCkgPyB0YWJpbmRleCA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgZ2V0IHRhYmluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/IC0xIDogdGhpcy5fdGFiaW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRhdGVzIG9mIHRoZSBEYXRlVGltZVBpY2tlciB0aGF0IHdpbGwgYmUgZGlzYWJsZWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX2RhdGVzX2RhdGV0aW1lcGlja2VyICV9KSkuXG4gICAgICovXG4gICAgc2V0IGRpc2FibGVkRGF0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWREYXRlcyA9IHZhbHVlO1xuICAgICAgICB0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmluaXRpYWxpemUodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWREYXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkRGF0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHBvcHVwIHNldHRpbmdzIG9mIHRoZSBEYXRlVGltZVBpY2tlclxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXRpbWVwaWNrZXJfcG9wdXBfb3B0aW9ucyAlfSN0b2MtY3VzdG9taXppbmctdGhlLXBvcHVwKSkuXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlOlxuICAgICAqIC0gYGFuaW1hdGU6IEJvb2xlYW5gJm1kYXNoO0NvbnRyb2xzIHRoZSBwb3B1cCBhbmltYXRpb24uIEJ5IGRlZmF1bHQsIHRoZSBvcGVuIGFuZCBjbG9zZSBhbmltYXRpb25zIGFyZSBlbmFibGVkLlxuICAgICAqIC0gYGFwcGVuZFRvOiAncm9vdCcgfCAnY29tcG9uZW50JyB8IFZpZXdDb250YWluZXJSZWZgJm1kYXNoO0NvbnRyb2xzIHRoZSBwb3B1cCBjb250YWluZXIuIEJ5IGRlZmF1bHQsIHRoZSBwb3B1cCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSByb290IGNvbXBvbmVudC5cbiAgICAgKiAtIGBwb3B1cENsYXNzOiBTdHJpbmdgJm1kYXNoO1NwZWNpZmllcyBhIGxpc3Qgb2YgQ1NTIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCB0byBzdHlsZSB0aGUgcG9wdXAuXG4gICAgICovXG4gICAgc2V0IHBvcHVwU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHsgYW5pbWF0ZTogdHJ1ZSB9LCBzZXR0aW5ncyk7XG4gICAgfVxuICAgIGdldCBwb3B1cFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9wdXBTZXR0aW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBzbWFsbGVzdCB2YWxpZCBkYXRlLlxuICAgICAqIFRoZSBDYWxlbmRhciB3aWxsIG5vdCBkaXNwbGF5IGRhdGVzIGJlZm9yZSB0aGlzIHZhbHVlLlxuICAgICAqIElmIHRoZSBgbWluYCB2YWx1ZSBvZiB0aGUgQ2FsZW5kYXIgaXMgc2VsZWN0ZWQsIHRoZSBUaW1lUGlja2VyIHdpbGwgbm90IGRpc3BsYXlcbiAgICAgKiB0aW1lIGVudHJpZXMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgdGltZSBwb3J0aW9uIG9mIHRoaXMgdmFsdWVcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVyYW5nZXNfZGF0ZXRpbWVwaWNrZXIgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgbWluKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21pbiA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJNaW4gPSBnZXREYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IG1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBiaWdnZXN0IHZhbGlkIGRhdGUuXG4gICAgICogVGhlIENhbGVuZGFyIHdpbGwgbm90IGRpc3BsYXkgZGF0ZXMgYWZ0ZXIgdGhpcyB2YWx1ZS5cbiAgICAgKiBJZiB0aGUgYG1heGAgdmFsdWUgb2YgdGhlIENhbGVuZGFyIGlzIHNlbGVjdGVkLCB0aGUgVGltZVBpY2tlciB3aWxsIG5vdCBkaXNwbGF5XG4gICAgICogdGltZSBlbnRyaWVzIGFmdGVyIHRoZSBzcGVjaWZpZWQgdGltZSBwb3J0aW9uIG9mIHRoaXMgdmFsdWVcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVyYW5nZXNfZGF0ZXRpbWVwaWNrZXIgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgbWF4KHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21heCA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJNYXggPSBsYXN0TWlsbGlzZWNvbmRPZkRhdGUodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGN1cnJlbnRseSBvcGVuLlxuICAgICAqL1xuICAgIGdldCBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5wb3B1cFJlZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjb21wb25lbnQgb3IgaXRzIHBvcHVwIGNvbnRlbnQgaXMgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0FjdGl2ZTtcbiAgICB9XG4gICAgc2V0IGlzQWN0aXZlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2stZm9jdXMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsICdrLWZvY3VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNBY3RpdmUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIHRhYiBvbiBvcGVuaW5nIHRoZSBwb3B1cFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0ZXRpbWVwaWNrZXJfcG9wdXBfb3B0aW9ucyAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC10YWIpKS5cbiAgICAgKi9cbiAgICBzZXQgZGVmYXVsdFRhYih0YWIpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFRhYiA9IHRhYiB8fCBERUZBVUxUX0FDVElWRV9UQUI7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFiID0gdGhpcy5kZWZhdWx0VGFiO1xuICAgIH1cbiAgICBnZXQgZGVmYXVsdFRhYigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRUYWI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYCdzbWFsbCdgXG4gICAgICogKiBgJ21lZGl1bSdgIChEZWZhdWx0KVxuICAgICAqICogYCdsYXJnZSdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKlxuICAgICAqL1xuICAgIHNldCBzaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0U2l6ZUNsYXNzKCdpbnB1dCcsIHRoaXMuc2l6ZSkpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLm5hdGl2ZUVsZW1lbnQsIGdldFNpemVDbGFzcygnaW5wdXQnLCB0aGlzLnNpemUpKTtcbiAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldFNpemVDbGFzcygnaW5wdXQnLCBzaXplKSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLm5hdGl2ZUVsZW1lbnQsIGdldFNpemVDbGFzcygnaW5wdXQnLCBzaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9yZGVyIHJhZGl1cyBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgJ3NtYWxsJ2BcbiAgICAgKiAqIGAnbWVkaXVtJ2AgKERlZmF1bHQpXG4gICAgICogKiBgJ2xhcmdlJ2BcbiAgICAgKiAqIGAnZnVsbCdgXG4gICAgICogKiBgbnVsbGBcbiAgICAgKlxuICAgICAqL1xuICAgIHNldCByb3VuZGVkKHJvdW5kZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0Um91bmRlZENsYXNzKHRoaXMucm91bmRlZCkpO1xuICAgICAgICBpZiAocm91bmRlZCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0Um91bmRlZENsYXNzKHJvdW5kZWQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3VuZGVkID0gcm91bmRlZDtcbiAgICB9XG4gICAgZ2V0IHJvdW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3VuZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmaWxsTW9kZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogKiBgJ3NvbGlkJ2AgKERlZmF1bHQpXG4gICAgICogKiBgJ2ZsYXQnYFxuICAgICAqICogYCdvdXRsaW5lJ2BcbiAgICAgKiAqIGBudWxsYFxuICAgICAqXG4gICAgICovXG4gICAgc2V0IGZpbGxNb2RlKGZpbGxNb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldEZpbGxNb2RlQ2xhc3MoJ2lucHV0JywgdGhpcy5maWxsTW9kZSkpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLm5hdGl2ZUVsZW1lbnQsIGdldEZpbGxNb2RlQ2xhc3MoJ2J1dHRvbicsIHRoaXMuZmlsbE1vZGUpKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBgay1idXR0b24tJHt0aGlzLmZpbGxNb2RlfS1iYXNlYCk7XG4gICAgICAgIGlmIChmaWxsTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0RmlsbE1vZGVDbGFzcygnaW5wdXQnLCBmaWxsTW9kZSkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBnZXRGaWxsTW9kZUNsYXNzKCdidXR0b24nLCBmaWxsTW9kZSkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBgay1idXR0b24tJHtmaWxsTW9kZX0tYmFzZWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZpbGxNb2RlID0gZmlsbE1vZGU7XG4gICAgfVxuICAgIGdldCBmaWxsTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxNb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRhYlN3aXRjaFRyYW5zaXRpb24oKSB7XG4gICAgICAgIC8qXG4gICAgICAgICBXaGVuIHRoZSBwb3B1cCBpcyBvcGVuaW5nLCBkaXNhYmxlcyB0aGUgc2V0IHRyYW5zaXRpb24gaW4gdGhlIHRoZW1lcy4gV2hlbiBgZGVmYXVsdFRhYmAgaXMgc2V0IHRvIGB0aW1lYCxcbiAgICAgICAgIHRoZSBwb3B1cCBvcGVucyB3aXRoIGFuIGFjdGl2ZSAqKlRpbWUqKiB0YWIgYW5kIHRoZSBhbmltYXRpb24gb2YgdGhlIGluaXRpYWwgdHJhbnNpdGlvbiBpcyB1bmRlc2lyZWQuXG4gICAgICAgICBTZXR0aW5nIHRoZSBpbmxpbmUgdHJhbnNpdGlvbiBzdHlsZSB0byBgbm9uZWAgb3ZlcnJpZGVzIHRoZSBzZXQgYW5pbWF0aW9uIGluIHRoZSB0aGVtZXMuXG4gICAgICAgICBTZXR0aW5nIHRoZSBpbmxpbmUgdHJhbnNpdGlvbiBzdHlsZSB0byBgbnVsbGAgZG9lcyBub3QgYXBwbHkgYW55IGlubGluZSBzdHlsZXMgb3Igb3ZlcnJpZGUgdGhlIHRoZW1lcyBDU1MuXG4gICAgICAgICovXG4gICAgICAgIHJldHVybiB0aGlzLmlzT3BlbiA/IG51bGwgOiAnbm9uZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBDYWxlbmRhciB3aWxsIGJlIGRpc2FibGVkLlxuICAgICAqIFRoZSBpbmFjdGl2ZSB0YWIgY29tcG9uZW50IGdldHMgZGlzYWJsZWQgYW5kIGJlY29tZXMgaW5hY2Nlc3NpYmxlIG9uIHRhYiBjbGljay5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZUNhbGVuZGFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVUYWIgIT09ICdkYXRlJyAmJiAhdGhpcy5jYWxlbmRhci5pc0FjdGl2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpbnB1dFJvbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRPbmx5SW5wdXQgPyAnbGlzdGJveCcgOiAnc3BpbmJ1dHRvbic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBUaW1lU2VsZWN0b3Igd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgKiBUaGUgaW5hY3RpdmUgdGFiIGNvbXBvbmVudCBnZXRzIGRpc2FibGVkIGFuZCBiZWNvbWVzIGluYWNjZXNzaWJsZSBvbiB0YWIgY2xpY2suXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVUaW1lU2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVRhYiAhPT0gJ3RpbWUnICYmICF0aGlzLnRpbWVTZWxlY3Rvci5pc0FjdGl2ZTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZVRhYkNvbXBvbmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGlzUHJlc2VudCh0aGlzLmNhbGVuZGFyKSB8fCBpc1ByZXNlbnQodGhpcy50aW1lU2VsZWN0b3IpKSkge1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVRhYiA9PT0gJ2RhdGUnID8gdGhpcy5jYWxlbmRhciA6IHRoaXMudGltZVNlbGVjdG9yO1xuICAgIH1cbiAgICBnZXQgYXBwZW5kVG8oKSB7XG4gICAgICAgIGNvbnN0IHsgYXBwZW5kVG8gfSA9IHRoaXMucG9wdXBTZXR0aW5ncztcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoYXBwZW5kVG8pIHx8IGFwcGVuZFRvID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGVuZFRvID09PSAnY29tcG9uZW50JyA/IHRoaXMuY29udGFpbmVyIDogYXBwZW5kVG87XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucGlja2VyU2VydmljZS5vbkZvY3VzXG4gICAgICAgICAgICAvLyBkZXRlY3QgcG9wdXAgY2hhbmdlcyB0byBkaXNhYmxlIHRoZSBpbmFjdGl2ZSB2aWV3IG1hcmstdXAgd2hlbiB0aGUgcG9wdXAgaXMgb3BlblxuICAgICAgICAgICAgLnBpcGUodGFwKHRoaXMuZGV0ZWN0UG9wdXBDaGFuZ2VzLmJpbmQodGhpcykpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLmhhbmRsZUZvY3VzLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnBpY2tlclNlcnZpY2Uub25CbHVyLnN1YnNjcmliZSh0aGlzLmhhbmRsZUJsdXIuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucGlja2VyU2VydmljZS5zYW1lRGF0ZVNlbGVjdGVkLnN1YnNjcmliZSh0aGlzLmhhbmRsZUNhbGVuZGFyVmFsdWVDaGFuZ2UuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5waWNrZXJTZXJ2aWNlLmRhdGVDb21wbGV0ZW5lc3NDaGFuZ2Uuc3Vic2NyaWJlKHRoaXMuaGFuZGxlRGF0ZUNvbXBsZXRlbmVzc0NoYW5nZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIGlmIChpc1dpbmRvd0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IGZyb21FdmVudCh3aW5kb3csICdibHVyJykuc3Vic2NyaWJlKHRoaXMuaGFuZGxlQ2FuY2VsLmJpbmQodGhpcykpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudENsYXNzZXMoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXMubWluKSB8fCBpc1ByZXNlbnQoY2hhbmdlcy5tYXgpKSB7XG4gICAgICAgICAgICB0aGlzLnZlcmlmeU1pbk1heFJhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMubWluIHx8IGNoYW5nZXMubWF4IHx8IGNoYW5nZXMucmFuZ2VWYWxpZGF0aW9uIHx8IGNoYW5nZXMuZGlzYWJsZWREYXRlc1ZhbGlkYXRpb24gfHwgY2hhbmdlcy5kaXNhYmxlZERhdGVzIHx8IGNoYW5nZXMuaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1pblZhbGlkYXRlRm4gPSB0aGlzLnJhbmdlVmFsaWRhdGlvbiA/IG1pblZhbGlkYXRvcih0aGlzLm1pbikgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5tYXhWYWxpZGF0ZUZuID0gdGhpcy5yYW5nZVZhbGlkYXRpb24gPyBtYXhWYWxpZGF0b3IodGhpcy5tYXgpIDogbm9vcDtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1ZhbGlkYXRlRm4gPSB0aGlzLmRpc2FibGVkRGF0ZXNWYWxpZGF0aW9uID8gZGlzYWJsZWREYXRlc1ZhbGlkYXRvcih0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmlzRGF0ZURpc2FibGVkKSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLmluY29tcGxldGVWYWxpZGF0b3IgPSB0aGlzLmluY29tcGxldGVEYXRlVmFsaWRhdGlvbiA/IGluY29tcGxldGVEYXRlVmFsaWRhdG9yKCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAqIElmIHRoZSBwb3B1cCBpcyBjbG9zZWQsIGZvY3VzZXMgdGhlIERhdGVUaW1lUGlja2VyIGlucHV0LlxuICAgICAqICogSWYgdGhlIHBvcHVwIGlzIG9wZW4sIHRoZSBmb2N1cyBpcyBtb3ZlZCB0byBpdHMgY29udGVudC5cbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVGFiQ29tcG9uZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIERhdGVUaW1lUGlja2VyLlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3BlbiAmJiB0aGlzLmFjdGl2ZVRhYkNvbXBvbmVudC5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWJDb21wb25lbnQuYmx1cigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcG9wdXAuIElmIHlvdSB1c2UgdGhlIGB0b2dnbGVgIG1ldGhvZCB0byBzaG93IG9yIGhpZGUgdGhlIHBvcHVwLFxuICAgICAqIHRoZSBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIGRvIG5vdCBmaXJlLlxuICAgICAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19kYXRldGltZXBpY2tlciAlfSN0b2MtbWV0aG9kcy1hbmQtZXZlbnRzKSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hvdyAtIFRoZSBzdGF0ZSBvZiB0aGUgcG9wdXAuXG4gICAgICovXG4gICAgdG9nZ2xlKHNob3cpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSB8fCBzaG93ID09PSB0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNob3VsZE9wZW4gPSBpc1ByZXNlbnQoc2hvdykgPyBzaG93IDogIXRoaXMuaXNPcGVuO1xuICAgICAgICBpZiAoc2hvdWxkT3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuUG9wdXAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgICAgICAgICAgLy8gQ2hhbmdlcyB0aGUgdGFiIGFuZCB0aGUgY2FsZW5kYXIgb3IgY2xvY2sgaWNvbiB0byB0aGUgZGVzaWduYXRlZCBkZWZhdWx0LlxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGFiICE9PSB0aGlzLmRlZmF1bHRUYWIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVRhYiA9IHRoaXMuZGVmYXVsdFRhYjtcbiAgICAgICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ29udHJvbENoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNvbnRyb2xUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZShjb250cm9sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblZhbGlkYXRlRm4oY29udHJvbCkgfHwgdGhpcy5tYXhWYWxpZGF0ZUZuKGNvbnRyb2wpIHx8IHRoaXMuZGlzYWJsZWREYXRlc1ZhbGlkYXRlRm4oY29udHJvbCkgfHwgdGhpcy5pbmNvbXBsZXRlVmFsaWRhdG9yKGNvbnRyb2wsIHRoaXMuaW5wdXQgJiYgdGhpcy5pbnB1dC5pc0RhdGVJbmNvbXBsZXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IHRoZSBUZXh0Qm94Q29udGFpbmVyIHRvIGRldGVybWluZSBpZiB0aGUgZmxvYXRpbmcgbGFiZWwgd2lsbCByZW5kZXIgaW4gdGhlIGlucHV0LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhaXNQcmVzZW50KHRoaXMudmFsdWUpICYmIHRoaXMuaW5wdXQuaXNFbXB0eSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlSWNvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50cyB0aGUgZXZlbnQgZGVmYXVsdCB0byBldmFkZSBmb2N1c2luZyB0aGUgRGF0ZUlucHV0IGlucHV0IHdoZW4gcGxhY2VkIGluc2lkZSBhIGxhYmVsIChGRi9JRS9FZGdlKVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBydW5JblpvbmUgPSAhdGhpcy5pc09wZW4gfHwgaGFzT2JzZXJ2ZXJzKHRoaXMuY2xvc2UpO1xuICAgICAgICB0aGlzLnJ1bihydW5JblpvbmUsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZE9wZW4gPSAhdGhpcy5pc09wZW47XG4gICAgICAgICAgICAvLyBoYW5kbGUgZm9jdXMgZmlyc3QgdG8gbWFpbnRhaW4gY29ycmVjdCBldmVudCBvcmRlciBgZm9jdXNgID0+IGBvcGVuYFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVGb2N1cygpO1xuICAgICAgICAgICAgdGhpcy50b2dnbGVQb3B1cChzaG91bGRPcGVuKTtcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoRm9jdXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVGb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uRm9jdXMpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5vbkZvY3VzLmVtaXQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUJsdXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8IHRoaXMuZm9jdXNUYXJnZXRJbkNvbXBvbmVudChldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlzTmdDb250cm9sVW50b3VjaGVkID0gdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCduZy11bnRvdWNoZWQnKTtcbiAgICAgICAgY29uc3QgcnVuSW5ab25lID0gaXNOZ0NvbnRyb2xVbnRvdWNoZWQgfHwgaGFzT2JzZXJ2ZXJzKHRoaXMub25CbHVyKSB8fCAodGhpcy5pc09wZW4gJiYgaGFzT2JzZXJ2ZXJzKHRoaXMuY2xvc2UpKTtcbiAgICAgICAgdGhpcy5ydW4ocnVuSW5ab25lLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KCk7XG4gICAgICAgICAgICB0aGlzLm9uQ29udHJvbFRvdWNoZWQoKTtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY2hhbmdlQWN0aXZlVGFiKHRhYikge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuIHx8IHRoaXMuYWN0aXZlVGFiID09PSB0YWIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJzaXN0cyB0aGUgVGN1cnJlbnQgdmFsdWUgb2YgdGhlIFRpbWVTZWxlY3RvciB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIHRhYnNcbiAgICAgICAgaWYgKCFpc0VxdWFsKHRoaXMudGltZVNlbGVjdG9yLnZhbHVlLCB0aGlzLnRpbWVTZWxlY3Rvci5jdXJyZW50KSkge1xuICAgICAgICAgICAgdGhpcy50aW1lU2VsZWN0b3IuaGFuZGxlQWNjZXB0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVUYWIgPSB0YWI7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5kZXRlY3RQb3B1cENoYW5nZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVRhYkNoYW5nZVRyYW5zaXRpb25FbmQoZGF0ZVRpbWVTZWxlY3RvciwgZXZlbnQpIHtcbiAgICAgICAgLy8gaGFuZGxlIG9ubHkgdGhlIC5rLWRhdGV0aW1lLXNlbGVjdG9yIGVsZW1lbnQgdHJhbnNpdGlvbiwgaWdub3JlIGFueSBjaGlsZCBlbGVtZW50IHRyYW5zaXRpb25zXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGRhdGVUaW1lU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVRhYkNvbXBvbmVudC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQWNjZXB0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVyZ2VEYXRlQW5kVGltZSh0aGlzLmNhbGVuZGFyLnZhbHVlLCB0aGlzLnRpbWVTZWxlY3Rvci5jdXJyZW50KTtcbiAgICAgICAgY29uc3QgdmFsdWVDaGFuZ2VQcmVzZW50ID0gIWlzRXF1YWwodGhpcy52YWx1ZSwgY2FuZGlkYXRlKTtcbiAgICAgICAgY29uc3QgcnVuSW5ab25lID0gdmFsdWVDaGFuZ2VQcmVzZW50IHx8IGhhc09ic2VydmVycyh0aGlzLmNsb3NlKTtcbiAgICAgICAgdGhpcy5ydW4ocnVuSW5ab25lLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVDYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5JblpvbmUgPSBoYXNPYnNlcnZlcnModGhpcy5jbG9zZSk7XG4gICAgICAgIHRoaXMucnVuKHJ1bkluWm9uZSwgKCkgPT4gdGhpcy50b2dnbGVQb3B1cChmYWxzZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlSW5wdXRWYWx1ZUNoYW5nZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQ2FsZW5kYXJWYWx1ZUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZXRUaW1lU2VsZWN0b3JNaW5NYXgodGhpcy5jYWxlbmRhci52YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlQWN0aXZlVGFiKCd0aW1lJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGtleUNvZGUsIGFsdEtleSB9ID0gZXZlbnQ7XG4gICAgICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBhbHRLZXkgJiYgS2V5cy5BcnJvd1VwOlxuICAgICAgICAgICAgY2FzZSBLZXlzLkVzY2FwZTpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhdGhpcy5pc09wZW4gJiYgYWx0S2V5ICYmIEtleXMuQXJyb3dEb3duOlxuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB0aGlzLnRvZ2dsZVBvcHVwKHRydWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWx0S2V5ICYmIEtleXMuQXJyb3dSaWdodDpcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZUFjdGl2ZVRhYigndGltZScpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhbHRLZXkgJiYgS2V5cy5BcnJvd0xlZnQ6XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VBY3RpdmVUYWIoJ2RhdGUnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc09wZW4gJiYgdGhpcy50aW1lU2VsZWN0b3IuaXNBY3RpdmUgJiYgaXNQcmVzZW50KHRoaXMuY2FsZW5kYXJWYWx1ZSkgJiYgS2V5cy5FbnRlcjpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVUYWJPdXQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBrZXlDb2RlLCBzaGlmdEtleSwgdGFyZ2V0IH0gPSBldmVudDtcbiAgICAgICAgLy8gaWYgbm8gZm9jdXNhYmxlIG5leHQgc2libGluZyBlbGVtZW50cyBleGlzdCBpbiB0aGUgY29udHJvbHMgc2VjdGlvbnMsIHRoZSB1c2VyIGlzIHRhYmJpbmcgb3V0IG9mIHRoZSBwb3B1cFxuICAgICAgICBjb25zdCBmb2N1c2FibGVTaWJsaW5nQXZhaWxhYmxlID0gaXNQcmVzZW50KHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmcpICYmICF0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLmRpc2FibGVkO1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5UYWIgJiYgIXNoaWZ0S2V5ICYmICFmb2N1c2FibGVTaWJsaW5nQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVCYWNrVGFiT3V0KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsga2V5Q29kZSwgc2hpZnRLZXkgfSA9IGV2ZW50O1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5UYWIgJiYgc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcG9wdXBCdXR0b25zQ2xhc3Nlcyh0eXBlKSB7XG4gICAgICAgIGNvbnN0IGJ1dHRvblR5cGUgPSB0eXBlID8gdHlwZSA6ICdiYXNlJztcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuc2l6ZSA/IGdldFNpemVDbGFzcygnYnV0dG9uJywgdGhpcy5zaXplKSA6ICcnfSAke3RoaXMucm91bmRlZCA/IGdldFJvdW5kZWRDbGFzcyh0aGlzLnJvdW5kZWQpIDogJyd9ICR7dGhpcy5maWxsTW9kZSA/ICdrLWJ1dHRvbi0nICsgdGhpcy5maWxsTW9kZSArICcgJyArICdrLWJ1dHRvbi0nICsgdGhpcy5maWxsTW9kZSArICctJyArIGJ1dHRvblR5cGUgOiAnJ31gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBQcmV2ZW50cyB0aGUgZGl2ZXJzaW9uIG9mIHRoZSBmb2N1cyBmcm9tIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVsZW1lbnQgaW4gdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBwcmV2ZW50TW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIHZlcmlmeVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICd2YWx1ZScgc2hvdWxkIGJlIGEgdmFsaWQgSmF2YVNjcmlwdCBEYXRlIGluc3RhbmNlLiBDaGVjayAke1ZBTFVFX0RPQ19MSU5LJDV9IGZvciBwb3NzaWJsZSByZXNvbHV0aW9uLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeU1pbk1heFJhbmdlKCkge1xuICAgICAgICBpZiAoIWlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ZhbGlkUmFuZ2UodGhpcy5taW4sIHRoaXMubWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWF4IHZhbHVlIHNob3VsZCBiZSBiaWdnZXIgdGhhbiB0aGUgbWluLiBTZWUgJHtNSU5fTUFYX0RPQ19MSU5LfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdGltZSBzbG90cyBhbmQgdGhlIGxpdGVyYWxzIHRoYXQgYXJlIG5vdCBwcmVjZWRlZCBieSBkYXRlIHBhcnRzXG4gICAgICogYW5kIGNvbmNhdGVuYXRlcyB0aGUgcmVzdWx0aW5nIHBhcnRzIGludG8gYSBzdHJpbmcuXG4gICAgICogSWYgdGhlIHByb3ZpZGVkIGZvcm1hdCB2YWx1ZSBkb2VzIG5vdCBjb250YWluIGFueSB0aW1lIHBhcnRzLFxuICAgICAqIHJldHVybnMgdGhlIGRlc2lnbmF0ZWQgZm9ybWF0IG9mIHRoZSBkZWZhdWx0IHBvcHVwIGNvbXBvbmVudCBvZiB0aGUgVGltZVBpY2tlci5cbiAgICAgKi9cbiAgICBnZXRUaW1lU2VsZWN0b3JGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IHRpbWVTZWxlY3RvckZvcm1hdCA9IHRoaXMuaW50bFxuICAgICAgICAgICAgLnNwbGl0RGF0ZUZvcm1hdChmb3JtYXQpXG4gICAgICAgICAgICAuZmlsdGVyKHRoaXMudGltZUZvcm1hdFBhcnRGaWx0ZXIpXG4gICAgICAgICAgICAucmVkdWNlKChmb3JtYXQsIHBhcnQpID0+IGZvcm1hdCArPSBwYXJ0LnBhdHRlcm4sICcnKTtcbiAgICAgICAgcmV0dXJuIHRpbWVTZWxlY3RvckZvcm1hdCB8fCBERUZBVUxUX1RJTUVTRUxFQ1RPUl9GT1JNQVQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBgZGlzcGxheUZvcm1hdGAgZnJvbSB0aGUgcHJvdmlkZWQgYHN0cmluZyB8IEZvcm1hdFNldHRpbmdzYCB2YWx1ZS5cbiAgICAgKiBGYWxsYmFja3MgdG8gdGhlIGRlZmF1bHQgaW5wdXQgdmFsdWUsIGlmIGEgZmFsc3kgdmFsdWUgcGFyYW0gaXMgcGFzc2VkLlxuICAgICAqL1xuICAgIGdldERpc3BsYXlGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9EQVRFSU5QVVRfRk9STUFUO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQuZGlzcGxheUZvcm1hdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlsdGVyIGV4cHJlc3Npb24gdGhhdCBmaWx0ZXJzIG91dCBhbGwgZm9ybWF0IHBhcnRzXG4gICAgICogZXhjZXB0IGZvciBgaG91cmAsIGBtaW51dGVgLCBgc2Vjb25kYCwgYGRheXBlcmlvZGAsIGFuZCBzcGVjaWZpYyBsaXRlcmFscy5cbiAgICAgKiBMaXRlcmFscyB3aWxsIGJlIGxlZnQgb25seSBpZiB0aGV5IGFyZSBub3QgcHJlY2VkZWQgYnkgZGF0ZSBwYXJ0cy5cbiAgICAgKi9cbiAgICB0aW1lRm9ybWF0UGFydEZpbHRlcihwYXJ0LCBpbmRleCwgcGFydHMpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNQYXJ0ID0gaW5kZXggPj0gMSAmJiBwYXJ0c1tpbmRleCAtIDFdO1xuICAgICAgICBpZiAocHJldmlvdXNQYXJ0ICYmIHBhcnQudHlwZSA9PT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZUZvcm1hdFJlZ0V4cC50ZXN0KHByZXZpb3VzUGFydC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZUZvcm1hdFJlZ0V4cC50ZXN0KHBhcnQudHlwZSk7XG4gICAgfVxuICAgIHRvZ2dsZVBvcHVwKG9wZW4pIHtcbiAgICAgICAgaWYgKG9wZW4gPT09IHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgUHJldmVudGFibGVFdmVudCgpO1xuICAgICAgICBvcGVuID8gdGhpcy5vcGVuLmVtaXQoZXZlbnQpIDogdGhpcy5jbG9zZS5lbWl0KGV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2dnbGUob3Blbik7XG4gICAgICAgIHRoaXMuc3dpdGNoRm9jdXMoKTtcbiAgICB9XG4gICAgc3dpdGNoRm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWJDb21wb25lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy50b3VjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5pbnB1dC5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVCbHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3BlblBvcHVwKCkge1xuICAgICAgICB0aGlzLnNldENhbGVuZGFyVmFsdWUodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0VGltZVNlbGVjdG9yTWluTWF4KHRoaXMudmFsdWUpO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICAgICAgICBhbmNob3I6IHRoaXMud3JhcHBlcixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucG9wdXBUZW1wbGF0ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uTW9kZTogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGFuaW1hdGU6IHRoaXMucG9wdXBTZXR0aW5ncy5hbmltYXRlLFxuICAgICAgICAgICAgYXBwZW5kVG86IHRoaXMuYXBwZW5kVG8sXG4gICAgICAgICAgICBwb3B1cENsYXNzOiBgay1kYXRldGltZS1jb250YWluZXIgJHt0aGlzLnBvcHVwU2V0dGluZ3MucG9wdXBDbGFzcyB8fCAnJ31gLFxuICAgICAgICAgICAgYW5jaG9yQWxpZ246IHsgdmVydGljYWw6ICdib3R0b20nLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfSxcbiAgICAgICAgICAgIHBvcHVwQWxpZ246IHsgdmVydGljYWw6ICd0b3AnLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cEFuY2hvclZpZXdwb3J0TGVhdmUuc3Vic2NyaWJlKCgpID0+IHRoaXMuaGFuZGxlQ2FuY2VsKCkpO1xuICAgIH1cbiAgICBjbG9zZVBvcHVwKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3B1cFJlZi5jbG9zZSgpO1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gbnVsbDtcbiAgICB9XG4gICAgaGFuZGxlVmFsdWVDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzRXF1YWwodGhpcy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IGNsb25lRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMub25Db250cm9sQ2hhbmdlKGNsb25lRGF0ZSh2YWx1ZSkpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQoY2xvbmVEYXRlKHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBmb2N1cyB0YXJnZXQgaXMgcGFydCBvZiB0aGlzIGNvbXBvbmVudCxcbiAgICAgKiB0aGF0IGlzLCB3aGV0aGVyIHRoZSBmb2N1cyB0YXJnZXQgaXMgaW5zaWRlIHRoZSBjb21wb25lbnQgb3IgaW4gdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIGZvY3VzVGFyZ2V0SW5Db21wb25lbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgZm9jdXNJblBvcHVwID0gaXNQcmVzZW50KHRoaXMucG9wdXBSZWYpICYmIHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50LmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICBjb25zdCBmb2N1c0luV3JhcHBlciA9IHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICByZXR1cm4gZm9jdXNJblBvcHVwIHx8IGZvY3VzSW5XcmFwcGVyO1xuICAgIH1cbiAgICBzZXRUaW1lU2VsZWN0b3JNaW5NYXgoc2VsZWN0ZWREYXRlKSB7XG4gICAgICAgIGNvbnN0IG1pbkRhdGVTZWxlY3RlZCA9IGlzUHJlc2VudChzZWxlY3RlZERhdGUpICYmIGlzRXF1YWwoZ2V0RGF0ZShzZWxlY3RlZERhdGUpLCBnZXREYXRlKHRoaXMubWluKSk7XG4gICAgICAgIHRoaXMudGltZVNlbGVjdG9yTWluID0gY2xvbmVEYXRlKG1pbkRhdGVTZWxlY3RlZCA/IHRoaXMubWluIDogTUlOX1RJTUUpO1xuICAgICAgICBjb25zdCBtYXhEYXRlU2VsZWN0ZWQgPSBpc1ByZXNlbnQoc2VsZWN0ZWREYXRlKSAmJiBpc0VxdWFsKGdldERhdGUoc2VsZWN0ZWREYXRlKSwgZ2V0RGF0ZSh0aGlzLm1heCkpO1xuICAgICAgICB0aGlzLnRpbWVTZWxlY3Rvck1heCA9IGNsb25lRGF0ZShtYXhEYXRlU2VsZWN0ZWQgPyB0aGlzLm1heCA6IE1BWF9USU1FKTtcbiAgICB9XG4gICAgc2V0Q2FsZW5kYXJWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBpc0luQ2FsZW5kYXJSYW5nZSA9IGlzUHJlc2VudCh2YWx1ZSkgJiYgaXNJblJhbmdlKHZhbHVlLCB0aGlzLmNhbGVuZGFyTWluLCB0aGlzLmNhbGVuZGFyTWF4KTtcbiAgICAgICAgdGhpcy5jYWxlbmRhclZhbHVlID0gaXNJbkNhbGVuZGFyUmFuZ2UgPyBnZXREYXRlKHZhbHVlKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBwb3B1cCBpcyBhdmFpbGFibGUsIHJ1bnMgYSBwb3B1cCBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAqL1xuICAgIGRldGVjdFBvcHVwQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9wdXBSZWYucG9wdXAuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIHByZWRpY2F0ZSBgcnVuSW5ab25lYCB2YWx1ZSB0aGF0IGlzIHBhc3NlZCxcbiAgICAgKiBydW5zIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBlaXRoZXIgaW4gdGhlIEFuZ3VsYXIgb3IgaW4gdGhlIGN1cnJlbnQgem9uZS5cbiAgICAgKi9cbiAgICBydW4ocnVuSW5ab25lLCBmbikge1xuICAgICAgICBpZiAocnVuSW5ab25lKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gZm4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZURhdGVDb21wbGV0ZW5lc3NDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpKTtcbiAgICB9XG4gICAgc2V0Q29tcG9uZW50Q2xhc3NlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0U2l6ZUNsYXNzKCdpbnB1dCcsIHRoaXMuc2l6ZSkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCBnZXRTaXplQ2xhc3MoJ2J1dHRvbicsIHRoaXMuc2l6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvdW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsIGdldFJvdW5kZWRDbGFzcyh0aGlzLnJvdW5kZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWxsTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgZ2V0RmlsbE1vZGVDbGFzcygnaW5wdXQnLCB0aGlzLmZpbGxNb2RlKSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLm5hdGl2ZUVsZW1lbnQsIGdldEZpbGxNb2RlQ2xhc3MoJ2J1dHRvbicsIHRoaXMuZmlsbE1vZGUpKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy50b2dnbGVCdXR0b24ubmF0aXZlRWxlbWVudCwgYGstYnV0dG9uLSR7dGhpcy5maWxsTW9kZX0tYmFzZWApO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWRhdGV0aW1lcGlja2VyJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstaW5wdXQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0Q2xhc3Nlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3RvZ2dsZUJ1dHRvbicsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRvZ2dsZUJ1dHRvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0d29EaWdpdFllYXJNYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWREYXRlc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwU2V0dGluZ3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9jdXNhYmxlSWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWFkT25seUlucHV0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNhbmNlbEJ1dHRvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c2VkRGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNhbGVuZGFyVHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRlQ2FsZW5kYXJOYXZpZ2F0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGF0ZV0pXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlVmFsaWRhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZERhdGVzVmFsaWRhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwib3BlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbG9zZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCdmb2N1cycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Gb2N1c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCdibHVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRlZmF1bHRUYWJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaXplXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmRlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZpbGxNb2RlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKENlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoTW9udGhDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTW9udGhDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibW9udGhDZWxsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwieWVhckNlbGxUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVjYWRlQ2VsbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoQ2VudHVyeUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNlbnR1cnlDZWxsVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIZWFkZXJUaXRsZVRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhlYWRlclRpdGxlVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnY29udGFpbmVyJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmLCBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpZXdDb250YWluZXJSZWYpXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGFpbmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3BvcHVwVGVtcGxhdGUnLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbkRhdGVUaW1lUGlja2VyQ29tcG9uZW50ID0gRGF0ZVRpbWVQaWNrZXJDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZGF0ZXRpbWVwaWNrZXInLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvLWRhdGV0aW1lcGlja2VyJyxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgUGlja2VyU2VydmljZSxcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBEaXNhYmxlZERhdGVzU2VydmljZSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTDEwTl9QUkVGSVgsIHVzZVZhbHVlOiAna2VuZG8uZGF0ZXRpbWVwaWNrZXInIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlVGltZVBpY2tlckNvbXBvbmVudF8xKSwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTkdfVkFMSURBVE9SUywgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZVRpbWVQaWNrZXJDb21wb25lbnRfMSksIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IEtlbmRvSW5wdXQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVUaW1lUGlja2VyQ29tcG9uZW50XzEpIH1cbiAgICAgICAgXSxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAga2VuZG9EYXRlVGltZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzXG5cbiAgICAgICAgICAgIGkxOG4tZGF0ZVRhYj1cImtlbmRvLmRhdGV0aW1lcGlja2VyLmRhdGVUYWJ8VGhlIERhdGUgdGFiIHRleHQgaW4gdGhlIGRhdGV0aW1lcGlja2VyIHBvcHVwIGhlYWRlclwiXG4gICAgICAgICAgICBkYXRlVGFiPVwiRGF0ZVwiXG5cbiAgICAgICAgICAgIGkxOG4tZGF0ZVRhYkxhYmVsPVwia2VuZG8uZGF0ZXRpbWVwaWNrZXIuZGF0ZVRhYkxhYmVsfFRoZSBsYWJlbCBmb3IgdGhlIERhdGUgdGFiIGluIHRoZSBkYXRldGltZXBpY2tlciBwb3B1cCBoZWFkZXJcIlxuICAgICAgICAgICAgZGF0ZVRhYkxhYmVsPVwiRGF0ZSB0YWJcIlxuXG4gICAgICAgICAgICBpMThuLXRpbWVUYWI9XCJrZW5kby5kYXRldGltZXBpY2tlci50aW1lVGFifFRoZSBUaW1lIHRhYiB0ZXh0IGluIHRoZSBkYXRldGltZXBpY2tlciBwb3B1cCBoZWFkZXJcIlxuICAgICAgICAgICAgdGltZVRhYj1cIlRpbWVcIlxuXG4gICAgICAgICAgICBpMThuLXRpbWVUYWJMYWJlbD1cImtlbmRvLmRhdGV0aW1lcGlja2VyLnRpbWVUYWJMYWJlbHxUaGUgbGFiZWwgZm9yIHRoZSBUaW1lIHRhYiBpbiB0aGUgZGF0ZXRpbWVwaWNrZXIgcG9wdXAgaGVhZGVyXCJcbiAgICAgICAgICAgIHRpbWVUYWJMYWJlbD1cIlRpbWUgdGFiXCJcblxuICAgICAgICAgICAgaTE4bi10b2dnbGU9XCJrZW5kby5kYXRldGltZXBpY2tlci50b2dnbGV8VGhlIHRpdGxlIG9mIHRoZSB0b2dnbGUgYnV0dG9uIGluIHRoZSBkYXRldGltZXBpY2tlciBjb21wb25lbnRcIlxuICAgICAgICAgICAgdG9nZ2xlPVwiVG9nZ2xlIHBvcHVwXCJcblxuICAgICAgICAgICAgaTE4bi1hY2NlcHQ9XCJrZW5kby5kYXRldGltZXBpY2tlci5hY2NlcHR8VGhlIEFjY2VwdCBidXR0b24gdGV4dCBpbiB0aGUgZGF0ZXRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIGFjY2VwdD1cIlNldFwiXG5cbiAgICAgICAgICAgIGkxOG4tYWNjZXB0TGFiZWw9XCJrZW5kby5kYXRldGltZXBpY2tlci5hY2NlcHRMYWJlbHxUaGUgbGFiZWwgZm9yIHRoZSBBY2NlcHQgYnV0dG9uIGluIHRoZSBkYXRldGltZXBpY2tlciBjb21wb25lbnRcIlxuICAgICAgICAgICAgYWNjZXB0TGFiZWw9XCJTZXRcIlxuXG4gICAgICAgICAgICBpMThuLWNhbmNlbD1cImtlbmRvLmRhdGV0aW1lcGlja2VyLmNhbmNlbHxUaGUgQ2FuY2VsIGJ1dHRvbiB0ZXh0IGluIHRoZSBkYXRldGltZXBpY2tlciBjb21wb25lbnRcIlxuICAgICAgICAgICAgY2FuY2VsPVwiQ2FuY2VsXCJcblxuICAgICAgICAgICAgaTE4bi1jYW5jZWxMYWJlbD1cImtlbmRvLmRhdGV0aW1lcGlja2VyLmNhbmNlbExhYmVsfFRoZSBsYWJlbCBmb3IgdGhlIENhbmNlbCBidXR0b24gaW4gdGhlIGRhdGV0aW1lcGlja2VyIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBjYW5jZWxMYWJlbD1cIkNhbmNlbFwiXG5cbiAgICAgICAgICAgIGkxOG4tbm93PVwia2VuZG8uZGF0ZXRpbWVwaWNrZXIubm93fFRoZSBOb3cgYnV0dG9uIHRleHQgaW4gdGhlIHRpbWVwaWNrZXIgY29tcG9uZW50XCJcbiAgICAgICAgICAgIG5vdz1cIk5PV1wiXG5cbiAgICAgICAgICAgIGkxOG4tbm93TGFiZWw9XCJrZW5kby5kYXRldGltZXBpY2tlci5ub3dMYWJlbHxUaGUgbGFiZWwgZm9yIHRoZSBOb3cgYnV0dG9uIGluIHRoZSB0aW1lcGlja2VyIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBub3dMYWJlbD1cIlNlbGVjdCBub3dcIlxuXG4gICAgICAgICAgICBpMThuLXRvZGF5PVwia2VuZG8uZGF0ZXRpbWVwaWNrZXIudG9kYXl8VGhlIGxhYmVsIGZvciB0aGUgdG9kYXkgYnV0dG9uIGluIHRoZSBjYWxlbmRhciBoZWFkZXJcIlxuICAgICAgICAgICAgdG9kYXk9XCJUb2RheVwiXG5cbiAgICAgICAgICAgIGkxOG4tcHJldkJ1dHRvblRpdGxlPVwia2VuZG8uZGF0ZXRpbWVwaWNrZXIucHJldkJ1dHRvblRpdGxlfFRoZSB0aXRsZSBvZiB0aGUgcHJldmlvdXMgYnV0dG9uIGluIHRoZSBDbGFzc2ljIGNhbGVuZGFyXCJcbiAgICAgICAgICAgIHByZXZCdXR0b25UaXRsZT1cIk5hdmlnYXRlIHRvIHByZXZpb3VzIHZpZXdcIlxuXG4gICAgICAgICAgICBpMThuLW5leHRCdXR0b25UaXRsZT1cImtlbmRvLmRhdGV0aW1lcGlja2VyLm5leHRCdXR0b25UaXRsZXxUaGUgdGl0bGUgb2YgdGhlIG5leHQgYnV0dG9uIGluIHRoZSBDbGFzc2ljIGNhbGVuZGFyXCJcbiAgICAgICAgICAgIG5leHRCdXR0b25UaXRsZT1cIk5hdmlnYXRlIHRvIG5leHQgdmlld1wiXG4gICAgICAgID5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPGtlbmRvLWRhdGVpbnB1dFxuICAgICAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgICAgIFtmb3JtYXRdPVwiZm9ybWF0XCJcbiAgICAgICAgICAgIFt0d29EaWdpdFllYXJNYXhdPVwidHdvRGlnaXRZZWFyTWF4XCJcbiAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgIFtpbmNvbXBsZXRlRGF0ZVZhbGlkYXRpb25dPVwiaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uXCJcbiAgICAgICAgICAgIFtmb3JtYXRQbGFjZWhvbGRlcl09XCJmb3JtYXRQbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seSB8fCByZWFkT25seUlucHV0XCJcbiAgICAgICAgICAgIFtyb2xlXT1cImlucHV0Um9sZVwiXG4gICAgICAgICAgICBbYXJpYVJlYWRPbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgIFtzdGVwc109XCJzdGVwc1wiXG4gICAgICAgICAgICBbdGFiaW5kZXhdPVwidGFiaW5kZXhcIlxuICAgICAgICAgICAgW3RpdGxlXT1cInRpdGxlXCJcbiAgICAgICAgICAgIFtmb2N1c2FibGVJZF09XCJmb2N1c2FibGVJZFwiXG4gICAgICAgICAgICBbaGFzUG9wdXBdPVwidHJ1ZVwiXG4gICAgICAgICAgICBbaXNQb3B1cE9wZW5dPVwiaXNPcGVuXCJcbiAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVJbnB1dFZhbHVlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgIGtleWRvd246IGhhbmRsZUtleURvd25cbiAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgW3Njb3BlXT1cInRoaXNcIlxuICAgICAgICAgICAgW2ZpbGxNb2RlXT1cImZpbGxNb2RlXCJcbiAgICAgICAgICAgIFtyb3VuZGVkXT1cInJvdW5kZWRcIlxuICAgICAgICAgICAgW3NpemVdPVwic2l6ZVwiXG4gICAgICAgID5cbiAgICAgICAgPC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICN0b2dnbGVCdXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWlucHV0LWJ1dHRvbiBrLWJ1dHRvbiBrLWljb24tYnV0dG9uXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCItMVwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCd0b2dnbGUnKVwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ3RvZ2dsZScpXCJcbiAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICBtb3VzZWRvd246IHByZXZlbnRNb3VzZURvd24sXG4gICAgICAgICAgICAgICAgY2xpY2s6IGhhbmRsZUljb25DbGlja1xuICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1idXR0b24taWNvbiBrLWljb25cIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICAgICAgICAgJ2staS1jYWxlbmRhcic6IGFjdGl2ZVRhYiA9PT0gJ2RhdGUnLFxuICAgICAgICAgICAgICAgICAgICAnay1pLWNsb2NrJzogYWN0aXZlVGFiID09PSAndGltZSdcbiAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgID48L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgI2NvbnRhaW5lcj48L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8bmctdGVtcGxhdGUgI3BvcHVwVGVtcGxhdGU+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWRhdGV0aW1lLXdyYXAgay17e2FjdGl2ZVRhYn19LXRhYlwiXG4gICAgICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgICAgICBtb3VzZWRvd246IHByZXZlbnRNb3VzZURvd24sXG4gICAgICAgICAgICAgICAgICAgIGtleWRvd246IGhhbmRsZUtleURvd25cbiAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstZGF0ZXRpbWUtYnV0dG9uZ3JvdXBcIlxuICAgICAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c2luOiBoYW5kbGVGb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3Vzb3V0OiBoYW5kbGVCbHVyXG4gICAgICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1idXR0b24tZ3JvdXAgay1idXR0b24tZ3JvdXAtc3RyZXRjaGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvbiBrLWdyb3VwLXN0YXJ0IGstZGF0ZS10YWJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInBvcHVwQnV0dG9uc0NsYXNzZXMoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstYWN0aXZlXT1cImFjdGl2ZVRhYiA9PT0gJ2RhdGUnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCdkYXRlVGFiTGFiZWwnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdkYXRlVGFiTGFiZWwnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogY2hhbmdlQWN0aXZlVGFiLmJpbmQodGhpcywgJ2RhdGUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ZG93bjogaGFuZGxlQmFja1RhYk91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2xvY2FsaXphdGlvbi5nZXQoJ2RhdGVUYWInKX19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uIGstZ3JvdXAtZW5kIGstdGltZS10YWJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInBvcHVwQnV0dG9uc0NsYXNzZXMoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstYWN0aXZlXT1cImFjdGl2ZVRhYiA9PT0gJ3RpbWUnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCd0aW1lVGFiTGFiZWwnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCd0aW1lVGFiTGFiZWwnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogY2hhbmdlQWN0aXZlVGFiLmJpbmQodGhpcywgJ3RpbWUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7bG9jYWxpemF0aW9uLmdldCgndGltZVRhYicpfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICNkYXRlVGltZVNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1kYXRldGltZS1zZWxlY3RvclwiXG4gICAgICAgICAgICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uXT1cInRhYlN3aXRjaFRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uZW5kOiBoYW5kbGVUYWJDaGFuZ2VUcmFuc2l0aW9uRW5kLmJpbmQodGhpcywgZGF0ZVRpbWVTZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1kYXRldGltZS1jYWxlbmRhci13cmFwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8a2VuZG8tY2FsZW5kYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbKHZhbHVlKV09XCJjYWxlbmRhclZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdHlwZV09XCJjYWxlbmRhclR5cGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttaW5dPVwiY2FsZW5kYXJNaW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttYXhdPVwiY2FsZW5kYXJNYXhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtmb2N1c2VkRGF0ZV09XCJmb2N1c2VkRGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3dlZWtOdW1iZXJdPVwid2Vla051bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25hdmlnYXRpb25dPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFthbmltYXRlTmF2aWdhdGlvbl09XCJhbmltYXRlQ2FsZW5kYXJOYXZpZ2F0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2VsbFRlbXBsYXRlXT1cImNlbGxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW21vbnRoQ2VsbFRlbXBsYXRlXT1cIm1vbnRoQ2VsbFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbeWVhckNlbGxUZW1wbGF0ZV09XCJ5ZWFyQ2VsbFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGVjYWRlQ2VsbFRlbXBsYXRlXT1cImRlY2FkZUNlbGxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NlbnR1cnlDZWxsVGVtcGxhdGVdPVwiY2VudHVyeUNlbGxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3dlZWtOdW1iZXJUZW1wbGF0ZV09XCJ3ZWVrTnVtYmVyVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtoZWFkZXJUaXRsZVRlbXBsYXRlXT1cImhlYWRlclRpdGxlVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlQ2FsZW5kYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZERhdGVzXT1cImRpc2FibGVkRGF0ZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVDYWxlbmRhclZhbHVlQ2hhbmdlKClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxrZW5kby1jYWxlbmRhci1tZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdG9kYXldPVwibG9jYWxpemF0aW9uLmdldCgndG9kYXknKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtwcmV2QnV0dG9uVGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgncHJldkJ1dHRvblRpdGxlJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmV4dEJ1dHRvblRpdGxlXT1cImxvY2FsaXphdGlvbi5nZXQoJ25leHRCdXR0b25UaXRsZScpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9rZW5kby1jYWxlbmRhci1tZXNzYWdlcz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwva2VuZG8tY2FsZW5kYXI+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1kYXRldGltZS10aW1lLXdyYXBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxrZW5kby10aW1lc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtmb3JtYXRdPVwidGltZVNlbGVjdG9yRm9ybWF0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbWluXT1cInRpbWVTZWxlY3Rvck1pblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW21heF09XCJ0aW1lU2VsZWN0b3JNYXhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZXRCdXR0b25dPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjYW5jZWxCdXR0b25dPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdGVwc109XCJzdGVwc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVUaW1lU2VsZWN0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxrZW5kby10aW1lc2VsZWN0b3ItbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25vd109XCJsb2NhbGl6YXRpb24uZ2V0KCdub3cnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtub3dMYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdub3dMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9rZW5kby10aW1lc2VsZWN0b3ItbWVzc2FnZXM+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2tlbmRvLXRpbWVzZWxlY3Rvcj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstZGF0ZXRpbWUtZm9vdGVyIGstYWN0aW9uLWJ1dHRvbnMgay1hY3Rpb25zIGstaHN0YWNrIGstanVzdGlmeS1jb250ZW50LXN0cmV0Y2hcIlxuICAgICAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlkb3duOiBoYW5kbGVUYWJPdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c2luOiBoYW5kbGVGb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3Vzb3V0OiBoYW5kbGVCbHVyXG4gICAgICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImNhbmNlbEJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1idXR0b24gay10aW1lLWNhbmNlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJwb3B1cEJ1dHRvbnNDbGFzc2VzKClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgnY2FuY2VsTGFiZWwnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ2NhbmNlbExhYmVsJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBoYW5kbGVDYW5jZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgW3Njb3BlXT1cInRoaXNcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICB7e2xvY2FsaXphdGlvbi5nZXQoJ2NhbmNlbCcpfX1cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvbiBrLXRpbWUtYWNjZXB0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInBvcHVwQnV0dG9uc0NsYXNzZXMoJ3ByaW1hcnknKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCdhY2NlcHRMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwibG9jYWxpemF0aW9uLmdldCgnYWNjZXB0TGFiZWwnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiIWNhbGVuZGFyVmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBoYW5kbGVBY2NlcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgW3Njb3BlXT1cInRoaXNcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICB7e2xvY2FsaXphdGlvbi5nZXQoJ2FjY2VwdCcpfX1cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgXG4gICAgfSksXG4gICAgX19wYXJhbSg2LCBJbmplY3QoVE9VQ0hfRU5BQkxFRCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUG9wdXBTZXJ2aWNlLFxuICAgICAgICBJbnRsU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIFBpY2tlclNlcnZpY2UsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgRWxlbWVudFJlZiwgQm9vbGVhbiwgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgRGlzYWJsZWREYXRlc1NlcnZpY2UsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBEYXRlVGltZVBpY2tlckNvbXBvbmVudCk7XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggcmVuZGVycyB0aGUgY29udGVudCBvZiB0aGUgRGF0ZVJhbmdlIFBvcHVwLiBUbyBkZWZpbmUgdGhlIGNlbGwgdGVtcGxhdGUsIG5lc3QgYW5cbiAqIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvUmFuZ2VQb3B1cFRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBjb21wb25lbnQgdGFnLlxuICovXG5sZXQgRGF0ZVJhbmdlUG9wdXBUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIERhdGVSYW5nZVBvcHVwVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuRGF0ZVJhbmdlUG9wdXBUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRGF0ZVJhbmdlUG9wdXBUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBEYXRlUmFuZ2VQb3B1cFRlbXBsYXRlRGlyZWN0aXZlKTtcblxuY29uc3QgaXNBY3RpdmUgPSAoY21wKSA9PiAoY21wICYmIGNtcC5pc0FjdGl2ZSkgfHwgZmFsc2U7XG5jb25zdCBoYXNBY3RpdmVDb250ZW50ID0gKHBvcHVwKSA9PiBwb3B1cCAmJiBwb3B1cC5oYXNBY3RpdmVDb250ZW50KCk7XG4vKipcbiAqIEEgc2VydmljZSB0aGF0IGhhbmRsZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgY29tcG9uZW50cyB0aGF0IGFyZSBwbGFjZWQgaW5zaWRlIHRoZSBEYXRlUmFuZ2VDb21wb25lbnQuXG4gKiBGb3IgZXhhbXBsZSwgdGhlIHN0YXJ0IGFuZCBlbmQgYERhdGVJbnB1dGAgYW5kIGBEYXRlUmFuZ2VQb3B1cGAgY29tcG9uZW50cy5cbiAqL1xubGV0IERhdGVSYW5nZVNlcnZpY2UgPSBjbGFzcyBEYXRlUmFuZ2VTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBBIHNlcnZpY2UgdGhhdCBoYW5kbGVzIHRoZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIGNvbXBvbmVudHMgdGhhdCBhcmUgcGxhY2VkIGluc2lkZSB0aGUgRGF0ZVJhbmdlQ29tcG9uZW50LlxuICAgICAqIEZvciBleGFtcGxlLCB0aGUgc3RhcnQgYW5kIGVuZCBgRGF0ZUlucHV0YCBhbmQgYERhdGVSYW5nZVBvcHVwYCBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gT2JzZXJ2YWJsZSBpbnN0YW5jZSB0aGF0IG5vdGlmaWVzIHdoZW4gdGhlIGBhY3RpdmVSYW5nZUVuZGAgc3RhdGUgaXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlUmFuZ2VFbmQkID0gbmV3IEJlaGF2aW9yU3ViamVjdChudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgaW5zdGFuY2UgdGhhdCBub3RpZmllcyB3aGVuIHRoZSBgZm9jdXNlZERhdGVgIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzZWREYXRlJCA9IG5ldyBCZWhhdmlvclN1YmplY3QobnVsbCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBPYnNlcnZhYmxlIGluc3RhbmNlIHRoYXQgbm90aWZpZXMgd2hlbiB0aGUgZW5kIGBEYXRlSW5wdXRgIGNvbXBvbmVudCBpcyBjaGFuZ2VkLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiBhIG5ldyBlbmQgYERhdGVJbnB1dGAgaXMgYXR0YWNoZWQgb3Igd2hlbiB0aGUgb2xkIG9uZSBpcyBkZXRhY2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5kSW5wdXQkID0gbmV3IEJlaGF2aW9yU3ViamVjdChudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgaW5zdGFuY2UgdGhhdCBub3RpZmllcyB3aGVuIHRoZSBzdGFydCBgRGF0ZUlucHV0YCBjb21wb25lbnQgaXMgY2hhbmdlZC5cbiAgICAgICAgICogRm9yIGV4YW1wbGUsIHdoZW4gYSBuZXcgc3RhcnQgYERhdGVJbnB1dGAgaXMgYXR0YWNoZWQgb3IgdGhlIG9sZCBvbmUgaXMgZGV0YWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0SW5wdXQkID0gbmV3IEJlaGF2aW9yU3ViamVjdChudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgaW5zdGFuY2UgdGhhdCBub3RpZmllcyB3aGVuIHRoZSBgRGF0ZVJhbmdlUG9wdXBgIGNvbXBvbmVudCBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VQb3B1cCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KG51bGwpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gT2JzZXJ2YWJsZSBpbnN0YW5jZSB0aGF0IG5vdGlmaWVzIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBzZWxlY3Rpb24gcmFuZ2UgaXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFuZ2UkID0gbmV3IEJlaGF2aW9yU3ViamVjdChFTVBUWV9TRUxFQ1RJT05SQU5HRSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgYGFjdGl2ZVJhbmdlRW5kYCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgYWN0aXZlUmFuZ2VFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVJhbmdlRW5kJC52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBgZm9jdXNlZERhdGVgIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCBmb2N1c2VkRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNlZERhdGUkLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgbWluYCByYW5nZSB2YWx1ZS5cbiAgICAgKiBUaGUgYG1pbmAgdmFsdWUgaXMgZXh0cmFjdGVkIGZyb20gdGhlIGBzdGFydGAgRGF0ZUlucHV0IHZhbHVlIG9yIHRoZSBgbWluYCB2YWx1ZSBvZiB0aGUgQ2FsZW5kYXIuXG4gICAgICovXG4gICAgZ2V0IG1pbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXJ0SW5wdXQkLnZhbHVlIHx8IHt9KS5taW4gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYG1heGAgcmFuZ2UgdmFsdWUuXG4gICAgICogVGhlIGBtYXhgIHZhbHVlIGlzIGV4dHJhY3RlZCBmcm9tIHRoZSBgZW5kYCBEYXRlSW5wdXQgdmFsdWUgb3IgdGhlIGBtYXhgIHZhbHVlIG9mIHRoZSBDYWxlbmRhci5cbiAgICAgKi9cbiAgICBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZW5kSW5wdXQkLnZhbHVlIHx8IHt9KS5tYXggfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBgc2VsZWN0aW9uUmFuZ2VgIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2UkLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIHJlZ2lzdGVyZWQgYERhdGVSYW5nZVBvcHVwYCBjb21wb25lbnQuXG4gICAgICogVGhlIG1ldGhvZCBvcGVucyB0aGUgcG9wdXAgYW5kIGZvY3VzZXMgdGhlIGNhbGVuZGFyLlxuICAgICAqL1xuICAgIGFjdGl2YXRlUG9wdXAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGVSYW5nZVBvcHVwID0gdGhpcy5kYXRlUmFuZ2VQb3B1cCQudmFsdWU7XG4gICAgICAgIGlmICghZGF0ZVJhbmdlUG9wdXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRlUmFuZ2VQb3B1cC5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlcyB0aGUgcmVnaXN0ZXJlZCBgRGF0ZVJhbmdlUG9wdXBgIGNvbXBvbmVudC5cbiAgICAgKiBUaGUgbWV0aG9kIGNsb3NlcyB0aGUgcG9wdXAuXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZVBvcHVwKCkge1xuICAgICAgICBjb25zdCBkYXRlUmFuZ2VQb3B1cCA9IHRoaXMuZGF0ZVJhbmdlUG9wdXAkLnZhbHVlO1xuICAgICAgICBpZiAoIShkYXRlUmFuZ2VQb3B1cCAmJiBkYXRlUmFuZ2VQb3B1cC5zaG93KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGVSYW5nZVBvcHVwLnNob3cgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogRGVhY3RpdmF0ZXMgdGhlIHJlZ2lzdGVyZWQgYERhdGVSYW5nZVBvcHVwYCBjb21wb25lbnQgYW5kIGZpcmVzIHRoZSBgY2FuY2VsYCBldmVudC5cbiAgICAgKiBUaGUgbWV0aG9kIGNsb3NlcyB0aGUgcG9wdXAuXG4gICAgICovXG4gICAgY2FuY2VsUG9wdXAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGVSYW5nZVBvcHVwID0gdGhpcy5kYXRlUmFuZ2VQb3B1cCQudmFsdWU7XG4gICAgICAgIGlmICghKGRhdGVSYW5nZVBvcHVwICYmIGRhdGVSYW5nZVBvcHVwLnNob3cpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGF0ZVJhbmdlUG9wdXAuY2FuY2VsUG9wdXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGVzIGFsbCBvYnNlcnZhYmxlcyB0byBtaXRpZ2F0ZSBwb3NzaWJsZSBtZW1vcnkgbGVha3MuXG4gICAgICogQ2FsbHMgdGhlIG1ldGhvZCB3aGVuIGEgY29tcG9uZW50IHRoYXQgdXNlcyBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSYW5nZUVuZCQuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VQb3B1cCQuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkRGF0ZSQuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5lbmRJbnB1dCQuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5zdGFydElucHV0JC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnJhbmdlJC5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCB3aGVuIGFuIGFjdGl2ZSBjb21wb25lbnQgdGhhdCBpcyBwbGFjZWQgaW5zaWRlIHRoZSBgRGF0ZVJhbmdlQ29tcG9uZW50YCBpcyBkZXRlY3RlZC5cbiAgICAgKiBGb3IgZXhhbXBsZSwgdGhlIG9wZW5lZCBwb3B1cCBvciB0aGUgZm9jdXNlZCBEYXRlSW5wdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYW4gYWN0aXZlIGNvbXBvbmVudCBpcyBwcmVzZW50LlxuICAgICAqL1xuICAgIGhhc0FjdGl2ZUNvbXBvbmVudCgpIHtcbiAgICAgICAgY29uc3QgcG9wdXAgPSB0aGlzLmRhdGVSYW5nZVBvcHVwJC52YWx1ZTtcbiAgICAgICAgY29uc3QgaXNQb3B1cCA9IGlzQWN0aXZlKHBvcHVwKTtcbiAgICAgICAgY29uc3QgaXNTdGFydCA9IGlzQWN0aXZlKHRoaXMuc3RhcnRJbnB1dCQudmFsdWUpO1xuICAgICAgICBjb25zdCBpc0VuZCA9IGlzQWN0aXZlKHRoaXMuZW5kSW5wdXQkLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzUG9wdXAgfHwgaXNTdGFydCB8fCBpc0VuZCB8fCBoYXNBY3RpdmVDb250ZW50KHBvcHVwKSB8fCBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IHN0YXJ0IGBEYXRlSW5wdXRgIGNvbXBvbmVudC4gTm90aWZpZXMgYWxsIGBzdGFydElucHV0JGAgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyU3RhcnRJbnB1dChzdGFydElucHV0KSB7XG4gICAgICAgIHRoaXMuc3RhcnRJbnB1dCQubmV4dChzdGFydElucHV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGVuZCBgRGF0ZUlucHV0YCBjb21wb25lbnQuIE5vdGlmaWVzIGFsbCBgZW5kSW5wdXQkYCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJFbmRJbnB1dChlbmRJbnB1dCkge1xuICAgICAgICB0aGlzLmVuZElucHV0JC5uZXh0KGVuZElucHV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGBEYXRlUmFuZ2VQb3B1cGAgY29tcG9uZW50LiBOb3RpZmllcyBhbGwgYGRhdGVSYW5nZVBvcHVwJGAgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyUG9wdXAoZGF0ZVJhbmdlUG9wdXApIHtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VQb3B1cCQubmV4dChkYXRlUmFuZ2VQb3B1cCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGBhY3RpdmVSYW5nZUVuZGAgdmFsdWUuIE5vdGlmaWVzIGFsbCBgYWN0aXZlUmFuZ2VFbmQkYCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgc2V0QWN0aXZlUmFuZ2VFbmQoYWN0aXZlUmFuZ2UpIHtcbiAgICAgICAgaWYgKCFhY3RpdmVSYW5nZSB8fCB0aGlzLmFjdGl2ZVJhbmdlRW5kID09PSBhY3RpdmVSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlUmFuZ2VFbmQkLm5leHQoYWN0aXZlUmFuZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBmb2N1c2VkIGRhdGUuIE5vdGlmaWVzIGFsbCBgZm9jdXNlZERhdGUkYCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgc2V0Rm9jdXNlZERhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzRXF1YWwodGhpcy5mb2N1c2VkRGF0ZSQudmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXNlZERhdGUkLm5leHQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzZWxlY3Rpb24gcmFuZ2UuIE5vdGlmaWVzIGFsbCBgcmFuZ2UkYCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgc2V0UmFuZ2UocmFuZ2UgPSBFTVBUWV9TRUxFQ1RJT05SQU5HRSkge1xuICAgICAgICB0aGlzLnJhbmdlJC5uZXh0KHJhbmdlKTtcbiAgICB9XG59O1xuRGF0ZVJhbmdlU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgRGF0ZVJhbmdlU2VydmljZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgS2VuZG8gVUkgRGF0ZVJhbmdlUG9wdXAgY29tcG9uZW50IGZvciBBbmd1bGFyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRGF0ZUlucHV0c01vZHVsZSwgRGF0ZVJhbmdlU2VydmljZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWRhdGVpbnB1dHMnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHByb3ZpZGVyczogW0RhdGVSYW5nZVNlcnZpY2VdLFxuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8YnV0dG9uICNhbmNob3IgKGNsaWNrKT1cInBvcHVwLnRvZ2dsZSgpXCI+VG9nZ2xlPC9idXR0b24+XG4gKiAgPGtlbmRvLWRhdGVyYW5nZS1wb3B1cCBbYW5jaG9yXT1cImFuY2hvclwiICNwb3B1cD48L2tlbmRvLWRhdGVyYW5nZS1wb3B1cD5cbiAqIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQgPSBjbGFzcyBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocG9wdXBTZXJ2aWNlLCBkYXRlUmFuZ2VTZXJ2aWNlLCByZWYsIHpvbmUsIHJ0bCkge1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlID0gZGF0ZVJhbmdlU2VydmljZTtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMucnRsID0gcnRsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgdGhlIHBvcHVwIGFuaW1hdGlvbi5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgYW5pbWF0aW9ucyBhcmUgZW5hYmxlZC5cbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgY29udHJvbGxpbmcgdGhlIHBvcHVwIGFuaW1hdGlvbnMsXG4gICAgICAgICAqIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uIFthbmltYXRpb25zXSh7JSBzbHVnIGFuaW1hdGlvbnNfcG9wdXAgJX0pLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyZXMgdGhlIGNvbGxpc2lvbiBiZWhhdmlvciBvZiB0aGUgcG9wdXAuXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgYXJ0aWNsZSBvblxuICAgICAgICAgKiBbdmlld3BvcnQgYm91bmRhcnkgZGV0ZWN0aW9uXSh7JSBzbHVnIHZpZXdwb3J0Ym91bmRhcnlkZXRlY3Rpb25fcG9wdXAgJX0pLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xsaXNpb24gPSB7IGhvcml6b250YWw6ICdmaXQnLCB2ZXJ0aWNhbDogJ2ZsaXAnIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHBvcHVwIGlzIGFib3V0IHRvIG9wZW4uXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgdGhlIGV2ZW50LCB0aGUgcG9wdXAgd2lsbCByZW1haW4gY2xvc2VkLlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHNlY3Rpb24gb25cbiAgICAgICAgICogW2V2ZW50c10oeyUgc2x1ZyBvdmVydmlld19kYXRlcGlja2VyICV9I3RvYy1ldmVudHMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBjbG9zZS5cbiAgICAgICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCB0aGUgZXZlbnQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBvcGVuLlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHNlY3Rpb24gb25cbiAgICAgICAgICogW2V2ZW50c10oeyUgc2x1ZyBvdmVydmlld19kYXRlcGlja2VyICV9I3RvYy1ldmVudHMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgY2FsZW5kYXIgZWxlbWVudCBpcyBibHVycmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGNhbGVuZGFyIGVsZW1lbnQgaXMgZm9jdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgY2xvc2VkIGVpdGhlciBvbiBgRVNDYCBrZXlwcmVzcyBvciBvbiBsZWF2aW5nIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3B1cFVJRCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhclN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMucG9wdXBTdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLnJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYWN0aXZlIGNhbGVuZGFyIHRoYXQgaXMgdmlzaWJsZSBpbiB0aGUgcG9wdXAuXG4gICAgICpcbiAgICAgKiA+IFdoZW4gdGhlIHBvcHVwIGlzIGNsb3NlZCwgdGhlIHByb3BlcnR5IHJldHVybnMgYG51bGxgLlxuICAgICAqL1xuICAgIGdldCBjYWxlbmRhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGVuZGFyO1xuICAgIH1cbiAgICBzZXQgY2FsZW5kYXIoY2FsZW5kYXIpIHtcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIgPSBjYWxlbmRhcjtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVGb2N1c0JsdXIoY2FsZW5kYXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBXaGVuIHRoZSBvcGVuZWQgY2FsZW5kYXIgaXMgYWN0aXZlLCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKi9cbiAgICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyICYmIHRoaXMuY2FsZW5kYXIuaXNBY3RpdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHNldCBzaG93KHNob3cpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3cgPT09IHNob3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBQcmV2ZW50YWJsZUV2ZW50KCk7XG4gICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4uZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RvZ2dsZShzaG93KTtcbiAgICB9XG4gICAgZ2V0IHNob3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnJlZ2lzdGVyUG9wdXAodGhpcyk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5jYWxlbmRhclN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuY29udGVudENhbGVuZGFyLmNoYW5nZXMuc3Vic2NyaWJlKChjaGFuZ2VzKSA9PiB0aGlzLmNhbGVuZGFyID0gY2hhbmdlcy5maXJzdCkpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3Vic2NyaXB0aW9ucy5hZGQodGhpcy52aWV3Q2FsZW5kYXIuY2hhbmdlcy5zdWJzY3JpYmUoKGNoYW5nZXMpID0+IHRoaXMuY2FsZW5kYXIgPSBjaGFuZ2VzLmZpcnN0KSk7XG4gICAgICAgIGlmIChpc1dpbmRvd0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy53aW5kb3dCbHVyU3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KHdpbmRvdywgJ2JsdXInKS5zdWJzY3JpYmUodGhpcy5oYW5kbGVXaW5kb3dCbHVyLmJpbmQodGhpcykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95UG9wdXAoKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhclN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdGVTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ibHVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmJsdXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53aW5kb3dCbHVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvd0JsdXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgT3BlbnMgdGhlIHBvcHVwIGNvbXBvbmVudCBhbmQgZm9jdXNlcyB0aGUgY2FsZW5kYXIuXG4gICAgICovXG4gICAgYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3cgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVN1YnNjcmlwdGlvbiA9IG1lcmdlKHRoaXMuY29udGVudENhbGVuZGFyLmNoYW5nZXMsIHRoaXMudmlld0NhbGVuZGFyLmNoYW5nZXMpXG4gICAgICAgICAgICAgICAgLnBpcGUoZmlsdGVyKGNoYW5nZXMgPT4gY2hhbmdlcyAmJiBjaGFuZ2VzLmZpcnN0KSwgbWFwKGNoYW5nZXMgPT4gY2hhbmdlcy5maXJzdCkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoY2FsZW5kYXIpID0+IHNldFRpbWVvdXQoKCkgPT4gY2FsZW5kYXIuZm9jdXMoKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEZvY3VzZXMgdGhlIGNhbGVuZGFyIChpZiBhdmFpbGFibGUpLlxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhcikge1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhci5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGZvY3VzZWQgZWxlbWVudCBpZHMgcGxhY2VkIGluc2lkZSB0aGUgcG9wdXAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW47XG4gICAgICovXG4gICAgaGFzQWN0aXZlQ29udGVudCgpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkgfHwgIXRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHBvcHVwLlxuICAgICAqIElmIHlvdSB1c2UgdGhlIGB0b2dnbGVgIG1ldGhvZCB0byBzaG93IG9yIGhpZGUgdGhlIHBvcHVwLFxuICAgICAqIHRoZSBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIGRvIG5vdCBmaXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNob3cgVGhlIHN0YXRlIG9mIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICB0b2dnbGUoc2hvdykge1xuICAgICAgICB0aGlzLnJlc29sdmVkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZSgoc2hvdyA9PT0gdW5kZWZpbmVkKSA/ICF0aGlzLnNob3cgOiBzaG93KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIENsb3NlcyB0aGUgcG9wdXAgYW5kIHRyaWdnZXJzIHRoZSBgY2FuY2VsYCBldmVudC5cbiAgICAgKi9cbiAgICBjYW5jZWxQb3B1cCgpIHtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuY2VsLmVtaXQoKTtcbiAgICB9XG4gICAgaGFuZGxlV2luZG93Qmx1cigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNob3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMuY2xvc2UpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHRoaXMuc2hvdyA9IGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU1vdXNlTGVhdmUoKSB7XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5zZXRSYW5nZSh0aGlzLmRhdGVSYW5nZVNlcnZpY2Uuc2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cbiAgICBoYW5kbGVLZXlkb3duKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgYWx0S2V5LCBrZXlDb2RlIH0gPSBldmVudDtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRXNjYXBlIHx8IChhbHRLZXkgJiYga2V5Q29kZSA9PT0gS2V5cy5BcnJvd1VwKSkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLmNhbmNlbFBvcHVwKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZUZvY3VzQmx1cihjYWxlbmRhcikge1xuICAgICAgICBpZiAodGhpcy5ibHVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmJsdXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbGVuZGFyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmF0aXZlRWxlbWVudCA9IGNhbGVuZGFyLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5ibHVyU3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KG5hdGl2ZUVsZW1lbnQsICdibHVyJykuc3Vic2NyaWJlKCgpID0+IHRoaXMub25CbHVyLmVtaXQoKSk7XG4gICAgICAgIHRoaXMuZm9jdXNTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQobmF0aXZlRWxlbWVudCwgJ2ZvY3VzJykuc3Vic2NyaWJlKCgpID0+IHRoaXMub25Gb2N1cy5lbWl0KCkpO1xuICAgIH1cbiAgICBhZGRQb3B1cFN1YnNjcmlwdGlvbnMoLi4uc3Vic2NyaXB0aW9ucykge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnBvcHVwU3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBTdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmlwdGlvbnMubWFwKHMgPT4gdGhpcy5wb3B1cFN1YnNjcmlwdGlvbnMuYWRkKHMpKTtcbiAgICB9XG4gICAgZ2V0IF9hcHBlbmRUbygpIHtcbiAgICAgICAgY29uc3QgYXBwZW5kVG8gPSB0aGlzLmFwcGVuZFRvO1xuICAgICAgICBpZiAoIWFwcGVuZFRvIHx8IGFwcGVuZFRvID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGVuZFRvID09PSAnY29tcG9uZW50JyA/IHRoaXMuY29udGFpbmVyIDogYXBwZW5kVG87XG4gICAgfVxuICAgIF90b2dnbGUoc2hvdykge1xuICAgICAgICB0aGlzLl9zaG93ID0gc2hvdztcbiAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVBvcHVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Nob3cpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMucnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSB0aGlzLnBvcHVwU2VydmljZS5vcGVuKHtcbiAgICAgICAgICAgICAgICBhbmNob3I6IHRoaXMuYW5jaG9yLFxuICAgICAgICAgICAgICAgIGFuY2hvckFsaWduOiB0aGlzLmFuY2hvckFsaWduIHx8IHsgdmVydGljYWw6ICdib3R0b20nLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfSxcbiAgICAgICAgICAgICAgICBhbmltYXRlOiB0aGlzLmFuaW1hdGUsXG4gICAgICAgICAgICAgICAgYXBwZW5kVG86IHRoaXMuX2FwcGVuZFRvLFxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbjogdGhpcy5jb2xsaXNpb24sXG4gICAgICAgICAgICAgICAgY29udGVudDogKHRoaXMuY29udGVudFRlbXBsYXRlIHx8IHt9KS50ZW1wbGF0ZVJlZiB8fCB0aGlzLmRlZmF1bHRUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICBtYXJnaW46IHRoaXMubWFyZ2luLFxuICAgICAgICAgICAgICAgIHBvcHVwQWxpZ246IHRoaXMucG9wdXBBbGlnbiB8fCB7IHZlcnRpY2FsOiAndG9wJywgaG9yaXpvbnRhbDogZGlyZWN0aW9uIH0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25Nb2RlOiAnYWJzb2x1dGUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9wdXBFbGVtZW50LCBwb3B1cEFuY2hvclZpZXdwb3J0TGVhdmUgfSA9IHRoaXMucG9wdXBSZWY7XG4gICAgICAgICAgICBwb3B1cEVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMucG9wdXBVSUQpO1xuICAgICAgICAgICAgdGhpcy5hZGRQb3B1cFN1YnNjcmlwdGlvbnModGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IGZyb21FdmVudChwb3B1cEVsZW1lbnQsICdrZXlkb3duJykuc3Vic2NyaWJlKHRoaXMuaGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKSksIGZyb21FdmVudChwb3B1cEVsZW1lbnQsICdtb3VzZWxlYXZlJykuc3Vic2NyaWJlKHRoaXMuaGFuZGxlTW91c2VMZWF2ZS5iaW5kKHRoaXMpKSwgcG9wdXBBbmNob3JWaWV3cG9ydExlYXZlLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNhbmNlbFBvcHVwKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95UG9wdXAoKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wb3B1cFJlZikpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wb3B1cFN1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwU3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnY29udGFpbmVyJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmLCBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBWaWV3Q29udGFpbmVyUmVmKVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRhaW5lclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdkZWZhdWx0VGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImRlZmF1bHRUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKERhdGVSYW5nZVBvcHVwVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZVJhbmdlUG9wdXBUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250ZW50VGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZHJlbihNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aWV3Q2FsZW5kYXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250ZW50Q2FsZW5kYXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImFuY2hvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImFuY2hvckFsaWduXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiYXBwZW5kVG9cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xsaXNpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cEFsaWduXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcIm9wZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xvc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgnYmx1cicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwib25CbHVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoJ2ZvY3VzJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVSYW5nZVBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImNhbmNlbFwiLCB2b2lkIDApO1xuRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvLWRhdGVyYW5nZS1wb3B1cCcsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZGF0ZXJhbmdlLXBvcHVwJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciAjY29udGFpbmVyPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRUZW1wbGF0ZT5cbiAgICAgICAgICAgIDxrZW5kby1tdWx0aXZpZXdjYWxlbmRhciBrZW5kb0RhdGVSYW5nZVNlbGVjdGlvbj48L2tlbmRvLW11bHRpdmlld2NhbGVuZGFyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIEluamVjdChSVEwpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1BvcHVwU2VydmljZSxcbiAgICAgICAgRGF0ZVJhbmdlU2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIE5nWm9uZSwgQm9vbGVhbl0pXG5dLCBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgS2VuZG8gVUkgRGF0ZVJhbmdlIGNvbXBvbmVudCBmb3IgQW5ndWxhci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWRhdGVyYW5nZT5cbiAqICAgICAgPGtlbmRvLWRhdGVpbnB1dCBrZW5kb0RhdGVSYW5nZVN0YXJ0SW5wdXQgWyh2YWx1ZSldPVwiZGF0ZVJhbmdlLnN0YXJ0XCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gKiAgICAgIDxrZW5kby1kYXRlaW5wdXQga2VuZG9EYXRlUmFuZ2VFbmRJbnB1dCBbKHZhbHVlKV09XCJkYXRlUmFuZ2UuZW5kXCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gKiAgPC9rZW5kby1kYXRlcmFuZ2U+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBkYXRlUmFuZ2U6IGFueSA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuICogfVxuICogYGBgXG4gKi9cbmxldCBEYXRlUmFuZ2VDb21wb25lbnQgPSBjbGFzcyBEYXRlUmFuZ2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0IGhhc0NvbnRlbnRQb3B1cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFBvcHVwLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy5zaG93RGVmYXVsdCA9ICF0aGlzLmhhc0NvbnRlbnRQb3B1cDtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmNvbnRlbnRQb3B1cC5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNob3dEZWZhdWx0ID0gIXRoaXMuaGFzQ29udGVudFBvcHVwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBEYXRlUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRlbnRQb3B1cFwiLCB2b2lkIDApO1xuRGF0ZVJhbmdlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbRGF0ZVJhbmdlU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZGF0ZXJhbmdlJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8a2VuZG8tZGF0ZXJhbmdlLXBvcHVwICpuZ0lmPVwic2hvd0RlZmF1bHRcIj48L2tlbmRvLWRhdGVyYW5nZS1wb3B1cD5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgRGF0ZVJhbmdlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERhdGVSYW5nZUlucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmVSYW5nZUVuZCwgZGF0ZVJhbmdlU2VydmljZSwgaW5wdXQsIGVsZW1lbnQsIHJlbmRlcmVyLCB6b25lKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUmFuZ2VFbmQgPSBhY3RpdmVSYW5nZUVuZDtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlID0gZGF0ZVJhbmdlU2VydmljZTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMubmF2aWdhdGVDYWxlbmRhck9uRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb3B1cFN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgZ2V0IGlzQWN0aXZlRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLmFjdGl2ZVJhbmdlRW5kID09PSB0aGlzLmFjdGl2ZVJhbmdlRW5kO1xuICAgIH1cbiAgICBnZXQgcG9wdXBDYWxlbmRhckFjdGl2YXRlZCgpIHtcbiAgICAgICAgY29uc3QgcG9wdXAgPSB0aGlzLmRhdGVSYW5nZVNlcnZpY2UuZGF0ZVJhbmdlUG9wdXAkLnZhbHVlO1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHBvcHVwKSAmJiBpc1ByZXNlbnQocG9wdXAuY2FsZW5kYXIpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dC52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnNldFJhbmdlKHRoaXMuZ2V0UmFuZ2UodGhpcy5pbnB1dC52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIFtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQub25CbHVyLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRlYWN0aXZhdGUoKSksXG4gICAgICAgICAgICB0aGlzLmlucHV0Lm9uRm9jdXMucGlwZShmaWx0ZXIoKCkgPT4gIXRoaXMucG9wdXBDYWxlbmRhckFjdGl2YXRlZCkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmFjdGl2YXRlKCkpLFxuICAgICAgICAgICAgdGhpcy5pbnB1dC52YWx1ZVVwZGF0ZS5zdWJzY3JpYmUodmFsdWUgPT4gdGhpcy51cGRhdGVSYW5nZSh2YWx1ZSwgJ2NoYW5nZScpKSxcbiAgICAgICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5hY3RpdmVSYW5nZUVuZCQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uYXZpZ2F0ZUNhbGVuZGFyT25Gb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzQWN0aXZlRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZUNsYXNzKHRoaXMuaXNBY3RpdmVFbmQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLmRhdGVSYW5nZVNlcnZpY2UuZGF0ZVJhbmdlUG9wdXAkLnN1YnNjcmliZShwb3B1cCA9PiB0aGlzLmluaXRQb3B1cChwb3B1cCkpLFxuICAgICAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnJhbmdlJC5zdWJzY3JpYmUocmFuZ2UgPT4gdGhpcy51cGRhdGVJbnB1dFZhbHVlKHJhbmdlKSksXG4gICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdjbGljaycpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmFjdGl2YXRlKCkpLFxuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAna2V5ZG93bicpLnN1YnNjcmliZSgoZXZlbnQpID0+IHRoaXMudG9nZ2xlUG9wdXAoZXZlbnQgfHwge30pKVxuICAgICAgICBdLm1hcChzID0+IHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQocykpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZVBvcHVwKCk7XG4gICAgfVxuICAgIGluaXRQb3B1cChwb3B1cCkge1xuICAgICAgICBpZiAoIXBvcHVwKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlUG9wdXAoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBvcHVwLmFuY2hvcikge1xuICAgICAgICAgICAgcG9wdXAuYW5jaG9yID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgW1xuICAgICAgICAgICAgcG9wdXAuY2FuY2VsLnN1YnNjcmliZSgoKSA9PiB0aGlzLmlzQWN0aXZlRW5kICYmIHRoaXMuaW5wdXQuZm9jdXMoKSksXG4gICAgICAgICAgICBwb3B1cC5vbkZvY3VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLnRvZ2dsZUFjdGl2ZUNsYXNzKHRoaXMuaXNBY3RpdmVFbmQpKSxcbiAgICAgICAgICAgIHBvcHVwLm9uQmx1ci5zdWJzY3JpYmUoKCkgPT4gdGhpcy5kZWFjdGl2YXRlKCkpXG4gICAgICAgIF0ubWFwKHMgPT4gdGhpcy5wb3B1cFN1YnNjcmlwdGlvbnMuYWRkKHMpKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVQb3B1cCgpIHtcbiAgICAgICAgdGhpcy5wb3B1cFN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5wb3B1cFN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgfVxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLmRhdGVSYW5nZVNlcnZpY2Uuc2V0QWN0aXZlUmFuZ2VFbmQodGhpcy5hY3RpdmVSYW5nZUVuZCk7XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5hY3RpdmF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMuaW5wdXQudmFsdWUsICdibHVyJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0ZVJhbmdlU2VydmljZS5oYXNBY3RpdmVDb21wb25lbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlQ2xhc3MoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLmRlYWN0aXZhdGVQb3B1cCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlUmFuZ2UodmFsdWUsIGNvcnJlY3RPbikge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UodmFsdWUsIGNvcnJlY3RPbik7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0FjdGl2ZURhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9nZ2xlUG9wdXAoeyBhbHRLZXksIGtleUNvZGUgfSkge1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Fc2NhcGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5jYW5jZWxQb3B1cCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsdEtleSAmJiBrZXlDb2RlID09PSBLZXlzLkFycm93RG93bikge1xuICAgICAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLmFjdGl2YXRlUG9wdXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb2N1c0FjdGl2ZURhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0LnZhbHVlICYmIHRoaXMuaXNBY3RpdmVFbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5zZXRGb2N1c2VkRGF0ZShjbG9uZURhdGUodGhpcy5pbnB1dC52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvZ2dsZUFjdGl2ZUNsYXNzKHNob3cpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gc2hvdyA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnO1xuICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChuYXRpdmVFbGVtZW50ICYmIG5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlclthY3Rpb25dKG5hdGl2ZUVsZW1lbnQsICdrLWZvY3VzJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbWFuYWdlcyB0aGUgZW5kIHJhbmdlIHNlbGVjdGlvbi5cbiAqXG4gKiA+IFlvdSBjYW4gdXNlIHRoZSBEYXRlUmFuZ2VFbmRJbnB1dERpcmVjdGl2ZSBvbmx5IHdpdGggYSBEYXRlSW5wdXQgY29tcG9uZW50LlxuICovXG5sZXQgRGF0ZVJhbmdlRW5kSW5wdXREaXJlY3RpdmUgPSBjbGFzcyBEYXRlUmFuZ2VFbmRJbnB1dERpcmVjdGl2ZSBleHRlbmRzIERhdGVSYW5nZUlucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZVNlcnZpY2UsIGRhdGVJbnB1dCwgZWxlbWVudCwgcmVuZGVyZXIsIHpvbmUpIHtcbiAgICAgICAgc3VwZXIoJ2VuZCcsIHJhbmdlU2VydmljZSwgZGF0ZUlucHV0LCBlbGVtZW50LCByZW5kZXJlciwgem9uZSk7XG4gICAgICAgIHRoaXMucmFuZ2VTZXJ2aWNlID0gcmFuZ2VTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGVJbnB1dCA9IGRhdGVJbnB1dDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbmF2aWdhdGlvbiBiZWhhdmlvciBvZiB0aGUgY2FsZW5kYXIgd2hlbiB0aGUgYWN0aXZlIGVuZCBpcyBjaGFuZ2VkIG9uIGlucHV0IGZvY3VzLiBXaGVuIGVuYWJsZWQsXG4gICAgICAgICAqIHRoZSBjYWxlbmRhciBuYXZpZ2F0ZXMgdG8gdGhlIHZhbHVlIG9mIHRoZSBmb2N1c2VkIGlucHV0LiBPdGhlcndpc2UsIHRoZSBjYWxlbmRhciBkaXNwbGF5cyB0aGUgbGFzdCBwaWNrZWQgZGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGF1dG9tYXRpYyBuYXZpZ2F0aW9uIGJlaGF2aW9yIG9uIGlucHV0IGZvY3VzIGlzIGRpc2FibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogIDxoNT5Ub2dnbGUgaW5wdXQgZm9jdXMgdG8gc2VlIHRoZSBjYWxlbmRhciBuYXZpZ2F0aW5nIGJldHdlZW4gcmFuZ2UgZW5kcy48L2g1PlxuICAgICAgICAgKiAgPGtlbmRvLWRhdGVyYW5nZT5cbiAgICAgICAgICogICAgICA8a2VuZG8tZGF0ZWlucHV0IGtlbmRvRGF0ZVJhbmdlU3RhcnRJbnB1dCBbbmF2aWdhdGVDYWxlbmRhck9uRm9jdXNdPVwidHJ1ZVwiIFsodmFsdWUpXT1cInN0YXJ0XCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICAgICAqICAgICAgPGtlbmRvLWRhdGVpbnB1dCBrZW5kb0RhdGVSYW5nZUVuZElucHV0IFtuYXZpZ2F0ZUNhbGVuZGFyT25Gb2N1c109XCJ0cnVlXCIgWyh2YWx1ZSldPVwiZW5kXCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICAgICAqICA8L2tlbmRvLWRhdGVyYW5nZT5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgc3RhcnQ6IERhdGUgPSBuZXcgRGF0ZSgyMDE4LCAzLCAxMCk7XG4gICAgICAgICAqICAgcHVibGljIGVuZDogRGF0ZSA9IG5ldyBEYXRlKDIwMTgsIDEwLCAyMCk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRlQ2FsZW5kYXJPbkZvY3VzID0gZmFsc2U7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnJhbmdlU2VydmljZS5yZWdpc3RlckVuZElucHV0KHRoaXMuZGF0ZUlucHV0KTtcbiAgICAgICAgc3VwZXIuaW5pdCgpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXRSYW5nZSh2YWx1ZSwgY29ycmVjdE9uKSB7XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMuZGF0ZUlucHV0O1xuICAgICAgICBpZiAoIWlzSW5SYW5nZSh2YWx1ZSwgbWluLCBtYXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXJ0IH0gPSB0aGlzLnJhbmdlU2VydmljZS5zZWxlY3Rpb25SYW5nZSB8fCBFTVBUWV9TRUxFQ1RJT05SQU5HRTtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ2xhbXAgPSB0aGlzLmF1dG9Db3JyZWN0T24gPT09IGNvcnJlY3RPbiAmJiBpc1ByZXNlbnQodmFsdWUpICYmIHZhbHVlIDwgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzaG91bGRDbGFtcCA/IGNsYW1wUmFuZ2UodmFsdWUpIDogeyBzdGFydCwgZW5kOiBjbG9uZURhdGUodmFsdWUpIH07XG4gICAgfVxuICAgIHVwZGF0ZUlucHV0VmFsdWUocmFuZ2UkJDEpIHtcbiAgICAgICAgY29uc3QgeyBlbmQgfSA9IHJhbmdlJCQxIHx8IEVNUFRZX1NFTEVDVElPTlJBTkdFO1xuICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzLmRhdGVJbnB1dDtcbiAgICAgICAgaWYgKGlzRXF1YWwodGhpcy5kYXRlSW5wdXQudmFsdWUsIGVuZCkgfHwgIWlzSW5SYW5nZShlbmQsIG1pbiwgbWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZUlucHV0LndyaXRlVmFsdWUoY2xvbmVEYXRlKGVuZCkpO1xuICAgICAgICB0aGlzLmRhdGVJbnB1dC5ub3RpZnkoKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZVJhbmdlRW5kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImF1dG9Db3JyZWN0T25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRlUmFuZ2VFbmRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibmF2aWdhdGVDYWxlbmRhck9uRm9jdXNcIiwgdm9pZCAwKTtcbkRhdGVSYW5nZUVuZElucHV0RGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9EYXRlUmFuZ2VFbmRJbnB1dF0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlUmFuZ2VTZXJ2aWNlLFxuICAgICAgICBEYXRlSW5wdXRDb21wb25lbnQsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTmdab25lXSlcbl0sIERhdGVSYW5nZUVuZElucHV0RGlyZWN0aXZlKTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBtYW5hZ2VzIHRoZSBzdGFydCBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogPiBZb3UgY2FuIHVzZSB0aGUgRGF0ZVJhbmdlU3RhcnRJbnB1dERpcmVjdGl2ZSBvbmx5IHdpdGggYSBEYXRlSW5wdXQgY29tcG9uZW50LlxuICovXG5sZXQgRGF0ZVJhbmdlU3RhcnRJbnB1dERpcmVjdGl2ZSA9IGNsYXNzIERhdGVSYW5nZVN0YXJ0SW5wdXREaXJlY3RpdmUgZXh0ZW5kcyBEYXRlUmFuZ2VJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2VTZXJ2aWNlLCBkYXRlSW5wdXQsIGVsZW1lbnQsIHJlbmRlcmVyLCB6b25lKSB7XG4gICAgICAgIHN1cGVyKCdzdGFydCcsIHJhbmdlU2VydmljZSwgZGF0ZUlucHV0LCBlbGVtZW50LCByZW5kZXJlciwgem9uZSk7XG4gICAgICAgIHRoaXMucmFuZ2VTZXJ2aWNlID0gcmFuZ2VTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGVJbnB1dCA9IGRhdGVJbnB1dDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbmF2aWdhdGlvbiBiZWhhdmlvciBvZiB0aGUgY2FsZW5kYXIgd2hlbiB0aGUgYWN0aXZlIGVuZCBpcyBjaGFuZ2VkIG9uIGlucHV0IGZvY3VzLlxuICAgICAgICAgKiBXaGVuIGVuYWJsZWQsIHRoZSBjYWxlbmRhciBuYXZpZ2F0ZXMgdG8gdGhlIHZhbHVlIG9mIHRoZSBmb2N1c2VkIGlucHV0LiBPdGhlcndpc2UsIHRoZSBjYWxlbmRhclxuICAgICAgICAgKiBkaXNwbGF5cyB0aGUgbGFzdCBwaWNrZWQgZGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGF1dG9tYXRpYyBuYXZpZ2F0aW9uIGJlaGF2aW9yIG9uIGlucHV0IGZvY3VzIGlzIGRpc2FibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogIDxoNT5Ub2dnbGUgaW5wdXQgZm9jdXMgdG8gc2VlIHRoZSBjYWxlbmRhciBuYXZpZ2F0aW5nIGJldHdlZW4gcmFuZ2UgZW5kcy48L2g1PlxuICAgICAgICAgKiAgPGtlbmRvLWRhdGVyYW5nZT5cbiAgICAgICAgICogICAgICA8a2VuZG8tZGF0ZWlucHV0IGtlbmRvRGF0ZVJhbmdlU3RhcnRJbnB1dCBbbmF2aWdhdGVDYWxlbmRhck9uRm9jdXNdPVwidHJ1ZVwiIFsodmFsdWUpXT1cInN0YXJ0XCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICAgICAqICAgICAgPGtlbmRvLWRhdGVpbnB1dCBrZW5kb0RhdGVSYW5nZUVuZElucHV0IFtuYXZpZ2F0ZUNhbGVuZGFyT25Gb2N1c109XCJ0cnVlXCIgWyh2YWx1ZSldPVwiZW5kXCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICAgICAqICA8L2tlbmRvLWRhdGVyYW5nZT5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgc3RhcnQ6IERhdGUgPSBuZXcgRGF0ZSgyMDE4LCAzLCAxMCk7XG4gICAgICAgICAqICAgcHVibGljIGVuZDogRGF0ZSA9IG5ldyBEYXRlKDIwMTgsIDEwLCAyMCk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRlQ2FsZW5kYXJPbkZvY3VzID0gZmFsc2U7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnJhbmdlU2VydmljZS5yZWdpc3RlclN0YXJ0SW5wdXQodGhpcy5kYXRlSW5wdXQpO1xuICAgICAgICBzdXBlci5pbml0KCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGdldFJhbmdlKHZhbHVlLCBjb3JyZWN0T24pIHtcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcy5kYXRlSW5wdXQ7XG4gICAgICAgIGlmICghaXNJblJhbmdlKHZhbHVlLCBtaW4sIG1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZW5kIH0gPSB0aGlzLnJhbmdlU2VydmljZS5zZWxlY3Rpb25SYW5nZSB8fCBFTVBUWV9TRUxFQ1RJT05SQU5HRTtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ2xhbXAgPSB0aGlzLmF1dG9Db3JyZWN0T24gPT09IGNvcnJlY3RPbiAmJiBlbmQgJiYgdmFsdWUgPiBlbmQ7XG4gICAgICAgIHJldHVybiBzaG91bGRDbGFtcCA/IGNsYW1wUmFuZ2UodmFsdWUpIDogeyBzdGFydDogY2xvbmVEYXRlKHZhbHVlKSwgZW5kIH07XG4gICAgfVxuICAgIHVwZGF0ZUlucHV0VmFsdWUocmFuZ2UkJDEpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCB9ID0gcmFuZ2UkJDEgfHwgRU1QVFlfU0VMRUNUSU9OUkFOR0U7XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMuZGF0ZUlucHV0O1xuICAgICAgICBpZiAoaXNFcXVhbCh0aGlzLmRhdGVJbnB1dC52YWx1ZSwgc3RhcnQpIHx8ICFpc0luUmFuZ2Uoc3RhcnQsIG1pbiwgbWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZUlucHV0LndyaXRlVmFsdWUoY2xvbmVEYXRlKHN0YXJ0KSk7XG4gICAgICAgIHRoaXMuZGF0ZUlucHV0Lm5vdGlmeSgpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlUmFuZ2VTdGFydElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhdXRvQ29ycmVjdE9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0ZVJhbmdlU3RhcnRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibmF2aWdhdGVDYWxlbmRhck9uRm9jdXNcIiwgdm9pZCAwKTtcbkRhdGVSYW5nZVN0YXJ0SW5wdXREaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RhdGVSYW5nZVN0YXJ0SW5wdXRdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGF0ZVJhbmdlU2VydmljZSxcbiAgICAgICAgRGF0ZUlucHV0Q29tcG9uZW50LFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBEYXRlUmFuZ2VTdGFydElucHV0RGlyZWN0aXZlKTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBtYW5hZ2VzIHRoZSBNdWx0aVZpZXdDYWxlbmRhciByYW5nZSBzZWxlY3Rpb24uXG4gKi9cbmxldCBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUgPSBjbGFzcyBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGVuZGFyLCBjZHIsIGVsZW1lbnQsIHJlbmRlcmVyLCBkYXRlUmFuZ2VTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXIgPSBjYWxlbmRhcjtcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZSA9IGRhdGVSYW5nZVNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGF1dG8tY29ycmVjdGlvbiBiZWhhdmlvci4gSWYgdGhlIHN0YXJ0IGRhdGUgaXMgZ3JlYXRlciB0aGFuIHRoZSBlbmQgZGF0ZSxcbiAgICAgICAgICogdGhlIGRpcmVjdGl2ZSBmaXhlcyB0aGUgZGF0ZSByYW5nZSB0byBhIHNpbmdsZSBkYXRlIGVpdGhlciBvbiBpbnB1dCBjaGFuZ2Ugb3Igb24gYmx1clxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGF1dG9jb3JyZWN0X2RhdGVyYW5nZSAlfSN0b2MtY29uZmlndXJpbmctdGhlLWNhbGVuZGFyLXNlbGVjdGlvbi1kaXJlY3RpdmUpKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGF1dG8tY29ycmVjdGlvbiBpcyB0cmlnZ2VyZWQgb24gY2hhbmdlLlxuICAgICAgICAgKiBUbyBkaXNhYmxlIHRoaXMgYmVoYXZpb3IsIHNldCB0aGUgYGF1dG9Db3JyZWN0T25gIHByb3BlcnR5IHRvIGBub25lYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0NvcnJlY3RPbiA9ICdjaGFuZ2UnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYWN0aXZlIHJhbmdlIGVuZCBpcyBjaGFuZ2VkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG9cbiAgICAgICAgICogdGhlIHNlY3Rpb24gb24gW2V2ZW50c10oeyUgc2x1ZyBvdmVydmlld19tdWx0aXZpZXdjYWxlbmRhciAlfSN0b2MtZXZlbnRzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlUmFuZ2VFbmRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBzZWxlY3Rpb24gcmFuZ2UgaXMgY2hhbmdlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvXG4gICAgICAgICAqIHRoZSBzZWN0aW9uIG9uIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfbXVsdGl2aWV3Y2FsZW5kYXIgJX0jdG9jLWV2ZW50cykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlID0gdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlIHx8IG5ldyBEYXRlUmFuZ2VTZXJ2aWNlKCk7XG4gICAgICAgIHJlbmRlcmVyLnNldEF0dHJpYnV0ZShlbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdhcmlhLW11bHRpc2VsZWN0YWJsZScsICd0cnVlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc2VsZWN0aW9uIHJhbmdlIG9mIHRoZSBjYWxlbmRhci4gV2hlbiBhIG5ldyByYW5nZSBpcyBzZXQsXG4gICAgICogdGhlIGNvbm5lY3RlZCBEYXRlUmFuZ2VTZXJ2aWNlIG5vdGlmaWVzIGFsbCByZWxhdGVkIHBhcnRpZXMuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhciA/IHRoaXMuY2FsZW5kYXIuc2VsZWN0aW9uUmFuZ2UgOiBudWxsO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0aW9uUmFuZ2UocmFuZ2UkJDEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRXF1YWxDYWxlbmRhclJhbmdlKHJhbmdlJCQxKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSQkMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsUmFuZ2UodGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnNlbGVjdGlvblJhbmdlLCByYW5nZSQkMSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5zZXRSYW5nZShyYW5nZSQkMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVGb2N1c2VkRGF0ZShyYW5nZSQkMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYWN0aXZlIGVuZCBvZiB0aGUgc2VsZWN0aW9uIHJhbmdlLiBUaGlzIG9wdGlvbiBkZXRlcm1pbmVzIHdoaWNoIHJhbmdlIGVuZCB3aWxsIGJlIHVwZGF0ZWQgb25cbiAgICAgKiB1c2VyIGludGVyYWN0aW9uLiBXaGVuIGEgbmV3IGFjdGl2ZSBlbmQgaXMgc2V0LCB0aGUgY29ubmVjdGVkIERhdGVSYW5nZVNlcnZpY2Ugbm90aWZpZXMgYWxsIHJlbGF0ZWQgcGFydGllcy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hpY2ggZW5kIG9mIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbCBiZSBtYXJrZWQgYXMgYWN0aXZlLiBUaGUgYWN0aXZlIGVuZCBnZXRzIG1vZGlmaWVkIHVwb24gdXNlclxuICAgICAqIGludGVyYWN0aW9uLiBXaGVuIGEgbmV3IGFjdGl2ZSBlbmQgaXMgc2V0LCB0aGUgd2lyZWQgRGF0ZVJhbmdlU2VydmljZSBub3RpZmllcyBhbGwgcmVsYXRlZCBjb21wb25lbnRzLiBGb3JcbiAgICAgKiBleGFtcGxlLCB0aGUgc3RhcnQgYW5kIGVuZCBEYXRlSW5wdXQgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqID4gSWYgdGhlIHNlbGVjdGlvbiByYW5nZSBpcyB1bmRlZmluZWQsIHRoZSB2YWx1ZSBpcyBpZ25vcmVkLlxuICAgICAqL1xuICAgIGdldCBhY3RpdmVSYW5nZUVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXIuYWN0aXZlUmFuZ2VFbmQ7XG4gICAgfVxuICAgIHNldCBhY3RpdmVSYW5nZUVuZChhY3RpdmVSYW5nZSkge1xuICAgICAgICBpZiAodGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLmFjdGl2ZVJhbmdlRW5kID09PSBhY3RpdmVSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsZW5kYXIuYWN0aXZlUmFuZ2VFbmQgPSBhY3RpdmVSYW5nZTtcbiAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnNldEFjdGl2ZVJhbmdlRW5kKGFjdGl2ZVJhbmdlKTtcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblJhbmdlIHx8IEVNUFRZX1NFTEVDVElPTlJBTkdFO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xuICAgICAgICBjb25zdCBkYXRlUmFuZ2VTZXJ2aWNlID0gdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlO1xuICAgICAgICBjYWxlbmRhci5taW4gPSBlaXRoZXIoZGF0ZVJhbmdlU2VydmljZS5taW4sIGNhbGVuZGFyLm1pbik7XG4gICAgICAgIGNhbGVuZGFyLm1heCA9IGVpdGhlcihkYXRlUmFuZ2VTZXJ2aWNlLm1heCwgY2FsZW5kYXIubWF4KTtcbiAgICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb25zKGNhbGVuZGFyLmNlbGxFbnRlci5zdWJzY3JpYmUoKHZhbHVlKSA9PiB0aGlzLmhhbmRsZUhvdmVyKHZhbHVlKSksIGNhbGVuZGFyLnZhbHVlQ2hhbmdlLnN1YnNjcmliZSgodmFsdWUpID0+IHRoaXMuaGFuZGxlQ2hhbmdlKHZhbHVlKSksIGRhdGVSYW5nZVNlcnZpY2UuZm9jdXNlZERhdGUkLnN1YnNjcmliZShmb2N1c2VkRGF0ZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwoY2FsZW5kYXIuZm9jdXNlZERhdGUsIGZvY3VzZWREYXRlKSkge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyLmZvY3VzZWREYXRlID0gZm9jdXNlZERhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBkYXRlUmFuZ2VTZXJ2aWNlLmFjdGl2ZVJhbmdlRW5kJC5zdWJzY3JpYmUocmFuZ2VFbmQgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGVuZGFyLmFjdGl2ZVJhbmdlRW5kID09PSByYW5nZUVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGVuZGFyLmFjdGl2ZVJhbmdlRW5kID0gcmFuZ2VFbmQ7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVJhbmdlRW5kQ2hhbmdlLmVtaXQocmFuZ2VFbmQpO1xuICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pLCBkYXRlUmFuZ2VTZXJ2aWNlLnJhbmdlJC5zdWJzY3JpYmUocmFuZ2UkJDEgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRXF1YWxDYWxlbmRhclJhbmdlKHJhbmdlJCQxKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWNjZXB0QW5kRW1pdChyYW5nZSQkMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvY3VzZWREYXRlKHJhbmdlJCQxKTtcbiAgICAgICAgfSksIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2JsdXInKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5oYW5kbGVCbHVyKCkpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGFkZFN1YnNjcmlwdGlvbnMoLi4uc3Vic2NyaXB0aW9ucykge1xuICAgICAgICBzdWJzY3JpcHRpb25zLm1hcChzID0+IHRoaXMuY2FsZW5kYXJTdWJzY3JpcHRpb25zLmFkZChzKSk7XG4gICAgfVxuICAgIGlzRXF1YWxDYWxlbmRhclJhbmdlKHJhbmdlJCQxKSB7XG4gICAgICAgIHJldHVybiBpc0VxdWFsUmFuZ2UodGhpcy5jYWxlbmRhci5zZWxlY3Rpb25SYW5nZSwgcmFuZ2UkJDEpO1xuICAgIH1cbiAgICBoYW5kbGVCbHVyKCkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMuY2FsZW5kYXJSYW5nZTtcbiAgICAgICAgY29uc3QgYXV0b0NvcnJlY3QgPSB0aGlzLmF1dG9Db3JyZWN0T24gPT09ICdibHVyJyAmJiBzdGFydCAhPT0gbnVsbCAmJiBlbmQgIT09IG51bGwgJiYgZW5kIDwgc3RhcnQ7XG4gICAgICAgIGlmIChhdXRvQ29ycmVjdCkge1xuICAgICAgICAgICAgdGhpcy5kYXRlUmFuZ2VTZXJ2aWNlLnNldFJhbmdlKGNsYW1wUmFuZ2Uoc3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IHRoaXMuZGF0ZVJhbmdlU2VydmljZTtcbiAgICAgICAgY29uc3QgYXV0b0NvcnJlY3QgPSB0aGlzLmF1dG9Db3JyZWN0T24gPT09ICdjaGFuZ2UnICYmIHRoaXMuc2hvdWxkQXV0b0NvcnJlY3QodmFsdWUpO1xuICAgICAgICBjb25zdCBhY3RpdmVFbmQgPSB0aGlzLmNhbGVuZGFyLmFjdGl2ZVJhbmdlRW5kICE9PSAnZW5kJyA/ICdlbmQnIDogKGF1dG9Db3JyZWN0ID8gJ2VuZCcgOiAnc3RhcnQnKTtcbiAgICAgICAgY29uc3QgcmFuZ2UkJDEgPSBhdXRvQ29ycmVjdCA/IGNsYW1wUmFuZ2UodmFsdWUpIDogdGhpcy51cGRhdGVSYW5nZSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNFcXVhbFJhbmdlKHNlcnZpY2Uuc2VsZWN0aW9uUmFuZ2UsIHJhbmdlJCQxKSkge1xuICAgICAgICAgICAgdGhpcy5hY2NlcHRBbmRFbWl0KHJhbmdlJCQxKTtcbiAgICAgICAgICAgIHNlcnZpY2Uuc2V0QWN0aXZlUmFuZ2VFbmQoYWN0aXZlRW5kKTtcbiAgICAgICAgICAgIHNlcnZpY2Uuc2V0UmFuZ2UocmFuZ2UkJDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUhvdmVyKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlUmFuZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5jYWxlbmRhclJhbmdlO1xuICAgICAgICBjb25zdCBhY3RpdmVSYW5nZUVuZCA9IHRoaXMuY2FsZW5kYXIuYWN0aXZlUmFuZ2VFbmQ7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVJhbmdlID0gKHN0YXJ0ICYmIGFjdGl2ZVJhbmdlRW5kID09PSAnZW5kJykgfHwgKGVuZCAmJiBhY3RpdmVSYW5nZUVuZCA9PT0gJ3N0YXJ0Jyk7XG4gICAgICAgIGlmICh1cGRhdGVSYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLnVwZGF0ZVJhbmdlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzQ29tcGxldGVSYW5nZSgpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLmRhdGVSYW5nZVNlcnZpY2Uuc2VsZWN0aW9uUmFuZ2UgfHwgRU1QVFlfU0VMRUNUSU9OUkFOR0U7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHN0YXJ0KSAmJiBCb29sZWFuKGVuZCk7XG4gICAgfVxuICAgIHNob3VsZEF1dG9Db3JyZWN0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgZW5kLCBzdGFydCB9ID0gdGhpcy5jYWxlbmRhclJhbmdlO1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhci5hY3RpdmVSYW5nZUVuZCAhPT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmQgIT09IG51bGwgJiYgdmFsdWUgPiBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQgIT09IG51bGwgJiYgdmFsdWUgPCBzdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVGb2N1c2VkRGF0ZShyYW5nZSQkMSkge1xuICAgICAgICBpZiAoIXJhbmdlJCQxIHx8IHRoaXMuZGF0ZVJhbmdlU2VydmljZS5mb2N1c2VkRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlU2VydmljZS5zZXRGb2N1c2VkRGF0ZShyYW5nZSQkMS5zdGFydCB8fCByYW5nZSQkMS5lbmQpO1xuICAgIH1cbiAgICB1cGRhdGVSYW5nZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCB7IGVuZCwgc3RhcnQgfSA9IHRoaXMuY2FsZW5kYXJSYW5nZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXIuYWN0aXZlUmFuZ2VFbmQgIT09ICdlbmQnID8gKHsgc3RhcnQ6IHZhbHVlLCBlbmQgfSkgOiAoeyBzdGFydCwgZW5kOiB2YWx1ZSB9KTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UkJDEpIHtcbiAgICAgICAgdGhpcy5jYWxlbmRhci5zZWxlY3Rpb25SYW5nZSA9IHJhbmdlJCQxO1xuICAgICAgICB0aGlzLmNhbGVuZGFyLndyaXRlVmFsdWUobnVsbCk7XG4gICAgfVxuICAgIGFjY2VwdEFuZEVtaXQocmFuZ2UkJDEpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSQkMSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2VDaGFuZ2UuZW1pdChyYW5nZSQkMSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVSYW5nZVNlbGVjdGlvbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYXV0b0NvcnJlY3RPblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUucHJvdG90eXBlLCBcInNlbGVjdGlvblJhbmdlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUucHJvdG90eXBlLCBcImFjdGl2ZVJhbmdlRW5kXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERhdGVSYW5nZVNlbGVjdGlvbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWN0aXZlUmFuZ2VFbmRDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUucHJvdG90eXBlLCBcInNlbGVjdGlvblJhbmdlQ2hhbmdlXCIsIHZvaWQgMCk7XG5EYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RhdGVSYW5nZVNlbGVjdGlvbl0nXG4gICAgfSksXG4gICAgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW011bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBEYXRlUmFuZ2VTZXJ2aWNlXSlcbl0sIERhdGVSYW5nZVNlbGVjdGlvbkRpcmVjdGl2ZSk7XG5cbi8qIHRzbGludDpkaXNhYmxlOmRpcmVjdGl2ZS1jbGFzcy1zdWZmaXggZGlyZWN0aXZlLXNlbGVjdG9yICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgS0Zvck9mQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoJGltcGxpY2l0LCBrRm9yT2YsIGluZGV4LCBjb3VudCkge1xuICAgICAgICB0aGlzLiRpbXBsaWNpdCA9ICRpbXBsaWNpdDtcbiAgICAgICAgdGhpcy5rRm9yT2YgPSBrRm9yT2Y7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIH1cbiAgICBnZXQgZmlyc3QoKSB7IHJldHVybiB0aGlzLmluZGV4ID09PSAwOyB9XG4gICAgZ2V0IGxhc3QoKSB7IHJldHVybiB0aGlzLmluZGV4ID09PSB0aGlzLmNvdW50IC0gMTsgfVxuICAgIGdldCBldmVuKCkgeyByZXR1cm4gdGhpcy5pbmRleCAlIDIgPT09IDA7IH1cbiAgICBnZXQgb2RkKCkgeyByZXR1cm4gIXRoaXMuZXZlbjsgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBLRm9yT2YgPSBjbGFzcyBLRm9yT2Yge1xuICAgIGNvbnN0cnVjdG9yKF92aWV3Q29udGFpbmVyLCBfdGVtcGxhdGUsIF9kaWZmZXJzKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBfdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuX2RpZmZlcnMgPSBfZGlmZmVycztcbiAgICAgICAgdGhpcy5fZGlmZmVyID0gbnVsbDtcbiAgICB9XG4gICAgc2V0IGtGb3JUZW1wbGF0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoJ2tGb3JPZicgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaGFuZ2VzLmtGb3JPZi5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlmZmVyIHx8ICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHZhbHVlKS5jcmVhdGUodGhpcy5rRm9yVHJhY2tCeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgJyR7dmFsdWV9JyBvZiB0eXBlICcke2dldFR5cGVOYW1lRm9yRGVidWdnaW5nKHZhbHVlKX0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpZmZlcikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMua0Zvck9mKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hcHBseUNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdDb250YWluZXJMZW5ndGggPSB0aGlzLl92aWV3Q29udGFpbmVyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IHRoaXMua0Zvck9mLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdHVwbGVzID0ge307XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaE9wZXJhdGlvbigocmVjb3JkLCBfLCBjdXJyZW50SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0dXBsZXNbY3VycmVudEluZGV4XSA9IHJlY29yZC5pdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHZpZXdDb250YWluZXJMZW5ndGg7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3RlbXBsYXRlLCBuZXcgS0Zvck9mQ29udGV4dChudWxsLCB0aGlzLmtGb3JPZiwgLTEsIC0xKSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3ZpZXdDb250YWluZXIubGVuZ3RoOyBpID4gZGF0YUxlbmd0aDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLnJlbW92ZShpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl92aWV3Q29udGFpbmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5fdmlld0NvbnRhaW5lci5nZXQoaSk7XG4gICAgICAgICAgICB2aWV3LmNvbnRleHQuaW5kZXggPSBpO1xuICAgICAgICAgICAgdmlldy5jb250ZXh0LmNvdW50ID0gbGVuZ3RoO1xuICAgICAgICAgICAgdmlldy5jb250ZXh0LiRpbXBsaWNpdCA9IHR1cGxlc1tpXSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEtGb3JPZi5wcm90b3R5cGUsIFwia0Zvck9mXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIEtGb3JPZi5wcm90b3R5cGUsIFwia0ZvclRyYWNrQnlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIEtGb3JPZi5wcm90b3R5cGUsIFwia0ZvclRlbXBsYXRlXCIsIG51bGwpO1xuS0Zvck9mID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdba0Zvcl1ba0Zvck9mXScgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBUZW1wbGF0ZVJlZixcbiAgICAgICAgSXRlcmFibGVEaWZmZXJzXSlcbl0sIEtGb3JPZik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodHlwZSkge1xuICAgIHJldHVybiB0eXBlLm5hbWUgfHwgdHlwZW9mIHR5cGU7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVmlld0NvbXBvbmVudCA9IGNsYXNzIFZpZXdDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGJ1cywgaW50bCwgY2RyLCBlbGVtZW50LCB6b25lLCByZW5kZXJlciwgZGlzYWJsZWREYXRlc1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5idXMgPSBidXM7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UgPSBkaXNhYmxlZERhdGVzU2VydmljZTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAndmVydGljYWwnO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVzID0gW107XG4gICAgICAgIHRoaXMuY2VsbENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLndlZWtOdW1iZXJDZWxsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2VsbEVudGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNlbGxMZWF2ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jb2xTcGFuID0gMDtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuaW50bC5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmludGxDaGFuZ2UuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuZGlzYWJsZWREYXRlc1NlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5kaXNhYmxlZERhdGVzQ2hhbmdlLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgZ2V0IHdlZWtOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3dXZWVrTnVtYmVycyAmJiB0aGlzLmFjdGl2ZVZpZXcgPT09IENhbGVuZGFyVmlld0VudW0ubW9udGg7XG4gICAgfVxuICAgIHNldCB3ZWVrTnVtYmVyKHNob3dXZWVrTnVtYmVycykge1xuICAgICAgICB0aGlzLnNob3dXZWVrTnVtYmVycyA9IHNob3dXZWVrTnVtYmVycztcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHRoaXMuYnVzLnNlcnZpY2UodGhpcy5hY3RpdmVWaWV3KTtcbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbFNwYW4gPSB0aGlzLnNlcnZpY2Uucm93TGVuZ3RoKHsgcHJlcGVuZENlbGw6IHRoaXMud2Vla051bWJlciB9KTtcbiAgICAgICAgdGhpcy50aXRsZSA9IHRoaXMuc2VydmljZS50aXRsZSh0aGlzLnZpZXdEYXRlKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIGlmIChjaGFuZ2VzLmFjdGl2ZVZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENlbGxJbmRleCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cy5mb3JFYWNoKHVuc3Vic2NyaWJlQ2FsbGJhY2sgPT4gdW5zdWJzY3JpYmVDYWxsYmFjaygpKTtcbiAgICB9XG4gICAgaXNIb3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJztcbiAgICB9XG4gICAgaXNNb250aFZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZpZXcgPT09IENhbGVuZGFyVmlld0VudW0ubW9udGg7XG4gICAgfVxuICAgIHNob3VsZFJlbmRlckNlbGxDb250ZW50KGNlbGxDdHgpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChjZWxsQ3R4KSAmJiAhKCF0aGlzLmlzSG9yaXpvbnRhbCgpICYmIGNlbGxDdHguaXNPdGhlck1vbnRoKTtcbiAgICB9XG4gICAgZmlyc3REYXRlKHJvd0N0eCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmZpcnN0V2Vla0RhdGVDb250ZXh0KHJvd0N0eCk7XG4gICAgICAgIHJldHVybiBjdHggPyBjdHgudmFsdWUgOiBudWxsO1xuICAgIH1cbiAgICBnZXRXZWVrTnVtYmVyKGRhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLndlZWtOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWVrSW5ZZWFyKGRhdGUsIHRoaXMuaW50bC5maXJzdERheSgpKTtcbiAgICB9XG4gICAgZ2V0V2Vla051bWJlckNvbnRleHQocm93Q3R4KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuZmlyc3RXZWVrRGF0ZUNvbnRleHQocm93Q3R4KTtcbiAgICAgICAgaWYgKCF0aGlzLndlZWtOdW1iZXIgfHwgIWN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2Vla051bWJlciA9IHdlZWtJblllYXIoY3R4LnZhbHVlLCB0aGlzLmludGwuZmlyc3REYXkoKSkudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiB3ZWVrTnVtYmVyLFxuICAgICAgICAgICAgaWQ6IG51bGwsXG4gICAgICAgICAgICBpc0ZvY3VzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNTZWxlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICBpc1dlZWtlbmQ6IGZhbHNlLFxuICAgICAgICAgICAgdGl0bGU6IHdlZWtOdW1iZXIsXG4gICAgICAgICAgICB2YWx1ZTogY2xvbmVEYXRlKGN0eC52YWx1ZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0U3R5bGVzKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBpc1JhbmdlRW5kLCBpc1JhbmdlU3RhcnQgfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IGlzRW5kQWN0aXZlID0gdGhpcy5hY3RpdmVSYW5nZUVuZCA9PT0gJ2VuZCcgJiYgaXNSYW5nZUVuZDtcbiAgICAgICAgY29uc3QgaXNTdGFydEFjdGl2ZSA9IHRoaXMuYWN0aXZlUmFuZ2VFbmQgPT09ICdzdGFydCcgJiYgaXNSYW5nZVN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q2xhc3NPYmplY3Qoe1xuICAgICAgICAgICAgJ2stcmFuZ2UtZW5kJzogIWNvbnRleHQuaXNPdGhlck1vbnRoICYmIGlzUmFuZ2VFbmQsXG4gICAgICAgICAgICAnay1yYW5nZS1taWQnOiAhY29udGV4dC5pc090aGVyTW9udGggJiYgY29udGV4dC5pc1JhbmdlTWlkLFxuICAgICAgICAgICAgJ2stcmFuZ2Utc3BsaXQtZW5kJzogIWNvbnRleHQuaXNPdGhlck1vbnRoICYmIGNvbnRleHQuaXNSYW5nZVNwbGl0RW5kLFxuICAgICAgICAgICAgJ2stcmFuZ2Utc3BsaXQtc3RhcnQnOiAhY29udGV4dC5pc090aGVyTW9udGggJiYgY29udGV4dC5pc1JhbmdlU3BsaXRTdGFydCxcbiAgICAgICAgICAgICdrLXJhbmdlLXN0YXJ0JzogIWNvbnRleHQuaXNPdGhlck1vbnRoICYmIGlzUmFuZ2VTdGFydCxcbiAgICAgICAgICAgICdrLXN0YXRlLWFjdGl2ZSc6IGlzU3RhcnRBY3RpdmUgfHwgaXNFbmRBY3RpdmUsXG4gICAgICAgICAgICAnay1zdGF0ZS1mb2N1c2VkJzogIWNvbnRleHQuaXNPdGhlck1vbnRoICYmIHRoaXMuaXNBY3RpdmUgJiYgY29udGV4dC5pc0ZvY3VzZWQsXG4gICAgICAgICAgICAnay1zdGF0ZS1zZWxlY3RlZCc6ICFjb250ZXh0LmlzT3RoZXJNb250aCAmJiAoY29udGV4dC5pc1NlbGVjdGVkIHx8IGlzUmFuZ2VTdGFydCB8fCBpc1JhbmdlRW5kKSxcbiAgICAgICAgICAgICdrLXRvZGF5JzogIWNvbnRleHQuaXNPdGhlck1vbnRoICYmIGNvbnRleHQuaXNUb2RheSxcbiAgICAgICAgICAgICdrLXdlZWtlbmQnOiBjb250ZXh0LmlzV2Vla2VuZCxcbiAgICAgICAgICAgICdrLWRpc2FibGVkJzogY29udGV4dC5pc0Rpc2FibGVkLFxuICAgICAgICAgICAgJ2stb3RoZXItbW9udGgnOiBjb250ZXh0LmlzT3RoZXJNb250aFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGFibGVDZWxsSW5kZXgocm93SW5kZXgsIGNlbGxJbmRleCkge1xuICAgICAgICByZXR1cm4gYCR7cm93SW5kZXh9OiR7Y2VsbEluZGV4fWA7XG4gICAgfVxuICAgIGhhbmRsZVdlZWtOdW1iZXJDbGljayh3ZWVrKSB7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZURhdGVzID0gd2Vlay5tYXAoaXRlbSA9PiBpdGVtLnZhbHVlKS5maWx0ZXIoZGF0ZSA9PiAhdGhpcy5kaXNhYmxlZERhdGVzU2VydmljZS5pc0RhdGVEaXNhYmxlZChkYXRlKSk7XG4gICAgICAgIHRoaXMud2Vla051bWJlckNlbGxDbGljay5lbWl0KGF2YWlsYWJsZURhdGVzKTtcbiAgICB9XG4gICAgZmlyc3RXZWVrRGF0ZUNvbnRleHQocm93Q3R4KSB7XG4gICAgICAgIGlmICghdGhpcy53ZWVrTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgbGV0IGN0eCA9IHRoaXMuc2hvdWxkUmVuZGVyQ2VsbENvbnRlbnQocm93Q3R4W2lkeF0pID8gcm93Q3R4W2lkeF0gOiBudWxsO1xuICAgICAgICB3aGlsZSAoIWN0eCAmJiBpZHggPCByb3dDdHgubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsQ3R4ID0gcm93Q3R4WysraWR4XTtcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuc2hvdWxkUmVuZGVyQ2VsbENvbnRlbnQoY2VsbEN0eCkgPyBjZWxsQ3R4IDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4O1xuICAgIH1cbiAgICB1cGRhdGVEYXRhKCkge1xuICAgICAgICBjb25zdCB0aW1lID0gbGFzdCh0aGlzLnNlbGVjdGVkRGF0ZXMpIHx8IGdldFRvZGF5KCk7XG4gICAgICAgIGNvbnN0IHZpZXdEYXRlID0gc2V0VGltZSh0aGlzLnZpZXdEYXRlLCB0aW1lKTtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5zZXJ2aWNlLmRhdGEoe1xuICAgICAgICAgICAgY2VsbFVJRDogdGhpcy5jZWxsVUlELFxuICAgICAgICAgICAgZm9jdXNlZERhdGU6IHRoaXMuZm9jdXNlZERhdGUsXG4gICAgICAgICAgICBpc0FjdGl2ZVZpZXc6ICF0aGlzLmJ1cy5jYW5Nb3ZlRG93bih0aGlzLmFjdGl2ZVZpZXcpLFxuICAgICAgICAgICAgbWF4OiB0aGlzLm1heCxcbiAgICAgICAgICAgIG1pbjogdGhpcy5taW4sXG4gICAgICAgICAgICBzZWxlY3RlZERhdGVzOiB0aGlzLnNlbGVjdGVkRGF0ZXMsXG4gICAgICAgICAgICBzZWxlY3Rpb25SYW5nZTogdGhpcy5zZWxlY3Rpb25SYW5nZSxcbiAgICAgICAgICAgIHZpZXdEYXRlOiB2aWV3RGF0ZSxcbiAgICAgICAgICAgIGlzRGF0ZURpc2FibGVkOiB0aGlzLmRpc2FibGVkRGF0ZXNTZXJ2aWNlLmlzRGF0ZURpc2FibGVkLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW50bENoYW5nZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBkaXNhYmxlZERhdGVzQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIGJpbmRFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5kb21FdmVudHMucHVzaCh0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnbW91c2VvdmVyJywgdGhpcy5jZWxsTW91c2VvdmVySGFuZGxlci5iaW5kKHRoaXMpKSwgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ21vdXNlbGVhdmUnLCB0aGlzLm1vdXNlTGVhdmVIYW5kbGVyLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlci5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIGNsaWNrSGFuZGxlcihhcmdzKSB7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmNsb3Nlc3RDZWxsKGFyZ3MpO1xuICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IGNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWNlbGwtaW5kZXgnKTtcbiAgICAgICAgY29uc3QgY2VsbENvbnRleHQgPSB0aGlzLmNlbGxCeUluZGV4KGluZGV4KTtcbiAgICAgICAgaWYgKCFjZWxsQ29udGV4dC5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGN0cmxLZXksIG1ldGFLZXksIHNoaWZ0S2V5IH0gPSBhcmdzO1xuICAgICAgICAgICAgdGhpcy5jZWxsQ2xpY2suZW1pdCh7XG4gICAgICAgICAgICAgICAgZGF0ZTogY2VsbENvbnRleHQudmFsdWUsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzOiB7IGN0cmxLZXksIG1ldGFLZXksIHNoaWZ0S2V5IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdXNlTGVhdmVIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2VsbEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRDZWxsTGVhdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjZWxsTW91c2VvdmVySGFuZGxlcihhcmdzKSB7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmNsb3Nlc3RDZWxsKGFyZ3MpO1xuICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS1jZWxsLWluZGV4Jyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2VsbEluZGV4ICYmIHRoaXMuY3VycmVudENlbGxJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDZWxsTGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jZWxsQnlJbmRleChpbmRleCkudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNlbGxFbnRlci5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENlbGxJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY3VycmVudENlbGxJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0Q2VsbExlYXZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2VzdENlbGwoZXZlbnRBcmdzKSB7XG4gICAgICAgIHJldHVybiBjbG9zZXN0SW5TY29wZShldmVudEFyZ3MudGFyZ2V0LCBub2RlID0+IG5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLWNlbGwtaW5kZXgnKSwgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgICBlbWl0Q2VsbExlYXZlKCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5jZWxsQnlJbmRleCh0aGlzLmN1cnJlbnRDZWxsSW5kZXgpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5jZWxsTGVhdmUuZW1pdChpdGVtLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRDZWxsSW5kZXggPSBudWxsO1xuICAgIH1cbiAgICBjZWxsQnlJbmRleChpbmRleCkge1xuICAgICAgICBjb25zdCBbcm93SW5kZXgsIGNlbGxJbmRleF0gPSBpbmRleC5zcGxpdCgnOicpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3Jvd0luZGV4XVtjZWxsSW5kZXhdO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0FjdGl2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlVmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbFVJRFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImZvY3VzZWREYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmlld0RhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVJhbmdlRW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3Rpb25SYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZERhdGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZpZXdDb21wb25lbnQucHJvdG90eXBlLCBcInZpZXdJbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVJlZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3ZWVrTnVtYmVyVGVtcGxhdGVSZWZcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBWaWV3Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3ZWVrTnVtYmVyQ2VsbENsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbEVudGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbExlYXZlXCIsIHZvaWQgMCk7XG5WaWV3Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DYWxlbmRhclZpZXddJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctdGVtcGxhdGUgI2VtcHR5Q2VsbD48dGQgY2xhc3M9XCJrLWVtcHR5IGstY2FsZW5kYXItdGRcIj4mbmJzcDs8L3RkPjwvbmctdGVtcGxhdGU+XG4gICAgPHRyICpuZ0lmPVwiIWlzSG9yaXpvbnRhbCgpXCIgY2xhc3M9XCJrLWNhbGVuZGFyLXRyXCIgcm9sZT1cInJvd1wiPjx0aCBjbGFzcz1cImstY2FsZW5kYXItY2FwdGlvblwiIHNjb3BlPVwiY29sXCIgW2NvbFNwYW5dPVwiY29sU3BhblwiPnt7dGl0bGV9fTwvdGg+PC90cj5cbiAgICA8dHIgKmtGb3I9XCJsZXQgcm93IG9mIGRhdGE7IGxldCByb3dJbmRleCA9IGluZGV4XCIgY2xhc3M9XCJrLWNhbGVuZGFyLXRyXCIgcm9sZT1cInJvd1wiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwid2Vla051bWJlclwiPlxuICAgICAgICAgICAgPHRkXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWFsdCBrLWNhbGVuZGFyLXRkXCJcbiAgICAgICAgICAgICAgICAqbmdJZj1cImZpcnN0RGF0ZShyb3cpOyBlbHNlIGVtcHR5Q2VsbFwiXG4gICAgICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgICAgICBjbGljazogaGFuZGxlV2Vla051bWJlckNsaWNrLmJpbmQodGhpcywgcm93KVxuICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhd2Vla051bWJlclRlbXBsYXRlUmVmXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7Z2V0V2Vla051bWJlcihmaXJzdERhdGUocm93KSl9fVxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgIFtuZ0lmXT1cIndlZWtOdW1iZXJUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIndlZWtOdW1iZXJUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGZpcnN0RGF0ZShyb3cpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbENvbnRleHQ6IGdldFdlZWtOdW1iZXJDb250ZXh0KHJvdylcbiAgICAgICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgPjwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctY29udGFpbmVyICprRm9yPVwibGV0IGNlbGwgb2Ygcm93OyBsZXQgY2VsbEluZGV4ID0gaW5kZXhcIj5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cImstY2FsZW5kYXItdGRcIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwic2hvdWxkUmVuZGVyQ2VsbENvbnRlbnQoY2VsbCk7IGVsc2UgZW1wdHlDZWxsXCJcbiAgICAgICAgICAgICAgICByb2xlPVwiZ3JpZGNlbGxcIlxuICAgICAgICAgICAgICAgIFthdHRyLmlkXT1cImNlbGwuaWRcIlxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtY2VsbC1pbmRleF09XCJ0YWJsZUNlbGxJbmRleChyb3dJbmRleCwgY2VsbEluZGV4KVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJjZWxsLmlzU2VsZWN0ZWQgfHwgY2VsbC5pc1JhbmdlU3RhcnQgfHwgY2VsbC5pc1JhbmdlTWlkIHx8IGNlbGwuaXNSYW5nZUVuZFwiXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJjZWxsLmlzRGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cImdldFN0eWxlcyhjZWxsKVwiXG4gICAgICAgICAgICAgICAgW3RpdGxlXT1cImNlbGwudGl0bGVcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1saW5rXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhdGVtcGxhdGVSZWZcIj57e2NlbGwuZm9ybWF0dGVkVmFsdWV9fTwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJ0ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJ0ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyAkaW1wbGljaXQ6IGNlbGwudmFsdWUsIGNlbGxDb250ZXh0OiBjZWxsIH1cIlxuICAgICAgICAgICAgICAgICAgICA+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L3RyPlxuICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCdXNWaWV3U2VydmljZSxcbiAgICAgICAgSW50bFNlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgRGlzYWJsZWREYXRlc1NlcnZpY2VdKVxuXSwgVmlld0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFRoZSBleHBvcnRlZCBwYWNrYWdlIG1vZHVsZS5cbiAqXG4gKiBUaGUgcGFja2FnZSBleHBvcnRzOlxuICogLSBgSGVhZGVyQ29tcG9uZW50YCZtZGFzaDtUaGUgY29tcG9uZW50IHRoYXQgcmVuZGVycyB0aGUgVUkgZm9yIHZlcnRpY2FsIG5hdmlnYXRpb24uXG4gKiAtIGBWaWV3Q29tcG9uZW50YCZtZGFzaDtUaGUgY29tcG9uZW50IHRoYXQgcmVuZGVycyB0aGUgYWN0aXZlIENhbGVuZGFyIHZpZXcuXG4gKi9cbmxldCBDYWxlbmRhckNvbW1vbk1vZHVsZSA9IGNsYXNzIENhbGVuZGFyQ29tbW9uTW9kdWxlIHtcbn07XG5DYWxlbmRhckNvbW1vbk1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBLRm9yT2YsXG4gICAgICAgICAgICBIZWFkZXJDb21wb25lbnQsXG4gICAgICAgICAgICBWaWV3Q29tcG9uZW50XG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIEtGb3JPZixcbiAgICAgICAgICAgIEhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgICAgIFZpZXdDb21wb25lbnRcbiAgICAgICAgXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRXZlbnRzTW9kdWxlXVxuICAgIH0pXG5dLCBDYWxlbmRhckNvbW1vbk1vZHVsZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFRoZSBleHBvcnRlZCBwYWNrYWdlIG1vZHVsZS5cbiAqXG4gKiBUaGUgcGFja2FnZSBleHBvcnRzOlxuICogLSBgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgbW9udGggY2VsbCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIG1vbnRoIGNlbGwgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIHllYXIgY2VsbCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBkZWNhZGUgY2VsbCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgY2VudHVyeSBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBtb250aCB3ZWVrIG51bWJlciBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBoZWFkZXIgdGl0bGUgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgTmF2aWdhdGlvbkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIG5hdmlnYXRpb24gaXRlbSB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKi9cbmxldCBUZW1wbGF0ZXNNb2R1bGUgPSBjbGFzcyBUZW1wbGF0ZXNNb2R1bGUge1xufTtcblRlbXBsYXRlc01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBNb250aENlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBEZWNhZGVDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBDZW50dXJ5Q2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIEhlYWRlclRpdGxlVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBOYXZpZ2F0aW9uSXRlbVRlbXBsYXRlRGlyZWN0aXZlXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIENlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBXZWVrTnVtYmVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmVcbiAgICAgICAgXVxuICAgIH0pXG5dLCBUZW1wbGF0ZXNNb2R1bGUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTWVzc2FnZXMgZXh0ZW5kcyBDb21wb25lbnRNZXNzYWdlcyB7XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwidG9kYXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJwcmV2QnV0dG9uVGl0bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzLnByb3RvdHlwZSwgXCJuZXh0QnV0dG9uVGl0bGVcIiwgdm9pZCAwKTtcblxudmFyIE11bHRpVmlld0NhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTXVsdGlWaWV3Q2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSA9IE11bHRpVmlld0NhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IGNsYXNzIE11bHRpVmlld0NhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5NdWx0aVZpZXdDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlID0gTXVsdGlWaWV3Q2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTXVsdGlWaWV3Q2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvTXVsdGlWaWV3Q2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc10nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIE11bHRpVmlld0NhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUpO1xuXG52YXIgTXVsdGlWaWV3Q2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xO1xuLyoqXG4gKiBDdXN0b20gY29tcG9uZW50IG1lc3NhZ2VzIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50IG1lc3NhZ2VzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZ2xvYmFsaXphdGlvbl9kYXRlaW5wdXRzICV9I3RvYy1jdXN0b20tbWVzc2FnZXMpKS5cbiAqL1xubGV0IE11bHRpVmlld0NhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBNdWx0aVZpZXdDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50XzEgPSBjbGFzcyBNdWx0aVZpZXdDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50IGV4dGVuZHMgTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuTXVsdGlWaWV3Q2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IE11bHRpVmlld0NhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE11bHRpVmlld0NhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLW11bHRpdmlld2NhbGVuZGFyLW1lc3NhZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIE11bHRpVmlld0NhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBwYWNrYWdlIGV4cG9ydHM6XG4gKiAtIGBDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBtb250aCBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgbW9udGggY2VsbCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgeWVhciBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIGRlY2FkZSBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBjZW50dXJ5IGNlbGwgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIG1vbnRoIHdlZWsgbnVtYmVyIGNlbGwgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIGhlYWRlciB0aXRsZSB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgTXVsdGlWaWV3Q2FsZW5kYXIgbW9kdWxlXG4gKiBpbXBvcnQgeyBNdWx0aVZpZXdDYWxlbmRhck1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWRhdGVpbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBNdWx0aVZpZXdDYWxlbmRhck1vZHVsZV0sIC8vIGltcG9ydCBNdWx0aVZpZXdDYWxlbmRhciBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKi9cbmxldCBNdWx0aVZpZXdDYWxlbmRhck1vZHVsZSA9IGNsYXNzIE11bHRpVmlld0NhbGVuZGFyTW9kdWxlIHtcbn07XG5NdWx0aVZpZXdDYWxlbmRhck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBIb3Jpem9udGFsVmlld0xpc3RDb21wb25lbnQsXG4gICAgICAgICAgICBNdWx0aVZpZXdDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLFxuICAgICAgICAgICAgTXVsdGlWaWV3Q2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCxcbiAgICAgICAgICAgIE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50XG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIEhvcml6b250YWxWaWV3TGlzdENvbXBvbmVudCxcbiAgICAgICAgICAgIE11bHRpVmlld0NhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUsXG4gICAgICAgICAgICBNdWx0aVZpZXdDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICAgICAgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQsXG4gICAgICAgICAgICBDYWxlbmRhckNvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgIFRlbXBsYXRlc01vZHVsZVxuICAgICAgICBdLFxuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICBDYWxlbmRhckNvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgIEludGxNb2R1bGUsXG4gICAgICAgICAgICBUZW1wbGF0ZXNNb2R1bGUsXG4gICAgICAgICAgICBQb3B1cE1vZHVsZSxcbiAgICAgICAgICAgIEV2ZW50c01vZHVsZVxuICAgICAgICBdLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgQ2VudHVyeVZpZXdTZXJ2aWNlLFxuICAgICAgICAgICAgRGVjYWRlVmlld1NlcnZpY2UsXG4gICAgICAgICAgICBNb250aFZpZXdTZXJ2aWNlLFxuICAgICAgICAgICAgWWVhclZpZXdTZXJ2aWNlLFxuICAgICAgICAgICAgV2Vla05hbWVzU2VydmljZVxuICAgICAgICBdXG4gICAgfSlcbl0sIE11bHRpVmlld0NhbGVuZGFyTW9kdWxlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENhbGVuZGFyTWVzc2FnZXMgZXh0ZW5kcyBDb21wb25lbnRNZXNzYWdlcyB7XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYWxlbmRhck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJ0b2RheVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2FsZW5kYXJNZXNzYWdlcy5wcm90b3R5cGUsIFwicHJldkJ1dHRvblRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYWxlbmRhck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJuZXh0QnV0dG9uVGl0bGVcIiwgdm9pZCAwKTtcblxudmFyIENhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ2FsZW5kYXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSA9IENhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IGNsYXNzIENhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBDYWxlbmRhck1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxufTtcbkNhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgPSBDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBDYWxlbmRhck1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlKTtcblxudmFyIENhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMTtcbi8qKlxuICogQ3VzdG9tIGNvbXBvbmVudCBtZXNzYWdlcyBvdmVycmlkZSBkZWZhdWx0IGNvbXBvbmVudCBtZXNzYWdlcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGdsb2JhbGl6YXRpb25fZGF0ZWlucHV0cyAlfSN0b2MtY3VzdG9tLW1lc3NhZ2VzKSkuXG4gKi9cbmxldCBDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gQ2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gY2xhc3MgQ2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIENhbGVuZGFyTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuQ2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IENhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IENhbGVuZGFyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNhbGVuZGFyLW1lc3NhZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIENhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQpO1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyA9IFtcbiAgICBWaXJ0dWFsaXphdGlvbkNvbXBvbmVudFxuXTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBWaXJ0dWFsaXphdGlvbiBjb21wb25lbnQuXG4gKi9cbmxldCBWaXJ0dWFsaXphdGlvbk1vZHVsZSA9IGNsYXNzIFZpcnR1YWxpemF0aW9uTW9kdWxlIHtcbn07XG5WaXJ0dWFsaXphdGlvbk1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NUE9ORU5UX0RJUkVDVElWRVNdLFxuICAgICAgICBleHBvcnRzOiBbQ09NUE9ORU5UX0RJUkVDVElWRVNdLFxuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxuICAgIH0pXG5dLCBWaXJ0dWFsaXphdGlvbk1vZHVsZSk7XG5cbi8qKlxuICogVGhlIGV4cG9ydGVkIHBhY2thZ2UgbW9kdWxlLlxuICpcbiAqIFRoZSBwYWNrYWdlIGV4cG9ydHM6XG4gKiAtIGBDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBtb250aCBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYE1vbnRoQ2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgbW9udGggY2VsbCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBZZWFyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgeWVhciBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIGRlY2FkZSBjZWxsIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBjZW50dXJ5IGNlbGwgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgV2Vla051bWJlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIG1vbnRoIHdlZWsgbnVtYmVyIGNlbGwgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIGhlYWRlciB0aXRsZSB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBOYXZpZ2F0aW9uSXRlbVRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgbmF2aWdhdGlvbiBpdGVtIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBDYWxlbmRhciBtb2R1bGVcbiAqIGltcG9ydCB7IENhbGVuZGFyTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZGF0ZWlucHV0cyc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIENhbGVuZGFyTW9kdWxlXSwgLy8gaW1wb3J0IENhbGVuZGFyIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xubGV0IENhbGVuZGFyTW9kdWxlID0gY2xhc3MgQ2FsZW5kYXJNb2R1bGUge1xufTtcbkNhbGVuZGFyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIENhbGVuZGFyQ29tcG9uZW50LFxuICAgICAgICAgICAgTmF2aWdhdGlvbkNvbXBvbmVudCxcbiAgICAgICAgICAgIENhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICBDYWxlbmRhckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLFxuICAgICAgICAgICAgVmlld0xpc3RDb21wb25lbnRcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgQ2FsZW5kYXJDb21wb25lbnQsXG4gICAgICAgICAgICBOYXZpZ2F0aW9uQ29tcG9uZW50LFxuICAgICAgICAgICAgQ2FsZW5kYXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCxcbiAgICAgICAgICAgIENhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUsXG4gICAgICAgICAgICBWaWV3TGlzdENvbXBvbmVudCxcbiAgICAgICAgICAgIENhbGVuZGFyQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgVGVtcGxhdGVzTW9kdWxlXG4gICAgICAgIF0sXG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgIENhbGVuZGFyQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgTXVsdGlWaWV3Q2FsZW5kYXJNb2R1bGUsXG4gICAgICAgICAgICBJbnRsTW9kdWxlLFxuICAgICAgICAgICAgVGVtcGxhdGVzTW9kdWxlLFxuICAgICAgICAgICAgVmlydHVhbGl6YXRpb25Nb2R1bGUsXG4gICAgICAgICAgICBFdmVudHNNb2R1bGUsXG4gICAgICAgICAgICBSZXNpemVTZW5zb3JNb2R1bGVcbiAgICAgICAgXSxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBDYWxlbmRhckRPTVNlcnZpY2UsXG4gICAgICAgICAgICBDZW50dXJ5Vmlld1NlcnZpY2UsXG4gICAgICAgICAgICBEZWNhZGVWaWV3U2VydmljZSxcbiAgICAgICAgICAgIE1vbnRoVmlld1NlcnZpY2UsXG4gICAgICAgICAgICBZZWFyVmlld1NlcnZpY2UsXG4gICAgICAgICAgICBXZWVrTmFtZXNTZXJ2aWNlXG4gICAgICAgIF1cbiAgICB9KVxuXSwgQ2FsZW5kYXJNb2R1bGUpO1xuXG4vKipcbiAqIFRoZSBleHBvcnRlZCBwYWNrYWdlIG1vZHVsZS5cbiAqXG4gKiBUaGUgcGFja2FnZSBleHBvcnRzOlxuICogLSBgQ2FsZW5kYXJNb2R1bGVgJm1kYXNoO1RoZSBjYWxlbmRhciBtb2R1bGUuXG4gKiAtIGBNdWx0aVZpZXdDYWxlbmRhck1vZHVsZWAmbWRhc2g7VGhlIG11bHRpLXZpZXcgY2FsZW5kYXIgbW9kdWxlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIENhbGVuZGFycyBtb2R1bGVcbiAqIGltcG9ydCB7IENhbGVuZGFyc01vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWRhdGVpbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBDYWxlbmRhcnNNb2R1bGVdLCAvLyBpbXBvcnQgdGhlIENhbGVuZGFycyBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBDYWxlbmRhcnNNb2R1bGUgPSBjbGFzcyBDYWxlbmRhcnNNb2R1bGUge1xufTtcbkNhbGVuZGFyc01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgQ2FsZW5kYXJNb2R1bGUsXG4gICAgICAgICAgICBNdWx0aVZpZXdDYWxlbmRhck1vZHVsZVxuICAgICAgICBdLFxuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBDYWxlbmRhck1vZHVsZSxcbiAgICAgICAgICAgIE11bHRpVmlld0NhbGVuZGFyTW9kdWxlXG4gICAgICAgIF1cbiAgICB9KVxuXSwgQ2FsZW5kYXJzTW9kdWxlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERhdGVJbnB1dE1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZUlucHV0TWVzc2FnZXMucHJvdG90eXBlLCBcImRlY3JlbWVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZUlucHV0TWVzc2FnZXMucHJvdG90eXBlLCBcImluY3JlbWVudFwiLCB2b2lkIDApO1xuXG52YXIgRGF0ZUlucHV0TG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRGF0ZUlucHV0TG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgPSBEYXRlSW5wdXRMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xID0gY2xhc3MgRGF0ZUlucHV0TG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBEYXRlSW5wdXRNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5EYXRlSW5wdXRMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSA9IERhdGVJbnB1dExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBEYXRlSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlSW5wdXRMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRGF0ZUlucHV0TG9jYWxpemVkTWVzc2FnZXNdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBEYXRlSW5wdXRMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSk7XG5cbnZhciBEYXRlSW5wdXRDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xO1xuLyoqXG4gKiBDdXN0b20gY29tcG9uZW50IG1lc3NhZ2VzIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50IG1lc3NhZ2VzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZ2xvYmFsaXphdGlvbl9kYXRlaW5wdXRzICV9I3RvYy1jdXN0b20tbWVzc2FnZXMpKS5cbiAqL1xubGV0IERhdGVJbnB1dEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gRGF0ZUlucHV0Q3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IGNsYXNzIERhdGVJbnB1dEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50IGV4dGVuZHMgRGF0ZUlucHV0TWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuRGF0ZUlucHV0Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBEYXRlSW5wdXRDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogRGF0ZUlucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZUlucHV0Q3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWRhdGVpbnB1dC1tZXNzYWdlcycsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBEYXRlSW5wdXRDdXN0b21NZXNzYWdlc0NvbXBvbmVudCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIERhdGVJbnB1dCBjb21wb25lbnQuXG4gKi9cbmxldCBEYXRlSW5wdXRNb2R1bGUgPSBjbGFzcyBEYXRlSW5wdXRNb2R1bGUge1xufTtcbkRhdGVJbnB1dE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBEYXRlSW5wdXRDb21wb25lbnQsXG4gICAgICAgICAgICBEYXRlSW5wdXRDdXN0b21NZXNzYWdlc0NvbXBvbmVudCxcbiAgICAgICAgICAgIERhdGVJbnB1dExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIERhdGVJbnB1dENvbXBvbmVudCxcbiAgICAgICAgICAgIERhdGVJbnB1dEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICAgICAgRGF0ZUlucHV0TG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVcbiAgICAgICAgXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgSW50bE1vZHVsZSwgRXZlbnRzTW9kdWxlXVxuICAgIH0pXG5dLCBEYXRlSW5wdXRNb2R1bGUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRGF0ZVBpY2tlck1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZVBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJ0b2RheVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0ZVBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJ0b2dnbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGVQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwicHJldkJ1dHRvblRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRlUGlja2VyTWVzc2FnZXMucHJvdG90eXBlLCBcIm5leHRCdXR0b25UaXRsZVwiLCB2b2lkIDApO1xuXG52YXIgRGF0ZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzE7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERhdGVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSA9IERhdGVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xID0gY2xhc3MgRGF0ZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlIGV4dGVuZHMgRGF0ZVBpY2tlck1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxufTtcbkRhdGVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSA9IERhdGVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogRGF0ZVBpY2tlck1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRGF0ZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgRGF0ZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlKTtcblxudmFyIERhdGVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xO1xuLyoqXG4gKiBDdXN0b20gY29tcG9uZW50IG1lc3NhZ2VzIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50IG1lc3NhZ2VzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZ2xvYmFsaXphdGlvbl9kYXRlaW5wdXRzICV9I3RvYy1jdXN0b20tbWVzc2FnZXMpKS5cbiAqL1xubGV0IERhdGVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IERhdGVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gY2xhc3MgRGF0ZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50IGV4dGVuZHMgRGF0ZVBpY2tlck1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbkRhdGVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IERhdGVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogRGF0ZVBpY2tlck1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZGF0ZXBpY2tlci1tZXNzYWdlcycsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBEYXRlUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQpO1xuXG5jb25zdCDJtTAkZSA9IHRvdWNoRW5hYmxlZDtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIERhdGVQaWNrZXIgY29tcG9uZW50LlxuICovXG5sZXQgRGF0ZVBpY2tlck1vZHVsZSA9IGNsYXNzIERhdGVQaWNrZXJNb2R1bGUge1xufTtcbkRhdGVQaWNrZXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgRGF0ZVBpY2tlckNvbXBvbmVudCxcbiAgICAgICAgICAgIERhdGVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCxcbiAgICAgICAgICAgIERhdGVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZVxuICAgICAgICBdLFxuICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICBEYXRlUGlja2VyQ29tcG9uZW50LFxuICAgICAgICAgICAgRGF0ZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICAgICAgRGF0ZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLFxuICAgICAgICAgICAgVGVtcGxhdGVzTW9kdWxlXG4gICAgICAgIF0sXG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgIERhdGVJbnB1dE1vZHVsZSxcbiAgICAgICAgICAgIENhbGVuZGFyTW9kdWxlLFxuICAgICAgICAgICAgSW50bE1vZHVsZSxcbiAgICAgICAgICAgIFBvcHVwTW9kdWxlLFxuICAgICAgICAgICAgVGVtcGxhdGVzTW9kdWxlLFxuICAgICAgICAgICAgRXZlbnRzTW9kdWxlXG4gICAgICAgIF0sXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogVE9VQ0hfRU5BQkxFRCwgdXNlVmFsdWU6IMm1MCRlIH1dXG4gICAgfSlcbl0sIERhdGVQaWNrZXJNb2R1bGUpO1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyQxID0gW1xuICAgIERhdGVSYW5nZUNvbXBvbmVudCxcbiAgICBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudCxcbiAgICBEYXRlUmFuZ2VQb3B1cFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIERhdGVSYW5nZVNlbGVjdGlvbkRpcmVjdGl2ZSxcbiAgICBEYXRlUmFuZ2VTdGFydElucHV0RGlyZWN0aXZlLFxuICAgIERhdGVSYW5nZUVuZElucHV0RGlyZWN0aXZlXG5dO1xuY29uc3QgQ09NUE9ORU5UX01PRFVMRVMgPSBbXG4gICAgTXVsdGlWaWV3Q2FsZW5kYXJNb2R1bGUsXG4gICAgRGF0ZUlucHV0TW9kdWxlLFxuICAgIFBvcHVwTW9kdWxlLFxuICAgIEV2ZW50c01vZHVsZVxuXTtcbi8qKlxuICogVGhlIGV4cG9ydGVkIHBhY2thZ2UgbW9kdWxlLlxuICpcbiAqIFRoZSBwYWNrYWdlIGV4cG9ydHM6XG4gKiAtIGBEYXRlUmFuZ2VDb21wb25lbnRgJm1kYXNoO1RoZSBEYXRlUmFuZ2UgY29tcG9uZW50IGNsYXNzLlxuICogLSBgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnRgJm1kYXNoO1RoZSBEYXRlUmFuZ2VQb3B1cCBjb21wb25lbnQgY2xhc3MuXG4gKiAtIGBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmVgJm1kYXNoO1RoZSBNdWx0aXZpZXdDYWxlbmRhciBkYXRlIHJhbmdlIHNlbGVjdGlvbiBkaXJlY3RpdmUuXG4gKiAtIGBEYXRlUmFuZ2VFbmRJbnB1dERpcmVjdGl2ZWAmbWRhc2g7VGhlIGVuZCBEYXRlSW5wdXQgZGF0ZSByYW5nZSBzZWxlY3Rpb24gZGlyZWN0aXZlLlxuICogLSBgRGF0ZVJhbmdlU3RhcnRJbnB1dERpcmVjdGl2ZWAmbWRhc2g7VGhlIHN0YXJ0IERhdGVJbnB1dCBkYXRlIHJhbmdlIHNlbGVjdGlvbiBkaXJlY3RpdmUuXG4gKiAtIGBEYXRlUmFuZ2VQb3B1cFRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgRGF0ZVJhbmdlUG9wdXAgY29udGVudCB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBNdWx0aVZpZXdDYWxlbmRhck1vZHVsZWAmbWRhc2g7VGhlIE11bHRpVmlld0NhbGVuZGFyIG1vZHVsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBEYXRlUmFuZ2UgbW9kdWxlXG4gKiBpbXBvcnQgeyBEYXRlUmFuZ2VNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1kYXRlaW5wdXRzJztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgRGF0ZVJhbmdlTW9kdWxlXSwgLy8gaW1wb3J0IERhdGVSYW5nZSBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBEYXRlUmFuZ2VNb2R1bGUgPSBjbGFzcyBEYXRlUmFuZ2VNb2R1bGUge1xufTtcbkRhdGVSYW5nZU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NUE9ORU5UX0RJUkVDVElWRVMkMV0sXG4gICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFUyQxXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ09NUE9ORU5UX01PRFVMRVNdXG4gICAgfSlcbl0sIERhdGVSYW5nZU1vZHVsZSk7XG5cbmNvbnN0IGRpdiQxID0gZG9tQ29udGFpbmVyRmFjdG9yeSgnZGl2Jyk7XG5jb25zdCB1bCQxID0gZG9tQ29udGFpbmVyRmFjdG9yeSgndWwnKTtcbmNvbnN0IGxpJDEgPSBkb21Db250YWluZXJGYWN0b3J5KCdsaScpO1xuY29uc3Qgc3BhbiA9IGRvbUNvbnRhaW5lckZhY3RvcnkoJ3NwYW4nKTtcbmNvbnN0IGxpc3RUaXRsZSA9ICgpID0+IHNwYW4oJ2hvdXInLCAnay10aXRsZSBrLXRpbWVzZWxlY3Rvci10aXRsZScpO1xuY29uc3QgbGlzdEl0ZW0gPSAoKSA9PiBsaSQxKCc8c3Bhbj4wMjwvc3Bhbj4nLCAnay1pdGVtJyk7XG5jb25zdCBsaXN0ID0gKCkgPT4gdWwkMShbbGlzdEl0ZW0oKV0sICdrLXJlc2V0Jyk7XG5jb25zdCBzY3JvbGxhYmxlJDEgPSAoKSA9PiAoZGl2JDEoW2xpc3QoKV0sICdrLXRpbWUtY29udGFpbmVyIGstZmxleCBrLWNvbnRlbnQgay1jYWxlbmRhci1jb250ZW50IGstc2Nyb2xsYWJsZScpKTtcbmNvbnN0IHRpbWVMaXN0V3JhcHBlciA9ICgpID0+IHtcbiAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRpdiQxKFtsaXN0VGl0bGUoKSwgZGl2JDEoW3Njcm9sbGFibGUkMSgpXSwgJ2stdGltZS1saXN0JyldLCAnay10aW1lLWxpc3Qtd3JhcHBlcicsIHsgbGVmdDogJy0xMDAwMHB4JywgcG9zaXRpb246ICdhYnNvbHV0ZScgfSk7XG59O1xuY29uc3QgVElNRUxJU1RfV1JBUFBFUiA9IHRpbWVMaXN0V3JhcHBlcigpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBUaW1lUGlja2VyRE9NU2VydmljZSA9IGNsYXNzIFRpbWVQaWNrZXJET01TZXJ2aWNlIHtcbiAgICBlbnN1cmVIZWlnaHRzKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lTGlzdEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVIZWlnaHRzKCk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUhlaWdodHMoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdENvbnRhaW5lciA9IGNvbnRhaW5lciAmJiBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmstdGltZS1saXN0LWNvbnRhaW5lcicpO1xuICAgICAgICBjb25zdCBob3N0Q29udGFpbmVyID0gbGlzdENvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gaG9zdENvbnRhaW5lci5hcHBlbmRDaGlsZChUSU1FTElTVF9XUkFQUEVSKTtcbiAgICAgICAgdGhpcy50aW1lTGlzdEhlaWdodCA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignLmstc2Nyb2xsYWJsZScpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgdGhpcy5pdGVtSGVpZ2h0ID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yKCdsaScpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgaG9zdENvbnRhaW5lci5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICB9XG4gICAgaXNBY3RpdmUoZWxlbWVudCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSB8fCAhZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZWxlbWVudC5uYXRpdmVFbGVtZW50IHx8IGVsZW1lbnQpID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH1cbn07XG5UaW1lUGlja2VyRE9NU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgVGltZVBpY2tlckRPTVNlcnZpY2UpO1xuXG5jb25zdCBIT1VSU19JTl9EQVkgPSAyNDtcbmNvbnN0IGNsYW1wVG9SYW5nZSA9IChyYW5nZVZhbHVlKSA9PiAodmFsdWUpID0+IHZhbHVlICUgcmFuZ2VWYWx1ZTtcbmNvbnN0IGNsYW1wID0gY2xhbXBUb1JhbmdlKEhPVVJTX0lOX0RBWSk7XG5jb25zdCBzdGVwcGVyID0gKHN0YXJ0LCBzdGVwKSA9PiAoaWR4KSA9PiBjbGFtcChzdGFydCArIChpZHggKiBzdGVwKSk7XG5jb25zdCBkaXN0YW5jZUZyb21NaW4gPSAodmFsdWUsIG1pbikgPT4gY2xhbXAoSE9VUlNfSU5fREFZICsgdmFsdWUgLSBtaW4pO1xuY29uc3QgbGltaXQgPSAoYm9yZGVyVmFsdWUpID0+IChiYXJyaWVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHVzZUJhcnJpZXIgPSAhdmFsdWUgfHwgZ2V0RGF0ZShiYXJyaWVyKS5nZXRUaW1lKCkgPT09IGdldERhdGUodmFsdWUpLmdldFRpbWUoKTtcbiAgICByZXR1cm4gdXNlQmFycmllciA/IGJhcnJpZXIgOiBzZXRIb3VycyhiYXJyaWVyLCBib3JkZXJWYWx1ZSk7XG59O1xuY29uc3QgbGltaXREb3duID0gbGltaXQoMCk7XG5jb25zdCBsaW1pdFVwID0gbGltaXQoSE9VUlNfSU5fREFZIC0gMSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEhvdXJzU2VydmljZSA9IGNsYXNzIEhvdXJzU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoaW50bCkge1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLmJvdW5kUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggPSBmYWxzZTtcbiAgICB9XG4gICAgYXBwbHkodmFsdWUsIGNhbmRpZGF0ZSkge1xuICAgICAgICByZXR1cm4gc2V0SG91cnModmFsdWUsIGNhbmRpZGF0ZS5nZXRIb3VycygpKTtcbiAgICB9XG4gICAgY29uZmlndXJlKHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHsgYm91bmRSYW5nZSA9IHRoaXMuYm91bmRSYW5nZSwgaW5zZXJ0VW5kaXZpZGVkTWF4ID0gdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXgsIG1pbiA9IHRoaXMubWluLCBtYXggPSB0aGlzLm1heCwgcGFydCwgc3RlcCA9IHRoaXMuc3RlcCB9ID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuYm91bmRSYW5nZSA9IGJvdW5kUmFuZ2U7XG4gICAgICAgIHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ID0gaW5zZXJ0VW5kaXZpZGVkTWF4O1xuICAgICAgICB0aGlzLnRvTGlzdEl0ZW0gPSAoaG91cikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IHNldEhvdXJzKE1JRE5JR0hUX0RBVEUsIGhvdXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmludGwuZm9ybWF0RGF0ZShkYXRlLCBwYXJ0LnBhdHRlcm4pLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHRoaXMuc3RlcCA9IHN0ZXA7XG4gICAgfVxuICAgIGRhdGEoc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBjb25zdCBbbWluXSA9IHRoaXMucmFuZ2Uoc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGdldEhvdXIgPSBzdGVwcGVyKG1pbiwgdGhpcy5zdGVwKTtcbiAgICAgICAgY29uc3QgY29udmVydFRvSXRlbSA9IChpZHgpID0+ICh0aGlzLnRvTGlzdEl0ZW0oZ2V0SG91cihpZHgpKSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByYW5nZSgwLCB0aGlzLmNvdW50RnJvbU1pbihzZWxlY3RlZFZhbHVlKSkubWFwKGNvbnZlcnRUb0l0ZW0pO1xuICAgICAgICB0aGlzLmFkZExhc3QoZGF0YSk7XG4gICAgICAgIHRoaXMuYWRkTWlzc2luZyhkYXRhLCBzZWxlY3RlZFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlzUmFuZ2VDaGFuZ2VkKG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiAhaXNFcXVhbCh0aGlzLm1pbiwgbWluKSB8fCAhaXNFcXVhbCh0aGlzLm1heCwgbWF4KTtcbiAgICB9XG4gICAgbGltaXRSYW5nZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRSYW5nZSA/IFtsaW1pdERvd24obWluLCB2YWx1ZSksIGxpbWl0VXAobWF4LCB2YWx1ZSldIDogW21pbiwgbWF4XTtcbiAgICB9XG4gICAgdG90YWwodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbGFzdCQkMSA9IHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ICYmIHRoaXMuaXNMYXN0TWlzc2luZyh2YWx1ZSkgPyAxIDogMDtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IHRoaXMuaXNNaXNzaW5nKHZhbHVlKSA/IDEgOiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3VudEZyb21NaW4odmFsdWUpICsgbWlzc2luZyArIGxhc3QkJDE7XG4gICAgfVxuICAgIHNlbGVjdGVkSW5kZXgodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRpdmlkZUJ5U3RlcCh2YWx1ZSkpO1xuICAgIH1cbiAgICB2YWx1ZUluTGlzdCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaE1heCA9IHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ICYmIHRoaXMubGFzdEhvdXIodmFsdWUpID09PSB2YWx1ZS5nZXRIb3VycygpO1xuICAgICAgICByZXR1cm4gbWF0Y2hNYXggfHwgIXRoaXMuaXNNaXNzaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgYWRkTGFzdChkYXRhLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggJiYgdGhpcy5pc0xhc3RNaXNzaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgZGF0YS5wdXNoKHRoaXMudG9MaXN0SXRlbSh0aGlzLmxhc3RIb3VyKHZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBhZGRNaXNzaW5nKGRhdGEsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlSW5MaXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWlzc2luZ0l0ZW0gPSB0aGlzLnRvTGlzdEl0ZW0odmFsdWUuZ2V0SG91cnMoKSk7XG4gICAgICAgIGRhdGEuc3BsaWNlKHRoaXMuc2VsZWN0ZWRJbmRleCh2YWx1ZSksIDAsIG1pc3NpbmdJdGVtKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvdW50RnJvbU1pbih2YWx1ZSkge1xuICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gdGhpcy5yYW5nZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGRpc3RhbmNlRnJvbU1pbihtYXgsIG1pbikgLyB0aGlzLnN0ZXApICsgMTsgLyogaW5jbHVkZSBtaW4gKi9cbiAgICB9XG4gICAgaXNNaXNzaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4KHZhbHVlKSAhPT0gdGhpcy5kaXZpZGVCeVN0ZXAodmFsdWUpO1xuICAgIH1cbiAgICBpc0xhc3RNaXNzaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTWlzc2luZyhzZXRIb3Vycyh0aGlzLm1heCwgdGhpcy5sYXN0SG91cih2YWx1ZSkpKTtcbiAgICB9XG4gICAgZGl2aWRlQnlTdGVwKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkaXN0YW5jZUZyb21NaW4odmFsdWUuZ2V0SG91cnMoKSwgdGhpcy5taW4uZ2V0SG91cnMoKSkgLyB0aGlzLnN0ZXA7XG4gICAgfVxuICAgIGxhc3RIb3VyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlKHZhbHVlKVsxXTtcbiAgICB9XG4gICAgcmFuZ2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IHRoaXMubGltaXRSYW5nZSh0aGlzLm1pbiwgdGhpcy5tYXgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIFttaW4uZ2V0SG91cnMoKSwgbWF4LmdldEhvdXJzKCldO1xuICAgIH1cbn07XG5Ib3Vyc1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtJbnRsU2VydmljZV0pXG5dLCBIb3Vyc1NlcnZpY2UpO1xuXG5jb25zdCBNSU5VVEVTX0lOX0hPVVIgPSA2MDtcbmNvbnN0IGNsYW1wVG9SYW5nZSQxID0gKHJhbmdlVmFsdWUpID0+ICh2YWx1ZSkgPT4gdmFsdWUgJSByYW5nZVZhbHVlO1xuY29uc3QgY2xhbXAkMSA9IGNsYW1wVG9SYW5nZSQxKE1JTlVURVNfSU5fSE9VUik7XG5jb25zdCBzdGVwcGVyJDEgPSAoc3RhcnQsIHN0ZXApID0+IChpZHgpID0+IGNsYW1wJDEoc3RhcnQgKyAoaWR4ICogc3RlcCkpO1xuY29uc3QgZGlzdGFuY2VGcm9tTWluJDEgPSAodmFsdWUsIG1pbikgPT4gY2xhbXAkMShNSU5VVEVTX0lOX0hPVVIgKyB2YWx1ZSAtIG1pbik7XG5jb25zdCBsaW1pdCQxID0gKGJvcmRlclZhbHVlKSA9PiAoYmFycmllciwgdmFsdWUpID0+IHtcbiAgICBjb25zdCB1c2VCYXJyaWVyID0gIXZhbHVlIHx8IGJhcnJpZXIuZ2V0SG91cnMoKSA9PT0gdmFsdWUuZ2V0SG91cnMoKTtcbiAgICByZXR1cm4gdXNlQmFycmllciA/IGJhcnJpZXIgOiBzZXRNaW51dGVzKGJhcnJpZXIsIGJvcmRlclZhbHVlKTtcbn07XG5jb25zdCBsaW1pdERvd24kMSA9IGxpbWl0JDEoMCk7XG5jb25zdCBsaW1pdFVwJDEgPSBsaW1pdCQxKE1JTlVURVNfSU5fSE9VUiAtIDEpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBNaW51dGVzU2VydmljZSA9IGNsYXNzIE1pbnV0ZXNTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihpbnRsKSB7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ID0gZmFsc2U7XG4gICAgfVxuICAgIGFwcGx5KHZhbHVlLCBjYW5kaWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHNldE1pbnV0ZXModmFsdWUsIGNhbmRpZGF0ZS5nZXRNaW51dGVzKCkpO1xuICAgIH1cbiAgICBjb25maWd1cmUoc2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgeyBpbnNlcnRVbmRpdmlkZWRNYXggPSB0aGlzLmluc2VydFVuZGl2aWRlZE1heCwgbWluID0gdGhpcy5taW4sIG1heCA9IHRoaXMubWF4LCBwYXJ0LCBzdGVwID0gdGhpcy5zdGVwIH0gPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggPSBpbnNlcnRVbmRpdmlkZWRNYXg7XG4gICAgICAgIHRoaXMudG9MaXN0SXRlbSA9IChtaW51dGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBzZXRNaW51dGVzKE1JRE5JR0hUX0RBVEUsIG1pbnV0ZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuaW50bC5mb3JtYXREYXRlKGRhdGUsIHBhcnQucGF0dGVybiksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWluID0gbWluO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgICAgdGhpcy5zdGVwID0gc3RlcDtcbiAgICB9XG4gICAgZGF0YShzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IFttaW5dID0gdGhpcy5yYW5nZShzZWxlY3RlZFZhbHVlKTtcbiAgICAgICAgY29uc3QgZ2V0TWludXRlID0gc3RlcHBlciQxKG1pbiwgdGhpcy5zdGVwKTtcbiAgICAgICAgY29uc3QgY29udmVydFRvSXRlbSA9IChpZHgpID0+ICh0aGlzLnRvTGlzdEl0ZW0oZ2V0TWludXRlKGlkeCkpKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHJhbmdlKDAsIHRoaXMuY291bnRGcm9tTWluKHNlbGVjdGVkVmFsdWUpKS5tYXAoY29udmVydFRvSXRlbSk7XG4gICAgICAgIHRoaXMuYWRkTGFzdChkYXRhKTtcbiAgICAgICAgdGhpcy5hZGRNaXNzaW5nKGRhdGEsIHNlbGVjdGVkVmFsdWUpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaXNSYW5nZUNoYW5nZWQobWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuICFpc0VxdWFsKHRoaXMubWluLCBtaW4pIHx8ICFpc0VxdWFsKHRoaXMubWF4LCBtYXgpO1xuICAgIH1cbiAgICBsaW1pdFJhbmdlKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW2xpbWl0RG93biQxKG1pbiwgdmFsdWUpLCBsaW1pdFVwJDEobWF4LCB2YWx1ZSldO1xuICAgIH1cbiAgICB0b3RhbCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBsYXN0JCQxID0gdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggJiYgdGhpcy5pc0xhc3RNaXNzaW5nKHZhbHVlKSA/IDEgOiAwO1xuICAgICAgICBjb25zdCBtaXNzaW5nID0gdGhpcy5pc01pc3NpbmcodmFsdWUpID8gMSA6IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50RnJvbU1pbih2YWx1ZSkgKyBtaXNzaW5nICsgbGFzdCQkMTtcbiAgICB9XG4gICAgc2VsZWN0ZWRJbmRleCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZGl2aWRlQnlTdGVwKHZhbHVlKSk7XG4gICAgfVxuICAgIHZhbHVlSW5MaXN0KHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoTWF4ID0gdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggJiYgdGhpcy5sYXN0TWludXRlKHZhbHVlKSA9PT0gdmFsdWUuZ2V0TWludXRlcygpO1xuICAgICAgICByZXR1cm4gbWF0Y2hNYXggfHwgIXRoaXMuaXNNaXNzaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgYWRkTGFzdChkYXRhLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggJiYgdGhpcy5pc0xhc3RNaXNzaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgZGF0YS5wdXNoKHRoaXMudG9MaXN0SXRlbSh0aGlzLmxhc3RNaW51dGUodmFsdWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGFkZE1pc3NpbmcoZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVJbkxpc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaXNzaW5nSXRlbSA9IHRoaXMudG9MaXN0SXRlbSh2YWx1ZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICBkYXRhLnNwbGljZSh0aGlzLnNlbGVjdGVkSW5kZXgodmFsdWUpLCAwLCBtaXNzaW5nSXRlbSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb3VudEZyb21NaW4odmFsdWUpIHtcbiAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IHRoaXMucmFuZ2UodmFsdWUpO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkaXN0YW5jZUZyb21NaW4kMShtYXgsIG1pbikgLyB0aGlzLnN0ZXApICsgMTsgLyogaW5jbHVkZSBtaW4gKi9cbiAgICB9XG4gICAgaXNNaXNzaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4KHZhbHVlKSAhPT0gdGhpcy5kaXZpZGVCeVN0ZXAodmFsdWUpO1xuICAgIH1cbiAgICBpc0xhc3RNaXNzaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTWlzc2luZyhzZXRNaW51dGVzKHRoaXMubWF4LCB0aGlzLmxhc3RNaW51dGUodmFsdWUpKSk7XG4gICAgfVxuICAgIGRpdmlkZUJ5U3RlcCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGlzdGFuY2VGcm9tTWluJDEodmFsdWUuZ2V0TWludXRlcygpLCB0aGlzLm1pbi5nZXRNaW51dGVzKCkpIC8gdGhpcy5zdGVwO1xuICAgIH1cbiAgICBsYXN0TWludXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlKHZhbHVlKVsxXTtcbiAgICB9XG4gICAgcmFuZ2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IHRoaXMubGltaXRSYW5nZSh0aGlzLm1pbiwgdGhpcy5tYXgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIFttaW4uZ2V0TWludXRlcygpLCBtYXguZ2V0TWludXRlcygpXTtcbiAgICB9XG59O1xuTWludXRlc1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtJbnRsU2VydmljZV0pXG5dLCBNaW51dGVzU2VydmljZSk7XG5cbmNvbnN0IFNFQ09ORFNfSU5fSE9VUiA9IDYwO1xuY29uc3QgY2xhbXBUb1JhbmdlJDIgPSAocmFuZ2VWYWx1ZSkgPT4gKHZhbHVlKSA9PiB2YWx1ZSAlIHJhbmdlVmFsdWU7XG5jb25zdCBjbGFtcCQyID0gY2xhbXBUb1JhbmdlJDIoU0VDT05EU19JTl9IT1VSKTtcbmNvbnN0IHN0ZXBwZXIkMiA9IChzdGFydCwgc3RlcCkgPT4gKGlkeCkgPT4gY2xhbXAkMihzdGFydCArIChpZHggKiBzdGVwKSk7XG5jb25zdCBkaXN0YW5jZUZyb21NaW4kMiA9ICh2YWx1ZSwgbWluKSA9PiBjbGFtcCQyKFNFQ09ORFNfSU5fSE9VUiArIHZhbHVlIC0gbWluKTtcbmNvbnN0IGxpbWl0JDIgPSAoYm9yZGVyVmFsdWUpID0+IChiYXJyaWVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHVzZUJhcnJpZXIgPSAhdmFsdWUgfHwgYmFycmllci5nZXRIb3VycygpID09PSB2YWx1ZS5nZXRIb3VycygpICYmIGJhcnJpZXIuZ2V0TWludXRlcygpID09PSB2YWx1ZS5nZXRNaW51dGVzKCk7XG4gICAgcmV0dXJuIHVzZUJhcnJpZXIgPyBiYXJyaWVyIDogc2V0U2Vjb25kcyhiYXJyaWVyLCBib3JkZXJWYWx1ZSk7XG59O1xuY29uc3QgbGltaXREb3duJDIgPSBsaW1pdCQyKDApO1xuY29uc3QgbGltaXRVcCQyID0gbGltaXQkMihTRUNPTkRTX0lOX0hPVVIgLSAxKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU2Vjb25kc1NlcnZpY2UgPSBjbGFzcyBTZWNvbmRzU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoaW50bCkge1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLmluc2VydFVuZGl2aWRlZE1heCA9IGZhbHNlO1xuICAgIH1cbiAgICBhcHBseSh2YWx1ZSwgY2FuZGlkYXRlKSB7XG4gICAgICAgIHJldHVybiBzZXRTZWNvbmRzKHZhbHVlLCBjYW5kaWRhdGUuZ2V0U2Vjb25kcygpKTtcbiAgICB9XG4gICAgY29uZmlndXJlKHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHsgaW5zZXJ0VW5kaXZpZGVkTWF4ID0gdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXgsIG1pbiA9IHRoaXMubWluLCBtYXggPSB0aGlzLm1heCwgcGFydCwgc3RlcCA9IHRoaXMuc3RlcCB9ID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ID0gaW5zZXJ0VW5kaXZpZGVkTWF4O1xuICAgICAgICB0aGlzLnRvTGlzdEl0ZW0gPSAoc2Vjb25kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gc2V0U2Vjb25kcyhNSUROSUdIVF9EQVRFLCBzZWNvbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmludGwuZm9ybWF0RGF0ZShkYXRlLCBwYXJ0LnBhdHRlcm4pLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHRoaXMuc3RlcCA9IHN0ZXA7XG4gICAgfVxuICAgIGRhdGEoc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBjb25zdCBbbWluXSA9IHRoaXMucmFuZ2Uoc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGdldFNlY29uZCA9IHN0ZXBwZXIkMihtaW4sIHRoaXMuc3RlcCk7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRUb0l0ZW0gPSAoaWR4KSA9PiAodGhpcy50b0xpc3RJdGVtKGdldFNlY29uZChpZHgpKSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByYW5nZSgwLCB0aGlzLmNvdW50RnJvbU1pbihzZWxlY3RlZFZhbHVlKSkubWFwKGNvbnZlcnRUb0l0ZW0pO1xuICAgICAgICB0aGlzLmFkZExhc3QoZGF0YSk7XG4gICAgICAgIHRoaXMuYWRkTWlzc2luZyhkYXRhLCBzZWxlY3RlZFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlzUmFuZ2VDaGFuZ2VkKG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiAhaXNFcXVhbCh0aGlzLm1pbiwgbWluKSB8fCAhaXNFcXVhbCh0aGlzLm1heCwgbWF4KTtcbiAgICB9XG4gICAgbGltaXRSYW5nZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtsaW1pdERvd24kMihtaW4sIHZhbHVlKSwgbGltaXRVcCQyKG1heCwgdmFsdWUpXTtcbiAgICB9XG4gICAgdG90YWwodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbGFzdCQkMSA9IHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ICYmIHRoaXMuaXNMYXN0TWlzc2luZyh2YWx1ZSkgPyAxIDogMDtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IHRoaXMuaXNNaXNzaW5nKHZhbHVlKSA/IDEgOiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3VudEZyb21NaW4odmFsdWUpICsgbWlzc2luZyArIGxhc3QkJDE7XG4gICAgfVxuICAgIHNlbGVjdGVkSW5kZXgodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRpdmlkZUJ5U3RlcCh2YWx1ZSkpO1xuICAgIH1cbiAgICB2YWx1ZUluTGlzdCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaE1heCA9IHRoaXMuaW5zZXJ0VW5kaXZpZGVkTWF4ICYmIHRoaXMubGFzdFNlY29uZCh2YWx1ZSkgPT09IHZhbHVlLmdldFNlY29uZHMoKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoTWF4IHx8ICF0aGlzLmlzTWlzc2luZyh2YWx1ZSk7XG4gICAgfVxuICAgIGRpdmlkZUJ5U3RlcCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGlzdGFuY2VGcm9tTWluJDIodmFsdWUuZ2V0U2Vjb25kcygpLCB0aGlzLm1pbi5nZXRTZWNvbmRzKCkpIC8gdGhpcy5zdGVwO1xuICAgIH1cbiAgICBhZGRMYXN0KGRhdGEsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmluc2VydFVuZGl2aWRlZE1heCAmJiB0aGlzLmlzTGFzdE1pc3NpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2godGhpcy50b0xpc3RJdGVtKHRoaXMubGFzdFNlY29uZCh2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgYWRkTWlzc2luZyhkYXRhLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZUluTGlzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pc3NpbmdJdGVtID0gdGhpcy50b0xpc3RJdGVtKHZhbHVlLmdldFNlY29uZHMoKSk7XG4gICAgICAgIGRhdGEuc3BsaWNlKHRoaXMuc2VsZWN0ZWRJbmRleCh2YWx1ZSksIDAsIG1pc3NpbmdJdGVtKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvdW50RnJvbU1pbih2YWx1ZSkge1xuICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gdGhpcy5yYW5nZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGRpc3RhbmNlRnJvbU1pbiQyKG1heCwgbWluKSAvIHRoaXMuc3RlcCkgKyAxOyAvKiBpbmNsdWRlIG1pbiAqL1xuICAgIH1cbiAgICBpc01pc3NpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSW5kZXgodmFsdWUpICE9PSB0aGlzLmRpdmlkZUJ5U3RlcCh2YWx1ZSk7XG4gICAgfVxuICAgIGlzTGFzdE1pc3NpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNNaXNzaW5nKHNldFNlY29uZHModGhpcy5tYXgsIHRoaXMubGFzdFNlY29uZCh2YWx1ZSkpKTtcbiAgICB9XG4gICAgbGFzdFNlY29uZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZSh2YWx1ZSlbMV07XG4gICAgfVxuICAgIHJhbmdlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSB0aGlzLmxpbWl0UmFuZ2UodGhpcy5taW4sIHRoaXMubWF4LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBbbWluLmdldFNlY29uZHMoKSwgbWF4LmdldFNlY29uZHMoKV07XG4gICAgfVxufTtcblNlY29uZHNTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgU2Vjb25kc1NlcnZpY2UpO1xuXG5jb25zdCBNSUxMSVNFQ09ORFNfSU5fU0VDT05EID0gMTAwMDtcbmNvbnN0IGNsYW1wVG9SYW5nZSQzID0gKHJhbmdlVmFsdWUpID0+ICh2YWx1ZSkgPT4gdmFsdWUgJSByYW5nZVZhbHVlO1xuY29uc3QgY2xhbXAkMyA9IGNsYW1wVG9SYW5nZSQzKE1JTExJU0VDT05EU19JTl9TRUNPTkQpO1xuY29uc3Qgc3RlcHBlciQzID0gKHN0YXJ0LCBzdGVwKSA9PiAoaWR4KSA9PiBjbGFtcCQzKHN0YXJ0ICsgKGlkeCAqIHN0ZXApKTtcbmNvbnN0IGRpc3RhbmNlRnJvbU1pbiQzID0gKHZhbHVlLCBtaW4pID0+IGNsYW1wJDMoTUlMTElTRUNPTkRTX0lOX1NFQ09ORCArIHZhbHVlIC0gbWluKTtcbmNvbnN0IGxpbWl0JDMgPSAoYm9yZGVyVmFsdWUpID0+IChiYXJyaWVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHVzZUJhcnJpZXIgPSAhdmFsdWUgfHxcbiAgICAgICAgKGJhcnJpZXIuZ2V0SG91cnMoKSA9PT0gdmFsdWUuZ2V0SG91cnMoKSAmJlxuICAgICAgICAgICAgYmFycmllci5nZXRNaW51dGVzKCkgPT09IHZhbHVlLmdldE1pbnV0ZXMoKSAmJlxuICAgICAgICAgICAgYmFycmllci5nZXRTZWNvbmRzKCkgPT09IHZhbHVlLmdldFNlY29uZHMoKSk7XG4gICAgcmV0dXJuIHVzZUJhcnJpZXIgPyBiYXJyaWVyIDogc2V0TWlsbGlzZWNvbmRzKGJhcnJpZXIsIGJvcmRlclZhbHVlKTtcbn07XG5jb25zdCBsaW1pdERvd24kMyA9IGxpbWl0JDMoMCk7XG5jb25zdCBsaW1pdFVwJDMgPSBsaW1pdCQzKE1JTExJU0VDT05EU19JTl9TRUNPTkQgLSAxKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTWlsbGlzZWNvbmRzU2VydmljZSA9IGNsYXNzIE1pbGxpc2Vjb25kc1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGludGwpIHtcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICAgICAgdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggPSBmYWxzZTtcbiAgICB9XG4gICAgYXBwbHkodmFsdWUsIGNhbmRpZGF0ZSkge1xuICAgICAgICByZXR1cm4gc2V0TWlsbGlzZWNvbmRzKHZhbHVlLCBjYW5kaWRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkpO1xuICAgIH1cbiAgICBjb25maWd1cmUoc2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgeyBpbnNlcnRVbmRpdmlkZWRNYXggPSB0aGlzLmluc2VydFVuZGl2aWRlZE1heCwgbWluID0gdGhpcy5taW4sIG1heCA9IHRoaXMubWF4LCBzdGVwID0gdGhpcy5zdGVwIH0gPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5pbnNlcnRVbmRpdmlkZWRNYXggPSBpbnNlcnRVbmRpdmlkZWRNYXg7XG4gICAgICAgIHRoaXMudG9MaXN0SXRlbSA9IChtaWxsaXNlY29uZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IHNldE1pbGxpc2Vjb25kcyhNSUROSUdIVF9EQVRFLCBtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuaW50bC5mb3JtYXREYXRlKGRhdGUsIFwiU1NTXCIpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHRoaXMuc3RlcCA9IHN0ZXA7XG4gICAgfVxuICAgIGRhdGEoc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBjb25zdCBbbWluXSA9IHRoaXMucmFuZ2Uoc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGdldE1pbGxpc2Vjb25kID0gc3RlcHBlciQzKG1pbiwgdGhpcy5zdGVwKTtcbiAgICAgICAgY29uc3QgY29udmVydFRvSXRlbSA9IChpZHgpID0+ICh0aGlzLnRvTGlzdEl0ZW0oZ2V0TWlsbGlzZWNvbmQoaWR4KSkpO1xuICAgICAgICBjb25zdCBkYXRhID0gcmFuZ2UoMCwgdGhpcy5jb3VudEZyb21NaW4oc2VsZWN0ZWRWYWx1ZSkpLm1hcChjb252ZXJ0VG9JdGVtKTtcbiAgICAgICAgdGhpcy5hZGRMYXN0KGRhdGEpO1xuICAgICAgICB0aGlzLmFkZE1pc3NpbmcoZGF0YSwgc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpc1JhbmdlQ2hhbmdlZChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gIWlzRXF1YWwodGhpcy5taW4sIG1pbikgfHwgIWlzRXF1YWwodGhpcy5tYXgsIG1heCk7XG4gICAgfVxuICAgIGxpbWl0UmFuZ2UobWluLCBtYXgsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbbGltaXREb3duJDMobWluLCB2YWx1ZSksIGxpbWl0VXAkMyhtYXgsIHZhbHVlKV07XG4gICAgfVxuICAgIHRvdGFsKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGxhc3QkJDEgPSB0aGlzLmluc2VydFVuZGl2aWRlZE1heCAmJiB0aGlzLmlzTGFzdE1pc3NpbmcodmFsdWUpID8gMSA6IDA7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSB0aGlzLmlzTWlzc2luZyh2YWx1ZSkgPyAxIDogMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRGcm9tTWluKHZhbHVlKSArIG1pc3NpbmcgKyBsYXN0JCQxO1xuICAgIH1cbiAgICBzZWxlY3RlZEluZGV4KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kaXZpZGVCeVN0ZXAodmFsdWUpKTtcbiAgICB9XG4gICAgdmFsdWVJbkxpc3QodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hNYXggPSB0aGlzLmluc2VydFVuZGl2aWRlZE1heCAmJiB0aGlzLmxhc3RNaWxsaXNlY29uZCh2YWx1ZSkgPT09IHZhbHVlLmdldE1pbGxpc2Vjb25kcygpO1xuICAgICAgICByZXR1cm4gbWF0Y2hNYXggfHwgIXRoaXMuaXNNaXNzaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgZGl2aWRlQnlTdGVwKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkaXN0YW5jZUZyb21NaW4kMyh2YWx1ZS5nZXRNaWxsaXNlY29uZHMoKSwgdGhpcy5taW4uZ2V0TWlsbGlzZWNvbmRzKCkpIC8gdGhpcy5zdGVwO1xuICAgIH1cbiAgICBhZGRMYXN0KGRhdGEsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmluc2VydFVuZGl2aWRlZE1heCAmJiB0aGlzLmlzTGFzdE1pc3NpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2godGhpcy50b0xpc3RJdGVtKHRoaXMubGFzdE1pbGxpc2Vjb25kKHZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBhZGRNaXNzaW5nKGRhdGEsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlSW5MaXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWlzc2luZ0l0ZW0gPSB0aGlzLnRvTGlzdEl0ZW0odmFsdWUuZ2V0TWlsbGlzZWNvbmRzKCkpO1xuICAgICAgICBkYXRhLnNwbGljZSh0aGlzLnNlbGVjdGVkSW5kZXgodmFsdWUpLCAwLCBtaXNzaW5nSXRlbSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb3VudEZyb21NaW4odmFsdWUpIHtcbiAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IHRoaXMucmFuZ2UodmFsdWUpO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkaXN0YW5jZUZyb21NaW4kMyhtYXgsIG1pbikgLyB0aGlzLnN0ZXApICsgMTsgLyogaW5jbHVkZSBtaW4gKi9cbiAgICB9XG4gICAgaXNNaXNzaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4KHZhbHVlKSAhPT0gdGhpcy5kaXZpZGVCeVN0ZXAodmFsdWUpO1xuICAgIH1cbiAgICBpc0xhc3RNaXNzaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTWlzc2luZyhzZXRNaWxsaXNlY29uZHModGhpcy5tYXgsIHRoaXMubGFzdE1pbGxpc2Vjb25kKHZhbHVlKSkpO1xuICAgIH1cbiAgICBsYXN0TWlsbGlzZWNvbmQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2UodmFsdWUpWzFdO1xuICAgIH1cbiAgICByYW5nZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gdGhpcy5saW1pdFJhbmdlKHRoaXMubWluLCB0aGlzLm1heCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gW21pbi5nZXRNaWxsaXNlY29uZHMoKSwgbWF4LmdldE1pbGxpc2Vjb25kcygpXTtcbiAgICB9XG59O1xuTWlsbGlzZWNvbmRzU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0ludGxTZXJ2aWNlXSlcbl0sIE1pbGxpc2Vjb25kc1NlcnZpY2UpO1xuXG5jb25zdCBzZXRIb3VycyQxID0gKGRhdGUsIGhvdXJzKSA9PiB7XG4gICAgY29uc3QgY2xvbmUgPSBjbG9uZURhdGUoZGF0ZSk7XG4gICAgY2xvbmUuc2V0SG91cnMoaG91cnMpO1xuICAgIHJldHVybiBjbG9uZTtcbn07XG5jb25zdCBpc0FNID0gKHZhbHVlKSA9PiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSA8IDEyO1xuY29uc3QgaXNQTSA9ICh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGwgJiYgKCF2YWx1ZSB8fCB2YWx1ZSA+IDExKTtcbmNvbnN0IGluUmFuZ2UgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiAoKCFtaW4gJiYgIW1heCkgfHwgKHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXgpKTtcbmNvbnN0IGluUmV2ZXJzZVJhbmdlID0gKHZhbHVlLCBtaW4sIG1heCkgPT4gKCghbWluICYmICFtYXgpIHx8IHZhbHVlID49IG1pbiB8fCB2YWx1ZSA8PSBtYXgpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBEYXlQZXJpb2RTZXJ2aWNlID0gY2xhc3MgRGF5UGVyaW9kU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoaW50bCkge1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgYXBwbHkodmFsdWUsIGNhbmRpZGF0ZSkge1xuICAgICAgICBjb25zdCBob3VyID0gdmFsdWUuZ2V0SG91cnMoKTtcbiAgICAgICAgY29uc3QgaG91ckFNID0gaXNBTShob3VyKTtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlQU0gPSBpc0FNKGNhbmRpZGF0ZS5nZXRIb3VycygpKTtcbiAgICAgICAgaWYgKChob3VyQU0gJiYgY2FuZGlkYXRlQU0pIHx8ICghaG91ckFNICYmICFjYW5kaWRhdGVBTSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbbWluLCBtYXggPSAyNF0gPSB0aGlzLm5vcm1hbGl6ZWRSYW5nZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBob3VyICsgKGNhbmRpZGF0ZUFNID8gLTEyIDogMTIpO1xuICAgICAgICByZXR1cm4gc2V0SG91cnMkMSh2YWx1ZSwgTWF0aC5taW4oTWF0aC5tYXgobWluLCByZXN1bHQpLCAobWF4IHx8IDI0KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uZmlndXJlKHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHsgbWluID0gdGhpcy5taW4sIG1heCA9IHRoaXMubWF4LCBwYXJ0ID0gdGhpcy5wYXJ0IH0gPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICB0aGlzLnBhcnQgPSBwYXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZGF0YShfKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5wYXJ0Lm5hbWVzO1xuICAgICAgICBpZiAoIW5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gdGhpcy5ub3JtYWxpemVkUmFuZ2UoKTtcbiAgICAgICAgY29uc3QgZGF5UGVyaW9kID0gdGhpcy5pbnRsLmRhdGVGb3JtYXROYW1lcyhuYW1lcyk7XG4gICAgICAgIGlmIChpc0FNKG1pbikpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh7IHRleHQ6IGRheVBlcmlvZC5hbSwgdmFsdWU6IHNldEhvdXJzJDEodGhpcy5taW4sIG1pbikgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUE0obWF4KSkge1xuICAgICAgICAgICAgZGF0YS5wdXNoKHsgdGV4dDogZGF5UGVyaW9kLnBtLCB2YWx1ZTogc2V0SG91cnMkMSh0aGlzLm1pbiwgTWF0aC5tYXgoMTIsIG1heCkpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1pbi5nZXRIb3VycygpICE9PSBtaW4gPyBkYXRhLnJldmVyc2UoKSA6IGRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpc1JhbmdlQ2hhbmdlZChfLCBfXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBsaW1pdFJhbmdlKG1pbiwgbWF4LCBfKSB7XG4gICAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG90YWwoKSB7XG4gICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSB0aGlzLm5vcm1hbGl6ZWRSYW5nZSgpO1xuICAgICAgICBpZiAoIW1pbiAmJiAhbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID4gMTEgfHwgbWF4IDwgMTIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2VsZWN0ZWRJbmRleCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWVJbkxpc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKHZhbHVlLmdldEhvdXJzKCkgLyAxMik7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbi5nZXRIb3VycygpID09PSB0aGlzLm5vcm1hbGl6ZWRSYW5nZSgpWzBdID8gaW5kZXggOiAoaW5kZXggPT09IDAgPyAxIDogMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2YWx1ZUluTGlzdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCByZXZlcnNlID0gdGhpcy5taW4uZ2V0SG91cnMoKSAhPT0gdGhpcy5ub3JtYWxpemVkUmFuZ2UoKVswXTtcbiAgICAgICAgY29uc3QgaXNJblJhbmdlID0gcmV2ZXJzZSA/IGluUmV2ZXJzZVJhbmdlIDogaW5SYW5nZTtcbiAgICAgICAgcmV0dXJuIGlzSW5SYW5nZSh2YWx1ZS5nZXRIb3VycygpLCB0aGlzLm1pbi5nZXRIb3VycygpLCB0aGlzLm1heC5nZXRIb3VycygpKTtcbiAgICB9XG4gICAgbm9ybWFsaXplZFJhbmdlKCkge1xuICAgICAgICBjb25zdCBtaW5Ib3VyID0gdGhpcy5taW4uZ2V0SG91cnMoKTtcbiAgICAgICAgY29uc3QgbWF4SG91ciA9IHRoaXMubWF4LmdldEhvdXJzKCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBNYXRoLm1pbihtaW5Ib3VyLCBtYXhIb3VyKSxcbiAgICAgICAgICAgIE1hdGgubWF4KG1pbkhvdXIsIG1heEhvdXIpXG4gICAgICAgIF07XG4gICAgfVxufTtcbkRheVBlcmlvZFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtJbnRsU2VydmljZV0pXG5dLCBEYXlQZXJpb2RTZXJ2aWNlKTtcblxuY29uc3QgU05BUF9USFJFU0hPTEQgPSAwLjA1OyAvLyUgb2YgdGhlIGl0ZW0gaGVpZ2h0XG5jb25zdCBTQ1JPTExfVEhSRVNIT0xEID0gMjsgLy88IDJweCB0aHJlc2hvbGRcbmNvbnN0IG5pbCA9ICgpID0+IChudWxsKTtcbmNvbnN0IGdldHRlcnMgPSB7XG4gICAgMzU6IChkYXRhLCBfKSA9PiBkYXRhW2RhdGEubGVuZ3RoIC0gMV0sXG4gICAgMzY6IChkYXRhLCBfKSA9PiBkYXRhWzBdLFxuICAgIDM4OiAoZGF0YSwgaW5kZXgpID0+IGRhdGFbaW5kZXggLSAxXSxcbiAgICA0MDogKGRhdGEsIGluZGV4KSA9PiBkYXRhW2luZGV4ICsgMV1cbn07XG5jb25zdCBzZXJ2aWNlcyQxID0ge1xuICAgIFtUSU1FX1BBUlQuZGF5cGVyaW9kXTogRGF5UGVyaW9kU2VydmljZSxcbiAgICBbVElNRV9QQVJULmhvdXJdOiBIb3Vyc1NlcnZpY2UsXG4gICAgW1RJTUVfUEFSVC5taW51dGVdOiBNaW51dGVzU2VydmljZSxcbiAgICBbVElNRV9QQVJULnNlY29uZF06IFNlY29uZHNTZXJ2aWNlLFxuICAgIFtUSU1FX1BBUlQubWlsbGlzZWNvbmRdOiBNaWxsaXNlY29uZHNTZXJ2aWNlXG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBUaW1lTGlzdENvbXBvbmVudCA9IGNsYXNzIFRpbWVMaXN0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBpbmplY3RvciwgZG9tLCByZW5kZXJlciwgem9uZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMubWluID0gY2xvbmVEYXRlKE1JRE5JR0hUX0RBVEUpO1xuICAgICAgICB0aGlzLm1heCA9IGNsb25lRGF0ZShNQVhfVElNRSk7XG4gICAgICAgIHRoaXMuc3RlcCA9IDE7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMuYW5pbWF0ZVRvSW5kZXggPSB0cnVlO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2tpcCA9IDA7XG4gICAgICAgIHRoaXMudG90YWwgPSA2MDtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMuaW5kZXhUb1Njcm9sbCA9IC0xO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cyA9IFtdO1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gdW5kZWZpbmVkIDogMDtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5wYXJ0KSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2UgPSB0aGlzLmluamVjdG9yLmdldChzZXJ2aWNlcyQxW3RoaXMucGFydC50eXBlXSk7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2UuY29uZmlndXJlKHRoaXMuc2VydmljZVNldHRpbmdzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgY29uc3QgdmFsdWVDaGFuZ2VzID0gY2hhbmdlcy52YWx1ZSB8fCB7fTtcbiAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IHRoaXMuc2VydmljZS5saW1pdFJhbmdlKHRoaXMubWluLCB0aGlzLm1heCwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5zZXJ2aWNlLmlzUmFuZ2VDaGFuZ2VkKG1pbiwgbWF4KSB8fCBjaGFuZ2VzLm1pbiB8fCBjaGFuZ2VzLm1heCB8fCBjaGFuZ2VzLnN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLmNvbmZpZ3VyZSh0aGlzLnNlcnZpY2VTZXR0aW5ncyh7IG1pbiwgbWF4IH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIHRoZSByZW5kZXJpbmcgb2YgdGhlIGxpc3Qgd2hlbmV2ZXIgcG9zc2libGVcbiAgICAgICAgaWYgKCF0aGlzLmRhdGEubGVuZ3RoIHx8IHRoaXMuaGFzTWlzc2luZ1ZhbHVlKHZhbHVlQ2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvSW5kZXggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuc2VydmljZS5kYXRhKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdGVUb0luZGV4ID0gdGhpcy5hbmltYXRlVG9JbmRleCAmJiB0aGlzLnRleHRIYXNDaGFuZ2VkKHZhbHVlQ2hhbmdlcyk7XG4gICAgICAgIHRoaXMudG90YWwgPSB0aGlzLnNlcnZpY2UudG90YWwodmFsdWUpO1xuICAgICAgICB0aGlzLmluZGV4VG9TY3JvbGwgPSB0aGlzLnNlbGVjdGVkSW5kZXgodmFsdWUpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRlVG9JbmRleCA9IHRydWU7XG4gICAgICAgIHRoaXMuZG9tLmVuc3VyZUhlaWdodHMoKTtcbiAgICAgICAgdGhpcy5pdGVtSGVpZ2h0ID0gdGhpcy5kb20uaXRlbUhlaWdodDtcbiAgICAgICAgdGhpcy5saXN0SGVpZ2h0ID0gdGhpcy5kb20udGltZUxpc3RIZWlnaHQ7XG4gICAgICAgIHRoaXMudG9wT2Zmc2V0ID0gKHRoaXMubGlzdEhlaWdodCAtIHRoaXMuaXRlbUhlaWdodCkgLyAyO1xuICAgICAgICB0aGlzLmJvdHRvbU9mZnNldCA9IHRoaXMubGlzdEhlaWdodCAtIHRoaXMuaXRlbUhlaWdodDtcbiAgICAgICAgdGhpcy50b3BUaHJlc2hvbGQgPSB0aGlzLml0ZW1IZWlnaHQgKiBTTkFQX1RIUkVTSE9MRDtcbiAgICAgICAgdGhpcy5ib3R0b21UaHJlc2hvbGQgPSB0aGlzLml0ZW1IZWlnaHQgKiAoMSAtIFNOQVBfVEhSRVNIT0xEKTtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlID0gYHRyYW5zbGF0ZVkoJHt0aGlzLnRvcE9mZnNldH1weClgO1xuICAgICAgICB0aGlzLnN0eWxlID0geyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSwgJy1tcy10cmFuc2Zvcm0nOiB0cmFuc2xhdGUgfTtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cy5mb3JFYWNoKHVuYmluZENhbGxiYWNrID0+IHVuYmluZENhbGxiYWNrKCkpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsT25jZSgoaW5kZXgpID0+IHRoaXMudmlydHVhbGl6YXRpb24uc2Nyb2xsVG9JbmRleChpbmRleCkpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsT25jZSgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYW5pbWF0ZVRvSW5kZXggPyAnYW5pbWF0ZVRvSW5kZXgnIDogJ3Njcm9sbFRvSW5kZXgnO1xuICAgICAgICAgICAgdGhpcy52aXJ0dWFsaXphdGlvblthY3Rpb25dKGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvSW5kZXggPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKGRhdGFJdGVtKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHRoaXMuc2VydmljZS5hcHBseSh0aGlzLnZhbHVlLCBkYXRhSXRlbS52YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlLmdldFRpbWUoKSA9PT0gY2FuZGlkYXRlLmdldFRpbWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXhUb1Njcm9sbCA9IHRoaXMuZGF0YS5pbmRleE9mKGRhdGFJdGVtKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KGNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIGhhbmRsZUl0ZW1DbGljayhhcmdzKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBjbG9zZXN0SW5TY29wZShhcmdzLnRhcmdldCwgbm9kZSA9PiBub2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS10aW1lbGlzdC1pdGVtLWluZGV4JyksIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGltZWxpc3QtaXRlbS1pbmRleCcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UodGhpcy5kYXRhW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgaG9zdCBlbGVtZW50IG9mIHRoZSBUaW1lTGlzdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxidXR0b24gKGNsaWNrKT1cInRpbWVsaXN0LmZvY3VzKClcIj5Gb2N1cyBUaW1lTGlzdDwvYnV0dG9uPlxuICAgICAqICA8a2VuZG8tdGltZWxpc3QgI3RpbWVsaXN0Pjwva2VuZG8tdGltZWxpc3Q+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgVGltZUxpc3QgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgICBpdGVtT2Zmc2V0KHNjcm9sbFRvcCkge1xuICAgICAgICBjb25zdCB2YWx1ZUluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4KHRoaXMudmFsdWUpO1xuICAgICAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMudmlydHVhbGl6YXRpb24uYWN0aXZlSW5kZXgoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy52aXJ0dWFsaXphdGlvbi5pdGVtT2Zmc2V0KGFjdGl2ZUluZGV4KTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmFicyhNYXRoLmNlaWwoc2Nyb2xsVG9wKSAtIG9mZnNldCk7XG4gICAgICAgIGlmICh2YWx1ZUluZGV4ID09PSBhY3RpdmVJbmRleCAmJiBkaXN0YW5jZSA8IFNDUk9MTF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Nyb2xsVXAgPSB2YWx1ZUluZGV4ID4gYWN0aXZlSW5kZXg7XG4gICAgICAgIGNvbnN0IG1vdmVUb05leHQgPSBzY3JvbGxVcCAmJiBkaXN0YW5jZSA+PSB0aGlzLmJvdHRvbVRocmVzaG9sZCB8fCAhc2Nyb2xsVXAgJiYgZGlzdGFuY2UgPiB0aGlzLnRvcFRocmVzaG9sZDtcbiAgICAgICAgcmV0dXJuIG1vdmVUb05leHQgPyB0aGlzLnZpcnR1YWxpemF0aW9uLml0ZW1PZmZzZXQoYWN0aXZlSW5kZXggKyAxKSA6IG9mZnNldDtcbiAgICB9XG4gICAgaGFzTWlzc2luZ1ZhbHVlKHsgcHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlIH0pIHtcbiAgICAgICAgY29uc3QgaXNQcmV2aW91c01pc3NpbmcgPSBwcmV2aW91c1ZhbHVlICYmICF0aGlzLnNlcnZpY2UudmFsdWVJbkxpc3QocHJldmlvdXNWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGlzQ3VycmVudE1pc3NpbmcgPSBjdXJyZW50VmFsdWUgJiYgIXRoaXMuc2VydmljZS52YWx1ZUluTGlzdChjdXJyZW50VmFsdWUpO1xuICAgICAgICByZXR1cm4gaXNQcmV2aW91c01pc3NpbmcgfHwgaXNDdXJyZW50TWlzc2luZztcbiAgICB9XG4gICAgc2Nyb2xsT25jZShhY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhUb1Njcm9sbCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFjdGlvbih0aGlzLmluZGV4VG9TY3JvbGwpO1xuICAgICAgICAgICAgdGhpcy5pbmRleFRvU2Nyb2xsID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VydmljZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgYm91bmRSYW5nZTogZmFsc2UsXG4gICAgICAgICAgICBpbnNlcnRVbmRpdmlkZWRNYXg6IGZhbHNlLFxuICAgICAgICAgICAgbWF4OiB0aGlzLm1heCxcbiAgICAgICAgICAgIG1pbjogdGhpcy5taW4sXG4gICAgICAgICAgICBwYXJ0OiB0aGlzLnBhcnQsXG4gICAgICAgICAgICBzdGVwOiB0aGlzLnN0ZXBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHNldHRpbmdzKTtcbiAgICAgICAgcmVzdWx0LmJvdW5kUmFuZ2UgPSByZXN1bHQucGFydC50eXBlICE9PSAnaG91cic7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNlbGVjdGVkSW5kZXgodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2Uuc2VsZWN0ZWRJbmRleCh2YWx1ZSk7XG4gICAgfVxuICAgIHRleHRIYXNDaGFuZ2VkKHsgcHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlIH0pIHtcbiAgICAgICAgaWYgKCFwcmV2aW91c1ZhbHVlIHx8ICFjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGREYXRhID0gdGhpcy5kYXRhW3RoaXMuc2VsZWN0ZWRJbmRleChwcmV2aW91c1ZhbHVlKV07XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSB0aGlzLmRhdGFbdGhpcy5zZWxlY3RlZEluZGV4KGN1cnJlbnRWYWx1ZSldO1xuICAgICAgICByZXR1cm4gb2xkRGF0YSAmJiBuZXdEYXRhICYmIG9sZERhdGEudGV4dCAhPT0gbmV3RGF0YS50ZXh0O1xuICAgIH1cbiAgICBoYW5kbGVLZXlEb3duKGUpIHtcbiAgICAgICAgY29uc3QgZ2V0dGVyID0gZ2V0dGVyc1tlLmtleUNvZGVdIHx8IG5pbDtcbiAgICAgICAgY29uc3QgZGF0YUl0ZW0gPSBnZXR0ZXIodGhpcy5kYXRhLCB0aGlzLnNlcnZpY2Uuc2VsZWN0ZWRJbmRleCh0aGlzLnZhbHVlKSk7XG4gICAgICAgIGlmIChkYXRhSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoZGF0YUl0ZW0pO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmRFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uID0gdGhpcy52aXJ0dWFsaXphdGlvblxuICAgICAgICAgICAgLnNjcm9sbCQoKVxuICAgICAgICAgICAgLnBpcGUoZGVib3VuY2VUaW1lKDEwMCksIG1hcCgoZSkgPT4gZS50YXJnZXQuc2Nyb2xsVG9wKSwgbWFwKCh0b3ApID0+IHRoaXMuaXRlbU9mZnNldCh0b3ApKSwgbWFwKChpdGVtT2Zmc2V0KSA9PiB0aGlzLnZpcnR1YWxpemF0aW9uLml0ZW1JbmRleChpdGVtT2Zmc2V0KSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGluZGV4ID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlydHVhbGl6YXRpb24uc2Nyb2xsVG9JbmRleChpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSh0aGlzLmRhdGFbaW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5kb21FdmVudHMucHVzaCh0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnbW91c2VvdmVyJywgKCkgPT4gIXRoaXMuaXNBY3RpdmUgJiYgdGhpcy5mb2N1cygpKSwgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2NsaWNrJywgKCkgPT4gdGhpcy5mb2N1cygpKSwgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2JsdXInLCAoKSA9PiB0aGlzLmlzQWN0aXZlID0gZmFsc2UpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnZm9jdXMnLCAoKSA9PiB0aGlzLmlzQWN0aXZlID0gdHJ1ZSksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duLmJpbmQodGhpcykpKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIFRpbWVMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBUaW1lTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUaW1lTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwicGFydFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVGltZUxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInN0ZXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaW1lTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBUaW1lTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBUaW1lTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZChWaXJ0dWFsaXphdGlvbkNvbXBvbmVudCwgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFZpcnR1YWxpemF0aW9uQ29tcG9uZW50KVxuXSwgVGltZUxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInZpcnR1YWxpemF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZyhcImF0dHIudGFiaW5kZXhcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgVGltZUxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoXCJjbGFzcy5rLXRpbWUtbGlzdFwiKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpbWVMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb21wb25lbnRDbGFzc1wiLCB2b2lkIDApO1xuVGltZUxpc3RDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRpbWVsaXN0JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8a2VuZG8tdmlydHVhbGl6YXRpb25cbiAgICAgICAgW3NraXBdPVwic2tpcFwiXG4gICAgICAgIFt0YWtlXT1cInRvdGFsXCJcbiAgICAgICAgW3RvdGFsXT1cInRvdGFsXCJcbiAgICAgICAgW2l0ZW1IZWlnaHRdPVwiaXRlbUhlaWdodFwiXG4gICAgICAgIFttYXhTY3JvbGxEaWZmZXJlbmNlXT1cImxpc3RIZWlnaHRcIlxuICAgICAgICBbdG9wT2Zmc2V0XT1cInRvcE9mZnNldFwiXG4gICAgICAgIFtib3R0b21PZmZzZXRdPVwiYm90dG9tT2Zmc2V0XCJcbiAgICAgICAgY2xhc3M9XCJrLXRpbWUtY29udGFpbmVyXCJcbiAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgID5cbiAgICAgICAgPHVsIFtuZ1N0eWxlXT1cInN0eWxlXCIgY2xhc3M9XCJrLXJlc2V0XCJcbiAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICBjbGljazogaGFuZGxlSXRlbUNsaWNrXG4gICAgICAgICAgICB9XCJcbiAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBpdGVtIG9mIGRhdGE7IGxldCBpbmRleCA9IGluZGV4O1wiIGNsYXNzPVwiay1pdGVtXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLXRpbWVsaXN0LWl0ZW0taW5kZXhdPVwiaW5kZXhcIj5cbiAgICAgICAgICAgICAgICA8c3Bhbj57e2l0ZW0udGV4dH19PC9zcGFuPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC91bD5cbiAgICA8L2tlbmRvLXZpcnR1YWxpemF0aW9uPlxuICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBJbmplY3RvcixcbiAgICAgICAgVGltZVBpY2tlckRPTVNlcnZpY2UsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTmdab25lXSlcbl0sIFRpbWVMaXN0Q29tcG9uZW50KTtcblxuY29uc3QgaXNFcXVhbFRpbGxNaW51dGUgPSAodmFsdWUsIG1pbikgPT4gdmFsdWUuZ2V0SG91cnMoKSA9PT0gbWluLmdldEhvdXJzKCkgJiYgdmFsdWUuZ2V0TWludXRlcygpID09PSBtaW4uZ2V0TWludXRlcygpO1xuY29uc3QgaXNFcXVhbFRpbGxTZWNvbmQgPSAodmFsdWUsIG1pbikgPT4gaXNFcXVhbFRpbGxNaW51dGUodmFsdWUsIG1pbikgJiYgdmFsdWUuZ2V0U2Vjb25kcygpID09PSBtaW4uZ2V0U2Vjb25kcygpO1xuY29uc3QgaXNFcXVhbFRpbGxNaWxsaXNlY29uZCA9ICh2YWx1ZSwgbWluKSA9PiBpc0VxdWFsVGlsbFNlY29uZCh2YWx1ZSwgbWluKSAmJiB2YWx1ZS5nZXRNaWxsaXNlY29uZHMoKSA9PT0gbWluLmdldE1pbGxpc2Vjb25kcygpO1xuY29uc3QgybUzJDcgPSAodmFsdWUpID0+IHZhbHVlLmdldEhvdXJzKCksIMm1NCQzID0gKF8sIG1pbikgPT4gbWluLmdldEhvdXJzKCksIMm1NSQxID0gKHZhbHVlKSA9PiB2YWx1ZS5nZXRNaW51dGVzKCksIMm1NiQxID0gKHZhbHVlLCBtaW4pID0+IGlzRXF1YWxUaWxsTWludXRlKHZhbHVlLCBtaW4pID8gbWluLmdldE1pbnV0ZXMoKSA6IDAsIMm1NyQxID0gKHZhbHVlKSA9PiB2YWx1ZS5nZXRTZWNvbmRzKCksIMm1OCQxID0gKHZhbHVlLCBtaW4pID0+IGlzRXF1YWxUaWxsU2Vjb25kKHZhbHVlLCBtaW4pID8gbWluLmdldFNlY29uZHMoKSA6IDAsIMm1OSQxID0gKHZhbHVlKSA9PiB2YWx1ZS5nZXRNaWxsaXNlY29uZHMoKSwgybUxMCQxID0gKHZhbHVlLCBtaW4pID0+IGlzRXF1YWxUaWxsTWlsbGlzZWNvbmQodmFsdWUsIG1pbikgPyBtaW4uZ2V0TWlsbGlzZWNvbmRzKCkgOiAwO1xuY29uc3QgZGVmYXVsdEdldHRlcnMgPSBbXG4gICAge1xuICAgICAgICB0eXBlOiBUSU1FX1BBUlQuaG91cixcbiAgICAgICAgZ2V0dGVyOiDJtTMkNyxcbiAgICAgICAgbWluR2V0dGVyOiDJtTQkM1xuICAgIH0sIHtcbiAgICAgICAgdHlwZTogVElNRV9QQVJULm1pbnV0ZSxcbiAgICAgICAgZ2V0dGVyOiDJtTUkMSxcbiAgICAgICAgbWluR2V0dGVyOiDJtTYkMVxuICAgIH0sIHtcbiAgICAgICAgdHlwZTogVElNRV9QQVJULnNlY29uZCxcbiAgICAgICAgZ2V0dGVyOiDJtTckMSxcbiAgICAgICAgbWluR2V0dGVyOiDJtTgkMVxuICAgIH0sIHtcbiAgICAgICAgdHlwZTogVElNRV9QQVJULm1pbGxpc2Vjb25kLFxuICAgICAgICBnZXR0ZXI6IMm1OSQxLFxuICAgICAgICBtaW5HZXR0ZXI6IMm1MTAkMVxuICAgIH1cbl07XG5jb25zdCBsZWZ0ID0gZ2V0dGVyID0+IChvcmlnaW4sIF8pID0+IGdldHRlcihvcmlnaW4pO1xuY29uc3QgcmlnaHQgPSBnZXR0ZXIgPT4gKF8sIGNhbmRpZGF0ZSkgPT4gZ2V0dGVyKGNhbmRpZGF0ZSk7XG5jb25zdCBjb252ZXJ0VG9PYmplY3QgPSAocGFydHMpID0+IHBhcnRzLnJlZHVjZSgob2JqLCBwKSA9PiB7IG9ialtwLnR5cGVdID0gcC50eXBlOyByZXR1cm4gb2JqOyB9LCB7fSk7XG5jb25zdCBnZXR0ZXJCeVBhcnQgPSBwYXJ0cyA9PiBnID0+IHBhcnRzW2cudHlwZV0gPyByaWdodChnLmdldHRlcikgOiBsZWZ0KGcuZ2V0dGVyKTtcbmNvbnN0IGdldHRlcnNGYWN0b3J5ID0gZ2V0dGVycyA9PiBwYXJ0cyA9PiAoZ2V0dGVycy5tYXAoZ2V0dGVyQnlQYXJ0KGNvbnZlcnRUb09iamVjdChwYXJ0cykpKSk7XG5jb25zdCBzbmFwVmFsdWUgPSAoZ2V0dGVyLCBtaW5HZXR0ZXIsIHN0ZXApID0+IChkYXRlLCBtaW4pID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldHRlcihkYXRlKTtcbiAgICBjb25zdCBtaW5WYWx1ZSA9IG1pbkdldHRlcihkYXRlLCBtaW4pO1xuICAgIGNvbnN0IHJlc3QgPSB2YWx1ZSAtIG1pblZhbHVlO1xuICAgIGlmIChyZXN0IDwgMCkge1xuICAgICAgICByZXR1cm4gbWluVmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IG1vZCA9IHJlc3QgJSBzdGVwO1xuICAgIHJldHVybiB2YWx1ZSAtIG1vZCArIChtb2QgPiBzdGVwIC8gMiA/IHN0ZXAgOiAwKTtcbn07XG5jb25zdCBzbmFwcGVyc0ZhY3RvcnkgPSAoZ2V0dGVycykgPT4gc3RlcHMgPT4gKGdldHRlcnMubWFwKGcgPT4ge1xuICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1tnLnR5cGVdO1xuICAgIHJldHVybiBzdGVwID8gc25hcFZhbHVlKGcuZ2V0dGVyLCBnLm1pbkdldHRlciwgc3RlcCkgOiBnLmdldHRlcjtcbn0pKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBnZW5lcmF0ZUdldHRlcnMgPSBnZXR0ZXJzRmFjdG9yeShkZWZhdWx0R2V0dGVycyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2VuZXJhdGVTbmFwcGVycyA9IHNuYXBwZXJzRmFjdG9yeShkZWZhdWx0R2V0dGVycyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdmFsdWVNZXJnZXIgPSBnZXR0ZXJzID0+IChvcmlnaW4sIGNhbmRpZGF0ZSkgPT4ge1xuICAgIG9yaWdpbi5zZXRIb3VycyguLi5nZXR0ZXJzLm1hcChnID0+IGcob3JpZ2luLCBjYW5kaWRhdGUpKSk7XG4gICAgcmV0dXJuIG9yaWdpbjtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc25hcFRpbWUgPSBzbmFwcGVycyA9PiAoY2FuZGlkYXRlLCBtaW4pID0+IHtcbiAgICBjb25zdCBkYXRlID0gY2xvbmVEYXRlKGNhbmRpZGF0ZSk7XG4gICAgZGF0ZS5zZXRIb3VycyguLi5zbmFwcGVycy5tYXAocyA9PiBzKGRhdGUsIG1pbikpKTtcbiAgICByZXR1cm4gZGF0ZTtcbn07XG5cbmNvbnN0IGxpc3RSZWR1Y2VyID0gKHN0YXRlLCBsaXN0LCBpZHgsIGFsbCkgPT4ge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggfHwgIWxpc3QuaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIG5leHQ6IGFsbFtpZHggKyAxXSB8fCBsaXN0LFxuICAgICAgICAgICAgcHJldjogYWxsW2lkeCAtIDFdIHx8IGxpc3RcbiAgICAgICAgfV07XG59O1xudmFyIERpcmVjdGlvbjtcbihmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxlZnRcIl0gPSAwXSA9IFwiTGVmdFwiO1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJSaWdodFwiXSA9IDFdID0gXCJSaWdodFwiO1xufSkoRGlyZWN0aW9uIHx8IChEaXJlY3Rpb24gPSB7fSkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmVwcmVzZW50cyB0aGUgS2VuZG8gVUkgVGltZVNlbGVjdG9yIGNvbXBvbmVudCBmb3IgQW5ndWxhci5cbiAqL1xubGV0IFRpbWVTZWxlY3RvckNvbXBvbmVudCA9IGNsYXNzIFRpbWVTZWxlY3RvckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uLCBjZHIsIGVsZW1lbnQsIGludGwsIGRvbSwgem9uZSwgcmVuZGVyZXIsIHBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2UgPSBwaWNrZXJTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSB0aW1lIGZvcm1hdCB1c2VkIHRvIGRpc3BsYXkgdGhlIHRpbWUgbGlzdCBjb2x1bW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSAndCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHNtYWxsZXN0IHZhbGlkIHRpbWUgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbiA9IGNsb25lRGF0ZShNSU5fVElNRSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGJpZ2dlc3QgdmFsaWQgdGltZSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4ID0gY2xvbmVEYXRlKE1BWF9USU1FKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBkaXNwbGF5IHRoZSAqKkNhbmNlbCoqIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZGlzcGxheSB0aGUgKipTZXQqKiBidXR0b24gaW4gdGhlIHBvcHVwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRCdXR0b24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGRpc3BsYXkgdGhlICoqTm93KiogYnV0dG9uIGluIHRoZSBwb3B1cC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBJZiB0aGUgY3VycmVudCB0aW1lIGlzIG91dCBvZiByYW5nZSBvciB0aGUgaW5jcmVtZW50YWwgc3RlcCBpcyBncmVhdGVyIHRoYW4gYDFgLCB0aGUgKipOb3cqKiBidXR0b24gd2lsbCBiZSBoaWRkZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vd0J1dHRvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGBkaXNhYmxlZGAgcHJvcGVydHkgb2YgdGhlIFRpbWVTZWxlY3RvciBhbmQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgYWN0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSB2YWx1ZSBvZiB0aGUgVGltZVNlbGVjdG9yIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSBuZXcgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGNhbmNlbHMgdGhlIHNlbGVjdGVkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZVJlamVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3dOb3dCdXR0b24gPSB0cnVlO1xuICAgICAgICB0aGlzLl9hY3RpdmVMaXN0SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fc3RlcHMgPSB7fTtcbiAgICAgICAgdGhpcy5kb21FdmVudHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXJTZXJ2aWNlLnRpbWVTZWxlY3RvciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgaW5jcmVtZW50YWwgc3RlcHMgb2YgdGhlIFRpbWVTZWxlY3Rvci5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAgICogLSBgaG91cjogTnVtYmVyYCZtZGFzaDtDb250cm9scyB0aGUgaW5jcmVtZW50YWwgc3RlcCBvZiB0aGUgaG91ciB2YWx1ZS5cbiAgICAgKiAtIGBtaW51dGU6IE51bWJlcmAmbWRhc2g7Q29udHJvbHMgdGhlIGluY3JlbWVudGFsIHN0ZXAgb2YgdGhlIG1pbnV0ZSB2YWx1ZS5cbiAgICAgKiAtIGBzZWNvbmQ6IE51bWJlcmAmbWRhc2g7Q29udHJvbHMgdGhlIGluY3JlbWVudGFsIHN0ZXAgb2YgdGhlIHNlY29uZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxrZW5kby10aW1lc2VsZWN0b3IgZm9ybWF0PVwiSEg6bW06c3NcIiBbc3RlcHNdPVwic3RlcHNcIj48L2tlbmRvLXRpbWVzZWxlY3Rvcj5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgIHB1YmxpYyBzdGVwcyA9IHsgaG91cjogMiwgbWludXRlOiAxNSwgc2Vjb25kOiAxNSB9O1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqID4gSWYgdGhlIGluY3JlbWVudGFsIHN0ZXAgaXMgZ3JlYXRlciB0aGFuIGAxYCwgdGhlICoqTm93KiogYnV0dG9uIHdpbGwgYmUgaGlkZGVuLlxuICAgICAqL1xuICAgIHNldCBzdGVwcyhzdGVwcykge1xuICAgICAgICB0aGlzLl9zdGVwcyA9IHN0ZXBzIHx8IHt9O1xuICAgIH1cbiAgICBnZXQgc3RlcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGVwcztcbiAgICB9XG4gICAgc2V0IGN1cnJlbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRpbWVJblJhbmdlKHRoaXMuc25hcFRpbWUoY2xvbmVEYXRlKHZhbHVlIHx8IE1JRE5JR0hUX0RBVEUpLCB0aGlzLm1pbiksIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIGlmICghTmdab25lLmlzSW5Bbmd1bGFyWm9uZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICAgIH1cbiAgICBnZXQgYWN0aXZlTGlzdEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlTGlzdEluZGV4O1xuICAgIH1cbiAgICBzZXQgYWN0aXZlTGlzdEluZGV4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUxpc3RJbmRleCA9IHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMudGltZUxpc3RXcmFwcGVycyB8fCAhdGhpcy50aW1lTGlzdFdyYXBwZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZUxpc3RXcmFwcGVycy5mb3JFYWNoKGxpc3RXcmFwcGVyID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MobGlzdFdyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2stc3RhdGUtZm9jdXNlZCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RJbmRleCA9IHRoaXMubGlzdEluZGV4KHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRXcmFwcGVyID0gdGhpcy50aW1lTGlzdFdyYXBwZXJzLnRvQXJyYXkoKVtsaXN0SW5kZXhdO1xuICAgICAgICAgICAgaWYgKGZvY3VzZWRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhmb2N1c2VkV3JhcHBlci5uYXRpdmVFbGVtZW50LCAnay1zdGF0ZS1mb2N1c2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSB0aGlzLmludGwuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5pbnRsQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5sb2NhbGl6YXRpb25cbiAgICAgICAgICAgICAgICAuY2hhbmdlc1xuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jZHIubWFya0ZvckNoZWNrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnay10aW1lc2VsZWN0b3InKTtcbiAgICAgICAgdGhpcy5kb20uY2FsY3VsYXRlSGVpZ2h0cyh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKF8pIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5waWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2UudGltZVNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbUV2ZW50cy5mb3JFYWNoKHVuYmluZENhbGxiYWNrID0+IHVuYmluZENhbGxiYWNrKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBUaW1lU2VsZWN0b3IgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogdGVtcGxhdGU6IGBcbiAgICAgKiAgPGJ1dHRvbiAoY2xpY2spPVwidGltZXNlbGVjdG9yLmZvY3VzKClcIj5Gb2N1cyB0aW1lIHBpY2tlcjwvYnV0dG9uPlxuICAgICAqICA8a2VuZG8tdGltZXNlbGVjdG9yICN0aW1lc2VsZWN0b3I+PC9rZW5kby10aW1lc2VsZWN0b3I+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMudGltZUxpc3RzLmZpcnN0O1xuICAgICAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsaXN0LmZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBUaW1lU2VsZWN0b3IgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLnRpbWVMaXN0cy5maXJzdDtcbiAgICAgICAgaWYgKCFsaXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5ibHVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVBY2NlcHQoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlKHRoaXMubWVyZ2VWYWx1ZShjbG9uZURhdGUodGhpcy52YWx1ZSB8fCBnZXREYXRlKGdldE5vdygpKSksIHRoaXMuY3VycmVudCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlTm93KCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBnZXROb3coKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UodGhpcy5jdXJyZW50KTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVSZWplY3QoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMudmFsdWVSZWplY3QuZW1pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlRm9jdXMoYXJncykge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXRGb2N1cyhhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUxpc3RGb2N1cyhhcmdzKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoYXJncy50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRpbWVsaXN0LWluZGV4JyksIDEwKTtcbiAgICAgICAgdGhpcy5hY3RpdmVMaXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1cyhhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUJsdXIoYXJncykge1xuICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gY3VycmVudEZvY3VzVGFyZ2V0KGFyZ3MpO1xuICAgICAgICBpZiAoY3VycmVudFRhcmdldCAmJiB0aGlzLmNvbnRhaW5zRWxlbWVudChjdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlTGlzdEluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0Qmx1cihhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnRhaW5zRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGNsb3Nlc3QoZWxlbWVudCwgbm9kZSA9PiBub2RlID09PSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkpO1xuICAgIH1cbiAgICBwYXJ0U3RlcChwYXJ0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzW3BhcnQudHlwZV0gfHwgMTtcbiAgICB9XG4gICAgaW5pdChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghY2hhbmdlcyB8fCBoYXNDaGFuZ2UoY2hhbmdlcywgJ2Zvcm1hdCcpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGVGb3JtYXRQYXJ0cyA9IHRoaXMuaW50bC5zcGxpdERhdGVGb3JtYXQodGhpcy5mb3JtYXQpO1xuICAgICAgICAgICAgdGhpcy5tZXJnZVZhbHVlID0gdmFsdWVNZXJnZXIoZ2VuZXJhdGVHZXR0ZXJzKHRoaXMuZGF0ZUZvcm1hdFBhcnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGFuZ2VzIHx8IGhhc0NoYW5nZShjaGFuZ2VzLCAnc3RlcHMnKSkge1xuICAgICAgICAgICAgdGhpcy5zbmFwVGltZSA9IHNuYXBUaW1lKGdlbmVyYXRlU25hcHBlcnModGhpcy5zdGVwcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hhbmdlcyB8fCBoYXNDaGFuZ2UoY2hhbmdlcywgJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaG93Tm93QnV0dG9uID0gIXRoaXMuaGFzU3RlcHMoKSAmJiB0aGlzLm5vd0J1dHRvbiAmJiBpc0luVGltZVJhbmdlKGdldE5vdygpLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgIH1cbiAgICBmb2N1c0xpc3QoZGlyKSB7XG4gICAgICAgIGlmICghdGhpcy50aW1lTGlzdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lTGlzdHMucmVkdWNlKGxpc3RSZWR1Y2VyLCBbXSlcbiAgICAgICAgICAgIC5tYXAoc3RhdGUgPT4gZGlyID09PSBEaXJlY3Rpb24uUmlnaHQgPyBzdGF0ZS5uZXh0IDogc3RhdGUucHJldilcbiAgICAgICAgICAgIC5tYXAobGlzdCA9PiBsaXN0ICYmIGxpc3QuZm9jdXMoKSk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdChjbG9uZURhdGUodmFsdWUpKTtcbiAgICB9XG4gICAgaGFzQWN0aXZlQnV0dG9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWNjZXB0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0aGlzLmFjY2VwdCwgdGhpcy5jYW5jZWwsIHRoaXMubm93XS5yZWR1Y2UoKGlzQWN0aXZlLCBlbCkgPT4gaXNBY3RpdmUgfHwgdGhpcy5kb20uaXNBY3RpdmUoZWwpLCBmYWxzZSk7XG4gICAgfVxuICAgIGhhc1N0ZXBzKCkge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zdGVwcyk7XG4gICAgICAgIHJldHVybiBrZXlzLmxlbmd0aCAhPT0ga2V5cy5yZWR1Y2UoKGFjYywgaykgPT4gYWNjICsgdGhpcy5zdGVwc1trXSwgMCk7XG4gICAgfVxuICAgIGludGxDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuZGF0ZUZvcm1hdFBhcnRzID0gdGhpcy5pbnRsLnNwbGl0RGF0ZUZvcm1hdCh0aGlzLmZvcm1hdCk7XG4gICAgICAgIHRoaXMubWVyZ2VWYWx1ZSA9IHZhbHVlTWVyZ2VyKGdlbmVyYXRlR2V0dGVycyh0aGlzLmRhdGVGb3JtYXRQYXJ0cykpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgYmluZEV2ZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUV2ZW50cy5wdXNoKHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVLZXlkb3duKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBrZXlDb2RlLCBhbHRLZXkgfSA9IGFyZ3M7XG4gICAgICAgIC8vIHJlc2VydmUgdGhlIGFsdCArIGFycm93IGtleSBjb21tYW5kcyBmb3IgdGhlIHBpY2tlclxuICAgICAgICBjb25zdCBhcnJvd0tleVByZXNzZWQgPSBbS2V5cy5BcnJvd0xlZnQsIEtleXMuQXJyb3dSaWdodF0uaW5kZXhPZihrZXlDb2RlKSAhPT0gLTE7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5waWNrZXJTZXJ2aWNlKSAmJiBhcnJvd0tleVByZXNzZWQgJiYgYWx0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRW50ZXIgJiYgIXRoaXMuaGFzQWN0aXZlQnV0dG9uKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQWNjZXB0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5Q29kZSA9PT0gS2V5cy5BcnJvd0xlZnQgfHwga2V5Q29kZSA9PT0gS2V5cy5BcnJvd1JpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzTGlzdChrZXlDb2RlID09PSBLZXlzLkFycm93TGVmdCA/IERpcmVjdGlvbi5MZWZ0IDogRGlyZWN0aW9uLlJpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0Qmx1cihhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLnBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyU2VydmljZS5vbkJsdXIuZW1pdChhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0Rm9jdXMoYXJncykge1xuICAgICAgICBpZiAodGhpcy5waWNrZXJTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tlclNlcnZpY2Uub25Gb2N1cy5lbWl0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpc3RJbmRleChwYXJ0SW5kZXgpIHtcbiAgICAgICAgbGV0IGxpc3RJZHggPSAwO1xuICAgICAgICBsZXQgcGFydElkeCA9IDA7XG4gICAgICAgIHdoaWxlIChwYXJ0SWR4IDwgcGFydEluZGV4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRlRm9ybWF0UGFydHNbcGFydElkeF0udHlwZSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgbGlzdElkeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFydElkeCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0SWR4O1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2FjY2VwdCcsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWNjZXB0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2NhbmNlbCcsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2FuY2VsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ25vdycsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwibm93XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGRyZW4oVGltZUxpc3RDb21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQucHJvdG90eXBlLCBcInRpbWVMaXN0c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkcmVuKCdsaXN0V3JhcHBlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQucHJvdG90eXBlLCBcInRpbWVMaXN0V3JhcHBlcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgVGltZVNlbGVjdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2FuY2VsQnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGltZVNlbGVjdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXRCdXR0b25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQucHJvdG90eXBlLCBcIm5vd0J1dHRvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgVGltZVNlbGVjdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVGltZVNlbGVjdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRpbWVTZWxlY3RvckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVSZWplY3RcIiwgdm9pZCAwKTtcblRpbWVTZWxlY3RvckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvLXRpbWVzZWxlY3RvcicsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLnRpbWVzZWxlY3RvcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10aW1lc2VsZWN0b3InLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvVGltZVNlbGVjdG9yTG9jYWxpemVkTWVzc2FnZXNcbiAgICAgICAgICAgIGkxOG4tYWNjZXB0PVwia2VuZG8udGltZXNlbGVjdG9yLmFjY2VwdHxUaGUgQWNjZXB0IGJ1dHRvbiB0ZXh0IGluIHRoZSB0aW1lc2VsZWN0b3IgY29tcG9uZW50XCJcbiAgICAgICAgICAgIGFjY2VwdD1cIlNldFwiXG5cbiAgICAgICAgICAgIGkxOG4tYWNjZXB0TGFiZWw9XCJrZW5kby50aW1lc2VsZWN0b3IuYWNjZXB0TGFiZWx8VGhlIGxhYmVsIGZvciB0aGUgQWNjZXB0IGJ1dHRvbiBpbiB0aGUgdGltZXNlbGVjdG9yIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBhY2NlcHRMYWJlbD1cIlNldCB0aW1lXCJcblxuICAgICAgICAgICAgaTE4bi1jYW5jZWw9XCJrZW5kby50aW1lc2VsZWN0b3IuY2FuY2VsfFRoZSBDYW5jZWwgYnV0dG9uIHRleHQgaW4gdGhlIHRpbWVzZWxlY3RvciBjb21wb25lbnRcIlxuICAgICAgICAgICAgY2FuY2VsPVwiQ2FuY2VsXCJcblxuICAgICAgICAgICAgaTE4bi1jYW5jZWxMYWJlbD1cImtlbmRvLnRpbWVzZWxlY3Rvci5jYW5jZWxMYWJlbHxUaGUgbGFiZWwgZm9yIHRoZSBDYW5jZWwgYnV0dG9uIGluIHRoZSB0aW1lc2VsZWN0b3IgY29tcG9uZW50XCJcbiAgICAgICAgICAgIGNhbmNlbExhYmVsPVwiQ2FuY2VsIGNoYW5nZXNcIlxuXG4gICAgICAgICAgICBpMThuLW5vdz1cImtlbmRvLnRpbWVzZWxlY3Rvci5ub3d8VGhlIE5vdyBidXR0b24gdGV4dCBpbiB0aGUgdGltZXNlbGVjdG9yIGNvbXBvbmVudFwiXG4gICAgICAgICAgICBub3c9XCJOb3dcIlxuXG4gICAgICAgICAgICBpMThuLW5vd0xhYmVsPVwia2VuZG8udGltZXNlbGVjdG9yLm5vd0xhYmVsfFRoZSBsYWJlbCBmb3IgdGhlIE5vdyBidXR0b24gaW4gdGhlIHRpbWVzZWxlY3RvciBjb21wb25lbnRcIlxuICAgICAgICAgICAgbm93TGFiZWw9XCJTZWxlY3Qgbm93XCJcbiAgICAgICAgPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImstdGltZS1oZWFkZXJcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay10aXRsZSBrLXRpbWVzZWxlY3Rvci10aXRsZVwiPlxuICAgICAgICAgICAgICAgIHt7IGludGwuZm9ybWF0RGF0ZShjdXJyZW50LCBmb3JtYXQpIH19XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgI25vd1xuICAgICAgICAgICAgICAgICpuZ0lmPVwic2hvd05vd0J1dHRvblwiXG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvbiBrLWJ1dHRvbi1tZCBrLXJvdW5kZWQtbWQgay1idXR0b24tZmxhdCBrLWJ1dHRvbi1mbGF0LWJhc2Ugay10aW1lLW5vd1wiXG4gICAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwibG9jYWxpemF0aW9uLmdldCgnbm93TGFiZWwnKVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJsb2NhbGl6YXRpb24uZ2V0KCdub3dMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBoYW5kbGVOb3csXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzOiBoYW5kbGVGb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgYmx1cjogaGFuZGxlQmx1clxuICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgIFtzY29wZV09XCJ0aGlzXCJcbiAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgPnt7bG9jYWxpemF0aW9uLmdldCgnbm93Jyl9fTwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImstdGltZS1saXN0LWNvbnRhaW5lclwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLXRpbWUtaGlnaGxpZ2h0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIFtuZ0Zvck9mXT1cImRhdGVGb3JtYXRQYXJ0c1wiIGxldC1wYXJ0IGxldC1pZHg9XCJpbmRleFwiPlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgI2xpc3RXcmFwcGVyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay10aW1lLWxpc3Qtd3JhcHBlclwiXG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIiB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJwYXJ0LnR5cGUgIT09ICdsaXRlcmFsJ1wiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstdGl0bGUgay10aW1lc2VsZWN0b3ItdGl0bGVcIj57e2ludGwuZGF0ZUZpZWxkTmFtZShwYXJ0KX19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8a2VuZG8tdGltZWxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJ0XT1cInBhcnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW3N0ZXBdPVwicGFydFN0ZXAocGFydClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFsodmFsdWUpXT1cImN1cnJlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiBoYW5kbGVMaXN0Rm9jdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmx1cjogaGFuZGxlQmx1clxuICAgICAgICAgICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLXRpbWVsaXN0LWluZGV4XT1cImlkeFwiXG4gICAgICAgICAgICAgICAgICAgID48L2tlbmRvLXRpbWVsaXN0PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJrLXRpbWUtc2VwYXJhdG9yXCIgKm5nSWY9XCJwYXJ0LnR5cGUgPT09ICdsaXRlcmFsJ1wiPlxuICAgICAgICAgICAgICAgICAgICB7e3BhcnQucGF0dGVybn19XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImstdGltZS1mb290ZXIgay1hY3Rpb24tYnV0dG9ucyBrLWFjdGlvbnMgay1oc3RhY2sgay1qdXN0aWZ5LWNvbnRlbnQtc3RyZXRjaFwiICpuZ0lmPVwic2V0QnV0dG9uIHx8IGNhbmNlbEJ1dHRvblwiPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICNjYW5jZWxcbiAgICAgICAgICAgICAgICAqbmdJZj1cImNhbmNlbEJ1dHRvblwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvbiBrLXRpbWUtY2FuY2VsIGstYnV0dG9uLW1kIGstcm91bmRlZC1tZCBrLWJ1dHRvbi1zb2xpZCBrLWJ1dHRvbi1zb2xpZC1iYXNlXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCdjYW5jZWxMYWJlbCcpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImxvY2FsaXphdGlvbi5nZXQoJ2NhbmNlbExhYmVsJylcIlxuICAgICAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cIntcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGhhbmRsZVJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBibHVyOiBoYW5kbGVCbHVyXG4gICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgW3Njb3BlXT1cInRoaXNcIlxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICA+e3tsb2NhbGl6YXRpb24uZ2V0KCdjYW5jZWwnKX19PC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgI2FjY2VwdFxuICAgICAgICAgICAgICAgICpuZ0lmPVwic2V0QnV0dG9uXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uIGstdGltZS1hY2NlcHQgay1idXR0b24tbWQgay1yb3VuZGVkLW1kIGstYnV0dG9uLXNvbGlkIGstYnV0dG9uLXNvbGlkLXByaW1hcnlcIlxuICAgICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImxvY2FsaXphdGlvbi5nZXQoJ2FjY2VwdExhYmVsJylcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwibG9jYWxpemF0aW9uLmdldCgnYWNjZXB0TGFiZWwnKVwiXG4gICAgICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwie1xuICAgICAgICAgICAgICAgICAgICBjbGljazogaGFuZGxlQWNjZXB0LFxuICAgICAgICAgICAgICAgICAgICBmb2N1czogaGFuZGxlRm9jdXMsXG4gICAgICAgICAgICAgICAgICAgIGJsdXI6IGhhbmRsZUJsdXJcbiAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICBbc2NvcGVdPVwidGhpc1wiXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgID57e2xvY2FsaXphdGlvbi5nZXQoJ2FjY2VwdCcpfX08L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oNywgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgSW50bFNlcnZpY2UsXG4gICAgICAgIFRpbWVQaWNrZXJET01TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgUGlja2VyU2VydmljZV0pXG5dLCBUaW1lU2VsZWN0b3JDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVGltZVBpY2tlck1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGltZVBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJhY2NlcHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpbWVQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiYWNjZXB0TGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpbWVQaWNrZXJNZXNzYWdlcy5wcm90b3R5cGUsIFwiY2FuY2VsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaW1lUGlja2VyTWVzc2FnZXMucHJvdG90eXBlLCBcImNhbmNlbExhYmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaW1lUGlja2VyTWVzc2FnZXMucHJvdG90eXBlLCBcIm5vd1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGltZVBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJub3dMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGltZVBpY2tlck1lc3NhZ2VzLnByb3RvdHlwZSwgXCJ0b2dnbGVcIiwgdm9pZCAwKTtcblxudmFyIFRpbWVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBUaW1lUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgPSBUaW1lUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IGNsYXNzIFRpbWVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSBleHRlbmRzIFRpbWVQaWNrZXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn07XG5UaW1lUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgPSBUaW1lUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRpbWVQaWNrZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUaW1lUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RpbWVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc10nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFRpbWVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSk7XG5cbnZhciBUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMTtcbi8qKlxuICogQ3VzdG9tIGNvbXBvbmVudCBtZXNzYWdlcyBvdmVycmlkZSBkZWZhdWx0IGNvbXBvbmVudCBtZXNzYWdlcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGdsb2JhbGl6YXRpb25fZGF0ZWlucHV0cyAlfSN0b2MtY3VzdG9tLW1lc3NhZ2VzKSkuXG4gKi9cbmxldCBUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IGNsYXNzIFRpbWVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIFRpbWVQaWNrZXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5UaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgPSBUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRpbWVQaWNrZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRpbWVwaWNrZXItbWVzc2FnZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KTtcblxudmFyIFRpbWVTZWxlY3RvckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlXzE7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFRpbWVTZWxlY3RvckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlID0gVGltZVNlbGVjdG9yTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IGNsYXNzIFRpbWVTZWxlY3RvckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlIGV4dGVuZHMgVGltZVBpY2tlck1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxufTtcblRpbWVTZWxlY3RvckxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlID0gVGltZVNlbGVjdG9yTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRpbWVQaWNrZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUaW1lU2VsZWN0b3JMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVGltZVNlbGVjdG9yTG9jYWxpemVkTWVzc2FnZXNdJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBUaW1lU2VsZWN0b3JMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSk7XG5cbnZhciBUaW1lU2VsZWN0b3JDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogQ3VzdG9tIGNvbXBvbmVudCBtZXNzYWdlcyBvdmVycmlkZSBkZWZhdWx0IGNvbXBvbmVudCBtZXNzYWdlcy5cbiAqL1xubGV0IFRpbWVTZWxlY3RvckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gVGltZVNlbGVjdG9yQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IGNsYXNzIFRpbWVTZWxlY3RvckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50IGV4dGVuZHMgVGltZVBpY2tlck1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblRpbWVTZWxlY3RvckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gVGltZVNlbGVjdG9yQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRpbWVQaWNrZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUaW1lU2VsZWN0b3JDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdGltZXNlbGVjdG9yLW1lc3NhZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIFRpbWVTZWxlY3RvckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KTtcblxuY29uc3QgQ09NUE9ORU5UX0RJUkVDVElWRVMkMiA9IFtcbiAgICBUaW1lUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUsXG4gICAgVGltZUxpc3RDb21wb25lbnQsXG4gICAgVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgIFRpbWVQaWNrZXJDb21wb25lbnQsXG4gICAgVGltZVNlbGVjdG9yTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUsXG4gICAgVGltZVNlbGVjdG9yQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgVGltZVNlbGVjdG9yQ29tcG9uZW50XG5dO1xuY29uc3QgQ09NUE9ORU5UX01PRFVMRVMkMSA9IFtcbiAgICBEYXRlSW5wdXRNb2R1bGUsXG4gICAgSW50bE1vZHVsZSxcbiAgICBQb3B1cE1vZHVsZSxcbiAgICBWaXJ0dWFsaXphdGlvbk1vZHVsZSxcbiAgICBFdmVudHNNb2R1bGVcbl07XG5jb25zdCDJtTAkbyA9IHRvdWNoRW5hYmxlZDtcbmNvbnN0IHByb3ZpZGVycyA9IFtcbiAgICBUaW1lUGlja2VyRE9NU2VydmljZSxcbiAgICBIb3Vyc1NlcnZpY2UsXG4gICAgTWludXRlc1NlcnZpY2UsXG4gICAgU2Vjb25kc1NlcnZpY2UsXG4gICAgTWlsbGlzZWNvbmRzU2VydmljZSxcbiAgICBEYXlQZXJpb2RTZXJ2aWNlLFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogVE9VQ0hfRU5BQkxFRCxcbiAgICAgICAgdXNlVmFsdWU6IMm1MCRvXG4gICAgfVxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIFRpbWVQaWNrZXIgY29tcG9uZW50LlxuICovXG5sZXQgVGltZVBpY2tlck1vZHVsZSA9IGNsYXNzIFRpbWVQaWNrZXJNb2R1bGUge1xufTtcblRpbWVQaWNrZXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTJDJdLFxuICAgICAgICBleHBvcnRzOiBbQ09NUE9ORU5UX0RJUkVDVElWRVMkMl0sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIC4uLkNPTVBPTkVOVF9NT0RVTEVTJDFdLFxuICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVyc1xuICAgIH0pXG5dLCBUaW1lUGlja2VyTW9kdWxlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE1lc3NhZ2VzJDEgZXh0ZW5kcyBDb21wb25lbnRNZXNzYWdlcyB7XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcyQxLnByb3RvdHlwZSwgXCJ0b2dnbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzJDEucHJvdG90eXBlLCBcImRhdGVUYWJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzJDEucHJvdG90eXBlLCBcImRhdGVUYWJMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMkMS5wcm90b3R5cGUsIFwidGltZVRhYlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMkMS5wcm90b3R5cGUsIFwidGltZVRhYkxhYmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcyQxLnByb3RvdHlwZSwgXCJhY2NlcHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzJDEucHJvdG90eXBlLCBcImFjY2VwdExhYmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcyQxLnByb3RvdHlwZSwgXCJjYW5jZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lc3NhZ2VzJDEucHJvdG90eXBlLCBcImNhbmNlbExhYmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcyQxLnByb3RvdHlwZSwgXCJ0b2RheVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMkMS5wcm90b3R5cGUsIFwibm93XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcyQxLnByb3RvdHlwZSwgXCJub3dMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVzc2FnZXMkMS5wcm90b3R5cGUsIFwicHJldkJ1dHRvblRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNZXNzYWdlcyQxLnByb3RvdHlwZSwgXCJuZXh0QnV0dG9uVGl0bGVcIiwgdm9pZCAwKTtcblxudmFyIERhdGVUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMTtcbi8qKlxuICogQ3VzdG9tIGNvbXBvbmVudCBtZXNzYWdlcyBvdmVycmlkZSBkZWZhdWx0IGNvbXBvbmVudCBtZXNzYWdlcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGdsb2JhbGl6YXRpb25fZGF0ZWlucHV0cyAlfSN0b2MtY3VzdG9tLW1lc3NhZ2VzKSkuXG4gKi9cbmxldCBEYXRlVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50ID0gRGF0ZVRpbWVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xID0gY2xhc3MgRGF0ZVRpbWVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIE1lc3NhZ2VzJDEge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuRGF0ZVRpbWVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCA9IERhdGVUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1lc3NhZ2VzJDEsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZVRpbWVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudF8xKVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWRhdGV0aW1lcGlja2VyLW1lc3NhZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIERhdGVUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQpO1xuXG52YXIgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgPSBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZV8xID0gY2xhc3MgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBNZXNzYWdlcyQxIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxufTtcbkxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlID0gTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1lc3NhZ2VzJDEsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVfMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9EYXRlVGltZVBpY2tlckxvY2FsaXplZE1lc3NhZ2VzXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0xvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUpO1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyQzID0gW1xuICAgIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LFxuICAgIERhdGVUaW1lUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVcbl07XG5jb25zdCDJtTAkcCA9IHRvdWNoRW5hYmxlZDtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIERhdGVUaW1lUGlja2VyIGNvbXBvbmVudC5cbiAqL1xubGV0IERhdGVUaW1lUGlja2VyTW9kdWxlID0gY2xhc3MgRGF0ZVRpbWVQaWNrZXJNb2R1bGUge1xufTtcbkRhdGVUaW1lUGlja2VyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIC4uLkNPTVBPTkVOVF9ESVJFQ1RJVkVTJDNcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgLi4uQ09NUE9ORU5UX0RJUkVDVElWRVMkMyxcbiAgICAgICAgICAgIFRlbXBsYXRlc01vZHVsZVxuICAgICAgICBdLFxuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICBJbnRsTW9kdWxlLFxuICAgICAgICAgICAgRGF0ZUlucHV0TW9kdWxlLFxuICAgICAgICAgICAgQ2FsZW5kYXJNb2R1bGUsXG4gICAgICAgICAgICBUaW1lUGlja2VyTW9kdWxlLFxuICAgICAgICAgICAgUG9wdXBNb2R1bGUsXG4gICAgICAgICAgICBFdmVudHNNb2R1bGUsXG4gICAgICAgICAgICBUZW1wbGF0ZXNNb2R1bGVcbiAgICAgICAgXSxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7IHByb3ZpZGU6IFRPVUNIX0VOQUJMRUQsIHVzZVZhbHVlOiDJtTAkcCB9XG4gICAgICAgIF1cbiAgICB9KVxuXSwgRGF0ZVRpbWVQaWNrZXJNb2R1bGUpO1xuXG5jb25zdCBDT01QT05FTlRfTU9EVUxFUyQyID0gW1xuICAgIENhbGVuZGFyc01vZHVsZSxcbiAgICBEYXRlSW5wdXRNb2R1bGUsXG4gICAgRGF0ZVBpY2tlck1vZHVsZSxcbiAgICBUaW1lUGlja2VyTW9kdWxlLFxuICAgIERhdGVSYW5nZU1vZHVsZSxcbiAgICBEYXRlVGltZVBpY2tlck1vZHVsZVxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIERhdGUgSW5wdXRzIGNvbXBvbmVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgRGF0ZSBJbnB1dHMgbW9kdWxlXG4gKiBpbXBvcnQgeyBEYXRlSW5wdXRzTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZGF0ZWlucHV0cyc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgdGhlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBEYXRlSW5wdXRzTW9kdWxlXSwgLy8gaW1wb3J0IHRoZSBEYXRlIElucHV0cyBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBEYXRlSW5wdXRzTW9kdWxlID0gY2xhc3MgRGF0ZUlucHV0c01vZHVsZSB7XG59O1xuRGF0ZUlucHV0c01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZXhwb3J0czogQ09NUE9ORU5UX01PRFVMRVMkMixcbiAgICAgICAgaW1wb3J0czogQ09NUE9ORU5UX01PRFVMRVMkMlxuICAgIH0pXG5dLCBEYXRlSW5wdXRzTW9kdWxlKTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBDYWxlbmRhckNvbW1vbk1vZHVsZSwgQ0FMRU5EQVJfUkFOR0VfVkFMSURBVE9SUywgQ0FMRU5EQVJfVkFMVUVfQUNDRVNTT1IsIEtFTkRPX0lOUFVUX1BST1ZJREVSLCBLRm9yT2YsIEtGb3JPZkNvbnRleHQsIEhlYWRlckNvbXBvbmVudCwgSG9yaXpvbnRhbFZpZXdMaXN0Q29tcG9uZW50LCBDYWxlbmRhck1lc3NhZ2VzLCBNdWx0aVZpZXdDYWxlbmRhckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LCBNZXNzYWdlcywgUkFOR0VfQ0FMRU5EQVJfUkFOR0VfVkFMSURBVE9SUywgUkFOR0VfQ0FMRU5EQVJfVkFMVUVfQUNDRVNTT1IsIE5hdmlnYXRpb25Db21wb25lbnQsIEJ1c1ZpZXdTZXJ2aWNlLCBDZW50dXJ5Vmlld1NlcnZpY2UsIERlY2FkZVZpZXdTZXJ2aWNlLCBEaXNhYmxlZERhdGVzU2VydmljZSwgQ2FsZW5kYXJET01TZXJ2aWNlLCBNb250aFZpZXdTZXJ2aWNlLCBOYXZpZ2F0aW9uU2VydmljZSwgU2Nyb2xsU3luY1NlcnZpY2UsIFNlbGVjdGlvblNlcnZpY2UsIFdlZWtOYW1lc1NlcnZpY2UsIFllYXJWaWV3U2VydmljZSwgVGVtcGxhdGVzTW9kdWxlLCBDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIENlbnR1cnlDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIERlY2FkZUNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgSGVhZGVyVGl0bGVUZW1wbGF0ZURpcmVjdGl2ZSwgTW9udGhDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIE5hdmlnYXRpb25JdGVtVGVtcGxhdGVEaXJlY3RpdmUsIFdlZWtOdW1iZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIFllYXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIFZpZXdMaXN0Q29tcG9uZW50LCBWaWV3Q29tcG9uZW50LCBQaWNrZXJTZXJ2aWNlLCBEYXRlSW5wdXRNZXNzYWdlcywgRGF0ZVBpY2tlck1lc3NhZ2VzLCBEYXRlUmFuZ2VJbnB1dCwgRGF0ZVJhbmdlUG9wdXBUZW1wbGF0ZURpcmVjdGl2ZSwgRGF0ZVRpbWVQaWNrZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCwgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUsIE1lc3NhZ2VzJDEsIFRpbWVQaWNrZXJNZXNzYWdlcywgVGltZVBpY2tlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LCBUaW1lU2VsZWN0b3JDdXN0b21NZXNzYWdlc0NvbXBvbmVudCwgRGF5UGVyaW9kU2VydmljZSwgVGltZVBpY2tlckRPTVNlcnZpY2UsIEhvdXJzU2VydmljZSwgTWlsbGlzZWNvbmRzU2VydmljZSwgTWludXRlc1NlcnZpY2UsIFNlY29uZHNTZXJ2aWNlLCBUaW1lTGlzdENvbXBvbmVudCwgVGltZVNlbGVjdG9yQ29tcG9uZW50LCBUT1VDSF9FTkFCTEVELCBTY3JvbGxlclNlcnZpY2UsIERFRkFVTFRfU0NST0xMRVJfRkFDVE9SWSwgU0NST0xMRVJfRkFDVE9SWV9UT0tFTiwgVmlydHVhbGl6YXRpb25Db21wb25lbnQsIFZpcnR1YWxpemF0aW9uTW9kdWxlLCBDYWxlbmRhckNvbXBvbmVudCwgRGF0ZUlucHV0Q29tcG9uZW50LCBEYXRlUGlja2VyQ29tcG9uZW50LCBUaW1lUGlja2VyQ29tcG9uZW50LCBEYXRlVGltZVBpY2tlckNvbXBvbmVudCwgTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQsIERhdGVSYW5nZUNvbXBvbmVudCwgRGF0ZVJhbmdlUG9wdXBDb21wb25lbnQsIERhdGVSYW5nZUVuZElucHV0RGlyZWN0aXZlLCBEYXRlUmFuZ2VTdGFydElucHV0RGlyZWN0aXZlLCBEYXRlUmFuZ2VTZWxlY3Rpb25EaXJlY3RpdmUsIENhbGVuZGFyTW9kdWxlLCBDYWxlbmRhcnNNb2R1bGUsIERhdGVJbnB1dE1vZHVsZSwgRGF0ZVBpY2tlck1vZHVsZSwgRGF0ZUlucHV0c01vZHVsZSwgVGltZVBpY2tlck1vZHVsZSwgRGF0ZVRpbWVQaWNrZXJNb2R1bGUsIE11bHRpVmlld0NhbGVuZGFyTW9kdWxlLCBEYXRlUmFuZ2VNb2R1bGUsIERhdGVSYW5nZVNlcnZpY2UsIENhbGVuZGFyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsIERhdGVJbnB1dEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LCBEYXRlUGlja2VyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsIFByZXZlbnRhYmxlRXZlbnQsIENhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUsIE11bHRpVmlld0NhbGVuZGFyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUsIERhdGVJbnB1dExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLCBEYXRlUGlja2VyTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUsIFRpbWVQaWNrZXJMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSwgVGltZVNlbGVjdG9yTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgfTtcbiJdfQ==