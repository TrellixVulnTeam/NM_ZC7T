/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';
import { Keys } from '@progress/kendo-angular-common';
import { closestWithMatch, fitIntoRange, getListItemIndex, isListViewItem, isPresent, relatedTarget } from '../utils';
/**
 * @hidden
 *
 * Provided per ListView instance. Keeps the availability, active index and focused state of the current ListView.
 * Emits `changes` when any of the aforementioned states changes.
 */
var NavigationService = /** @class */ (function () {
    function NavigationService() {
        /**
         * Emits every time a change in active index/focus/blur/navigation availability occurs.
         */
        this.changes = new Subject();
        /**
         * Specifies if a ListView item currently holds focus.
         */
        this.isFocused = false;
        /**
         * Keeps track of the index of the items that should be the current focus target (tabindex="0").
         * When set to `null`/`undefined`, the navigation is disabled and the items should not render a tabindex.
         */
        this.activeIndex = null;
    }
    Object.defineProperty(NavigationService.prototype, "isEnabled", {
        /**
         * Sets or gets if the navigation is enabled.
         * When no activeIndex is present, the navigation is inferred as disabled.
         * Toggling the service availability clears the current active index or activates the first one.
         */
        get: function () {
            return isPresent(this.activeIndex);
        },
        set: function (enabled) {
            if (enabled) {
                this.activeIndex = 0;
            }
            else {
                this.activeIndex = null;
            }
            this.changes.next();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows if the checked index should be the current available focus target (tabindex="0").
     */
    NavigationService.prototype.isActive = function (index) {
        return index === this.activeIndex;
    };
    NavigationService.prototype.handleKeyDown = function (event, totalItemsCount) {
        var keyCode = event.keyCode;
        switch (keyCode) {
            case Keys.ArrowLeft:
            case Keys.ArrowUp:
                this.navigateToPrevious();
                break;
            case Keys.ArrowRight:
            case Keys.ArrowDown:
                this.navigateToNext(totalItemsCount);
                break;
            case Keys.Home:
                var firstIndex = 0;
                this.navigateTo(firstIndex);
                break;
            case Keys.End:
                var lastIndex = totalItemsCount - 1;
                this.navigateTo(lastIndex);
                break;
            default: return;
        }
        // the following line is executed only if the pressed key matches one of the listview hotkeys -
        // they `break`, while the `default` case `return`s
        event.preventDefault();
    };
    NavigationService.prototype.handleFocusIn = function (event) {
        var target = event.target;
        if (!isListViewItem(target)) {
            var listViewItemSelector = '.k-listview-item';
            var closestListViewItem = closestWithMatch(target, listViewItemSelector);
            var isListViewItemChild = isPresent(closestListViewItem);
            if (isListViewItemChild) {
                var itemIndex = getListItemIndex(closestListViewItem);
                this.setActiveIndex(itemIndex);
            }
            return;
        }
        var targetIndex = getListItemIndex(target);
        // don't emit if the no change in focused state has occurred and the targeted index is the same as the current activeIndex
        if (this.isFocused && targetIndex === this.activeIndex) {
            return;
        }
        this.activeIndex = targetIndex;
        this.isFocused = true;
        this.changes.next();
    };
    NavigationService.prototype.handleFocusOut = function (event) {
        // don't emit if the blurred item is not a listview item or if the new focus target is another listview item
        if (!isListViewItem(event.target) || isListViewItem(relatedTarget(event))) {
            return;
        }
        this.isFocused = false;
        this.changes.next();
    };
    /**
     * Sets the `activeIndex` and triggers changes without focusing the corresponding ListView item.
     */
    NavigationService.prototype.setActiveIndex = function (index) {
        if (!this.isEnabled) {
            return;
        }
        if (index === this.activeIndex) {
            return;
        }
        this.activeIndex = index;
        this.changes.next();
    };
    /**
     * Focuses item at the targeted index. If no index is passed, the current `activeIndex` is used.
     * The passed target index is normalized to fit the min/max available indices bounds.
     */
    NavigationService.prototype.focusIndex = function (index, totalItemsCount) {
        if (!this.isEnabled) {
            return;
        }
        var parsed = parseInt(index, 10);
        var firstIndex = 0;
        var lastIndex = totalItemsCount - 1;
        var targetIndex = isNaN(parsed) ? this.activeIndex : fitIntoRange(parsed, firstIndex, lastIndex);
        this.navigateTo(targetIndex);
    };
    NavigationService.prototype.navigateTo = function (index) {
        if (this.isFocused && this.activeIndex === index) {
            return;
        }
        this.isFocused = true;
        this.activeIndex = index;
        this.changes.next();
    };
    NavigationService.prototype.navigateToPrevious = function () {
        var previousIndex = Math.max(this.activeIndex - 1, 0);
        this.navigateTo(previousIndex);
    };
    NavigationService.prototype.navigateToNext = function (totalItemsCount) {
        var lastAvailableIndex = totalItemsCount - 1;
        var nextIndex = Math.min(this.activeIndex + 1, lastAvailableIndex);
        this.navigateTo(nextIndex);
    };
    NavigationService = tslib_1.__decorate([
        Injectable()
    ], NavigationService);
    return NavigationService;
}());
export { NavigationService };
