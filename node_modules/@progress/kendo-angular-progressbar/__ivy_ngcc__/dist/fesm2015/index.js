/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata } from 'tslib';
import { isDevMode, HostBinding, Input, EventEmitter, Output, ViewChild, ElementRef, Component, NgZone, Renderer2, NgModule } from '@angular/core';
import { validatePackage } from '@progress/kendo-licensing';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { hasObservers } from '@progress/kendo-angular-common';
import { CommonModule } from '@angular/common';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@angular/common';

const _c0 = ["progressStatus"];
const _c1 = ["progressStatusWrap"];
function ProgressBarComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.formattedLabelValue);
} }
function ProgressBarComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.formattedLabelValue);
} }
function ChunkProgressBarComponent_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "li", 2);
} if (rf & 2) {
    const chunk_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r0.orientationStyles.width)("height", ctx_r0.orientationStyles.height);
    ɵngcc0.ɵɵclassProp("k-first", i_r2 === 0)("k-last", i_r2 === ctx_r0.chunkCount - 1)("k-state-selected", chunk_r1);
    ɵngcc0.ɵɵproperty("ngClass", chunk_r1 ? ctx_r0.progressCssClass : ctx_r0.emptyCssClass)("ngStyle", chunk_r1 ? ctx_r0.progressCssStyle : ctx_r0.emptyCssStyle);
} }
const packageMetadata = {
    name: '@progress/kendo-angular-progressbar',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1646219371,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * @hidden
 */
const MIN_MAX_ERROR_MESSAGE = `The max value should be greater than the min.`;
/**
 * @hidden
 */
const LABEL_DECIMALS = 3;
/**
 * @hidden
 */
const MIN_RATIO = 0.0001;

/**
 * @hidden
 */
const reverseChunks = (orientation, reverse) => (orientation === 'vertical' && !reverse || orientation === 'horizontal' && reverse);
/**
 * @hidden
 */
const formatValue = (value, min, max, label) => {
    const defaultFormattedValue = truncateNumber(value);
    if (typeof label !== 'boolean') {
        if (typeof label.format === 'string') {
            switch (label.format) {
                case 'value':
                    return defaultFormattedValue;
                case 'percent':
                    return `${Math.floor(calculatePercentage(value, min, max))}%`;
                default:
                    return defaultFormattedValue;
            }
        }
        else if (typeof label.format === 'function') {
            return label.format(value);
        }
        else {
            return defaultFormattedValue;
        }
    }
    return defaultFormattedValue;
};
/**
 * @hidden
 */
const validateRange = (min, max) => {
    if (isDevMode && min > max) {
        throw new Error(MIN_MAX_ERROR_MESSAGE);
    }
};
/**
 * @hidden
 */
const adjustValueToRange = (min, max, value) => Math.max(Math.min(value, max), min);
/**
 * @hidden
 */
const calculatePercentage = (value, min, max) => {
    const onePercent = Math.abs((max - min) / 100);
    return Math.abs((value - min) / onePercent);
};
/**
 * @hidden
 */
const truncateNumber = (value) => {
    const numberParts = value.toString().split('.');
    return numberParts.length === 1 ? `${numberParts[0]}` : `${numberParts[0]}.${numberParts[1].substr(0, LABEL_DECIMALS)}`;
};
/**
 * @hidden
 */
const calculateRatio = (min, max, value) => Math.max((value - min) / (max - min), MIN_RATIO);
/**
 * @hidden
 */
const extractValueFromChanges = (changes, type, value) => changes[type] && changes[type].currentValue !== undefined ? changes[type].currentValue : value;
/**
 * @hidden
 */
const runAnimation = (changes, animation, previousValue, displayValue) => animation && typeof requestAnimationFrame !== 'undefined' && changes.value && previousValue !== displayValue;
/**
 * @hidden
 */
const stopCurrentAnimation = (changes) => {
    const isAnimationChanged = Boolean(changes.animation);
    const hasAnimation = isAnimationChanged && changes.animation.currentValue;
    return isAnimationChanged && !hasAnimation;
};

/**
 * @hidden
 */
class ProgressBarBase {
    /**
     * @hidden
     */
    constructor(localization) {
        this.localization = localization;
        this.widgetClasses = true;
        this.roleAttribute = 'progressbar';
        /**
         * The maximum value of the ProgressBar.
         * Defaults to `100`.
         */
        this.max = 100;
        /**
         * The minimum value of the ProgressBar.
         * Defaults to `0`.
         */
        this.min = 0;
        /**
         * The value of the ProgressBar.
         * Has to be between `min` and `max`.
         * By default, the value is equal to the `min` value.
         */
        /**
         * The value of the ProgressBar.
         * Has to be between `min` and `max`.
         * Defaults to `0`.
         */
        this.value = 0;
        /**
         * Defines the orientation of the ProgressBar
         * ([see example]({% slug progressbar_orientation %})).
         * Defaults to `horizontal`.
         */
        this.orientation = 'horizontal';
        /**
         * If set to `true`, the ProgressBar will be disabled
         * ([see example]({% slug progressbar_disabled %})).
         * It will still allow you to change its value.
         * Defaults to `false`.
         */
        this.disabled = false;
        /**
         * If set to `true`, the ProgressBar will be reversed
         * ([see example]({% slug progressbar_direction %})).
         * Defaults to `false`.
         */
        this.reverse = false;
        /**
         * Sets the `indeterminate` state of the ProgressBar.
         * Defaults to `false`.
         */
        this.indeterminate = false;
        this.displayValue = 0;
        this.previousValue = 0;
        validatePackage(packageMetadata);
        this.localizationChangeSubscription = localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    get isHorizontal() {
        return this.orientation === 'horizontal';
    }
    get isVertical() {
        return this.orientation === 'vertical';
    }
    get disabledClass() {
        return this.disabled;
    }
    get reverseClass() {
        return this.reverse;
    }
    get indeterminateClass() {
        return this.indeterminate;
    }
    get dirAttribute() {
        return this.direction;
    }
    get ariaMinAttribute() {
        return String(this.min);
    }
    get ariaMaxAttribute() {
        return String(this.max);
    }
    get ariaValueAttribute() {
        return this.indeterminate ? undefined : String(this.displayValue);
    }
    /**
     * @hidden
     */
    get isCompleted() {
        return this.value === this.max;
    }
    /**
     * @hidden
     */
    get statusWidth() {
        return this.orientation === 'horizontal' ? this._progressRatio * 100 : 100;
    }
    /**
     * @hidden
     */
    get statusHeight() {
        return this.orientation === 'vertical' ? this._progressRatio * 100 : 100;
    }
    /**
     * @hidden
     */
    get statusWrapperWidth() {
        return this.orientation === 'horizontal' ? 100 / this._progressRatio : 100;
    }
    /**
     * @hidden
     */
    get statusWrapperHeight() {
        return this.orientation === 'vertical' ? 100 / this._progressRatio : 100;
    }
    get _progressRatio() {
        return calculateRatio(this.min, this.max, this.displayValue);
    }
    ngOnChanges(changes) {
        const min = extractValueFromChanges(changes, 'min', this.min);
        const max = extractValueFromChanges(changes, 'max', this.max);
        const value = extractValueFromChanges(changes, 'value', this.value);
        if (changes.min || changes.max || changes.value) {
            if (changes.min || changes.max) {
                validateRange(min, max);
            }
            if (changes.value) {
                if (value == null || Number.isNaN(value)) {
                    this.value = min;
                }
                const previousValue = this.displayValue;
                this.displayValue = adjustValueToRange(this.min, this.max, value);
                this.previousValue = previousValue;
            }
            this.min = min;
            this.max = max;
            this.displayValue = adjustValueToRange(this.min, this.max, value);
        }
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
}
ProgressBarBase.ɵfac = function ProgressBarBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ProgressBarBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ProgressBarBase, hostVars: 19, hostBindings: function ProgressBarBase_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.roleAttribute)("dir", ctx.dirAttribute)("aria-valuemin", ctx.ariaMinAttribute)("aria-valuemax", ctx.ariaMaxAttribute)("aria-valuenow", ctx.ariaValueAttribute);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.widgetClasses)("k-progressbar", ctx.widgetClasses)("k-progressbar-horizontal", ctx.isHorizontal)("k-progressbar-vertical", ctx.isVertical)("k-state-disabled", ctx.disabledClass)("k-progressbar-reverse", ctx.reverseClass)("k-progressbar-indeterminate", ctx.indeterminateClass);
    } }, inputs: { max: "max", min: "min", value: "value", orientation: "orientation", disabled: "disabled", reverse: "reverse", indeterminate: "indeterminate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-progressbar'),
    __metadata("design:type", Boolean)
], ProgressBarBase.prototype, "widgetClasses", void 0);
__decorate([
    HostBinding('class.k-progressbar-horizontal'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ProgressBarBase.prototype, "isHorizontal", null);
__decorate([
    HostBinding('class.k-progressbar-vertical'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ProgressBarBase.prototype, "isVertical", null);
__decorate([
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ProgressBarBase.prototype, "disabledClass", null);
__decorate([
    HostBinding('class.k-progressbar-reverse'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ProgressBarBase.prototype, "reverseClass", null);
__decorate([
    HostBinding('class.k-progressbar-indeterminate'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ProgressBarBase.prototype, "indeterminateClass", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ProgressBarBase.prototype, "dirAttribute", null);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String)
], ProgressBarBase.prototype, "roleAttribute", void 0);
__decorate([
    HostBinding('attr.aria-valuemin'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ProgressBarBase.prototype, "ariaMinAttribute", null);
__decorate([
    HostBinding('attr.aria-valuemax'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ProgressBarBase.prototype, "ariaMaxAttribute", null);
__decorate([
    HostBinding('attr.aria-valuenow'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ProgressBarBase.prototype, "ariaValueAttribute", null);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ProgressBarBase.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ProgressBarBase.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ProgressBarBase.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ProgressBarBase.prototype, "orientation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ProgressBarBase.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ProgressBarBase.prototype, "reverse", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ProgressBarBase.prototype, "indeterminate", void 0);

/**
 * Represents the [Kendo UI ProgressBar component for Angular]({% slug overview_progressbar %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-progressbar [value]="value">
 *        </kendo-progressbar>
 *    `
 * })
 * class AppComponent {
 *     public value = 50;
 * }
 * ```
 */
let ProgressBarComponent = class ProgressBarComponent extends ProgressBarBase {
    /**
     * @hidden
     */
    constructor(localization, zone, renderer) {
        super(localization);
        this.localization = localization;
        this.zone = zone;
        this.renderer = renderer;
        /**
         * Determines whether the status label will be visible.
         * Defaults to `true`&mdash;the label will be visible and displayed with the default
         * `LabelSettings` having its position set to `end` and its format set to `value`.
         */
        this.label = true;
        /**
         * The animation configuration of the ProgressBar.
         * Defaults to `false`.
         */
        this.animation = false;
        /**
         * Fires when the animation which indicates the latest value change is completed.
         */
        this.animationEnd = new EventEmitter();
    }
    /**
     * @hidden
     */
    get showLabel() {
        if (typeof this.label === 'boolean') {
            return this.label;
        }
        else {
            if (this.label && !this.label.hasOwnProperty('visible')) {
                this.label.visible = true;
            }
            return this.label.visible;
        }
    }
    /**
     * @hidden
     */
    get labelPosition() {
        if (typeof this.label === 'boolean') {
            return 'end';
        }
        else {
            if (this.label && !this.label.hasOwnProperty('position')) {
                this.label.position = 'end';
            }
            return this.label.position;
        }
    }
    /**
     * @hidden
     */
    get isPositionStart() {
        return this.labelPosition === 'start';
    }
    /**
     * @hidden
     */
    get isPositionCenter() {
        return this.labelPosition === 'center';
    }
    /**
     * @hidden
     */
    get isPositionEnd() {
        return this.labelPosition === 'end';
    }
    /**
     * @hidden
     */
    get formattedLabelValue() {
        return formatValue(this.displayValue, this.min, this.max, this.label);
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (this.isAnimationInProgress && stopCurrentAnimation(changes)) {
            this.cancelCurrentAnimation = true;
        }
        if (runAnimation(changes, this.animation, this.previousValue, this.displayValue) && !changes.value.firstChange) {
            this.startAnimation(this.previousValue);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
        }
    }
    /**
     * @hidden
     */
    startAnimation(previousValue) {
        this.isAnimationInProgress = true;
        const element = this.progressStatusElement.nativeElement;
        const wrapperElement = this.progressStatusWrapperElement.nativeElement;
        const animationOptions = this.getAnimationOptions(previousValue);
        this.zone.runOutsideAngular(() => {
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
            }
            const animate = () => {
                const elapsed = new Date().getTime() - animationOptions.startTime;
                const position = Math.min(elapsed / animationOptions.duration, 1);
                const size = animationOptions.startSize + animationOptions.deltaSize * position;
                const wrapperSize = (100 / size) * 100;
                this.renderValueChange(element, wrapperElement, animationOptions.property, size, wrapperSize);
                if (position < 1) {
                    if (this.cancelCurrentAnimation) {
                        this.resetProgress(element, wrapperElement, animationOptions.property);
                        return;
                    }
                    this.animationFrame = requestAnimationFrame(animate);
                }
                else {
                    this.stopAnimation(previousValue);
                }
            };
            animate();
        });
    }
    /**
     * @hidden
     */
    get animationDuration() {
        if (typeof this.animation === 'boolean') {
            return 400;
        }
        else {
            if (this.animation && !this.animation.hasOwnProperty('duration')) {
                this.animation.duration = 400;
            }
            return this.animation.duration;
        }
    }
    stopAnimation(value) {
        if (hasObservers(this.animationEnd)) {
            this.zone.run(() => {
                this.animationEnd.emit({
                    from: value,
                    to: this.displayValue
                });
            });
        }
        this.zone.run(() => {
            this.isAnimationInProgress = false;
        });
    }
    getAnimationOptions(value) {
        const isHorizontal = this.orientation === 'horizontal';
        const previousRatio = calculateRatio(this.min, this.max, value);
        const previousStatusWidth = isHorizontal ? previousRatio * 100 : 100;
        const previousStatusHeight = !isHorizontal ? previousRatio * 100 : 100;
        const property = isHorizontal ? 'width' : 'height';
        const startTime = new Date().getTime();
        const startSize = isHorizontal ? previousStatusWidth : previousStatusHeight;
        const deltaSize = isHorizontal ? this.statusWidth - previousStatusWidth : this.statusHeight - previousStatusHeight;
        const duration = this.animationDuration * Math.abs((deltaSize / 100));
        return {
            property,
            startTime,
            startSize,
            deltaSize,
            duration
        };
    }
    renderValueChange(element, wrapperElement, property, size, wrapperSize) {
        this.renderer.setStyle(element, property, size + '%');
        this.renderer.setStyle(wrapperElement, property, wrapperSize + '%');
    }
    resetProgress(element, wrapperElement, property) {
        const size = calculateRatio(this.min, this.max, this.value);
        const newSize = size * 100;
        const newWrapperSize = 100 / size;
        this.renderValueChange(element, wrapperElement, property, newSize, newWrapperSize);
        this.zone.run(() => {
            this.cancelCurrentAnimation = false;
            this.isAnimationInProgress = false;
        });
    }
};
ProgressBarComponent.ɵfac = function ProgressBarComponent_Factory(t) { return new (t || ProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ProgressBarComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ProgressBarComponent, selectors: [["kendo-progressbar"]], viewQuery: function ProgressBarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 5);
        ɵngcc0.ɵɵviewQuery(_c1, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.progressStatusElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.progressStatusWrapperElement = _t.first);
    } }, inputs: { label: "label", animation: "animation", progressCssStyle: "progressCssStyle", progressCssClass: "progressCssClass", emptyCssStyle: "emptyCssStyle", emptyCssClass: "emptyCssClass" }, outputs: { animationEnd: "animationEnd" }, exportAs: ["kendoProgressBar"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.progressbar'
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 7, vars: 28, consts: [[1, "k-progress-status-wrap", 3, "ngStyle", "ngClass"], ["class", "k-progress-status", 4, "ngIf"], [1, "k-state-selected", 3, "ngStyle", "ngClass"], ["progressStatus", ""], [1, "k-progress-status-wrap"], ["progressStatusWrap", ""], [1, "k-progress-status"]], template: function ProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtemplate(1, ProgressBarComponent_span_1_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3)(4, "span", 4, 5);
        ɵngcc0.ɵɵtemplate(6, ProgressBarComponent_span_6_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵelementEnd()();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-progress-start", ctx.isPositionStart)("k-progress-center", ctx.isPositionCenter)("k-progress-end", ctx.isPositionEnd);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.emptyCssStyle)("ngClass", ctx.emptyCssClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.statusWidth, "%")("height", ctx.statusHeight, "%");
        ɵngcc0.ɵɵclassProp("k-complete", ctx.isCompleted);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.progressCssStyle)("ngClass", ctx.progressCssClass);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.statusWrapperWidth, "%")("height", ctx.statusWrapperHeight, "%");
        ɵngcc0.ɵɵclassProp("k-progress-start", ctx.isPositionStart)("k-progress-center", ctx.isPositionCenter)("k-progress-end", ctx.isPositionEnd);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc2.NgStyle, ɵngcc2.NgClass, ɵngcc2.NgIf], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], ProgressBarComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ProgressBarComponent.prototype, "progressCssStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ProgressBarComponent.prototype, "progressCssClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ProgressBarComponent.prototype, "emptyCssStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ProgressBarComponent.prototype, "emptyCssClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ProgressBarComponent.prototype, "animation", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ProgressBarComponent.prototype, "animationEnd", void 0);
__decorate([
    ViewChild('progressStatus', { static: false }),
    __metadata("design:type", ElementRef)
], ProgressBarComponent.prototype, "progressStatusElement", void 0);
__decorate([
    ViewChild('progressStatusWrap', { static: false }),
    __metadata("design:type", ElementRef)
], ProgressBarComponent.prototype, "progressStatusWrapperElement", void 0);
ProgressBarComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService,
        NgZone,
        Renderer2])
], ProgressBarComponent);

/**
 * Represents the [Kendo UI ChunkProgressBar component for Angular]({% slug overview_chunkprogressbar %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-chunkprogressbar [value]="value">
 *        </kendo-chunkprogressbar>
 *    `
 * })
 * class AppComponent {
 *     public value = 40;
 * }
 * ```
 */
let ChunkProgressBarComponent = class ChunkProgressBarComponent extends ProgressBarBase {
    /**
     * @hidden
     */
    constructor(localization) {
        super(localization);
        this.localization = localization;
        /**
         * Sets the number of chunks into which the ChunkProgressBar will be split.
         * Defaults to `5`.
         */
        this.chunkCount = 5;
        this._orientationStyles = {
            width: `${this.chunkSizePercentage}%`
        };
    }
    /**
     * @hidden
     */
    get chunks() {
        const count = this.chunkCount;
        const chunks = Array(count).fill(false);
        const completedChunks = Math.floor(this._progressRatio * count);
        for (let i = 0; i < completedChunks; i++) {
            chunks[i] = true;
        }
        if (reverseChunks(this.orientation, this.reverse)) {
            chunks.reverse();
        }
        return chunks;
    }
    /**
     * @hidden
     */
    get chunkSizePercentage() {
        return 100 / this.chunkCount;
    }
    /**
     * @hidden
     */
    get orientationStyles() {
        if (this.orientation === 'horizontal') {
            this._orientationStyles.width = `${this.chunkSizePercentage}%`;
            this._orientationStyles.height = undefined;
        }
        else {
            this._orientationStyles.height = `${this.chunkSizePercentage}%`;
            this._orientationStyles.width = undefined;
        }
        return this._orientationStyles;
    }
};
ChunkProgressBarComponent.ɵfac = function ChunkProgressBarComponent_Factory(t) { return new (t || ChunkProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
ChunkProgressBarComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ChunkProgressBarComponent, selectors: [["kendo-chunkprogressbar"]], inputs: { chunkCount: "chunkCount", progressCssStyle: "progressCssStyle", progressCssClass: "progressCssClass", emptyCssStyle: "emptyCssStyle", emptyCssClass: "emptyCssClass" }, exportAs: ["kendoChunkProgressBar"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.chunkprogressbar'
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 1, consts: [[1, "k-reset"], ["class", "k-item", 3, "k-first", "k-last", "k-state-selected", "ngClass", "ngStyle", "width", "height", 4, "ngFor", "ngForOf"], [1, "k-item", 3, "ngClass", "ngStyle"]], template: function ChunkProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, ChunkProgressBarComponent_li_1_Template, 1, 12, "li", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.chunks);
    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgClass, ɵngcc2.NgStyle], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], ChunkProgressBarComponent.prototype, "chunkCount", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChunkProgressBarComponent.prototype, "progressCssStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChunkProgressBarComponent.prototype, "progressCssClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChunkProgressBarComponent.prototype, "emptyCssStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChunkProgressBarComponent.prototype, "emptyCssClass", void 0);
ChunkProgressBarComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService])
], ChunkProgressBarComponent);

const COMPONENT_DIRECTIVES = [ProgressBarComponent, ChunkProgressBarComponent];
const MODULES = [CommonModule];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmodules'] }})
 * definition for the ProgressBar components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the ProgressBar module
 * import { ProgressBarModule } from '@progress/kendo-angular-progressbar';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, ProgressBarModule], // import ProgressBar module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let ProgressBarModule = class ProgressBarModule {
};
ProgressBarModule.ɵfac = function ProgressBarModule_Factory(t) { return new (t || ProgressBarModule)(); };
ProgressBarModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ProgressBarModule });
ProgressBarModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [MODULES] });

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ProgressBarComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoProgressBar',
                selector: 'kendo-progressbar',
                template: `
        <span class="k-progress-status-wrap"
            [class.k-progress-start]="isPositionStart"
            [class.k-progress-center]="isPositionCenter"
            [class.k-progress-end]="isPositionEnd"
            [ngStyle]="emptyCssStyle"
            [ngClass]="emptyCssClass">
            <span *ngIf="showLabel" class="k-progress-status">{{formattedLabelValue}}</span>
        </span>
        <div
            #progressStatus
            class="k-state-selected"
            [class.k-complete]="isCompleted"
            [ngStyle]="progressCssStyle"
            [ngClass]="progressCssClass"
            [style.width.%]="statusWidth"
            [style.height.%]="statusHeight"
            >
            <span
                #progressStatusWrap
                class="k-progress-status-wrap"
                [style.width.%]="statusWrapperWidth"
                [style.height.%]="statusWrapperHeight"
                [class.k-progress-start]="isPositionStart"
                [class.k-progress-center]="isPositionCenter"
                [class.k-progress-end]="isPositionEnd"
                >
                <span *ngIf="showLabel" class="k-progress-status">{{formattedLabelValue}}</span>
            </span>
        </div>
       `,
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.progressbar'
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { label: [{
            type: Input
        }], animation: [{
            type: Input
        }], animationEnd: [{
            type: Output
        }], progressCssStyle: [{
            type: Input
        }], progressCssClass: [{
            type: Input
        }], emptyCssStyle: [{
            type: Input
        }], emptyCssClass: [{
            type: Input
        }], progressStatusElement: [{
            type: ViewChild,
            args: ['progressStatus', { static: false }]
        }], progressStatusWrapperElement: [{
            type: ViewChild,
            args: ['progressStatusWrap', { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChunkProgressBarComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoChunkProgressBar',
                selector: 'kendo-chunkprogressbar',
                template: `
        <ul class="k-reset">
            <li class="k-item" *ngFor="let chunk of chunks; let i = index;"
                [class.k-first]="i === 0"
                [class.k-last]="i === chunkCount - 1"
                [class.k-state-selected]="chunk"
                [ngClass]="chunk ? progressCssClass : emptyCssClass"
                [ngStyle]="chunk ? progressCssStyle : emptyCssStyle"
                [style.width]="orientationStyles.width"
                [style.height]="orientationStyles.height"
                >
            </li>
        </ul>
    `,
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.chunkprogressbar'
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { chunkCount: [{
            type: Input
        }], progressCssStyle: [{
            type: Input
        }], progressCssClass: [{
            type: Input
        }], emptyCssStyle: [{
            type: Input
        }], emptyCssClass: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ProgressBarModule, [{
        type: NgModule,
        args: [{
                declarations: COMPONENT_DIRECTIVES,
                exports: COMPONENT_DIRECTIVES,
                imports: MODULES
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ProgressBarModule, { declarations: [ProgressBarComponent, ChunkProgressBarComponent], imports: [CommonModule], exports: [ProgressBarComponent, ChunkProgressBarComponent] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ProgressBarBase, ProgressBarComponent, ChunkProgressBarComponent, ProgressBarModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OE1BQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dGQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBMkNHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OzsyRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0EwQkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K1FBT3NCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIxIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBpc0Rldk1vZGUsIEhvc3RCaW5kaW5nLCBJbnB1dCwgRXZlbnRFbWl0dGVyLCBPdXRwdXQsIFZpZXdDaGlsZCwgRWxlbWVudFJlZiwgQ29tcG9uZW50LCBOZ1pvbmUsIFJlbmRlcmVyMiwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHZhbGlkYXRlUGFja2FnZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1saWNlbnNpbmcnO1xuaW1wb3J0IHsgTG9jYWxpemF0aW9uU2VydmljZSwgTDEwTl9QUkVGSVggfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IGhhc09ic2VydmVycyB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcGFja2FnZU1ldGFkYXRhID0ge1xuICAgIG5hbWU6ICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1wcm9ncmVzc2JhcicsXG4gICAgcHJvZHVjdE5hbWU6ICdLZW5kbyBVSSBmb3IgQW5ndWxhcicsXG4gICAgcHJvZHVjdENvZGVzOiBbJ0tFTkRPVUlBTkdVTEFSJywgJ0tFTkRPVUlDT01QTEVURSddLFxuICAgIHB1Ymxpc2hEYXRlOiAxNjQ2MjE5MzcxLFxuICAgIHZlcnNpb246ICcnLFxuICAgIGxpY2Vuc2luZ0RvY3NVcmw6ICdodHRwczovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL215LWxpY2Vuc2UvP3V0bV9tZWRpdW09cHJvZHVjdCZ1dG1fc291cmNlPWtlbmRvYW5ndWxhciZ1dG1fY2FtcGFpZ249a2VuZG8tdWktYW5ndWxhci1wdXJjaGFzZS1saWNlbnNlLWtleXMtd2FybmluZydcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBNSU5fTUFYX0VSUk9SX01FU1NBR0UgPSBgVGhlIG1heCB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHRoZSBtaW4uYDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBMQUJFTF9ERUNJTUFMUyA9IDM7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgTUlOX1JBVElPID0gMC4wMDAxO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcmV2ZXJzZUNodW5rcyA9IChvcmllbnRhdGlvbiwgcmV2ZXJzZSkgPT4gKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmICFyZXZlcnNlIHx8IG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgcmV2ZXJzZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZm9ybWF0VmFsdWUgPSAodmFsdWUsIG1pbiwgbWF4LCBsYWJlbCkgPT4ge1xuICAgIGNvbnN0IGRlZmF1bHRGb3JtYXR0ZWRWYWx1ZSA9IHRydW5jYXRlTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbC5mb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxhYmVsLmZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICBjYXNlICdwZXJjZW50JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke01hdGguZmxvb3IoY2FsY3VsYXRlUGVyY2VudGFnZSh2YWx1ZSwgbWluLCBtYXgpKX0lYDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsYWJlbC5mb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbC5mb3JtYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlZFZhbHVlO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB2YWxpZGF0ZVJhbmdlID0gKG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKGlzRGV2TW9kZSAmJiBtaW4gPiBtYXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1JTl9NQVhfRVJST1JfTUVTU0FHRSk7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBhZGp1c3RWYWx1ZVRvUmFuZ2UgPSAobWluLCBtYXgsIHZhbHVlKSA9PiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjYWxjdWxhdGVQZXJjZW50YWdlID0gKHZhbHVlLCBtaW4sIG1heCkgPT4ge1xuICAgIGNvbnN0IG9uZVBlcmNlbnQgPSBNYXRoLmFicygobWF4IC0gbWluKSAvIDEwMCk7XG4gICAgcmV0dXJuIE1hdGguYWJzKCh2YWx1ZSAtIG1pbikgLyBvbmVQZXJjZW50KTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdHJ1bmNhdGVOdW1iZXIgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBudW1iZXJQYXJ0cyA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gbnVtYmVyUGFydHMubGVuZ3RoID09PSAxID8gYCR7bnVtYmVyUGFydHNbMF19YCA6IGAke251bWJlclBhcnRzWzBdfS4ke251bWJlclBhcnRzWzFdLnN1YnN0cigwLCBMQUJFTF9ERUNJTUFMUyl9YDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY2FsY3VsYXRlUmF0aW8gPSAobWluLCBtYXgsIHZhbHVlKSA9PiBNYXRoLm1heCgodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbiksIE1JTl9SQVRJTyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZXh0cmFjdFZhbHVlRnJvbUNoYW5nZXMgPSAoY2hhbmdlcywgdHlwZSwgdmFsdWUpID0+IGNoYW5nZXNbdHlwZV0gJiYgY2hhbmdlc1t0eXBlXS5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCA/IGNoYW5nZXNbdHlwZV0uY3VycmVudFZhbHVlIDogdmFsdWU7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcnVuQW5pbWF0aW9uID0gKGNoYW5nZXMsIGFuaW1hdGlvbiwgcHJldmlvdXNWYWx1ZSwgZGlzcGxheVZhbHVlKSA9PiBhbmltYXRpb24gJiYgdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY2hhbmdlcy52YWx1ZSAmJiBwcmV2aW91c1ZhbHVlICE9PSBkaXNwbGF5VmFsdWU7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc3RvcEN1cnJlbnRBbmltYXRpb24gPSAoY2hhbmdlcykgPT4ge1xuICAgIGNvbnN0IGlzQW5pbWF0aW9uQ2hhbmdlZCA9IEJvb2xlYW4oY2hhbmdlcy5hbmltYXRpb24pO1xuICAgIGNvbnN0IGhhc0FuaW1hdGlvbiA9IGlzQW5pbWF0aW9uQ2hhbmdlZCAmJiBjaGFuZ2VzLmFuaW1hdGlvbi5jdXJyZW50VmFsdWU7XG4gICAgcmV0dXJuIGlzQW5pbWF0aW9uQ2hhbmdlZCAmJiAhaGFzQW5pbWF0aW9uO1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFByb2dyZXNzQmFyQmFzZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy53aWRnZXRDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb2xlQXR0cmlidXRlID0gJ3Byb2dyZXNzYmFyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBQcm9ncmVzc0Jhci5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gYDEwMGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heCA9IDEwMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHZhbHVlIG9mIHRoZSBQcm9ncmVzc0Jhci5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gYDBgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW4gPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIHRoZSBQcm9ncmVzc0Jhci5cbiAgICAgICAgICogSGFzIHRvIGJlIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdmFsdWUgaXMgZXF1YWwgdG8gdGhlIGBtaW5gIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgUHJvZ3Jlc3NCYXIuXG4gICAgICAgICAqIEhhcyB0byBiZSBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YC5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gYDBgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgUHJvZ3Jlc3NCYXJcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwcm9ncmVzc2Jhcl9vcmllbnRhdGlvbiAlfSkpLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgaG9yaXpvbnRhbGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIFByb2dyZXNzQmFyIHdpbGwgYmUgZGlzYWJsZWRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwcm9ncmVzc2Jhcl9kaXNhYmxlZCAlfSkpLlxuICAgICAgICAgKiBJdCB3aWxsIHN0aWxsIGFsbG93IHlvdSB0byBjaGFuZ2UgaXRzIHZhbHVlLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIFByb2dyZXNzQmFyIHdpbGwgYmUgcmV2ZXJzZWRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwcm9ncmVzc2Jhcl9kaXJlY3Rpb24gJX0pKS5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgYGluZGV0ZXJtaW5hdGVgIHN0YXRlIG9mIHRoZSBQcm9ncmVzc0Jhci5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IDA7XG4gICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IDA7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbiA9IGxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGlzSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJztcbiAgICB9XG4gICAgZ2V0IGlzVmVydGljYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIGdldCByZXZlcnNlQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2U7XG4gICAgfVxuICAgIGdldCBpbmRldGVybWluYXRlQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGU7XG4gICAgfVxuICAgIGdldCBkaXJBdHRyaWJ1dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbjtcbiAgICB9XG4gICAgZ2V0IGFyaWFNaW5BdHRyaWJ1dGUoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5taW4pO1xuICAgIH1cbiAgICBnZXQgYXJpYU1heEF0dHJpYnV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLm1heCk7XG4gICAgfVxuICAgIGdldCBhcmlhVmFsdWVBdHRyaWJ1dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGUgPyB1bmRlZmluZWQgOiBTdHJpbmcodGhpcy5kaXNwbGF5VmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzQ29tcGxldGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gdGhpcy5tYXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgPyB0aGlzLl9wcm9ncmVzc1JhdGlvICogMTAwIDogMTAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyB0aGlzLl9wcm9ncmVzc1JhdGlvICogMTAwIDogMTAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c1dyYXBwZXJXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IDEwMCAvIHRoaXMuX3Byb2dyZXNzUmF0aW8gOiAxMDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzV3JhcHBlckhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyAxMDAgLyB0aGlzLl9wcm9ncmVzc1JhdGlvIDogMTAwO1xuICAgIH1cbiAgICBnZXQgX3Byb2dyZXNzUmF0aW8oKSB7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVSYXRpbyh0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuZGlzcGxheVZhbHVlKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBjb25zdCBtaW4gPSBleHRyYWN0VmFsdWVGcm9tQ2hhbmdlcyhjaGFuZ2VzLCAnbWluJywgdGhpcy5taW4pO1xuICAgICAgICBjb25zdCBtYXggPSBleHRyYWN0VmFsdWVGcm9tQ2hhbmdlcyhjaGFuZ2VzLCAnbWF4JywgdGhpcy5tYXgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGV4dHJhY3RWYWx1ZUZyb21DaGFuZ2VzKGNoYW5nZXMsICd2YWx1ZScsIHRoaXMudmFsdWUpO1xuICAgICAgICBpZiAoY2hhbmdlcy5taW4gfHwgY2hhbmdlcy5tYXggfHwgY2hhbmdlcy52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMubWluIHx8IGNoYW5nZXMubWF4KSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVSYW5nZShtaW4sIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gYWRqdXN0VmFsdWVUb1JhbmdlKHRoaXMubWluLCB0aGlzLm1heCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSBhZGp1c3RWYWx1ZVRvUmFuZ2UodGhpcy5taW4sIHRoaXMubWF4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXdpZGdldCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXByb2dyZXNzYmFyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBQcm9ncmVzc0JhckJhc2UucHJvdG90eXBlLCBcIndpZGdldENsYXNzZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLXByb2dyZXNzYmFyLWhvcml6b250YWwnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgUHJvZ3Jlc3NCYXJCYXNlLnByb3RvdHlwZSwgXCJpc0hvcml6b250YWxcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1wcm9ncmVzc2Jhci12ZXJ0aWNhbCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQcm9ncmVzc0JhckJhc2UucHJvdG90eXBlLCBcImlzVmVydGljYWxcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQcm9ncmVzc0JhckJhc2UucHJvdG90eXBlLCBcImRpc2FibGVkQ2xhc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1wcm9ncmVzc2Jhci1yZXZlcnNlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFByb2dyZXNzQmFyQmFzZS5wcm90b3R5cGUsIFwicmV2ZXJzZUNsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstcHJvZ3Jlc3NiYXItaW5kZXRlcm1pbmF0ZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQcm9ncmVzc0JhckJhc2UucHJvdG90eXBlLCBcImluZGV0ZXJtaW5hdGVDbGFzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmRpcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFByb2dyZXNzQmFyQmFzZS5wcm90b3R5cGUsIFwiZGlyQXR0cmlidXRlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQcm9ncmVzc0JhckJhc2UucHJvdG90eXBlLCBcInJvbGVBdHRyaWJ1dGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVtaW4nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBQcm9ncmVzc0JhckJhc2UucHJvdG90eXBlLCBcImFyaWFNaW5BdHRyaWJ1dGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5hcmlhLXZhbHVlbWF4JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgUHJvZ3Jlc3NCYXJCYXNlLnByb3RvdHlwZSwgXCJhcmlhTWF4QXR0cmlidXRlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW5vdycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIFByb2dyZXNzQmFyQmFzZS5wcm90b3R5cGUsIFwiYXJpYVZhbHVlQXR0cmlidXRlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUHJvZ3Jlc3NCYXJCYXNlLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFByb2dyZXNzQmFyQmFzZS5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBQcm9ncmVzc0JhckJhc2UucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQcm9ncmVzc0JhckJhc2UucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUHJvZ3Jlc3NCYXJCYXNlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFByb2dyZXNzQmFyQmFzZS5wcm90b3R5cGUsIFwicmV2ZXJzZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFByb2dyZXNzQmFyQmFzZS5wcm90b3R5cGUsIFwiaW5kZXRlcm1pbmF0ZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBQcm9ncmVzc0JhciBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfcHJvZ3Jlc3NiYXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1wcm9ncmVzc2JhciBbdmFsdWVdPVwidmFsdWVcIj5cbiAqICAgICAgICA8L2tlbmRvLXByb2dyZXNzYmFyPlxuICogICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgcHVibGljIHZhbHVlID0gNTA7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IFByb2dyZXNzQmFyQ29tcG9uZW50ID0gY2xhc3MgUHJvZ3Jlc3NCYXJDb21wb25lbnQgZXh0ZW5kcyBQcm9ncmVzc0JhckJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIHpvbmUsIHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKGxvY2FsaXphdGlvbik7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHN0YXR1cyBsYWJlbCB3aWxsIGJlIHZpc2libGUuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGB0cnVlYCZtZGFzaDt0aGUgbGFiZWwgd2lsbCBiZSB2aXNpYmxlIGFuZCBkaXNwbGF5ZWQgd2l0aCB0aGUgZGVmYXVsdFxuICAgICAgICAgKiBgTGFiZWxTZXR0aW5nc2AgaGF2aW5nIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGVuZGAgYW5kIGl0cyBmb3JtYXQgc2V0IHRvIGB2YWx1ZWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhYmVsID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbmltYXRpb24gY29uZmlndXJhdGlvbiBvZiB0aGUgUHJvZ3Jlc3NCYXIuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYW5pbWF0aW9uIHdoaWNoIGluZGljYXRlcyB0aGUgbGF0ZXN0IHZhbHVlIGNoYW5nZSBpcyBjb21wbGV0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBzaG93TGFiZWwoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sYWJlbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhYmVsICYmICF0aGlzLmxhYmVsLmhhc093blByb3BlcnR5KCd2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWwudmlzaWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGxhYmVsUG9zaXRpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sYWJlbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbCAmJiAhdGhpcy5sYWJlbC5oYXNPd25Qcm9wZXJ0eSgncG9zaXRpb24nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwucG9zaXRpb24gPSAnZW5kJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaXNQb3NpdGlvblN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09PSAnc3RhcnQnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzUG9zaXRpb25DZW50ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsUG9zaXRpb24gPT09ICdjZW50ZXInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzUG9zaXRpb25FbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsUG9zaXRpb24gPT09ICdlbmQnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGZvcm1hdHRlZExhYmVsVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZSh0aGlzLmRpc3BsYXlWYWx1ZSwgdGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLmxhYmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLmlzQW5pbWF0aW9uSW5Qcm9ncmVzcyAmJiBzdG9wQ3VycmVudEFuaW1hdGlvbihjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxDdXJyZW50QW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuQW5pbWF0aW9uKGNoYW5nZXMsIHRoaXMuYW5pbWF0aW9uLCB0aGlzLnByZXZpb3VzVmFsdWUsIHRoaXMuZGlzcGxheVZhbHVlKSAmJiAhY2hhbmdlcy52YWx1ZS5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbih0aGlzLnByZXZpb3VzVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzdGFydEFuaW1hdGlvbihwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpb25JblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucHJvZ3Jlc3NTdGF0dXNFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHdyYXBwZXJFbGVtZW50ID0gdGhpcy5wcm9ncmVzc1N0YXR1c1dyYXBwZXJFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSB0aGlzLmdldEFuaW1hdGlvbk9wdGlvbnMocHJldmlvdXNWYWx1ZSk7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBhbmltYXRpb25PcHRpb25zLnN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IE1hdGgubWluKGVsYXBzZWQgLyBhbmltYXRpb25PcHRpb25zLmR1cmF0aW9uLCAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gYW5pbWF0aW9uT3B0aW9ucy5zdGFydFNpemUgKyBhbmltYXRpb25PcHRpb25zLmRlbHRhU2l6ZSAqIHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXJTaXplID0gKDEwMCAvIHNpemUpICogMTAwO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVmFsdWVDaGFuZ2UoZWxlbWVudCwgd3JhcHBlckVsZW1lbnQsIGFuaW1hdGlvbk9wdGlvbnMucHJvcGVydHksIHNpemUsIHdyYXBwZXJTaXplKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbEN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRQcm9ncmVzcyhlbGVtZW50LCB3cmFwcGVyRWxlbWVudCwgYW5pbWF0aW9uT3B0aW9ucy5wcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbihwcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBhbmltYXRpb25EdXJhdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmFuaW1hdGlvbiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gNDAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uICYmICF0aGlzLmFuaW1hdGlvbi5oYXNPd25Qcm9wZXJ0eSgnZHVyYXRpb24nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmR1cmF0aW9uID0gNDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3BBbmltYXRpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLmFuaW1hdGlvbkVuZCkpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRW5kLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMuZGlzcGxheVZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBbmltYXRpb25PcHRpb25zKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgY29uc3QgcHJldmlvdXNSYXRpbyA9IGNhbGN1bGF0ZVJhdGlvKHRoaXMubWluLCB0aGlzLm1heCwgdmFsdWUpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1N0YXR1c1dpZHRoID0gaXNIb3Jpem9udGFsID8gcHJldmlvdXNSYXRpbyAqIDEwMCA6IDEwMDtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTdGF0dXNIZWlnaHQgPSAhaXNIb3Jpem9udGFsID8gcHJldmlvdXNSYXRpbyAqIDEwMCA6IDEwMDtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBpc0hvcml6b250YWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBzdGFydFNpemUgPSBpc0hvcml6b250YWwgPyBwcmV2aW91c1N0YXR1c1dpZHRoIDogcHJldmlvdXNTdGF0dXNIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGRlbHRhU2l6ZSA9IGlzSG9yaXpvbnRhbCA/IHRoaXMuc3RhdHVzV2lkdGggLSBwcmV2aW91c1N0YXR1c1dpZHRoIDogdGhpcy5zdGF0dXNIZWlnaHQgLSBwcmV2aW91c1N0YXR1c0hlaWdodDtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uICogTWF0aC5hYnMoKGRlbHRhU2l6ZSAvIDEwMCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICBzdGFydFNpemUsXG4gICAgICAgICAgICBkZWx0YVNpemUsXG4gICAgICAgICAgICBkdXJhdGlvblxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXJWYWx1ZUNoYW5nZShlbGVtZW50LCB3cmFwcGVyRWxlbWVudCwgcHJvcGVydHksIHNpemUsIHdyYXBwZXJTaXplKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHksIHNpemUgKyAnJScpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHdyYXBwZXJFbGVtZW50LCBwcm9wZXJ0eSwgd3JhcHBlclNpemUgKyAnJScpO1xuICAgIH1cbiAgICByZXNldFByb2dyZXNzKGVsZW1lbnQsIHdyYXBwZXJFbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgICAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlUmF0aW8odGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLnZhbHVlKTtcbiAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHNpemUgKiAxMDA7XG4gICAgICAgIGNvbnN0IG5ld1dyYXBwZXJTaXplID0gMTAwIC8gc2l6ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJWYWx1ZUNoYW5nZShlbGVtZW50LCB3cmFwcGVyRWxlbWVudCwgcHJvcGVydHksIG5ld1NpemUsIG5ld1dyYXBwZXJTaXplKTtcbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEN1cnJlbnRBbmltYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQcm9ncmVzc0JhckNvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFByb2dyZXNzQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcm9ncmVzc0Nzc1N0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQcm9ncmVzc0JhckNvbXBvbmVudC5wcm90b3R5cGUsIFwicHJvZ3Jlc3NDc3NDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImVtcHR5Q3NzU3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFByb2dyZXNzQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlbXB0eUNzc0NsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQcm9ncmVzc0JhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbkVuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdwcm9ncmVzc1N0YXR1cycsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIFByb2dyZXNzQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcm9ncmVzc1N0YXR1c0VsZW1lbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgncHJvZ3Jlc3NTdGF0dXNXcmFwJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInByb2dyZXNzU3RhdHVzV3JhcHBlckVsZW1lbnRcIiwgdm9pZCAwKTtcblByb2dyZXNzQmFyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1Byb2dyZXNzQmFyJyxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1wcm9ncmVzc2JhcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiay1wcm9ncmVzcy1zdGF0dXMtd3JhcFwiXG4gICAgICAgICAgICBbY2xhc3Muay1wcm9ncmVzcy1zdGFydF09XCJpc1Bvc2l0aW9uU3RhcnRcIlxuICAgICAgICAgICAgW2NsYXNzLmstcHJvZ3Jlc3MtY2VudGVyXT1cImlzUG9zaXRpb25DZW50ZXJcIlxuICAgICAgICAgICAgW2NsYXNzLmstcHJvZ3Jlc3MtZW5kXT1cImlzUG9zaXRpb25FbmRcIlxuICAgICAgICAgICAgW25nU3R5bGVdPVwiZW1wdHlDc3NTdHlsZVwiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJlbXB0eUNzc0NsYXNzXCI+XG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cInNob3dMYWJlbFwiIGNsYXNzPVwiay1wcm9ncmVzcy1zdGF0dXNcIj57e2Zvcm1hdHRlZExhYmVsVmFsdWV9fTwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICAjcHJvZ3Jlc3NTdGF0dXNcbiAgICAgICAgICAgIGNsYXNzPVwiay1zdGF0ZS1zZWxlY3RlZFwiXG4gICAgICAgICAgICBbY2xhc3Muay1jb21wbGV0ZV09XCJpc0NvbXBsZXRlZFwiXG4gICAgICAgICAgICBbbmdTdHlsZV09XCJwcm9ncmVzc0Nzc1N0eWxlXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInByb2dyZXNzQ3NzQ2xhc3NcIlxuICAgICAgICAgICAgW3N0eWxlLndpZHRoLiVdPVwic3RhdHVzV2lkdGhcIlxuICAgICAgICAgICAgW3N0eWxlLmhlaWdodC4lXT1cInN0YXR1c0hlaWdodFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICNwcm9ncmVzc1N0YXR1c1dyYXBcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstcHJvZ3Jlc3Mtc3RhdHVzLXdyYXBcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS53aWR0aC4lXT1cInN0YXR1c1dyYXBwZXJXaWR0aFwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC4lXT1cInN0YXR1c1dyYXBwZXJIZWlnaHRcIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLXByb2dyZXNzLXN0YXJ0XT1cImlzUG9zaXRpb25TdGFydFwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstcHJvZ3Jlc3MtY2VudGVyXT1cImlzUG9zaXRpb25DZW50ZXJcIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLXByb2dyZXNzLWVuZF09XCJpc1Bvc2l0aW9uRW5kXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJzaG93TGFiZWxcIiBjbGFzcz1cImstcHJvZ3Jlc3Mtc3RhdHVzXCI+e3tmb3JtYXR0ZWRMYWJlbFZhbHVlfX08L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgIGAsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLnByb2dyZXNzYmFyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBQcm9ncmVzc0JhckNvbXBvbmVudCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIENodW5rUHJvZ3Jlc3NCYXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2NodW5rcHJvZ3Jlc3NiYXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1jaHVua3Byb2dyZXNzYmFyIFt2YWx1ZV09XCJ2YWx1ZVwiPlxuICogICAgICAgIDwva2VuZG8tY2h1bmtwcm9ncmVzc2Jhcj5cbiAqICAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgIHB1YmxpYyB2YWx1ZSA9IDQwO1xuICogfVxuICogYGBgXG4gKi9cbmxldCBDaHVua1Byb2dyZXNzQmFyQ29tcG9uZW50ID0gY2xhc3MgQ2h1bmtQcm9ncmVzc0JhckNvbXBvbmVudCBleHRlbmRzIFByb2dyZXNzQmFyQmFzZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikge1xuICAgICAgICBzdXBlcihsb2NhbGl6YXRpb24pO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBjaHVua3MgaW50byB3aGljaCB0aGUgQ2h1bmtQcm9ncmVzc0JhciB3aWxsIGJlIHNwbGl0LlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgNWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNodW5rQ291bnQgPSA1O1xuICAgICAgICB0aGlzLl9vcmllbnRhdGlvblN0eWxlcyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBgJHt0aGlzLmNodW5rU2l6ZVBlcmNlbnRhZ2V9JWBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBjaHVua3MoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5jaHVua0NvdW50O1xuICAgICAgICBjb25zdCBjaHVua3MgPSBBcnJheShjb3VudCkuZmlsbChmYWxzZSk7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRlZENodW5rcyA9IE1hdGguZmxvb3IodGhpcy5fcHJvZ3Jlc3NSYXRpbyAqIGNvdW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wbGV0ZWRDaHVua3M7IGkrKykge1xuICAgICAgICAgICAgY2h1bmtzW2ldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV2ZXJzZUNodW5rcyh0aGlzLm9yaWVudGF0aW9uLCB0aGlzLnJldmVyc2UpKSB7XG4gICAgICAgICAgICBjaHVua3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY2h1bmtTaXplUGVyY2VudGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIDEwMCAvIHRoaXMuY2h1bmtDb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBvcmllbnRhdGlvblN0eWxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25TdHlsZXMud2lkdGggPSBgJHt0aGlzLmNodW5rU2l6ZVBlcmNlbnRhZ2V9JWA7XG4gICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblN0eWxlcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblN0eWxlcy5oZWlnaHQgPSBgJHt0aGlzLmNodW5rU2l6ZVBlcmNlbnRhZ2V9JWA7XG4gICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblN0eWxlcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25TdHlsZXM7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNodW5rQ291bnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInByb2dyZXNzQ3NzU3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInByb2dyZXNzQ3NzQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImVtcHR5Q3NzU3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImVtcHR5Q3NzQ2xhc3NcIiwgdm9pZCAwKTtcbkNodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvQ2h1bmtQcm9ncmVzc0JhcicsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2h1bmtwcm9ncmVzc2JhcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDx1bCBjbGFzcz1cImstcmVzZXRcIj5cbiAgICAgICAgICAgIDxsaSBjbGFzcz1cImstaXRlbVwiICpuZ0Zvcj1cImxldCBjaHVuayBvZiBjaHVua3M7IGxldCBpID0gaW5kZXg7XCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1maXJzdF09XCJpID09PSAwXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1sYXN0XT1cImkgPT09IGNodW5rQ291bnQgLSAxXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGF0ZS1zZWxlY3RlZF09XCJjaHVua1wiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiY2h1bmsgPyBwcm9ncmVzc0Nzc0NsYXNzIDogZW1wdHlDc3NDbGFzc1wiXG4gICAgICAgICAgICAgICAgW25nU3R5bGVdPVwiY2h1bmsgPyBwcm9ncmVzc0Nzc1N0eWxlIDogZW1wdHlDc3NTdHlsZVwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLndpZHRoXT1cIm9yaWVudGF0aW9uU3R5bGVzLndpZHRoXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0XT1cIm9yaWVudGF0aW9uU3R5bGVzLmhlaWdodFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC91bD5cbiAgICBgLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5jaHVua3Byb2dyZXNzYmFyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhbGl6YXRpb25TZXJ2aWNlXSlcbl0sIENodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQpO1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyA9IFtQcm9ncmVzc0JhckNvbXBvbmVudCwgQ2h1bmtQcm9ncmVzc0JhckNvbXBvbmVudF07XG5jb25zdCBNT0RVTEVTID0gW0NvbW1vbk1vZHVsZV07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVzJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgUHJvZ3Jlc3NCYXIgY29tcG9uZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBQcm9ncmVzc0JhciBtb2R1bGVcbiAqIGltcG9ydCB7IFByb2dyZXNzQmFyTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcHJvZ3Jlc3NiYXInO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBQcm9ncmVzc0Jhck1vZHVsZV0sIC8vIGltcG9ydCBQcm9ncmVzc0JhciBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBQcm9ncmVzc0Jhck1vZHVsZSA9IGNsYXNzIFByb2dyZXNzQmFyTW9kdWxlIHtcbn07XG5Qcm9ncmVzc0Jhck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBDT01QT05FTlRfRElSRUNUSVZFUyxcbiAgICAgICAgZXhwb3J0czogQ09NUE9ORU5UX0RJUkVDVElWRVMsXG4gICAgICAgIGltcG9ydHM6IE1PRFVMRVNcbiAgICB9KVxuXSwgUHJvZ3Jlc3NCYXJNb2R1bGUpO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IFByb2dyZXNzQmFyQmFzZSwgUHJvZ3Jlc3NCYXJDb21wb25lbnQsIENodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQsIFByb2dyZXNzQmFyTW9kdWxlIH07XG4iXX0=