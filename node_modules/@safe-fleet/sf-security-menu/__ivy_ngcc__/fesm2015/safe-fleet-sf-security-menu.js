import * as i0 from '@angular/core';
import { Injectable, Component, HostListener, NgModule } from '@angular/core';
import { BehaviorSubject, of } from 'rxjs';
import * as i1$1 from '@safe-fleet/sf-menu';
import { MenuConfig, MenuItem, MenuEventType, SfMenuService, SfMenuModule } from '@safe-fleet/sf-menu';
import { MenuEvent } from '@progress/kendo-angular-menu';
import * as i1 from '@angular/common/http';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { map, catchError, mergeMap, debounceTime } from 'rxjs/operators';
import { PopupModule } from '@progress/kendo-angular-popup';
import { CommonModule } from '@angular/common';
import { ButtonsModule } from '@progress/kendo-angular-buttons';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
import * as ɵngcc2 from '@safe-fleet/sf-menu';
import * as ɵngcc3 from '@angular/common';
import * as ɵngcc4 from '@progress/kendo-angular-popup';
import * as ɵngcc5 from '@progress/kendo-angular-buttons';

function SfSecurityMenuComponent_kendo_popup_2_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-popup", 1)(1, "div", 2)(2, "div", 3);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "div", 4);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "div")(7, "button", 5);
    ɵngcc0.ɵɵlistener("click", function SfSecurityMenuComponent_kendo_popup_2_Template_button_click_7_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.closeShowOrganizationMsgPopup(); });
    ɵngcc0.ɵɵtext(8);
    ɵngcc0.ɵɵelementEnd()()()();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("popupAlign", ctx_r0.popupAlign)("offset", ctx_r0.offsetPopup);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.unauthorizedPopup.popupMessageText);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.unauthorizedPopup.popupMessageActionText);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("primary", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.unauthorizedPopup.popupButtonText, " ");
} }
const _c0 = ["*"];
class IMenuConfig extends MenuConfig {
    constructor() {
        super();
    }
}
class IUnauthorizedPopup {
}
class IMenuItem extends MenuItem {
    constructor() {
        super();
    }
}
class IEvent extends MenuEvent {
    constructor() {
        super();
    }
}
const EventTypeEnum = Object.assign({}, MenuEventType);

class SecurityService {
    constructor(httpClient) {
        this.httpClient = httpClient;
    }
    setSecurityInformation(securityEndpoint, settingsEndpoint, headers) {
        this.securityHeaders = headers;
        this.securityEndpoint = securityEndpoint;
        this.settingsEndpoint = settingsEndpoint;
    }
    getApplications() {
        const url = `${this.securityEndpoint}/applications`;
        return this.httpClient.get(url, {
            headers: this.securityHeaders,
        });
    }
    getPermissions() {
        return this.permissions;
    }
    getInfo() {
        return this.applicationInfo;
    }
    getSecurityPermissions(resourceName) {
        const url = `${this.securityEndpoint}/permissions?resourceName=${resourceName}`;
        return this.httpClient
            .get(url, {
            headers: this.securityHeaders,
        })
            .pipe(map((x) => (this.permissions = x)), catchError((error) => {
            throw error;
        }));
    }
    getApplicationInfo() {
        const url = `${this.settingsEndpoint}/info`;
        return this.httpClient
            .get(url, {
            headers: this.securityHeaders,
        })
            .pipe(map((x) => (this.applicationInfo = x)), catchError((error) => {
            throw error;
        }));
    }
}
SecurityService.ɵfac = function SecurityService_Factory(t) { return new (t || SecurityService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient)); };
SecurityService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SecurityService_Factory() { return new SecurityService(i0.ɵɵinject(i1.HttpClient)); }, token: SecurityService, providedIn: "root" });
SecurityService.ctorParameters = () => [
    { type: HttpClient }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SecurityService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }]; }, null); })();

class SfSecurityMenuService {
    constructor(sfMenuService, securityService) {
        this.sfMenuService = sfMenuService;
        this.securityService = securityService;
        this.infoMessageVisibilityChange = new BehaviorSubject(false);
        this.events$ = this.sfMenuService.events$;
    }
    configureMenu(config, securityInfo) {
        this.securityService.setSecurityInformation(securityInfo.securityEndpoint, securityInfo.settingsEndpoint, securityInfo.headers);
        this.refreshMenu(config);
        this.onMenuChanges();
        this.infoMessageVisibilityChange.next(false);
        this.unauthorizedPopup = this.getUnauthorizedPopup(config.unauthorizedPopup);
        const permissionsObservable = this.securityService.getSecurityPermissions(config.currentProduct.id).pipe(catchError((error) => {
            if (error.status === 403 && config.multipleTenants && config.unauthorizedPopup) {
                this.infoMessageVisibilityChange.next(true);
            }
            throw error;
        }));
        const applicationsObservable = this.securityService.getApplications().pipe(map((applications) => this.mapConfiguration(config, applications, securityInfo)), catchError((error) => {
            this.refreshMenu(config);
            throw error;
        }));
        const applicationInfoObservable = this.securityService.getApplicationInfo();
        return applicationsObservable.pipe(mergeMap(() => permissionsObservable), mergeMap(() => applicationInfoObservable), catchError(() => of('')));
    }
    refreshMenu(config) {
        this.sfMenuService.setMenuConfig(config);
    }
    getPermissions() {
        return this.securityService.getPermissions();
    }
    getSettingsInfo() {
        return this.securityService.getInfo();
    }
    mapConfiguration(config, applications, securityInfo) {
        config.products = [];
        const menuItems = [];
        applications.forEach((app) => {
            menuItems.push(this.mapMenuApplication(app));
        });
        const selectedProduct = menuItems.find((app) => app.text === securityInfo.selectedApplication);
        if (!selectedProduct || selectedProduct === null) {
            config.products = menuItems;
            this.refreshMenu(config);
            return;
        }
        config.currentProduct = selectedProduct;
        config.products = menuItems.filter((item) => item.id !== config.currentProduct.id);
        this.refreshMenu(config);
    }
    mapMenuApplication(app) {
        return {
            text: app.applicationName,
            routeHref: app.applicationUrl,
            iconPath: app.applicationIconUrl,
            id: app.applicationName,
            newWindow: false,
            active: false,
            expanded: false,
            newTab: false,
        };
    }
    getUnauthorizedPopup(popupConfig) {
        return {
            popupButtonText: popupConfig ? popupConfig.popupButtonText : '',
            popupMessageActionText: popupConfig ? popupConfig.popupMessageActionText : '',
            popupMessageText: popupConfig ? popupConfig.popupMessageText : '',
        };
    }
    reloadPermissions(applicationName) {
        return this.securityService.getSecurityPermissions(applicationName);
    }
    onMenuChanges() {
        return this.sfMenuService.events$.subscribe((menuEvent) => {
            if (menuEvent.type === EventTypeEnum.OpenTenantListClick) {
                this.infoMessageVisibilityChange.next(false);
            }
        });
    }
}
SfSecurityMenuService.ɵfac = function SfSecurityMenuService_Factory(t) { return new (t || SfSecurityMenuService)(ɵngcc0.ɵɵinject(ɵngcc2.SfMenuService), ɵngcc0.ɵɵinject(SecurityService)); };
SfSecurityMenuService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SfSecurityMenuService_Factory() { return new SfSecurityMenuService(i0.ɵɵinject(i1$1.SfMenuService), i0.ɵɵinject(SecurityService)); }, token: SfSecurityMenuService, providedIn: "root" });
SfSecurityMenuService.ctorParameters = () => [
    { type: SfMenuService },
    { type: SecurityService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SfSecurityMenuService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc2.SfMenuService }, { type: SecurityService }]; }, null); })();

class SfSecurityMenuComponent {
    constructor(sfSecMenuService, sfMenuService) {
        this.sfSecMenuService = sfSecMenuService;
        this.sfMenuService = sfMenuService;
        this.highlightClass = 'highlight-org-menu';
        this.paddingWidth = 10;
        this.popupAlign = { horizontal: 'left', vertical: 'center' };
        this.delayTime = 300;
        this.offsetPopup = { left: -1000, top: 0 };
        this.showOrganizationMsgPopup = false;
    }
    ngOnInit() {
        this.sfSecMenuService.infoMessageVisibilityChange.subscribe((showInfoMessage) => {
            if (showInfoMessage) {
                this.unauthorizedPopup = this.sfSecMenuService.unauthorizedPopup;
                this.onMenuCollapseOrExpand();
            }
            else {
                this.closeShowOrganizationMsgPopup();
            }
        });
    }
    onMenuCollapseOrExpand() {
        this.showOrganizationMsgPopup = true;
        this.sfMenuService.menuCollapse$.pipe(debounceTime(this.delayTime)).subscribe(() => {
            this.getOrganizationPosition();
        });
    }
    onResize() {
        this.getOrganizationPosition();
    }
    getOrganizationPosition() {
        if (this.showOrganizationMsgPopup) {
            const elem = document.querySelector('.sf-fleet-list');
            this.organizationItemMenu = elem && elem.parentElement ? elem.parentElement : null;
            if (this.organizationItemMenu) {
                const bounding = this.organizationItemMenu.getBoundingClientRect();
                const top = bounding.top + bounding.height / 2;
                const left = bounding.left + bounding.width + this.paddingWidth;
                this.offsetPopup = { left, top };
                this.organizationItemMenu.classList.add(this.highlightClass);
            }
            else {
                this.showOrganizationMsgPopup = false;
            }
        }
    }
    closeShowOrganizationMsgPopup() {
        this.showOrganizationMsgPopup = false;
        if (this.organizationItemMenu) {
            this.organizationItemMenu.classList.remove(this.highlightClass);
        }
    }
}
SfSecurityMenuComponent.ɵfac = function SfSecurityMenuComponent_Factory(t) { return new (t || SfSecurityMenuComponent)(ɵngcc0.ɵɵdirectiveInject(SfSecurityMenuService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.SfMenuService)); };
SfSecurityMenuComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SfSecurityMenuComponent, selectors: [["sf-security-menu"]], hostBindings: function SfSecurityMenuComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("resize", function SfSecurityMenuComponent_resize_HostBindingHandler($event) { return ctx.onResize($event); }, false, ɵngcc0.ɵɵresolveWindow);
    } }, ngContentSelectors: _c0, decls: 3, vars: 1, consts: [[3, "popupAlign", "offset", 4, "ngIf"], [3, "popupAlign", "offset"], [1, "content-popup"], [1, "message"], [1, "message", "action-bold"], ["type", "button", "kendoButton", "", 1, "primary-size", 3, "primary", "click"]], template: function SfSecurityMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "sf-menu");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, SfSecurityMenuComponent_kendo_popup_2_Template, 9, 6, "kendo-popup", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.unauthorizedPopup && ctx.showOrganizationMsgPopup);
    } }, directives: [ɵngcc2.SfMenuComponent, ɵngcc3.NgIf, ɵngcc4.PopupComponent, ɵngcc5.ButtonDirective], styles: ["[_nghost-%COMP%]{width:100%;height:100%}[_nghost-%COMP%]     .highlight-org-menu{background-color:#00000080}[_nghost-%COMP%]     .k-popup{border-radius:5px}[_nghost-%COMP%]     .k-popup .content-popup{width:210px;padding:25px 15px;text-align:center;background-color:var(--clr-gray-500);color:#fff;border-radius:5px}[_nghost-%COMP%]     .k-popup .content-popup .message{margin:10px}[_nghost-%COMP%]     .k-popup .content-popup .action-bold{font-weight:600}[_nghost-%COMP%]     .k-popup .content-popup:before{content:\"\";position:absolute;top:75px;left:-38px;border-left:10px solid transparent;border-right:10px solid var(--clr-gray-500);border-bottom:10px solid transparent;border-top:10px solid transparent;width:20px}"] });
SfSecurityMenuComponent.ctorParameters = () => [
    { type: SfSecurityMenuService },
    { type: SfMenuService }
];
SfSecurityMenuComponent.propDecorators = {
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SfSecurityMenuComponent, [{
        type: Component,
        args: [{
                selector: 'sf-security-menu',
                template: "<sf-menu>\n  <ng-content></ng-content>\n</sf-menu>\n\n<kendo-popup [popupAlign]=\"popupAlign\" *ngIf=\"unauthorizedPopup && showOrganizationMsgPopup\" [offset]=\"offsetPopup\">\n  <div class=\"content-popup\">\n    <div class=\"message\">{{unauthorizedPopup.popupMessageText}}</div>\n    <div class=\"message action-bold\">{{unauthorizedPopup.popupMessageActionText}}</div>\n    <div>\n      <button type=\"button\" class=\"primary-size\" [primary]=\"true\" kendoButton (click)=\"closeShowOrganizationMsgPopup()\">\n        {{unauthorizedPopup.popupButtonText}}\n      </button>\n    </div>\n  </div>\n</kendo-popup>\n",
                styles: [":host{width:100%;height:100%}:host ::ng-deep .highlight-org-menu{background-color:#00000080}:host ::ng-deep .k-popup{border-radius:5px}:host ::ng-deep .k-popup .content-popup{width:210px;padding:25px 15px;text-align:center;background-color:var(--clr-gray-500);color:#fff;border-radius:5px}:host ::ng-deep .k-popup .content-popup .message{margin:10px}:host ::ng-deep .k-popup .content-popup .action-bold{font-weight:600}:host ::ng-deep .k-popup .content-popup:before{content:\"\";position:absolute;top:75px;left:-38px;border-left:10px solid transparent;border-right:10px solid var(--clr-gray-500);border-bottom:10px solid transparent;border-top:10px solid transparent;width:20px}\n"]
            }]
    }], function () { return [{ type: SfSecurityMenuService }, { type: ɵngcc2.SfMenuService }]; }, { onResize: [{
            type: HostListener,
            args: ['window:resize', ['$event']]
        }] }); })();

class SfSecurityMenuModule {
}
SfSecurityMenuModule.ɵfac = function SfSecurityMenuModule_Factory(t) { return new (t || SfSecurityMenuModule)(); };
SfSecurityMenuModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: SfSecurityMenuModule });
SfSecurityMenuModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, SfMenuModule, HttpClientModule, PopupModule, ButtonsModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SfSecurityMenuModule, [{
        type: NgModule,
        args: [{
                declarations: [SfSecurityMenuComponent],
                imports: [CommonModule, SfMenuModule, HttpClientModule, PopupModule, ButtonsModule],
                exports: [SfSecurityMenuComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SfSecurityMenuModule, { declarations: function () { return [SfSecurityMenuComponent]; }, imports: function () { return [CommonModule, SfMenuModule, HttpClientModule, PopupModule, ButtonsModule]; }, exports: function () { return [SfSecurityMenuComponent]; } }); })();

/*
 * Public API Surface of sf-security-menu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { EventTypeEnum, IEvent, IMenuConfig, IMenuItem, IUnauthorizedPopup, SfSecurityMenuComponent, SfSecurityMenuModule, SfSecurityMenuService, SecurityService as ɵa };

//# sourceMappingURL=safe-fleet-sf-security-menu.js.map