import * as i0 from '@angular/core';
import { Injectable, Component, HostListener, NgModule } from '@angular/core';
import { BehaviorSubject, of } from 'rxjs';
import * as i1$1 from '@safe-fleet/sf-menu';
import { MenuConfig, MenuItem, MenuEventType, SfMenuService, SfMenuModule } from '@safe-fleet/sf-menu';
import { MenuEvent } from '@progress/kendo-angular-menu';
import * as i1 from '@angular/common/http';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { map, catchError, mergeMap, debounceTime } from 'rxjs/operators';
import { PopupModule } from '@progress/kendo-angular-popup';
import { CommonModule } from '@angular/common';
import { ButtonsModule } from '@progress/kendo-angular-buttons';

class IMenuConfig extends MenuConfig {
    constructor() {
        super();
    }
}
class IUnauthorizedPopup {
}
class IMenuItem extends MenuItem {
    constructor() {
        super();
    }
}
class IEvent extends MenuEvent {
    constructor() {
        super();
    }
}
const EventTypeEnum = Object.assign({}, MenuEventType);

class SecurityService {
    constructor(httpClient) {
        this.httpClient = httpClient;
    }
    setSecurityInformation(securityEndpoint, settingsEndpoint, headers) {
        this.securityHeaders = headers;
        this.securityEndpoint = securityEndpoint;
        this.settingsEndpoint = settingsEndpoint;
    }
    getApplications() {
        const url = `${this.securityEndpoint}/applications`;
        return this.httpClient.get(url, {
            headers: this.securityHeaders,
        });
    }
    getPermissions() {
        return this.permissions;
    }
    getInfo() {
        return this.applicationInfo;
    }
    getSecurityPermissions(resourceName) {
        const url = `${this.securityEndpoint}/permissions?resourceName=${resourceName}`;
        return this.httpClient
            .get(url, {
            headers: this.securityHeaders,
        })
            .pipe(map((x) => (this.permissions = x)), catchError((error) => {
            throw error;
        }));
    }
    getApplicationInfo() {
        const url = `${this.settingsEndpoint}/info`;
        return this.httpClient
            .get(url, {
            headers: this.securityHeaders,
        })
            .pipe(map((x) => (this.applicationInfo = x)), catchError((error) => {
            throw error;
        }));
    }
}
SecurityService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SecurityService_Factory() { return new SecurityService(i0.ɵɵinject(i1.HttpClient)); }, token: SecurityService, providedIn: "root" });
SecurityService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
SecurityService.ctorParameters = () => [
    { type: HttpClient }
];

class SfSecurityMenuService {
    constructor(sfMenuService, securityService) {
        this.sfMenuService = sfMenuService;
        this.securityService = securityService;
        this.infoMessageVisibilityChange = new BehaviorSubject(false);
        this.events$ = this.sfMenuService.events$;
    }
    configureMenu(config, securityInfo) {
        this.securityService.setSecurityInformation(securityInfo.securityEndpoint, securityInfo.settingsEndpoint, securityInfo.headers);
        this.refreshMenu(config);
        this.onMenuChanges();
        this.infoMessageVisibilityChange.next(false);
        this.unauthorizedPopup = this.getUnauthorizedPopup(config.unauthorizedPopup);
        const permissionsObservable = this.securityService.getSecurityPermissions(config.currentProduct.id).pipe(catchError((error) => {
            if (error.status === 403 && config.multipleTenants && config.unauthorizedPopup) {
                this.infoMessageVisibilityChange.next(true);
            }
            throw error;
        }));
        const applicationsObservable = this.securityService.getApplications().pipe(map((applications) => this.mapConfiguration(config, applications, securityInfo)), catchError((error) => {
            this.refreshMenu(config);
            throw error;
        }));
        const applicationInfoObservable = this.securityService.getApplicationInfo();
        return applicationsObservable.pipe(mergeMap(() => permissionsObservable), mergeMap(() => applicationInfoObservable), catchError(() => of('')));
    }
    refreshMenu(config) {
        this.sfMenuService.setMenuConfig(config);
    }
    getPermissions() {
        return this.securityService.getPermissions();
    }
    getSettingsInfo() {
        return this.securityService.getInfo();
    }
    mapConfiguration(config, applications, securityInfo) {
        config.products = [];
        const menuItems = [];
        applications.forEach((app) => {
            menuItems.push(this.mapMenuApplication(app));
        });
        const selectedProduct = menuItems.find((app) => app.text === securityInfo.selectedApplication);
        if (!selectedProduct || selectedProduct === null) {
            config.products = menuItems;
            this.refreshMenu(config);
            return;
        }
        config.currentProduct = selectedProduct;
        config.products = menuItems.filter((item) => item.id !== config.currentProduct.id);
        this.refreshMenu(config);
    }
    mapMenuApplication(app) {
        return {
            text: app.applicationName,
            routeHref: app.applicationUrl,
            iconPath: app.applicationIconUrl,
            id: app.applicationName,
            newWindow: false,
            active: false,
            expanded: false,
            newTab: false,
        };
    }
    getUnauthorizedPopup(popupConfig) {
        return {
            popupButtonText: popupConfig ? popupConfig.popupButtonText : '',
            popupMessageActionText: popupConfig ? popupConfig.popupMessageActionText : '',
            popupMessageText: popupConfig ? popupConfig.popupMessageText : '',
        };
    }
    reloadPermissions(applicationName) {
        return this.securityService.getSecurityPermissions(applicationName);
    }
    onMenuChanges() {
        return this.sfMenuService.events$.subscribe((menuEvent) => {
            if (menuEvent.type === EventTypeEnum.OpenTenantListClick) {
                this.infoMessageVisibilityChange.next(false);
            }
        });
    }
}
SfSecurityMenuService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SfSecurityMenuService_Factory() { return new SfSecurityMenuService(i0.ɵɵinject(i1$1.SfMenuService), i0.ɵɵinject(SecurityService)); }, token: SfSecurityMenuService, providedIn: "root" });
SfSecurityMenuService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
SfSecurityMenuService.ctorParameters = () => [
    { type: SfMenuService },
    { type: SecurityService }
];

class SfSecurityMenuComponent {
    constructor(sfSecMenuService, sfMenuService) {
        this.sfSecMenuService = sfSecMenuService;
        this.sfMenuService = sfMenuService;
        this.highlightClass = 'highlight-org-menu';
        this.paddingWidth = 10;
        this.popupAlign = { horizontal: 'left', vertical: 'center' };
        this.delayTime = 300;
        this.offsetPopup = { left: -1000, top: 0 };
        this.showOrganizationMsgPopup = false;
    }
    ngOnInit() {
        this.sfSecMenuService.infoMessageVisibilityChange.subscribe((showInfoMessage) => {
            if (showInfoMessage) {
                this.unauthorizedPopup = this.sfSecMenuService.unauthorizedPopup;
                this.onMenuCollapseOrExpand();
            }
            else {
                this.closeShowOrganizationMsgPopup();
            }
        });
    }
    onMenuCollapseOrExpand() {
        this.showOrganizationMsgPopup = true;
        this.sfMenuService.menuCollapse$.pipe(debounceTime(this.delayTime)).subscribe(() => {
            this.getOrganizationPosition();
        });
    }
    onResize() {
        this.getOrganizationPosition();
    }
    getOrganizationPosition() {
        if (this.showOrganizationMsgPopup) {
            const elem = document.querySelector('.sf-fleet-list');
            this.organizationItemMenu = elem && elem.parentElement ? elem.parentElement : null;
            if (this.organizationItemMenu) {
                const bounding = this.organizationItemMenu.getBoundingClientRect();
                const top = bounding.top + bounding.height / 2;
                const left = bounding.left + bounding.width + this.paddingWidth;
                this.offsetPopup = { left, top };
                this.organizationItemMenu.classList.add(this.highlightClass);
            }
            else {
                this.showOrganizationMsgPopup = false;
            }
        }
    }
    closeShowOrganizationMsgPopup() {
        this.showOrganizationMsgPopup = false;
        if (this.organizationItemMenu) {
            this.organizationItemMenu.classList.remove(this.highlightClass);
        }
    }
}
SfSecurityMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'sf-security-menu',
                template: "<sf-menu>\n  <ng-content></ng-content>\n</sf-menu>\n\n<kendo-popup [popupAlign]=\"popupAlign\" *ngIf=\"unauthorizedPopup && showOrganizationMsgPopup\" [offset]=\"offsetPopup\">\n  <div class=\"content-popup\">\n    <div class=\"message\">{{unauthorizedPopup.popupMessageText}}</div>\n    <div class=\"message action-bold\">{{unauthorizedPopup.popupMessageActionText}}</div>\n    <div>\n      <button type=\"button\" class=\"primary-size\" [primary]=\"true\" kendoButton (click)=\"closeShowOrganizationMsgPopup()\">\n        {{unauthorizedPopup.popupButtonText}}\n      </button>\n    </div>\n  </div>\n</kendo-popup>\n",
                styles: [":host{width:100%;height:100%}:host ::ng-deep .highlight-org-menu{background-color:#00000080}:host ::ng-deep .k-popup{border-radius:5px}:host ::ng-deep .k-popup .content-popup{width:210px;padding:25px 15px;text-align:center;background-color:var(--clr-gray-500);color:#fff;border-radius:5px}:host ::ng-deep .k-popup .content-popup .message{margin:10px}:host ::ng-deep .k-popup .content-popup .action-bold{font-weight:600}:host ::ng-deep .k-popup .content-popup:before{content:\"\";position:absolute;top:75px;left:-38px;border-left:10px solid transparent;border-right:10px solid var(--clr-gray-500);border-bottom:10px solid transparent;border-top:10px solid transparent;width:20px}\n"]
            },] }
];
SfSecurityMenuComponent.ctorParameters = () => [
    { type: SfSecurityMenuService },
    { type: SfMenuService }
];
SfSecurityMenuComponent.propDecorators = {
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};

class SfSecurityMenuModule {
}
SfSecurityMenuModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SfSecurityMenuComponent],
                imports: [CommonModule, SfMenuModule, HttpClientModule, PopupModule, ButtonsModule],
                exports: [SfSecurityMenuComponent],
            },] }
];

/*
 * Public API Surface of sf-security-menu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { EventTypeEnum, IEvent, IMenuConfig, IMenuItem, IUnauthorizedPopup, SfSecurityMenuComponent, SfSecurityMenuModule, SfSecurityMenuService, SecurityService as ɵa };
//# sourceMappingURL=safe-fleet-sf-security-menu.js.map
