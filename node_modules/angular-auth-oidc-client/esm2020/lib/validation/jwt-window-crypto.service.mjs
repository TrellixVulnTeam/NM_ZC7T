import { Injectable } from '@angular/core';
import { from } from 'rxjs';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
export class JwtWindowCryptoService {
    constructor() {
        this.crypto = window.crypto || window.msCrypto; // for IE11
    }
    generateCodeChallenge(codeVerifier) {
        return this.calcHash(codeVerifier).pipe(map((challengeRaw) => base64UrlEncode(challengeRaw)));
    }
    generateAtHash(accessToken, algorithm) {
        return this.calcHash(accessToken, algorithm).pipe(map((tokenHash) => {
            let substr = tokenHash.substr(0, tokenHash.length / 2);
            const tokenHashBase64 = btoa(substr);
            return tokenHashBase64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }));
    }
    calcHash(valueToHash, algorithm = 'SHA-256') {
        const msgBuffer = new TextEncoder().encode(valueToHash);
        return from(this.crypto.subtle.digest(algorithm, msgBuffer)).pipe(map((hashBuffer) => {
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return this.toHashString(hashArray);
        }));
    }
    toHashString(byteArray) {
        let result = '';
        for (let e of byteArray) {
            result += String.fromCharCode(e);
        }
        return result;
    }
}
JwtWindowCryptoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: JwtWindowCryptoService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
JwtWindowCryptoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: JwtWindowCryptoService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: JwtWindowCryptoService, decorators: [{
            type: Injectable
        }] });
export function base64UrlEncode(str) {
    const base64 = btoa(str);
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiand0LXdpbmRvdy1jcnlwdG8uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItYXV0aC1vaWRjLWNsaWVudC9zcmMvbGliL3ZhbGlkYXRpb24vand0LXdpbmRvdy1jcnlwdG8uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxJQUFJLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDeEMsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOztBQUdyQyxNQUFNLE9BQU8sc0JBQXNCO0lBRG5DO1FBRVUsV0FBTSxHQUFXLE1BQU0sQ0FBQyxNQUFNLElBQUssTUFBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFdBQVc7S0FxQ2hGO0lBbkNDLHFCQUFxQixDQUFDLFlBQW9CO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsWUFBb0IsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4RyxDQUFDO0lBRUQsY0FBYyxDQUFDLFdBQW1CLEVBQUUsU0FBaUI7UUFDbkQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQy9DLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFO1lBQ2hCLElBQUksTUFBTSxHQUFXLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0QsTUFBTSxlQUFlLEdBQVcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTdDLE9BQU8sZUFBZSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ25GLENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0lBRU8sUUFBUSxDQUFDLFdBQW1CLEVBQUUsWUFBb0IsU0FBUztRQUNqRSxNQUFNLFNBQVMsR0FBZSxJQUFJLFdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUVwRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUMvRCxHQUFHLENBQUMsQ0FBQyxVQUF1QixFQUFFLEVBQUU7WUFDOUIsTUFBTSxTQUFTLEdBQWEsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBRW5FLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN0QyxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQztJQUVPLFlBQVksQ0FBQyxTQUFtQjtRQUN0QyxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDaEIsS0FBSyxJQUFJLENBQUMsSUFBSSxTQUFTLEVBQUU7WUFDdkIsTUFBTSxJQUFJLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDbEM7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOzttSEFyQ1Usc0JBQXNCO3VIQUF0QixzQkFBc0I7MkZBQXRCLHNCQUFzQjtrQkFEbEMsVUFBVTs7QUF5Q1gsTUFBTSxVQUFVLGVBQWUsQ0FBQyxHQUFHO0lBQ2pDLE1BQU0sTUFBTSxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVqQyxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMxRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbSwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSnd0V2luZG93Q3J5cHRvU2VydmljZSB7XG4gIHByaXZhdGUgY3J5cHRvOiBDcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8ICh3aW5kb3cgYXMgYW55KS5tc0NyeXB0bzsgLy8gZm9yIElFMTFcblxuICBnZW5lcmF0ZUNvZGVDaGFsbGVuZ2UoY29kZVZlcmlmaWVyOiBzdHJpbmcpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmNhbGNIYXNoKGNvZGVWZXJpZmllcikucGlwZShtYXAoKGNoYWxsZW5nZVJhdzogc3RyaW5nKSA9PiBiYXNlNjRVcmxFbmNvZGUoY2hhbGxlbmdlUmF3KSkpO1xuICB9XG5cbiAgZ2VuZXJhdGVBdEhhc2goYWNjZXNzVG9rZW46IHN0cmluZywgYWxnb3JpdGhtOiBzdHJpbmcpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmNhbGNIYXNoKGFjY2Vzc1Rva2VuLCBhbGdvcml0aG0pLnBpcGUoXG4gICAgICBtYXAoKHRva2VuSGFzaCkgPT4ge1xuICAgICAgICBsZXQgc3Vic3RyOiBzdHJpbmcgPSB0b2tlbkhhc2guc3Vic3RyKDAsIHRva2VuSGFzaC5sZW5ndGggLyAyKTtcbiAgICAgICAgY29uc3QgdG9rZW5IYXNoQmFzZTY0OiBzdHJpbmcgPSBidG9hKHN1YnN0cik7XG5cbiAgICAgICAgcmV0dXJuIHRva2VuSGFzaEJhc2U2NC5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89L2csICcnKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY0hhc2godmFsdWVUb0hhc2g6IHN0cmluZywgYWxnb3JpdGhtOiBzdHJpbmcgPSAnU0hBLTI1NicpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIGNvbnN0IG1zZ0J1ZmZlcjogVWludDhBcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZVRvSGFzaCk7XG5cbiAgICByZXR1cm4gZnJvbSh0aGlzLmNyeXB0by5zdWJ0bGUuZGlnZXN0KGFsZ29yaXRobSwgbXNnQnVmZmVyKSkucGlwZShcbiAgICAgIG1hcCgoaGFzaEJ1ZmZlcjogQXJyYXlCdWZmZXIpID0+IHtcbiAgICAgICAgY29uc3QgaGFzaEFycmF5OiBudW1iZXJbXSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlcikpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRvSGFzaFN0cmluZyhoYXNoQXJyYXkpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSB0b0hhc2hTdHJpbmcoYnl0ZUFycmF5OiBudW1iZXJbXSk6IHN0cmluZyB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGUgb2YgYnl0ZUFycmF5KSB7XG4gICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRVcmxFbmNvZGUoc3RyKTogc3RyaW5nIHtcbiAgY29uc3QgYmFzZTY0OiBzdHJpbmcgPSBidG9hKHN0cik7XG5cbiAgcmV0dXJuIGJhc2U2NC5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89L2csICcnKTtcbn1cbiJdfQ==